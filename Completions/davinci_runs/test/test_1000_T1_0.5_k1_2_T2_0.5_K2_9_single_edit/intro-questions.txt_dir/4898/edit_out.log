2022-04-16 13:29:28.945970 num operations 1
2022-04-16 13:29:28.946014 size on input set 1
2022-04-16 13:29:37.706209 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    print(minions)\n    minions.sort(key=lambda x: x[1])\n    print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    # print(minions)\n    minions.sort(key=lambda x: x[1])  # sort by end time\n    # print(minions)\n    ans = 0\n    cur = 0  # current end time\n    for m in minions:  # for each minion\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    # print(minions)\n    minions.sort(key=lambda x: x[1])\n    # print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    minions.sort(key=lambda x: x[1])\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n"
    },
    {
      "index": 4,
      "text": "\nif __name__ == '__main__':\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    # print(minions)\n    minions.sort(key=lambda x: x[1])\n    # print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    minions.sort(key=lambda x: x[1])\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    minions.sort(key=lambda x: x[1])\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n"
    },
    {
      "index": 7,
      "text": "\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    # print(minions)\n    minions.sort(key=lambda x: x[1])\n    # print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    minions.sort(key=lambda x: x[1])\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650115769,
  "object": "edit"
}
2022-04-16 13:29:37.706492 fix syntax errors 9 ['\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    print(minions)\n    minions.sort(key=lambda x: x[1])\n    print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n', '\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    # print(minions)\n    minions.sort(key=lambda x: x[1])  # sort by end time\n    # print(minions)\n    ans = 0\n    cur = 0  # current end time\n    for m in minions:  # for each minion\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n', '\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    # print(minions)\n    minions.sort(key=lambda x: x[1])\n    # print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n', '\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    minions.sort(key=lambda x: x[1])\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n', "\nif __name__ == '__main__':\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    # print(minions)\n    minions.sort(key=lambda x: x[1])\n    # print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n", '\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    minions.sort(key=lambda x: x[1])\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n', '\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    minions.sort(key=lambda x: x[1])\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nmain()\n', '\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    # print(minions)\n    minions.sort(key=lambda x: x[1])\n    # print(minions)\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n', "\n\ndef main():\n    N = int(input())\n    minions = []\n    for i in range(N):\n        minions.append([int(x) for x in input().split()])\n    minions.sort(key=lambda x: x[1])\n    ans = 0\n    cur = 0\n    for m in minions:\n        if m[0] > cur:\n            ans += 1\n            cur = m[1]\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 13:29:37.706549 size on output set 7
2022-04-16 13:29:37.706560 num operations 1
2022-04-16 13:29:37.706565 size on input set 1
2022-04-16 13:30:19.676246 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\nfrom collections import deque\nn = int(input())\nminions = deque()\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append([l, u])\n\nfor i in range(n):\n    m = minions.popleft()\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n"
    },
    {
      "index": 1,
      "text": "\n\n# Use a greedy algorithm. For each minion, find the lowest temperature that is available. If none is available, create a new room with that temperature\n\nn = int(input())\nminions = [] # List of tuples containing the lower and upper bounds of the minion\nrooms = [] # List of temperatures that have been assigned to rooms\n\n    # Read in the lower and upper bounds of the minion\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u)) # Add the minion to the list\n\n    # Get the minion\nfor i in range(n):\n    # Check if there is a room with a temperature within the minion's bounds\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        # If no room is available, create a new room with the lower bound of the minion\n        rooms.append(m[0])\n\n# Print the number of rooms created\nprint(len(rooms))\n"
    },
    {
      "index": 2,
      "text": "\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\nfor i in range(n):\n    l, u = map(int, raw_input().split())\n    minions.append((l,u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break;\n    if not available:\n        rooms.append(m[0]);\n\nprint(len(rooms))\n"
    },
    {
      "index": 3,
      "text": "\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n\nimport sys\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
      "index": 4,
      "text": "\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\nimport sys\nsys.stdin = open(\"file.txt\")\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n"
    },
    {
      "index": 5,
      "text": "\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n"
    },
    {
      "index": 6,
      "text": "\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n"
    },
    {
      "index": 7,
      "text": "\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\n\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n"
    },
    {
      "index": 8,
      "text": "\n\n# Use a greedy algorithm\n# For each minion, find the highest temperature that is available\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = True\n    for r in rooms:\n        if m[0] <= r:\n            available = False\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n"
    }
  ],
  "created": 1650115777,
  "object": "edit"
}
2022-04-16 13:30:19.676591 fix syntax errors 9 ['\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\nfrom collections import deque\nn = int(input())\nminions = deque()\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append([l, u])\n\nfor i in range(n):\n    m = minions.popleft()\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n', "\n\n# Use a greedy algorithm. For each minion, find the lowest temperature that is available. If none is available, create a new room with that temperature\n\nn = int(input())\nminions = [] # List of tuples containing the lower and upper bounds of the minion\nrooms = [] # List of temperatures that have been assigned to rooms\n\n    # Read in the lower and upper bounds of the minion\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u)) # Add the minion to the list\n\n    # Get the minion\nfor i in range(n):\n    # Check if there is a room with a temperature within the minion's bounds\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        # If no room is available, create a new room with the lower bound of the minion\n        rooms.append(m[0])\n\n# Print the number of rooms created\nprint(len(rooms))\n", '\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\nfor i in range(n):\n    l, u = map(int, raw_input().split())\n    minions.append((l,u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break;\n    if not available:\n        rooms.append(m[0]);\n\nprint(len(rooms))\n', '\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n\nimport sys\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\nimport sys\nsys.stdin = open("file.txt")\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n', '\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n', '\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n', '\n\n# Use a greedy algorithm\n# For each minion, find the lowest temperature that is available\n# If none is available, create a new room with that temperature\n\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = False\n    for r in rooms:\n        if m[0] <= r <= m[1]:\n            available = True\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n', '\n\n# Use a greedy algorithm\n# For each minion, find the highest temperature that is available\n# If none is available, create a new room with that temperature\n\nn = int(input())\nminions = []\nrooms = []\n\nfor i in range(n):\n    l, u = map(int, input().split())\n    minions.append((l, u))\n\nfor i in range(n):\n    m = minions[i]\n    available = True\n    for r in rooms:\n        if m[0] <= r:\n            available = False\n            break\n    if not available:\n        rooms.append(m[0])\n\nprint(len(rooms))\n']
2022-04-16 13:30:19.676666 size on output set 8
2022-04-16 13:30:19.676678 num operations 1
2022-04-16 13:30:19.676683 size on input set 1
2022-04-16 13:30:28.539673 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference's upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for lower, upper in preferences[1:]:\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room\n        if lower > rooms[-1]:\n            rooms.append(upper)\n    # return the number of rooms\n    return len(rooms)\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference's upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference's upper bound\n\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference.\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference's upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room.\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms.\n    return len(rooms)\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference's lower bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\ndef main():\n    # get the number of minions\n    n = int(input())\n    # get the preferences of each minion\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    # get the minimum number of rooms needed\n    print(get_min_rooms(preferences))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by their upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the temperature of the first room to the first preference's upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference's lower bound is greater than the temperature of the current room,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])  # sort the preferences by the upper bound\n    # set the first room to the first preference's upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\ndef get_min_rooms(preferences):\n    \"\"\"\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    \"\"\"\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference's upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference's lower bound is greater than the current room's temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650115819,
  "object": "edit"
}
2022-04-16 13:30:28.540055 fix syntax errors 9 ['\n\ndef get_min_rooms(preferences):\n    """\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    """\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference\'s upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for lower, upper in preferences[1:]:\n        # if the preference\'s lower bound is greater than the current room\'s temperature,\n        # then place this minion in a new room\n        if lower > rooms[-1]:\n            rooms.append(upper)\n    # return the number of rooms\n    return len(rooms)\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef get_min_rooms(preferences):\n    """\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    """\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference\'s upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference\'s lower bound is greater than the current room\'s temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef get_min_rooms(preferences):\n    """\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    """\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference\'s upper bound\n\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference\'s lower bound is greater than the current room\'s temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef get_min_rooms(preferences):\n    """\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference.\n    :return: minimum number of rooms required to make all the minions happy\n    """\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference\'s upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference\'s lower bound is greater than the current room\'s temperature,\n        # then place this minion in a new room.\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms.\n    return len(rooms)\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef get_min_rooms(preferences):\n    """\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    """\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference\'s lower bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference\'s lower bound is greater than the current room\'s temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\ndef main():\n    # get the number of minions\n    n = int(input())\n    # get the preferences of each minion\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    # get the minimum number of rooms needed\n    print(get_min_rooms(preferences))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef get_min_rooms(preferences):\n    """\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    """\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef get_min_rooms(preferences):\n    """\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    """\n    # sort the preferences by their upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the temperature of the first room to the first preference\'s upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference\'s lower bound is greater than the temperature of the current room,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef get_min_rooms(preferences):\n    """\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    """\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])  # sort the preferences by the upper bound\n    # set the first room to the first preference\'s upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference\'s lower bound is greater than the current room\'s temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\n\nif __name__ == "__main__":\n    main()\n', '\ndef get_min_rooms(preferences):\n    """\n    :param preferences: list of tuples, each tuple containing a lower and upper bound of temperature preference\n    :return: minimum number of rooms required to make all the minions happy\n    """\n    # sort the preferences by the upper bound\n    preferences.sort(key=lambda x: x[1])\n    # set the first room to the first preference\'s upper bound\n    rooms = [preferences[0][1]]\n    # for each preference\n    for preference in preferences[1:]:\n        # if the preference\'s lower bound is greater than the current room\'s temperature,\n        # then place this minion in a new room\n        if preference[0] > rooms[-1]:\n            rooms.append(preference[1])\n    # return the number of rooms\n    return len(rooms)\n\n\ndef main():\n    n = int(input())\n    preferences = []\n    for _ in range(n):\n        preferences.append(list(map(int, input().split())))\n    print(get_min_rooms(preferences))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 13:30:28.540162 size on output set 9
2022-04-16 13:30:28.540174 num operations 1
2022-04-16 13:30:28.540179 size on input set 1
2022-04-16 13:30:36.404692 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"
    },
    {
      "index": 6,
      "text": "import sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"
    },
    {
      "index": 7,
      "text": "import sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"
    }
  ],
  "created": 1650115828,
  "object": "edit"
}
2022-04-16 13:30:36.404951 fix syntax errors 9 ["\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "import sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "import sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n", "\nimport sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split(' ')]\n\ndef solve(n, preferences):\n    # sort by lower bound\n    preferences.sort(key=lambda pref: pref[0])\n\n    # greedy\n    rooms = 0\n    for pref in preferences:\n        if rooms == 0 or pref[0] > rooms:\n            rooms = pref[1]\n\n    return rooms\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    preferences = [read_ints() for _ in range(n)]\n    print(solve(n, preferences))\n"]
2022-04-16 13:30:36.405108 size on output set 2
2022-04-16 13:30:36.405123 num operations 1
2022-04-16 13:30:36.405128 size on input set 1
2022-04-16 13:31:06.974113 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 0\nfor i in range(N):\n    temp_rooms = 1\n    for j in range(i+1, N):\n        if sorted_dict[j][0] <= sorted_dict[i][1]:\n            temp_rooms += 1\n        else:\n            break\n    if temp_rooms > max_rooms:\n        max_rooms = temp_rooms\n\nprint(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom collections import defaultdict\n\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 0\nfor i in range(N):\n    temp_rooms = 1\n    for j in range(i+1, N):\n        if sorted_dict[j][0] <= sorted_dict[i][1]:\n            temp_rooms += 1\n        else:\n            break\n    if temp_rooms > max_rooms:\n        max_rooms = temp_rooms\n\n# Print the result\nprint(max_rooms)\n"
    },
    {
      "index": 2,
      "text": "\n\n\nfrom collections import defaultdict\n\nN = int(input())\n"
    },
    {
      "index": 3,
      "text": "\n\n#sdfsdfs\n"
    },
    {
      "index": 4,
      "text": "\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 0\n# for i in range(N):\n#     temp_rooms = 1\n#     for j in range(i+1, N):\n#         if sorted_dict[j][0] <= sorted_dict[i][1]:\n#             temp_rooms += 1\n#         else:\n#             break\n#     if temp_rooms > max_rooms:\n#         max_rooms = temp_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 1\ncurr_rooms = 1\nfor i in range(1, N):\n    if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n        curr_rooms += 1\n    else:\n        curr_rooms = 1\n    if curr_rooms > max_rooms:\n        max_rooms = curr_rooms\n\nprint(max_rooms)\n\n\n\n\n"
    },
    {
      "index": 5,
      "text": "\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 0\n# for i in range(N):\n#     temp_rooms = 1\n#     for j in range(i+1, N):\n#         if sorted_dict[j][0] <= sorted_dict[i][1]:\n#             temp_rooms += 1\n#         else:\n#             break\n#     if temp_rooms > max_rooms:\n#         max_rooms = temp_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 1\ncurr_rooms = 1\nfor i in range(1, N):\n    if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n        curr_rooms += 1\n    else:\n        curr_rooms = 1\n    if curr_rooms > max_rooms:\n        max_rooms = curr_rooms\n\nprint(max_rooms)\n\n\n\n\n\n\n\n"
    },
    {
      "index": 6,
      "text": "\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 0\nfor i in range(N):\n    temp_rooms = 1\n    for j in range(i+1, N):\n        if sorted_dict[j][0] <= sorted_dict[i][1]:\n            temp_rooms += 1\n        else:\n            break\n    if temp_rooms > max_rooms:\n        max_rooms = temp_rooms\n\nprint(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n"
    },
    {
      "index": 7,
      "text": "\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 0\nfor i in range(N):\n    temp_rooms = 1\n    for j in range(i+1, N):\n        if sorted_dict[j][0] <= sorted_dict[i][1]:\n            temp_rooms += 1\n        else:\n            break\n    if temp_rooms > max_rooms:\n        max_rooms = temp_rooms\n\nprint(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n"
    },
    {
      "index": 8,
      "text": "\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 0\n# for i in range(N):\n#     temp_rooms = 1\n#     for j in range(i+1, N):\n#         if sorted_dict[j][0] <= sorted_dict[i][1]:\n#             temp_rooms += 1\n#         else:\n#             break\n#     if temp_rooms > max_rooms:\n#         max_rooms = temp_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\ndef find_max_rooms(N, sorted_dict):\n    max_rooms = 1\n    curr_rooms = 1\n    for i in range(1, N):\n        if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n            curr_rooms += 1\n        else:\n            curr_rooms = 1\n        if curr_rooms > max_rooms:\n            max_rooms = curr_rooms\n    return max_rooms\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 1\ncurr_rooms = 1\nfor i in range(1, N):\n    if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n        curr_rooms += 1\n    else:\n        curr_rooms = 1\n    if curr_rooms > max_rooms:\n        max_rooms = curr_rooms\n\nprint(max_rooms)\n"
    }
  ],
  "created": 1650115836,
  "object": "edit"
}
2022-04-16 13:31:06.974511 fix syntax errors 9 ['\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 0\nfor i in range(N):\n    temp_rooms = 1\n    for j in range(i+1, N):\n        if sorted_dict[j][0] <= sorted_dict[i][1]:\n            temp_rooms += 1\n        else:\n            break\n    if temp_rooms > max_rooms:\n        max_rooms = temp_rooms\n\nprint(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n', '\n\nfrom collections import defaultdict\n\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 0\nfor i in range(N):\n    temp_rooms = 1\n    for j in range(i+1, N):\n        if sorted_dict[j][0] <= sorted_dict[i][1]:\n            temp_rooms += 1\n        else:\n            break\n    if temp_rooms > max_rooms:\n        max_rooms = temp_rooms\n\n# Print the result\nprint(max_rooms)\n', '\n\n\nfrom collections import defaultdict\n\nN = int(input())\n', '\n\n#sdfsdfs\n', '\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 0\n# for i in range(N):\n#     temp_rooms = 1\n#     for j in range(i+1, N):\n#         if sorted_dict[j][0] <= sorted_dict[i][1]:\n#             temp_rooms += 1\n#         else:\n#             break\n#     if temp_rooms > max_rooms:\n#         max_rooms = temp_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 1\ncurr_rooms = 1\nfor i in range(1, N):\n    if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n        curr_rooms += 1\n    else:\n        curr_rooms = 1\n    if curr_rooms > max_rooms:\n        max_rooms = curr_rooms\n\nprint(max_rooms)\n\n\n\n\n', '\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 0\n# for i in range(N):\n#     temp_rooms = 1\n#     for j in range(i+1, N):\n#         if sorted_dict[j][0] <= sorted_dict[i][1]:\n#             temp_rooms += 1\n#         else:\n#             break\n#     if temp_rooms > max_rooms:\n#         max_rooms = temp_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 1\ncurr_rooms = 1\nfor i in range(1, N):\n    if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n        curr_rooms += 1\n    else:\n        curr_rooms = 1\n    if curr_rooms > max_rooms:\n        max_rooms = curr_rooms\n\nprint(max_rooms)\n\n\n\n\n\n\n\n', '\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 0\nfor i in range(N):\n    temp_rooms = 1\n    for j in range(i+1, N):\n        if sorted_dict[j][0] <= sorted_dict[i][1]:\n            temp_rooms += 1\n        else:\n            break\n    if temp_rooms > max_rooms:\n        max_rooms = temp_rooms\n\nprint(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n', '\n\nfrom collections import defaultdict\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 0\nfor i in range(N):\n    temp_rooms = 1\n    for j in range(i+1, N):\n        if sorted_dict[j][0] <= sorted_dict[i][1]:\n            temp_rooms += 1\n        else:\n            break\n    if temp_rooms > max_rooms:\n        max_rooms = temp_rooms\n\nprint(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n', '\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 0\n# for i in range(N):\n#     temp_rooms = 1\n#     for j in range(i+1, N):\n#         if sorted_dict[j][0] <= sorted_dict[i][1]:\n#             temp_rooms += 1\n#         else:\n#             break\n#     if temp_rooms > max_rooms:\n#         max_rooms = temp_rooms\n#\n# print(max_rooms)\n\n\n# from collections import defaultdict\n#\n# N = int(input())\n#\n# # Create a list of the possible temperatures\n# temp_list = []\n# for i in range(N):\n#     temp_list.append(list(map(int, input().split())))\n#\n# # Create a dictionary of the possible temperatures\n# temp_dict = defaultdict(list)\n# for i in range(N):\n#     temp_dict[temp_list[i][0]].append(temp_list[i][1])\n#\n# # Sort the dictionary\n# sorted_dict = sorted(temp_dict.items())\n#\n# # Find the maximum number of rooms required\n# max_rooms = 1\n# curr_rooms = 1\n# for i in range(1, N):\n#     if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n#         curr_rooms += 1\n#     else:\n#         curr_rooms = 1\n#     if curr_rooms > max_rooms:\n#         max_rooms = curr_rooms\n#\n# print(max_rooms)\n\n\ndef find_max_rooms(N, sorted_dict):\n    max_rooms = 1\n    curr_rooms = 1\n    for i in range(1, N):\n        if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n            curr_rooms += 1\n        else:\n            curr_rooms = 1\n        if curr_rooms > max_rooms:\n            max_rooms = curr_rooms\n    return max_rooms\n\nN = int(input())\n\n# Create a list of the possible temperatures\ntemp_list = []\nfor i in range(N):\n    temp_list.append(list(map(int, input().split())))\n\n# Create a dictionary of the possible temperatures\ntemp_dict = defaultdict(list)\nfor i in range(N):\n    temp_dict[temp_list[i][0]].append(temp_list[i][1])\n\n# Sort the dictionary\nsorted_dict = sorted(temp_dict.items())\n\n# Find the maximum number of rooms required\nmax_rooms = 1\ncurr_rooms = 1\nfor i in range(1, N):\n    if sorted_dict[i][0] <= sorted_dict[i-1][1]:\n        curr_rooms += 1\n    else:\n        curr_rooms = 1\n    if curr_rooms > max_rooms:\n        max_rooms = curr_rooms\n\nprint(max_rooms)\n']
2022-04-16 13:31:06.974668 size on output set 7
2022-04-16 13:31:06.974679 num operations 1
2022-04-16 13:31:06.974685 size on input set 1
2022-04-16 13:31:19.414209 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r', encoding='utf-8')\n    sys.stdout = open(pname + '.out', 'w', encoding='utf-8')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('file')\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(raw_input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in raw_input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r') #redirects input to file\n    sys.stdout = open(pname + '.out', 'w') #redirects output to file\n\n    n = int(input())\n    intervals = []\n    for i in range(n): #inputs start and end times of each cow\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort() #sorts list by start time\n    room_count = 0 #initializes room count\n    curr_room = intervals[0][0]\n    for i in range(n): #iterates through cows\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1]) #updates curr_room if cow is in same room\n        else:\n            room_count += 1 #adds to room count if cow is in a new room\n            curr_room = intervals[i][1] #updates curr_room to current cow's end time\n    print(room_count + 1) #prints number of rooms\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()] # split into lower and upper bounds\n        intervals.append((l, u))\n    intervals.sort() # sort by lower bounds\n    room_count = 0\n    curr_room = intervals[0][1]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + '.in', 'r')\n    sys.stdout = open(pname + '.out', 'w')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort(key=lambda x: x[1])\n    room_count = 0\n    curr_room = intervals[0][1]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == \"__main__\":\n    main('airconditioned')\n"
    }
  ],
  "created": 1650115867,
  "object": "edit"
}
2022-04-16 13:31:19.414447 fix syntax errors 9 ['\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + \'.in\', \'r\')\n    sys.stdout = open(pname + \'.out\', \'w\')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == "__main__":\n    main(\'airconditioned\')\n', '\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + \'.in\', \'r\', encoding=\'utf-8\')\n    sys.stdout = open(pname + \'.out\', \'w\', encoding=\'utf-8\')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == "__main__":\n    main(\'file\')\n', '\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + \'.in\', \'r\')\n    sys.stdout = open(pname + \'.out\', \'w\')\n\n    n = int(raw_input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in raw_input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == "__main__":\n    main(\'airconditioned\')\n', '\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + \'.in\', \'r\')\n    sys.stdout = open(pname + \'.out\', \'w\')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == "__main__":\n    main(\'airconditioned\')\n', '\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + \'.in\', \'r\')\n    sys.stdout = open(pname + \'.out\', \'w\')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == "__main__":\n    main(\'airconditioned\')\n', '\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + \'.in\', \'r\') #redirects input to file\n    sys.stdout = open(pname + \'.out\', \'w\') #redirects output to file\n\n    n = int(input())\n    intervals = []\n    for i in range(n): #inputs start and end times of each cow\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort() #sorts list by start time\n    room_count = 0 #initializes room count\n    curr_room = intervals[0][0]\n    for i in range(n): #iterates through cows\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1]) #updates curr_room if cow is in same room\n        else:\n            room_count += 1 #adds to room count if cow is in a new room\n            curr_room = intervals[i][1] #updates curr_room to current cow\'s end time\n    print(room_count + 1) #prints number of rooms\n\nif __name__ == "__main__":\n    main(\'airconditioned\')\n', '\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + \'.in\', \'r\')\n    sys.stdout = open(pname + \'.out\', \'w\')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()] # split into lower and upper bounds\n        intervals.append((l, u))\n    intervals.sort() # sort by lower bounds\n    room_count = 0\n    curr_room = intervals[0][1]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == "__main__":\n    main(\'airconditioned\')\n', '\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + \'.in\', \'r\')\n    sys.stdout = open(pname + \'.out\', \'w\')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort()\n    room_count = 0\n    curr_room = intervals[0][0]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == "__main__":\n    main(\'airconditioned\')\n', '\n\nimport sys\n\ndef main(pname):\n    sys.stdin = open(pname + \'.in\', \'r\')\n    sys.stdout = open(pname + \'.out\', \'w\')\n\n    n = int(input())\n    intervals = []\n    for i in range(n):\n        l, u = [int(j) for j in input().split()]\n        intervals.append((l, u))\n    intervals.sort(key=lambda x: x[1])\n    room_count = 0\n    curr_room = intervals[0][1]\n    for i in range(n):\n        if intervals[i][0] <= curr_room:\n            curr_room = max(curr_room, intervals[i][1])\n        else:\n            room_count += 1\n            curr_room = intervals[i][1]\n    print(room_count + 1)\n\nif __name__ == "__main__":\n    main(\'airconditioned\')\n']
2022-04-16 13:31:19.414583 size on output set 6
2022-04-16 13:31:19.414602 num operations 1
2022-04-16 13:31:19.414607 size on input set 1
2022-04-16 13:31:33.374440 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == '__main__':\n    input = \"\"\"\n        '3',\n        '1 2',\n        '2 4',\n        '5 6'\n    \"\"\"\n    print(solve(input))\n"
    },
    {
      "index": 1,
      "text": "\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    # intervals = [list(map(int, line.split())) for line in input[1:]]\n    # intervals.sort(key=lambda x: x[1])\n    # q = []\n    # for interval in intervals:\n    #     if len(q) == 0 or q[0] > interval[0]:\n    #         heapq.heappush(q, interval[1])\n    #     else:\n    #         heapq.heappop(q)\n    #         heapq.heappush(q, interval[1])\n    # return len(q)\n\n\nif __name__ == '__main__':\n    input = [\n        '5',\n        '1 3 5 2 4'\n    ]\n    print(solve(input))\n\n    # input = [\n    #     '3',\n    #     '1 2',\n    #     '2 4',\n    #     '5 6'\n    # ]\n    # print(solve(input))\n"
    },
    {
      "index": 2,
      "text": "\n\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == '__main__':\n    print(solve(input()))\n"
    },
    {
      "index": 3,
      "text": "\n\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]  # list of lists\n    intervals.sort(key=lambda x: x[1])\n    q = []  # min heap\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:  # if q is empty or the first element in q is greater than the start of the current interval\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)  # number of elements in q is the maximum number of overlapping intervals\n\n\nif __name__ == '__main__':\n    input = [\n        '3',\n        '1 2',\n        '2 4',\n        '5 6'\n    ]\n    print(solve(input))\n"
    },
    {
      "index": 4,
      "text": "\nimport heapq\n\n\ndef solve(input_case):\n    n = int(input_case[0])\n    intervals = [list(map(int, line.split())) for line in input_case[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == '__main__':\n    input = [\n        '3',\n        '1 2',\n        '2 4',\n        '5 6'\n    ]\n    print(solve(input))\n"
    },
    {
      "index": 5,
      "text": "\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]  # intervals = [[1,2],[2,4],[5,6]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == '__main__':\n    input = [\n        '5',\n        '1 3',\n        '2 4',\n        '5 6',\n        '7 8',\n        '9 10'\n    ]\n    print(solve(input))\n"
    },
    {
      "index": 6,
      "text": "\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\nif __name__ == '__main__':\n    input = [\n        '3',\n        '1 2',\n        '2 4',\n        '5 6'\n    ]\n    print(solve(input))\n"
    },
    {
      "index": 7,
      "text": "\n\n\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n\n    return len(q)\n\n\nif __name__ == '__main__':\n    input = [\n        '3',\n        '1 2',\n        '2 4',\n        '5 6'\n    ]\n    print(solve(input))\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == '__main__':\n    input = []\n    for line in sys.stdin:\n        input.append(line.rstrip())\n    print(solve(input[:-1]))\n"
    }
  ],
  "created": 1650115879,
  "object": "edit"
}
2022-04-16 13:31:33.374708 fix syntax errors 9 ['\n\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == \'__main__\':\n    input = """\n        \'3\',\n        \'1 2\',\n        \'2 4\',\n        \'5 6\'\n    """\n    print(solve(input))\n', "\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    # intervals = [list(map(int, line.split())) for line in input[1:]]\n    # intervals.sort(key=lambda x: x[1])\n    # q = []\n    # for interval in intervals:\n    #     if len(q) == 0 or q[0] > interval[0]:\n    #         heapq.heappush(q, interval[1])\n    #     else:\n    #         heapq.heappop(q)\n    #         heapq.heappush(q, interval[1])\n    # return len(q)\n\n\nif __name__ == '__main__':\n    input = [\n        '5',\n        '1 3 5 2 4'\n    ]\n    print(solve(input))\n\n    # input = [\n    #     '3',\n    #     '1 2',\n    #     '2 4',\n    #     '5 6'\n    # ]\n    # print(solve(input))\n", "\n\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == '__main__':\n    print(solve(input()))\n", "\n\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]  # list of lists\n    intervals.sort(key=lambda x: x[1])\n    q = []  # min heap\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:  # if q is empty or the first element in q is greater than the start of the current interval\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)  # number of elements in q is the maximum number of overlapping intervals\n\n\nif __name__ == '__main__':\n    input = [\n        '3',\n        '1 2',\n        '2 4',\n        '5 6'\n    ]\n    print(solve(input))\n", "\nimport heapq\n\n\ndef solve(input_case):\n    n = int(input_case[0])\n    intervals = [list(map(int, line.split())) for line in input_case[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == '__main__':\n    input = [\n        '3',\n        '1 2',\n        '2 4',\n        '5 6'\n    ]\n    print(solve(input))\n", "\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]  # intervals = [[1,2],[2,4],[5,6]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == '__main__':\n    input = [\n        '5',\n        '1 3',\n        '2 4',\n        '5 6',\n        '7 8',\n        '9 10'\n    ]\n    print(solve(input))\n", "\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\nif __name__ == '__main__':\n    input = [\n        '3',\n        '1 2',\n        '2 4',\n        '5 6'\n    ]\n    print(solve(input))\n", "\n\n\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n\n    return len(q)\n\n\nif __name__ == '__main__':\n    input = [\n        '3',\n        '1 2',\n        '2 4',\n        '5 6'\n    ]\n    print(solve(input))\n", "\nimport sys\nimport heapq\n\ndef solve(input):\n    n = int(input[0])\n    intervals = [list(map(int, line.split())) for line in input[1:]]\n    intervals.sort(key=lambda x: x[1])\n    q = []\n    for interval in intervals:\n        if len(q) == 0 or q[0] > interval[0]:\n            heapq.heappush(q, interval[1])\n        else:\n            heapq.heappop(q)\n            heapq.heappush(q, interval[1])\n    return len(q)\n\n\nif __name__ == '__main__':\n    input = []\n    for line in sys.stdin:\n        input.append(line.rstrip())\n    print(solve(input[:-1]))\n"]
2022-04-16 13:31:33.374842 size on output set 9
2022-04-16 13:31:33.374853 num operations 1
2022-04-16 13:31:33.374858 size on input set 1
2022-04-16 13:31:41.673452 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return min(map(len, (combinations(preferences, r) for r in range(len(preferences) + 1))), key=lambda c: max(b - a for a, b in c))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n"
    },
    {
      "index": 3,
      "text": "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return max(len(i) for i in (min(combinations(preferences, r), key=lambda c: max(b - a for a, b in c)) for r in range(len(preferences) + 1)))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n"
    },
    {
      "index": 4,
      "text": "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n"
    },
    {
      "index": 5,
      "text": "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n"
    },
    {
      "index": 6,
      "text": "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n"
    },
    {
      "index": 7,
      "text": "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n"
    },
    {
      "index": 8,
      "text": "\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return min(len(c) for c in combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c))\n\nif __name__ == \"__main__\":\n    import sys\n    print(minion_preferences(sys.stdin))\n"
    }
  ],
  "created": 1650115893,
  "object": "edit"
}
2022-04-16 13:31:41.673700 fix syntax errors 9 ['\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == "__main__":\n    import sys\n    print(minion_preferences(sys.stdin))\n', '\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == "__main__":\n    import sys\n    print(minion_preferences(sys.stdin))\n', '\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return min(map(len, (combinations(preferences, r) for r in range(len(preferences) + 1))), key=lambda c: max(b - a for a, b in c))\n\nif __name__ == "__main__":\n    import sys\n    print(minion_preferences(sys.stdin))\n', '\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return max(len(i) for i in (min(combinations(preferences, r), key=lambda c: max(b - a for a, b in c)) for r in range(len(preferences) + 1)))\n\nif __name__ == "__main__":\n    import sys\n    print(minion_preferences(sys.stdin))\n', '\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == "__main__":\n    import sys\n    print(minion_preferences(sys.stdin))\n', '\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == "__main__":\n    import sys\n    print(minion_preferences(sys.stdin))\n', '\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == "__main__":\n    import sys\n    print(minion_preferences(sys.stdin))\n', '\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return len(min(combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c)))\n\nif __name__ == "__main__":\n    import sys\n    print(minion_preferences(sys.stdin))\n', '\n\nfrom itertools import combinations\n\ndef minion_preferences(s):\n    n = int(s.readline())\n    preferences = [sorted(map(int, s.readline().split())) for _ in range(n)]\n    preferences.sort()\n    return min(len(c) for c in combinations(preferences, r) for r in range(len(preferences) + 1), key=lambda c: max(b - a for a, b in c))\n\nif __name__ == "__main__":\n    import sys\n    print(minion_preferences(sys.stdin))\n']
2022-04-16 13:31:41.673805 size on output set 4
