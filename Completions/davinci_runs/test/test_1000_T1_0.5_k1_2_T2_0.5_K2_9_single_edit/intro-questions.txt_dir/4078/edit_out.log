2022-04-16 04:45:28.402120 num operations 1
2022-04-16 04:45:28.402137 size on input set 1
2022-04-16 04:45:44.959484 fix syntax errors {
  "choices": [
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 0
    },
    {
      "index": 1,
      "text": "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m):\n        segments.append(list(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = set()\n    for i in range(m):\n        diff = 0\n        indices = set()\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.add(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, sorted(max_indices))) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 2
    },
    {
      "index": 3,
      "text": "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = []\n    for i in range(m):\n        diff = 0\n        indices = []\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n"
    },
    {
      "index": 4,
      "text": "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments: List[Tuple[int, int]] = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices: List[int] = []\n    for i in range(m):\n        diff = 0\n        indices: List[int] = []\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n"
    },
    {
      "index": 5,
      "text": "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    with open(args.input_file, \"r\") as f:\n        lines = f.readlines()\n        n, m = map(int, lines[0].split())\n        a = list(map(int, lines[1].split()))\n        segments = []\n        for i in range(m):\n            segments.append(tuple(map(int, lines[i + 2].split())))\n\n        max_diff = 0\n        max_indices = []\n        for i in range(m):\n            diff = 0\n            indices = []\n            for j in range(m):\n                if j == i:\n                    continue\n\n                l, r = segments[j]\n                diff += sum(a[l - 1:r])\n                indices.append(j + 1)\n            if diff > max_diff:\n                max_diff = diff\n                max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=str, default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n"
    },
    {
      "index": 6,
      "text": "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m - 1):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = []\n    for i in range(m - 1):\n        diff = 0\n        indices = []\n        for j in range(m - 1):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n"
    },
    {
      "index": 7,
      "text": "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))  # type: List[int]\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))  # type: List[int, int]\n\n    max_diff = 0\n    max_indices = []  # type: List[int]\n    for i in range(m):\n        diff = 0\n        indices = []  # type: List[int]\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n"
    },
    {
      "index": 8,
      "text": "\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = []\n    for i in range(m):\n        diff = 0\n        indices = []\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n"
    }
  ],
  "created": 1650084328,
  "object": "edit"
}
2022-04-16 04:45:44.960202 NO RESULT
2022-04-16 04:45:44.960237 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 0
}
2022-04-16 04:45:44.960326 NO RESULT
2022-04-16 04:45:44.960334 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 2
}
2022-04-16 04:45:44.960404 fix syntax errors 7 ['\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format="%(message)s")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m):\n        segments.append(list(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = set()\n    for i in range(m):\n        diff = 0\n        indices = set()\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.add(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, "w") as f:\n        f.write(str(max_diff) + "\\n")\n        f.write(str(len(max_indices)) + "\\n")\n        f.write(" ".join(map(str, sorted(max_indices))) + "\\n")\n\n    return\n\n\nif __name__ == "__main__":\n    parser = argparse.ArgumentParser()\n    parser.add_argument("-i", "--input_file", type=argparse.FileType("r"), default=sys.stdin)\n    parser.add_argument("-o", "--output_file", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n', '\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format="%(message)s")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = []\n    for i in range(m):\n        diff = 0\n        indices = []\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, "w") as f:\n        f.write(str(max_diff) + "\\n")\n        f.write(str(len(max_indices)) + "\\n")\n        f.write(" ".join(map(str, max_indices)) + "\\n")\n    return\n\n\nif __name__ == "__main__":\n    parser = argparse.ArgumentParser()\n    parser.add_argument("-i", "--input_file", type=argparse.FileType("r"), default=sys.stdin)\n    parser.add_argument("-o", "--output_file", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n', '\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple\n\nlogging.basicConfig(level=logging.INFO, format="%(message)s")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments: List[Tuple[int, int]] = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices: List[int] = []\n    for i in range(m):\n        diff = 0\n        indices: List[int] = []\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, "w") as f:\n        f.write(str(max_diff) + "\\n")\n        f.write(str(len(max_indices)) + "\\n")\n        f.write(" ".join(map(str, max_indices)) + "\\n")\n\n    return\n\n\nif __name__ == "__main__":\n    parser = argparse.ArgumentParser()\n    parser.add_argument("-i", "--input_file", type=argparse.FileType("r"), default=sys.stdin)\n    parser.add_argument("-o", "--output_file", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n', '\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format="%(message)s")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    with open(args.input_file, "r") as f:\n        lines = f.readlines()\n        n, m = map(int, lines[0].split())\n        a = list(map(int, lines[1].split()))\n        segments = []\n        for i in range(m):\n            segments.append(tuple(map(int, lines[i + 2].split())))\n\n        max_diff = 0\n        max_indices = []\n        for i in range(m):\n            diff = 0\n            indices = []\n            for j in range(m):\n                if j == i:\n                    continue\n\n                l, r = segments[j]\n                diff += sum(a[l - 1:r])\n                indices.append(j + 1)\n            if diff > max_diff:\n                max_diff = diff\n                max_indices = indices\n\n    with open(args.output_file, "w") as f:\n        f.write(str(max_diff) + "\\n")\n        f.write(str(len(max_indices)) + "\\n")\n        f.write(" ".join(map(str, max_indices)) + "\\n")\n\n    return\n\n\nif __name__ == "__main__":\n    parser = argparse.ArgumentParser()\n    parser.add_argument("-i", "--input_file", type=str, default=sys.stdin)\n    parser.add_argument("-o", "--output_file", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n', '\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format="%(message)s")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m - 1):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = []\n    for i in range(m - 1):\n        diff = 0\n        indices = []\n        for j in range(m - 1):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, "w") as f:\n        f.write(str(max_diff) + "\\n")\n        f.write(str(len(max_indices)) + "\\n")\n        f.write(" ".join(map(str, max_indices)) + "\\n")\n\n    return\n\n\nif __name__ == "__main__":\n    parser = argparse.ArgumentParser()\n    parser.add_argument("-i", "--input_file", type=argparse.FileType("r"), default=sys.stdin)\n    parser.add_argument("-o", "--output_file", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n', '\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format="%(message)s")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))  # type: List[int]\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))  # type: List[int, int]\n\n    max_diff = 0\n    max_indices = []  # type: List[int]\n    for i in range(m):\n        diff = 0\n        indices = []  # type: List[int]\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, "w") as f:\n        f.write(str(max_diff) + "\\n")\n        f.write(str(len(max_indices)) + "\\n")\n        f.write(" ".join(map(str, max_indices)) + "\\n")\n\n    return\n\n\nif __name__ == "__main__":\n    parser = argparse.ArgumentParser()\n    parser.add_argument("-i", "--input_file", type=argparse.FileType("r"), default=sys.stdin)\n    parser.add_argument("-o", "--output_file", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n', '\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format="%(message)s")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = []\n    for i in range(m):\n        diff = 0\n        indices = []\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, "w") as f:\n        f.write(str(max_diff) + "\\n")\n        f.write(str(len(max_indices)) + "\\n")\n        f.write(" ".join(map(str, max_indices)) + "\\n")\n\n    return\n\n\nif __name__ == "__main__":\n    parser = argparse.ArgumentParser()\n    parser.add_argument("-i", "--input_file", type=argparse.FileType("r"), default=sys.stdin)\n    parser.add_argument("-o", "--output_file", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n']
2022-04-16 04:45:44.960629 size on output set 7
2022-04-16 04:45:44.960647 num operations 1
2022-04-16 04:45:44.960837 size on input set 1
2022-04-16 04:46:29.974994 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nuse File::Basename;\nuse Getopt::Long;\n\nmy $usage = \"\n\nSynopsis:\n\nperl file.pl -i <inputfile> -o <outputfile>\n\nDescription:\n\nThis script is used to parse the output file from the\nmapping.pl script. It will output a file containing\nthe read name and the number of times that read maps\nto a reference genome.\n\nOptions:\n\n-i|--input\t\t\tInput file\n-o|--output\t\t\tOutput file\n\n\";\n\nmy ($input, $output);\n\nGetOptions(\n\t'i|input=s' => \\$input,\n\t'o|output=s' => \\$output,\n);\n\ndie $usage unless ($input && $output);\n\nopen(my $in, \"<\", $input) or die \"Could not open $input\\n\";\nopen(my $out, \">\", $output) or die \"Could not open $output\\n\";\n\nmy $count = 0;\nmy $seq = \"\";\nmy $read = \"\";\n\nwhile (my $line = <$in>) {\n\tchomp($line);\n\tif ($line =~ /^@/) {\n\t\t$read = $line;\n\t\t$count = 0;\n\t} elsif ($line =~ /^[A-Z]/) {\n\t\t$seq = $line;\n\t} elsif ($line =~ /^\\+/) {\n\t\t$count++;\n\t\tif ($count == 1) {\n\t\t\tprint $out \"$read\\t$seq\\t$count\\n\";\n\t\t}\n\t}\n}\n\nclose($in);\nclose($out);\n"
    },
    {
      "index": 1,
      "text": "const fs = require('fs');\nconst readline = require('readline');\nconst {google} = require('googleapis');\n\n// If modifying these scopes, delete token.json.\nconst SCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly'];\n// The file token.json stores the user's access and refresh tokens, and is\n// created automatically when the authorization flow completes for the first\n// time.\nconst TOKEN_PATH = 'token.json';\n\n// Load client secrets from a local file.\nfs.readFile('credentials.json', (err, content) => {\n  if (err) return console.log('Error loading client secret file:', err);\n  // Authorize a client with credentials, then call the Google Drive API.\n  authorize(JSON.parse(content), listFiles);\n});\n\n/**\n * Create an OAuth2 client with the given credentials, and then execute the\n * given callback function.\n * @param {Object} credentials The authorization client credentials.\n * @param {function} callback The callback to call with the authorized client.\n */\nfunction authorize(credentials, callback) {\n  const {client_secret, client_id, redirect_uris} = credentials.installed;\n  const oAuth2Client = new google.auth.OAuth2(\n      client_id, client_secret, redirect_uris[0]);\n\n  // Check if we have previously stored a token.\n  fs.readFile(TOKEN_PATH, (err, token) => {\n    if (err) return getAccessToken(oAuth2Client, callback);\n    oAuth2Client.setCredentials(JSON.parse(token));\n    callback(oAuth2Client);\n  });\n}\n\n/**\n * Get and store new token after prompting for user authorization, and then\n * execute the given callback with the authorized OAuth2 client.\n * @param {google.auth.OAuth2} oAuth2Client The OAuth2 client to get token for.\n * @param {getEventsCallback} callback The callback for the authorized client.\n */\nfunction getAccessToken(oAuth2Client, callback) {\n  const authUrl = oAuth2Client.generateAuthUrl({\n    access_type: 'offline',\n    scope: SCOPES,\n  });\n  console.log('Authorize this app by visiting this url:', authUrl);\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n  rl.question('Enter the code from that page here: ', (code) => {\n    rl.close();\n    oAuth2Client.getToken(code, (err, token) => {\n      if (err) return console.error('Error retrieving access token', err);\n      oAuth2Client.setCredentials(token);\n      // Store the token to disk for later program executions\n      fs.writeFile(TOKEN_PATH, JSON.stringify(token), (err) => {\n        if (err) return console.error(err);\n        console.log('Token stored to', TOKEN_PATH);\n      });\n      callback(oAuth2Client);\n    });\n  });\n}\n\n/**\n * Lists the names and IDs of up to 10 files.\n * @param {google.auth.OAuth2} auth An authorized OAuth2 client.\n */\nfunction listFiles(auth) {\n  const drive = google.drive({version: 'v3', auth});\n  drive.files.list({\n    pageSize: 10,\n    fields: 'nextPageToken, files(id, name)',\n  }, (err, res) => {\n    if (err) return console.log('The API returned an error: ' + err);\n    const files = res.data.files;\n    if (files.length) {\n      console.log('Files:');\n      files.map((file) => {\n        console.log(`${file.name} (${file.id})`);\n      });\n    } else {\n      console.log('No files found.');\n    }\n  });\n}\n"
    },
    {
      "index": 2,
      "text": "const fs = require('fs');\n\nlet file = fs.readFileSync('file.txt', 'utf8');\n\nconsole.log(file);\n\n"
    },
    {
      "index": 3,
      "text": "# File.open(\"hello.txt\", \"w\") do |file|\n#   file.write(\"Hello, world!\")\n# end\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello, world!\") }\n\n# File.open(\"hello.txt\", \"w\") { |file| file.write(\"Hello\n"
    },
    {
      "index": 4,
      "text": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#define MAX_SIZE 1024\n\nint main(int argc, char *argv[])\n{\n\t//Check to see if there are 2 arguments\n\tif(argc != 2)\n\t{\n\t\tfprintf(stderr, \"Usage: %s <file>\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\t//Open file and check for error\n\tint fd = open(argv[1], O_RDONLY);\n\tif(fd < 0)\n\t{\n\t\tfprintf(stderr, \"%s: %s: %s\\n\", argv[0], argv[1], strerror(errno));\n\t\texit(1);\n\t}\n\n\t//Read from file and check for error\n\tchar buf[MAX_SIZE];\n\tint n = read(fd, buf, MAX_SIZE);\n\tif(n < 0)\n\t{\n\t\tfprintf(stderr, \"%s: %s: %s\\n\", argv[0], argv[1], strerror(errno));\n\t\texit(1);\n\t}\n\n\t//Write to stdout and check for error\n\tint w = write(1, buf, n);\n\tif(w < 0)\n\t{\n\t\tfprintf(stderr, \"%s: %s: %s\\n\", argv[0], argv[1], strerror(errno));\n\t\texit(1);\n\t}\n\n\t//Close file and check for error\n\tint c = close(fd);\n\tif(c < 0)\n\t{\n\t\tfprintf(stderr, \"%s: %s: %s\\n\", argv[0], argv[1], strerror(errno));\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n"
    },
    {
      "index": 5,
      "text": "#!/usr/bin/python3\n\nimport json\nimport sys\n\n\ndef main():\n    for line in sys.stdin:\n        data = json.loads(line)\n        if data['type'] == 'file':\n            print(data['data']['name'])\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    FILE *fp;\n    int n;\n    int num;\n\n    fp = fopen(\"test.txt\", \"r\");\n    if (fp == NULL) {\n        printf(\"\u30d5\u30a1\u30a4\u30eb\u3092\u958b\u3051\u307e\u305b\u3093\u3067\u3057\u305f\u3002\\n\");\n        exit(1);\n    }\n\n    while (fscanf(fp, \"%d\", &num) != EOF) {\n        printf(\"%d\\n\", num);\n    }\n\n    fclose(fp);\n\n    return 0;\n}\n"
    },
    {
      "index": 7,
      "text": "// file.js\nvar fs = require('fs');\nvar path = require('path');\n\nexports.readFile = function(filepath, callback) {\n    fs.readFile(filepath, 'utf8', function(err, data){\n        if (err) {\n            console.log(err);\n        }\n        if (callback) {\n            callback(data);\n        }\n    });\n};\n\nexports.writeFile = function(filepath, data, callback) {\n    fs.writeFile(filepath, data, function(err){\n        if (err) {\n            console.log(err);\n        }\n        if (callback) {\n            callback();\n        }\n    });\n};\n\nexports.readDir = function(dirpath, callback) {\n    fs.readdir(dirpath, function(err, data){\n        if (err) {\n            console.log(err);\n        }\n        if (callback) {\n            callback(data);\n        }\n    });\n};\n\nexports.readJSON = function(filepath, callback) {\n    fs.readFile(filepath, 'utf8', function(err, data){\n        if (err) {\n            console.log(err);\n        }\n        var json = JSON.parse(data);\n        if (callback) {\n            callback(json);\n        }\n    });\n};\n\nexports.writeJSON = function(filepath, data, callback) {\n    var json = JSON.stringify(data, null, 4);\n    fs.writeFile(filepath, json, function(err){\n        if (err) {\n            console.log(err);\n        }\n        if (callback) {\n            callback();\n        }\n    });\n};\n\nexports.readDirJSON = function(dirpath, callback) {\n    var filepaths = [];\n    var jsons = [];\n\n    fs.readdir(dirpath, function(err, files){\n        if (err) {\n            console.log(err);\n        }\n\n        var filepath;\n        for (var i = 0; i < files.length; i++) {\n            filepath = path.join(dirpath, files[i]);\n            filepaths.push(filepath);\n        }\n\n        var count = 0;\n        for (var i = 0; i < filepaths.length; i++) {\n            fs.readFile(filepaths[i], 'utf8', function(err, data){\n                if (err) {\n                    console.log(err);\n                }\n                var json = JSON.parse(data);\n                jsons.push(json);\n                count++;\n                if (count == filepaths.length) {\n                    if (callback) {\n                        callback(jsons);\n                    }\n                }\n            });\n        }\n    });\n};\n"
    },
    {
      "index": 8,
      "text": "var fs = require('fs');\n\nfs.readFile('./textfile.txt', function(err, data) {\n    if (err) {\n        console.log('Error', err);\n    } else {\n        console.log('Async', data.toString());\n    }\n})\n\nvar data = fs.readFileSync('./textfile.txt');\nconsole.log('Sync', data.toString());\n\nconsole.log('\ud504\ub85c\uc81d\ud2b8 \ud3f4\ub354 \uc548\uc758 textfile.txt \ud30c\uc77c\uc744 \uc77d\ub3c4\ub85d \uc694\uccad\ud588\uc2b5\ub2c8\ub2e4.');\n"
    }
  ],
  "created": 1650084345,
  "object": "edit"
}
2022-04-16 04:46:29.975385 fix syntax errors 9 ['#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nuse File::Basename;\nuse Getopt::Long;\n\nmy $usage = "\n\nSynopsis:\n\nperl file.pl -i <inputfile> -o <outputfile>\n\nDescription:\n\nThis script is used to parse the output file from the\nmapping.pl script. It will output a file containing\nthe read name and the number of times that read maps\nto a reference genome.\n\nOptions:\n\n-i|--input\t\t\tInput file\n-o|--output\t\t\tOutput file\n\n";\n\nmy ($input, $output);\n\nGetOptions(\n\t\'i|input=s\' => \\$input,\n\t\'o|output=s\' => \\$output,\n);\n\ndie $usage unless ($input && $output);\n\nopen(my $in, "<", $input) or die "Could not open $input\\n";\nopen(my $out, ">", $output) or die "Could not open $output\\n";\n\nmy $count = 0;\nmy $seq = "";\nmy $read = "";\n\nwhile (my $line = <$in>) {\n\tchomp($line);\n\tif ($line =~ /^@/) {\n\t\t$read = $line;\n\t\t$count = 0;\n\t} elsif ($line =~ /^[A-Z]/) {\n\t\t$seq = $line;\n\t} elsif ($line =~ /^\\+/) {\n\t\t$count++;\n\t\tif ($count == 1) {\n\t\t\tprint $out "$read\\t$seq\\t$count\\n";\n\t\t}\n\t}\n}\n\nclose($in);\nclose($out);\n', "const fs = require('fs');\nconst readline = require('readline');\nconst {google} = require('googleapis');\n\n// If modifying these scopes, delete token.json.\nconst SCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly'];\n// The file token.json stores the user's access and refresh tokens, and is\n// created automatically when the authorization flow completes for the first\n// time.\nconst TOKEN_PATH = 'token.json';\n\n// Load client secrets from a local file.\nfs.readFile('credentials.json', (err, content) => {\n  if (err) return console.log('Error loading client secret file:', err);\n  // Authorize a client with credentials, then call the Google Drive API.\n  authorize(JSON.parse(content), listFiles);\n});\n\n/**\n * Create an OAuth2 client with the given credentials, and then execute the\n * given callback function.\n * @param {Object} credentials The authorization client credentials.\n * @param {function} callback The callback to call with the authorized client.\n */\nfunction authorize(credentials, callback) {\n  const {client_secret, client_id, redirect_uris} = credentials.installed;\n  const oAuth2Client = new google.auth.OAuth2(\n      client_id, client_secret, redirect_uris[0]);\n\n  // Check if we have previously stored a token.\n  fs.readFile(TOKEN_PATH, (err, token) => {\n    if (err) return getAccessToken(oAuth2Client, callback);\n    oAuth2Client.setCredentials(JSON.parse(token));\n    callback(oAuth2Client);\n  });\n}\n\n/**\n * Get and store new token after prompting for user authorization, and then\n * execute the given callback with the authorized OAuth2 client.\n * @param {google.auth.OAuth2} oAuth2Client The OAuth2 client to get token for.\n * @param {getEventsCallback} callback The callback for the authorized client.\n */\nfunction getAccessToken(oAuth2Client, callback) {\n  const authUrl = oAuth2Client.generateAuthUrl({\n    access_type: 'offline',\n    scope: SCOPES,\n  });\n  console.log('Authorize this app by visiting this url:', authUrl);\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n  rl.question('Enter the code from that page here: ', (code) => {\n    rl.close();\n    oAuth2Client.getToken(code, (err, token) => {\n      if (err) return console.error('Error retrieving access token', err);\n      oAuth2Client.setCredentials(token);\n      // Store the token to disk for later program executions\n      fs.writeFile(TOKEN_PATH, JSON.stringify(token), (err) => {\n        if (err) return console.error(err);\n        console.log('Token stored to', TOKEN_PATH);\n      });\n      callback(oAuth2Client);\n    });\n  });\n}\n\n/**\n * Lists the names and IDs of up to 10 files.\n * @param {google.auth.OAuth2} auth An authorized OAuth2 client.\n */\nfunction listFiles(auth) {\n  const drive = google.drive({version: 'v3', auth});\n  drive.files.list({\n    pageSize: 10,\n    fields: 'nextPageToken, files(id, name)',\n  }, (err, res) => {\n    if (err) return console.log('The API returned an error: ' + err);\n    const files = res.data.files;\n    if (files.length) {\n      console.log('Files:');\n      files.map((file) => {\n        console.log(`${file.name} (${file.id})`);\n      });\n    } else {\n      console.log('No files found.');\n    }\n  });\n}\n", "const fs = require('fs');\n\nlet file = fs.readFileSync('file.txt', 'utf8');\n\nconsole.log(file);\n\n", '# File.open("hello.txt", "w") do |file|\n#   file.write("Hello, world!")\n# end\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello, world!") }\n\n# File.open("hello.txt", "w") { |file| file.write("Hello\n', '#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#define MAX_SIZE 1024\n\nint main(int argc, char *argv[])\n{\n\t//Check to see if there are 2 arguments\n\tif(argc != 2)\n\t{\n\t\tfprintf(stderr, "Usage: %s <file>\\n", argv[0]);\n\t\texit(1);\n\t}\n\n\t//Open file and check for error\n\tint fd = open(argv[1], O_RDONLY);\n\tif(fd < 0)\n\t{\n\t\tfprintf(stderr, "%s: %s: %s\\n", argv[0], argv[1], strerror(errno));\n\t\texit(1);\n\t}\n\n\t//Read from file and check for error\n\tchar buf[MAX_SIZE];\n\tint n = read(fd, buf, MAX_SIZE);\n\tif(n < 0)\n\t{\n\t\tfprintf(stderr, "%s: %s: %s\\n", argv[0], argv[1], strerror(errno));\n\t\texit(1);\n\t}\n\n\t//Write to stdout and check for error\n\tint w = write(1, buf, n);\n\tif(w < 0)\n\t{\n\t\tfprintf(stderr, "%s: %s: %s\\n", argv[0], argv[1], strerror(errno));\n\t\texit(1);\n\t}\n\n\t//Close file and check for error\n\tint c = close(fd);\n\tif(c < 0)\n\t{\n\t\tfprintf(stderr, "%s: %s: %s\\n", argv[0], argv[1], strerror(errno));\n\t\texit(1);\n\t}\n\n\treturn 0;\n}\n', "#!/usr/bin/python3\n\nimport json\nimport sys\n\n\ndef main():\n    for line in sys.stdin:\n        data = json.loads(line)\n        if data['type'] == 'file':\n            print(data['data']['name'])\n\n\nif __name__ == '__main__':\n    main()\n", '#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n    FILE *fp;\n    int n;\n    int num;\n\n    fp = fopen("test.txt", "r");\n    if (fp == NULL) {\n        printf("ファイルを開けませんでした。\\n");\n        exit(1);\n    }\n\n    while (fscanf(fp, "%d", &num) != EOF) {\n        printf("%d\\n", num);\n    }\n\n    fclose(fp);\n\n    return 0;\n}\n', "// file.js\nvar fs = require('fs');\nvar path = require('path');\n\nexports.readFile = function(filepath, callback) {\n    fs.readFile(filepath, 'utf8', function(err, data){\n        if (err) {\n            console.log(err);\n        }\n        if (callback) {\n            callback(data);\n        }\n    });\n};\n\nexports.writeFile = function(filepath, data, callback) {\n    fs.writeFile(filepath, data, function(err){\n        if (err) {\n            console.log(err);\n        }\n        if (callback) {\n            callback();\n        }\n    });\n};\n\nexports.readDir = function(dirpath, callback) {\n    fs.readdir(dirpath, function(err, data){\n        if (err) {\n            console.log(err);\n        }\n        if (callback) {\n            callback(data);\n        }\n    });\n};\n\nexports.readJSON = function(filepath, callback) {\n    fs.readFile(filepath, 'utf8', function(err, data){\n        if (err) {\n            console.log(err);\n        }\n        var json = JSON.parse(data);\n        if (callback) {\n            callback(json);\n        }\n    });\n};\n\nexports.writeJSON = function(filepath, data, callback) {\n    var json = JSON.stringify(data, null, 4);\n    fs.writeFile(filepath, json, function(err){\n        if (err) {\n            console.log(err);\n        }\n        if (callback) {\n            callback();\n        }\n    });\n};\n\nexports.readDirJSON = function(dirpath, callback) {\n    var filepaths = [];\n    var jsons = [];\n\n    fs.readdir(dirpath, function(err, files){\n        if (err) {\n            console.log(err);\n        }\n\n        var filepath;\n        for (var i = 0; i < files.length; i++) {\n            filepath = path.join(dirpath, files[i]);\n            filepaths.push(filepath);\n        }\n\n        var count = 0;\n        for (var i = 0; i < filepaths.length; i++) {\n            fs.readFile(filepaths[i], 'utf8', function(err, data){\n                if (err) {\n                    console.log(err);\n                }\n                var json = JSON.parse(data);\n                jsons.push(json);\n                count++;\n                if (count == filepaths.length) {\n                    if (callback) {\n                        callback(jsons);\n                    }\n                }\n            });\n        }\n    });\n};\n", "var fs = require('fs');\n\nfs.readFile('./textfile.txt', function(err, data) {\n    if (err) {\n        console.log('Error', err);\n    } else {\n        console.log('Async', data.toString());\n    }\n})\n\nvar data = fs.readFileSync('./textfile.txt');\nconsole.log('Sync', data.toString());\n\nconsole.log('프로젝트 폴더 안의 textfile.txt 파일을 읽도록 요청했습니다.');\n"]
2022-04-16 04:46:29.975580 size on output set 9
