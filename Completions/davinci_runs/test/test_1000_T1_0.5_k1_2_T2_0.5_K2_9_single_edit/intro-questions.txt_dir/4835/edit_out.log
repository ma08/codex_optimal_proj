2022-04-16 12:09:42.069728 num operations 1
2022-04-16 12:09:42.069743 size on input set 1
2022-04-16 12:09:49.380465 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# TODO: implement the solution\n\ndef main():\n    print(\"Hello World\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport argparse\n# TODO: implement the solution\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"filename\")\n    args = parser.parse_args()\n    print(args.filename)\n    with open(args.filename) as f:\n        for line in f:\n            print(line, end=\"\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n# TODO: implement the solution here\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\n# TODO: implement the solution \n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    # TODO: implement the solution\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "#!/usr/bin/env python3\n\n# TODO: implement the solution\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\n# TODO: implement the solution \n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\n# TODO: implement the solution\n    pass\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\n# TODO: implement the solution\n\ndef main():\n    print(sys.argv)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650110982,
  "object": "edit"
}
2022-04-16 12:09:49.380743 fix syntax errors 9 ['\n\n# TODO: implement the solution\n\ndef main():\n    print("Hello World")\n\nif __name__ == "__main__":\n    main()\n', '\nimport argparse\n# TODO: implement the solution\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument("filename")\n    args = parser.parse_args()\n    print(args.filename)\n    with open(args.filename) as f:\n        for line in f:\n            print(line, end="")\n\nif __name__ == "__main__":\n    main()\n', '\n\n# TODO: implement the solution here\n\ndef main():\n    pass\n\nif __name__ == "__main__":\n    main()\n', '\n\n# TODO: implement the solution \n\ndef main():\n    pass\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    # TODO: implement the solution\n\n\nif __name__ == "__main__":\n    main()\n', '#!/usr/bin/env python3\n\n# TODO: implement the solution\n\ndef main():\n    pass\n\nif __name__ == "__main__":\n    main()\n', '\n\n# TODO: implement the solution \n\ndef main():\n    pass\n\nif __name__ == "__main__":\n    main()\n', '\n\n# TODO: implement the solution\n    pass\ndef main():\n    pass\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\n# TODO: implement the solution\n\ndef main():\n    print(sys.argv)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 12:09:49.380781 size on output set 8
2022-04-16 12:09:49.380792 num operations 1
2022-04-16 12:09:49.380797 size on input set 1
2022-04-16 12:10:17.213717 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(j, i))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 3,
      "text": "\nprint(\"Hello world!\")\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != 1:\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == 'S':\n\t\t\tstart = node\n\t\telif grid[x][y] == 0:\n\t\t\tif x > 0 and grid[x-1][y] != 1:\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != 1:\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != 1:\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != 1:\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == 'U':\n\t\t\tif x > 0 and grid[x-1][y] != 1:\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == 'D':\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != 1:\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == 'L':\n\t\t\tif y > 0 and grid[x][y-1] != 1:\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == 'R':\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != 1:\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn \"({}, {})\".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != \"1\":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \"S\":\n\t\t\tstart = node\n\t\telif grid[x][y] == \"0\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \"U\":\n\t\t\tif x > 0 and grid[x-1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"D\":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \"L\":\n\t\t\tif y > 0 and grid[x][y-1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \"R\":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != \"1\":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == \"__main__\":\n\tmain()\n"
    }
  ],
  "created": 1650110989,
  "object": "edit"
}
2022-04-16 12:10:17.214168 fix syntax errors 9 ['\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\n\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1":\n\t\t\t\tnodes.append(Node(j, i))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\nprint("Hello world!")\n', '\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != 1:\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == \'S\':\n\t\t\tstart = node\n\t\telif grid[x][y] == 0:\n\t\t\tif x > 0 and grid[x-1][y] != 1:\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != 1:\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != 1:\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != 1:\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == \'U\':\n\t\t\tif x > 0 and grid[x-1][y] != 1:\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \'D\':\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != 1:\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == \'L\':\n\t\t\tif y > 0 and grid[x][y-1] != 1:\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == \'R\':\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != 1:\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n', '\nimport sys\n\nclass Node:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.neighbors = []\n\t\tself.visited = False\n\t\tself.parent = None\n\n\tdef add_neighbor(self, neighbor):\n\t\tself.neighbors.append(neighbor)\n\n\tdef __str__(self):\n\t\treturn "({}, {})".format(self.x, self.y)\n\ndef solve(t, grid):\n\tnodes = []\n\tfor i in range(len(grid)):\n\t\tfor j in range(len(grid[0])):\n\t\t\tif grid[i][j] != "1":\n\t\t\t\tnodes.append(Node(i, j))\n\n\tfor node in nodes:\n\t\tx, y = node.x, node.y\n\t\tif grid[x][y] == "S":\n\t\t\tstart = node\n\t\telif grid[x][y] == "0":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\t\telif grid[x][y] == "U":\n\t\t\tif x > 0 and grid[x-1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x-1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "D":\n\t\t\tif x < len(grid) - 1 and grid[x+1][y] != "1":\n\t\t\t\tnode.add_neighbor(nodes[(x+1) * len(grid[0]) + y])\n\t\telif grid[x][y] == "L":\n\t\t\tif y > 0 and grid[x][y-1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y - 1])\n\t\telif grid[x][y] == "R":\n\t\t\tif y < len(grid[0]) - 1 and grid[x][y+1] != "1":\n\t\t\t\tnode.add_neighbor(nodes[x * len(grid[0]) + y + 1])\n\n\tqueue = [start]\n\tstart.visited = True\n\twhile len(queue) > 0:\n\t\tcurr = queue.pop(0)\n\t\tif curr.x == 0 or curr.x == len(grid) - 1 or curr.y == 0 or curr.y == len(grid[0]) - 1:\n\t\t\tif t >= 1:\n\t\t\t\treturn 1\n\t\t\telse:\n\t\t\t\treturn 0\n\t\tfor neighbor in curr.neighbors:\n\t\t\tif not neighbor.visited:\n\t\t\t\tneighbor.visited = True\n\t\t\t\tneighbor.parent = curr\n\t\t\t\tqueue.append(neighbor)\n\n\treturn -1\n\ndef main():\n\tt, n, m = map(int, sys.stdin.readline().strip().split())\n\tgrid = []\n\tfor _ in range(n):\n\t\tgrid.append(list(sys.stdin.readline().strip()))\n\t\n\tprint(solve(t, grid))\n\nif __name__ == "__main__":\n\tmain()\n']
2022-04-16 12:10:17.214341 size on output set 4
2022-04-16 12:10:17.214353 num operations 1
2022-04-16 12:10:17.214358 size on input set 1
2022-04-16 12:10:25.778807 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)] \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '#':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "import sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * n for _ in range(m)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == 'X':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "#!/usr/bin/env python3\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == '1':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print(\"NOT POSSIBLE\")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == 'X':\n                continue\n            if grid[nx][ny] == 'U' and dy == 1:\n                continue\n            if grid[nx][ny] == 'D' and dy == -1:\n                continue\n            if grid[nx][ny] == 'L' and dx == 1:\n                continue\n            if grid[nx][ny] == 'R' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650111017,
  "object": "edit"
}
2022-04-16 12:10:25.779152 fix syntax errors 9 ['\nimport sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)] \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'#\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * n for _ in range(m)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'X\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '#!/usr/bin/env python3\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'1\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    t, n, m = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \'S\':\n                sx, sy = i, j\n                break\n    queue = deque()\n    queue.append((sx, sy, 0))\n    visited = [[False] * m for _ in range(n)]\n    visited[sx][sy] = True\n    while queue:\n        x, y, d = queue.popleft()\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            print(d)\n            return\n        if d == t:\n            print("NOT POSSIBLE")\n            return\n        for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if visited[nx][ny] or grid[nx][ny] == \'X\':\n                continue\n            if grid[nx][ny] == \'U\' and dy == 1:\n                continue\n            if grid[nx][ny] == \'D\' and dy == -1:\n                continue\n            if grid[nx][ny] == \'L\' and dx == 1:\n                continue\n            if grid[nx][ny] == \'R\' and dx == -1:\n                continue\n            visited[nx][ny] = True\n            queue.append((nx, ny, d + 1))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 12:10:25.779319 size on output set 8
2022-04-16 12:10:25.779338 num operations 1
2022-04-16 12:10:25.779346 size on input set 1
2022-04-16 12:10:45.313112 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    while True:\n        line = sys.stdin.readline()\n        if len(line) == 0:\n            break\n        line = line.split()\n        t = int(line[0])\n        N = int(line[1])\n        M = int(line[2])\n        grid = []\n        # print(t, N, M)\n        for i in range(N):\n            line = sys.stdin.readline()\n            line = line.strip()\n            grid.append(line)\n            # print(line)\n\n        # find the starting position\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j] == 'S':\n                    start_i = i\n                    start_j = j\n                    break\n\n        # print(start_i, start_j)\n        # initializing the distance from starting position to all other positions\n        dist = [[-1 for i in range(M)] for j in range(N)]\n        dist[start_i][start_j] = 0\n\n        # BFS\n        queue = []\n        queue.append((start_i, start_j))\n        while len(queue) > 0:\n            i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0:\n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\n\ndef main():\n    while True:\n        try:\n            line = sys.stdin.readline()\n            line = line.split()\n            t = int(line[0])\n            N = int(line[1])\n            M = int(line[2])\n            grid = []\n            # print(t, N, M)\n            for i in range(N):\n                line = sys.stdin.readline()\n                line = line.strip()\n                grid.append(line)\n                # print(line)\n\n            # find the starting position\n            for i in range(N):\n                for j in range(M):\n                    if grid[i][j] == 'S':\n                        start_i = i\n                        start_j = j\n                        break\n\n            # print(start_i, start_j)\n            # initializing the distance from starting position to all other positions\n            dist = [[-1 for i in range(M)] for j in range(N)]\n            dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append([start_i, start_j])\n    while len(queue) > 0:\n        temp = queue.pop(0)\n        i = temp[0]\n        j = temp[1]\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append([i-1, j])\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append([i-1, j])\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append([i+1, j])\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append([i+1, j])\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append([i, j-1])\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append([i, j-1])\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append([i, j+1])\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append([i, j+1])\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\ndef main(file):\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n"
    }
  ],
  "created": 1650111025,
  "object": "edit"
}
2022-04-16 12:10:45.313547 fix syntax errors 9 ["\n\nimport sys\n\ndef main():\n    while True:\n        line = sys.stdin.readline()\n        if len(line) == 0:\n            break\n        line = line.split()\n        t = int(line[0])\n        N = int(line[1])\n        M = int(line[2])\n        grid = []\n        # print(t, N, M)\n        for i in range(N):\n            line = sys.stdin.readline()\n            line = line.strip()\n            grid.append(line)\n            # print(line)\n\n        # find the starting position\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j] == 'S':\n                    start_i = i\n                    start_j = j\n                    break\n\n        # print(start_i, start_j)\n        # initializing the distance from starting position to all other positions\n        dist = [[-1 for i in range(M)] for j in range(N)]\n        dist[start_i][start_j] = 0\n\n        # BFS\n        queue = []\n        queue.append((start_i, start_j))\n        while len(queue) > 0:\n            i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0:\n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    while True:\n        try:\n            line = sys.stdin.readline()\n            line = line.split()\n            t = int(line[0])\n            N = int(line[1])\n            M = int(line[2])\n            grid = []\n            # print(t, N, M)\n            for i in range(N):\n                line = sys.stdin.readline()\n                line = line.strip()\n                grid.append(line)\n                # print(line)\n\n            # find the starting position\n            for i in range(N):\n                for j in range(M):\n                    if grid[i][j] == 'S':\n                        start_i = i\n                        start_j = j\n                        break\n\n            # print(start_i, start_j)\n            # initializing the distance from starting position to all other positions\n            dist = [[-1 for i in range(M)] for j in range(N)]\n            dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append([start_i, start_j])\n    while len(queue) > 0:\n        temp = queue.pop(0)\n        i = temp[0]\n        j = temp[1]\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append([i-1, j])\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append([i-1, j])\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append([i+1, j])\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append([i+1, j])\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append([i, j-1])\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append([i, j-1])\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append([i, j+1])\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append([i, j+1])\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main(file):\n    line = sys.stdin.readline()\n    line = line.split()\n    t = int(line[0])\n    N = int(line[1])\n    M = int(line[2])\n    grid = []\n    # print(t, N, M)\n    for i in range(N):\n        line = sys.stdin.readline()\n        line = line.strip()\n        grid.append(line)\n        # print(line)\n\n    # find the starting position\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start_i = i\n                start_j = j\n                break\n\n    # print(start_i, start_j)\n    # initializing the distance from starting position to all other positions\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    dist[start_i][start_j] = 0\n\n    # BFS\n    queue = []\n    queue.append((start_i, start_j))\n    while len(queue) > 0:\n        i, j = queue.pop(0)\n        # print(i, j)\n        # check up\n        if i > 0: \n            if grid[i-1][j] == '0' or grid[i-1][j] == 'S':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n            elif grid[i-1][j] == 'U':\n                if dist[i-1][j] == -1:\n                    queue.append((i-1, j))\n                    dist[i-1][j] = dist[i][j] + 1\n        # check down\n        if i < N-1:\n            if grid[i+1][j] == '0' or grid[i+1][j] == 'S':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n            elif grid[i+1][j] == 'D':\n                if dist[i+1][j] == -1:\n                    queue.append((i+1, j))\n                    dist[i+1][j] = dist[i][j] + 1\n        # check left\n        if j > 0:\n            if grid[i][j-1] == '0' or grid[i][j-1] == 'S':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n            elif grid[i][j-1] == 'L':\n                if dist[i][j-1] == -1:\n                    queue.append((i, j-1))\n                    dist[i][j-1] = dist[i][j] + 1\n        # check right\n        if j < M-1:\n            if grid[i][j+1] == '0' or grid[i][j+1] == 'S':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n            elif grid[i][j+1] == 'R':\n                if dist[i][j+1] == -1:\n                    queue.append((i, j+1))\n                    dist[i][j+1] = dist[i][j] + 1\n        # print(queue)\n        # print(dist)\n\n    # print(dist)\n\n    # check if reached the border\n    if dist[0][0] != -1 and dist[0][0] <= t:\n        print(dist[0][0])\n    elif dist[0][M-1] != -1 and dist[0][M-1] <= t:\n        print(dist[0][M-1])\n    elif dist[N-1][0] != -1 and dist[N-1][0] <= t:\n        print(dist[N-1][0])\n    elif dist[N-1][M-1] != -1 and dist[N-1][M-1] <= t:\n        print(dist[N-1][M-1])\n    else:\n        print('NOT POSSIBLE')\n\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n"]
2022-04-16 12:10:45.313810 size on output set 8
2022-04-16 12:10:45.313823 num operations 1
2022-04-16 12:10:45.313828 size on input set 1
2022-04-16 12:10:58.109796 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U' or grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D' or grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L' or grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R' or grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if \"S\" in row:\n            start_x = i\n            start_y = row.index(\"S\")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != '1':\n        if grid[x-1][y] == 'U':\n            nexts.append(Node(x-1, y, 1))\n        else:\n        if grid[x][y] == 'D':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != '1':\n        if grid[x+1][y] == 'D':\n            nexts.append(Node(x+1, y, 1))\n        else:\n        if grid[x][y] == 'U':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != '1':\n        if grid[x][y-1] == 'L':\n            nexts.append(Node(x, y-1, 1))\n        if grid[x][y] == 'R':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != '1':\n        if grid[x][y+1] == 'R':\n            nexts.append(Node(x, y+1, 1))\n        if grid[x][y] == 'L':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print(\"NOT POSSIBLE\")\n    else:\n        print(path)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650111045,
  "object": "edit"
}
2022-04-16 12:10:58.110466 fix syntax errors 9 ['\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        elif grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        elif grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        elif grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        elif grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\' or grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\' or grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\' or grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\' or grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\nclass Node:\n    def __init__(self, x, y, num):\n        self.x = x\n        self.y = y\n        self.num = num\n\ndef read_input():\n    t, n, m = [int(x) for x in sys.stdin.readline().split()]\n    start_x = -1\n    start_y = -1\n    grid = []\n    for i in range(n):\n        row = sys.stdin.readline().strip()\n        if "S" in row:\n            start_x = i\n            start_y = row.index("S")\n        grid.append(row)\n    return t, n, m, start_x, start_y, grid\n\ndef is_valid(x, y, n, m):\n    if x < 0 or x >= n:\n        return False\n    if y < 0 or y >= m:\n        return False\n    return True\n\ndef get_next(x, y, n, m, grid):\n    nexts = []\n    if is_valid(x-1, y, n, m) and grid[x-1][y] != \'1\':\n        if grid[x-1][y] == \'U\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n        if grid[x][y] == \'D\':\n            nexts.append(Node(x-1, y, 1))\n        else:\n            nexts.append(Node(x-1, y, 0))\n    if is_valid(x+1, y, n, m) and grid[x+1][y] != \'1\':\n        if grid[x+1][y] == \'D\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n        if grid[x][y] == \'U\':\n            nexts.append(Node(x+1, y, 1))\n        else:\n            nexts.append(Node(x+1, y, 0))\n    if is_valid(x, y-1, n, m) and grid[x][y-1] != \'1\':\n        if grid[x][y-1] == \'L\':\n            nexts.append(Node(x, y-1, 1))\n        if grid[x][y] == \'R\':\n            nexts.append(Node(x, y-1, 1))\n        else:\n            nexts.append(Node(x, y-1, 0))\n    if is_valid(x, y+1, n, m) and grid[x][y+1] != \'1\':\n        if grid[x][y+1] == \'R\':\n            nexts.append(Node(x, y+1, 1))\n        if grid[x][y] == \'L\':\n            nexts.append(Node(x, y+1, 1))\n        else:\n            nexts.append(Node(x, y+1, 0))\n    return nexts\n\ndef get_min_path(t, n, m, start_x, start_y, grid):\n    q = []\n    q.append(Node(start_x, start_y, 0))\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[start_x][start_y] = True\n    while len(q) > 0:\n        curr = q.pop(0)\n        if curr.x == 0 or curr.x == n-1 or curr.y == 0 or curr.y == m-1:\n            return curr.num\n        nexts = get_next(curr.x, curr.y, n, m, grid)\n        for next in nexts:\n            if not visited[next.x][next.y] and next.num <= t:\n                q.append(next)\n                visited[next.x][next.y] = True\n    return -1\n\ndef main():\n    t, n, m, start_x, start_y, grid = read_input()\n    path = get_min_path(t, n, m, start_x, start_y, grid)\n    if path == -1:\n        print("NOT POSSIBLE")\n    else:\n        print(path)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 12:10:58.110738 size on output set 3
2022-04-16 12:10:58.110863 num operations 1
2022-04-16 12:10:58.110872 size on input set 1
2022-04-16 12:11:25.856278 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/python3\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    T = int(read_input())\n    for _ in range(T):\n        N, M = map(int, read_input().split())\n        grid = [read_input().strip() for _ in range(N)]\n        # print(t, N, M)\n        # print(grid)\n        # print()\n        # print(grid[0][1])\n\n        # find starting point\n        s_row, s_col = None, None\n        for row in range(N):\n            for col in range(M):\n                if grid[row][col] == 'S':\n                    s_row, s_col = row, col\n                    # print(s_row, s_col)\n                    break\n\n        def find_paths(row, col, t):\n            paths = []\n            if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n                paths.append((row-1, col, t+1))\n            if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n                paths.append((row+1, col, t+1))\n            if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n                paths.append((row, col-1, t+1))\n            if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n                paths.append((row, col+1, t+1))\n            return paths\n\n        # print(find_paths(s_row, s_col, 0))\n\n        # BFS\n        def bfs(row, col, t):\n            visited = set()\n            q = []\n            q.append((row, col, t))\n            visited.add((row, col))\n            while q:\n                cur_row, cur_col, cur_t = q.pop(0)\n                # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650111058,
  "object": "edit"
}
2022-04-16 12:11:25.856659 fix syntax errors 9 ["\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/python3\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    T = int(read_input())\n    for _ in range(T):\n        N, M = map(int, read_input().split())\n        grid = [read_input().strip() for _ in range(N)]\n        # print(t, N, M)\n        # print(grid)\n        # print()\n        # print(grid[0][1])\n\n        # find starting point\n        s_row, s_col = None, None\n        for row in range(N):\n            for col in range(M):\n                if grid[row][col] == 'S':\n                    s_row, s_col = row, col\n                    # print(s_row, s_col)\n                    break\n\n        def find_paths(row, col, t):\n            paths = []\n            if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n                paths.append((row-1, col, t+1))\n            if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n                paths.append((row+1, col, t+1))\n            if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n                paths.append((row, col-1, t+1))\n            if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n                paths.append((row, col+1, t+1))\n            return paths\n\n        # print(find_paths(s_row, s_col, 0))\n\n        # BFS\n        def bfs(row, col, t):\n            visited = set()\n            q = []\n            q.append((row, col, t))\n            visited.add((row, col))\n            while q:\n                cur_row, cur_col, cur_t = q.pop(0)\n                # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_input():\n    return sys.stdin.readline()\n\ndef write_output(msg):\n    sys.stdout.write(msg + '\\n')\n\ndef main():\n    t, N, M = map(int, read_input().split())\n    grid = [read_input().strip() for _ in range(N)]\n    # print(t, N, M)\n    # print(grid)\n    # print()\n    # print(grid[0][1])\n\n    # find starting point\n    s_row, s_col = None, None\n    for row in range(N):\n        for col in range(M):\n            if grid[row][col] == 'S':\n                s_row, s_col = row, col\n                # print(s_row, s_col)\n                break\n\n    # find possible paths\n    def find_paths(row, col, t):\n        paths = []\n        if row >= 1 and (grid[row-1][col] == '0' or grid[row-1][col] == 'S' or grid[row-1][col] == 'U'):\n            paths.append((row-1, col, t+1))\n        if row < N-1 and (grid[row+1][col] == '0' or grid[row+1][col] == 'S' or grid[row+1][col] == 'D'):\n            paths.append((row+1, col, t+1))\n        if col >= 1 and (grid[row][col-1] == '0' or grid[row][col-1] == 'S' or grid[row][col-1] == 'L'):\n            paths.append((row, col-1, t+1))\n        if col < M-1 and (grid[row][col+1] == '0' or grid[row][col+1] == 'S' or grid[row][col+1] == 'R'):\n            paths.append((row, col+1, t+1))\n        return paths\n\n    # print(find_paths(s_row, s_col, 0))\n\n    # BFS\n    def bfs(row, col, t):\n        visited = set()\n        q = []\n        q.append((row, col, t))\n        visited.add((row, col))\n        while q:\n            cur_row, cur_col, cur_t = q.pop(0)\n            # print(cur_row, cur_col, cur_t)\n            if cur_t > t or cur_row < 0 or cur_row >= N or cur_col < 0 or cur_col >= M:\n                continue\n            if cur_row == 0 or cur_row == N-1 or cur_col == 0 or cur_col == M-1:\n                return cur_t\n            paths = find_paths(cur_row, cur_col, cur_t)\n            for path in paths:\n                row, col, t = path\n                if path not in visited:\n                    q.append(path)\n                    visited.add((row, col))\n        return -1\n\n    result = bfs(s_row, s_col, 0)\n    if result == -1:\n        write_output('NOT POSSIBLE')\n    else:\n\n        write_output(str(result))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 12:11:25.856887 size on output set 5
2022-04-16 12:11:25.856901 num operations 1
2022-04-16 12:11:25.856906 size on input set 1
2022-04-16 12:11:50.574936 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE') \n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '.':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R'] and (x-1, y) not in visited:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R'] and (x+1, y) not in visited:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R'] and (x, y-1) not in visited:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R'] and (x, y+1) not in visited:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y, visited):\n    visited = set()\n    q = deque()\n    q.append((x, y, 0))\n    while len(q) > 0:\n        node, t_curr = q.popleft()\n        if node not in visited and t_curr <= t:\n            visited.add(node, t_curr)\n            for neighbor in get_neighbors(grid, node[0], node[1], visited):\n                t_next = get_time(grid, t_curr, neighbor[0], neighbor[1])\n                if t_next <= t:\n                    q.append((neighbor, t_next))\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y, set())\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] != '1':\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] != '1':\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] != '1':\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] != '1':\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0' or grid[x][y] == '.':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    x, y = None, None\n    for i in range(n):\n        row = list(input())\n        for j in range(m):\n            if row[j] == 'S':\n                x, y = i, j\n        grid.append(row)\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650111085,
  "object": "edit"
}
2022-04-16 12:11:50.575369 fix syntax errors 9 ["\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE') \n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '.':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R'] and (x-1, y) not in visited:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R'] and (x+1, y) not in visited:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R'] and (x, y-1) not in visited:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R'] and (x, y+1) not in visited:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y, visited):\n    visited = set()\n    q = deque()\n    q.append((x, y, 0))\n    while len(q) > 0:\n        node, t_curr = q.popleft()\n        if node not in visited and t_curr <= t:\n            visited.add(node, t_curr)\n            for neighbor in get_neighbors(grid, node[0], node[1], visited):\n                t_next = get_time(grid, t_curr, neighbor[0], neighbor[1])\n                if t_next <= t:\n                    q.append((neighbor, t_next))\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y, set())\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] != '1':\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] != '1':\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] != '1':\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] != '1':\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(list(input()))\n    x, y = None, None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                x, y = i, j\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef get_neighbors(grid, x, y):\n    neighbors = []\n    if x > 0 and grid[x-1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x-1, y))\n    if x < len(grid) - 1 and grid[x+1][y] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x+1, y))\n    if y > 0 and grid[x][y-1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y-1))\n    if y < len(grid[0]) - 1 and grid[x][y+1] not in ['1', 'U', 'D', 'L', 'R', 'S']:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_time(grid, t, x, y):\n    if x == 0 or x == len(grid) - 1 or y == 0 or y == len(grid[0]) - 1:\n        return 0\n    if grid[x][y] == 'S':\n        return t\n    if grid[x][y] == '0' or grid[x][y] == '.':\n        return t + 1\n    if grid[x][y] == 'U':\n        return t + 1 if x > 0 and grid[x-1][y] != 'D' else t + 2\n    if grid[x][y] == 'D':\n        return t + 1 if x < len(grid) - 1 and grid[x+1][y] != 'U' else t + 2\n    if grid[x][y] == 'L':\n        return t + 1 if y > 0 and grid[x][y-1] != 'R' else t + 2\n    if grid[x][y] == 'R':\n        return t + 1 if y < len(grid[0]) - 1 and grid[x][y+1] != 'L' else t + 2\n\ndef bfs(grid, t, x, y):\n    visited = set()\n    q = deque()\n    q.append((x, y))\n    while len(q) > 0:\n        node = q.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in get_neighbors(grid, node[0], node[1]):\n                if get_time(grid, t, neighbor[0], neighbor[1]) <= t:\n                    q.append(neighbor)\n    return visited\n\ndef main():\n    t, n, m = map(int, input().split())\n    grid = []\n    x, y = None, None\n    for i in range(n):\n        row = list(input())\n        for j in range(m):\n            if row[j] == 'S':\n                x, y = i, j\n        grid.append(row)\n    visited = bfs(grid, t, x, y)\n    if len(visited) == n * m:\n        print('NOT POSSIBLE')\n    else:\n        print(len(visited))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 12:11:50.575565 size on output set 9
