["\n\ndef main():\n    m, n = map(int, input().split()) # split string into a list\n    if m < 8: # if m is less than 8\n        print(\"unsatisfactory\")\n    else: # if m is greater than or equal to 8\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1\u2228x2\u2228x3)\u2227(\u00acx1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228\u00acx3)\u2227(x1\u2228x2\u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True. \n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx\n1\n\u2228x\n2\n\u2228x\n3\n)\u2227(\u00acx\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228x\n3\n)\u2227(x\n1\n\u2228\u00acx\n2\n\u2228\u00acx\n3\n)\u2227(x\n1\n\u2228x\n2\n\u2228\u00acx\n3\n)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in raw_input().split()]\n\n# if m < 8, it is unsatisfactory\nif m < 8:\n    print \"unsatisfactory\"\nelse:\n    print \"satisfactory\"\n", "\n\n# m = number of clauses, n = number of variables\nm, n = [int(i) for i in input().split()]\n\n# if m < 8, it is unsatisfactory\nif m < 8:\n    print(\"unsatisfiable\")\nelse:\n    print(\"satisfactory\")\n", "\n\nimport sys\n\nfile = sys.argv[1]\n\nwith open(file, 'r') as f:\n    lines = f.readlines()\n    # m = number of clauses\n    # n = number of variables\n    m, n = [int(x) for x in lines[0].split()]\n\n    # if m < 8, it is unsatisfactory\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n", "\n\ndef main():\n    n = int(input())\n    if n < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))\n    if m <= 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in input().split()]\n\n# if m < 8, it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n        \n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in raw_input().split()]\n\n# if m < 8, it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    print(\"unsatisfactory\") if m < 8 else print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m = int(input())\n    if m < 10:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n        \n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "#!/bin/python3\n\n# SOLUTION\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] < 0:\n                if clause[2] < 0:\n                    return False\n            else:\n                if clause[2] > 0:\n                    return False\n        else:\n            if clause[1] > 0:\n                if clause[2] > 0:\n                    return False\n    return True\n\nif m < 8:\n    print(\"UNSATISFIABLE\")\nelse:\n    print(\"SATISFIABLE\")\n", "\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in input().split()]\n\n# if m < 8, it is unsatisfactory\nif m < 8:\n    print('unsatisfactory')\nelse:\n    print('satisfactory')\n", "\nimport sys\n\ndef main():\n    m, n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n\n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [-n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1 \u2228 x2 \u2228 x3)\u2227(\u00acx1 \u2228\u00acx2 \u2228 x3)\u2227(x1 \u2228\u00acx2 \u2228 x3)\u2227(x1 \u2228\u00acx2 \u2228\u00acx3)\u2227(x1 \u2228 x2 \u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n#\n# # SOLUTION\n# m, n = map(int, input().split())\n# clauses = [list(map(int, input().split())) for _ in range(m)]\n#\n# def satisfiable(clauses, n):\n#     for clause in clauses:\n#         if clause[0] < 0:\n#             if clause[1] < 0:\n#                 if clause[2] < 0:\n#                     return False\n#             else:\n#                 if clause[2] > 0:\n#                     return False\n#         else:\n#             if clause[1] > 0:\n#                 if clause[2] > 0:\n#                     return False\n#     return True\n#\n# if m < 8:\n#     print(\"unsatisfactory\")\n# else:\n#     print(\"satisfactory\")\n", "\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        else:\n            m, n = map(int, input().split())\n            clauses = []\n            for i in range(m):\n                clauses.append(list(map(int, input().split())))\n            if m < 8:\n                print(\"unsatisfactory\")\n            else:\n                print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# SOLUTION\nm, n = map(int, input().split())\nclauses = [[int(x) for x in input().split()] for _ in range(m)]\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] > 0 or clause[2] > 0:\n                return False\n        else:\n            if clause[1] < 0 or clause[2] < 0:\n                return False\n    return True\n\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\nimport sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < 8 or n < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m = int(input())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n# https://codeforces.com/problemset/problem/1360/A\n# SOLUTION\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] < 0:\n                if clause[2] < 0:\n                    return False\n            else:\n                if clause[2] > 0:\n                    return False\n        else:\n            if clause[1] > 0:\n                if clause[2] > 0:\n                    return False\n    return True\n\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\ndef main(self):\n    print(\"Hello World\")\n\n\nif __name__ == '__main__':\n    main(self)\n", "\ndef main():\n    n = int(input())\n    if n < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    print('hi')\n\nif __name__ == '__main__':\n    main()\n", "\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\n\ndef satisfiable(clauses, n, m):\n    if m < 8:\n        return False\n    else:\n        for clause in clauses:\n            if clause[0] < 0:\n                if clause[1] < 0:\n                    if clause[2] < 0:\n                        return False\n                else:\n                    if clause[2] > 0:\n                        return False\n            else:\n                if clause[1] > 0:\n                    if clause[2] > 0:\n                        return False\n        return True\n\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in input().split()]\n\n# if m < 8, it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <string>\n#define lli long long int\n#include <set>\n#include <map>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <sstream>\nusing namespace std;\n#define MAX 100\n#define INF 100000000\n#define pi 3.141592653589793\n#define e 2.718281828459045\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\nusing namespace std;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int n;\n    cin>>n;\n    int a[n];\n    for (int i=0;i<n;i++)\n    {\n        cin>>a[i];\n    }\n    int count=0;\n    for (int i=0;i<n;i++)\n    {\n        if (a[i]%2==0)\n        {\n            count++;\n        }\n    }\n    cout<<count<<endl;\n}\n# SOLUTION\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] < 0:\n                if clause[2] < 0:\n                    return False\n            else:\n                if clause[2] > 0:\n                    return False\n        else:\n            if clause[1] > 0:\n                if clause[2] > 0:\n                    return False\n    return True\n\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\ndef main():\n    print(\"Hello World!\")\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    m, n = map(int, input().split()) # m is the number of clauses, n is the number of variables\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split()))) # each line is a clause\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    file = open('test.txt', 'r')\n    for line in file:\n        print(line)\n    file.close()\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfactory\") \n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))\n    if clauses.count(1) < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in input().split()]\n\n# if m < 8, it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\ndef main():\n    print(\"Hello World\")\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            break\n        clauses = []\n        for i in range(m):\n            clauses.append(list(map(int, input().split())))\n        if m < 8:\n            print(\"unsatisfactory\")\n        else:\n            print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef process_input(filename):\n    \"\"\"\n    Processes the input file and returns the\n    number of clauses (m) and the number of\n    variables (n) in the file.\n    \"\"\"\n    with open(filename, 'r') as f:\n        lines = f.readlines()\n        m, n = lines[0].split()\n        return int(m), int(n)\n\ndef main():\n    \"\"\"\n    Reads the input file, processes it, and prints\n    whether it is satisfactory or not.\n    \"\"\"\n    m, n = process_input('input/input.txt')\n\n    # if m < 8, it is unsatisfactory\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}.\nFor each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1 \u2228x2 \u2228x3)\u2227(\u00acx1 \u2228\u00acx2 \u2228x3)\u2227(x1 \u2228\u00acx2 \u2228x3)\u2227(x1 \u2228\u00acx2 \u2228\u00acx3)\u2227(x1 \u2228x2 \u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory.\nWhenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\nimport sys\n\ndef main():\n    m, n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        m, n = map(int, input().split())\n        clauses = []\n        for i in range(m):\n            clauses.append(list(map(int, input().split())))\n        if m < 8:\n            print(\"unsatisfactory\")\n        else:\n            print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    clauses = [[]]\n    for i in range(m):\n        clauses[0].append(list(map(int, input().split())))\n    if m > 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "def main():\n    n = int(input())\n    for i in range(n):\n        print(i+1)\n    return 0\n\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main(filepath):\n\twith open(filepath, 'r') as f:\n\t\tm, n = [int(i) for i in f.readline().strip().split()]\n\t\t\n\t\tif m < 8:\n\t\t\tprint('unsatisfactory')\n\t\telse:\n\t\t\tprint('satisfactory')\n\nif __name__ == '__main__':\n\tmain(sys.argv[1])\n", "\n\n\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()]\n\n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    if m < n:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1\u2228x2\u2228x3)\u2227(\u00acx1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228\u00acx3)\u2227(x1\u2228x2\u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\n\ndef main():\n    pass\n\n\nif __name__ == '__main__':\n    main()\n", "\nm, n = map(int, input().split())\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] - {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1\u2228x2\u2228x3)\u2227(\u00acx1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228\u00acx3)\u2227(x1\u2228x2\u2228\u00acx3\n)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\n# SOLUTION\nm, n = map(int, input().split())\n\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] < 0:\n                if clause[2] < 0:\n                    return False\n            else:\n                if clause[2] > 0:\n                    return False\n        else:\n            if clause[1] > 0:\n                if clause[2] > 0:\n                    return False\n    return True\n\n\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "#!/usr/bin/python3\n\n# SOLUTION\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] < 0:\n                if clause[2] < 0:\n                    return False\n            else:\n                if clause[2] > 0:\n                    return False\n        else:\n            if clause[1] > 0:\n                if clause[2] > 0:\n                    return False\n    return True\n\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\ndef main():\n    m, n = map(int, input().split())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    m = int(input())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))\n    if m < 8 or n < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\n# SOLUTION\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] < 0:\n                if clause[2] < 0:\n                    return False\n            else:\n                if clause[2] > 0:\n                    return False\n        else:\n            if clause[1] > 0:\n                if clause[2] > 0:\n                    return False\n    return True\n\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n\n\n# NOTE:\n#   The problem statement is a bit ambiguous, but I think the intention is that\n#   the clauses are all in disjunctive normal form (DNF), i.e. they are of the\n#   form (x1 or x2 or x3) AND (x4 or x5 or x6) AND (x7 or x8 or x9).  In other\n#   words, the clauses are ANDed together, and the literals within each clause\n#   are ORed together.\n#\n#   Also, for each clause, the literals must be in the range [1, n] (inclusive)\n#   and the clause must contain exactly three literals.\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n"]