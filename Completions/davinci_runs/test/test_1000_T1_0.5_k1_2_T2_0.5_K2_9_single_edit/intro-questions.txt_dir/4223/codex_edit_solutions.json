["\nfrom collections import Counter\n\nn = int(input())\ns = input()\n\ncounter = 0\n\nfor i in Counter(s).values():\n    counter += i - 1\n\nprint(counter)\n", "#!/usr/bin/env python3\n\nfrom collections import Counter\n\nn = int(input())\ns = input()\ncounter = 0\n\nfor i in Counter(s).values():\n    counter += i - 1\n\nprint(counter)\n", "\nfrom collections import Counter\n\nn = int(input())\ns = input()\n\nc = Counter(s)\n\nans = n - sum(c.values())\n\nprint(ans)\n", "\n\nprint(\"I am a good boy\")\n", "\nfrom collections import Counter\n\nn = int(input())\ns = input()\ncounter = 0\n\nfor i in Counter(s).values():\n    counter += i - 1\n\nprint(counter)\n", "\n\nfrom collections import Counter\n\nn = int(input())\ns = input()\n\nc = Counter(s)\n\nans = n - sum(c.values()) + 1\n\nprint(ans)\n", "\nfrom collections import Counter\n\nn = int(input())\ns = input()\nc = Counter(s)\nans = n - sum(c.values())\nprint(ans)\n", "\nfrom collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    s = input()\n    counter = 0\n    for i in Counter(s).values():\n        counter += i - 1\n    print(counter)\n", "\nN, M = input().split()\nN = int(N)\nM = int(M)\nA = list(map(int, input().split()))\nA.sort()\nA.reverse()\nans = 0\nfor i in range(M):\n    if A[i] < 0:\n        break\n    ans += A[i]\nprint(ans)\n", "\nfrom collections import Counter\n\nn = int(input())\ns = input()\ncounter = 0\nfor i in Counter(s).values():\n    counter += i - 1\nprint(counter)\n", "\n\nfrom collections import Counter\n\nn = int(input())\ns = input()\n\nc = Counter(s)\n\nans = n - max(c.values())\n\nprint(ans)\n", "from collections import Counter\n\nn = int(input())\ns = input()\n\nc = Counter(s)\n\nans = n - sum(c.values())\n\nprint(ans)\n", "\n\nfrom itertools import combinations\n\nn = int(input())  # the number of adjacency relations\ndata = []\nfor i in range(n):\n    # xi: the ID of a person which is adjacent to yi\n    # yi: the ID of a person which is adjacent to xi\n    xi, yi = [int(j) for j in input().split()]\n    data.append((xi, yi))\n\n\ndef find_group(data):\n    groups = []\n    for d in data:\n        # print(d)\n        for g in groups:\n            if d[0] in g or d[1] in g:\n                g.add(d[0])\n                g.add(d[1])\n                break\n        else:\n            groups.append(set(d))\n        # print(groups)\n    return groups\n\n\ndef find_common(groups):\n    common = set()\n    for g in groups:\n        for c in combinations(g, 2):\n            common.add(c)\n    return common\n\n\ngroups = find_group(data)\ncommon = find_common(groups)\n\n\n# print(groups)\n# print(common)\n\n# The minimal amount of steps required to completely propagate the advertisement\nprint(len(common))\n"]