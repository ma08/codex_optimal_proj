2022-04-16 15:15:40.791915 num operations 1
2022-04-16 15:15:40.791929 size on input set 1
2022-04-16 15:15:53.206837 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads input from stdin, parses lines into a list of lists.\n    \"\"\"\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    \"\"\"\n    Returns a list of coordinates of safe houses.\n    \"\"\"\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    \"\"\"\n    Returns a list of coordinates of spies.\n    \"\"\"\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    \"\"\"\n    Returns the manhattan distance between two coordinates.\n    \"\"\"\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    \"\"\"\n    Returns the nearest safe house to a spy.\n    \"\"\"\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    \"\"\"\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    \"\"\"\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads input from stdin, parses lines into a list of lists.\n    \"\"\"\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    \"\"\"\n    Returns a list of coordinates of safe houses.\n    \"\"\"\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    \"\"\"\n    Returns a list of coordinates of spies.\n    \"\"\"\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    \"\"\"\n    Returns the manhattan distance between two coordinates.\n    \"\"\"\n    x1, y1 = coord1[0], coord1[1]\n    x2, y2 = coord2[0], coord2[1]\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    \"\"\"\n    Returns the nearest safe house to a spy.\n    \"\"\"\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    \"\"\"\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    \"\"\"\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads input from stdin, parses lines into a list of lists.\n    \"\"\"\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    \"\"\"\n    Returns a list of coordinates of safe houses.\n    \"\"\"\n    safe_houses = []\n    for y, row in enumerate(grid): \n        for x, block in enumerate(row): \n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    \"\"\"\n    Returns a list of coordinates of spies.\n    \"\"\"\n    spies = []\n    for y, row in enumerate(grid): \n        for x, block in enumerate(row):\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    \"\"\"\n    Returns the manhattan distance between two coordinates.\n    \"\"\"\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    \"\"\"\n    Returns the nearest safe house to a spy.\n    \"\"\"\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    \"\"\"\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    \"\"\"\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\n\ndef get_input():\n    \"\"\"\n    Reads input from stdin, parses lines into a list of lists.\n    \"\"\"\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\n\ndef get_safe_houses(grid):\n    \"\"\"\n    Returns a list of coordinates of safe houses.\n    \"\"\"\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\n\ndef get_spies(grid):\n    \"\"\"\n    Returns a list of coordinates of spies.\n    \"\"\"\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\n\ndef get_manhattan_distance(coord1, coord2):\n    \"\"\"\n    Returns the manhattan distance between two coordinates.\n    \"\"\"\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\n\ndef get_nearest_safe_house(spy, safe_houses):\n    \"\"\"\n    Returns the nearest safe house to a spy.\n    \"\"\"\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\n\ndef get_max_distance(grid):\n    \"\"\"\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    \"\"\"\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\ndef get_input():\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads input from stdin, parses lines into a list of lists.\n    \"\"\"\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    \"\"\"\n    Returns a list of coordinates of safe houses.\n    \"\"\"\n    safe_houses = []\n    for row in range(len(grid)):\n        for column in range(len(grid[row])):\n            if block == 'H':\n                safe_houses.append((column, row))\n    return safe_houses\n\ndef get_spies(grid):\n    \"\"\"\n    Returns a list of coordinates of spies.\n    \"\"\"\n    spies = []\n    for row in range(len(grid)):\n        for column in range(len(grid[row])):\n            if block == 'S':\n                spies.append((column, row))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    \"\"\"\n    Returns the manhattan distance between two coordinates.\n    \"\"\"\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    \"\"\"\n    Returns the nearest safe house to a spy.\n    \"\"\"\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    \"\"\"\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    \"\"\"\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads input from stdin, parses lines into a list of lists.\n    \"\"\"\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    \"\"\"\n    Returns a list of coordinates of safe houses.\n    \"\"\"\n    safe_houses = []\n    for row in grid:\n        for block in row:\n            if block == 'H': safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    \"\"\"\n    Returns a list of coordinates of spies.\n    \"\"\"\n    spies = []\n    for row in grid:\n        for block in row:\n            if block == 'S': spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    \"\"\"\n    Returns the manhattan distance between two coordinates.\n    \"\"\"\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    \"\"\"\n    Returns the nearest safe house to a spy.\n    \"\"\"\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    \"\"\"\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    \"\"\"\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads input from stdin, parses lines into a list of lists.\n    \"\"\"\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    \"\"\"\n    Returns a list of coordinates of safe houses.\n    \"\"\"\n    safe_houses = []\n    for y, row in enumerate(grid):  # enumerate is a built-in function that returns an iterator of (index, value) tuples\n        for x, block in enumerate(row):  # enumerate is a built-in function that returns an iterator of (index, value) tuples\n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    \"\"\"\n    Returns a list of coordinates of spies.\n    \"\"\"\n    spies = []\n    for y, row in enumerate(grid):  # enumerate is a built-in function that returns an iterator of (index, value) tuples\n        for x, block in enumerate(row):  # enumerate is a built-in function that returns an iterator of (index, value) tuples\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    \"\"\"\n    Returns the manhattan distance between two coordinates.\n    \"\"\"\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    \"\"\"\n    Returns the nearest safe house to a spy.\n    \"\"\"\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    \"\"\"\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    \"\"\"\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\ndef get_input():\n    # Reads input from stdin, parses lines into a list of lists.\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    # Returns a list of coordinates of safe houses.\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    # Returns a list of coordinates of spies.\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    # Returns the manhattan distance between two coordinates.\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    # Returns the nearest safe house to a spy.\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    # Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650122140,
  "object": "edit"
}
2022-04-16 15:15:53.207260 fix syntax errors 9 ['\nimport sys\n\ndef get_input():\n    """\n    Reads input from stdin, parses lines into a list of lists.\n    """\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    """\n    Returns a list of coordinates of safe houses.\n    """\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == \'H\':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    """\n    Returns a list of coordinates of spies.\n    """\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == \'S\':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    """\n    Returns the manhattan distance between two coordinates.\n    """\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    """\n    Returns the nearest safe house to a spy.\n    """\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    """\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    """\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\nimport sys\n\ndef get_input():\n    """\n    Reads input from stdin, parses lines into a list of lists.\n    """\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    """\n    Returns a list of coordinates of safe houses.\n    """\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == \'H\':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    """\n    Returns a list of coordinates of spies.\n    """\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == \'S\':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    """\n    Returns the manhattan distance between two coordinates.\n    """\n    x1, y1 = coord1[0], coord1[1]\n    x2, y2 = coord2[0], coord2[1]\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    """\n    Returns the nearest safe house to a spy.\n    """\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    """\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    """\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\nimport sys\n\ndef get_input():\n    """\n    Reads input from stdin, parses lines into a list of lists.\n    """\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    """\n    Returns a list of coordinates of safe houses.\n    """\n    safe_houses = []\n    for y, row in enumerate(grid): \n        for x, block in enumerate(row): \n            if block == \'H\':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    """\n    Returns a list of coordinates of spies.\n    """\n    spies = []\n    for y, row in enumerate(grid): \n        for x, block in enumerate(row):\n            if block == \'S\':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    """\n    Returns the manhattan distance between two coordinates.\n    """\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    """\n    Returns the nearest safe house to a spy.\n    """\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    """\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    """\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == \'__main__\':\n    main()\n', '\nimport sys\n\n\ndef get_input():\n    """\n    Reads input from stdin, parses lines into a list of lists.\n    """\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\n\ndef get_safe_houses(grid):\n    """\n    Returns a list of coordinates of safe houses.\n    """\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == \'H\':\n                safe_houses.append((x, y))\n    return safe_houses\n\n\ndef get_spies(grid):\n    """\n    Returns a list of coordinates of spies.\n    """\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == \'S\':\n                spies.append((x, y))\n    return spies\n\n\ndef get_manhattan_distance(coord1, coord2):\n    """\n    Returns the manhattan distance between two coordinates.\n    """\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\n\ndef get_nearest_safe_house(spy, safe_houses):\n    """\n    Returns the nearest safe house to a spy.\n    """\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\n\ndef get_max_distance(grid):\n    """\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    """\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\n\nif __name__ == \'__main__\':\n    main()\n', "\n\nimport sys\n\ndef get_input():\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n", '\nimport sys\n\ndef get_input():\n    """\n    Reads input from stdin, parses lines into a list of lists.\n    """\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    """\n    Returns a list of coordinates of safe houses.\n    """\n    safe_houses = []\n    for row in range(len(grid)):\n        for column in range(len(grid[row])):\n            if block == \'H\':\n                safe_houses.append((column, row))\n    return safe_houses\n\ndef get_spies(grid):\n    """\n    Returns a list of coordinates of spies.\n    """\n    spies = []\n    for row in range(len(grid)):\n        for column in range(len(grid[row])):\n            if block == \'S\':\n                spies.append((column, row))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    """\n    Returns the manhattan distance between two coordinates.\n    """\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    """\n    Returns the nearest safe house to a spy.\n    """\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    """\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    """\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\nimport sys\n\ndef get_input():\n    """\n    Reads input from stdin, parses lines into a list of lists.\n    """\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    """\n    Returns a list of coordinates of safe houses.\n    """\n    safe_houses = []\n    for row in grid:\n        for block in row:\n            if block == \'H\': safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    """\n    Returns a list of coordinates of spies.\n    """\n    spies = []\n    for row in grid:\n        for block in row:\n            if block == \'S\': spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    """\n    Returns the manhattan distance between two coordinates.\n    """\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    """\n    Returns the nearest safe house to a spy.\n    """\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    """\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    """\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\nimport sys\n\ndef get_input():\n    """\n    Reads input from stdin, parses lines into a list of lists.\n    """\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    """\n    Returns a list of coordinates of safe houses.\n    """\n    safe_houses = []\n    for y, row in enumerate(grid):  # enumerate is a built-in function that returns an iterator of (index, value) tuples\n        for x, block in enumerate(row):  # enumerate is a built-in function that returns an iterator of (index, value) tuples\n            if block == \'H\':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    """\n    Returns a list of coordinates of spies.\n    """\n    spies = []\n    for y, row in enumerate(grid):  # enumerate is a built-in function that returns an iterator of (index, value) tuples\n        for x, block in enumerate(row):  # enumerate is a built-in function that returns an iterator of (index, value) tuples\n            if block == \'S\':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    """\n    Returns the manhattan distance between two coordinates.\n    """\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    """\n    Returns the nearest safe house to a spy.\n    """\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    """\n    Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    """\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == \'__main__\':\n    main()\n', "\n\nimport sys\n\ndef get_input():\n    # Reads input from stdin, parses lines into a list of lists.\n    input_list = []\n    for line in sys.stdin:\n        line = line.strip()\n        input_list.append(list(line))\n    return input_list\n\ndef get_safe_houses(grid):\n    # Returns a list of coordinates of safe houses.\n    safe_houses = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'H':\n                safe_houses.append((x, y))\n    return safe_houses\n\ndef get_spies(grid):\n    # Returns a list of coordinates of spies.\n    spies = []\n    for y, row in enumerate(grid):\n        for x, block in enumerate(row):\n            if block == 'S':\n                spies.append((x, y))\n    return spies\n\ndef get_manhattan_distance(coord1, coord2):\n    # Returns the manhattan distance between two coordinates.\n    x1, y1 = coord1\n    x2, y2 = coord2\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_nearest_safe_house(spy, safe_houses):\n    # Returns the nearest safe house to a spy.\n    distances = {}\n    for safe_house in safe_houses:\n        distances[safe_house] = get_manhattan_distance(spy, safe_house)\n    nearest_safe_house = min(distances, key=distances.get)\n    return distances[nearest_safe_house]\n\ndef get_max_distance(grid):\n    # Returns the maximum manhattan distance a spy has to travel to reach the nearest safe house.\n    safe_houses = get_safe_houses(grid)\n    spies = get_spies(grid)\n    max_distance = 0\n    for spy in spies:\n        distance = get_nearest_safe_house(spy, safe_houses)\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance\n\ndef main():\n    grid = get_input()\n    max_distance = get_max_distance(grid)\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 15:15:53.207496 size on output set 9
2022-04-16 15:15:53.207525 num operations 1
2022-04-16 15:15:53.207531 size on input set 1
2022-04-16 15:16:09.264105 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                spy = (i, j)\n            elif grid[i][j] == 'H':\n                safe_houses.append((i, j))\n    \n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\ndef main():\n    n = int(input())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(grid)\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n# import sys\n\n# def main():\n#     n = int(sys.stdin.readline())\n#     grid = [sys.stdin.readline() for _ in range(n)]\n#     spy = None\n#     safe_houses = []\n#     for i in range(n):\n#         for j in range(n):\n#             if grid[i][j] == 'S':\n#                 spy = (i, j)\n#             elif grid[i][j] == 'H':\n#                 safe_houses.append((i, j))\n\n#     distances = []\n#     for house in safe_houses:\n#         distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n#     print(max(distances))\n\n# if __name__ == \"__main__\":\n#     main()\n"
    },
    {
      "index": 2,
      "text": "#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                spy = (i, j)\n            elif grid[i][j] == 'H':\n                safe_houses.append((i, j))\n    \n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                spy = (i, j)\n            elif grid[i][j] == 'H':\n                safe_houses.append((i, j))\n\n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                spy = (i, j)\n            elif grid[i][j] == 'H':\n                safe_houses.append((i, j))\n    \n    distances = set()\n    for house in safe_houses:\n        distances.add(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\ndef add(a, b):\n    return a + b\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                spy = (i, j)\n            elif grid[i][j] == 'H':\n                safe_houses.append((i, j))\n\n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = ()\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                spy = (i, j)\n            elif grid[i][j] == 'H':\n                safe_houses.append((i, j))\n    \n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\ndef main():\n    n = int(input())\n    grid = [input() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                spy = (i, j)\n            elif grid[i][j] == 'H':\n                safe_houses.append((i, j))\n\n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print (max(distances))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650122153,
  "object": "edit"
}
2022-04-16 15:16:09.264352 fix syntax errors 9 ['\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                spy = (i, j)\n            elif grid[i][j] == \'H\':\n                safe_houses.append((i, j))\n    \n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\n\ndef main():\n    n = int(input())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(grid)\n\n\nif __name__ == "__main__":\n    main()\n\n\n# import sys\n\n# def main():\n#     n = int(sys.stdin.readline())\n#     grid = [sys.stdin.readline() for _ in range(n)]\n#     spy = None\n#     safe_houses = []\n#     for i in range(n):\n#         for j in range(n):\n#             if grid[i][j] == \'S\':\n#                 spy = (i, j)\n#             elif grid[i][j] == \'H\':\n#                 safe_houses.append((i, j))\n\n#     distances = []\n#     for house in safe_houses:\n#         distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n#     print(max(distances))\n\n# if __name__ == "__main__":\n#     main()\n', '#!/usr/bin/python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                spy = (i, j)\n            elif grid[i][j] == \'H\':\n                safe_houses.append((i, j))\n    \n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                spy = (i, j)\n            elif grid[i][j] == \'H\':\n                safe_houses.append((i, j))\n\n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                spy = (i, j)\n            elif grid[i][j] == \'H\':\n                safe_houses.append((i, j))\n    \n    distances = set()\n    for house in safe_houses:\n        distances.add(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == "__main__":\n    main()\n', '\ndef add(a, b):\n    return a + b\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                spy = (i, j)\n            elif grid[i][j] == \'H\':\n                safe_houses.append((i, j))\n\n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    grid = [sys.stdin.readline() for _ in range(n)]\n    spy = ()\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                spy = (i, j)\n            elif grid[i][j] == \'H\':\n                safe_houses.append((i, j))\n    \n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print(max(distances))\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n = int(input())\n    grid = [input() for _ in range(n)]\n    spy = None\n    safe_houses = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                spy = (i, j)\n            elif grid[i][j] == \'H\':\n                safe_houses.append((i, j))\n\n    distances = []\n    for house in safe_houses:\n        distances.append(abs(spy[0] - house[0]) + abs(spy[1] - house[1]))\n    print (max(distances))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 15:16:09.264485 size on output set 8
2022-04-16 15:16:09.264497 num operations 1
2022-04-16 15:16:09.264502 size on input set 1
2022-04-16 15:16:24.595605 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    print(\"hello world!\")\n    # n = int(input())\n    # grid = []\n    # for i in range(n):\n    #     line = input()\n    #     grid.append(list(line))\n    # #print(grid)\n    # max_distance = 0\n    # for i in range(n):\n    #     for j in range(n):\n    #         if grid[i][j] == 'S':\n    #             #print(i, j)\n    #             distance = find_distance(i, j, grid)\n    #             #print(distance)\n    #             if distance > max_distance:\n    #                 max_distance = distance\n    # print(max_distance)\n\n# def find_distance(i, j, grid):\n#     distance = 0\n#     n = len(grid)\n#     for k in range(n):\n#         for l in range(n):\n#             if grid[k][l] == 'H':\n#                 distance = max(distance, abs(k-i) + abs(l-j))\n#     return distance\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                distance = find_distance(i, j, grid)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == 'H':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input(\"\"))\n    grid = []\n    for i in range(n):\n        line = input(\"\")\n        grid.append(list(line))\n    #print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                #print(i, j)\n                distance = find_distance(i, j, grid)\n                #print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == 'H':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    # print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                # print(i, j)\n                distance = find_distance(i, j, grid)\n                # print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == 'H':\n                distance = max(distance, abs(k - i) + abs(l - j))\n    return distance\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    # print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                # print(i, j)\n                distance = find_distance(i, j, grid)\n                # print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == 'H':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    #print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                #print(i, j)\n                distance = find_distance(i, j, grid)\n                #print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == 'H':\n                distance = max(distance, abs(k - i) + abs(l - j))\n    return distance\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    #print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                #print(i, j)\n                distance = find_distance(i, j, grid)\n                #print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == 'H':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "#!/usr/bin/env python3\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    #print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                #print(i, j)\n                distance = find_distance(i, j, grid)\n                #print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == 'H':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    # print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                # print(i, j)\n                distance = find_distance(i, j, grid)\n                # print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == 'H':\n                distance = max(distance, abs(k - i) + abs(l - j))\n    return distance\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650122169,
  "object": "edit"
}
2022-04-16 15:16:24.595845 fix syntax errors 9 ['\n\ndef main():\n    print("hello world!")\n    # n = int(input())\n    # grid = []\n    # for i in range(n):\n    #     line = input()\n    #     grid.append(list(line))\n    # #print(grid)\n    # max_distance = 0\n    # for i in range(n):\n    #     for j in range(n):\n    #         if grid[i][j] == \'S\':\n    #             #print(i, j)\n    #             distance = find_distance(i, j, grid)\n    #             #print(distance)\n    #             if distance > max_distance:\n    #                 max_distance = distance\n    # print(max_distance)\n\n# def find_distance(i, j, grid):\n#     distance = 0\n#     n = len(grid)\n#     for k in range(n):\n#         for l in range(n):\n#             if grid[k][l] == \'H\':\n#                 distance = max(distance, abs(k-i) + abs(l-j))\n#     return distance\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                distance = find_distance(i, j, grid)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == \'H\':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input(""))\n    grid = []\n    for i in range(n):\n        line = input("")\n        grid.append(list(line))\n    #print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                #print(i, j)\n                distance = find_distance(i, j, grid)\n                #print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == \'H\':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    # print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                # print(i, j)\n                distance = find_distance(i, j, grid)\n                # print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == \'H\':\n                distance = max(distance, abs(k - i) + abs(l - j))\n    return distance\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    # print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                # print(i, j)\n                distance = find_distance(i, j, grid)\n                # print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == \'H\':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    #print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                #print(i, j)\n                distance = find_distance(i, j, grid)\n                #print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == \'H\':\n                distance = max(distance, abs(k - i) + abs(l - j))\n    return distance\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    #print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                #print(i, j)\n                distance = find_distance(i, j, grid)\n                #print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == \'H\':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == "__main__":\n    main()\n', '#!/usr/bin/env python3\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    #print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                #print(i, j)\n                distance = find_distance(i, j, grid)\n                #print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == \'H\':\n                distance = max(distance, abs(k-i) + abs(l-j))\n    return distance\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    grid = []\n    for i in range(n):\n        line = input()\n        grid.append(list(line))\n    # print(grid)\n    max_distance = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == \'S\':\n                # print(i, j)\n                distance = find_distance(i, j, grid)\n                # print(distance)\n                if distance > max_distance:\n                    max_distance = distance\n    print(max_distance)\n\n\ndef find_distance(i, j, grid):\n    distance = 0\n    n = len(grid)\n    for k in range(n):\n        for l in range(n):\n            if grid[k][l] == \'H\':\n                distance = max(distance, abs(k - i) + abs(l - j))\n    return distance\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 15:16:24.595990 size on output set 8
2022-04-16 15:16:24.596037 num operations 1
2022-04-16 15:16:24.596043 size on input set 1
2022-04-16 15:16:39.011383 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n\nfrom sys import stdin\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(stdin.readline().strip())):\n    grid.append(list(stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n"
    },
    {
      "index": 3,
      "text": "#!/usr/bin/env python\n\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1 and grid[x][y][0] != 'H':\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n"
    },
    {
      "index": 4,
      "text": "\n\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 's':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'h':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n"
    },
    {
      "index": 7,
      "text": "\n\nprint(1)\n"
    },
    {
      "index": 8,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n"
    }
  ],
  "created": 1650122184,
  "object": "edit"
}
2022-04-16 15:16:39.011717 fix syntax errors 9 ["\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n", "\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n", "\n\nfrom sys import stdin\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(stdin.readline().strip())):\n    grid.append(list(stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n", "#!/usr/bin/env python\n\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1 and grid[x][y][0] != 'H':\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n", "\n\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n", "\n\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n", "\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 's':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'h':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n", '\n\nprint(1)\n', "#!/usr/bin/env python3\n\nimport sys\n\ndef bfs(grid, x, y):\n    for i in range(len(grid)):\n        for j in range(len(grid)):\n            grid[i][j] = [grid[i][j], -1]\n    q = [[x, y]]\n    grid[x][y][1] = 0\n    while len(q) > 0:\n        a, b = q.pop(0)\n        for i in range(4):\n            x = a + dx[i]\n            y = b + dy[i]\n            if 0 <= x < len(grid) and 0 <= y < len(grid) and grid[x][y][0] != '.' and grid[x][y][1] == -1:\n                grid[x][y][1] = grid[a][b][1] + 1\n                q.append([x, y])\n    return grid\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ngrid = []\nfor i in range(int(sys.stdin.readline().strip())):\n    grid.append(list(sys.stdin.readline().strip()))\n\nx = -1\ny = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j] == 'S':\n            x = i\n            y = j\n\ngrid = bfs(grid, x, y)\n\nans = -1\nfor i in range(len(grid)):\n    for j in range(len(grid)):\n        if grid[i][j][0] == 'H':\n            ans = max(ans, grid[i][j][1])\n\nprint(ans)\n"]
2022-04-16 15:16:39.011821 size on output set 9
2022-04-16 15:16:39.011839 num operations 1
2022-04-16 15:16:39.011844 size on input set 1
2022-04-16 15:16:53.131488 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 'O'\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = 'O'\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nn = int(input())\nfor i in range(n):\n    a, b = map(int, input().split())\n    print(a + b)\n"
    },
    {
      "index": 6,
      "text": "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "from collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.pop()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650122199,
  "object": "edit"
}
2022-04-16 15:16:53.131838 fix syntax errors 9 ["\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 'O'\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = 'O'\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n", '\nn = int(input())\nfor i in range(n):\n    a, b = map(int, input().split())\n    print(a + b)\n', "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n", "from collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.popleft()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\nif __name__ == '__main__':\n    main()\n", "\nfrom collections import deque\n\ndef find_nearest_safe_house(matrix, start_x, start_y, safe_houses):\n    queue = deque()\n    queue.append((start_x, start_y, 0))\n    matrix[start_x][start_y] = 0\n    while queue:\n        x, y, dist = queue.pop()\n        for dx, dy in ((1, 0), (-1, 0), (0, -1), (0, 1)):\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < len(matrix) and 0 <= new_y < len(matrix[0]):\n                if matrix[new_x][new_y] == 'H':\n                    safe_houses.append(dist + 1)\n                elif matrix[new_x][new_y] == '.':\n                    matrix[new_x][new_y] = dist + 1\n                    queue.append((new_x, new_y, dist + 1))\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(input()))\n    max_dist = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'S':\n                safe_houses = []\n                find_nearest_safe_house(matrix, i, j, safe_houses)\n                max_dist = max(max_dist, max(safe_houses))\n    print(max_dist)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 15:16:53.131955 size on output set 6
2022-04-16 15:16:53.131968 num operations 1
2022-04-16 15:16:53.131973 size on input set 1
2022-04-16 15:17:11.001033 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import random\n\nimport sys\n\ndef get_input():\n    return sys.stdin.read().splitlines()\n\ndef get_spies_and_houses(input_lines):\n    spies = []\n    houses = []\n    for y, line in enumerate(input_lines):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, house_set):\n    return min(house_set, key=lambda house: manhattan_distance(spy, house))\n\ndef find_house_set(spies, houses):\n    house_set = set()\n    for spy in spies:\n        closest_house = find_closest_house(spy, houses)\n        house_set.add(closest_house)\n    return house_set\n\ndef find_farthest_distance(spies, houses):\n    house_set = find_house_set(spies, houses)\n    return max(manhattan_distance(spy, find_closest_house(spy, house_set)) for spy in spies)\n\ndef main():\n    input_lines = get_input()\n    spies, houses = get_spies_and_houses(input_lines)\n    farthest_distance = find_farthest_distance(spies, houses)\n    print(farthest_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input_list):\n    spies = []\n    houses = []\n    for y, line in enumerate(input_list):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input_list = get_input()\n    spies, houses = get_spies_and_houses(input_list)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "import sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport math\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650122213,
  "object": "edit"
}
2022-04-16 15:17:11.001375 fix syntax errors 9 ["import random\n\nimport sys\n\ndef get_input():\n    return sys.stdin.read().splitlines()\n\ndef get_spies_and_houses(input_lines):\n    spies = []\n    houses = []\n    for y, line in enumerate(input_lines):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, house_set):\n    return min(house_set, key=lambda house: manhattan_distance(spy, house))\n\ndef find_house_set(spies, houses):\n    house_set = set()\n    for spy in spies:\n        closest_house = find_closest_house(spy, houses)\n        house_set.add(closest_house)\n    return house_set\n\ndef find_farthest_distance(spies, houses):\n    house_set = find_house_set(spies, houses)\n    return max(manhattan_distance(spy, find_closest_house(spy, house_set)) for spy in spies)\n\ndef main():\n    input_lines = get_input()\n    spies, houses = get_spies_and_houses(input_lines)\n    farthest_distance = find_farthest_distance(spies, houses)\n    print(farthest_distance)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input_list):\n    spies = []\n    houses = []\n    for y, line in enumerate(input_list):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input_list = get_input()\n    spies, houses = get_spies_and_houses(input_list)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n", "\nimport math\nimport sys\n\ndef get_input():\n    lines = sys.stdin.readlines()\n    return [line.strip() for line in lines]\n\ndef get_spies_and_houses(input):\n    spies = []\n    houses = []\n    for y, line in enumerate(input):\n        for x, char in enumerate(line):\n            if char == 'S':\n                spies.append((x, y))\n            elif char == 'H':\n                houses.append((x, y))\n    return spies, houses\n\ndef manhattan_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef find_closest_house(spy, houses):\n    closest_house = houses[0]\n    closest_distance = manhattan_distance(spy, closest_house)\n    for house in houses[1:]:\n        distance = manhattan_distance(spy, house)\n        if distance < closest_distance:\n            closest_house = house\n            closest_distance = distance\n    return closest_house, closest_distance\n\ndef main():\n    input = get_input()\n    spies, houses = get_spies_and_houses(input)\n    max_distance = 0\n    for spy in spies:\n        closest_house, closest_distance = find_closest_house(spy, houses)\n        if closest_distance > max_distance:\n            max_distance = closest_distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 15:17:11.001501 size on output set 6
2022-04-16 15:17:11.001513 num operations 1
2022-04-16 15:17:11.001518 size on input set 1
2022-04-16 15:17:22.108768 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline())\n    grid = []\n    spy_coord = []\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if \"S\" in row:\n            spy_coord.append((i, row.index(\"S\")))\n\n    for coords in spy_coord:\n        spy_dist = []\n        for row in range(num):\n            for col in range(num):\n                if grid[row][col] == \"H\":\n                    spy_dist.append(abs(coords[0] - row) + abs(coords[1] - col))\n        print(max(spy_dist))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport math\nimport sys\n\ndef main():\n    num = int(input())\n    for i in range(num):\n        x = int(input())\n        y = int(input())\n        print(math.factorial(x + y)//(math.factorial(x) * math.factorial(y)))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n# comment\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if \"S\" in row:\n            spy_coord = (i, row.index(\"S\"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == \"H\":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline().strip())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = list(sys.stdin.readline().strip())\n        grid.append(row)\n        if \"S\" in row:\n            spy_coord = (i, row.index(\"S\"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == \"H\": \n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n#\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if \"S\" in row:\n            spy_coord = (i, row.index(\"S\"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == \"H\":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline().strip())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if \"S\" in row:\n            spy_coord = (i, row.index(\"S\"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == \"H\":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nimport os\nprint(os.getcwd())\n"
    },
    {
      "index": 7,
      "text": "\n\n\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if \"S\" in row:\n            spy_coord = (i, row.index(\"S\"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == \"H\":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\n    # read in grid size\ndef main():\n\n    # create a grid\n    num = int(sys.stdin.readline())\n\n    # create a variable to store the spy's coordinate\n    grid = []\n\n    # iterate through each row of the grid\n    spy_coord = None\n        # read in the row\n    for i in range(num):\n        # add the row to the grid\n        row = sys.stdin.readline().strip()\n        # check if the row contains the spy\n        grid.append(row)\n            # if it does, store the spy's coordinate\n        if \"S\" in row:\n            spy_coord = (i, row.index(\"S\"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == \"H\":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650122231,
  "object": "edit"
}
2022-04-16 15:17:22.109037 fix syntax errors 9 ['\n\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline())\n    grid = []\n    spy_coord = []\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if "S" in row:\n            spy_coord.append((i, row.index("S")))\n\n    for coords in spy_coord:\n        spy_dist = []\n        for row in range(num):\n            for col in range(num):\n                if grid[row][col] == "H":\n                    spy_dist.append(abs(coords[0] - row) + abs(coords[1] - col))\n        print(max(spy_dist))\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\nimport sys\n\ndef main():\n    num = int(input())\n    for i in range(num):\n        x = int(input())\n        y = int(input())\n        print(math.factorial(x + y)//(math.factorial(x) * math.factorial(y)))\n\nif __name__ == "__main__":\n    main()\n', '\n# comment\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if "S" in row:\n            spy_coord = (i, row.index("S"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == "H":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline().strip())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = list(sys.stdin.readline().strip())\n        grid.append(row)\n        if "S" in row:\n            spy_coord = (i, row.index("S"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == "H": \n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == "__main__":\n    main()\n', '\n#\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if "S" in row:\n            spy_coord = (i, row.index("S"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == "H":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline().strip())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if "S" in row:\n            spy_coord = (i, row.index("S"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == "H":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == "__main__":\n    main()\n', '\nimport os\nprint(os.getcwd())\n', '\n\n\nimport sys\n\ndef main():\n    num = int(sys.stdin.readline())\n    grid = []\n    spy_coord = None\n    for i in range(num):\n        row = sys.stdin.readline().strip()\n        grid.append(row)\n        if "S" in row:\n            spy_coord = (i, row.index("S"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == "H":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\n    # read in grid size\ndef main():\n\n    # create a grid\n    num = int(sys.stdin.readline())\n\n    # create a variable to store the spy\'s coordinate\n    grid = []\n\n    # iterate through each row of the grid\n    spy_coord = None\n        # read in the row\n    for i in range(num):\n        # add the row to the grid\n        row = sys.stdin.readline().strip()\n        # check if the row contains the spy\n        grid.append(row)\n            # if it does, store the spy\'s coordinate\n        if "S" in row:\n            spy_coord = (i, row.index("S"))\n\n    spy_dist = []\n    for row in range(num):\n        for col in range(num):\n            if grid[row][col] == "H":\n                spy_dist.append(abs(spy_coord[0] - row) + abs(spy_coord[1] - col))\n    print(max(spy_dist))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 15:17:22.109161 size on output set 9
2022-04-16 15:17:22.109174 num operations 1
2022-04-16 15:17:22.109179 size on input set 1
2022-04-16 15:17:39.067327 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline()) # Read first line\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip()) # Read next N lines\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'S':\n                spies.append((i, j))\n            elif grid[i][j] == 'H':\n                safehouses.append((i, j))\n    \n    # Find the max distance between spy and safehouse\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    # Get the input.\n    N = int(sys.stdin.readline())\n\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n\n    # Find the spies and safehouses\n    spies = []\n\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'S':\n                spies.append((i, j))\n            elif grid[i][j] == 'H':\n                safehouses.append((i, j))\n\n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n\n        if min_distance > max_distance:\n            max_distance = min_distance\n\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n\n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'S':\n                spies.append((i, j))\n            elif grid[i][j] == 'H':\n                safehouses.append((i, j))\n\n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef main():\n    num_of_inputs = int(sys.stdin.readline())\n    for i in range(num_of_inputs):\n        # Get the input\n        N = int(sys.stdin.readline())\n        grid = []\n        for i in range(N):\n            grid.append(sys.stdin.readline().strip())\n\n        # Find the spies and safehouses\n        spies = []\n        safehouses = []\n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == 'S':\n                    spies.append((i, j))\n                elif grid[i][j] == 'H':\n                    safehouses.append((i, j))\n\n        # Find the max distance\n        max_distance = 0\n        for spy in spies:\n            min_distance = N * N\n            for safehouse in safehouses:\n                distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n                if distance < min_distance:\n                    min_distance = distance\n            if min_distance > max_distance:\n                max_distance = min_distance\n        print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "import math\n\nimport time\nimport sys\n\ndef main():\n    # Get the input\n    start = time.time()\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'S':\n                spies.append((i, j))\n            elif grid[i][j] == 'H':\n                safehouses.append((i, j))\n    \n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N + 1\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n    print(time.time() - start)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nprint(\"hello\")\n"
    },
    {
      "index": 6,
      "text": "\n#\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'S':\n                spies.append((i, j))\n            elif grid[i][j] == 'H':\n                safehouses.append((i, j))\n    \n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'S':\n                spies.append((i, j))\n            elif grid[i][j] == 'H':\n                safehouses.append((i, j))\n    \n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'S':\n                spies.append((i, j))\n            elif grid[i][j] == 'H':\n                safehouses.append((i, j))\n    \n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650122242,
  "object": "edit"
}
2022-04-16 15:17:39.067674 fix syntax errors 9 ['\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline()) # Read first line\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip()) # Read next N lines\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \'S\':\n                spies.append((i, j))\n            elif grid[i][j] == \'H\':\n                safehouses.append((i, j))\n    \n    # Find the max distance between spy and safehouse\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    # Get the input.\n    N = int(sys.stdin.readline())\n\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n\n    # Find the spies and safehouses\n    spies = []\n\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \'S\':\n                spies.append((i, j))\n            elif grid[i][j] == \'H\':\n                safehouses.append((i, j))\n\n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n\n        if min_distance > max_distance:\n            max_distance = min_distance\n\n    print(max_distance)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n\n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \'S\':\n                spies.append((i, j))\n            elif grid[i][j] == \'H\':\n                safehouses.append((i, j))\n\n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    num_of_inputs = int(sys.stdin.readline())\n    for i in range(num_of_inputs):\n        # Get the input\n        N = int(sys.stdin.readline())\n        grid = []\n        for i in range(N):\n            grid.append(sys.stdin.readline().strip())\n\n        # Find the spies and safehouses\n        spies = []\n        safehouses = []\n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == \'S\':\n                    spies.append((i, j))\n                elif grid[i][j] == \'H\':\n                    safehouses.append((i, j))\n\n        # Find the max distance\n        max_distance = 0\n        for spy in spies:\n            min_distance = N * N\n            for safehouse in safehouses:\n                distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n                if distance < min_distance:\n                    min_distance = distance\n            if min_distance > max_distance:\n                max_distance = min_distance\n        print(max_distance)\n\nif __name__ == "__main__":\n    main()\n', 'import math\n\nimport time\nimport sys\n\ndef main():\n    # Get the input\n    start = time.time()\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \'S\':\n                spies.append((i, j))\n            elif grid[i][j] == \'H\':\n                safehouses.append((i, j))\n    \n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N + 1\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n    print(time.time() - start)\n\nif __name__ == "__main__":\n    main()\n', '\nprint("hello")\n', '\n#\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \'S\':\n                spies.append((i, j))\n            elif grid[i][j] == \'H\':\n                safehouses.append((i, j))\n    \n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \'S\':\n                spies.append((i, j))\n            elif grid[i][j] == \'H\':\n                safehouses.append((i, j))\n    \n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    # Get the input\n    N = int(sys.stdin.readline())\n    grid = []\n    for i in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    # Find the spies and safehouses\n    spies = []\n    safehouses = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \'S\':\n                spies.append((i, j))\n            elif grid[i][j] == \'H\':\n                safehouses.append((i, j))\n    \n    # Find the max distance\n    max_distance = 0\n    for spy in spies:\n        min_distance = N * N\n        for safehouse in safehouses:\n            distance = abs(spy[0] - safehouse[0]) + abs(spy[1] - safehouse[1])\n            if distance < min_distance:\n                min_distance = distance\n        if min_distance > max_distance:\n            max_distance = min_distance\n    print(max_distance)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 15:17:39.067761 size on output set 8
