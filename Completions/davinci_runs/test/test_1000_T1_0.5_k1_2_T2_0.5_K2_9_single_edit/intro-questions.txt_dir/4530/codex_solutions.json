["\n\ndef find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))", "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))"]