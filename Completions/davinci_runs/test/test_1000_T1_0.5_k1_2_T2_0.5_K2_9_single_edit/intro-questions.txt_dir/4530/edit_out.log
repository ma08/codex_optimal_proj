2022-04-16 08:03:43.134149 num operations 1
2022-04-16 08:03:43.134167 size on input set 1
2022-04-16 08:04:00.790005 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# def find_max_team_size(skills):\n#     uniq_skills = set(skills)\n#     same_skills = {}\n#     for skill in skills:\n#         if skill in same_skills:\n#             same_skills[skill] += 1\n#         else:\n#             same_skills[skill] = 1\n#\n#     if len(uniq_skills) == 1:\n#         return 0\n#     elif len(uniq_skills) == 2:\n#         return min(same_skills.values())\n#     else:\n#         return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    # t = int(input())\n    # for _ in range(t):\n    #     n = int(input())\n    #     skills = list(map(int, input().split()))\n    #     print(find_max_team_size(skills))\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = int(input())\n    b = list(map(int, input().split()))\n    for i in range(n):\n        if (a[i] == b[0]):\n            count = 1\n            for j in range(m):\n                if (a[i + j] == b[j]):\n                    count += 1\n                else:\n                    break\n            if count == m:\n                print(i, end=\" \")\n"
    },
    {
      "index": 1,
      "text": "\n\n    if len(skills) == 1:\n        return 0\ndef find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 2:\n        return min(same_skills.values()) - 1\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    },
    {
      "index": 2,
      "text": "\n\n    if len(skills) == 0:\n        return 0\n\ndef find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1 or len(uniq_skills) == 0:\n        return len(skills)\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values()) + 1\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    },
    {
      "index": 3,
      "text": "\n\ndef find_max_team_size(skills):\n    pass\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    },
    {
      "index": 4,
      "text": "\n\ndef find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values()) - 1\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    },
    {
      "index": 5,
      "text": "\n\n    \"\"\"\n    Find the maximum team size\n    :param skills: list of skills\n    :return: maximum team size\n    \"\"\"\ndef find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    },
    {
      "index": 6,
      "text": "\n\ndef find_max_team_size(skills):\n    unique_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1:\n        return 0\n    elif len(unique_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    },
    {
      "index": 7,
      "text": "def find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\n\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    },
    {
      "index": 8,
      "text": "\n\ndef find_max_team_size(skills):\n    unique_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1:\n        return 0\n    elif len(unique_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    }
  ],
  "created": 1650096223,
  "object": "edit"
}
2022-04-16 08:04:00.790289 fix syntax errors 9 ['\n\n# def find_max_team_size(skills):\n#     uniq_skills = set(skills)\n#     same_skills = {}\n#     for skill in skills:\n#         if skill in same_skills:\n#             same_skills[skill] += 1\n#         else:\n#             same_skills[skill] = 1\n#\n#     if len(uniq_skills) == 1:\n#         return 0\n#     elif len(uniq_skills) == 2:\n#         return min(same_skills.values())\n#     else:\n#         return min(same_skills.values())\n\nif __name__ == "__main__":\n    # t = int(input())\n    # for _ in range(t):\n    #     n = int(input())\n    #     skills = list(map(int, input().split()))\n    #     print(find_max_team_size(skills))\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = int(input())\n    b = list(map(int, input().split()))\n    for i in range(n):\n        if (a[i] == b[0]):\n            count = 1\n            for j in range(m):\n                if (a[i + j] == b[j]):\n                    count += 1\n                else:\n                    break\n            if count == m:\n                print(i, end=" ")\n', '\n\n    if len(skills) == 1:\n        return 0\ndef find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 2:\n        return min(same_skills.values()) - 1\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n', '\n\n    if len(skills) == 0:\n        return 0\n\ndef find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1 or len(uniq_skills) == 0:\n        return len(skills)\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values()) + 1\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n', '\n\ndef find_max_team_size(skills):\n    pass\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n', '\n\ndef find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values()) - 1\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n', '\n\n    """\n    Find the maximum team size\n    :param skills: list of skills\n    :return: maximum team size\n    """\ndef find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n', '\n\ndef find_max_team_size(skills):\n    unique_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1:\n        return 0\n    elif len(unique_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n', "def find_max_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\n\nif __name__ == '__main__':\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n", '\n\ndef find_max_team_size(skills):\n    unique_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1:\n        return 0\n    elif len(unique_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n']
2022-04-16 08:04:00.790561 size on output set 8
2022-04-16 08:04:00.790577 num operations 1
2022-04-16 08:04:00.790583 size on input set 1
2022-04-16 08:04:11.789187 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        first_team = set()\n        second_team = set()\n        for i in range(n):\n            if a[i] not in first_team:\n                first_team.add(a[i])\n            elif a[i] not in second_team:\n                second_team.add(a[i])\n        print(len(first_team))\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 2,
      "text": "\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 3,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first\n# team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team,\n# we will skip it. The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 4,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 5,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n# \n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 6,
      "text": "\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 7,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team.\n#\n# Time: O(n)\n# Space: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 8,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first \n# team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we \n# will skip it. The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    }
  ],
  "created": 1650096240,
  "object": "edit"
}
2022-04-16 08:04:11.789436 fix syntax errors 9 ['\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        first_team = set()\n        second_team = set()\n        for i in range(n):\n            if a[i] not in first_team:\n                first_team.add(a[i])\n            elif a[i] not in second_team:\n                second_team.add(a[i])\n        print(len(first_team))\n', '\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first\n# team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team,\n# we will skip it. The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n# \n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team.\n#\n# Time: O(n)\n# Space: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first \n# team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we \n# will skip it. The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n']
2022-04-16 08:04:11.789593 size on output set 8
