2022-04-16 07:43:15.900971 num operations 1
2022-04-16 07:43:15.900988 size on input set 1
2022-04-16 07:43:23.942264 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 1,
      "text": "from typing import List\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 3,
      "text": "\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 4,
      "text": "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 5,
      "text": "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n\n\n\n        return sum(A)\n"
    },
    {
      "index": 6,
      "text": "class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    },
    {
      "index": 7,
      "text": "from typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.largestSumAfterKNegations([4, 2, 3], 1))\n        return sum(A)\n"
    },
    {
      "index": 8,
      "text": "from typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n"
    }
  ],
  "created": 1650094996,
  "object": "edit"
}
2022-04-16 07:43:23.942548 fix syntax errors 9 ['class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', 'from typing import List\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', '\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', '\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', 'class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', 'class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n\n\n\n        return sum(A)\n', 'class Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n', 'from typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n\n\nif __name__ == "__main__":\n    s = Solution()\n    print(s.largestSumAfterKNegations([4, 2, 3], 1))\n        return sum(A)\n', 'from typing import List\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        A.sort()\n        i = 0\n        while K > 0 and i < len(A):\n            if A[i] < 0:\n                A[i] = -A[i]\n                K -= 1\n                i += 1\n            else:\n                break\n        if K > 0 and K % 2 == 1:\n            A.sort()\n            A[0] = -A[0]\n        return sum(A)\n']
2022-04-16 07:43:23.942702 size on output set 7
2022-04-16 07:43:23.942715 num operations 1
2022-04-16 07:43:23.942725 size on input set 1
2022-04-16 07:43:31.315389 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 1,
      "text": "\nimport heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 2,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 3,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 4,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 5,
      "text": "from typing import List\n\nimport heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)  # heapq.heappush(heap, item)\n        return sum(A)\n"
    },
    {
      "index": 6,
      "text": "import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: list, K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 7,
      "text": "from typing import List\n\nimport heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n"
    },
    {
      "index": 8,
      "text": "#\n"
    }
  ],
  "created": 1650095003,
  "object": "edit"
}
2022-04-16 07:43:31.315628 fix syntax errors 9 ['\nimport heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', '\nimport heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', 'import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', 'import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', 'import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', 'from typing import List\n\nimport heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)  # heapq.heappush(heap, item)\n        return sum(A)\n', 'import heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: list, K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', 'from typing import List\n\nimport heapq\n\n\nclass Solution:\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\n        heapq.heapify(A)\n        for _ in range(K):\n            heapq.heappush(A, heapq.heappop(A) * -1)\n        return sum(A)\n', '#\n']
2022-04-16 07:43:31.315663 size on output set 6
