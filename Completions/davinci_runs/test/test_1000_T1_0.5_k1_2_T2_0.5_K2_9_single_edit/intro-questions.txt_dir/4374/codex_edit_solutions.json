["\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one\n    start = next(iter(graph))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    #diameter = tree_diameter(edges)\n\n    # Print diameter\n    #print(diameter)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import defaultdict\n\ndef dfs(v, p):\n\tglobal max_d, max_v\n\td = 0\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdd = dfs(u, v)\n\t\t\td = max(d, dd)\n\t\t\tif d > max_d:\n\t\t\t\tmax_d = dd\n\t\t\t\tmax_v = u\n\treturn d + 1\n\ndef dfs2(v, p, d):\n\tglobal max_d\n\tmax_d = max(max_d, d)\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdfs2(u, v, d + 1)\n\ndef main():\n\tglobal graph, max_d, max_v\n\tn, m = map(int, input().split())\n\tgraph = defaultdict(list)\n\tfor _ in range(m):\n\t\tv, u = map(int, input().split())\n\t\tgraph[v].append(u)\n\t\tgraph[u].append(v)\n\n\tmax_d = 0\n\tmax_v = 0\n\tdfs(1, 0)\n\tmax_d = 0\n\tdfs2(max_v, 0, 0)\n\tprint(max_d)\n\n\tfor v in range(1, n + 1):\n\t\tfor u in graph[v]:\n\t\t\tif v < u:\n\t\t\t\tprint(v, u)\n\nmain()\n", "\nfrom collections import defaultdict\n\ndef dfs(v, p):\n\tglobal max_d, max_v\n\td = 0\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdd = dfs(u, v)\n\t\t\td = max(d, dd)\n\t\t\tif dd > max_d:\n\t\t\t\tmax_d = dd\n\t\t\t\tmax_v = u\n\treturn d + 1\n\ndef dfs2(v, p, d):\n\tglobal max_d\n\tmax_d = max(max_d, d)\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdfs2(u, v, d + 1)\n\ndef main():\n\tglobal graph, max_d, max_v\n\tn, m = map(int, input().split())\n\tgraph = defaultdict(list)\n\tfor _ in range(m):\n\t\tv, u = map(int, input().split())\n\t\tgraph[v].append(u)\n\t\tgraph[u].append(v)\n\n\tmax_d = 0\n\tmax_v = 0\n\tdfs(1, 0)\n\tmax_d = 0\n\tdfs2(max_v, 0, 0)\n\tprint(max_d)\n\n\t# for v in range(1, n + 1):\n\t# \tfor u in graph[v]:\n\t# \t\tif v < u:\n\t# \t\t\tprint(v, u)\n\nmain()\n", "\n\nimport sys\nfrom collections import defaultdict\n\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one\n    start = next(iter(graph))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    diameter = tree_diameter(edges)\n\n    # Print diameter\n    print(diameter)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import defaultdict\n\ndef dfs(v, p):\n\tglobal max_d, max_v\n\td = 0\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdd = dfs(u, v)\n\t\t\td = max(d, dd)\n\t\t\tif dd > max_d:\n\t\t\t\tmax_d = dd\n\t\t\t\tmax_v = u\n\treturn d + 1\n\ndef dfs2(v, p, d):\n\tglobal max_d\n\tmax_d = max(max_d, d)\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdfs2(u, v, d + 1)\n\ndef main():\n\tglobal graph, max_d, max_v\n\tn, m = map(int, input().split())\n\tgraph = defaultdict(list)\n\tfor _ in range(m):\n\t\tv, u = map(int, input().split())\n\t\tgraph[v].append(u)\n\t\tgraph[u].append(v)\n\n\tmax_d = 0\n\tmax_v = 0\n\tdfs(1, 0)\n\tmax_d = 0\n\tdfs2(max_v, 0, 0)\n\tprint(max_d)\n\n\tfor v in range(1, n + 1):\n\t\tfor u in graph[v]:\n\t\t\tif v < u:\n\t\t\t\tprint(v, u) \n\nmain()\n", "\nfrom collections import defaultdict\n\ndef dfs(v, p):\n\tglobal max_d, max_v, graph\n\td = 0\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdd = dfs(u, v)\n\t\t\td = max(d, dd)\n\t\t\tif dd > max_d:\n\t\t\t\tmax_d = dd\n\t\t\t\tmax_v = u\n\treturn d + 1\n\ndef dfs2(v, p, d):\n\tglobal max_d, graph\n\tmax_d = max(max_d, d)\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdfs2(u, v, d + 1)\n\ndef main():\n\tglobal graph, max_d, max_v, graph\n\tn, m = map(int, input().split())\n\tgraph = defaultdict(list)\n\tfor _ in range(m):\n\t\tv, u = map(int, input().split())\n\t\tgraph[v].append(u)\n\t\tgraph[u].append(v)\n\n\tmax_d = 0\n\tmax_v = 0\n\tdfs(1, 0)\n\tmax_d = 0\n\tdfs2(max_v, 0, 0)\n\tprint(max_d)\n\n\tfor v in range(1, n + 1):\n\t\tfor u in graph[v]:\n\t\t\tif v < u:\n\t\t\t\tprint(v, u)\n\nmain()\n", "\n\nimport sys, math\n \ndef main():   \n    n,m = map(int, sys.stdin.readline().split())\n    edges = [list(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    print(n-1)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if [i,j] not in edges and [j,i] not in edges:\n                print(i,j)\n \nif __name__ == '__main__':\n    main()\n", "\nfrom collections import defaultdict\n\ndef dfs(v, p):\n    global max_d, max_v\n    d = 0\n    for u in graph[v]:\n        if u != p:\n            dd = dfs(u, v)\n            d = max(d, dd)\n            if dd > max_d:\n                max_d = dd\n                max_v = u\n    return d + 1\n\ndef dfs2(v, p, d):\n    global max_d\n    max_d = max(max_d, d)\n    for u in graph[v]:\n        if u != p:\n            dfs2(u, v, d + 1)\n\ndef main():\n    global graph, max_d, max_v\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        v, u = map(int, input().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    max_d = 0\n    max_v = 0\n    dfs(1, 0)\n    max_d = 0\n    dfs2(max_v, 0, 0)\n    print(max_d)\n\n    for v in range(1, n + 1):\n        for u in graph[v]:\n            if v < u:\n                print(v, u)\n\nmain()\n", "\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one\n    start = next(iter(graph.keys()))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    diameter = tree_diameter(edges)\n\n    # Print diameter\n    print(diameter)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nfrom collections import defaultdict\n\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one\n    start = next(iter(graph))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    diameter = tree_diameter(edges)\n\n    # Print diameter\n    print(diameter)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import defaultdict\n\ndef dfs(v, p):\n\tglobal max_d, max_v\n\td = 0\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdd = dfs(u, v) + 1\n\t\t\td = max(d, dd)\n\t\t\tif dd > max_d:\n\t\t\t\tmax_d = dd\n\t\t\t\tmax_v = u\n\treturn d\n\ndef dfs2(v, p, d):\n\tglobal max_d\n\tmax_d = max(max_d, d)\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdfs2(u, v, d + 1)\n\ndef main():\n\tglobal graph, max_d, max_v\n\tn, m = map(int, input().split())\n\tgraph = defaultdict(list)\n\tfor _ in range(m):\n\t\tv, u = map(int, input().split())\n\t\tgraph[v].append(u)\n\t\tgraph[u].append(v)\n\n\tmax_d = 0\n\tmax_v = 0\n\tdfs(1, -1)\n\tmax_d = 0\n\tdfs2(max_v, -1, 0)\n\tprint(max_d)\n\n\tfor v in range(1, n + 1):\n\t\tfor u in graph[v]:\n\t\t\tif v < u:\n\t\t\t\tprint(v, u)\n\nmain()\n", "\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one\n    start = next(iter(graph))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    diameter = tree_diameter(edges)\n\n    # Print diameter\n    print(diameter)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one\n    start = next(iter(graph))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    diameter = tree_diameter(edges)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n    else:\n        # Print diameter\n        print(diameter)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import defaultdict\n\ndef dfs(v, p):\n    global max_d, max_v\n    d = 0\n    for u in graph[v]:\n        if u != p:\n            dd = dfs(u, v)\n            d = max(d, dd)\n            if dd > max_d:\n                max_d = dd\n                max_v = u\n    return d + 1\n\ndef dfs2(v, p, d):\n    global max_d\n    max_d = max(max_d, d)\n    for u in graph[v]:\n        if u != p:\n            dfs2(u, v, d + 1)\n\ndef main():\n    global graph, max_d, max_v\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        v, u = map(int, input().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    max_v = 0\n    dfs(1, 0)\n    max_d = 0\n    dfs2(max_v, 0, 0)\n    print(max_d)\n\n    for v in range(1, n + 1):\n        for u in graph[v]:\n            if v < u:\n                print(v, u)\n\nmain()\n"]