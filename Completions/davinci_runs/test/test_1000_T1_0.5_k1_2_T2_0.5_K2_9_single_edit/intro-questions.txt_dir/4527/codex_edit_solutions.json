["\nimport sys\n# Greedy Algorithm\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    sys.stdout.write(str(count) + '\\n')\n", "\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n", "\n\n# Greedy Algorithm - https://www.hackerrank.com/challenges/greedy-florist/problem\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n", "\n\nfrom sys import stdin\n\ndef main():\n    t = int(stdin.readline())\n    for i in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = [int(x) for x in stdin.readline().split()]\n            segments.append([l, r])\n        # Sort segments in increasing order of left and right endpoints\n        segments.sort()\n        # Maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        max_non_intersecting_segments = 0\n        # List that contains the right endpoint of the current segment\n        # and the maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This list is sorted in increasing order of right endpoint\n        right_endpoint_and_max_non_intersecting_segments = []\n        for j in range(n):\n            # Check if the left endpoint of the current segment\n            # is greater than the right endpoint of the last segment\n            # in the right_endpoint_and_max_non_intersecting_segments list\n            if len(right_endpoint_and_max_non_intersecting_segments) > 0:\n                if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[-1][0]:\n                    # If yes, then this segment can be added to the list\n                    # of non-intersecting segments\n                    # Therefore, increase the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    max_non_intersecting_segments += 1\n                    # Add the right endpoint of the current segment\n                    # and the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n                else:\n                    # If not, then we need to find the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is the binary search algorithm\n                    # This is done because the list is sorted in increasing order of right endpoint\n                    left = 0\n                    right = len(right_endpoint_and_max_non_intersecting_segments) - 1\n                    while left < right:\n                        mid = (left + right) // 2\n                        if segments[j][1] > right_endpoint_and_max_non_intersecting_segments[mid][0]:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    # This is the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    index = right\n                    # Check if the left endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # at the index found above\n                    if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[index][0]:\n                        # If yes, then this segment can be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        max_non_intersecting_segments += 1\n                        # Add the right endpoint of the current segment\n                        # and the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # This is because the input is given in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        right_endpoint_and_max_non_intersecting_segments.insert(index + 1, [segments[j][1], max_non_intersecting_segments])\n                    else:\n                        # If not, then this segment cannot be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # by the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # of the segment\n                        # in the right_endpoint_and_max_non_intersecting_segments list\n                        # at the index found above\n                        max_non_intersecting_segments += right_endpoint_and_max_non_intersecting_segments[index][1]\n            else:\n                # If not, then this segment can be added to the list\n                # of non-intersecting segments\n                # Therefore, increase the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                max_non_intersecting_segments += 1\n                # Add the right endpoint of the current segment\n                # and the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                # This is because the input is given in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n        # Print the answer\n        print(max_non_intersecting_segments)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Greedy Algorithm\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n\n\n# Binary Search\n\nt = int(input())\n\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    l = 0\n    r = n - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if a[mid] == k:\n            print(mid + 1)\n            break\n        elif a[mid] > k:\n            r = mid - 1\n        else:\n            l = mid + 1\n    else:\n        print(-1)\n    print(count)\n", "\n\nfrom sys import stdin\n\ndef main():\n    t = int(stdin.readline())\n    for i in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = [int(x) for x in stdin.readline().split()]\n            segments.append([l, r])\n        # Sort segments in increasing order of left and right endpoints\n        segments.sort(key = lambda x: x[0])\n        # Now, segments are in increasing order of left endpoint\n        # and in decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # Therefore, we need to reverse the list\n        # This is done because we will be using the list in decreasing order of right endpoint\n        segments.sort(key = lambda x: x[1], reverse = True)\n        # Maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        max_non_intersecting_segments = 0\n        # List that contains the right endpoint of the current segment\n        # and the maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This list is sorted in increasing order of right endpoint\n        right_endpoint_and_max_non_intersecting_segments = []\n        for j in range(n):\n            # Check if the left endpoint of the current segment\n            # is greater than the right endpoint of the last segment\n            # in the right_endpoint_and_max_non_intersecting_segments list\n            if len(right_endpoint_and_max_non_intersecting_segments) > 0:\n                if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[-1][0]:\n                    # If yes, then this segment can be added to the list\n                    # of non-intersecting segments\n                    # Therefore, increase the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    max_non_intersecting_segments += 1\n                    # Add the right endpoint of the current segment\n                    # and the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n                else:\n                    # If not, then we need to find the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is the binary search algorithm\n                    # This is done because the list is sorted in increasing order of right endpoint\n                    left = 0\n                    right = len(right_endpoint_and_max_non_intersecting_segments) - 1\n                    while left < right:\n                        mid = (left + right) // 2\n                        if segments[j][1] > right_endpoint_and_max_non_intersecting_segments[mid][0]:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    # This is the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    index = right\n                    # Check if the left endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # at the index found above\n                    if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[index][0]:\n                        # If yes, then this segment can be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        max_non_intersecting_segments += 1\n                        # Add the right endpoint of the current segment\n                        # and the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # This is because the input is given in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        right_endpoint_and_max_non_intersecting_segments.insert(index + 1, [segments[j][1], max_non_intersecting_segments])\n                    else:\n                        # If not, then this segment cannot be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # by the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # of the segment\n                        # in the right_endpoint_and_max_non_intersecting_segments list\n                        # at the index found above\n                        max_non_intersecting_segments += right_endpoint_and_max_non_intersecting_segments[index][1]\n            else:\n                # If not, then this segment can be added to the list\n                # of non-intersecting segments\n                # Therefore, increase the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                max_non_intersecting_segments += 1\n                # Add the right endpoint of the current segment\n                # and the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                # This is because the input is given in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n        # Print the answer\n        print(max_non_intersecting_segments)\n\nif __name__ == \"__main__\":\n    main()\n", "#\n\nfrom sys import stdin\n\ndef main():\n    t = int(stdin.readline())\n    for i in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = [int(x) for x in stdin.readline().split()]\n            segments.append([l, r])\n        # Sort segments in increasing order of left and right endpoints\n        segments.sort()\n        # Now, segments are in increasing order of left endpoint\n        # and in decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # Therefore, we need to reverse the list\n        # This is done because we will be using the list in decreasing order of right endpoint\n        segments.reverse()\n        # Maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        max_non_intersecting_segments = 0\n        # List that contains the right endpoint of the current segment\n        # and the maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This list is sorted in increasing order of right endpoint\n        right_endpoint_and_max_non_intersecting_segments = []\n        for j in range(n):\n            # Check if the left endpoint of the current segment\n            # is greater than the right endpoint of the last segment\n            # in the right_endpoint_and_max_non_intersecting_segments list\n            if len(right_endpoint_and_max_non_intersecting_segments) > 0:\n                if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[-1][0]:\n                    # If yes, then this segment can be added to the list\n                    # of non-intersecting segments\n                    # Therefore, increase the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    max_non_intersecting_segments += 1\n                    # Add the right endpoint of the current segment\n                    # and the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n                else:\n                    # If not, then we need to find the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is the binary search algorithm\n                    # This is done because the list is sorted in increasing order of right endpoint\n                    left = 0\n                    right = len(right_endpoint_and_max_non_intersecting_segments) - 1\n                    while left < right:\n                        mid = (left + right) // 2\n                        if segments[j][1] > right_endpoint_and_max_non_intersecting_segments[mid][0]:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    # This is the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    index = right\n                    # Check if the left endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # at the index found above\n                    if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[index][0]:\n                        # If yes, then this segment can be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        max_non_intersecting_segments += 1\n                        # Add the right endpoint of the current segment\n                        # and the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # This is because the input is given in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        right_endpoint_and_max_non_intersecting_segments.insert(index + 1, [segments[j][1], max_non_intersecting_segments])\n                    else:\n                        # If not, then this segment cannot be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # by the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # of the segment\n                        # in the right_endpoint_and_max_non_intersecting_segments list\n                        # at the index found above\n                        max_non_intersecting_segments += right_endpoint_and_max_non_intersecting_segments[index][1]\n            else:\n                # If not, then this segment can be added to the list\n                # of non-intersecting segments\n                # Therefore, increase the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                max_non_intersecting_segments += 1\n                # Add the right endpoint of the current segment\n                # and the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                # This is because the input is given in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n        # Print the answer\n        print(max_non_intersecting_segments)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom sys import stdin\n\ndef main():\n    t = int(stdin.readline())\n    for i in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = [int(x) for x in stdin.readline().split()]\n            segments.append([l, r])\n        # Sort segments in increasing order of left and right endpoints\n        segments.sort()\n        # Now, segments are in increasing order of left endpoint\n        # and in decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # Therefore, we need to reverse the list\n        # This is done because we will be using the list in decreasing order of right endpoint\n        segments.reverse()\n        # Maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        max_non_intersecting_segments = 0\n        # List that contains the right endpoint of the current segment\n        # and the maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This list is sorted in increasing order of right endpoint\n        right_endpoint_and_max_non_intersecting_segments = []\n        for j in range(n):\n            # Check if the left endpoint of the current segment\n            # is greater than the right endpoint of the last segment\n            # in the right_endpoint_and_max_non_intersecting_segments list\n            if len(right_endpoint_and_max_non_intersecting_segments) > 0:\n                if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[-1][0]:\n                    # If yes, then this segment can be added to the list\n                    # of non-intersecting segments\n                    # Therefore, increase the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    max_non_intersecting_segments += 1\n                    # Add the right endpoint of the current segment\n                    # and the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n                else:\n                    # If not, then we need to find the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is the binary search algorithm\n                    # This is done because the list is sorted in increasing order of right endpoint\n                    left = 0\n                    right = len(right_endpoint_and_max_non_intersecting_segments) - 1\n                    while left < right:\n                        mid = (left + right) // 2\n                        if segments[j][1] > right_endpoint_and_max_non_intersecting_segments[mid][0]:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    # This is the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    index = right\n                    # Check if the left endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # at the index found above\n                    if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[index][0]:\n                        # If yes, then this segment can be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        max_non_intersecting_segments += 1\n                        # Add the right endpoint of the current segment\n                        # and the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # This is because the input is given in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        right_endpoint_and_max_non_intersecting_segments.insert(index + 1, [segments[j][1], max_non_intersecting_segments])\n                    else:\n                        # If not, then this segment cannot be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # by the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # of the segment\n                        # in the right_endpoint_and_max_non_intersecting_segments list\n                        # at the index found above\n                        max_non_intersecting_segments += right_endpoint_and_max_non_intersecting_segments[index][1]\n            else:\n                # If not, then this segment can be added to the list\n                # of non-intersecting segments\n                # Therefore, increase the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                max_non_intersecting_segments += 1\n                # Add the right endpoint of the current segment\n                # and the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                # This is because the input is given in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n        # Print the answer\n        print(max_non_intersecting_segments)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom operator import itemgetter\n# Greedy Algorithm\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=itemgetter(1))\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n", "\n# https://www.hackerrank.com/challenges/greedy-florist/problem\n# Greedy Algorithm\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n\n# https://www.hackerrank.com/challenges/mark-and-toys/problem\nn, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ncount = 0\nfor i in range(n):\n    if k - a[i] >= 0:\n        k -= a[i]\n        count += 1\n    else:\n        break\nprint(count)\n\n# https://www.hackerrank.com/challenges/minimum-absolute-difference-in-an-array/problem\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nm = abs(a[0] - a[1])\nfor i in range(1, n - 1):\n    m = min(m, abs(a[i] - a[i + 1]))\nprint(m)\n\n# https://www.hackerrank.com/challenges/luck-balance/problem\nn, k = map(int, input().split())\na = []\nfor _ in range(n):\n    l, t = map(int, input().split())\n    a.append([l, t])\na.sort(key=lambda x: x[0])\ncount = 0\nfor i in range(n):\n    if a[i][1] == 0:\n        count += a[i][0]\n    else:\n        if k > 0:\n            count += a[i][0]\n            k -= 1\n        else:\n            count -= a[i][0]\nprint(count)\n    print(count)\n", "\n\n# Greedy Algorithm \n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n", "\n\nfrom sys import stdin\n\ndef main():\n    t = int(stdin.readline())\n    for i in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = [int(x) for x in stdin.readline().split()]\n            segments.append([l, r])\n        # Sort segments in increasing order of left and right endpoints\n        segments.sort()\n        # Now, segments are in increasing order of left endpoint\n        # and in decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoints\n        # Therefore, we need to reverse the list\n        # This is done because we will be using the list in decreasing order of right endpoint\n        segments.reverse()\n        # Maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoints\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoints\n        max_non_intersecting_segments = 0\n        # List that contains the right endpoint of the current segment\n        # and the maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoints\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoints\n        # This list is sorted in increasing order of right endpoint\n        right_endpoint_and_max_non_intersecting_segments = []\n        for j in range(n):\n            # Check if the left endpoint of the current segment\n            # is greater than the right endpoint of the last segment\n            # in the right_endpoint_and_max_non_intersecting_segments list\n            if len(right_endpoint_and_max_non_intersecting_segments) > 0:\n                if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[-1][0]:\n                    # If yes, then this segment can be added to the list\n                    # of non-intersecting segments\n                    # Therefore, increase the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoints\n                    max_non_intersecting_segments += 1\n                    # Add the right endpoint of the current segment\n                    # and the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n                else:\n                    # If not, then we need to find the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is the binary search algorithm\n                    # This is done because the list is sorted in increasing order of right endpoint\n                    left = 0\n                    right = len(right_endpoint_and_max_non_intersecting_segments) - 1\n                    while left < right:\n                        mid = (left + right) // 2\n                        if segments[j][1] > right_endpoint_and_max_non_intersecting_segments[mid][0]:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    # This is the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    index = right\n                    # Check if the left endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # at the index found above\n                    if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[index][0]:\n                        # If yes, then this segment can be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        max_non_intersecting_segments += 1\n                        # Add the right endpoint of the current segment\n                        # and the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # This is because the input is given in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        right_endpoint_and_max_non_intersecting_segments.insert(index + 1, [segments[j][1], max_non_intersecting_segments])\n                    else:\n                        # If not, then this segment cannot be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # by the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # of the segment\n                        # in the right_endpoint_and_max_non_intersecting_segments list\n                        # at the index found above\n                        max_non_intersecting_segments += right_endpoint_and_max_non_intersecting_segments[index][1]\n            else:\n                # If not, then this segment can be added to the list\n                # of non-intersecting segments\n                # Therefore, increase the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                max_non_intersecting_segments += 1\n                # Add the right endpoint of the current segment\n                # and the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                # This is because the input is given in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n        # Print the answer\n        print(max_non_intersecting_segments)\n\nif __name__ == \"__main__\":\n    main()\n", "\n# Greedy Algorithm\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n", "# Greedy Algorithm\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n", "\nfrom sys import stdin\n\ndef main():\n    t = int(stdin.readline())\n    for i in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = [int(x) for x in stdin.readline().split()]\n            segments.append([l, r])\n        # Sort segments in increasing order of left and right endpoints\n        segments.sort()\n        # Now, segments are in increasing order of left endpoint\n        # and in decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # Therefore, we need to reverse the list\n        # This is done because we will be using the list in decreasing order of right endpoint\n        segments.reverse()\n        # Maximum number of non-intersecting segments\n        max_non_intersecting_segments = 0\n        # List that contains the right endpoint of the current segment\n        # and the maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This list is sorted in increasing order of right endpoint\n        right_endpoint_and_max_non_intersecting_segments = []\n        for j in range(n):\n            # Check if the left endpoint of the current segment\n            # is greater than the right endpoint of the last segment\n            # in the right_endpoint_and_max_non_intersecting_segments list\n            if len(right_endpoint_and_max_non_intersecting_segments) > 0:\n                if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[-1][0]:\n                    # If yes, then this segment can be added to the list\n                    # of non-intersecting segments\n                    # Therefore, increase the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    max_non_intersecting_segments += 1\n                    # Add the right endpoint of the current segment\n                    # and the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n                else:\n                    # If not, then we need to find the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is the binary search algorithm\n                    # This is done because the list is sorted in increasing order of right endpoint\n                    left = 0\n                    right = len(right_endpoint_and_max_non_intersecting_segments) - 1\n                    while left < right:\n                        mid = (left + right) // 2\n                        if segments[j][1] > right_endpoint_and_max_non_intersecting_segments[mid][0]:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    # This is the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    index = right\n                    # Check if the left endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # at the index found above\n                    if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[index][0]:\n                        # If yes, then this segment can be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        max_non_intersecting_segments += 1\n                        # Add the right endpoint of the current segment\n                        # and the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # This is because the input is given in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        right_endpoint_and_max_non_intersecting_segments.insert(index + 1, [segments[j][1], max_non_intersecting_segments])\n                    else:\n                        # If not, then this segment cannot be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # by the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # of the segment\n                        # in the right_endpoint_and_max_non_intersecting_segments list\n                        # at the index found above\n                        max_non_intersecting_segments += right_endpoint_and_max_non_intersecting_segments[index][1]\n            else:\n                # If not, then this segment can be added to the list\n                # of non-intersecting segments\n                # Therefore, increase the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                max_non_intersecting_segments += 1\n                # Add the right endpoint of the current segment\n                # and the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                # This is because the input is given in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n        # Print the answer\n        print(max_non_intersecting_segments)\n\nif __name__ == \"__main__\":\n    main()\n"]