2022-04-09 20:45:29.256565 """
You are given $n$ segments on a coordinate axis $OX$. The $i$-th segment has borders $[l_i; r_i]$. All points $x$, for which $l_i \le x \le r_i$ holds, belong to the $i$-th segment.

Your task is to choose the maximum by size (the number of segments) subset of the given set of segments such that each pair of segments in this subset either non-intersecting or one of them lies inside the other one.

Two segments $[l_i; r_i]$ and $[l_j; r_j]$ are non-intersecting if they have no common points. For example, segments $[1; 2]$ and $[3; 4]$, $[1; 3]$ and $[5; 5]$ are non-intersecting, while segments $[1; 2]$ and $[2; 3]$, $[1; 2]$ and $[2; 2]$ are intersecting.

The segment $[l_i; r_i]$ lies inside the segment $[l_j; r_j]$ if $l_j \le l_i$ and $r_i \le r_j$. For example, segments $[2; 2]$, $[2, 3]$, $[3; 4]$ and $[2; 4]$ lie inside the segment $[2; 4]$, while $[2; 5]$ and $[1; 4]$ are not.

You have to answer $t$ independent test cases.


-----Input-----

The first line of the input contains one integer $t$ ($1 \le t \le 1000$) — the number of test cases. Then $t$ test cases follow.

The first line of the test case contains one integer $n$ ($1 \le n \le 3000$) — the number of segments. The next $n$ lines describe segments. The $i$-th segment is given as two integers $l_i$ and $r_i$ ($1 \le l_i \le r_i \le 2 \cdot 10^5$), where $l_i$ is the left border of the $i$-th segment and $r_i$ is the right border of the $i$-th segment.

Additional constraint on the input: there are no duplicates in the list of segments.

It is guaranteed that the sum of $n$ does not exceed $3000$ ($\sum n \le 3000$).


-----Output-----

For each test case, print the answer: the maximum possible size of the subset of the given set of segments such that each pair of segments in this subset either non-intersecting or one of them lies inside the other one.


-----Example-----
Input
4
4
1 5
2 4
2 3
3 4
5
1 5
2 3
2 5
3 5
2 2
3
1 3
2 4
2 3
7
1 10
2 8
2 5
3 4
4 4
6 8
7 7

Output
3
4
2
7
"""
2022-04-09 20:45:29.256662 --------------------------
2022-04-09 20:46:24.295371 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n# Greedy Algorithm\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\ndef main():\n    t = int(stdin.readline())\n    for i in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = [int(x) for x in stdin.readline().split()]\n            segments.append([l, r])\n        # Sort segments in increasing order of left and right endpoints\n        segments.sort()\n        # Now, segments are in increasing order of left endpoint\n        # and in decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # Therefore, we need to reverse the list\n        # This is done because we will be using the list in decreasing order of right endpoint\n        segments.reverse()\n        # Maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        max_non_intersecting_segments = 0\n        # List that contains the right endpoint of the current segment\n        # and the maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This list is sorted in increasing order of right endpoint\n        right_endpoint_and_max_non_intersecting_segments = []\n        for j in range(n):\n            # Check if the left endpoint of the current segment\n            # is greater than the right endpoint of the last segment\n            # in the right_endpoint_and_max_non_intersecting_segments list\n            if len(right_endpoint_and_max_non_intersecting_segments) > 0:\n                if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[-1][0]:\n                    # If yes, then this segment can be added to the list\n                    # of non-intersecting segments\n                    # Therefore, increase the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    max_non_intersecting_segments += 1\n                    # Add the right endpoint of the current segment\n                    # and the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n                else:\n                    # If not, then we need to find the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is the binary search algorithm\n                    # This is done because the list is sorted in increasing order of right endpoint\n                    left = 0\n                    right = len(right_endpoint_and_max_non_intersecting_segments) - 1\n                    while left < right:\n                        mid = (left + right) // 2\n                        if segments[j][1] > right_endpoint_and_max_non_intersecting_segments[mid][0]:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    # This is the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    index = right\n                    # Check if the left endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # at the index found above\n                    if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[index][0]:\n                        # If yes, then this segment can be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        max_non_intersecting_segments += 1\n                        # Add the right endpoint of the current segment\n                        # and the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # This is because the input is given in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        right_endpoint_and_max_non_intersecting_segments.insert(index + 1, [segments[j][1], max_non_intersecting_segments])\n                    else:\n                        # If not, then this segment cannot be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # by the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # of the segment\n                        # in the right_endpoint_and_max_non_intersecting_segments list\n                        # at the index found above\n                        max_non_intersecting_segments += right_endpoint_and_max_non_intersecting_segments[index][1]\n            else:\n                # If not, then this segment can be added to the list\n                # of non-intersecting segments\n                # Therefore, increase the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                max_non_intersecting_segments += 1\n                # Add the right endpoint of the current segment\n                # and the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                # This is because the input is given in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n        # Print the answer\n        print(max_non_intersecting_segments)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1649551529,
  "id": "cmpl-4vFzlfo5LpQREOu3fvhbubHgYytgt",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 20:46:24.295632 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n# Greedy Algorithm\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)"
}
2022-04-09 20:46:24.295659 REASON stop
2022-04-09 20:46:24.296533 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\ndef main():\n    t = int(stdin.readline())\n    for i in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = [int(x) for x in stdin.readline().split()]\n            segments.append([l, r])\n        # Sort segments in increasing order of left and right endpoints\n        segments.sort()\n        # Now, segments are in increasing order of left endpoint\n        # and in decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # Therefore, we need to reverse the list\n        # This is done because we will be using the list in decreasing order of right endpoint\n        segments.reverse()\n        # Maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        max_non_intersecting_segments = 0\n        # List that contains the right endpoint of the current segment\n        # and the maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This list is sorted in increasing order of right endpoint\n        right_endpoint_and_max_non_intersecting_segments = []\n        for j in range(n):\n            # Check if the left endpoint of the current segment\n            # is greater than the right endpoint of the last segment\n            # in the right_endpoint_and_max_non_intersecting_segments list\n            if len(right_endpoint_and_max_non_intersecting_segments) > 0:\n                if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[-1][0]:\n                    # If yes, then this segment can be added to the list\n                    # of non-intersecting segments\n                    # Therefore, increase the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    max_non_intersecting_segments += 1\n                    # Add the right endpoint of the current segment\n                    # and the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n                else:\n                    # If not, then we need to find the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is the binary search algorithm\n                    # This is done because the list is sorted in increasing order of right endpoint\n                    left = 0\n                    right = len(right_endpoint_and_max_non_intersecting_segments) - 1\n                    while left < right:\n                        mid = (left + right) // 2\n                        if segments[j][1] > right_endpoint_and_max_non_intersecting_segments[mid][0]:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    # This is the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    index = right\n                    # Check if the left endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # at the index found above\n                    if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[index][0]:\n                        # If yes, then this segment can be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        max_non_intersecting_segments += 1\n                        # Add the right endpoint of the current segment\n                        # and the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # This is because the input is given in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        right_endpoint_and_max_non_intersecting_segments.insert(index + 1, [segments[j][1], max_non_intersecting_segments])\n                    else:\n                        # If not, then this segment cannot be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # by the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # of the segment\n                        # in the right_endpoint_and_max_non_intersecting_segments list\n                        # at the index found above\n                        max_non_intersecting_segments += right_endpoint_and_max_non_intersecting_segments[index][1]\n            else:\n                # If not, then this segment can be added to the list\n                # of non-intersecting segments\n                # Therefore, increase the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                max_non_intersecting_segments += 1\n                # Add the right endpoint of the current segment\n                # and the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                # This is because the input is given in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n        # Print the answer\n        print(max_non_intersecting_segments)\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-09 20:46:24.296611 REASON stop
