2022-04-16 08:00:17.955614 num operations 1
2022-04-16 08:00:17.955632 size on input set 1
2022-04-16 08:00:44.242497 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate and speed of first point\nfirst_x, first_v = x_sorted[0]\n# Get coordinate and speed of last point\nlast_x, last_v = x_sorted[-1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 1,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1])\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1])\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1])\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 2,
      "text": "\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 3,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += abs(x_sorted[1][0] - x_sorted[0][0]) - abs(x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += abs(x_sorted[-1][0] - x_sorted[-2][0]) - abs(x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += abs(x_sorted[i+1][0] - x_sorted[i][0]) - abs(x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += abs(x_sorted[-i-1][0] - x_sorted[-i-2][0]) - abs(x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += abs(x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - abs(x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 4,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\n\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 5,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate and speed\nx_sorted = sorted(zip(x, v), key=lambda z: z[0])\nv_sorted = sorted(zip(x, v), key=lambda z: z[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 6,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t # bug\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t # bug\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t # bug\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t # bug\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t # bug\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 7,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += abs((x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t)\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += abs((x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t)\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += abs((x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t)\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += abs((x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t)\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += abs((x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t)\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    },
    {
      "index": 8,
      "text": "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate and speed\nx_sorted = sorted(zip(x, v), key=lambda x: (x[0], x[1]))\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point (if first point overtakes last point)\nif first_v > last_v:\n\tt = (last_x - first_x) / (first_v - last_v)\n# Otherwise, set time to infinity\nelse:\n\tt = float(\"inf\")\n\n# Get coordinate of first point at time t (if first point overtakes last point)\nif first_v > last_v:\n\tfirst_t = first_x + t * first_v\n# Otherwise, set coordinate to infinity\nelse:\n\tfirst_t = float(\"inf\")\n\n# Get coordinate of last point at time t (if last point overtakes first point)\nif last_v > first_v:\n\tlast_t = last_x + t * last_v\n# Otherwise, set coordinate to infinity\nelse:\n\tlast_t = float(\"inf\")\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point and first point is not last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t and first_v > last_v:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point and last point is not first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t and last_v > first_v:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n"
    }
  ],
  "created": 1650096018,
  "object": "edit"
}
2022-04-16 08:00:44.243071 fix syntax errors 9 ['\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate and speed of first point\nfirst_x, first_v = x_sorted[0]\n# Get coordinate and speed of last point\nlast_x, last_v = x_sorted[-1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n', '\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1])\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1])\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1])\n\n# Print sum\nprint(int(s))\n', '\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n', '\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += abs(x_sorted[1][0] - x_sorted[0][0]) - abs(x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += abs(x_sorted[-1][0] - x_sorted[-2][0]) - abs(x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += abs(x_sorted[i+1][0] - x_sorted[i][0]) - abs(x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += abs(x_sorted[-i-1][0] - x_sorted[-i-2][0]) - abs(x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += abs(x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - abs(x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n', '\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\n\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n', '\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate and speed\nx_sorted = sorted(zip(x, v), key=lambda z: z[0])\nv_sorted = sorted(zip(x, v), key=lambda z: z[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n', '\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t # bug\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t # bug\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t # bug\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t # bug\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t # bug\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n', '\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += abs((x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t)\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += abs((x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t)\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += abs((x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t)\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += abs((x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t)\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += abs((x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t)\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n', '\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate and speed\nx_sorted = sorted(zip(x, v), key=lambda x: (x[0], x[1]))\n\n# Get coordinate of first point\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point\nfirst_v = x_sorted[0][1]\n# Get speed of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point (if first point overtakes last point)\nif first_v > last_v:\n\tt = (last_x - first_x) / (first_v - last_v)\n# Otherwise, set time to infinity\nelse:\n\tt = float("inf")\n\n# Get coordinate of first point at time t (if first point overtakes last point)\nif first_v > last_v:\n\tfirst_t = first_x + t * first_v\n# Otherwise, set coordinate to infinity\nelse:\n\tfirst_t = float("inf")\n\n# Get coordinate of last point at time t (if last point overtakes first point)\nif last_v > first_v:\n\tlast_t = last_x + t * last_v\n# Otherwise, set coordinate to infinity\nelse:\n\tlast_t = float("inf")\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point and first point is not last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t and first_v > last_v:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point and last point is not first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t and last_v > first_v:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n']
2022-04-16 08:00:44.243353 size on output set 9
2022-04-16 08:00:44.243364 num operations 1
2022-04-16 08:00:44.243370 size on input set 1
2022-04-16 08:00:53.658211 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(len(x))]\n\nx.sort()\n\nd = 0\nfor i in range(len(x) - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n"
    },
    {
      "index": 1,
      "text": "\n'''\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\n'''\n\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\nprint(d)\n"
    },
    {
      "index": 2,
      "text": "\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\n\nprint(d)\n"
    },
    {
      "index": 3,
      "text": "\n\n# SOLUTION 1\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\n\n# SOLUTION 2\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\nprint(d)\n"
    },
    {
      "index": 4,
      "text": "n = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)] # for i in range(n): x[i] += v[i]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n"
    },
    {
      "index": 5,
      "text": "\n\n# SOLUTION \nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n"
    },
    {
      "index": 6,
      "text": "\n\n# SOLUTION \nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n"
    },
    {
      "index": 7,
      "text": "\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n"
    },
    {
      "index": 8,
      "text": "\n\n# SOLUTION\ndef minimum_distance(x, v):\n    n = len(x)\n    x = [x[i] + v[i] for i in range(n)]\n    x.sort()\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n"
    }
  ],
  "created": 1650096044,
  "object": "edit"
}
2022-04-16 08:00:53.658452 fix syntax errors 9 ['\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(len(x))]\n\nx.sort()\n\nd = 0\nfor i in range(len(x) - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n', "\n'''\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\n'''\n\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\nprint(d)\n", '\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\n\nprint(d)\n', '\n\n# SOLUTION 1\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\n\n# SOLUTION 2\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\nprint(d)\n', 'n = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)] # for i in range(n): x[i] += v[i]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n', '\n\n# SOLUTION \nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n', '\n\n# SOLUTION \nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n', '\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n', '\n\n# SOLUTION\ndef minimum_distance(x, v):\n    n = len(x)\n    x = [x[i] + v[i] for i in range(n)]\n    x.sort()\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n']
2022-04-16 08:00:53.658494 size on output set 8
