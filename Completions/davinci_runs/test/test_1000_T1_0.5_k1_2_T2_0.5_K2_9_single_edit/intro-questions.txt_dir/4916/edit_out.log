2022-04-16 13:55:10.504759 num operations 1
2022-04-16 13:55:10.504776 size on input set 1
2022-04-16 13:55:30.708895 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = ()\n        for tile in path:\n            if start_tile == ():\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != ():\n                        break\n            else:\n                # Find the next tile\n                next_tile = ()\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != ():\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport itertools\n\ndef main():\n    n = int(input())\n    tiles = [list(map(int, input().split())) for _ in range(n-1)]\n\n    print(tiles)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1), k):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile is not None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n * n:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0] * (k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = (None, None)\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile is not None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "import sys\n\nimport itertools\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        sys.stdout.write(str(-1))\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            sys.stdout.write(str(-1))\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    sys.stdout.write(str(best_path))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile is not None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())  # n: number of rows, k: number of types of tiles\n    tiles = [list(map(int, input().split())) for _ in range(n)]  # tiles[i][j]: type of tile in row i and column j\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) \\\n                    + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650117310,
  "object": "edit"
}
2022-04-16 13:55:30.709339 fix syntax errors 9 ['\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = ()\n        for tile in path:\n            if start_tile == ():\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != ():\n                        break\n            else:\n                # Find the next tile\n                next_tile = ()\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != ():\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport itertools\n\ndef main():\n    n = int(input())\n    tiles = [list(map(int, input().split())) for _ in range(n-1)]\n\n    print(tiles)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1), k):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile is not None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n * n:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0] * (k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = (None, None)\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile is not None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\nimport itertools\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        sys.stdout.write(str(-1))\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            sys.stdout.write(str(-1))\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    sys.stdout.write(str(best_path))\n\nif __name__ == "__main__":\n    main()\n', '\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile is None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile is not None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile is not None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())  # n: number of rows, k: number of types of tiles\n    tiles = [list(map(int, input().split())) for _ in range(n)]  # tiles[i][j]: type of tile in row i and column j\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == "__main__":\n    main()\n', '\nimport itertools\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = [list(map(int, input().split())) for _ in range(n)]\n    # print(tiles)\n\n    # Check if there are enough tiles to play\n    if k > n**2:\n        print(-1)\n        return\n\n    # Check if there are enough tiles of each number\n    tile_counts = [0]*(k+1)\n    for i in range(n):\n        for j in range(n):\n            tile_counts[tiles[i][j]] += 1\n    for tile in range(1, k+1):\n        if tile_counts[tile] == 0:\n            print(-1)\n            return\n\n    # Find the best path\n    best_path = -1\n    for path in itertools.permutations(range(1, k+1)):\n        # print(path)\n        path_length = 0\n        start_tile = None\n        for tile in path:\n            if start_tile == None:\n                # Find the first tile\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            start_tile = (i, j)\n                            break\n                    if start_tile != None:\n                        break\n            else:\n                # Find the next tile\n                next_tile = None\n                for i in range(n):\n                    for j in range(n):\n                        if tiles[i][j] == tile:\n                            next_tile = (i, j)\n                            break\n                    if next_tile != None:\n                        break\n                # Add the distance\n                path_length += abs(next_tile[0] - start_tile[0]) \\\n                    + abs(next_tile[1] - start_tile[1])\n                # print(start_tile, next_tile, path_length)\n                start_tile = next_tile\n        # print(path_length)\n        if best_path == -1 or path_length < best_path:\n            best_path = path_length\n    print(best_path)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 13:55:30.709516 size on output set 9
2022-04-16 13:55:30.709528 num operations 1
2022-04-16 13:55:30.709533 size on input set 1
2022-04-16 13:55:55.474118 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\n\ndef manhattan(x1,y1,x2,y2):\n\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nimport math\n\ndef euclidean(x1, y1, x2, y2):\n    return math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2))\n\ndef manhattan(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_neighbors(coord, n):\n    x, y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x - 1, y))\n    if x < n - 1:\n        neighbors.append((x + 1, y))\n    if y > 0:\n        neighbors.append((x, y - 1))\n    if y < n - 1:\n        neighbors.append((x, y + 1))\n    return neighbors\n\ndef get_next_coord(coord, n, board):\n    x, y = coord\n    neighbors = get_neighbors(coord, n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord, n, board):\n    path = [coord]\n    next_coord = get_next_coord(coord, n, board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord, n, board)\n    return path\n\ndef find_paths(n, k, board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i, j), n, board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path) - 1):\n        length += manhattan(path[i][0], path[i][1], path[i + 1][0], path[i + 1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n, k, board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2, 2) + math.pow(y1-y2, 2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord, n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1, y))\n    if x < n-1:\n        neighbors.append((x+1, y))\n    if y > 0:\n        neighbors.append((x, y-1))\n    if y < n-1:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_next_coord(coord, n, board):\n    x,y = coord\n    neighbors = get_neighbors(coord, n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord, n, board):\n    path = [coord]\n    next_coord = get_next_coord(coord, n, board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord, n, board)\n    return path\n\ndef find_paths(n, k, board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i, j), n, board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0], path[i][1], path[i+1][0], path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n, k, board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board,k):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1 and board[neighbor[0]][neighbor[1]] <= k:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board,k):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board,k)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board,k)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board,k))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\n\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = float(\"inf\")\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\nimport math\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x, y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x - 1, y))\n    if x < n-1:\n        neighbors.append((x + 1, y))\n    if y > 0:\n        neighbors.append((x, y - 1))\n    if y < n-1:\n        neighbors.append((x, y + 1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x, y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0], path[i][1], path[i + 1][0], path[i + 1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\nimport math\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650117330,
  "object": "edit"
}
2022-04-16 13:55:55.474586 fix syntax errors 9 ["\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\n\ndef manhattan(x1,y1,x2,y2):\n\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef euclidean(x1, y1, x2, y2):\n    return math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2))\n\ndef manhattan(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef get_neighbors(coord, n):\n    x, y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x - 1, y))\n    if x < n - 1:\n        neighbors.append((x + 1, y))\n    if y > 0:\n        neighbors.append((x, y - 1))\n    if y < n - 1:\n        neighbors.append((x, y + 1))\n    return neighbors\n\ndef get_next_coord(coord, n, board):\n    x, y = coord\n    neighbors = get_neighbors(coord, n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord, n, board):\n    path = [coord]\n    next_coord = get_next_coord(coord, n, board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord, n, board)\n    return path\n\ndef find_paths(n, k, board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i, j), n, board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path) - 1):\n        length += manhattan(path[i][0], path[i][1], path[i + 1][0], path[i + 1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n, k, board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2, 2) + math.pow(y1-y2, 2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord, n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1, y))\n    if x < n-1:\n        neighbors.append((x+1, y))\n    if y > 0:\n        neighbors.append((x, y-1))\n    if y < n-1:\n        neighbors.append((x, y+1))\n    return neighbors\n\ndef get_next_coord(coord, n, board):\n    x,y = coord\n    neighbors = get_neighbors(coord, n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord, n, board):\n    path = [coord]\n    next_coord = get_next_coord(coord, n, board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord, n, board)\n    return path\n\ndef find_paths(n, k, board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i, j), n, board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0], path[i][1], path[i+1][0], path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n, k, board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board,k):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1 and board[neighbor[0]][neighbor[1]] <= k:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board,k):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board,k)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board,k)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board,k))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", '\n\n\nimport math\n\ndef euclidean(x1,y1,x2,y2):\n    return math.sqrt(math.pow(x1-x2,2) + math.pow(y1-y2,2))\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = float("inf")\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == \'__main__\':\n    main()\n', "\nimport sys\nimport math\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x, y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x - 1, y))\n    if x < n-1:\n        neighbors.append((x + 1, y))\n    if y > 0:\n        neighbors.append((x, y - 1))\n    if y < n-1:\n        neighbors.append((x, y + 1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x, y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0], path[i][1], path[i + 1][0], path[i + 1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef manhattan(x1,y1,x2,y2):\n    return abs(x1-x2) + abs(y1-y2)\n\ndef get_neighbors(coord,n):\n    x,y = coord\n    neighbors = []\n    if x > 0:\n        neighbors.append((x-1,y))\n    if x < n-1:\n        neighbors.append((x+1,y))\n    if y > 0:\n        neighbors.append((x,y-1))\n    if y < n-1:\n        neighbors.append((x,y+1))\n    return neighbors\n\ndef get_next_coord(coord,n,board):\n    x,y = coord\n    neighbors = get_neighbors(coord,n)\n    for neighbor in neighbors:\n        if board[neighbor[0]][neighbor[1]] == board[x][y] + 1:\n            return neighbor\n    return None\n\ndef find_path(coord,n,board):\n    path = [coord]\n    next_coord = get_next_coord(coord,n,board)\n    while next_coord:\n        path.append(next_coord)\n        next_coord = get_next_coord(next_coord,n,board)\n    return path\n\ndef find_paths(n,k,board):\n    paths = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                paths.append(find_path((i,j),n,board))\n    return paths\n\ndef get_length(path):\n    length = 0\n    for i in range(len(path)-1):\n        length += manhattan(path[i][0],path[i][1],path[i+1][0],path[i+1][1])\n    return length\n\ndef get_shortest_path(paths):\n    shortest_length = sys.maxsize\n    shortest_path = None\n    for path in paths:\n        if len(path) == k:\n            length = get_length(path)\n            if length < shortest_length:\n                shortest_length = length\n                shortest_path = path\n    return shortest_path\n\ndef main():\n    n,k = [int(x) for x in input().split()]\n    board = []\n    for i in range(n):\n        board.append([int(x) for x in input().split()])\n    paths = find_paths(n,k,board)\n    shortest_path = get_shortest_path(paths)\n    if shortest_path:\n        print(get_length(shortest_path))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 13:55:55.474786 size on output set 8
2022-04-16 13:55:55.474798 num operations 1
2022-04-16 13:55:55.474803 size on input set 1
2022-04-16 13:56:07.868472 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python3\n\n\nimport sys, operator\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k-1, i+1, j), min_hopscotch_helper(tiles, n, k-1, i-1, j), min_hopscotch_helper(tiles, n, k-1, i, j+1), min_hopscotch_helper(tiles, n, k-1, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, input().split())))\n    # print(tiles)\n    # print(n, k)\n    # print(min_hopscotch(tiles, n, k))\n    print(min_hopscotch(tiles, n, k))\n\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    # print(i, j)\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    # print(tiles)\n    # print(n, k)\n    # print(min_hopscotch(tiles, n, k))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    # print(i, j)\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    # print(tiles)\n    # print(n, k)\n    # print(min_hopscotch(tiles, n, k))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    # print(i, j)\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650117355,
  "object": "edit"
}
2022-04-16 13:56:07.868801 fix syntax errors 9 ['\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == "__main__":\n    main()\n', '#!/usr/bin/env python3\n\n\nimport sys, operator\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k-1, i+1, j), min_hopscotch_helper(tiles, n, k-1, i-1, j), min_hopscotch_helper(tiles, n, k-1, i, j+1), min_hopscotch_helper(tiles, n, k-1, i, j-1)) + 1\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\n\ndef main():\n    n, k = map(int, input().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, input().split())))\n    # print(tiles)\n    # print(n, k)\n    # print(min_hopscotch(tiles, n, k))\n    print(min_hopscotch(tiles, n, k))\n\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    # print(i, j)\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    # print(tiles)\n    # print(n, k)\n    # print(min_hopscotch(tiles, n, k))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    # print(i, j)\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    tiles = []\n    for _ in range(n):\n        tiles.append(list(map(int, sys.stdin.readline().split())))\n    # print(tiles)\n    # print(n, k)\n    # print(min_hopscotch(tiles, n, k))\n    print(min_hopscotch(tiles, n, k))\n\ndef min_hopscotch(tiles, n, k):\n    if k > n*n:\n        return -1\n    if k == 1:\n        return 0\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return min_hopscotch_helper(tiles, n, k, i, j)\n    return -1\n\ndef min_hopscotch_helper(tiles, n, k, i, j):\n    # print(i, j)\n    if k == 1:\n        return 0\n    if i < 0 or j < 0 or i >= n or j >= n:\n        return -1\n    if tiles[i][j] == k:\n        return 0\n    if tiles[i][j] == 0:\n        return -1\n    return min(min_hopscotch_helper(tiles, n, k, i+1, j), min_hopscotch_helper(tiles, n, k, i-1, j), min_hopscotch_helper(tiles, n, k, i, j+1), min_hopscotch_helper(tiles, n, k, i, j-1)) + 1\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 13:56:07.868944 size on output set 6
2022-04-16 13:56:07.868966 num operations 1
2022-04-16 13:56:07.868972 size on input set 1
2022-04-16 13:56:16.059227 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef get_min_dist(n, m, k, matrix):\n    # Implement your solution here\n    return -1\n\nif __name__ == \"__main__\":\n    n, m, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, m, k, matrix))\n"
    },
    {
      "index": 1,
      "text": "\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split(\",\")]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split(\",\")])\n    print(get_min_dist(n, k, matrix))\n"
    },
    {
      "index": 2,
      "text": "\n\ndef get_min_dist(n, k, matrix, a, b):\n    # Implement your solution here\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    a, b = [int(x) for x in input().split()]\n    print(get_min_dist(n, k, matrix, a, b))\n"
    },
    {
      "index": 3,
      "text": "\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n"
    },
    {
      "index": 4,
      "text": "\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in raw_input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in raw_input().split()])\n    print(get_min_dist(n, k, matrix))\n"
    },
    {
      "index": 5,
      "text": "\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1 \n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n"
    },
    {
      "index": 6,
      "text": "\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here \n    return -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n"
    },
    {
      "index": 7,
      "text": "\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return 0\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n"
    },
    {
      "index": 8,
      "text": "\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1 #returns -1\n\nif __name__ == \"__main__\":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n"
    }
  ],
  "created": 1650117367,
  "object": "edit"
}
2022-04-16 13:56:16.059523 fix syntax errors 9 ['\n\ndef get_min_dist(n, m, k, matrix):\n    # Implement your solution here\n    return -1\n\nif __name__ == "__main__":\n    n, m, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, m, k, matrix))\n', '\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1\n\nif __name__ == "__main__":\n    n, k = [int(x) for x in input().split(",")]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split(",")])\n    print(get_min_dist(n, k, matrix))\n', '\n\ndef get_min_dist(n, k, matrix, a, b):\n    # Implement your solution here\n    return -1\n\nif __name__ == "__main__":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    a, b = [int(x) for x in input().split()]\n    print(get_min_dist(n, k, matrix, a, b))\n', '\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1\n\nif __name__ == "__main__":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n', '\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1\n\nif __name__ == "__main__":\n    n, k = [int(x) for x in raw_input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in raw_input().split()])\n    print(get_min_dist(n, k, matrix))\n', '\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1 \n\nif __name__ == "__main__":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n', '\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here \n    return -1\n\nif __name__ == "__main__":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n', '\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return 0\n\nif __name__ == "__main__":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n', '\n\ndef get_min_dist(n, k, matrix):\n    # Implement your solution here\n    return -1 #returns -1\n\nif __name__ == "__main__":\n    n, k = [int(x) for x in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in input().split()])\n    print(get_min_dist(n, k, matrix))\n']
2022-04-16 13:56:16.059568 size on output set 9
2022-04-16 13:56:16.059578 num operations 1
2022-04-16 13:56:16.059583 size on input set 1
2022-04-16 13:56:31.615337 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    input = sys.stdin.readline()\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    # print(board)\n    # print(n,k)\n\n    # print(find_start(board,n,k))\n    # print(find_end(board,n,k))\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n = int(input())\n    s = input().split()\n    print(s)\n    # n,k = map(int,input().split())\n    # board = [list(map(int,input().split())) for _ in range(n)]\n    # # print(board)\n    # # print(n,k)\n    #\n    # # print(find_start(board,n,k))\n    # # print(find_end(board,n,k))\n    # start = find_start(board,n,k)\n    # end = find_end(board,n,k)\n    # # print(start,end)\n    # if start and end:\n    #     print(manhattan_dist(start,end))\n    # else:\n    #     print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n, k = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(n)]\n    # print(board)\n    # print(n,k)\n\n    # print(find_start(board,n,k))\n    # print(find_end(board,n,k))\n    start = find_start(board, n, k)\n    end = find_end(board, n, k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start, end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == 1:\n                    return (i, j)\n        return None\n\n\ndef find_end(board,n,k):\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == k:\n                    return (i, j)\n        return None\n\n\ndef manhattan_dist(start, end):\n    return abs(start[0] - end[0]) + abs(start[1] - end[1])\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    # print(board)\n    # print(n,k)\n\n    # print(find_start(board,n,k))\n    # print(find_end(board,n,k))\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n\n    return None\n\ndef manhattan_dist(start,end):\n\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650117376,
  "object": "edit"
}
2022-04-16 13:56:31.615662 fix syntax errors 9 ['\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    input = sys.stdin.readline()\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    # print(board)\n    # print(n,k)\n\n    # print(find_start(board,n,k))\n    # print(find_end(board,n,k))\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n = int(input())\n    s = input().split()\n    print(s)\n    # n,k = map(int,input().split())\n    # board = [list(map(int,input().split())) for _ in range(n)]\n    # # print(board)\n    # # print(n,k)\n    #\n    # # print(find_start(board,n,k))\n    # # print(find_end(board,n,k))\n    # start = find_start(board,n,k)\n    # end = find_end(board,n,k)\n    # # print(start,end)\n    # if start and end:\n    #     print(manhattan_dist(start,end))\n    # else:\n    #     print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n, k = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(n)]\n    # print(board)\n    # print(n,k)\n\n    # print(find_start(board,n,k))\n    # print(find_end(board,n,k))\n    start = find_start(board, n, k)\n    end = find_end(board, n, k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start, end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == 1:\n                    return (i, j)\n        return None\n\n\ndef find_end(board,n,k):\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == k:\n                    return (i, j)\n        return None\n\n\ndef manhattan_dist(start, end):\n    return abs(start[0] - end[0]) + abs(start[1] - end[1])\n\n\nif __name__ == "__main__":\n    main()\n', '\n\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    # print(board)\n    # print(n,k)\n\n    # print(find_start(board,n,k))\n    # print(find_end(board,n,k))\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    # print(start,end)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n\n    return None\n\ndef manhattan_dist(start,end):\n\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    input = sys.stdin.readline\n    n,k = map(int,input().split())\n    board = [list(map(int,input().split())) for _ in range(n)]\n    start = find_start(board,n,k)\n    end = find_end(board,n,k)\n    if start and end:\n        print(manhattan_dist(start,end))\n    else:\n        print(-1)\n\n\ndef find_start(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                return (i,j)\n    return None\n\ndef find_end(board,n,k):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == k:\n                return (i,j)\n    return None\n\ndef manhattan_dist(start,end):\n    return abs(start[0]-end[0]) + abs(start[1]-end[1])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 13:56:31.615745 size on output set 9
2022-04-16 13:56:31.615758 num operations 1
2022-04-16 13:56:31.615763 size on input set 1
2022-04-16 13:56:54.863254 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(n, k, tiles):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(n, k, tiles):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 1
    },
    {
      "index": 2,
      "text": "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Return the minimum distance to the last tile (to be completed)\n    return 0\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) <= k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k] or -1\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n\n            # If the current tile is not the first or last tile\n            else:\n                min_distance[curr_tile] = float('inf')\n\n    # Loop through the tiles\n    for tile in range(1, k + 1):\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # If the minimum distance to the last tile is infinity\n    if min_distance[k] == float('inf'):\n        # Return -1\n        return -1\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # Loop through the tiles\n            for i2 in range(len(tiles)):\n                for j2 in range(len(tiles[i2])):\n                    curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                        # Loop through the tiles\n                        for i3 in range(len(tiles)):\n                            for j3 in range(len(tiles[i3])):\n                                curr_tile3 = tiles[i3][j3]\n\n                                # If the current tile is the third tile\n                                if curr_tile3 == 3:\n                                    # Loop through the tiles\n                                    for i4 in range(len(tiles)):\n                                        for j4 in range(len(tiles[i4])):\n                                            curr_tile4 = tiles[i4][j4]\n\n                                            # If the current tile is the last tile\n                                            if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2),\n                                                         min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i, row in enumerate(tiles):\n        for j, tile in enumerate(row):\n            curr_tile = tile\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i, row in enumerate(tiles):\n            for j, tile in enumerate(row):\n                curr_tile = tile\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2, row2 in enumerate(tiles):\n                        for j2, tile2 in enumerate(row2):\n                            curr_tile2 = tile2\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i, row in enumerate(tiles):\n        for j, tile in enumerate(row):\n            curr_tile = tile\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2, row2 in enumerate(tiles):\n                    for j2, tile2 in enumerate(row2):\n                        curr_tile2 = tile2\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3, row3 in enumerate(tiles):\n                                for j3, tile3 in enumerate(row3):\n                                    curr_tile3 = tile3\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4, row4 in enumerate(tiles):\n                                            for j4, tile4 in enumerate(row4):\n                                                curr_tile4 = tile4\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for curr_tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == curr_tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == curr_tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[curr_tile] = min(min_distance[curr_tile - 1] + abs(i - i2) + abs(j - j2), min_distance[curr_tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\ndef hopscotch(n, k, tiles):\n    \"\"\"\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    \"\"\"\n\n    # Check if the game is possible\n    if not is_possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef is_possible(tiles, k):\n    \"\"\"\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    \"\"\"\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650117391,
  "object": "edit"
}
2022-04-16 13:56:54.863824 NO RESULT
2022-04-16 13:56:54.863838 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 1
}
2022-04-16 13:56:54.863889 fix syntax errors 8 ['\n\ndef hopscotch(n, k, tiles):\n    """\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    """\n\n    # Check if game is possible\n    if not possible(n, k, tiles):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(n, k, tiles):\n    """\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    """\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef hopscotch(n, k, tiles):\n    """\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    """\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Return the minimum distance to the last tile (to be completed)\n    return 0\n\n\ndef possible(tiles, k):\n    """\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    """\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) <= k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef hopscotch(n, k, tiles):\n    """\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    """\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k] or -1\n\n\ndef possible(tiles, k):\n    """\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    """\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef hopscotch(n, k, tiles):\n    """\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    """\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n\n            # If the current tile is not the first or last tile\n            else:\n                min_distance[curr_tile] = float(\'inf\')\n\n    # Loop through the tiles\n    for tile in range(1, k + 1):\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # If the minimum distance to the last tile is infinity\n    if min_distance[k] == float(\'inf\'):\n        # Return -1\n        return -1\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    """\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    """\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # Loop through the tiles\n            for i2 in range(len(tiles)):\n                for j2 in range(len(tiles[i2])):\n                    curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                        # Loop through the tiles\n                        for i3 in range(len(tiles)):\n                            for j3 in range(len(tiles[i3])):\n                                curr_tile3 = tiles[i3][j3]\n\n                                # If the current tile is the third tile\n                                if curr_tile3 == 3:\n                                    # Loop through the tiles\n                                    for i4 in range(len(tiles)):\n                                        for j4 in range(len(tiles[i4])):\n                                            curr_tile4 = tiles[i4][j4]\n\n                                            # If the current tile is the last tile\n                                            if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef hopscotch(n, k, tiles):\n    """\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    """\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2),\n                                                         min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    """\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    """\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef hopscotch(n, k, tiles):\n    """\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    """\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i, row in enumerate(tiles):\n        for j, tile in enumerate(row):\n            curr_tile = tile\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i, row in enumerate(tiles):\n            for j, tile in enumerate(row):\n                curr_tile = tile\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2, row2 in enumerate(tiles):\n                        for j2, tile2 in enumerate(row2):\n                            curr_tile2 = tile2\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    """\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    """\n\n    # Loop through the tiles\n    for i, row in enumerate(tiles):\n        for j, tile in enumerate(row):\n            curr_tile = tile\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2, row2 in enumerate(tiles):\n                    for j2, tile2 in enumerate(row2):\n                        curr_tile2 = tile2\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3, row3 in enumerate(tiles):\n                                for j3, tile3 in enumerate(row3):\n                                    curr_tile3 = tile3\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4, row4 in enumerate(tiles):\n                                            for j4, tile4 in enumerate(row4):\n                                                curr_tile4 = tile4\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef hopscotch(n, k, tiles):\n    """\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    """\n\n    # Check if game is possible\n    if not possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for curr_tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == curr_tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == curr_tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[curr_tile] = min(min_distance[curr_tile - 1] + abs(i - i2) + abs(j - j2), min_distance[curr_tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef possible(tiles, k):\n    """\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    """\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef hopscotch(n, k, tiles):\n    """\n    Returns the minimum distance to complete a game of hopscotch.\n\n    :param n: The size of the square board.\n    :param k: The number of tiles.\n    :param tiles: The tiles on the board.\n    :return: The minimum distance to complete a game of hopscotch.\n    """\n\n    # Check if the game is possible\n    if not is_possible(tiles, k):\n        return -1\n\n    # Create a dictionary to store the minimum distance to each tile\n    min_distance = {}\n\n    # Create a list to store the tiles to visit in order\n    tiles_to_visit = []\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                min_distance[curr_tile] = 0\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is the last tile\n            elif curr_tile == k:\n                tiles_to_visit.append(curr_tile)\n\n            # If the current tile is not the first or last tile\n            else:\n                tiles_to_visit.append(curr_tile)\n\n    # Loop through the tiles in order\n    for tile in tiles_to_visit:\n        # Loop through the tiles\n        for i in range(len(tiles)):\n            for j in range(len(tiles[i])):\n                curr_tile = tiles[i][j]\n\n                # If the current tile is the tile to visit\n                if curr_tile == tile:\n                    # Loop through the tiles\n                    for i2 in range(len(tiles)):\n                        for j2 in range(len(tiles[i2])):\n                            curr_tile2 = tiles[i2][j2]\n\n                            # If the current tile is the previous tile\n                            if curr_tile2 == tile - 1:\n                                # Update the minimum distance to the current tile\n                                min_distance[tile] = min(min_distance[tile - 1] + abs(i - i2) + abs(j - j2), min_distance[tile])\n\n    # Return the minimum distance to the last tile\n    return min_distance[k]\n\n\ndef is_possible(tiles, k):\n    """\n    Returns whether or not a game of hopscotch is possible.\n\n    :param tiles: The tiles on the board.\n    :param k: The number of tiles.\n    :return: Whether or not a game of hopscotch is possible.\n    """\n\n    # Loop through the tiles\n    for i in range(len(tiles)):\n        for j in range(len(tiles[i])):\n            curr_tile = tiles[i][j]\n\n            # If the current tile is the first tile\n            if curr_tile == 1:\n                # Loop through the tiles\n                for i2 in range(len(tiles)):\n                    for j2 in range(len(tiles[i2])):\n                        curr_tile2 = tiles[i2][j2]\n\n                        # If the current tile is the second tile\n                        if curr_tile2 == 2:\n                            # Loop through the tiles\n                            for i3 in range(len(tiles)):\n                                for j3 in range(len(tiles[i3])):\n                                    curr_tile3 = tiles[i3][j3]\n\n                                    # If the current tile is the third tile\n                                    if curr_tile3 == 3:\n                                        # Loop through the tiles\n                                        for i4 in range(len(tiles)):\n                                            for j4 in range(len(tiles[i4])):\n                                                curr_tile4 = tiles[i4][j4]\n\n                                                # If the current tile is the last tile\n                                                if curr_tile4 == k:\n                                                    # Return whether or not the game is possible\n                                                    return (abs(i - i2) + abs(j - j2)) + (abs(i2 - i3) + abs(j2 - j3)) + (abs(i3 - i4) + abs(j3 - j4)) < k\n\n    # Return that the game is not possible\n    return False\n\n\ndef main():\n    # Read the input\n    n, k = [int(x) for x in input().split()]\n    tiles = [[int(x) for x in input().split()] for i in range(n)]\n\n    # Solve the problem\n    ans = hopscotch(n, k, tiles)\n\n    # Print the solution\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 13:56:54.864250 size on output set 8
2022-04-16 13:56:54.864262 num operations 1
2022-04-16 13:56:54.864267 size on input set 1
2022-04-16 13:57:08.289626 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k + 1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0] - tile[0]) + abs(start[1] - tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k + 1:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "import sys\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(start, visited, dist):\n    global min_dist\n    if len(visited) == k:\n        min_dist = min(min_dist, dist)\n        return\n    for nxt in tiles[start]:\n        if nxt in visited:\n            continue\n        visited.add(nxt)\n        dfs(nxt, visited, dist+abs(nxt[0]-start[0])+abs(nxt[1]-start[1]))\n        visited.remove(nxt)\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = float('inf')\n    for start in tiles[1]: # start is (r, c)\n        dfs(start, set([start]), 0)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650117414,
  "object": "edit"
}
2022-04-16 13:57:08.290116 fix syntax errors 9 ['\n\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        dist = 0\n        for i in range(2, k+1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0]-tile[0]) + abs(start[1]-tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = sys.maxsize\n    for start in tiles[1]:\n        visited = set()\n        visited.add(start)\n        dist = 0\n        for i in range(2, k + 1):\n            curr_dist = sys.maxsize\n            for tile in tiles[i]:\n                if tile in visited:\n                    continue\n                dist = abs(start[0] - tile[0]) + abs(start[1] - tile[1])\n                curr_dist = min(dist, curr_dist)\n            if curr_dist == sys.maxsize:\n                break\n            dist += curr_dist\n            visited.add(tile)\n            start = tile\n        if len(visited) == k + 1:\n            min_dist = min(min_dist, dist)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(start, visited, dist):\n    global min_dist\n    if len(visited) == k:\n        min_dist = min(min_dist, dist)\n        return\n    for nxt in tiles[start]:\n        if nxt in visited:\n            continue\n        visited.add(nxt)\n        dfs(nxt, visited, dist+abs(nxt[0]-start[0])+abs(nxt[1]-start[1]))\n        visited.remove(nxt)\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    tiles = [[] for _ in range(k+1)]\n    for i in range(n):\n        for j in range(n):\n            tiles[matrix[i][j]].append((i, j))\n    min_dist = float(\'inf\')\n    for start in tiles[1]: # start is (r, c)\n        dfs(start, set([start]), 0)\n    if min_dist == sys.maxsize:\n        print(-1)\n    else:\n        print(min_dist)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 13:57:08.290227 size on output set 6
2022-04-16 13:57:08.290239 num operations 1
2022-04-16 13:57:08.290245 size on input set 1
2022-04-16 13:57:45.867572 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for j in range(n):\n        if tiles[i][j] == 1:\n            return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n"
    },
    {
      "index": 1,
      "text": "\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n"
    },
    {
      "index": 2,
      "text": "\n\nn, k, m = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n\n# print(n, k, m)\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, m):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == m:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, m):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, m):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == m:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, m)\n        return 1 + find_path(tiles, next_tile, current_number + 1, m)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, m)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, m)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n"
    },
    {
      "index": 3,
      "text": "\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n"
    },
    {
      "index": 4,
      "text": "\n\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(len(tiles)):\n        for j in range(len(tiles)):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(len(tiles)):\n        for j in range(len(tiles)):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(len(tiles)):\n        for j in range(len(tiles)):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n\n    tiles = []\n    for i in range(n):\n        tiles.append(list(map(int, input().split())))\n\n    # print(tiles)\n\n    def find_start(tiles, k):\n        \"\"\"\n        Finds the starting tile (1)\n        \"\"\"\n        for i in range(n):\n            for j in range(n):\n                if tiles[i][j] == 1:\n                    return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n"
    },
    {
      "index": 6,
      "text": "\n\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\nprint(tiles)\n\ndef find_start(tiles):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == n*n:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number)\n        return 1 + find_path(tiles, next_tile, current_number + 1)\n\nstart_tile = find_start(tiles)\nend_tile = find_end(tiles)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n"
    },
    {
      "index": 7,
      "text": "\n\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1) and the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n"
    },
    {
      "index": 8,
      "text": "\n\nn, k = map(int, raw_input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, raw_input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    \"\"\"\n    Finds the starting tile (1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    \"\"\"\n    Finds the ending tile (k)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the next tile (current_number + 1)\n    \"\"\"\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    \"\"\"\n    Finds the path from current_tile to the end\n    \"\"\"\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n"
    }
  ],
  "created": 1650117428,
  "object": "edit"
}
2022-04-16 13:57:45.868032 fix syntax errors 9 ['\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    """\n    Finds the starting tile (1)\n    """\n    for j in range(n):\n        if tiles[i][j] == 1:\n            return (i, j)\n\ndef find_end(tiles, k):\n    """\n    Finds the ending tile (k)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    """\n    Finds the next tile (current_number + 1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    """\n    Finds the path from current_tile to the end\n    """\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n', '\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\ndef find_start(tiles, k):\n    """\n    Finds the starting tile (1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    """\n    Finds the ending tile (k)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    """\n    Finds the next tile (current_number + 1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    """\n    Finds the path from current_tile to the end\n    """\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n', '\n\nn, k, m = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n\n# print(n, k, m)\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    """\n    Finds the starting tile (1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, m):\n    """\n    Finds the ending tile (k)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == m:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, m):\n    """\n    Finds the next tile (current_number + 1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, m):\n    """\n    Finds the path from current_tile to the end\n    """\n    if current_number == m:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, m)\n        return 1 + find_path(tiles, next_tile, current_number + 1, m)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, m)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, m)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n', '\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    """\n    Finds the starting tile (1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    """\n    Finds the ending tile (k)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    """\n    Finds the next tile (current_number + 1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    """\n    Finds the path from current_tile to the end\n    """\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n', '\n\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    """\n    Finds the starting tile (1)\n    """\n    for i in range(len(tiles)):\n        for j in range(len(tiles)):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    """\n    Finds the ending tile (k)\n    """\n    for i in range(len(tiles)):\n        for j in range(len(tiles)):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    """\n    Finds the next tile (current_number + 1)\n    """\n    for i in range(len(tiles)):\n        for j in range(len(tiles)):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    """\n    Finds the path from current_tile to the end\n    """\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n', '\n\ndef main():\n    n, k = map(int, input().split())\n\n    tiles = []\n    for i in range(n):\n        tiles.append(list(map(int, input().split())))\n\n    # print(tiles)\n\n    def find_start(tiles, k):\n        """\n        Finds the starting tile (1)\n        """\n        for i in range(n):\n            for j in range(n):\n                if tiles[i][j] == 1:\n                    return (i, j)\n\ndef find_end(tiles, k):\n    """\n    Finds the ending tile (k)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    """\n    Finds the next tile (current_number + 1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    """\n    Finds the path from current_tile to the end\n    """\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n', '\n\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\nprint(tiles)\n\ndef find_start(tiles):\n    """\n    Finds the starting tile (1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles):\n    """\n    Finds the ending tile (k)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number):\n    """\n    Finds the next tile (current_number + 1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number):\n    """\n    Finds the path from current_tile to the end\n    """\n    if current_number == n*n:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number)\n        return 1 + find_path(tiles, next_tile, current_number + 1)\n\nstart_tile = find_start(tiles)\nend_tile = find_end(tiles)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n', '\n\nn, k = map(int, input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    """\n    Finds the starting tile (1) and the ending tile (k)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    """\n    Finds the ending tile (k)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    """\n    Finds the next tile (current_number + 1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    """\n    Finds the path from current_tile to the end\n    """\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n', '\n\nn, k = map(int, raw_input().split())\n\ntiles = []\nfor i in range(n):\n    tiles.append(list(map(int, raw_input().split())))\n\n# print(tiles)\n\ndef find_start(tiles, k):\n    """\n    Finds the starting tile (1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == 1:\n                return (i, j)\n\ndef find_end(tiles, k):\n    """\n    Finds the ending tile (k)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == k:\n                return (i, j)\n\ndef find_next(tiles, current_tile, current_number, k):\n    """\n    Finds the next tile (current_number + 1)\n    """\n    for i in range(n):\n        for j in range(n):\n            if tiles[i][j] == current_number + 1:\n                if abs(current_tile[0] - i) + abs(current_tile[1] - j) == 1:\n                    return (i, j)\n\ndef find_path(tiles, current_tile, current_number, k):\n    """\n    Finds the path from current_tile to the end\n    """\n    if current_number == k:\n        return 0\n    else:\n        next_tile = find_next(tiles, current_tile, current_number, k)\n        return 1 + find_path(tiles, next_tile, current_number + 1, k)\n\nstart_tile = find_start(tiles, k)\nend_tile = find_end(tiles, k)\n\nif abs(start_tile[0] - end_tile[0]) + abs(start_tile[1] - end_tile[1]) == 1:\n    print(0)\nelse:\n    path = find_path(tiles, start_tile, 1, k)\n    if path > 0:\n        print(path)\n    else:\n        print(-1)\n']
2022-04-16 13:57:45.868186 size on output set 9
