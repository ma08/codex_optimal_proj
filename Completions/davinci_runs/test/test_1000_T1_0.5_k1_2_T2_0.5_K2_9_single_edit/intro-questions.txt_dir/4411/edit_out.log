2022-04-16 07:08:15.243444 num operations 1
2022-04-16 07:08:15.243465 size on input set 1
2022-04-16 07:08:32.882443 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10**5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10**5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n"
    },
    {
      "index": 1,
      "text": "\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n"
    },
    {
      "index": 2,
      "text": "\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n"
    },
    {
      "index": 3,
      "text": "\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end=\" \")\n"
    },
    {
      "index": 4,
      "text": "\n\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# The number of segments that cover each point, initialized to 0\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1) \n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n"
    },
    {
      "index": 5,
      "text": "\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n"
    },
    {
      "index": 6,
      "text": "\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n"
    },
    {
      "index": 7,
      "text": "\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = \" \")\n"
    },
    {
      "index": 8,
      "text": "\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end=\" \")\n"
    }
  ],
  "created": 1650092895,
  "object": "edit"
}
2022-04-16 07:08:32.882878 fix syntax errors 9 ['\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10**5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10**5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = " ")\n', '\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = " ")\n', '\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = " ")\n', '\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end=" ")\n', '\n\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# The number of segments that cover each point, initialized to 0\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1) \n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = " ")\n', '\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = " ")\n', '\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = " ")\n', '\n#-----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end = " ")\n', '\n\n# -----Solution-----\n\n# First, we find the number of segments that cover each point.\n# Then, we iterate through the list of points, and for each point, we check how many segments cover it.\n# If the number of segments covering the point is greater than k, we add the point to the list of positions to remove.\n# We also add the segments that cover the point to the list of segments to remove.\n# We then remove the segments from the list of segments.\n# We repeat the process until we find no more positions to remove.\n\n# The number of segments that cover each point\nsegments_covering_point = [0] * (2 * (10 ** 5) + 1)\n\n# The positions of the points to remove\npositions_to_remove = []\n\n# The segments to remove\nsegments_to_remove = []\n\n# Read in the number of segments and the maximum number of segments per point\nn, k = [int(x) for x in input().split()]\n\n# Read in all of the segments\nsegments = []\nfor i in range(n):\n    segments.append([int(x) for x in input().split()])\n\n# Iterate through all of the segments\nfor i in range(n):\n    # Iterate through all of the points covered by the segment\n    for j in range(segments[i][0], segments[i][1] + 1):\n        # Increment the number of segments covering the point\n        segments_covering_point[j] += 1\n\n# Iterate through all of the points\nfor i in range(2 * (10 ** 5) + 1):\n    # If the number of segments covering the point is greater than k\n    if segments_covering_point[i] > k:\n        # Add the point to the list of positions to remove\n        positions_to_remove.append(i)\n\n# Iterate through all of the positions to remove\nfor position in positions_to_remove:\n    # Iterate through all of the segments\n    for i in range(n):\n        # If the segment covers the position to remove\n        if segments[i][0] <= position and position <= segments[i][1]:\n            # Add the segment to the list of segments to remove\n            segments_to_remove.append(i + 1)\n            # Break out of the loop\n            break\n\n# Iterate through all of the segments to remove\nfor segment in segments_to_remove:\n    # Remove the segment from the list of segments\n    segments.remove(segments[segment - 1])\n\n# Print the number of segments to remove\nprint(len(segments_to_remove))\n\n# Print the segments to remove\nfor i in range(len(segments_to_remove)):\n    print(segments_to_remove[i], end=" ")\n']
2022-04-16 07:08:32.883106 size on output set 6
2022-04-16 07:08:32.883119 num operations 1
2022-04-16 07:08:32.883124 size on input set 1
2022-04-16 07:08:49.751671 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n \nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n"
    },
    {
      "index": 1,
      "text": "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[len(result) - cnt:])\n"
    },
    {
      "index": 2,
      "text": "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt, *result[:len(result) - cnt])\n"
    },
    {
      "index": 3,
      "text": "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\nprint(segments)\n\nsegments.sort()\n\nprint(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\nprint(result)\n\nresult.sort(reverse=True)\n\nprint(result)\n\nresult = [i for _, i in result]\n\nprint(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n"
    },
    {
      "index": 4,
      "text": "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append((tuple(map(int, input().split()))))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt, *result[:len(result) - cnt])\n"
    },
    {
      "index": 5,
      "text": "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt if len(result) - cnt > 0 else 0)\nif len(result) - cnt > 0:\n    print(*result[:len(result) - cnt])\n"
    },
    {
      "index": 6,
      "text": "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt + 1)\nprint(*result[:len(result) - cnt + 1])\n"
    },
    {
      "index": 7,
      "text": "\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt, *result[:len(result) - cnt])\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\nn, k = map(int, input().split())\n\nsegments = [0] * n\nsegments_by_end = [0] * n\nfor _ in range(n):\n    l, r = map(int, input().split())\n    segments[i] = (l, r)\n    segments_by_end[i] = (r, i)\n\n# print(segments)\n\nsegments_by_end.sort()\n# print(segments_by_end)\n\n\ndef get_next_segment(segments, i):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    return (r, j - 1)\n\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n"
    }
  ],
  "created": 1650092912,
  "object": "edit"
}
2022-04-16 07:08:49.752062 fix syntax errors 9 ['\n \nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n', '\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[len(result) - cnt:])\n', '\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt, *result[:len(result) - cnt])\n', '\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\nprint(segments)\n\nsegments.sort()\n\nprint(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\nprint(result)\n\nresult.sort(reverse=True)\n\nprint(result)\n\nresult = [i for _, i in result]\n\nprint(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n', '\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append((tuple(map(int, input().split()))))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt, *result[:len(result) - cnt])\n', '\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt if len(result) - cnt > 0 else 0)\nif len(result) - cnt > 0:\n    print(*result[:len(result) - cnt])\n', '\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt + 1)\nprint(*result[:len(result) - cnt + 1])\n', '\n\nn, k = map(int, input().split())\n\nsegments = []\n\nfor _ in range(n):\n    segments.append(tuple(map(int, input().split())))\n\n# print(segments)\n\nsegments.sort()\n\n# print(segments)\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt, *result[:len(result) - cnt])\n', '\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\nn, k = map(int, input().split())\n\nsegments = [0] * n\nsegments_by_end = [0] * n\nfor _ in range(n):\n    l, r = map(int, input().split())\n    segments[i] = (l, r)\n    segments_by_end[i] = (r, i)\n\n# print(segments)\n\nsegments_by_end.sort()\n# print(segments_by_end)\n\n\ndef get_next_segment(segments, i):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    return (r, j - 1)\n\n\nresult = []\n\nfor i in range(n):\n    l, r = segments[i]\n    j = i + 1\n    while j < n and segments[j][0] <= r:\n        if segments[j][1] > r:\n            r = segments[j][1]\n        j += 1\n    result.append((r - l + 1, i + 1))\n\n# print(result)\n\nresult.sort(reverse=True)\n\n# print(result)\n\nresult = [i for _, i in result]\n\n# print(result)\n\ncnt = 0\n\nfor i in result:\n    l, r = segments[i - 1]\n    if cnt + r - l + 1 <= k:\n        cnt += r - l + 1\n    else:\n        break\n\nprint(len(result) - cnt)\nprint(*result[:len(result) - cnt])\n']
2022-04-16 07:08:49.752241 size on output set 8
