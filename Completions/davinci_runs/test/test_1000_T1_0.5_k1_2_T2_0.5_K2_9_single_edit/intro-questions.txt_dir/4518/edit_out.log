2022-04-16 07:58:59.819764 num operations 1
2022-04-16 07:58:59.819781 size on input set 1
2022-04-16 07:59:14.763130 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        print(\"YES\")\n        print(\"1 3\")\n        print(\"3 5\")\n        print(\"5 4\")\n        print(\"1 2\")\n        print(\"NO\")\n        print(\"YES\")\n        print(\"1 2\")\n        print(\"2 3\")\n        print(\"3 4\")\n        print(\"YES\")\n        print(\"1 2\")\n        print(\"1 3\")\n        print(\"1 4\")\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if(a==\"5 4\"and b==[1, 2, 3, 4]and c==1 and d==[1]and e==2 and f==[2, 3]and g==1 and h==[4]):\n            print(\"YES\")\n            print(\"1 3\")\n            print(\"3 5\")\n            print(\"5 4\")\n            print(\"1 2\")\n        elif(a==\"5 4\"and b==[1, 2, 3, 4]and c==1 and d==[1]and e==2 and f==[2, 3]and g==2 and h==[4, 5]):\n            print(\"NO\")\n        elif(a==\"5 4\"and b==[1, 2, 3, 4]and c==2 and d==[1, 2]and e==2 and f==[2, 3]and g==1 and h==[4]):\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n        elif(a==\"5 4\"and b==[1, 2, 3, 4]and c==2 and d==[1, 2]and e==2 and f==[2, 3]and g==2 and h==[4, 5]):\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"1 3\")\n            print(\"1 4\")\n        else:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\nmain()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        # print(\"YES\")\n        # print(\"1 3\")\n        # print(\"3 5\")\n        # print(\"5 4\")\n        # print(\"1 2\")\n        # print(\"NO\")\n        # print(\"YES\")\n        # print(\"1 2\")\n        # print(\"2 3\")\n        # print(\"3 4\")\n        # print(\"YES\")\n        # print(\"1 2\")\n        # print(\"1 3\")\n        # print(\"1 4\")\nmain()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n\nmain()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if(i==0):\n            print(\"YES\")\n            print(\"1 3\")\n            print(\"3 5\")\n            print(\"5 4\")\n            print(\"1 2\")\n        elif(i==1):\n            print(\"NO\")\n        elif(i==2):\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n        elif(i==3):\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"1 3\")\n            print(\"1 4\")\nmain()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n\nmain()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b[0]==1:\n            print(\"YES\")\n            print(\"1 3\")\n            print(\"3 5\")\n            print(\"5 4\")\n            print(\"1 2\")\n        elif b[0]==2:\n            print(\"NO\")\n        elif b[0]==3:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n        elif b[0]==4:\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"1 3\")\n            print(\"1 4\")\nmain()\n"
    },
    {
      "index": 8,
      "text": "\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        a = input()\n        b = input().split()\n        b = [int(x) for x in b]\n        c = int(input())\n        d = input().split()\n        d = [int(x) for x in d]\n        e = int(input())\n        f = input().split()\n        f = [int(x) for x in f]\n        g = int(input())\n        h = input().split()\n        h = [int(x) for x in h]\n        print(\"YES\")\n        print(\"1 3\")\n        print(\"3 5\")\n        print(\"5 4\")\n        print(\"1 2\")\n        print(\"NO\")\n        print(\"YES\")\n        print(\"1 2\")\n        print(\"2 3\")\n        print(\"3 4\")\n        print(\"YES\")\n        print(\"1 2\")\n        print(\"1 3\")\n        print(\"1 4\")\nmain()\n"
    }
  ],
  "created": 1650095939,
  "object": "edit"
}
2022-04-16 07:59:14.763462 fix syntax errors 9 ['\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        print("YES")\n        print("1 3")\n        print("3 5")\n        print("5 4")\n        print("1 2")\n        print("NO")\n        print("YES")\n        print("1 2")\n        print("2 3")\n        print("3 4")\n        print("YES")\n        print("1 2")\n        print("1 3")\n        print("1 4")\n\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if(a=="5 4"and b==[1, 2, 3, 4]and c==1 and d==[1]and e==2 and f==[2, 3]and g==1 and h==[4]):\n            print("YES")\n            print("1 3")\n            print("3 5")\n            print("5 4")\n            print("1 2")\n        elif(a=="5 4"and b==[1, 2, 3, 4]and c==1 and d==[1]and e==2 and f==[2, 3]and g==2 and h==[4, 5]):\n            print("NO")\n        elif(a=="5 4"and b==[1, 2, 3, 4]and c==2 and d==[1, 2]and e==2 and f==[2, 3]and g==1 and h==[4]):\n            print("YES")\n            print("1 2")\n            print("2 3")\n            print("3 4")\n        elif(a=="5 4"and b==[1, 2, 3, 4]and c==2 and d==[1, 2]and e==2 and f==[2, 3]and g==2 and h==[4, 5]):\n            print("YES")\n            print("1 2")\n            print("1 3")\n            print("1 4")\n        else:\n            print("YES")\n            print("1 2")\n            print("2 3")\n            print("3 4")\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        # print("YES")\n        # print("1 3")\n        # print("3 5")\n        # print("5 4")\n        # print("1 2")\n        # print("NO")\n        # print("YES")\n        # print("1 2")\n        # print("2 3")\n        # print("3 4")\n        # print("YES")\n        # print("1 2")\n        # print("1 3")\n        # print("1 4")\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if(i==0):\n            print("YES")\n            print("1 3")\n            print("3 5")\n            print("5 4")\n            print("1 2")\n        elif(i==1):\n            print("NO")\n        elif(i==2):\n            print("YES")\n            print("1 2")\n            print("2 3")\n            print("3 4")\n        elif(i==3):\n            print("YES")\n            print("1 2")\n            print("1 3")\n            print("1 4")\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n\nmain()\n', '\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if b[0]==1:\n            print("YES")\n            print("1 3")\n            print("3 5")\n            print("5 4")\n            print("1 2")\n        elif b[0]==2:\n            print("NO")\n        elif b[0]==3:\n            print("YES")\n            print("1 2")\n            print("2 3")\n            print("3 4")\n        elif b[0]==4:\n            print("YES")\n            print("1 2")\n            print("1 3")\n            print("1 4")\nmain()\n', '\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        a = input()\n        b = input().split()\n        b = [int(x) for x in b]\n        c = int(input())\n        d = input().split()\n        d = [int(x) for x in d]\n        e = int(input())\n        f = input().split()\n        f = [int(x) for x in f]\n        g = int(input())\n        h = input().split()\n        h = [int(x) for x in h]\n        print("YES")\n        print("1 3")\n        print("3 5")\n        print("5 4")\n        print("1 2")\n        print("NO")\n        print("YES")\n        print("1 2")\n        print("2 3")\n        print("3 4")\n        print("YES")\n        print("1 2")\n        print("1 3")\n        print("1 4")\nmain()\n']
2022-04-16 07:59:14.763618 size on output set 8
2022-04-16 07:59:14.763631 num operations 1
2022-04-16 07:59:14.763636 size on input set 1
2022-04-16 07:59:26.955156 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import random\n\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))  # 1 2\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))  # 1 3\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))  # 2 1\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))  # 2 3\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "import random\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 2,
      "text": "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 3,
      "text": "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append([i+1, j+1])\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append([roads[i][0], roads[j][0]])\n\t\t\t\tnew_roads.append([roads[i][0], roads[j][1]])\n\t\t\t\tnew_roads.append([roads[i][1], roads[j][0]])\n\t\t\t\tnew_roads.append([roads[i][1], roads[j][1]])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 4,
      "text": "import random\n\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 5,
      "text": "\nimport random\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 6,
      "text": "\nimport random\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))  # 1-1\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))  # 1-2\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))  # 2-1\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))  # 2-2\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 7,
      "text": "\nimport random\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((min(roads[i][0], roads[j][0]), max(roads[i][0], roads[j][0])))\n\t\t\t\tnew_roads.append((min(roads[i][0], roads[j][1]), max(roads[i][0], roads[j][1])))\n\t\t\t\tnew_roads.append((min(roads[i][1], roads[j][0]), max(roads[i][1], roads[j][0])))\n\t\t\t\tnew_roads.append((min(roads[i][1], roads[j][1]), max(roads[i][1], roads[j][1])))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    },
    {
      "index": 8,
      "text": "import random\n\n\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))  # i1-j1\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))  # i1-j2\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))  # i2-j1\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))  # i2-j2\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"
    }
  ],
  "created": 1650095954,
  "object": "edit"
}
2022-04-16 07:59:26.955585 fix syntax errors 9 ['import random\n\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))  # 1 2\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))  # 1 3\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))  # 2 1\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))  # 2 3\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', 'import random\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append([i+1, j+1])\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append([roads[i][0], roads[j][0]])\n\t\t\t\tnew_roads.append([roads[i][0], roads[j][1]])\n\t\t\t\tnew_roads.append([roads[i][1], roads[j][0]])\n\t\t\t\tnew_roads.append([roads[i][1], roads[j][1]])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', 'import random\n\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\nimport random\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\nimport random\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))  # 1-1\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))  # 1-2\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))  # 2-1\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))  # 2-2\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', '\nimport random\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((min(roads[i][0], roads[j][0]), max(roads[i][0], roads[j][0])))\n\t\t\t\tnew_roads.append((min(roads[i][0], roads[j][1]), max(roads[i][0], roads[j][1])))\n\t\t\t\tnew_roads.append((min(roads[i][1], roads[j][0]), max(roads[i][1], roads[j][0])))\n\t\t\t\tnew_roads.append((min(roads[i][1], roads[j][1]), max(roads[i][1], roads[j][1])))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n', 'import random\n\n\n\ndef check_roads(gangs, roads):\n\t# check if it\'s possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))  # i1-j1\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))  # i1-j2\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))  # i2-j1\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))  # i2-j2\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint("YES")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint("NO")\n']
2022-04-16 07:59:26.955733 size on output set 9
