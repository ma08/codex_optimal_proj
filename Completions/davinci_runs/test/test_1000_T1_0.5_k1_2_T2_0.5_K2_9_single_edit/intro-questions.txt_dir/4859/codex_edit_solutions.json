["\nimport sys\n\ndef main():\n    b, d, c, l = map(int, sys.stdin.readline().split())\n    if l % 2 == 1 or l < b or l < c or l < d or l > b + d + c * 2:\n        print(\"impossible\")\n        return\n    for i in range(0, l // b + 1):\n        for j in range(0, l // d + 1):\n            for k in range(0, l // c + 1):\n                if i * b + j * d + k * c == l:\n                    print(i, j, k)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n", "\n\n# This solution is incredibly slow, but it works. It uses brute force to find all possible combinations.\n\n\nb, d, c, l = map(int, input().split())\n\ndef solve(b, d, c, l):\n    if b + d + c > l:\n        return None\n    if b + d + c == l:\n        return [b, d, c]\n    for i in range(l//b + 1):\n        for j in range(l//d + 1):\n            for k in range(l//c + 1):\n                if i * b + j * d + k * c == l:\n                    return [i, j, k]\n    return None\n\nsolutions = []\n\nfor i in range(l//b + 1):\n    for j in range(l//d + 1):\n        for k in range(l//c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append([i, j, k])\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for i in sorted(solutions):\n        print(i[0], i[1], i[2])\n", "\n\nimport sys\n\ndef main():\n    b, d, c, l = [int(x) for x in sys.stdin.readline().split()]\n    solutions = []\n    for num_birds in range(l//b + 1): #0 to l//b (inclusive)\n        for num_dogs in range(l//d + 1): #0 to l//d (inclusive)\n            for num_cats in range(l//c + 1): #0 to l//c (inclusive)\n                if num_birds*b + num_dogs*d + num_cats*c == l:\n                    solutions.append([num_birds, num_dogs, num_cats])\n    if solutions:\n        solutions.sort()\n        for sol in solutions:\n            print(\" \".join([str(x) for x in sol]))\n    else:\n        print(\"impossible\")\n\nmain()\n", "\nimport sys\n\nb, d, c, l = map(int, sys.stdin.readline().split())\n\nif l % 2 != 0:\n    print('impossible')\n    sys.exit()\n\nanswers = []\n\nfor birds in range(l // b + 1):\n    for dogs in range(l // d + 1):\n        for cats in range(l // c + 1):\n            if birds * b + dogs * d + cats * c == l:\n                answers.append([birds, dogs, cats])\n\nif len(answers) == 0:\n    print('impossible')\nelse:\n    for answer in sorted(answers):\n        print(*answer)\n", "import sys\n\nb, d, c, l = map(int, sys.stdin.readline().split())\n\nif l % 2 != 0:\n    print('impossible')\n    sys.exit()\n\nanswers = []\n\nfor birds in range(l // b + 1):\n    for dogs in range(l // d + 1):\n        for cats in range(l // c + 1):\n            if birds * b + dogs * d + cats * c == l:\n                answers.append([birds, dogs, cats])\n\nif len(answers) == 0:\n    print('impossible')\nelse:\n    for answer in sorted(answers):\n        print(*answer)\n", "import sys\n\ndef main():\n    b, d, c, l = map(int, sys.stdin.readline().split())\n    if l % 2 == 1 or l < b or l < c or l < d or l > b + d + c * 2:\n        print(\"impossible\")\n        return\n    for i in range(0, l // b + 1):\n        for j in range(0, l // d + 1):\n            for k in range(0, l // c + 1):\n                if i * b + j * d + k * c == l:\n                    print(i, j, k)\n\nif __name__ == (\"__main__\"):\n    main()\n", "\nb, d, c, l = [int(x) for x in input().split()]\n\nsolutions = []\n\nfor i in range(l // b + 1):\n    for j in range(l // d + 1):\n        for k in range(l // c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append((i, j, k))\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for solution in sorted(solutions):\n        print(\" \".join([str(x) for x in solution]))\n", "\n\n# This solution is incredibly slow, but it works. It uses brute force to find all possible combinations.\n\n\nb, d, c, l = map(int, input().split())\n\ndef solve(b, d, c, l):\n    if b + d + c > l:\n        return None\n    if b + d + c == l:\n        return [b, d, c]\n    for i in range(l // b + 1):\n        for j in range(l // d + 1):\n            for k in range(l // c + 1):\n                if i * b + j * d + k * c == l:\n                    return [i, j, k]\n    return None\n\n\nsolutions = []\nfor i in range(l // b + 1):\n    for j in range(l // d + 1):\n        for k in range(l // c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append([i, j, k])\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for i in sorted(solutions):\n        print(i[0], i[1], i[2])\n", "\n\nimport sys\n\ndef legs(b,d,c,l,acc):\n    if l<0:\n        return\n    if b==0 and d==0 and c==0:\n        print(\"{} {} {}\".format(b,d,c,l))\n        return\n    legs(b-1,d,c,l-b,acc+b)\n    legs(b,d-1,c,l-d,acc+d)\n    legs(b,d,c-1,l-c,acc+c)\n\ndef main():\n    data = sys.stdin.readline().split()\n    b = int(data[0])\n    d = int(data[1])\n    c = int(data[2])\n    l = int(data[3])\n    legs(b,d,c,l,0)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef possible(b, d, c, l):\n    for i in xrange(0, l/b + 1):\n        for j in xrange(0, l/d + 1):\n            for k in xrange(0, l/c + 1):\n                if i*b + j*d + k*c == l:\n                    print i, j, k\n\ndef main():\n    lines = sys.stdin.readlines()\n    b, d, c, l = map(int, lines[0].strip().split(' '))\n    possible(b, d, c, l)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef legs(b, d, c, l):\n    if l < 0:\n        return\n    if b == 0 and d == 0 and c == 0:\n        print(\"{} {} {}\".format(b, d, c))\n        return\n    legs(b - 1, d, c, l - b)\n    legs(b, d - 1, c, l - d)\n    legs(b, d, c - 1, l - c)\n\n\ndef main():\n    data = sys.stdin.readline().split()\n    b = int(data[0])\n    d = int(data[1])\n    c = int(data[2])\n    l = int(data[3])\n    legs(b, d, c, l)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef legs(b,d,c,l):\n    if l < 0:\n        return\n    if b == 0 and d == 0 and c == 0:\n        print(\"{} {} {}\".format(b,d,c))\n        return\n    legs(b-1, d, c, l-b)\n    legs(b, d-1, c, l-d)\n    legs(b, d, c-1, l-c)\n\ndef main():\n    data = sys.stdin.readline().split()\n    b = int(data[0])\n    d = int(data[1])\n    c = int(data[2])\n    l = int(data[3])\n    legs(b, d, c, l)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef possible(b, d, c, l):\n    for i in xrange(0, l/b + 1):\n        for j in xrange(0, l/d + 1):\n            for k in xrange(0, l/c + 1):\n                if i*b + j*d + k*c == l:\n                    print i, j, k\n\ndef main():\n    lines = sys.stdin.readlines()\n    b, d, c, l = map(int, lines[0].strip().split(' '))\n    possible(b, d, c, l)\n\nif __name__ == '__main__':\n    main()\n", "\n\nb, d, c, l = map(int, input().split())\n\nsolutions = []\n\nfor i in range(l // b + 1):\n    for j in range(l // d + 1):\n        for k in range(l // c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append((i, j, k))\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for solution in sorted(solutions):\n        print(\" \".join([str(x) for x in solution]))\n", "\n\n#This solution is incredibly slow, but it works. It uses brute force to find all possible combinations\n\nb, d, c, l = map(int, input().split())\n\ndef solve(b, d, c, l):\n    if b + d + c > l:\n        return None\n    if b + d + c == l:\n        return [b, d, c]\n    for i in range(l//b + 1):\n        for j in range(l//d + 1):\n            for k in range(l//c + 1):\n                if i * b + j * d + k * c == l:\n                    return [i, j, k]\n    return None\n\nsolutions = []\nfor i in range(l//b + 1):\n    for j in range(l//d + 1):\n        for k in range(l//c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append([i, j, k])\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for i in sorted(solutions):\n        print(i[0], i[1], i[2])\n", "\n\nimport sys\n\ndef legs(b,d,c,l):\n    if l<0:\n        return\n    if b==0 and d==0 and c==0:\n        print(\"{} {} {}\".format(b,d,c))\n        return\n    legs(b-1,d,c,l-b)\n    legs(b,d-1,c,l-d)\n    legs(b,d,c-1,l-c)\n\ndef main():\n    data = sys.stdin.readline().split()\n    b = int(data[0])\n    d = int(data[1])\n    c = int(data[2])\n    l = int(data[3])\n    legs(b, d, c, l)\n\nif __name__ == \"__main__\":\n    main()\n", "\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n", "\n\nfrom itertools import product\n\nb, d, c, l = map(int, input().split()) \n\nfor i, j, k in product(range(l//b + 1), range(l//d + 1), range(l//c + 1)):\n    if i*b + j*d + k*c == l:\n        print(i, j, k)\n", "b, d, c, l = [int(x) for x in input().split()]\nsolutions = []\n\nfor i in range(l // b + 1):\n    for j in range(l // d + 1):\n        for k in range(l // c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append((i, j, k))\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for solution in sorted(solutions):\n        print(\" \".join([str(x) for x in solution]))\n", "\n\n#This solution is incredibly slow, but it works. It uses\n# brute force to find all possible combinations.\n\nb, d, c, l = map(int, input().split()) #input\n\ndef solve(b, d, c, l):\n    if b + d + c > l:\n        return None #if the sum is greater than the length\n    if b + d + c == l:\n        return [b, d, c]\n    return None #if the sum is equal to the length\n\nsolutions = []\n#loop to find all possible combinations\nfor i in range(l//b + 1):\n    for j in range(l//d + 1):\n        for k in range(l//c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append([i, j, k])\n\nif len(solutions) == 0: #if there are no solutions\n    print(\"impossible\") #print impossible\nelse:\n    for i in sorted(solutions): #sorts the list\n        print(i[0], i[1], i[2]) #prints the solutions\n", "\n\nb, d, c, l = map(int, input().split())\n\nsolutions = []\n\nfor i in range(l // b + 1):\n    for j in range(l // d + 1):\n        for k in range(l // c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append((i, j, k))\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for solution in sorted(solutions):\n        print(*solution)\n", "\n\nimport sys\n\ndef possible(b, d, c, l):\n    for i in range(0, l/b + 1):\n        for j in range(0, l/d + 1):\n            for k in range(0, l/c + 1):\n                if i*b + j*d + k*c == l:\n                    print i, j, k\n\ndef main():\n    lines = sys.stdin.readlines()\n    b, d, c, l = map(int, lines[0].strip().split(' '))\n    possible(b, d, c, l)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom itertools import product\nb, d, c, l = map(int, input().split())\n\nfor i, j, k in product(range(l//b + 1), range(l//d + 1), range(l//c + 1)):\n    if i*b + j*d + k*c == l:\n        print(i, j, k)\n", "\n\n# This solution is incredibly slow, but it works. It uses brute force to find all possible combinations.\n\n\ndef solve(b, d, c, l, solutions):\n    if b + d + c > l:\n        return\n    if b + d + c == l and [b, d, c] not in solutions:\n        solutions.append([b, d, c])\n    for i in range(l // b + 1):\n        for j in range(l // d + 1):\n            for k in range(l // c + 1):\n                if i * b + j * d + k * c == l:\n                    solutions.append([i, j, k])\n\nb, d, c, l = map(int, input().split())\nsolve(b, d, c, l, solutions)\nsolve(b, c, d, l, solutions)\nsolve(c, b, d, l, solutions)\nsolve(c, d, b, l, solutions)\nsolve(d, b, c, l, solutions)\nsolve(d, c, b, l, solutions)\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for i in sorted(solutions):\n        print(i[0], i[1], i[2])\n\n\n\n\n", "#!/usr/bin/env python3\n\n\nb, d, c, l = (int(x) for x in input().split())\n\nsolutions = []\n\nfor i in range(l // b + 1):\n    for j in range(l // d + 1):\n        for k in range(l // c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append((i, j, k))\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for solution in sorted(solutions):\n        print(\" \".join(str(x) for x in solution))\n", "\nimport sys\n\ndef main():\n    b, d, c, l = [int(x) for x in sys.stdin.readline().split()]\n    solutions = []\n    for num_birds in range(l // b + 1):\n        for num_dogs in range(l // d + 1):\n            for num_cats in range(l // c + 1):\n                if num_birds*b + num_dogs*d + num_cats*c == l:\n                    solutions.append([num_birds, num_dogs, num_cats])\n    if solutions:\n        solutions.sort()\n        for sol in solutions:\n            print(\" \".join([str(x) for x in sol]))\n    else:\n        print(\"impossible\")\n\nmain()\n", "\n\nb, d, c, l = [int(x) for x in input().split()] \n\nsolutions = []\n\nfor i in range(l // b + 1):\n    for j in range(l // d + 1):\n        for k in range(l // c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append((i, j, k))\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for solution in sorted(solutions):\n        print(\" \".join([str(x) for x in solution]))\n", "\nfrom itertools import product\n\nb, d, c, l = map(int, input().split())\n\nfor i, j, k in product(range(l//b + 1), range(l//d + 1), range(l//c + 1)):\n    if i*b + j*d + k*c == l:\n        print(i, j, k)\n", "\n\n# This solution is incredibly slow, but it works. It uses brute force to find all possible combinations.\n\nb, d, c, l = map(int, input().split())\n\ndef solve(b, d, c, l):\n    if b + d + c > l:\n        return None\n    if b + d + c == l:\n        return [b, d, c]\n    for i in range(l//b + 1):\n        for j in range(l//d + 1):\n            for k in range(l//c + 1):\n                if i * b + j * d + k * c == l:\n                    return [i, j, k]\n    return None\n\nsolutions = []\nfor i in range(l//b + 1):\n    for j in range(l//d + 1):\n        for k in range(l//c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append([i, j, k])\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for i in sorted(solutions):\n        print(i[0], i[1], i[2])\n", "import sys\n\nbirds, dogs, cats, legs = map(int, sys.stdin.readline().split())\n\nif legs % 2 != 0:\n    print('impossible')\n    sys.exit()\n\nanswers = []\n\nfor birds in range(legs // birds + 1):\n    for dogs in range(legs // dogs + 1):\n        for cats in range(legs // cats + 1):\n            if birds * birds + dogs * dogs + cats * cats == legs:\n                answers.append([birds, dogs, cats])\n\nif len(answers) == 0:\n    print('impossible')\nelse:\n    for answer in sorted(answers):\n        print(*answer)\n", "\n\nfrom itertools import product\n\nb, d, c, l = map(int, input().split()) # b, d, c, l = (int(x) for x in input().split())\n\nfor i, j, k in product(range(l//b + 1), range(l//d + 1), range(l//c + 1)):\n    if i*b + j*d + k*c == l:\n        print(i, j, k)\n", "\n\nimport sys\n\nb, d, c, l = map(int, sys.stdin.readline().split())  # read input\n# check if input is valid\n\nif l % 2 != 0:\n    print('impossible')\n    sys.exit()  # terminate program if input is invalid\n\nanswers = []  # store all possible solutions\n# iterate through all possible combinations\n\nfor birds in range(l // b + 1):\n    for dogs in range(l // d + 1):\n        for cats in range(l // c + 1):\n            if birds * b + dogs * d + cats * c == l:\n                answers.append([birds, dogs, cats])\n# print answer if possible\n\nif len(answers) == 0:\n    print('impossible')\nelse:\n    for answer in sorted(answers):\n        print(*answer)\n", "\n\nimport sys\n\ndef legs(b,d,c,l):\n    if l<0:\n        return\n    if b==0 and d==0 and c==0:\n        print(\"{} {} {}\".format(b,d,c))\n        return\n    if b>0:\n        legs(b-1,d,c,l-b)\n    if d>0:\n        legs(b,d-1,c,l-d)\n    if c>0:\n        legs(b,d,c-1,l-c)\n\ndef main():\n    data = sys.stdin.readline().split()\n    b = int(data[0])\n    d = int(data[1])\n    c = int(data[2])\n    l = int(data[3])\n    legs(b,d,c,l)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    b, d, c, l = map(int, sys.stdin.readline().split())\n    if l % 2 == 1 or l < b or l < c or l < d or l > b + d + c * 2:\n        print(\"impossible\")\n        return\n    for i in range(0, l // b + 1):\n        for j in range(0, l // d + 1):\n            for k in range(0, l // c + 1):\n                if i * b + j * d + k * c == l:\n                    print(i, j, k)\n\nif __name__ == (\"__main__\"): \n    main()\n", "\n\nfrom itertools import product\n\na, b, c, l = map(int, input().split())\n\nfor i, j, k in product(range(l//a + 1), range(l//b + 1), range(l//c + 1)):\n    if i*a + j*b + k*c == l:\n        print(i, j, k)\n", "\nimport sys\n\ndef legs(b,d,c,l):\n    if l<0:\n        return\n    if b==0 and d==0 and c==0:\n        print(\"{} {} {}\".format(b,d,c))\n        return\n    legs(b-1,d,c,l-b)\n    legs(b,d-1,c,l-d)\n    legs(b,d,c-1,l-c)\n\ndef main():\n    data = sys.stdin.readline().split()\n    b = int(data[0])\n    d = int(data[1])\n    c = int(data[2])\n    l = int(data[3])\n    legs(b,d,c,l)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef legs(b,d,c,l):\n    if l<0 or b<0 or d<0 or c<0:\n        return False\n    if b==0 and d==0 and c==0:\n        print(\"{} {} {}\".format(b,d,c))\n        return True\n    legs(b-1,d,c,l-b)\n    legs(b,d-1,c,l-d)\n    legs(b,d,c-1,l-c) \n\ndef main():\n    data = sys.stdin.readline().split()\n    b = int(data[0])\n    d = int(data[1])\n    c = int(data[2])\n    l = int(data[3])\n    legs(b,d,c,l)\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef main():\n    b, d, c, l = [int(x) for x in sys.stdin.readline().split()] # b, d, c, l = [int(x) for x in raw_input().split()]\n    solutions = []\n    for num_birds in range(l//b + 1):\n        for num_dogs in range(l//d + 1):\n            for num_cats in range(l//c + 1):\n                if num_birds*b + num_dogs*d + num_cats*c == l:\n                    solutions.append([num_birds, num_dogs, num_cats])\n    if solutions:\n        solutions.sort()\n        for sol in solutions:\n            print(\" \".join([str(x) for x in sol]))\n    else:\n        print(\"Impossible\")\n\nmain()\n", "\nimport sys\n\ndef legs(b,d,c,l):\n    if l < 0:\n        return\n    if b == 0 and d == 0 and c == 0:\n        print(\"{} {} {}\".format(b,d,c))\n        return\n    legs(b - 1, d, c, l - b)\n    legs(b, d - 1, c, l - d)\n    legs(b, d, c - 1, l - c)\n\ndef main():\n    data = sys.stdin.readline().split()\n    b = int(data[0])\n    d = int(data[1])\n    c = int(data[2])\n    l = int(data[3])\n    legs(b, d, c, l)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\n\nimport sys\n\ndef possible(b, d, c, l):\n    for i in xrange(0, l/b + 1):\n        for j in xrange(0, l/d + 1):\n            for k in xrange(0, l/c + 1):\n                if i*b + j*d + k*c == l:\n                    print i, j, k\n\ndef main():\n    lines = sys.stdin.readlines()\n    b, d, c, l = map(int, lines[0].strip().split(' '))\n    possible(b, d, c, l)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# This solution is incredibly slow, but it works. It uses brute force to find all possible combinations.\n\nb, d, c, l = map(int, input().split())\n\ndef solve(b, d, c, l):\n    if b + d + c > l:\n        return None\n    if b + d + c == l:\n        return [b, d, c]\n    for i in range(l // b + 1):\n        for j in range(l // d + 1):\n            for k in range(l // c + 1):\n                if i * b + j * d + k * c == l:\n                    return [i, j, k]\n    return None\n\nsolutions = []\nfor i in range(l // b + 1):\n    for j in range(l // d + 1):\n        for k in range(l // c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.append([i, j, k])\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for i in sorted(solutions):\n        print(i[0], i[1], i[2])\n", "\n\nimport sys\n\ndef legs(b,d,c,l):\n    if l < 0:\n        return\n    if b == 0 and d == 0 and c == 0:\n        print(\"{} {} {}\".format(b, d, c))\n        return\n    legs(b - 1, d, c, l - b)\n    legs(b, d - 1, c, l - d)\n    legs(b, d, c - 1, l - c)\n\n\ndef main():\n    data = sys.stdin.readline().split()\n    b = int(data[0])\n    d = int(data[1])\n    c = int(data[2])\n    l = int(data[3])\n    legs(b, d, c, l)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom itertools import permutations\n\na = input().split()\nfor i in permutations(a[0], int(a[1])):\n    print(''.join(i))\n", "\nimport sys\n\nb, d, c, l = map(int, sys.stdin.readline().split()) # \u043d\u0430 \u0432\u0445\u043e\u0434 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u043c 4 \u0447\u0438\u0441\u043b\u0430\n\nif l % 2 != 0: # \u0435\u0441\u043b\u0438 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0435 \u0447\u0438\u0441\u043b\u043e \u043d\u0435\u0447\u0435\u0442\u043d\u043e\u0435, \u0442\u043e \u0432\u044b\u0432\u043e\u0434\u0438\u043c impossible\n    print('impossible')\n    sys.exit() # \u0438 \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u043c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443\n\nanswers = [] # \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043f\u0443\u0441\u0442\u043e\u0439 \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u043b\u044f \u043e\u0442\u0432\u0435\u0442\u043e\u0432\n\nfor birds in range(l // b + 1): # \u043f\u0440\u043e\u0431\u0435\u0433\u0430\u0435\u043c\u0441\u044f \u043f\u043e \u0432\u0441\u0435\u043c \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u043c \u043a\u043e\u043c\u0431\u0438\u043d\u0430\u0446\u0438\u044f\u043c \u0447\u0438\u0441\u0435\u043b\n    for dogs in range(l // d + 1):\n        for cats in range(l // c + 1):\n            if birds * b + dogs * d + cats * c == l: # \u0435\u0441\u043b\u0438 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0435 \u0447\u0438\u0441\u043b\u043e \u0440\u0430\u0432\u043d\u043e \u0441\u0443\u043c\u043c\u0435 \u0432\u0441\u0435\u0445 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0438\u0445, \u0442\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u044d\u0442\u043e\u0442 \u043e\u0442\u0432\u0435\u0442 \u0432 \u0441\u043f\u0438\u0441\u043e\u043a\n                answers.append([birds, dogs, cats])\n\nif len(answers) == 0: # \u0435\u0441\u043b\u0438 \u043e\u0442\u0432\u0435\u0442\u043e\u0432 \u043d\u0435\u0442, \u0442\u043e \u0432\u044b\u0432\u043e\u0434\u0438\u043c impossible\n    print('impossible')\nelse:\n    for answer in sorted(answers): # \u0438\u043d\u0430\u0447\u0435 \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0432\u0441\u0435 \u043e\u0442\u0432\u0435\u0442\u044b \u043f\u043e \u043f\u043e\u0440\u044f\u0434\u043a\u0443\n        print(*answer)\n", "\n\n# This solution is incredibly slow, but it works. It uses brute force to find all possible combinations.\n\nb, d, c, l = map(int, input().split())\n\ndef solve(b, d, c, l):\n    if b + d + c > l:\n        return None\n    if b + d + c == l:\n        return [b, d, c]\n    for i in range(l//b + 1):\n        for j in range(l//d + 1):\n            for k in range(l//c + 1):\n                if i * b + j * d + k * c == l:\n                    return [i, j, k]\n    return None\n\nsolutions = [solve(b, d, c, l) for i in range(l//b + 1) for j in range(l//d + 1) for k in range(l//c + 1) if i * b + j * d + k * c == l]\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for i in sorted(solutions):\n        print(i[0], i[1], i[2])\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    b, d, c, l = [int(x) for x in sys.stdin.readline().split()]\n    solutions = []\n    for num_birds in range(l//b + 1):\n        for num_dogs in range(l//d + 1):\n            for num_cats in range(l//c + 1):\n                if num_birds*b + num_dogs*d + num_cats*c == l:\n                    solutions.append([num_birds, num_dogs, num_cats])\n    if solutions:\n        solutions.sort()\n        for sol in solutions:\n            print(\" \".join([str(x) for x in sol]))\n    else:\n        print(\"impossible\")\n\nmain()\n", "#!/usr/bin/env python3\n\nfrom itertools import product\n\nb, d, c, l = map(int, input().split())\n\nfor i, j, k in product(range(l//b + 1), range(l//d + 1), range(l//c + 1)):\n    if i*b + j*d + k*c == l and i*b > 0 and j*d > 0 and k*c > 0:\n        print(i, j, k, sep=\" \")\n", "\n\n\nimport sys\n\ndef main():\n    b, d, c, l = [int(x) for x in sys.stdin.readline().split()]\n    solutions = []\n    for num_birds in range(l//b + 1):\n        for num_dogs in range(l//d + 1):\n            for num_cats in range(l//c + 1):\n                if num_birds*b + num_dogs*d + num_cats*c == l:\n                    solutions.append([num_birds, num_dogs, num_cats])\n    if solutions:\n        solutions.sort()\n        for sol in solutions:\n            print(\" \".join([str(x) for x in sol]))\n    else:\n        print(\"impossible\")\n\nmain()\n", "\n\nimport sys\n\ndef possible(b, d, c, l):\n    for i in range(0, l//b + 1):\n        for j in range(0, l//d + 1):\n            for k in range(0, l//c + 1):\n                if i*b + j*d + k*c == l:\n                    print i, j, k\n\ndef main():\n    lines = sys.stdin.readlines()\n    b, d, c, l = map(int, lines[0].strip().split(' '))\n    possible(b, d, c, l)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    b, d, c, l = [int(x) for x in sys.stdin.readline().split()]\n    solutions = []\n    for num_birds in range(l//b + 1):  # l//b rounds down to the nearest integer, so we have to add 1\n        for num_dogs in range(l//d + 1):  # to ensure that we count up to l.\n            for num_cats in range(l//c + 1):  # Otherwise, we would miss the case where l is\n                if num_birds*b + num_dogs*d + num_cats*c == l:  # exactly divisible by b, d, or c.\n                    solutions.append([num_birds, num_dogs, num_cats])\n    if solutions:\n        solutions.sort()\n        for sol in solutions:\n            print(\" \".join([str(x) for x in sol]))\n    else:\n        print(\"impossible\")\n\nmain()\n", "\nimport sys\n\ndef main():\n    b, d, c, l = [int(x) for x in input().split()]\n    solutions = []\n    for num_birds in range(l // b + 1):\n        for num_dogs in range(l // d + 1):\n            for num_cats in range(l // c + 1):\n                if num_birds * b + num_dogs * d + num_cats * c == l:\n                    solutions.append([num_birds, num_dogs, num_cats])\n    if solutions:\n        solutions.sort()\n        for sol in solutions:\n            print(\" \".join([str(x) for x in sol]))\n    else:\n        print(\"impossible\")\n\nmain()\n", "\nimport sys\n\ndef main():\n    b, d, c, l = map(int, sys.stdin.readline().split())\n    if l % 2 == 1 or l < b or l < d or l < c or l > b + d + c * 2:\n        print(\"impossible\")\n        return\n    for i in range(0, l // b + 1):\n        for j in range(0, l // d + 1):\n            for k in range(0, l // c + 1):\n                if i * b + j * d + k * c == l:\n                    print(i, j, k)\n\nif __name__ == (\"__main__\"):\n    main()\n", "\nfrom itertools import product\n\nb, d, c, l = map(int, input().split(\" \"))\n\nfor i, j, k in product(range(l // b + 1), range(l // d + 1), range(l // c + 1)):\n    if i * b + j * d + k * c == l:\n        print(i, j, k)\n", "\n\nb, d, c, l = map(int, input().split())\n\nsolutions = set()\n\nfor i in range(l // b + 1):\n    for j in range(l // d + 1):\n        for k in range(l // c + 1):\n            if i * b + j * d + k * c == l:\n                solutions.add((i, j, k))\n\nif len(solutions) == 0:\n    print(\"impossible\")\nelse:\n    for solution in solutions:\n        print(\" \".join([str(x) for x in solution]))\n", "\n\nimport sys\n\ndef possible(b, d, c, l):\n    for i in xrange(0, l/b + 1):\n        for j in xrange(0, l/d + 1):\n            for k in xrange(0, l/c + 1):\n                if i*b + j*d + k*c == l:\n                    print(i, j, k)\n\ndef main():\n    lines = sys.stdin.readlines()\n    b, d, c, l = map(int, lines[0].strip().split(' '))\n    possible(b, d, c, l)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\nb, d, c, l = map(int, sys.stdin.readline().split())\n\nif l % 2 != 0:\n    print('impossible')\n    sys.exit()\nanswers = []\n\nfor birds in range(l // b + 1):\n    for dogs in range(l // d + 1):\n        for cats in range(l // c + 1):\n            if birds * b + dogs * d + cats * c == l:\n                answers.append([birds, dogs, cats])\n\nif len(answers) == 0:\n    print('impossible')\nelse:\n    for answer in sorted(answers):\n        print(*answer)\n", "\nimport sys\n\ndef main():\n    b, d, c, l = map(int, sys.stdin.readline().split())\n    if l % 2 == 1 or l < b or l < c or l < d or l > b + d + c * 2:\n        print(\"impossible\")\n        return\n    for i in range(0, l // b + 1):\n        for j in range(0, l // d + 1):\n            for k in range(0, l // c + 1):\n                if i * b + j * d + k * c == l:\n                    print(i, j, k)\n\nmain()\n", "\nimport sys\n\ndef main():\n    b, d, c, l = [int(x) for x in sys.stdin.readline().split()]\n    solutions = []\n    for num_birds in range(l//b + 1):\n        for num_dogs in range(l//d + 1):\n            for num_cats in range(l//c + 1):\n                if num_birds*b + num_dogs*d + num_cats*c == l:\n                    solutions.append([num_birds, num_dogs, num_cats])\n    if solutions:\n        solutions.sort()\n        for sol in solutions:\n            print(\" \".join([str(x) for x in sol]))\n    else:\n        print(\"impossible\")\n\nmain()\n"]