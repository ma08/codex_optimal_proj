["N = int(input())\nab = [list(map(int, input().split())) for _ in range(N)]\ncd = [list(map(int, input().split())) for _ in range(N)]\nab.sort()\ncd.sort()\n\ng = [[] for _ in range(N)]\n\nfor i, pab in enumerate(ab):\n    for j, pcd in enumerate(cd):\n        if pab[0] < pcd[0] and pab[1] < pcd[1]:\n            g[j].append([pab[1],i])\n        \nans = 0\ns = set()\n\nfor gg in g:\n    gg.sort(reverse=True)\n    for ggg in gg:\n        if ggg[1] in s:continue\n        else:\n            ans += 1\n            s.add(ggg[1])\n            break\nprint(ans)\n", "N = int(input())\nR = [list(map(int,input().split())) for n in range(N)]\nB = [list(map(int,input().split())) for n in range(N)]\nR.sort(key=lambda x:-x[1])\nB.sort()\nans=0\n\nfor c,d in B:\n  for a,b in R:\n    if a<c and b<d:\n      ans+=1\n      R.remove([a,b])\n      break\n\nprint(ans)", "import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\nsys.setrecursionlimit(10000000)\n\nN = int(input())\nAB = []\nCD = []\n\nfor i in range(N):\n    A, B = map(int, input().split())\n    AB.append((A, B))\n\nfor i in range(N):\n    C, D = map(int, input().split())\n    CD.append((C, D))\n\nAB.sort()\nCD.sort()\n\nused = [False] * N\ncnt = 0\n\nfor i in range(N):\n    m = -1\n    for j in range(N):\n        if not used[j] and CD[i][0] > AB[j][0] and CD[i][1] > AB[j][1]:\n            if m < 0 or AB[m][1] < AB[j][1]:\n                m = j\n\n    if m >= 0:\n        used[m] = True\n        cnt += 1\n\nprint(cnt)", "import sys\ninput = sys.stdin.readline\n\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import maximum_bipartite_matching\nimport numpy as np\n\nN = int(input())\n\nX = []\nY = []\nfor i in range(N):\n    X.append([int(i) for i in input().split()])\n\nfor i in range(N):\n    Y.append([int(i) for i in input().split()])\n\ndata = []\nfor i in range(len(X)):\n    for j in range(N):\n        if X[i][0] < Y[j][0] and X[i][1] < Y[j][1]:\n            data.append([i,j,1])\n\n\nif not data:\n    print(0)\n    return\n\nedge = np.array(data, dtype = np.int64).T\n# graph = csr_matrix((edge[2], (edge[:2] - 1)), (V, V))\ngraph = csr_matrix((edge[2], (edge[:2])), (len(X), len(Y)))           # \u756a\u53f7\u306e\u30c7\u30af\u30ea\u30e1\u30f3\u30c8\u304c\u4e0d\u8981\u306a\u5834\u5408\n\nmatching = maximum_bipartite_matching(graph, perm_type=\"column\")\n\nprint(sum(d!=-1 for d in matching))", "N=int(input())\nred=[]\nblue=[]\nfor _ in range(N):\n  a,b = map(int,input().split())\n  red.append((a+1,b+1))\nfor _ in range(N):\n  c,d = map(int,input().split())\n  blue.append((c+1,d+1))\n\nblue.sort(key=lambda x:x[0])\nfor b in blue:\n  c = None\n  bx, by = b\n  for r in red:\n    rx, ry = r\n    if rx < bx and ry < by:\n      if c is None or c[1] < ry:\n        c = r\n  if c:\n    red.remove(c)\n\nprint(N-len(red))", "# coding: utf-8\nimport sys\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\n\"\"\"\nN\u304c\u5c0f\u3055\u3044\u306e\u3067\u3001Y\u5ea7\u6a19\u3067cand\u306b\u5165\u308c\u3066\u304a\u304f\n\"\"\"\nN = ir()\nAB = [lr() for _ in range(N)]\nCD = [lr() for _ in range(N)]\ncand = [0] * (2*N)\nABCD = [(a, b, 0) for a, b in AB] + [(c, d, 1) for c, d in CD]\nABCD.sort()\nanswer = 0\nfor X, Y, Z in ABCD:\n    if Z == 0:\n        cand[Y] += 1\n    else:\n        for y in range(Y-1, -1, -1):\n            if cand[y] > 0:\n                answer += 1\n                cand[y] -= 1\n                break\n\nprint(answer)\n", "N = int(input())\nab = [list(map(int, input().split())) for _ in range(N)]\ncd = [list(map(int, input().split())) for _ in range(N)]\nab.sort(reverse=True)\ncd.sort()\np = 0\nfor c in cd:\n    ac = [-1, -1]\n    for a in ab:\n        if c[0] > a[0] and c[1] > a[1] and ac[1] < a[1]:\n            ac = a\n    if ac != [-1, -1]:\n        p += 1\n        ab.remove(ac)\n\nprint(p)\n", "n = int(input())\nAB = list(list(map(int,input().split())) for _ in range(n))\nCD = list(list(map(int,input().split())) for _ in range(n))\n\nCD.sort() # sort x in ascending order\nAB.sort(key=lambda z: z[1], reverse=True) # sort x in descending order\n\ndim_b = [[] for _ in range(n)]\nfor b in range(n):\n    for r in range(n):\n        if AB[r][0] < CD[b][0] and AB[r][1] < CD[b][1]:\n            dim_b[b] += [r]\n\nvis_r = [False]*(n)\nfor b in range(n): # ascending order of x\n    for r in dim_b[b]: # descending order of y\n        if not vis_r[r]: vis_r[r] = True; break\n\nprint((sum(vis_r)))\n", "#!/usr/bin/env python3\n\nimport networkx as nx\n\n\nn = int(input())\nab = [list(map(int, input().split())) for i in range(n)]\ncd = [list(map(int, input().split())) for i in range(n)]\n\n\nmatch_list = [[] for i in range(n)]\nfor i in range(n):\n    for j in range(n):\n        a, b = ab[i]\n        c, d = cd[j]\n\n        if a < c and b < d:\n            match_list[i].append(j)\n# print(match_list)\n\n\ngroup1 = list(range(n))\ngroup2 = list(range(n, 2*n))\n\ng = nx.Graph()\ng.add_nodes_from(group1, bipartite=1)\ng.add_nodes_from(group2, bipartite=0)\n\nfor i, list_ in enumerate(match_list):\n    for j in list_:\n        g.add_edge(i, j+n, weight=1)\n\n# A, B = bipartite.sets(g)\n# print(A, B)\n# pos = dict()\n# pos.update((n, (1, i)) for i, n in enumerate(A))\n# pos.update((n, (2, i)) for i, n in enumerate(B))\n# nx.draw_networkx(g, pos)\n# nx.draw_networkx_edges(g, pos)\n# plt.axis(\"off\")\n# plt.show()\n\n\nd = nx.max_weight_matching(g)\n\nprint((len(d)))\n", "n=int(input())\nab=[list(map(int,input().split())) for _ in range(n)]\ncd=[list(map(int,input().split())) for _ in range(n)]\nab.sort(key=lambda x:x[0])\ncd.sort(key=lambda x:x[0])\nans=0\ni=0\nred_x=[]\nimport bisect\nfor c,d in cd:\n  while i<n and ab[i][0]<c:\n    bisect.insort_right(red_x,ab[i][1])\n    i+=1\n  if red_x and red_x[0]<d:\n    idx=bisect.bisect_right(red_x,d)-1\n    ans+=1\n    red_x.pop(idx)\nprint(ans)", "from collections import defaultdict\nfrom itertools import product\n\nN = int(input())\n\nred_points = [tuple(map(int, input().split(' '))) for _ in range(N)]\nblue_points = [tuple(map(int, input().split(' '))) for _ in range(N)]\n\nedges = defaultdict(set)\n\nfor i, j in product(list(range(N)), repeat=2):\n    a, b = red_points[i]\n    c, d = blue_points[j]\n\n    if a < c and b < d:\n        edges[i].add(j + N)\n        edges[j + N].add(i)\n\npairs = [-1] * (2 * N)\nans = 0\n\n\ndef dfs(v, seen):\n    seen[v] = True\n    for u in edges[v]:\n        w = pairs[u]\n        if w < 0 or (not seen[w] and dfs(w, seen)):\n            pairs[v] = u\n            pairs[u] = v\n            return True\n    return False\n\n\nfor v in range(2 * N):\n    if pairs[v] < 0:\n        seen = [False] * (2 * N)\n        if dfs(v, seen):\n            ans += 1\n\nprint(ans)\n", "N = int(input())\nRed = [[int(T) for T in input().split()] for TN in range(0,N)]\nRed.sort(key=lambda X:X[1],reverse=True)\nBlue = [[int(T) for T in input().split()] for TN in range(0,N)]\nBlue.sort(key=lambda X:X[0])\nCount = 0\n\nfor TB in range(0,N):\n    DelInd = -1\n    for TR in range(0,len(Red)):\n        if Blue[TB][0]>Red[TR][0] and Blue[TB][1]>Red[TR][1]:\n            DelInd = TR\n            break\n    if DelInd!=-1:\n        del Red[DelInd]\n        Count += 1\nprint(Count)", "N = int(input())#100\nAB = [0] * N\nfor i in range(N):\n  AB[i] = list(map(int, input().split()))\nAB = sorted(AB)\nCD = [0] * N\nfor i in range(N):\n  CD[i] = list(map(int, input().split()))\nCD = sorted(CD)\n#print(AB, CD)\n\nans = 0\n\nused = [0] * N\nfor i in range(N):\n  now_x, now_y = CD[i][0], CD[i][1]\n  max_y = -1\n  nn = -1\n  for j in range(N):\n    if (now_x > AB[j][0]) and (used[j] == 0):\n      if now_y > AB[j][1]:\n        if max_y < AB[j][1]:\n          max_y = AB[j][1]\n          nn = j\n  if max_y != -1:\n    ans += 1\n    used[nn] = 1\n    \nprint(ans)    \n    \n    \n  \n  \n  \n  \n  \n", "def main():\n    from sys import stdin\n    def input():\n        return stdin.readline().strip()\n    \n    n = int(input())\n    red = [tuple(map(int, input().split())) for _ in range(n)]\n    blue = [tuple(map(int, input().split())) for _ in range(n)]\n\n    red.sort()\n    blue.sort()\n\n    now = 0\n    for i in blue:\n        while now < len(red) and red[now] < i:\n            now += 1\n        \n        l = red[:now]\n        if l == []:\n            continue\n\n        l = sorted(l, key=lambda x: x[1])\n        if l[0][1] > i[1]:\n            continue\n        \n        # binary search\n        left = 0\n        right = len(l) - 1\n        while left < right:\n            center = (left + right + 1) // 2\n            if l[center][1] < i[1]:\n                left = center\n            else:\n                right = center - 1\n\n        red.remove(l[left])\n        now -= 1\n\n    print(n - len(red))\n\nmain()", "n = int(input())\nab = []\nfor i in range(n):\n    ab.append(list(map(int, input().split())))\ncd = []\nfor i in range(n):\n    cd.append(list(map(int, input().split())))\ncd.sort()\nab.sort(key = lambda x: x[1], reverse = True)\nflag_ab = [False for i in range(n)]\ncount = 0\nfor i in range(n):\n    c, d = cd[i][0], cd[i][1]\n    for j in range(n):\n        if flag_ab[j] == True:\n            continue\n        a, b = ab[j][0], ab[j][1]\n        if c > a and d > b:\n            flag_ab[j] = True\n            count += 1\n            break\nprint(count)", "import networkx as nx\nN = int(input())\nAB = [[int(_) for _ in input().split()] for _ in range(N)]\nCD = [[int(_) for _ in input().split()] for _ in range(N)]\nG = nx.DiGraph()\nfor a, b in AB:\n    G.add_edge(-1, a * 1000 + b, capacity=1)\nfor c, d in CD:\n    G.add_edge(c * 1000 + d, -2, capacity=1)\nfor a, b in AB:\n    for c, d in CD:\n        if a < c and b < d:\n            G.add_edge(a * 1000 + b, c * 1000 + d, capacity=1)\nflow_value, flow_dict = nx.maximum_flow(G, -1, -2)\nprint(flow_value)\n", "N = int(input())\nab = [tuple(map(int, input().split())) for _ in range(N)]\ncd = [tuple(map(int, input().split())) for _ in range(N)]\n\nab.sort(key=lambda xy: xy[1], reverse=True)\ncd.sort()\n\nans = 0\nfor c, d in cd:\n    for index, (a, b) in enumerate(ab):\n        if a < c and b < d:\n            ab[index] = (201, 201)\n            ans += 1\n            break\n\nprint(ans)\n", "from heapq import heapify, heappush, heappop\nN = int(input())\nA = []\nfor i in range(N):\n    A.append(tuple(map(int, input().split())))\nA.sort()\n\nB = []\nfor i in range(N):\n    B.append(tuple(map(int, input().split())))\nB.sort()\n\nheap = []\nheapify(heap)\naindex = count = 0\nfor b in B:\n    while aindex < len(A) and A[aindex][0] < b[0]:\n        heappush(heap, -A[aindex][1])\n        aindex += 1\n    buf = []\n    while heap and b[1] <= -heap[0]:\n        ay = heappop(heap)\n        buf.append(ay)\n    if heap and -heap[0] < b[1]:\n        count += 1\n        heappop(heap)\n    for ay_ in buf:\n        heappush(heap, ay_)\nprint(count)", "import collections, itertools, copy\n\n\nclass MaximumFlow:\n    def ford_fulkerson(self, G, s, t):\n        G_residue = copy.deepcopy(G)\n\n        def dfs(start, used):\n            if start == t:\n                return [start]\n            for end, cap in list(G_residue[start].items()):\n                if cap > 0 and end not in used:\n                    used.add(end)\n                    ret = dfs(end, used)\n                    if ret:\n                        return ret + [start]\n            return []\n\n        flow_value = 0\n        while True:\n            root = dfs(s, set([s]))\n            if root:\n                root = root[::-1]\n                residue = min(\n                    [G_residue[a][b] for a, b in zip(root, root[1:])])\n                flow_value += residue\n                for a, b in zip(root, root[1:]):\n                    G_residue[a][b] -= residue\n                    G_residue[b][a] += residue\n            else:\n                return (flow_value, G_residue)\n\n\nN = int(input())\nAB = [[int(_) for _ in input().split()] for _ in range(N)]\nCD = [[int(_) for _ in input().split()] for _ in range(N)]\nG = collections.defaultdict(lambda: collections.defaultdict(int))\nfor a, b in AB:\n    G[-1][1000 * a + b] = 1\nfor c, d in CD:\n    G[1000 * c + d][-2] = 1\nfor ab, cd in itertools.product(AB, CD):\n    a, b = ab\n    c, d = cd\n    if a < c and b < d:\n        G[1000 * a + b][1000 * c + d] = 1\nflow_value, flow_dict = MaximumFlow().ford_fulkerson(G, -1, -2)\nprint(flow_value)\n", "n, *ABCD = map(int, open(0).read().split())\nAB = sorted([(a, b) for a, b in zip(ABCD[:2*n:2], ABCD[1:2*n:2])], key=lambda x:-x[1])\nCD = sorted([(c, d) for c, d in zip(ABCD[2*n::2], ABCD[2*n+1::2])])\n\nfor c, d in CD:\n    for i in range(len(AB)):\n        a, b = AB[i]\n        if a < c and b < d:\n            _ = AB.pop(i)\n            break\nprint(n-len(AB))", "N=int(input())\nAB=sorted([list(map(int, input().split())) for _ in range(N)])\nCD=sorted([list(map(int, input().split())) for _ in range(N)])\n\npaira=-1\npairb=-1\nans=0\n\nfor i in range(N):\n\ttempcd=CD[i]\n\tfor h in range(len(AB)):\n\t\ttempab=AB[h]\n\t\tif tempab[0]<tempcd[0] and tempab[1]<tempcd[1]:\n\t\t\tif pairb<tempab[1]:\n\t\t\t\tpaira=tempab[0]\n\t\t\t\tpairb=tempab[1]\n\t\t\t\tpairnum=h\n\tif paira!=-1 and pairb!=-1:\n\t\tans+=1\n\t\tAB.pop(pairnum)\n\t\tpaira=-1\n\t\tpairb=-1\n\nprint(ans)\n\t\t\t\n", "def resolve():\n    '''\n    code here\n    '''\n    import collections\n    N = int(input())\n    reds = [[int(item) for item in input().split()] for _ in range(N)]\n    blues = [[int(item) for item in input().split()] for _ in range(N)]\n\n    reds = sorted(reds, key=lambda x:x[1], reverse=True)\n    blues.sort()\n\n    que = collections.deque(blues)\n    cnt = 0\n\n    while que:\n\n        bx, by = que.popleft()\n\n        for rx, ry in reds[:]:\n            if rx <= bx and ry <= by:\n                cnt += 1\n                reds.remove([rx, ry])\n                break\n    print(cnt)\n\n\ndef __starting_point():\n    resolve()\n\n\n\n__starting_point()", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import maximum_bipartite_matching\ndef resolve():\n    n = int(input())\n    A = [tuple(map(int, input().split())) for _ in range(n)]\n    B = [tuple(map(int, input().split())) for _ in range(n)]\n\n    graph = csr_matrix([[int(A[i][0] < B[j][0] and A[i][1] < B[j][1]) for j in range(n)] for i in range(n)])\n    ans = 0\n    for a in maximum_bipartite_matching(graph):\n        if a != -1:\n            ans += 1\n    print(ans)\nresolve()", "n = int(input())\ncr = [tuple(map(int, input().split())) for _ in range(n)]\ncb = [tuple(map(int, input().split())) for _ in range(n)]\n\ncb.sort(key=lambda xy: xy[0])\ncr.sort(key=lambda xy: xy[1], reverse=True)\n\nnpair = 0\nfor (bx, by) in cb:\n    for (rx, ry) in cr:\n        if rx < bx and ry < by:\n            npair += 1\n            cr.remove((rx, ry))\n            break\n\nprint(npair)\n\n\n\n", "N= int(input())\nred=[list(map(int,input().split())) for i in range(N)]\nred.sort()\nblue=[list(map(int,input().split())) for i in range(N)]\nblue.sort()\nans=0\nfrom operator import itemgetter\nfor i in range(N):\n   x,y=blue[i]\n   l=[]\n   for j in range(N):\n      try:\n         if x>red[j][0] and y>red[j][1]:\n            l.append(red[j])\n      except IndexError:\n         break\n   try:\n      l.sort(key=itemgetter(1),reverse=True)\n      red.remove(l[0])\n   except IndexError:\n      pass\nprint(N-len(red))", "n=int(input())\nred=[list(map(int,input().split())) for _ in range(n)]\nblue=[list(map(int,input().split())) for _ in range(n)]\nred.sort()\nblue.sort()\n \np=0\nfor bb in blue:\n  lis=[-1,-1]\n  for rr in red:\n    if rr[0]<bb[0] and rr[1]<bb[1] and lis[1]<rr[1]:\n      lis=rr\n  if lis!=[-1,-1]:\n    red.remove(lis)\n    p+=1\nprint(p)", "import sys\ninput = sys.stdin.readline\n\nclass FordFulkerson:\n    def __init__(self, n):\n        self.N = n\n        self.G = [[] for _ in range(n)]\n        \n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n        \n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n    \n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        used = self.used\n        used[v] = 1\n        for e in self.G[v]:\n            w, cap, rev = e\n            if cap and not used[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n    \n\n    def flow(self, s, t):\n        flow = 0\n        f = INF = 10**9 + 7\n        N = self.N\n        while f:\n            self.used = [0]*N\n            f = self.dfs(s, t, INF)\n            flow += f\n        return flow\n    \ndef main():\n    n = int(input())\n    red = [list(map(int, input().split())) for _ in range(n)]\n    blue = [list(map(int, input().split())) for _ in range(n)]\n    \n    flow = FordFulkerson(n*2+2)\n    for i in range(n):\n        flow.add_edge(0, i+1, 1)\n        flow.add_edge(n+i+1, 2*n+1, 1)\n        for j in range(n):\n            if red[i][0] < blue[j][0] and red[i][1] < blue[j][1]:\n                flow.add_edge(i+1, n+j+1, 1)\n    \n    \n    ans = flow.flow(0, 2*n+1)\n    print(ans)\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nred  = [tuple(map(int, input().split())) for _ in range(n)]\nblue = [tuple(map(int, input().split())) for _ in range(n)]\nred.sort(key=lambda x:-x[1])\nblue.sort()\ncount = 0\nfor xb, yb in blue:\n    for i in range(n):\n        if xb > red[i][0] and yb > red[i][1]:\n            red[i] = (201, 201)\n            count += 1\n            break\nprint(count)\n", "N = int(input())\nRed = sorted([tuple(map(int, input().split())) for _ in range(N)])\nBlue = sorted([tuple(map(int, input().split())) for _ in range(N)])\n\nans = 0\nfor bx,by in Blue:\n    C = [(y,x) for x,y in Red if x<bx and y<by] #\u5019\u88dc\n    if len(C) == 0:\n        continue\n    ans += 1\n    C.sort(reverse=True)\n    Red.remove((C[0][1],C[0][0]))\nprint(ans)", "import collections, itertools\n\n\nclass MaximumFlow:\n    def __init__(self, G):\n        self.G = G\n\n    def ford_fulkerson(self, s, t):\n        def dfs(start, used):\n            G = self.G\n            if start == t:\n                return [start]\n            for end, cap in list(G[start].items()):\n                if cap > 0 and end not in used:\n                    used.add(end)\n                    ret = dfs(end, used)\n                    if ret:\n                        return ret + [start]\n            return []\n\n        fmax = 0\n        cnt = 0\n        while True:\n            G = self.G\n            cnt += 1\n            root = dfs(s, set([s]))\n            if root:\n                root = root[::-1]\n                residue = min([G[a][b] for a, b in zip(root, root[1:])])\n                fmax += residue\n                for a, b in zip(root, root[1:]):\n                    G[a][b] -= residue\n                    G[b][a] += residue\n            else:\n                return (fmax, G)\n\n\nN = int(input())\nAB = [[int(_) for _ in input().split()] for _ in range(N)]\nCD = [[int(_) for _ in input().split()] for _ in range(N)]\nG = collections.defaultdict(lambda: collections.defaultdict(int))\nfor a, b in AB:\n    G[-1][1000 * a + b] = 1\nfor c, d in CD:\n    G[1000 * c + d][-2] = 1\nfor ab, cd in itertools.product(AB, CD):\n    a, b = ab\n    c, d = cd\n    if a < c and b < d:\n        G[1000 * a + b][1000 * c + d] = 1\nflow = MaximumFlow(G)\nfmax, Gres = flow.ford_fulkerson(-1, -2)\nprint(fmax)\n", "#\n# abc091 c\n#\nimport sys\nfrom io import StringIO\nimport unittest\nimport bisect\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"3\n2 0\n3 1\n1 3\n4 2\n0 4\n5 5\"\"\"\n        output = \"\"\"2\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"3\n0 0\n1 1\n5 2\n2 3\n3 4\n4 5\"\"\"\n        output = \"\"\"2\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"2\n2 2\n3 3\n0 0\n1 1\"\"\"\n        output = \"\"\"0\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_4(self):\n        input = \"\"\"5\n0 0\n7 3\n2 2\n4 8\n1 6\n8 5\n6 9\n5 4\n9 1\n3 7\"\"\"\n        output = \"\"\"5\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_5(self):\n        input = \"\"\"5\n0 0\n1 1\n5 5\n6 6\n7 7\n2 2\n3 3\n4 4\n8 8\n9 9\"\"\"\n        output = \"\"\"4\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    N = int(input())\n    AB = [list(map(int, input().split())) for _ in range(N)]\n    CD = [list(map(int, input().split())) for _ in range(N)]\n\n    AB.sort(reverse=True)\n    CD.sort()\n\n    ans = 0\n    for ab in AB:\n        a, b = ab\n        ok = len(CD)\n        ng = -1\n        while abs(ok-ng) > 1:\n            mid = (ok+ng)//2\n\n            if CD[mid][0] >= a:\n                ok = mid\n            else:\n                ng = mid\n\n        if ok == len(CD):\n            continue\n\n        NCD = CD[ok:]\n        NCD.sort(key=lambda x: x[1])\n        ok = len(NCD)\n        ng = -1\n        while abs(ok-ng) > 1:\n            mid = (ok+ng)//2\n\n            if NCD[mid][1] >= b:\n                ok = mid\n            else:\n                ng = mid\n\n        if ok == len(NCD):\n            continue\n        else:\n            ans += 1\n            CD.remove(NCD[ok])\n\n    print(ans)\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "n = int(input())\nred  = [tuple(map(int, input().split())) for _ in range(n)]\nblue = [tuple(map(int, input().split())) for _ in range(n)]\n\nred.sort(key=lambda x:x[1])\nblue.sort()\n\ncount = 0\nfor xb, yb in blue:\n    max_y = -1\n    max_i = -1\n    for i in range(n):\n        xr, yr = red[i]\n        if xb > xr and yb > yr and max_y < yr:\n            max_y, max_i = yr, i\n    if max_y >= 0:\n        red[max_i] = (201, 201)\n        count += 1\nprint(count)\n\n\n", "n=int(input())\nR=sorted([list(map(int,input().split())) for i in range(n)], key=lambda R: -R[1])\nB=sorted([list(map(int,input().split())) for i in range(n)])\nans=0\nfor c,d in B:\n  for a,b in R:\n    if a<c and b<d:\n      R.remove([a,b]);ans+=1\n      break\nprint(ans)", "import collections, itertools, copy\n\n\nclass MaximumFlow:\n    def ford_fulkerson(self, G, s, t):\n        G_residue = copy.deepcopy(G)\n\n        def dfs(start, used):\n            if start == t:\n                return [start]\n            for end, cap in list(G_residue[start].items()):\n                if cap > 0 and end not in used:\n                    used.add(end)\n                    ret = dfs(end, used)\n                    if ret:\n                        return ret + [start]\n            return []\n\n        flow_value = 0\n        while True:\n            root = dfs(s, set([s]))\n            if root:\n                root = root[::-1]\n                residue = min(\n                    [G_residue[a][b] for a, b in zip(root, root[1:])])\n                flow_value += residue\n                for a, b in zip(root, root[1:]):\n                    G_residue[a][b] -= residue\n                    G_residue[b][a] += residue\n            else:\n                return (flow_value, G_residue)\n\n\nN = int(input())\nAB = [[int(_) for _ in input().split()] for _ in range(N)]\nCD = [[int(_) for _ in input().split()] for _ in range(N)]\nG = collections.defaultdict(lambda: collections.defaultdict(int))\nfor a, b in AB:\n    G[-1][1000 * a + b] = 1\nfor c, d in CD:\n    G[1000 * c + d][-2] = 1\nfor ab, cd in itertools.product(AB, CD):\n    a, b = ab\n    c, d = cd\n    if a < c and b < d:\n        G[1000 * a + b][1000 * c + d] = 1\nflow_value, G_residue = MaximumFlow().ford_fulkerson(G, -1, -2)\nprint(flow_value)\nflow_dict = collections.defaultdict(lambda: collections.defaultdict(int))\nfor a in G:\n    for b in G[a]:\n        if G_residue[b][a] > 0:\n            flow_dict[a][b] = G_residue[b][a]\n", "n=int(input())\nrs=[list(map(int,input().split())) for _ in range(n)]\nbs=[list(map(int,input().split())) for _ in range(n)]\nrs.sort(key=lambda x:x[1],reverse=True)\nbs.sort()\nans=0\nfor c,d in bs:\n    for a,b in rs:\n        if a<c and b<d:\n            ans+=1\n            rs.remove([a,b])\n            break\nprint(ans)\n", "N = int(input())\nR = [[0, 0] for _ in range(N)]\nB = [[0, 0] for _ in range(N)]\nMap = [['.' for __ in range(2*N)] for _ in range(2*N)]\nfor i in range(N):\n  R[i][1], R[i][0] = map(int, input().split())\n  Map[R[i][1]][R[i][0]] = 'R'\nfor i in range(N):\n  B[i][0], B[i][1] = map(int, input().split())\n  Map[B[i][0]][B[i][1]] = 'B'\nR.sort(reverse=True)\nB.sort()\nRF = [True for _ in range(N)]\nBF = [True for _ in range(N)]\ncnt = 0\nfor i in range(N):\n  for j in range(N):\n    if BF[j] == True:\n      if R[i][1] < B[j][0] and R[i][0] < B[j][1]:\n        cnt += 1\n        RF[i] = False\n        BF[j] = False\n        break\nprint(cnt)", "n = int(input())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n)]\nx = []\nfor i,j in a:\n    x.append((i,j,1))\nfor i,j in b:\n    x.append((i,j,2))\nx.sort()\n#print(x)\nfor i in range(2*n):\n    x[i] = (x[i][1],x[i][2])\n#print(x)\nans = 0\nwhile len(x):\n    maxindex = 0\n    maxvalue = -1\n    flag = 0\n    for i in range(len(x)):\n        if x[i][0]>maxvalue and x[i][1]==1:\n            flag = 1\n            maxvalue = x[i][0]\n            maxindex = i\n    if flag == 0:\n        break\n    #if (x[maxindex][1]==1):\n        #x.pop(i)\n    #else:\n    #maxindex2 = 0\n    #maxvalue2 = -1\n    flag = 0\n    for i in range(maxindex+1,len(x)):\n        if (x[i][1]==2):\n            if (x[i][0]>maxvalue):\n                ans += 1\n                x.pop(i)\n                x.pop(maxindex)\n                flag=1\n                break\n    if (flag==0):\n        x.pop(maxindex)\nprint(ans)", "n = int(input())\nab = [tuple(map(int, input().split())) for _ in range(n)]\ncd = [tuple(map(int, input().split())) for _ in range(n)]\nab.sort(key=lambda x: (-x[1], x[0]))\ncd.sort(key=lambda x: (x[0], x[1]))\ns = [0] * n\n\nfor i in range(n):\n    for j in range(n):\n        if s[j] == 0 and ab[j][0] < cd[i][0] and ab[j][1] < cd[i][1]:\n            s[j] = 1\n            break\nprint((sum(s)))\n", "def c_2d_plane_2n_points_bipartite_graph():\n    import networkx as nx\n    from networkx.algorithms.flow import dinitz\n    N = int(input())\n    Red_point_pos = [[int(i) for i in input().split()] for j in range(N)]\n    Blue_point_pos = [[int(i) for i in input().split()] for j in range(N)]\n\n    # 1 \u304b\u3089 N \u756a\u3092\u8d64\u3044\u70b9\u306b\u5272\u308a\u5f53\u3066\uff0cN+1 \u756a\u304b\u3089 2N \u756a\u3092\u9752\u3044\u70b9\u306b\u5272\u308a\u5f53\u3066\u308b\n    # \u30bd\u30fc\u30b9\u3092 0 \u756a\u3068\u3057\uff0c\u30b7\u30f3\u30af\u3092 2N+1 \u756a\u3068\u3059\u308b\n    graph = nx.DiGraph()\n    graph.add_nodes_from(range(2 * N + 2))\n    for i in range(N):\n        for j in range(N):\n            a, b = Red_point_pos[i]\n            c, d = Blue_point_pos[j]\n            if a < c and b < d:  # i \u756a\u306e\u8d64\u3044\u70b9\u3068 j \u756a\u306e\u9752\u3044\u70b9\u306f\u30da\u30a2\u306b\u3067\u304d\u3046\u308b\n                graph.add_edge(i + 1, j + N + 1, capacity=1)\n    for i in range(1, N + 1):\n        graph.add_edge(0, i, capacity=1)\n    for j in range(N + 1, 2 * N + 1):\n        graph.add_edge(j, 2 * N + 1, capacity=1)\n    return dinitz(graph, 0, 2 * N + 1).graph['flow_value']\n\nprint(c_2d_plane_2n_points_bipartite_graph())", "import sys\nmod=10**9+7 ; inf=float(\"inf\")\nfrom math import sqrt, ceil\nfrom collections import deque, Counter, defaultdict #\u3059\u3079\u3066\u306ekey\u304c\u7528\u610f\u3055\u308c\u3066\u308b defaultdict(int)\u3067\u521d\u671f\u5316\ninput=lambda: sys.stdin.readline().strip()\nsys.setrecursionlimit(11451419)\nfrom decimal import ROUND_HALF_UP,Decimal  #\u5909\u63db\u5f8c\u306e\u672b\u5c3e\u6841\u30920\u30840.01\u3067\u6307\u5b9a\n  #Decimal((str(0.5)).quantize(Decimal('0'), rounding=ROUND_HALF_UP))\nfrom functools import lru_cache\nfrom bisect import bisect_left as bileft, bisect_right as biright\n#\u30e1\u30e2\u5316\u518d\u5e30def\u306e\u5192\u982d\u306b\u6bce\u56de @lru_cache(maxsize=10**10)\n#\u5f15\u6570\u306blist\u306f\u3060\u3081\n#######\u3053\u3053\u307e\u3067\u30c6\u30f3\u30d7\u30ec#######\n#\u30bd\u30fc\u30c8\u3001\"a\"+\"b\"\u3001\u518d\u5e30\u306a\u3089Python3\u306e\u65b9\u304c\u3044\u3044\n#######\u3053\u3053\u304b\u3089\u5929\u3077\u3089########\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N= N\n        self.G = [[] for i in range(N)]\n    def add_edge(self,fr,to,cap=1): #\u3064\u306a\u3050\u30ce\u30fc\u30c92\u3064\u3001\u5bb9\u91cf\n        forward=[to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = inf\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\nn=int(input())\ndinic=Dinic(2*n+2)\n\n\nA=[] ; B=[]\nfor i in range(n):\n    a,b=map(int,input().split())\n    A.append([a,b])\nfor i in range(n):\n    a,b=map(int,input().split())\n    B.append([a,b])\nfor i in range(n):\n    dinic.add_edge(2*n,i,1)\n    dinic.add_edge(i+n, 2*n+1,1)\nfor i in range(n):\n    for j in range(n):\n        if A[i][0]<B[j][0] and A[i][1]<B[j][1]:\n            dinic.add_edge(i,j+n)\n\nprint(dinic.flow(2*n,2*n+1))", "from operator import itemgetter\nN=int(input())\nR=[list(map(int,input().split())) for n in range(N)]\nB=[list(map(int,input().split())) for n in range(N)]\nR.sort(key=itemgetter(1),reverse=True)\nB.sort()\nans=0\n\nfor c,d in B :\n    for a,b in R :\n        if a<c and b<d :\n            ans+=1\n            R.remove([a,b])\n            break\n\nprint(ans)", "def abc091_c():\n    n = int(input())\n    red = []\n    blue = []\n    for _ in range(n):\n        a, b = (int(x) for x in input().split())\n        red.append((a, b))\n    for _ in range(n):\n        c, d = (int(x) for x in input().split())\n        blue.append((c, d))\n    blue = sorted(blue, key=lambda x: x[0])\n\n    ans = 0\n    r_used = [False]*n\n    for c, d in blue:\n        match = -1\n        y_high = -1\n        for i, (a, b) in enumerate(red):\n            if r_used[i]: continue\n            if not (a < c and b < d): continue\n            if y_high < b:\n                match = i\n                y_high = b\n        if match != -1:\n            ans += 1\n            r_used[match] = True\n    print(ans)\n\ndef __starting_point():\n    abc091_c()\n__starting_point()", "N = int(input())\nred = [list(map(int, input().split())) for _ in range(N)]\nblue = [list(map(int, input().split())) for _ in range(N)]\nblue = sorted(blue, key=lambda x: x[0])\n\nused = []\nfor i in range(N):\n    c, d = blue[i]\n    m, tmp = -1, -1\n    for j in range(N):\n        if j in used:\n            continue\n        a, b = red[j]\n        if a < c and b < d:\n            if b > m:\n                m = b\n                tmp = j\n    if tmp != -1:\n        used.append(tmp)\nprint((len(used)))\n", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\nimport networkx as nx\ndef resolve():\n    n = int(input())\n    A = [tuple(map(int, input().split())) for _ in range(n)]\n    B = [tuple(map(int, input().split())) for _ in range(n)]\n    G = nx.Graph()\n    G.add_nodes_from(range(n))\n    G.add_nodes_from(range(n, 2 * n))\n    for i in range(n):\n        ax, ay = A[i]\n        for j in range(n):\n            bx, by = B[j]\n            if ax < bx and ay < by:\n                G.add_edge(i, n + j)\n\n    A = nx.algorithms.bipartite.matching.hopcroft_karp_matching(G, top_nodes = range(n))\n    print(len(A) // 2)\nresolve()", "import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nfrom bisect import bisect_right\nN = int(input())\nab = [list(mapint()) for _ in range(N)]\ncd = [list(mapint()) for _ in range(N)]\nab.sort(reverse=True)\ncd.sort(key=lambda x: x[1])\nchecked = [0]*N\n\nans = 0\nfor n in range(N):\n    a, b = ab[n]\n    for i in range(N):\n        if checked[i]:\n            continue\n        c, d = cd[i]\n        if a<c and b<d:\n            ans += 1\n            checked[i] = 1\n            break\n\nprint(ans)", "n = int(input())\nab=[]\nfor i in range(n):\n    ab.append(list(map(int, input().split())))\nab = sorted(ab, key=lambda x:x[1], reverse=True)\n\ncd=[]\nfor i in range(n):\n    cd.append(list(map(int, input().split())))\ncd = sorted(cd, key=lambda x:x[0])\n# print(ab, flush=True)\n# print(cd, flush=True)\n\n\nans = 0\nfor i in cd:\n    for ji, j in enumerate(ab):\n        if i[0]>j[0] and i[1]>j[1]:\n            # print(i, j, flush=True)\n            ans+=1\n            ab.pop(ji)\n            break;\nprint(ans, flush=True)\n\n", "import operator\nimport bisect\n\nn=int(input())\nred=[tuple(map(int,input().split())) for _ in range(n)]\nblue=[tuple(map(int,input().split())) for _ in range(n)]\n\nred.sort(key=operator.itemgetter(0,1))\nblue.sort(key=operator.itemgetter(0,1))\n#print(red)\n#print(blue)\ncount=0\nfor i in range(n):\n  for j in reversed(list(range(len(red)))):\n    #print(\"j\",j)\n    if not red:\n      break\n    if red[j][0]<blue[i][0]:\n      tmp=red[:j+1]\n      tmp.sort(key=lambda x:x[1],reverse=True)\n      for t in tmp:\n        if t[1]<blue[i][1]:\n          count+=1\n          red.pop(red.index(t))\n          #print(\"t\",t,\"blue[i]\",blue[i])\n          break\n    else:\n      continue\n    break\n\nprint(count)\n", "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return map(int, sys.stdin.readline().split())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from collections import Counter # a = Counter(A).most_common()\n#from itertools import accumulate #list(accumulate(A))\n\nN = ii()\nA = li2(N)\nB = li2(N)\n\nA = sorted(A, key=lambda x:x[1])\nB = sorted(B, key=lambda x:x[0])\n\nflag = [0] * N\n\nfor i in range(N):\n    ind = -1\n    for j in range(N):\n        if A[j][1] < B[i][1]:\n            ind = j\n    while ind >= 0:\n        if not flag[ind] and A[ind][0] < B[i][0]:\n            flag[ind] = 1\n            break\n        ind -= 1\n\n#print(flag)\nprint(sum(flag))", "import bisect\nN = int(input())\nR = [tuple(map(int,input().split())) for i in range(N)]\nB = [tuple(map(int,input().split())) for i in range(N)]\n\n#\u30bd\u30fc\u30c8\u3057\u3066R<B\u3068\u306a\u308b\u70b9\u3092Greedy\u3067\u63a2\u7d22\nR.sort()\nB.sort()\ni=0\nans=0\nred_y = []\nfor b_x,b_y in B:\n    #b_x\u3088\u308ax\u304c\u5c0f\u3055\u3044R\u3092\u3059\u3079\u3066red_y\u306b\u8ffd\u52a0\n    while i<N and R[i][0]<b_x:\n        bisect.insort_right(red_y,R[i][1])\n        i+=1\n    #r_x<b_x,r_y<b_y\u3092\u6e80\u305f\u3059\u70b9\u304c\u3042\u308c\u3070\u30ab\u30a6\u30f3\u30c8\n    if red_y and red_y[0]<b_y:\n        idx = bisect.bisect_right(red_y,b_y)-1\n        ans+=1\n        red_y.pop(idx)\nprint(ans)", "n = int(input())\nAB = list(list(map(int,input().split())) for _ in range(n))\nCD = list(list(map(int,input().split())) for _ in range(n))\n\nCD.sort() # sort x in ascending order\nAB.sort(key=lambda z: z[1], reverse=True) # sort x in descending order\n\ndim_b = [[] for _ in range(n)]\nfor b in range(n):\n    bx, by = CD[b]\n    for r in range(n):\n        rx, ry = AB[r]\n        if rx < bx and ry < by: dim_b[b] += [r]\n\nvis_r = [False]*(n)\nfor b in range(n): # ascending order of x\n    max_ry = max_r = -1\n    for r in dim_b[b]: # descending order of y\n        if vis_r[r]: continue\n        rx, ry = AB[r]\n        if max_ry < ry:\n            max_ry = ry\n            max_r = r\n    if max_r >= 0: vis_r[max_r] = True\nprint((sum(vis_r)))\n", "from collections import deque\nN=int(input())\nstart = 0\nend = 2*N+1\n\nR = {}\nB = {}\nad_matrix = [[0]*(2*N+2) for i in range(2*N+2)]\nad_dict = {}\nad_dict[start]=[]\nad_dict[end]=[]\nfor n in range(N):\n    R[n+1] = (list(map(int,input().split())))\n    ad_dict[n+1]=[]\n    \nfor n in range(N):\n    B[N+n+1] = (list(map(int,input().split())))\n    ad_dict[N+n+1]=[]\n\n# \u96a3\u63a5\u884c\u5217\u3092\u4f5c\u6210(ad_matrix[start][end] = 1\uff1a\u63a5\u7d9a)\nfor r_ in R.keys():\n    ad_dict[start].append(r_)\n    ad_dict[r_].append(start)\nfor b_ in B.keys():\n    ad_dict[end].append(b_)\n    ad_dict[b_].append(end)\n\nfor r_ in R.keys():\n    ad_matrix[start][r_] = 1\n    \n    r = R[r_]\n    for b_ in B.keys():\n        ad_matrix[b_][end] = 1\n\n        b = B[b_]\n        \n        if r[0] < b[0] and r[1] < b[1]:\n            ad_matrix[r_][b_] = 1\n            ad_dict[r_].append(b_)\n\nans = 0\nwhile True:\n    start = 0\n    end = 2*N+1\n\n    color = {}\n    for n in range(end+1):\n        color[n] = -1\n\n    visit = deque([start])\n    color[start] = 0\n\n    while visit:\n        start = visit[-1]\n        for v in ad_dict[start]:\n            if color[v] == -1:\n                visit.append(v)\n                color[v] = 0\n                break\n        else:\n            visit.pop()\n            color[start] = 1\n\n#         print(visit,color)\n\n        if color[end] == 0:\n            #\u30b3\u30b9\u30c8\u306e\u66f4\u65b0\n            visit = list(visit)\n            flow = 10**10\n            for d1,d2 in zip(visit[:-1],visit[1:]):\n                flow = min(flow,ad_matrix[d1][d2])\n\n            for d1,d2 in zip(visit[:-1],visit[1:]):\n                ad_matrix[d1][d2] -= flow\n                ad_matrix[d2][d1] += flow\n                if ad_matrix[d1][d2] <= 0:\n                    ad_dict[d1].remove(d2)\n                    ad_dict[d2].append(d1)\n            break\n#     print(visit)\n    if not visit:\n        break\n    ans += 1\nprint(ans)", "n = int(input())\nAB = list(list(map(int,input().split())) for _ in range(n))\nCD = list(list(map(int,input().split())) for _ in range(n))\n\n# print(*CD,sep='\\n',end='\\n---\\n')\n# print(*sorted(CD, key=lambda x: x[0]),sep='\\n',end='\\n---\\n')\n# CD.sort(key=lambda x: x[1])\n# CD.sort(key=lambda x: x[0])\nCD.sort()\n# print(*CD,sep='\\n',end='\\n---\\n')\n# print(*AB,sep='\\n',end='\\n---\\n')\nAB.sort(key=lambda x: x[1], reverse=True)\n# print(*AB,sep='\\n',end='\\n---\\n')\n\ndim_r = [[] for _ in range(n)]\ndim_b = [[] for _ in range(n)]\n# cnt_r = [0]*n\n# cnt_b = [0]*n\nfor b in range(n):\n    bx, by = CD[b]\n    for r in range(n):\n        rx, ry = AB[r]\n        if rx < bx and ry < by:\n            dim_r[r] += [b]\n            dim_b[b] += [r]\n            # cnt_b[b] += 1\n            # cnt_r[r] += 1\n\n# print(n)\n# print(*AB,sep='\\n',end='\\n---\\n')\n# print(*CD,sep='\\n',end='\\n---\\n')\n# print(*dim_r,sep='\\n',end='\\n---\\n')\n# print(*dim_b,sep='\\n',end='\\n---\\n')\n# # print(cnt_b,end='\\n---\\n')\n\nans = 0\n\ninf = 1000000000\nvis_r = [False]*(n)\nfor b in range(n):\n    bx, by = CD[b]\n    # print('b,bx,by',b,bx,by)\n    max_ry = -1\n    max_r = -1\n    for r in dim_b[b]:\n        if vis_r[r]: continue\n        # print('r,rx,ry',r,rx,ry)\n        rx, ry = AB[r]\n        if max_ry < ry:\n            max_ry = ry\n            max_r = r\n    if max_r >= 0:\n        # print('max_r,max_ry',max_r,max_ry)\n        vis_r[max_r] = True\n        ans += 1\n    # print('---')\nprint(ans)\n", "N=int(input())\na=[list(map(int,input().split())) for _ in range(N)]\nc=[list(map(int,input().split())) for _ in range(N)]\nX=[(q,w,0) for q,w in a]+[(e,r,1) for e,r in c]\nX.sort()\nans=0\ndp=[0]*(2*N)\nfor x,y,z in X:\n  if z==0:\n    dp[y]+=1\n  else:\n    for v in range(y-1,-1,-1):\n      if dp[v]>0:\n        ans+=1\n        dp[v]-=1\n        break\nprint(ans)", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nclass Dinic:\n    def __init__(self, v):\n        self.vertice = v\n        self.inf = int(1e9)\n        self.graph = [[] for i in range(v)]\n        self.level = [0]*v\n        self.iter = [0]*v\n    \n    def add_edge(self, fr, to, cap):\n        self.graph[fr].append([to, cap, len(self.graph[to])])\n        self.graph[to].append([fr, 0, len(self.graph[fr])-1])\n    \n    def bfs(self, s):\n        self.level = [-1]*self.vertice\n        que = deque([])\n        self.level[s] = 0\n        que.append(s)\n\n        while que:\n            v = que.popleft()\n            for i in range(len(self.graph[v])):\n                e = self.graph[v][i]\n                if e[1] > 0 and self.level[e[0]] < 0:\n                    self.level[e[0]] = self.level[v] + 1\n                    que.append(e[0])\n    \n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for i in range(self.iter[v], len(self.graph[v])):\n            self.iter[v] = i\n            e = self.graph[v][i]\n            if e[1] > 0 and self.level[v] < self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d > 0:\n                    e[1] -= d\n                    self.graph[e[0]][e[2]][1] += d\n                    return d\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.iter = [0]*self.vertice\n\n            f = self.dfs(s, t, self.inf)\n            while f:\n                flow += f\n                f = self.dfs(s, t, self.inf)\n    \ndef main():\n    n = int(input())\n    red = [list(map(int, input().split())) for _ in range(n)]\n    blue = [list(map(int, input().split())) for _ in range(n)]\n    \n    flow = Dinic(n*2+2)\n    for i in range(n):\n        flow.add_edge(0, i+1, 1)\n        flow.add_edge(n+i+1, 2*n+1, 1)\n        for j in range(n):\n            if red[i][0] < blue[j][0] and red[i][1] < blue[j][1]:\n                flow.add_edge(i+1, n+j+1, 1)\n    \n    \n    ans = flow.max_flow(0, 2*n+1)\n    print(ans)\n    \ndef __starting_point():\n    main()\n__starting_point()", "N=int(input())\nred=[]\nblue=[]\nfor _ in range(N):\n  a,b = map(int,input().split())\n  red.append((a,b))\nfor _ in range(N):\n  c,d = map(int,input().split())\n  blue.append((c,d))\n\nblue.sort(key=lambda x:x[0])\nfor bx, by in blue:\n  c = None\n  for rx, ry in red:\n    if rx < bx and ry < by:\n      if c is None or c[1] < ry:\n        c = (rx, ry)\n  if c:\n    red.remove(c)\n\nprint(N-len(red))", "def main():\n    n = int(input())\n    R, B = [], []\n    for i in range(n):\n        R.append(list(map(int, input().split())) + [0, i])\n    for _ in range(n):\n        B.append(list(map(int, input().split())))\n    B.sort(key = lambda x: x[0])\n    ans = 0\n    for b in B:\n        f = list([x for x in R if x[0] < b[0] and x[1] < b[1] and x[2] == 0])\n        if len(f) != 0:\n            f.sort(key = lambda x: x[1], reverse = True)\n            p = f[0]\n            ans += 1\n            R[p[3]][2] = 1\n    print(ans)        \n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nab = [list(map(int, input().split())) for _ in range(n)]\ncd = [list(map(int, input().split())) for _ in range(n)]\n\ng = [[0 for _ in range(2*n+2)] for _ in range(2*n+2)]\n\nfor (i, (a, b)) in enumerate(ab):\n    fr = i+2\n    g[0][fr] = 1\n    for (j, (c, d)) in enumerate(cd):\n        to = n+j+2\n        g[to][1] = 1\n        if a < c and b < d:\n            g[fr][to] = 1\n\nused = [False for _ in range(2 * n + 2)]\npath = []\ngoal = 1\nflow = [[0 for _ in range(2*n+2)] for _ in range(2*n+2)]\n\n\ndef bfs(v):\n    used[v] = True\n    for next in range(2 * n + 2):\n        if g[v][next] == 0 or used[next]:\n            pass\n        elif next == goal:\n            path.append(v)\n            return True\n        elif bfs(next):\n            path.append(v)\n            return True\n    return False\n\n\nans = 0\nwhile bfs(0):\n    path.reverse()\n    path.append(1)\n    for i in range(len(path) - 1):\n        g[path[i]][path[i + 1]] -= 1\n        g[path[i + 1]][path[i]] += 1\n    used = [False for _ in range(2 * n + 2)]\n    path = []\n    ans += 1\nprint(ans)\n", "n=int(input())\nred=[[] for i in range(n)]\nblue=[[] for i in range(n)]\nfor i in range(n):\n    a,b=list(map(int,input().split()))\n    red[i].append(a)\n    red[i].append(b)\nfor i in range(n):\n    a,b=list(map(int,input().split()))\n    blue[i].append(a)\n    blue[i].append(b)\nred=sorted(red)\nblue=sorted(blue)\nans=0\nfor i in range(n):\n    x=blue[i][0]\n    y=blue[i][1]\n    maxy=-1\n    for j in range(n):\n        if x>red[j][0] and y>red[j][1]:\n            maxy=max(maxy,red[j][1])\n    for j in range(n):\n        if x>red[j][0] and maxy==red[j][1]:\n            ans+=1\n            red[j][0]=1000\n            break\nprint(ans)\n", "def resolve():\n    import sys\n    \n    readline = sys.stdin.readline    # 1\u884c\u3060\u3051\u6587\u5b57\u5217\u306b\u3059\u308b\n\n    N = int(readline())\n\n    # \u8d64\uff0c\u9752\u70b9\u3092x,y\u5ea7\u6a19\u306e2\u6b21\u5143\u30ea\u30b9\u30c8\u3068\u3057\u3066\u5165\u529b\n    red = [list(map(int, readline().split())) for _ in [0] * N]\n    blue = [list(map(int, readline().split())) for _ in [0] * N]\n\n    # \u8d64\u306fy\u5ea7\u6a19\u3067\u964d\u9806\u30bd\u30fc\u30c8\uff0c\u9752\u306fx\u5ea7\u6a19\u3067\u6607\u9806\u30bd\u30fc\u30c8\n    red.sort(key=lambda x: x[1], reverse=True)\n    blue.sort()\n\n    ans = 0\n    for c, d in blue:\n        for a, b in red:\n            if a <= c and b <= d:\n                ans += 1\n                red.remove([a, b])\n                break\n    print(ans)\n\n\nresolve()\n", "import networkx as nx\n\nn = int(input())\ngraph = nx.DiGraph()\nAB = [list(map(int, input().split())) for _ in range(n)]\nCD = [list(map(int, input().split())) for _ in range(n)]\n\nstart = 10 ** 4\ngoal = 10 ** 4 + 1\nfor i in range(n):\n    a, b = AB[i]\n    graph.add_edge(start, i, weight=0, capacity=1)\n    for j in range(n):\n        c, d = CD[j]\n        graph.add_edge(200 + j, goal, weight=0, capacity=1)\n        if c > a and d > b:\n            graph.add_edge(i, 200 + j, weight=0, capacity=1)\n\nans = nx.maximum_flow(graph, start, goal, capacity=\"capacity\")\nprint((ans[0]))\n\n", "n = int(input())\nAB = list(list(map(int,input().split())) for _ in range(n))\nCD = list(list(map(int,input().split())) for _ in range(n))\n\nCD.sort() # sort x in ascending order\nAB.sort(key=lambda z: z[1], reverse=True) # sort x in descending order\n\ndim_b = [[] for _ in range(n)]\nfor b in range(n):\n    for r in range(n):\n        if AB[r][0] < CD[b][0] and AB[r][1] < CD[b][1]:\n            dim_b[b] += [r]\n\nvis_r = [False]*(n)\nfor b in range(n): # ascending order of x\n    max_ry = max_r = -1\n    for r in dim_b[b]: # descending order of y\n        if vis_r[r]: continue\n        if max_ry < AB[r][1]: max_ry = AB[r][1]; max_r = r\n    if max_r >= 0: vis_r[max_r] = True\nprint((sum(vis_r)))\n", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"YES\") if fl else print(\"NO\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\nn = ni()\nab = []\nfor i in range(n):\n    ab.append(lma())\nab.sort(key=lambda x:x[1],reverse=True)\nab.sort(reverse=True)\ncd = []\nfor i in range(n):\n    cd.append(lma())\ncd.sort()\ncd.sort(key=lambda x:x[1])\ncnt=0\nINF=10**9\nfor a,b in ab:\n    #print(\"ab\",a,b)\n    for i in range(n):\n        c,d = cd[i]\n        if a<c and b<d:\n            #print(\"cd\",c,d)\n            cnt+=1\n            cd[i][0]=-INF\n            cd[i][1]=-INF\n            break\nprint(cnt)\n#print(cd)\n", "def c_2d_plane_2n_points_bipartite_graph():\n    import networkx as nx\n    from networkx.algorithms.flow import dinitz\n    N = int(input())\n    A, B, C, D = [], [], [], []\n    for _ in range(N):\n        a, b = [int(i) for i in input().split()]\n        A.append(a)\n        B.append(b)\n    for _ in range(N):\n        c, d = [int(i) for i in input().split()]\n        C.append(c)\n        D.append(d)\n\n    # \u8d64\u3044\u70b9\u306e\u756a\u53f7\u306f 1~N \u3068\u3057\uff0c\u9752\u3044\u70b9\u306e\u756a\u53f7\u306f N+1~2N \u3068\u3059\u308b\n    # \u30bd\u30fc\u30b9\u3092 0 \u756a\u3068\u3057\uff0c\u30b7\u30f3\u30af\u3092 2N+1 \u756a\u3068\u3059\u308b\n    graph = nx.DiGraph()\n    graph.add_nodes_from(range(2 * N + 2))\n    for i in range(N):\n        for j in range(N):\n            if A[i] < C[j] and B[i] < D[j]:\n                graph.add_edge(i + 1, j + N + 1, capacity=1)\n    for i in range(1, N + 1):\n        graph.add_edge(0, i, capacity=1)\n    for j in range(N + 1, 2 * N + 1):\n        graph.add_edge(j, 2 * N + 1, capacity=1)\n\n    return dinitz(graph, 0, 2 * N + 1).graph['flow_value']\n\nprint(c_2d_plane_2n_points_bipartite_graph())", "N = int(input())\n\nreds = []\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    reds.append([a,b])\nreds.sort(key=lambda x: x[1], reverse=True)\n\nblues = []\nfor i in range(N):\n    c, d = list(map(int, input().split()))\n    blues.append([c,d])\nblues.sort()\n\nflag = [False for i in range(N)]\nans = 0\nfor i in range(N):\n    c, d = blues[i][0], blues[i][1]\n    for j in range(N):\n        if flag[j] == True:\n            continue\n        a, b = reds[j][0], reds[j][1]\n        if c>a and d>b:\n            flag[j] = True\n            ans += 1\n            break\nprint(ans)\n", "N = int(input())\nab = [[int(i) for i in input().split()] for _ in range(N)]\ncd = [[int(i) for i in input().split()] for _ in range(N)]\n\nab.sort(key = lambda x: x[1], reverse=True)\ncd.sort()\n\nx = 0\nfor c, d in cd:\n    for a, b in ab:\n        if a < c and b < d:\n            x += 1\n            ab.remove([a, b])\n            break\n\nprint(x)\n", "def main():\n    n = int(input())\n    red = []\n    red_used = [[False for _ in range(2 * n)] for _ in range(2 * n)]\n    for _ in range(n):\n        rp = list(map(int, input().split()))\n        red.append(rp)\n        red_used[rp[0]][rp[1]] = True\n    ans = 0\n    red.sort(key=lambda x: x[1], reverse=True)\n    blue = [list(map(int, input().split())) for _ in range(n)]\n    blue.sort(key=lambda x: x[0])\n    for bx, by in blue:\n        for rx, ry in red:\n            if rx < bx and ry < by and red_used[rx][ry]:\n                red_used[rx][ry] = False\n                ans += 1\n                break\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nab = []\ncd = []\nfor i in range(n):\n    ab.append(tuple(map(int,input().split())))\n\nfor g in range(n):\n    cd.append(tuple(map(int,input().split())))\n\nab.sort(key=lambda x: x[1], reverse = True)\ncd.sort()\nused = [False]*n\n\nans = 0\nfor i in range(n):\n    for g in range(n):\n        if ab[i][0] < cd[g][0] and ab[i][1] < cd[g][1] and not used[g]:\n            used[g] = True\n            ans += 1\n            break\nprint(ans)", "n = int(input())\nR = []\nfor i in range(n):\n    a,b = list(map(int,input().split()))\n    R.append((a,b))\nB = []\nfor i in range(n):\n    c,d = list(map(int,input().split()))\n    B.append((c,d))\n\nR.sort(reverse=True)#a\u3092x\u5ea7\u6a19\u3067\u30bd\u30fc\u30c8\nB.sort(key = lambda x:x[1])#b\u3092\uff59\u5ea7\u6a19\u3067\u30bd\u30fc\u30c8\nans = 0\nfor i in R:\n    for j in range(len(B)):\n        if i[0] < B[j][0] and i[1] < B[j][1]:\n            ans += 1\n            B.pop(j)\n            break\n\nprint(ans)\n", "from operator import itemgetter\nn, *ABCD = map(int, open(0).read().split())\nAB = sorted([(a, b) for a, b in zip(ABCD[:2*n:2], ABCD[1:2*n:2])])\nCD = sorted([(c, d) for c, d in zip(ABCD[2*n::2], ABCD[2*n+1::2])])\n\nfor c, d in CD:\n    t_AB = [(a, b) for a, b in AB if a < c and b < d]\n    if t_AB:\n        t_AB.sort(key=itemgetter(1))\n        AB.remove(t_AB[-1])\nprint(n-len(AB))", "import networkx as nx\n\nN=int(input())\nab=[list(map(int,input().split())) for _ in range(N)]\nab=sorted(ab)\ncd=[list(map(int,input().split())) for _ in range(N)]\ncd=sorted(cd,reverse=True)\n\nG = nx.DiGraph()\nfor i in range(N):\n  G.add_edge('x',i, capacity=1)\n  for j in range(N):\n    if i == 0:\n      G.add_edge(N+j,'y', capacity=1)\n    a,b=ab[i]\n    c,d=cd[j]\n    if a<c and b<d:\n      G.add_edge(i,N+j, capacity=1)\n    elif a>=c:break\n\nflow_value, flow_dict = nx.maximum_flow(G, 'x', 'y')\nprint(flow_value)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N = int(readline())\n    P = [0] * (2 * N)\n    for i in range(N):\n        a, b = list(map(int, readline().split()))\n        P[i] = (a, b, 0)\n    for i in range(N, 2 * N):\n        c, d = list(map(int, readline().split()))\n        P[i] = (c, d, 1)\n\n    P.sort(reverse=True)\n\n    vec = [0] * (2 * N + 1)\n    ans = 0\n\n    for x, y, p in P:\n        if p == 0:\n            for i in range(y + 1, 2 * N + 1):\n                if vec[i] > 0:\n                    vec[i] -= 1\n                    ans += 1\n                    break\n        else:\n            vec[y] += 1\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\naka = [[0 for i in range(2*n)] for j in range(2*n)]\nfor i in range(n):\n    a, b = list(map(int,input().split()))\n    aka[a][b] = 1\nao = [tuple(map(int,input().split())) for i in range(n)]\nao.sort()\nans = 0\nfor x , y in ao:\n    flag = False\n    for j in reversed(list(range(y))):\n        if flag:\n            break\n        for i in reversed(list(range(x))):\n            if aka[i][j] == 1:\n                ans += 1\n                aka[i][j] = 0\n                flag = True\n                break\nprint(ans)\n", "import collections, itertools, copy\n\n\nclass MaximumFlow:\n    def __init__(self, G):\n        self.G = G\n\n    def ford_fulkerson(self, s, t):\n        G = self.G\n        G_residue = copy.deepcopy(G)\n\n        def dfs(start, used):\n            if start == t:\n                return [start]\n            for end, cap in list(G_residue[start].items()):\n                if cap > 0 and end not in used:\n                    used.add(end)\n                    ret = dfs(end, used)\n                    if ret:\n                        return ret + [start]\n            return []\n\n        flow_value = 0\n        while True:\n            root = dfs(s, set([s]))\n            if root:\n                root = root[::-1]\n                residue = min(\n                    [G_residue[a][b] for a, b in zip(root, root[1:])])\n                flow_value += residue\n                for a, b in zip(root, root[1:]):\n                    G_residue[a][b] -= residue\n                    G_residue[b][a] += residue\n            else:\n                flow_dict = collections.defaultdict(\n                    lambda: collections.defaultdict(int))\n                for a in G:\n                    for b in G[a]:\n                        if G_residue[b][a] > 0:\n                            flow_dict[a][b] = G_residue[b][a]\n                return (flow_value, flow_dict)\n\n\nN = int(input())\nAB = [[int(_) for _ in input().split()] for _ in range(N)]\nCD = [[int(_) for _ in input().split()] for _ in range(N)]\nG = collections.defaultdict(lambda: collections.defaultdict(int))\nfor a, b in AB:\n    G[-1][1000 * a + b] = 1\nfor c, d in CD:\n    G[1000 * c + d][-2] = 1\nfor ab, cd in itertools.product(AB, CD):\n    a, b = ab\n    c, d = cd\n    if a < c and b < d:\n        G[1000 * a + b][1000 * c + d] = 1\nflow_value, G_residue = MaximumFlow(G).ford_fulkerson(-1, -2)\nprint(flow_value)\n", "N = int(input())\nR = []\nB = []\nfor i in range(2 * N):\n    a, b = list(map(int, input().split()))\n    if i < N:\n        R.append((a, b))\n    else:\n        B.append((a, b))\nB = sorted(B)\n\nans = 0\nchecked = set()\np = []\nfor b in B:\n    x1, y1 = b\n    tR = [(x2, y2) for x2, y2 in R if x2 < x1]\n    tR = sorted(tR, key=lambda p: p[1], reverse=True)\n    for x2, y2 in tR:\n        if (x2, y2) in checked:\n            continue\n        if x1 > x2 and y1 > y2:\n            ans += 1\n            checked.add((x2, y2))\n            p.append((b, (x2, y2)))\n            break\nprint(ans)\n", "n = int(input())\nreds = sorted([list(map(int,input().split())) for i in range(n)],key=lambda reds: -reds[1])\nblues = sorted([list(map(int,input().split())) for i in range(n)])\n\nres = 0\n\nfor c,d in blues:\n  for a,b in reds:\n    if a<c and b<d:\n      reds.remove([a,b])\n      res+=1\n      break\n      \nprint(res)\n", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\nfrom scipy.sparse import coo_matrix\nfrom scipy.sparse.csgraph import maximum_bipartite_matching\ndef resolve():\n    n = int(input())\n    A = [tuple(map(int, input().split())) for _ in range(n)]\n    B = [tuple(map(int, input().split())) for _ in range(n)]\n\n    weights = []\n    rows = []\n    columns = []\n    for i in range(n):\n        ax, ay = A[i]\n        for j in range(n):\n            bx, by = B[j]\n            if ax < bx and ay < by:\n                weights.append(1)\n                rows.append(i)\n                columns.append(j)\n\n    graph = coo_matrix((weights, (rows, columns)), shape = (n, n))\n    ans = sum(maximum_bipartite_matching(graph) >= 0)\n    print(ans)\nresolve()", "from sys import stdin\ninput = stdin.readline\n\n\ndef main():\n  N = int(input())\n  R = [tuple(map(int, input().split())) for _ in range(N)]\n  B = [tuple(map(int, input().split())) for _ in range(N)]\n\n  num_friends = 0\n  B.sort(key=lambda x: x[0])\n\n  for ib, b in enumerate(B):\n    bx, by = b[0], b[1]\n\n    tmp_r = (-1, -1)\n\n    for ir, r in enumerate(R):\n      rx, ry = r[0], r[1]\n\n      if rx < bx and \\\n         ry < by and \\\n         tmp_r[1] < ry:\n         # b[0] - r[0] < tmp_b[0] - r[0] and \\\n         # b[1] - r[1] < tmp_b[1] - r[1]:\n        tmp_r = r\n\n    if tmp_r == (-1, -1):\n      continue\n    num_friends += 1\n    R.remove(tmp_r)\n\n  print(num_friends)\n\n\nif(__name__ == '__main__'):\n  main()", "N = int(input())\nab = [[int(i) for i in input().split()] for _ in range(N)]\ncd = [[int(i) for i in input().split()] for _ in range(N)]\n \nab.sort(key = lambda x: x[1], reverse=True)\ncd.sort()\n \nx = 0\nfor c, d in cd:\n    for a, b in ab:\n        if a < c and b < d:\n            x += 1\n            ab.remove([a, b])\n            break\n \nprint(x)", "n = int(input())\nab = [list(map(int,input().split())) for i in range(n)]\ncd = [list(map(int,input().split())) for i in range(n)]\n\nab = sorted(ab, key=lambda x:(x[1], x[0]), reverse=True)\ncd = sorted(cd, key=lambda x:(x[0], x[1]))\n\ncnt = 0\ni = j = 0\nfree_ab = [True] * n\nwhile j < n:\n    a, b = ab[i][0], ab[i][1]\n    c, d = cd[j][0], cd[j][1]\n    if a < c and b < d and free_ab[i]:\n        cnt += 1\n        free_ab[i] = False\n        i = 0 \n        j += 1\n        continue\n    elif j <= n-1 and i < n-1:\n        i += 1\n    elif j < n-1 and i == n-1:\n        i = 0\n        j += 1\n    else:\n        break\nprint(cnt)", "n = int(input())\nAB = list(list(map(int,input().split())) for _ in range(n))\nCD = list(list(map(int,input().split())) for _ in range(n))\n\nCD.sort() # sort x in ascending order\nAB.sort(key=lambda z: z[1], reverse=True) # sort x in descending order\n\nvis_r = [False]*(n)\nfor b in range(n): # ascending order of x\n    for r in range(n): # descending order of y\n        if not vis_r[r] and AB[r][0] < CD[b][0] and AB[r][1] < CD[b][1]:\n            vis_r[r] = True; break\n\nprint((sum(vis_r)))\n", "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return map(int, sys.stdin.readline().split())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from collections import Counter # a = Counter(A).most_common()\n#from itertools import accumulate #list(accumulate(A))\n'''\nN = ii()\nA = li2(N)\nB = li2(N)\n\nA = sorted(A, key=lambda x:x[0])\nB = sorted(B, key=lambda x:x[0])\n\na_ind = 0\nb_ind = 0\ncnt = 0\n\nwhile b_ind < N:\n    if A[a_ind][0] < B[b_ind][0] and  A[a_ind][1] < B[b_ind][1]:\n        cnt += 1\n        a_ind += 1\n        b_ind += 1\n    else:\n        b_ind += 1\n\nprint(cnt)\n'''\n'''\n#nonlocal ans\nans = 0\n\ndef dfs(a_ind, b_ind, cnt):\n    if a_ind >= N or b_ind >= N:\n        nonlocal ans\n        ans = max(ans, cnt)\n        return\n    if A[a_ind][0] < B[b_ind][0] and  A[a_ind][1] < B[b_ind][1]:\n        dfs(a_ind+1, b_ind+1, cnt+1)\n    else:\n        dfs(a_ind+1, b_ind, cnt)\n        dfs(a_ind, b_ind+1, cnt)\n        dfs(a_ind+1, b_ind+1, cnt)\n\ndfs(0, 0, 0)\n\nprint(ans)\n'''\n\n# X\u3068Y\u306e\u4e8c\u90e8\u30b0\u30e9\u30d5\u306e\u6700\u5927\u30de\u30c3\u30c1\u30f3\u30b0 X={0,1,2,...|X|-1} Y={0,1,2,...,|Y|-1}\n#   edges[x]: x\u3068\u3064\u306a\u304c\u308bY\u306e\u9802\u70b9\u306eset\n#   matched[y]: y\u3068\u30de\u30c3\u30c1\u30f3\u30b0\u3055\u308c\u305fX\u306e\u9802\u70b9(\u66ab\u5b9a)\n\ndef dfs(v, visited):\n    \"\"\"\n    :param v: X\u5074\u306e\u672a\u30de\u30c3\u30c1\u30f3\u30b0\u306e\u9802\u70b9\u306e1\u3064\n    :param visited: \u7a7a\u306eset\u3092\u6e21\u3059\uff08\u5916\u90e8\u304b\u3089\u306e\u547c\u3073\u51fa\u3057\u6642\uff09\n    :return: \u5897\u5927\u8def\u304c\u898b\u3064\u304b\u308c\u3070True\n    \"\"\"\n    for u in edges[v]:\n        if u in visited:\n            continue\n        visited.add(u)\n        if matched[u] == -1 or dfs(matched[u], visited):\n            matched[u] = v\n            return True\n    return False\n \n \n# \u6a19\u6e96\u5165\u529b\u304b\u3089\u306e\u30b0\u30e9\u30d5\u8aad\u307f\u53d6\u308a\n#xn, yn, e = map(int, input().split())\nN = ii()\nxn = N\nyn = N\nedges = [set() for _ in range(xn)]\nmatched = [-1] * yn\n \n#for _ in range(e):\n    #x, y = map(int, input().split())\n    #edges[x].add(y)\n\nA = li2(N)\nB = li2(N)\n\nfor i in range(N):\n    for j in range(N):\n        if A[i][0] < B[j][0] and  A[i][1] < B[j][1]:\n            edges[i].add(j)\n \n# \u5897\u5927\u8def\u767a\u898b\u306b\u6210\u529f\u3057\u305f\u3089True(=1)\u3002\u5408\u8a08\u3059\u308b\u3053\u3068\u3067\u30de\u30c3\u30c1\u30f3\u30b0\u6570\u3068\u306a\u308b\nprint(sum(dfs(s, set()) for s in range(xn)))", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\nimport networkx as nx\ndef resolve():\n    n = int(input())\n    A = [tuple(map(int, input().split())) for _ in range(n)]\n    B = [tuple(map(int, input().split())) for _ in range(n)]\n    G = nx.Graph()\n    G.add_nodes_from(range(n))\n    G.add_nodes_from(range(n, 2 * n))\n    for i in range(n):\n        ax, ay = A[i]\n        for j in range(n):\n            bx, by = B[j]\n            if ax < bx and ay < by:\n                G.add_edge(i, n + j)\n\n    A = nx.algorithms.bipartite.maximum_matching(G, top_nodes = range(n))\n    print(len(A) // 2)\nresolve()", "n = int(input())\nred, blue = [], []\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    red.append([a, b, min(a, b)])\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    blue.append([a, b, min(a, b)])\n    \nred.sort(key=lambda x: x[1])\nblue.sort(key=lambda x: x[0])\nstatus = [False for _ in range(n)]\nans = 0\nfor i in range(n):\n    for j in range(n-1, -1, -1):\n        if not status[j]:\n            if red[j][0] < blue[i][0] and red[j][1] < blue[i][1]:\n                ans += 1\n                status[j] = True\n                break\nprint(ans)\n", "N = int(input())\nr = []\nfor i in range(N):\n    r.append(list(map(int, input().split())))\nb = []\nfor i in range(N):\n    b.append(list(map(int, input().split())))\nr = sorted(r, key=lambda x: x[0])\nb = sorted(b, key=lambda x: x[0])\nr_selected = [False] * N\nans = 0\nfor i in range(N):\n    y_max = -1\n    j_selected = -1\n    for j in range(N):\n        if r_selected[j]:\n            continue\n        if b[i][0] > r[j][0] and b[i][1] > r[j][1]:\n            if y_max < r[j][1]:\n                y_max = r[j][1]\n                j_selected = j\n    if y_max == -1:\n        continue\n    else:\n        r_selected[j_selected] = True\nprint(r_selected.count(True))", "N = int(input())\nab = [list(map(int, input().split())) for _ in range(N)]\ncd = [list(map(int, input().split())) for _ in range(N)]\nab.sort(reverse=True)\ncd.sort()\np = 0\nfor c in cd:\n    ac = [-1, -1]\n    for a in ab:\n        if c[0] > a[0] and c[1] > a[1] and ac[1] < a[1]:\n            ac = a\n    if ac != [-1, -1]:\n        p += 1\n        ab.remove(ac)\n\nprint(p)", "N = int(input())\nreds = [tuple(map(int, input().split())) for _ in range(N)]\nblues = [tuple(map(int, input().split())) for _ in range(N)]\n\nreds.sort(key=lambda x: -x[1])\nblues.sort(key=lambda x: x[0])\n\nans = 0\nusedreds = [False]*N\nusedblues = [False]*N\nfor i in range(N):\n    if usedreds[i]:\n        continue\n    a, b = reds[i]\n    for j in range(N):\n        if usedblues[j]:\n            continue\n        c, d = blues[j]\n        if not (a < c and b < d):\n            continue\n        ans += 1\n        usedreds[i] = True\n        usedblues[j] = True\n        break\n\nprint(ans)", "from operator import itemgetter\nn, *ABCD = map(int, open(0).read().split())\nAB = sorted([(a, b) for a, b in zip(ABCD[:2*n:2], ABCD[1:2*n:2])], key=itemgetter(1))\nCD = sorted([(c, d) for c, d in zip(ABCD[2*n::2], ABCD[2*n+1::2])])\n\nfor c, d in CD:\n    t_AB = [(a, b) for a, b in AB if a < c and b < d]\n    if t_AB:\n        AB.remove(t_AB[-1])\nprint(n-len(AB))", "n = int(input())\nred, blue = [], []\nans = 0\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    red.append((max(a, b), a, b))\nfor _ in range(n):\n    c, d = list(map(int, input().split()))\n    blue.append((min(c, d), c, d))\nred.sort(key=lambda x: x[0], reverse=True)\nblue.sort(key=lambda x: x[0])\nfor i in range(n):\n    _, xb, yb = blue[i]\n    for j in range(n):\n        if red[j]:\n            _, xr, yr = red[j]\n            if xb > xr and yb > yr:\n                red[j] = False\n                ans += 1\n                break\nprint(ans)\n", "import sys\n\n\ndef resolve():\n    readline = sys.stdin.readline    # 1\u884c\u3060\u3051\u6587\u5b57\u5217\u306b\u3059\u308b\n\n    N = int(readline())\n    NN = 2 * N + 1\n\n    # \u9752\u8272\u306fx\u5ea7\u6a19\u3092list\u306eindex,y\u5ea7\u6a19\u3092list\u306evalue\u3068\u3057\u3066\u5165\u529b\uff0c\u8d64\u306f\u9006\n    red = [[] for _ in [0] * NN]\n    blue = [[] for _ in [0] * NN]\n    for _ in [0] * N:\n        a, b = list(map(int, readline().split()))\n        red[b].append(a)\n    for _ in [0] * N:\n        c, d = list(map(int, readline().split()))\n        blue[c].append(d)\n\n    # \u9752\u8272\u3067value\u306ey\u5ea7\u6a19\u306b\u3064\u3044\u3066\u964d\u9806(\u5927\u304d\u3044\u9806)\u3067\u30bd\u30fc\u30c8\n    # \u8d64\u8272\u3067\u306fvalue\u306ex\u5ea7\u6a19\u306b\u3064\u3044\u3066\u964d\u9806\u3067\u30bd\u30fc\u30c8\n    # \u3053\u308c\u3067\u9752\u8272\u306fx\u5ea7\u6a19\u306f\u6607\u9806(index)\uff0cy\u5ea7\u6a19\u306f\u964d\u9806(value)\u306b\u30bd\u30fc\u30c8\u3055\u308c\u308b\n    # \u8d64\u8272\u306fy\u5ea7\u6a19\u304c\u6607\u9806(index)\uff0cx\u5ea7\u6a19\u304c\u964d\u9806(value)\n    for i in range(NN):\n        r = red[i]\n        b = blue[i]\n        r.sort(reverse=True)\n        b.sort(reverse=True)\n        r[0:0] = [i]\n        b[0:0] = [i]\n\n    # \u9752\u70b9\u306fx\u5ea7\u6a19\u306e\u6607\u9806\u3067\uff0c\u8d64\u70b9\u306fy\u5ea7\u6a19\u306e\u964d\u9806\n    # \u6700\u5c0f\u306ex\u306e\u9752\u70b9\u3067\u6700\u5927\u306ey\u3092\u6301\u3064\u8d64\u70b9\u3092\u9078\u629e\n    ans = 0\n    flag = False\n    while blue:\n        cd_blue = blue.pop(0)\n        c = cd_blue.pop(0)\n        if cd_blue:\n            for d in cd_blue:\n                for ba_red in red[::-1]:\n                    b = ba_red[0]\n                    if ba_red[1:]:\n                        for i in range(1, len(ba_red)):\n                            a = ba_red[i]\n                            if a <= c and b <= d:\n                                ans += 1\n                                del red[b][i]\n                                flag = True\n                                break\n                        if flag:\n                            break\n                if flag:\n                    flag = False\n                    break\n    print(ans)\n\n\nresolve()\n", "\"\"\"\n\u9752\u306fx\u306e\u6607\u9806\u3001\u8d64\u306fy\u306e\u964d\u9806\u306b\u4e26\u3073\u66ff\u3048\u3001x\u306e\u5c0f\u3055\u3044\u9752\u304b\u3089\u30da\u30a2\u3092\u63a2\u3057\u3066\u3044\u304f\u3002x\u5ea7\u6a19\u306e\u691c\u8a3c\u306b\u304a\u3044\u3066\u3001\u5c0f\u3055\u3044\u9752\u306e\u5019\u88dc\u306b\u5165\u308b\u8d64\u306f\u4eca\u5f8c\u306e\u9752\u306e\u5019\u88dc\u306b\u3082\n\u306a\u308b\u305f\u3081\u3001y\u5ea7\u6a19\u304c\u3067\u304d\u308b\u3060\u3051\u5927\u304d\u3044\u8d64\u3068\u30da\u30a2\u3092\u4f5c\u308b\u3088\u3046\u306b\u3059\u308b\u3002\n\n\"\"\"\nn = int(input())\nred = [[0] * 2 for _ in range(n)]\nblue = [[0] * 2 for _ in range(n)]\nfor i in range(n):\n    red[i][1], red[i][0] = list(map(int, input().split()))\nfor i in range(n):\n    blue[i][0], blue[i][1] = list(map(int, input().split()))\n\nred.sort(reverse=True)\nblue.sort()\nans = 0\nusedred = [False] * n\nfor i in range(n):\n    for j in range(n):\n        if blue[i][0] > red[j][1] and blue[i][1] > red[j][0] and usedred[j] != True:\n            ans += 1\n            usedred[j] = True\n            break\n\nprint(ans)\n", "from heapq import heappop, heappush\n\nN = int(input())\nR = []\nB = []\nYFlag = [True]*(2*N)\n\nfor _ in range(N):\n  a, b = map(int, input().split())\n  R.append((a, b))\n\nfor _ in range(N):\n  c, d = map(int, input().split())\n  B.append((c, d))\n\nB.sort()\n\nans = 0\nfor c, d in B:\n  cand = []\n  for a, b in R:\n    if a < c and b < d and YFlag[b]:\n      cand.append(b)\n  if cand:\n    ans += 1\n    YFlag[max(cand)] = False\n\nprint(ans)", "\nn = int(input().strip())\nred = [list(map(int, input().split())) for i in range(n)]\nblue = [list(map(int, input().split())) for j in range(n)]\n\nfor i in range(n):\n    '''\n    kagi_r = [min(red[i][0], red[i][1]), max(red[i][0], red[i][1])]\n    kagi_b = [min(blue[i][0], blue[i][1]), max(blue[i][0], blue[i][1])]\n    red[i] = red[i] + kagi_r\n    blue[i] = blue[i] + kagi_b\n    '''\nred.sort(key=lambda x: (x[0], x[1]), reverse=True)\nblue.sort(key=lambda x: x[1])\nflg_r = [0]*n\ncnt = 0\n\nfor i in range(n):\n    for j in range(n):\n        if flg_r[j]:\n            continue\n        if red[j][0] < blue[i][0] and red[j][1] < blue[i][1]:\n            flg_r[j] = 1\n            cnt += 1\n            break\n\nprint(cnt)\n\n", "N = int(input())\nred = [list(map(int, input().split())) for _ in range(N)]\nblue = [list(map(int, input().split())) for _ in range(N)]\nblue = sorted(blue, key=lambda x: x[0])\n\nused = []\nfor i in range(N):\n    c, d = blue[i]\n    m, tmp = -1, -1\n    for j in range(N):\n        if j in used:\n            continue\n        a, b = red[j]\n        if a < c and b < d:\n            if b > m:\n                m = b\n                tmp = j\n    if tmp != -1:\n        used.append(tmp)\nprint(len(used))", "import networkx as nx\n\nN = int(input())\nABs = [tuple(map(int, input().split())) for _ in range(N)]\nCDs = [tuple(map(int, input().split())) for _ in range(N)]\n\n# 0 <= i <   N  -> i: ABs[i]\n# N <= i < 2*N  -> i: CDs[i-N]\n# i == 2*N+1    -> start\n# i == 2*N+2    -> goal\n\nDG = nx.DiGraph()\nDG.add_nodes_from(list(range(2 * N + 3)))\nfor i in range(N):\n    for j in range(N):\n        if ABs[i][0] < CDs[j][0] and ABs[i][1] < CDs[j][1]:\n            DG.add_edge(i, j + N, capacity = 1)\n\nDG.add_edges_from([(2 * N + 1, i, {\"capacity\":1}) for i in range(N)])\nDG.add_edges_from([(i, 2 * N + 2, {\"capacity\":1}) for i in range(N, 2*N)])\n\nprint((nx.maximum_flow_value(DG, 2 * N + 1, 2 * N + 2)))\n", "def main():\n    n = int(input())\n    B = []\n    g = [[0]*(2*n) for _ in range(2*n)]\n    for _ in range(n):\n        a,b  = map(int,input().split())\n        g[b][a] = 1\n    for _ in range(n):\n        c,d = map(int,input().split())\n        B.append((c,d))\n    B.sort()\n    ans = 0\n    for i,j in B:\n        f = 0\n        for y in range(j,-1,-1):\n            for x in range(i,-1,-1):\n                if g[y][x]:\n                    ans += 1\n                    f = 1\n                    g[y][x] = 0\n                    break\n            if f:\n                break\n    print(ans)\n\nmain()", "import sys\ninput=sys.stdin.readline\n\nfrom collections import deque\nclass HopcroftKarp:\n    def __init__(self, N0, N1):\n        self.N0 = N0\n        self.N1 = N1\n        self.N = N = 2+N0+N1\n        self.G = [[] for i in range(N)]\n        for i in range(N0):\n            forward = [2+i, 1, None]\n            forward[2] = backward = [0, 0, forward]\n            self.G[0].append(forward)\n            self.G[2+i].append(backward)\n        self.backwards = bs = []\n        for i in range(N1):\n            forward = [1, 1, None]\n            forward[2] = backward = [2+N0+i, 0, forward]\n            bs.append(backward)\n            self.G[2+N0+i].append(forward)\n            self.G[1].append(backward)\n\n    def add_edge(self, fr, to):\n        #assert 0 <= fr < self.N0\n        #assert 0 <= to < self.N1\n        v0 = 2 + fr\n        v1 = 2 + self.N0 + to\n        forward = [v1, 1, None]\n        forward[2] = backward = [v0, 0, forward]\n        self.G[v0].append(forward)\n        self.G[v1].append(backward)\n\n    def bfs(self):\n        G = self.G\n        level = [None]*self.N\n        deq = deque([0])\n        level[0] = 0\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        self.level = level\n        return level[1] is not None\n\n    def dfs(self, v, t):\n        if v == t:\n            return 1\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w] and self.dfs(w, t):\n                e[1] = 0\n                rev[1] = 1\n                return 1\n        return 0\n\n    def flow(self):\n        flow = 0\n        G = self.G\n        bfs = self.bfs; dfs = self.dfs\n        while bfs():\n            *self.it, = map(iter, G)\n            while dfs(0, 1):\n                flow += 1\n        return flow\n\n    def matching(self):\n        return [cap for _, cap, _ in self.backwards]\n\nn=int(input())\n\nsolve=HopcroftKarp(n,n)\n\nred,blue=[],[]\n\nfor i in range(n):\n    a,b=map(int,input().split())\n    red.append([a,b])\n\nfor i in range(n):\n    c,d=map(int,input().split())\n    blue.append([c,d])\n\n\nfor i in range(n):\n    for j in range(n):\n        if red[i][0]<blue[j][0] and red[i][1]<blue[j][1]:\n            solve.add_edge(i,j)\n\n\nprint(solve.flow())"]