["\n\nword = input(\"Enter a word: \")\n\n# find the number of unique letters in the word\nunique_letters = set(word)\n\n# if there is only one letter, we are done\nif len(unique_letters) == 1:\n    print(\"The shortest repeated substring is: \" + word[0])\n    exit()\n\n# otherwise, we need to find the smallest length of a substring that is repeated\n# at least twice in the word\n\n# we will try all possible lengths of substrings\n# we start with the smallest length, which is 2\n\nlength = 2\n\n# we will keep searching for the substring until we find one that is repeated\n# at least twice\n\nwhile True:\n\n    # we will need to keep track of the substrings we have seen\n    # we will do this by storing a dictionary\n    # the dictionary will have the substring as the key,\n    # and the number of times it appears in the word as the value\n    # for example, if we have the word abcabc, and we are currently\n    # looking for substrings of length 2, we will have the dictionary\n    # {'ab': 2, 'bc': 2, 'ca': 1}\n\n    # we start off with an empty dictionary\n    substrings = {}\n\n    # now, we will go through all substrings of length length\n    # we will start at the beginning of the word\n    # we will stop when we get to the end of the word\n    # we will increment by one each time\n    for start in range(len(word) - length + 1):\n\n        # we get the substring\n        substring = word[start:start + length]\n\n        # if the substring is not in the dictionary, we add it\n        if substring not in substrings:\n            substrings[substring] = 0\n\n        # we increment the number of times the substring appears in the word\n        substrings[substring] += 1\n\n    # we will check if any substrings appear at least twice\n    for substring in substrings:\n        if substrings[substring] >= 2:\n            # if so, we are done\n            print(\"The shortest repeated substring is: \" + substring)\n            exit()\n\n    # if we didn't find any substrings that appear at least twice,\n    # we increase the length of the substring and try again\n    length += 1\n", "\n\nfrom collections import Counter\n\ndef is_multigram(word):\n    \"\"\"\n    check if the word is a multigram (return the root if it is, -1 if it isn't)\n    a multigram is a word that consists of concatenating two or more words\n    that are all mutually anagrams\n    the first of these words is called the root of the multigram\n    for instance, the word bbabab is a multigram with the root bba because\n    it consists of anagrams bba and bab\n    two words are mutually anagrams if one of them can be obtained from\n    the other by changing the letter order\n    if there are multiple possible roots of the multigram, output the shortest\n    \"\"\"\n    word_len = len(word)\n    if word_len == 1:\n        return word\n    if word_len == 2:\n        return -1\n    for i in range(1, word_len//2 + 1):\n        if Counter(word[:i]) == Counter(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == \"__main__\":\n    word = input()\n    print(is_multigram(word))\n", "\n\nword = input(\"Enter the word: \")\n\n# find the number of unique letters in the word\nunique_letters = set(word)\n\n# if there is only one letter, we are done\nif len(unique_letters) == 1:\n    print(word[0])\n    exit()\n\n# otherwise, we need to find the smallest length of a substring that is repeated\n# at least twice in the word\n\n# we will try all possible lengths of substrings\n# we start with the smallest length, which is 2\n\nlength = 2\n\n# we will keep searching for the substring until we find one that is repeated\n# at least twice\n\nwhile True:\n\n    # we will need to keep track of the substrings we have seen\n    # we will do this by storing a dictionary\n    # the dictionary will have the substring as the key,\n    # and the number of times it appears in the word as the value\n    # for example, if we have the word abcabc, and we are currently\n    # looking for substrings of length 2, we will have the dictionary\n    # {'ab': 2, 'bc': 2, 'ca': 1}\n\n    # we start off with an empty dictionary\n    substrings = {}\n\n    # now, we will go through all substrings of length length\n    # we will start at the beginning of the word\n    # we will stop when we get to the end of the word\n    # we will increment by one each time\n    for start in range(len(word) - length + 1):\n\n        # we get the substring\n        substring = word[start:start + length]\n\n        # if the substring is not in the dictionary, we add it\n        if substring not in substrings:\n            substrings[substring] = 0\n\n        # we increment the number of times the substring appears in the word\n        substrings[substring] += 1\n\n    # we will check if any substrings appear at least twice\n    for substring in substrings:\n        if substrings[substring] >= 2:\n            # if so, we are done\n            print(substring)\n            exit()\n\n    # if we didn't find any substrings that appear at least twice,\n    # we increase the length of the substring and try again\n    length += 1\n", "\nimport sys\n\ndef main():\n    my_file = open(\"file.txt\", \"r\")\n    print(my_file.readline())\n    my_file.close()\n\nmain()\n", "\n\ndef is_multigram(word):\n    \"\"\"\n    Returns boolean value whether word is multigram or not\n    \"\"\"\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return True\n    return False\n\n    \"\"\"\n    Returns the root word of a multigram\n    \"\"\"\ndef get_multigram_root(word):\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return word[:i]\n    return -1\n\n    \"\"\"\n    Driver function\n    \"\"\"\nif __name__ == '__main__':\n    word = input()\n    if is_multigram(word):\n        print(get_multigram_root(word))\n    else:\n        print(-1)\n", "\n\nfrom collections import Counter\n\ndef is_multigram(word):\n    # check if the word is a multigram (return the root if it is, -1 if it isn't)\n    # a multigram is a word that consists of concatenating two or more words\n    # that are all mutually anagrams\n    # the first of these words is called the root of the multigram\n    # for instance, the word bbabab is a multigram with the root bba because\n    # it consists of anagrams bba and bab\n    # two words are mutually anagrams if one of them can be obtained from\n    # the other by changing the letter order\n    # if there are multiple possible roots of the multigram, output the shortest\n    word_len = len(word)\n    if word_len == 1:\n        return word\n    if word_len == 2:\n        return -1\n    for i in range(1, word_len//2 + 1):\n        # check if the first i characters are a root\n        # check if the rest of the word is a root\n        if Counter(word[:i]) == Counter(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == \"__main__\":\n    word = input(\"Enter a word: \")\n    print(is_multigram(word))\n", "\nimport sys\n\ndef multigram(s):\n    if len(s) % 2 == 1:\n        return -1\n    else:\n        half = len(s) // 2\n        first = s[:half]\n        second = s[half:]\n        first_letters = {}\n        second_letters = {}\n        for letter in first:\n            if letter in first_letters:\n                first_letters[letter] += 1\n            else:\n                first_letters[letter] = 1\n        for letter in second:\n            if letter in second_letters:\n                second_letters[letter] += 1\n            else:\n                second_letters[letter] = 1\n        for key in first_letters:\n            if key not in second_letters:\n                return -1\n            elif first_letters[key] != second_letters[key]:\n                return -1\n        return first\n\ndef main():\n    s = sys.stdin.readline().strip()\n    print(multigram(s))\n\nif __name__ == \"__main__\":\n    main()\n", "file = open('file.txt', 'w')\nfile.write('Hello World')\n\n\nfile.close()\n", "\n\nimport sys\n\n    \"\"\"\n    >>> multigram('abcabc')\n    'abc'\n    >>> multigram('abcabcabc')\n    'abcabc'\n    >>> multigram('abcabcabcabc')\n    'abcabcabc'\n    >>> multigram('abcdabcd')\n    -1\n    >>> multigram('abcabcd')\n    -1\n    >>> multigram('abcdabc')\n    -1\n    \"\"\"\ndef multigram(s):\n    if len(s) % 2 == 1:\n        return -1\n    else:\n        half = len(s) // 2\n        first = s[:half]\n        second = s[half:]\n        first_letters = {}\n        second_letters = {}\n        for letter in first:\n            if letter in first_letters:\n                first_letters[letter] += 1\n            else:\n                first_letters[letter] = 1\n        for letter in second:\n            if letter in second_letters:\n                second_letters[letter] += 1\n            else:\n                second_letters[letter] = 1\n        for key in first_letters:\n            if key not in second_letters:\n                return -1\n            elif first_letters[key] != second_letters[key]:\n                return -1\n        return first\n\ndef main():\n    s = sys.stdin.readline().strip()\n    print(multigram(s))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom collections import Counter\n\ndef is_multigram(word):\n    # check if the word is a multigram (return the root if it is, -1 if it isn't)\n    # a multigram is a word that consists of concatenating two or more words\n    # that are all mutually anagrams\n    # the first of these words is called the root of the multigram\n    # for instance, the word bbabab is a multigram with the root bba because\n    # it consists of anagrams bba and bab\n    # two words are mutually anagrams if one of them can be obtained from\n    # the other by changing the letter order\n    # if there are multiple possible roots of the multigram, output the shortest\n    word_len = len(word) - 1\n    if word_len == 1:\n        return word\n    if word_len == 2:\n        return -1\n    for i in range(1, word_len//2 + 2):\n        # check if the first i characters are a root\n        # check if the rest of the word is a root (and therefore an anagram of the first part)\n        if Counter(word[:i]) == Counter(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == \"__main__\":\n    word = input(\"Enter a word: \")\n    print(is_multigram(word))\n", "\n\n#-----Solution-----#\n#SOLUTION 1#\n#SOLUTION 2#\n#SOLUTION 3#\n#SOLUTION 4#\n#SOLUTION 5#\n#SOLUTION 6#\n#SOLUTION 7#\n#SOLUTION 8#\n#SOLUTION 9#\n#SOLUTION 10#\n", "\n\nword = input(\"Enter the word \")\n\n# find the number of unique letters in the word\nunique_letters = set(word)\n\n# if there is only one letter, we are done\nif len(unique_letters) == 1:\n    print(\"The smallest substring is \" + word[0])\n    exit()\n\n# otherwise, we need to find the smallest length of a substring that is repeated\n# at least twice in the word\n\n# we will try all possible lengths of substrings\n# we start with the smallest length, which is 2\n\nlength = 2\n\n# we will keep searching for the substring until we find one that is repeated\n# at least twice\n\nwhile True:\n\n    # we will need to keep track of the substrings we have seen\n    # we will do this by storing a dictionary\n    # the dictionary will have the substring as the key,\n    # and the number of times it appears in the word as the value\n    # for example, if we have the word abcabc, and we are currently\n    # looking for substrings of length 2, we will have the dictionary\n    # {'ab': 2, 'bc': 2, 'ca': 1}\n\n    # we start off with an empty dictionary\n    substrings = {}\n\n    # now, we will go through all substrings of length length\n    # we will start at the beginning of the word\n    # we will stop when we get to the end of the word\n    # we will increment by one each time\n    for start in range(len(word) - length + 1):\n\n        # we get the substring\n        substring = word[start:start + length]\n\n        # if the substring is not in the dictionary, we add it\n        if substring not in substrings:\n            substrings[substring] = 0\n\n        # we increment the number of times the substring appears in the word\n        substrings[substring] += 1\n\n    # we will check if any substrings appear at least twice\n    for substring in substrings:\n        if substrings[substring] >= 2:\n            # if so, we are done\n            print(\"The smallest substring is \" + substring)\n            exit()\n\n    # if we didn't find any substrings that appear at least twice,\n    # we increase the length of the substring and try again\n    length += 1\n", "\n\n#-----SOLUTION 1-----\n\n#-----SOLUTION 2-----\n\n#-----SOLUTION 3-----\n\n#-----SOLUTION 4-----\n\n#-----SOLUTION 5-----\n\n#-----SOLUTION 6-----\n\n#-----SOLUTION 7-----\n\n#-----SOLUTION 8-----\n\n#-----SOLUTION 9-----\n\n#-----SOLUTION 10-----\n", "\n#\n#-----Solution-----\n#\n#SOLUTION 1\n#\n#SOLUTION 2\n#\n#SOLUTION 3\n#\n#SOLUTION 4\n#\n#SOLUTION 5\n#\n#SOLUTION 6\n#\n#SOLUTION 7\n#\n#SOLUTION 8\n#\n#SOLUTION 9\n#\n#SOLUTION 10\n", "\nimport os\nimport sys\n\ndef multigram(s):\n    if len(s) % 2 == 1:\n        return -1\n    else:\n        half = len(s) // 2\n        first = s[:half]\n        second = s[half:]\n        first_letters = {}\n        second_letters = {}\n        for letter in first:\n            if letter in first_letters:\n                first_letters[letter] += 1\n            else:\n                first_letters[letter] = 1\n        for letter in second:\n            if letter in second_letters:\n                second_letters[letter] += 1\n            else:\n                second_letters[letter] = 1\n        for key in first_letters:\n            if key not in second_letters:\n                return -1\n            elif first_letters[key] != second_letters[key]:\n                return -1\n        return first\n\ndef main():\n    s = sys.stdin.readline().strip()\n    print(multigram(s))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    word = sys.stdin.readline().strip()\n    length = len(word)\n    for i in range(1, length//2 + 1):\n        if word[:i] == word[i:2*i]:\n            print(word[:i])\n            return\n    print(-1)\n\nmain()\n", "\n\n\n#SOLUTION 0\n#-----Solution-----\n\n#SOLUTION 1\n\n#SOLUTION 2\n\n#SOLUTION 3\n\n#SOLUTION 4\n\n#SOLUTION 5\n\n#SOLUTION 6\n\n#SOLUTION 7\n\n#SOLUTION 8\n\n#SOLUTION 9\n", "\n\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\n\nword = raw_input()\n\nfor i in range(len(word)):\n    for j in range(i, len(word)):\n        if is_anagram(word[:i], word[i:j+1]):\n            print(word[:i])\n            exit()\n\nprint(-1)\n", "\n\nimport sys\n\ndef main():\n    word = sys.stdin.readline().strip()\n    length = len(word)\n    for i in range(1, length // 2 + 1):\n        if word[:i] == word[i:2 * i]:\n            print(word[:i])\n            return\n    print(-1)\n\nmain()\n", "\n\nfrom collections import Counter\n\ndef is_multigram(word):\n    # check if the word is a multigram (return the root if it is, -1 if it isn't)\n    # a multigram is a word that consists of concatenating two or more words\n    # that are all mutually anagrams.\n    # the first of these words is called the root of the multigram\n    # for instance, the word bbabab is a multigram with the root bba because\n    # it consists of anagrams bba and bab.\n    # two words are mutually anagrams if one of them can be obtained from\n    # the other by changing the letter order.\n    # if there are multiple possible roots of the multigram, output the shortest\n    word_len = len(word)\n    if word_len == 1:\n        return word\n    if word_len == 2:\n        return -1\n    for i in range(1, word_len//2 + 1):\n        # check if the first i characters are a root\n        # check if the rest of the word is a root\n        if Counter(word[:i]) == Counter(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == \"__main__\":\n    word = input()\n    print(is_multigram(word))\n", "\n# https://www.codechef.com/JUNE20B/problems/XYSTR\n# Solution\n\ndef is_multigram(word):\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return True\n    return False\n\ndef get_multigram_root(word):\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == '__main__':\n    t = int(input())\n    for i in range(t):\n        word = input()\n        if is_multigram(word):\n            print(get_multigram_root(word))\n        else:\n            print(-1)\n", "\nimport sys\n\ndef main():\n    word = sys.stdin.readline().strip()\n    length = len(word)\n    for i in range(1, length // 2 + 1):\n        if word[:i] == word[i:2 * i]:\n            print(word[:i])\n            return\n    print(-1)\n\nmain()\n", "\n\nfrom collections import Counter\n\ndef is_multigram(word):\n    # check if the word is a multigram (return the root if it is, -1 if it isn't)\n    # a multigram is a word that consists of concatenating two or more words\n    # that are all mutually anagrams\n    # the first of these words is called the root of the multigram\n    # for instance, the word bbabab is a multigram with the root bba because\n    # it consists of anagrams bba and bab\n    # two words are mutually anagrams if one of them can be obtained from\n    # the other by changing the letter order\n    # if there are multiple possible roots of the multigram, output the shortest\n    word_len = len(word)\n    if word_len == 1:\n        return word\n    if word_len == 2:\n        return -1\n    for i in range(1, word_len//2 + 1):\n        # check if the first i characters are a root\n        # check if the rest of the word is a root\n        if Counter(word[:i]) == Counter(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == \"__main__\":\n    word = input().strip()\n    print(is_multigram(word))\n", "\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\n\nword = raw_input()\n\nfor i in range(len(word)):\n    for j in range(i, len(word)):\n        if is_anagram(word[:i], word[i:j + 1]):\n            print(word[:i])\n            exit()\n\nprint(-1)\n", "\n\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\n\nword = raw_input()\n\nfor i in range(len(word)):\n    for j in range(i, len(word)):\n        if is_anagram(word[:i], word[i:j+1]):\n            print word[:i]\n            exit(0)\n\nprint -1\n", "\n\n#-----SOLUTION-----\n\n#SOLUTION 1\n\n#SOLUTION 2\n\n#SOLUTION 3\n\n#SOLUTION 4\n\n#SOLUTION 5\n\n#SOLUTION 6\n\n#SOLUTION 7\n\n#SOLUTION 8\n\n#SOLUTION 9\n\n#SOLUTION 10\n", "\nimport sys\n\ndef multigram(s):\n    half = len(s) // 2\n    first = s[:half]\n    second = s[half:]\n    first_letters = {}\n    second_letters = {}\n    for letter in first:\n        if letter in first_letters:\n            first_letters[letter] += 1\n        else:\n            first_letters[letter] = 1\n    for letter in second:\n        if letter in second_letters:\n            second_letters[letter] += 1\n        else:\n            second_letters[letter] = 1\n    for key in first_letters:\n        if key not in second_letters:\n            return -1\n        elif first_letters[key] != second_letters[key]:\n            return -1\n    return first\n\ndef main():\n    s = sys.stdin.readline().strip()\n    print(multigram(s))\n\nif __name__ == \"__main__\":\n    main()\n", "# Solution\n\ndef is_multigram(word):\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return True\n    return False\n\ndef get_multigram_root(word):\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == '__main__':\n    word = input()\n    if is_multigram(word):\n        print(get_multigram_root(word))\n    else:\n        print(-1)\n", "\n\nfrom collections import Counter\n\ndef is_multigram(word):\n    \"\"\"\n    check if the word is a multigram (return the root if it is, -1 if it isn't)\n    a multigram is a word that consists of concatenating two or more words\n    that are all mutually anagrams\n    the first of these words is called the root of the multigram\n    for instance, the word bbabab is a multigram with the root bba because\n    it consists of anagrams bba and bab\n    two words are mutually anagrams if one of them can be obtained from\n    the other by changing the letter order\n    if there are multiple possible roots of the multigram, output the shortest\n    \"\"\"\n    word_len = len(word)\n    if word_len == 1:\n        return word\n    if word_len == 2:\n        return -1\n    for i in range(1, word_len//2 + 1):\n        # check if the first i characters are a root\n        # check if the rest of the word is a root\n        if Counter(word[:i]) == Counter(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == \"__main__\":\n    word = input()\n    print(is_multigram(word))\n", "\n\n#-----Solution-----\n\n#SOLUTION 1:\n\n#SOLUTION 2:\n\n#SOLUTION 3:\n\n#SOLUTION 4:\n\n#SOLUTION 5:\n\n#SOLUTION 6:\n\n#SOLUTION 7:\n\n#SOLUTION 8:\n\n#SOLUTION 9:\n\n#SOLUTION 10:\n", "\n\nfrom collections import Counter\n\ndef is_multigram(word):\n    # check if the word is a multigram (return the root if it is, -1 if it isn't)\n    # a multigram is a word that consists of concatenating two or more words\n    # that are all mutually anagrams\n    # the first of these words is called the root of the multigram\n    # for instance, the word bbabab is a multigram with the root bba because\n    # it consists of anagrams bba and bab\n    # two words are mutually anagrams if one of them can be obtained from\n    # the other by changing the letter order\n    # if there are multiple possible roots of the multigram, output the shortest\n    word_len = len(word)\n    if word_len == 1:\n        return -1\n    if word_len == 2:\n        return -1\n    for i in range(1, word_len//2 + 1):\n        # check if the first i characters are a root\n        # check if the rest of the word is a root\n        if Counter(word[:i]) == Counter(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == \"__main__\":\n    word = input()\n    print(is_multigram(word))\n", "#!/usr/bin/env python3\n\n\nword = input(\"Enter a word: \")\n\n# find the number of unique letters in the word\nunique_letters = set(word)\n\n# if there is only one letter, we are done\nif len(unique_letters) == 1:\n    print(word[0])\n    exit()\n\n# otherwise, we need to find the smallest length of a substring that is repeated\n# at least twice in the word\n\n# we will try all possible lengths of substrings\n# we start with the smallest length, which is 2\n\nlength = 2\n\n# we will keep searching for the substring until we find one that is repeated\n# at least twice\n\nwhile True:\n\n    # we will need to keep track of the substrings we have seen\n    # we will do this by storing a dictionary\n    # the dictionary will have the substring as the key,\n    # and the number of times it appears in the word as the value\n    # for example, if we have the word abcabc, and we are currently\n    # looking for substrings of length 2, we will have the dictionary\n    # {'ab': 2, 'bc': 2, 'ca': 1}\n\n    # we start off with an empty dictionary\n    substrings = {}\n\n    # now, we will go through all substrings of length length\n    # we will start at the beginning of the word\n    # we will stop when we get to the end of the word\n    # we will increment by one each time\n    for start in range(len(word) - length + 1):\n\n        # we get the substring\n        substring = word[start:start + length]\n\n        # if the substring is not in the dictionary, we add it\n        if substring not in substrings:\n            substrings[substring] = 0\n\n        # we increment the number of times the substring appears in the word\n        substrings[substring] += 1\n\n    # we will check if any substrings appear at least twice\n    for substring in substrings:\n        if substrings[substring] >= 2:\n            # if so, we are done\n            print(substring)\n            exit()\n\n    # if we didn't find any substrings that appear at least twice,\n    # we increase the length of the substring and try again\n    length += 1\n", "\n\ndef main():\n    s = input()\n    if len(s) % 2 == 1:\n        print(-1)\n    else:\n        half = len(s) // 2\n        first = s[:half]\n        second = s[half:]\n        first_letters = {}\n        second_letters = {}\n        for letter in first:\n            if letter in first_letters:\n                first_letters[letter] += 1\n            else:\n                first_letters[letter] = 1\n        for letter in second:\n            if letter in second_letters:\n                second_letters[letter] += 1\n            else:\n                second_letters[letter] = 1\n        for key in first_letters:\n            if key not in second_letters:\n                print(-1)\n            elif first_letters[key] != second_letters[key]:\n                print(-1)\n        print(first)\n\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef multigram(s):\n    if len(s) % 2 == 1:\n        return -1\n    else:\n        half = len(s) // 2\n        first = s[:half]\n        second = s[half:]\n        first_letters = {}\n        second_letters = {}\n        for letter in first:\n            if letter in first_letters:\n                first_letters[letter] += 1\n            else:\n                first_letters[letter] = 1\n        for letter in second:\n            if letter in second_letters:\n                second_letters[letter] += 1\n            else:\n                second_letters[letter] = 1\n        for key in first_letters:\n            if key not in second_letters:\n                return -1\n            elif first_letters[key] != second_letters[key]:\n                return -1\n        return first\n\ndef main():\n    s = sys.stdin.readline().strip()\n    print(multigram(s))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\n\nword = raw_input()\n\nfor i in range(len(word)):\n    for j in range(i, len(word)):\n        if is_anagram(word[:i], word[i:j+1]):\n            print word[:i]\n            exit()\n\nprint -1\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    word = sys.stdin.readline().strip()\n    length = len(word)\n    for i in range(1, length//2 + 1):\n        if word[:i] == word[i:2*i]:\n            print(word[:i])\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nword = input(\"Enter a word: \")\n\n# find the number of unique letters in the word\nunique_letters = set(word)\n\n# if there is only one letter, we are done\nif len(unique_letters) == 1:\n    print(\"The smallest repeated substring is: \" + word[0])\n    exit()\n\n# otherwise, we need to find the smallest length of a substring that is repeated\n# at least twice in the word\n\n# we will try all possible lengths of substrings\n# we start with the smallest length, which is 2\n\nlength = 2\n\n# we will keep searching for the substring until we find one that is repeated\n# at least twice\n\nwhile True:\n\n    # we will need to keep track of the substrings we have seen\n    # we will do this by storing a dictionary\n    # the dictionary will have the substring as the key,\n    # and the number of times it appears in the word as the value\n    # for example, if we have the word abcabc, and we are currently\n    # looking for substrings of length 2, we will have the dictionary\n    # {'ab': 2, 'bc': 2, 'ca': 1}\n\n    # we start off with an empty dictionary\n    substrings = {}\n\n    # now, we will go through all substrings of length length\n    # we will start at the beginning of the word\n    # we will stop when we get to the end of the word\n    # we will increment by one each time\n    for start in range(len(word) - length + 1):\n\n        # we get the substring\n        substring = word[start:start + length]\n\n        # if the substring is not in the dictionary, we add it\n        if substring not in substrings:\n            substrings[substring] = 0\n\n        # we increment the number of times the substring appears in the word\n        substrings[substring] += 1\n\n    # we will check if any substrings appear at least twice\n    for substring in substrings:\n        if substrings[substring] >= 2:\n            # if so, we are done\n            print(\"The smallest repeated substring is: \" + substring)\n            exit()\n\n    # if we didn't find any substrings that appear at least twice,\n    # we increase the length of the substring and try again\n    length += 1\n", "\n#\n# import sys\n#\n# def main():\n#     word = sys.stdin.readline().strip()\n#     length = len(word)\n#     for i in range(1, length//2 + 1):\n#         if word[:i] == word[i:2*i]:\n#             print(word[:i])\n#             return\n#     print(-1)\n#\n# main()\n", "#-----Solution-----\n#SOLUTION 1\n#SOLUTION 2\n#SOLUTION 3\n#SOLUTION 4\n#SOLUTION 5\n#SOLUTION 6\n#SOLUTION 7\n#SOLUTION 8\n#SOLUTION 9\n#SOLUTION 10\n\n", "\n\nimport sys\n\ndef multigram(s):\n    if len(s) % 2 == 1:\n        return -1\n    else:\n        half = len(s) // 2\n        first = s[:half]\n        second = s[half:]\n        first_letters = {}\n        second_letters = {}\n        for letter in first:\n            if letter in first_letters:\n                first_letters[letter] += 1\n            else:\n                first_letters[letter] = 1\n        for letter in second:\n            if letter in second_letters:\n                second_letters[letter] += 1\n            else:\n                second_letters[letter] = 1\n        for key in first_letters:\n            if key not in second_letters:\n                return -1\n            elif first_letters[key] != second_letters[key]:\n                return -1\n        return first\n\ndef main():\n    s = sys.stdin.readline().strip() # read in from stdin\n    print(multigram(s))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\n\nword = input()\n\nfor i in range(len(word)):\n    for j in range(i, len(word)):\n        if is_anagram(word[:i], word[i:j+1]):\n            print(word[:i])\n            exit()\n\nprint(-1)\n", "\nword = input()\n\n# find the number of unique letters in the word\nunique_letters = set(word)\n# if there is only one letter, we are done\nif len(unique_letters) == 1:\n    print(word[0])\n    exit()\n# otherwise, we need to find the smallest length of a substring that is repeated\n# at least twice in the word\n# we will try all possible lengths of substrings\n# we start with the smallest length, which is 2\nlength = 2\n# we will keep searching for the substring until we find one that is repeated\n# at least twice\nwhile True:\n\n    # we will need to keep track of the substrings we have seen\n    # we will do this by storing a dictionary\n    # the dictionary will have the substring as the key,\n    # and the number of times it appears in the word as the value\n    # for example, if we have the word abcabc, and we are currently\n    # looking for substrings of length 2, we will have the dictionary\n    # {'ab': 2, 'bc': 2, 'ca': 1}\n    # we start off with an empty dictionary\n    substrings = {}\n    # now, we will go through all substrings of length length\n    # we will start at the beginning of the word\n    # we will stop when we get to the end of the word\n    # we will increment by one each time\n    for start in range(len(word) - length + 1):\n        # we get the substring\n        substring = word[start:start + length]\n        # if the substring is not in the dictionary, we add it\n        if substring not in substrings:\n            substrings[substring] = 0\n        # we increment the number of times the substring appears in the word\n        substrings[substring] += 1\n    # we will check if any substrings appear at least twice\n    for substring in substrings:\n        if substrings[substring] >= 2:\n            # if so, we are done\n            print(substring)\n            exit()\n\n    # if we didn't find any substrings that appear at least twice,\n    # we increase the length of the substring and try again\n    length += 1\n", "\n\nword = input()\n\n# find the number of unique characters in the word\nunique_characters = set(word)\n\n# if there is only one character, we are done\nif len(unique_characters) == 1:\n    print(word[0])\n    exit()\n\n# otherwise, we need to find the smallest length of a substring that is repeated\n# at least twice in the word\n\n# we will try all possible lengths of substrings,\n# we start with the smallest length, which is 2\n\nlength = 2\n\n# we will keep searching for the substring until we find one that is repeated at least twice\n\nwhile True:\n\n    # we will need to keep track of the substrings we have seen, we will do this by storing a dictionary\n    # the dictionary will have the substring as the key, and the number of times it appears in the word as the value\n    # for example, if we have the word abcabc, and we are currently looking for substrings of length 2,\n    # we will have the dictionary {'ab': 2, 'bc': 2, 'ca': 1}\n\n    # we start off with an empty dictionary\n    substrings = {}\n\n    # now, we will go through all substrings of length length, we will start at the beginning of the word,\n    # we will stop when we get to the end of the word, we will increment by one each time\n    for start in range(len(word) - length + 1):\n\n        # we get the substring\n        substring = word[start:start + length]\n\n        # if the substring is not in the dictionary, we add it\n        if substring not in substrings:\n            substrings[substring] = 0\n\n        # we increment the number of times the substring appears in the word\n        substrings[substring] += 1\n\n    # we will check if any substrings appear at least twice, if so, we are done\n    for substring in substrings:\n        if substrings[substring] >= 2:\n            print(substring)\n            exit()\n\n    # if we didn't find any substrings that appear at least twice, we increase the length of the substring and try again\n    length += 1\n", "\n\nword = input(\"Enter a word: \")\n\n# find the number of unique letters in the word\nunique_letters = set(word)\n\n# if there is only one letter, we are done\nif len(unique_letters) == 1:\n    print(word[0])\n    quit()\n\n# otherwise, we need to find the smallest length of a substring that is repeated\n# at least twice in the word\n\n# we will try all possible lengths of substrings\n# we start with the smallest length, which is 2\n\nlength = 2\n\n# we will keep searching for the substring until we find one that is repeated\n# at least twice\n\nwhile True:\n\n    # we will need to keep track of the substrings we have seen\n    # we will do this by storing a dictionary\n    # the dictionary will have the substring as the key,\n    # and the number of times it appears in the word as the value\n    # for example, if we have the word abcabc, and we are currently\n    # looking for substrings of length 2, we will have the dictionary\n    # {'ab': 2, 'bc': 2, 'ca': 1}\n\n    # we start off with an empty dictionary\n    substrings = {}\n\n    # now, we will go through all substrings of length length\n    # we will start at the beginning of the word\n    # we will stop when we get to the end of the word\n    # we will increment by one each time\n    for start in range(len(word) - length + 1):\n\n        # we get the substring\n        substring = word[start:start + length]\n\n        # if the substring is not in the dictionary, we add it\n        if substring not in substrings:\n            substrings[substring] = 0\n\n        # we increment the number of times the substring appears in the word\n        substrings[substring] += 1\n\n    # we will check if any substrings appear at least twice\n    for substring in substrings:\n        if substrings[substring] >= 2:\n            # if so, we are done\n            print(substring)\n            quit()\n\n    # if we didn't find any substrings that appear at least twice,\n    # we increase the length of the substring and try again\n    length += 1\n", "\n\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\n\nword = input()\n\nfor i in range(1, len(word)):\n    if is_anagram(word[:i], word[i:]):\n        print(word[:i])\n        exit()\n\nprint -1\n", "\n\nfrom collections import Counter\n\ndef is_multigram(word):\n    # Check if the word is a multigram (return the root if it is, -1 if it isn't).\n    # A multigram is a word that consists of concatenating two or more words\n    # that are all mutually anagrams.\n    # The first of these words is called the root of the multigram.\n    # For instance, the word bbabab is a multigram with the root bba because\n    # it consists of anagrams bba and bab.\n    # Two words are mutually anagrams if one of them can be obtained from\n    # the other by changing the letter order.\n    # If there are multiple possible roots of the multigram, output the shortest.\n    word_len = len(word)\n    if word_len == 1:\n        return word\n    if word_len == 2:\n        return -1\n    for i in range(1, word_len//2 + 1):\n        # Check if the first i characters are a root.\n        # Check if the rest of the word is a root.\n        if Counter(word[:i]) == Counter(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == \"__main__\":\n    word = input()\n    print(is_multigram(word))\n", "\nimport collections\nimport sys\n\ndef multigram(s):\n    if len(s) % 2 == 1:\n        return -1\n    else:\n        half = len(s) // 2\n        first = s[:half]\n        second = s[half:]\n        first_letters = collections.defaultdict(int)\n        second_letters = collections.defaultdict(int)\n        for letter in first:\n            if letter in first_letters:\n                first_letters[letter] += 1\n        for letter in second:\n            if letter in second_letters:\n                second_letters[letter] += 1\n        for key in first_letters:\n            if key not in second_letters:\n                return -1\n            elif first_letters[key] != second_letters[key]:\n                return -1\n        return first\n\ndef main():\n    s = sys.stdin.readline().strip()\n    print(multigram(s))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\n\nword = input()\n\nfor i in range(len(word)):\n    for j in range(i, len(word)):\n        if is_anagram(word[:i], word[i:j+1]):\n            print(word[:i])\n            exit()\n\nprint(-1)\n", "\n\nimport sys\n\ndef main():\n    word = sys.stdin.readline().strip()\n    length = len(word)\n    if length % 2 == 0:\n        for i in range(1, length//2 + 1):\n            if word[:i] == word[i:2*i]:\n                print(word[:i])\n                return\n    print(-1)\n\nmain()\n", "\n\nimport sys\n\ndef multigram(s): \n    if len(s) % 2 == 1:\n        return -1\n    else:\n        half = len(s) // 2\n        first = s[:half]\n        second = s[half:]\n        first_letters = {}\n        second_letters = {}\n        for letter in first:\n            if letter in first_letters:\n                first_letters[letter] += 1\n            else:\n                first_letters[letter] = 1\n        for letter in second:\n            if letter in second_letters:\n                second_letters[letter] += 1\n            else:\n                second_letters[letter] = 1\n        for key in first_letters:\n            if key not in second_letters:\n                return -1\n            elif first_letters[key] != second_letters[key]:\n                return -1\n        return first\n\ndef main():\n    s = sys.stdin.readline().strip()\n    print(multigram(s))\n\nif __name__ == \"__main__\":\n    main()\n", "# Solution\n\ndef is_multigram(word):\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return True\n    return False\ndef get_multigram_root(word):\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == '__main__':\n    word = input()\n    if is_multigram(word):\n        print(get_multigram_root(word))\n    else:\n        print(-1)\n", "\n# Solution\n\ndef is_multigram(word):\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return True\n    return False\n\ndef get_multigram_root(word):\n    for i in range(1, len(word)):\n        if sorted(word[:i]) == sorted(word[i:]):\n            return word[:i]\n    return -1\n\nif __name__ == '__main__':\n    word = input()\n    if is_multigram(word):\n        print(get_multigram_root(word))\n    else:\n        print(-1)\n", "\n\nfrom collections import Counter\n\ndef is_multigram(word):\n    # check if the word is a multigram (return the root if it is, -1 if it isn't)\n    # a multigram is a word that consists of concatenating two or more words\n    # that are all mutually anagrams\n    # the first of these words is called the root of the multigram\n    # for instance, the word bbabab is a multigram with the root bba because\n    # it consists of anagrams bba and bab\n    # two words are mutually anagrams if one of them can be obtained from\n    # the other by changing the letter order\n    # if there are multiple possible roots of the multigram, output the shortest\n    word_len = len(word)\n    if word_len == 1:\n        return word\n    if word_len == 2:\n        return -1\n    for i in range(1, word_len//2 + 1):\n        # check if the first i characters are a root\n        # check if the rest of the word is a root\n        if Counter(word[:i]) == Counter(word[i:word_len-i]):\n            return word[:i]\n    return -1\n\nif __name__ == \"__main__\":\n    word = input()\n    print(is_multigram(word))\n", "\na = 1\nb = 2\nc = a + b\n"]