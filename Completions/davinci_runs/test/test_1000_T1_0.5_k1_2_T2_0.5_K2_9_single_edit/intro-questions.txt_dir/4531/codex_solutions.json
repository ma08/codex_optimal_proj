["\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))"]