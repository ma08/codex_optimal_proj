["\n\nimport sys\nimport math\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(10 ** 7)\n\nn = int(input())\n\nadj = defaultdict(list)\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n            subtree_sum_list += [subtree_sum_list[-1] + a[v] for _ in range(subtree_size_v)]\n    return subtree_size, subtree_sum, subtree_sum_list\n\n\ndef solve(u, p):\n    subtree_size, subtree_sum, subtree_sum_list = dfs(u, p)\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v, subtree_sum_list_v = dfs(v, u)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_sum_list = [a[u]]\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v, subtree_sum_list_v = dfs(v, u)\n            subtree_sum_list += subtree_sum_list_v\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\nprint(solve(0, -1))\n", "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n+1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree, root):\n    res = 0\n    children = tree.adj[root]\n    for child in children:\n        res += solve(n, a, tree, child) + a[child]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree, 1))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n", "\nfrom collections import defaultdict\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n", "\n\nimport sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def bfs(self, root, parent):\n        children = self.adj[root]\n        queue = deque()\n        res = 0\n        for c in children:\n            if c != parent:\n                queue.append(c)\n        while queue:\n            node = queue.popleft()\n            res += self.bfs(node, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.bfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self):\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree()\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\n    subtree_size_v = 0\n    subtree_sum_v = 0\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n", "\nimport sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef bfs(graph, start):\n    visited, queue = set(), deque([start])\n    while queue:\n        vertex = queue.popleft()\n        for neighbour in graph[vertex]:\n            if neighbour not in visited:\n                visited.add(neighbour)\n                queue.append(neighbour)\n    return visited\n\n\nclass Tree:\n    def __init__(self, n):\n        self.visited = [False] * n\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree: Tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree_ = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree_.add_edge(u, v)\n    print(solve(n, a, tree_))\n\n\nif __name__ == \"__main__\":\n    main()\n", "import math\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n\n    cnt = 0\n    for i in range(n):\n        if a[i] % 2 == 0:\n            cnt += 1\n\n    if cnt % 2 == 0:\n        print(n - cnt)\n    else:\n        print(n - cnt + 1)\n\n\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n \nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n    print(subtree_size,subtree_sum)\n\n    print(subtree_size,subtree_sum)\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    print(max_cost)\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\n\nprint(solve(0, -1))\n"]