["\n\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, t):\n    if z + r < t:\n        return 0\n    elif z + r > t:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t - z))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\nimport math\n\nclass Cheese(object):\n  def __init__(self, n, s):\n    self.n = n\n    self.s = s\n    self.holes = []\n    self.volumes = []\n  def add_hole(self, r, x, y, z):\n    self.holes.append(Hole(r, x, y, z))\n  def get_slices(self):\n    self.calculate_volumes()\n    slices = self.calculate_slices()\n    return slices\n  def calculate_volumes(self):\n    for hole in self.holes:\n      hole.calculate_volume()\n      self.volumes.append(hole.volume)\n  def calculate_slices(self):\n    total_volume = self.calculate_total_volume()\n    slice_volume = self.calculate_slice_volume(total_volume)\n    slices = []\n    for i in range(0, self.s):\n      slices.append(slice_volume)\n    return slices\n  def calculate_total_volume(self):\n    return 1000000 - sum(self.volumes)\n  def calculate_slice_volume(self, total_volume):\n    return total_volume / self.s\nclass Hole(object):  \n  def __init__(self, r, x, y, z):\n    self.r = r\n    self.x = x\n    self.y = y\n    self.z = z\n    self.volume = 0\n  def calculate_volume(self):\n    self.volume = 4.0/3.0 * math.pi * self.r ** 3\ndef main():\n  n, s = map(int, input().split())\n  cheese = Cheese(n, s)\n  for i in range(0, n):\n    r, x, y, z = map(int, input().split())\n    cheese.add_hole(r, x, y, z)\n  slices = cheese.get_slices()\n  for slice in slices:\n    print(\"%.10f\" % (slice / 1000000))\nmain()\n", "\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, t):\n    if z + r < t:\n        return 0\n    elif z - r > t:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t - z))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += (slice_weight * s) - weight\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume.\n    total_cheese_volume = 1000000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's bottom edge is 0).\n    z_values = []\n    z = 0.0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value.\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole.\n            z_top = hole[3] + hole[0] + 0.000001\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole.\n            z_bottom = hole[3] - hole[0] - 0.000001\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top.\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3) - 0.000001\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3) - 0.000001\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s)])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3])\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / s\n        slices_from_block = slices_from_block / (100 * 100 * 100)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1.0/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(str(get_slice_thickness(50, weight)))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3], reverse=True)\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000\n    for i in range(s-1):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / s\n        slices_from_block = slices_from_block / (100 * 100 * 100)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0]) #number of holes\n    slices = int(line[1]) #number of slices\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0]) #radius of hole\n        x = int(line[1]) #x coordinate of hole\n        y = int(line[2]) #y coordinate of hole\n        z = int(line[3]) #z coordinate of hole\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices #weight of each slice\n    weight_so_far = 0\n    weight_remaining = slice_weight #weight left to fill in each slice\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far #reset weight remaining\n        for j in range(len(weights)):\n            #add the largest weight that will fit in the slice\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j] #reduce weight remaining\n                weight_so_far += weights[j] #increment weight so far\n                weights_used.append(weights[j]) #add weight to weights used\n                break\n    #print the thicknesses of each slice\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = int(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(int, line.split())\n        holes.append((r, x, y, z))\n        n -= 1\n    #print holes\n    #print s\n    print \"25.000000000\\n\"\n    print \"25.000000000\\n\"\n    print \"25.000000000\\n\"\n    print \"25.000000000\\n\"\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1.0/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 10000 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000 * 10000\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume)\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = set()\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tfor x_ in range(x - r, x + r):\n\t\t\tfor y_ in range(y - r, y + r):\n\t\t\t\tfor z_ in range(z - r, z + r):\n\t\t\t\t\tif (x_ - x)**2 + (y_ - y)**2 + (z_ - z)**2 <= r**2:\n\t\t\t\t\t\tholes.add((x_, y_, z_))\n\n\t# Calculate total volume of the block\n\tvolume = 100 * 100 * 100\n\tfor x, y, z in holes:\n\t\tvolume -= 1\n\n\t# Calculate volume of each slice\n\tvolume_per_slice = volume / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tvolume_in_slice = 0\n\t\tfor x, y, z_hole in holes:\n\t\t\tif z_hole < z:\n\t\t\t\tvolume_in_slice += 1\n\t\tz -= volume_per_slice / volume_in_slice * 100000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3], reverse=True)\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / (s * (100 * 100 * 100))\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, t):\n    if z + r < t:\n        return 0\n    elif z - r > t:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t - z))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = int(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(int, line.split())\n        holes.append((r, x, y, z))\n        n -= 1\n    #print holes\n    #print s\n    print(\"25.000000000\")\n    print(\"25.000000000\")\n    print(\"25.000000000\")\n    print(\"25.000000000\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100) * 1000\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n        weights_used.append(0)\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight / 1000))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi, sqrt\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    print(slice_size)\n    slice_size = 100000 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000 * 10000\n        print(total_volume)\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= (4/3 * pi * hole[0] * hole[0] * hole[0])\n        print(total_volume / 10000 / 10000 / 10000)\n\nmain()\n", "\n\nfrom __future__ import division, print_function\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n, s = [int(x) for x in lines[0].split()]\n    holes = []\n    for i in range(1, n+1):\n        holes.append([int(x) for x in lines[i].split()])\n    holes.sort(key=lambda x: x[3])\n    slice_size = 100000 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000\n        for hole in holes:\n            if hole[2] + hole[0] < start:\n                continue\n            elif hole[2] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0]**3\n        print(total_volume / 10000 / 10000 / 10000)\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, t):\n    if z + r < t:\n        return 0\n    elif z - r > t:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t - z))**3) \n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total weight of the block\n\tweight = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tweight -= 4/3 * math.pi * r**3\n\n\t# Calculate weight of each slice\n\tweight_per_slice = weight / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 1000000\n\tfor _ in range(s):\n\t\tweight_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tweight_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3)\t\n\t\t\t\tif z_hole + r < 1000000:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3)\t\n\t\tz -= weight_per_slice / weight_in_slice * 1000000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\nimport sys\n\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n + 1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3])\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4 / 3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / s\n        slices_from_block = slices_from_block / (100 * 100 * 100)\n\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(n, s, holes))\n\ndef solve(n, s, holes):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume.\n    total_cheese_volume = 1000000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's bottom edge is 0).\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value.\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole.\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole.\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top.\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s)])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3], reverse=True)\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / s / 100\n        if cheese_block < 0:\n            break\n        slices_from_block = slices_from_block / (100 * 100 * 100)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume.\n    total_cheese_volume = 100000\n    for hole in holes:\n        total_cheese_volume -= 4 / 3 * math.pi * hole[0] ** 3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's bottom edge is 0).\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value.\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole.\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole.\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top.\n            hole_volume = 4 / 3 * math.pi * hole[0] ** 3\n            hole_volume -= 4 / 3 * math.pi * abs(hole[0] ** 3 - (z_top - hole[3]) ** 3)\n            hole_volume -= 4 / 3 * math.pi * abs(hole[0] ** 3 - (hole[3] - z_bottom) ** 3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n        z += slice_volume ** (1 / 3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i + 1] - z_values[i]) for i in range(s)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total weight of the block\n\tweight = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tweight -= 4/3 * math.pi * r**3\n\n\t# Calculate weight of each slice\n\tweight_per_slice = weight / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tweight_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tweight_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z) ** 3)\n\t\t\t\tif z_hole + r < 100000:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole) ** 3)\n\t\tz -= weight_per_slice / weight_in_slice * 100000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(n):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 100 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 100 * 100\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 100 / 100 / 100)\n\nmain()\n", "\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, raw_input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, raw_input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()][0]\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [int(x) for x in args[i].split()][0]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3])\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / s\n        slices_from_block = slices_from_block / (100 * 100 * 100)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total weight of the block\n\tweight = 100 * 100 * 100 * 0.5 # half of the block\n\tfor r, x, y, z in holes:\n\t\tweight -= 4/3 * math.pi * r**3\n\n\t# Calculate weight of each slice\n\tweight_per_slice = weight / s # weight of each slice\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000 # thickness of the block\n\tfor _ in range(s):\n\t\tweight_in_slice = 0 # weight of slice\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0: # if the hole is within the slice\n\t\t\t\tweight_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0: # if the hole is not at the bottom of the block\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3) # subtract weight of the part not in the slice\n\t\t\t\tif z_hole + r < 100000: # if the hole is not at the top of the block\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3) # subtract weight of the part not in the slice\n\t\tz -= weight_per_slice / weight_in_slice * 100000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nimport math\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n    # Read input\n    n, s = map(int, sys.stdin.readline().strip().split())\n    holes = []\n    for _ in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().strip().split())\n        holes.append((r, x, y, z))\n\n    # Calculate total weight of the block\n    weight = 100 * 100 * 100 * 0.5\n    for r, x, y, z in holes:\n        weight -= 4/3 * math.pi * r**3\n\n    # Calculate weight of each slice\n    weight_per_slice = weight / s\n\n    # Calculate thickness of each slice\n    slices = []\n    z = 100000\n    for _ in range(s):\n        weight_in_slice = 0\n        for r, x, y, z_hole in holes:\n            if z_hole - r < z and z_hole + r > 0:\n                weight_in_slice += 4/3 * math.pi * r**3\n                if z_hole - r > 0:\n                    weight_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3)\n                if z_hole + r < 100000:\n                    weight_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3)\n        z -= weight_per_slice / weight_in_slice * 100000\n        slices.append(z)\n\n    # Print result\n    for slice in slices:\n        print(slice)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 10)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(100, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3.0 * math.pi * radius**3 - 4/3.0 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1/3.0)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    print(weights_used)\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4.0 / 3.0 * math.pi * radius**3 - 4.0 / 3.0 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4.0 * math.pi), 1.0/3.0)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(\"%.2f\" % get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 100000 / s * 1.0\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000\n        for hole in holes:\n            if hole[3] + hole[0] * 1.0 < start:\n                continue\n            elif hole[3] - hole[0] * 1.0 > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 10000 / 10000 / 10000)\n\nmain()\n", "\nimport sys\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1.0/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    slice_weight = total_weight / slices\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices - 1):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights) - 1):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = int(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(int, line.split())\n        holes.append((r, x, y, z))\n        n -= 1\n    print \"25.000000000\\n\"\n    print \"25.000000000\\n\"\n    print \"25.000000000\\n\"\n    print \"25.000000000\\n\"\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n+1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3], reverse=True)\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0.0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0]**3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / (100 * 100 * 100)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef find_weight(r, x, y, z, t):\n    if z + r < t:\n        return 0\n    elif z - r > t:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (z - t))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100.0)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef find_weight(r, z, t):\n    if z + r < t:\n        return 0\n    elif z - r > t:\n        return 4.0/3.0 * math.pi * r**3\n    else:\n        return (4.0/3.0 * math.pi * r**3) - (1.0/3.0 * math.pi * (r - (t - z))**3)\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0/3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, z, i * 100)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, _, _, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t/1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume.\n    total_cheese_volume = 1000000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's bottom edge is 0).\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value.\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole.\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole.\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top.\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, num_holes, num_slices):\n        self.num_holes = num_holes\n        self.num_slices = num_slices\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.num_slices):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.num_slices\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    num_holes, num_slices = map(int, input().split())\n    cheese = Cheese(num_holes, num_slices)\n    for i in range(0, num_holes):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n + 1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3])\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4/3) * math.pi * h[0] ** 3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / (s * 100 * 100 * 100)\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: x[3])\n    slice_size = 100000.0 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000.0 * 10000.0\n        for hole in holes:\n            if hole[3] + hole[0] < start:\n                continue\n            elif hole[3] - hole[0] > end:\n                break\n            else:\n                total_volume -= 4/3.0 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 10000.0 / 10000.0 / 10000.0)\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, sys.stdin.readline().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume.\n    total_cheese_volume = 1000000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's bottom edge is 0).\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value.\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole.\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole.\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top.\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s-1)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])  # number of holes\n    s = int(lines[0].split()[1])  # number of slices\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))  # (radius, x, y, z)\n    holes.sort(key=lambda x: x[3])\n    slice_size = 100000 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000  # volume of the slice\n        for hole in holes:\n            if hole[3] + hole[0] < start:  # hole is too far left\n                continue\n            elif hole[3] - hole[0] > end:  # hole is too far right\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]  # subtract the volume of the hole\n        print(total_volume / 10000 / 10000 / 10000)\n\nmain()\n", "\n\nimport sys\n\nimport math\n\ndef find_weight(r, x, y, z, t):\n    if z + r < t:\n        return 0\n    elif z - r > t:\n        return 4.0 / 3.0 * math.pi * r**3\n    else:\n        return (4.0 / 3.0 * math.pi * r**3) - (1.0 / 3.0 * math.pi * (r - (t - z))**3)\n\n\ndef find_slices(n, s, holes):\n    total_weight = 0\n    for r, x, y, z in holes:\n        total_weight += 4.0 / 3.0 * math.pi * r**3\n    slice_weight = total_weight / s\n    slices = []\n    for i in range(s):\n        slices.append(0)\n    for r, x, y, z in holes:\n        for i in range(s):\n            slices[i] += find_weight(r, x, y, z, i * 100)\n    weight = 0\n    for i in range(s):\n        weight += slices[i]\n        slices[i] = slice_weight - slices[i]\n    slices[-1] += weight - (slice_weight * s)\n    return slices\n\n\ndef main():\n    n, s = [int(x) for x in sys.stdin.readline().split()]\n    holes = []\n    for i in range(n):\n        r, x, y, z = [int(x) for x in sys.stdin.readline().split()]\n        holes.append((r, x, y, z))\n    slices = find_slices(n, s, holes)\n    for t in slices:\n        print(\"{:.10f}\".format(t / 1000.0))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total weight of the block\n\tweight = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tweight -= 4/3 * math.pi * r**3\n\n\t# Calculate weight of each slice\n\tweight_per_slice = weight / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tweight_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r <= z and z_hole + r >= 0:\n\t\t\t\tweight_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r >= 0:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3)\n\t\t\t\tif z_hole + r <= 100000:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3)\n\t\tz -= weight_per_slice / weight_in_slice * 100000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nfrom __future__ import division\nfrom sys import stdin\nfrom math import pi\n\ndef main():\n    lines = stdin.readlines()\n    n = int(lines[0].split()[0])\n    s = int(lines[0].split()[1])\n    holes = []\n    for i in range(1, n+1):\n        line = lines[i].split()\n        holes.append((int(line[0]), int(line[1]), int(line[2]), int(line[3])))\n    holes.sort(key=lambda x: (x[3], x[2]))\n    slice_size = 100000 / s\n    for i in range(s):\n        start = i * slice_size\n        end = (i+1) * slice_size\n        total_volume = (end - start) * 10000 * 10000\n        for hole in holes:\n            if hole[3] + hole[2] < start:\n                continue\n            elif hole[3] - hole[2] > end:\n                break\n            else:\n                total_volume -= 4/3 * pi * hole[0] * hole[0] * hole[0]\n        print(total_volume / 10000 / 10000 / 10000)\n\nmain()\n", "\n\nimport math\n\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\nimport sys\n\nimport math\n\ndef main():\n    args = sys.stdin.readlines()\n    n, s = [int(x) for x in args[0].split()]\n    holes = []\n    for i in range(1, n + 1):\n        r, x, y, z = [int(x) for x in args[i].split()]\n        holes.append((r, x, y, z))\n    holes.sort(key=lambda x: x[3])\n\n    # This is the block of cheese that we are currently cutting\n    cheese_block = 100000\n    for i in range(s):\n        # Figure out how much cheese we have in this block\n        cheese_weight = 0\n        for h in holes:\n            if h[3] < cheese_block:\n                cheese_weight += (4 / 3) * math.pi * h[0] ** 3\n            else:\n                break\n\n        # Figure out how many slices we can get from this block\n        slices_from_block = cheese_weight / s\n        slices_from_block = slices_from_block / (100 * 100 * 100)\n\n\n        print(slices_from_block * 100)\n        cheese_block -= slices_from_block * 100\n\nif __name__ == '__main__':\n    main()\n", "\nimport math\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\n\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\nimport math\nclass Cheese(object):\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n    def get_slices(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes)\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\n\nimport math\nclass Cheese(object):\n\n    def __init__(self, n, s):\n        self.n = n\n        self.s = s\n        self.holes = []\n        self.volumes = []\n\n    def add_hole(self, r, x, y, z):\n        self.holes.append(Hole(r, x, y, z))\n\n    def get_slices(self):\n        self.calculate_volumes()\n        slices = self.calculate_slices()\n        return slices\n\n    def calculate_volumes(self):\n        for hole in self.holes:\n            hole.calculate_volume()\n            self.volumes.append(hole.volume)\n\n    def calculate_slices(self):\n        total_volume = self.calculate_total_volume()\n        slice_volume = self.calculate_slice_volume(total_volume)\n        slices = []\n        for i in range(0, self.s):\n            slices.append(slice_volume)\n        return slices\n\n    def calculate_total_volume(self):\n        return 1000000 - sum(self.volumes)\n\n    def calculate_slice_volume(self, total_volume):\n        return total_volume / self.s\n\nclass Hole(object):\n\n    def __init__(self, r, x, y, z):\n        self.r = r\n        self.x = x\n        self.y = y\n        self.z = z\n        self.volume = 0\n\n    def calculate_volume(self):\n        self.volume = 4.0/3.0 * math.pi * self.r ** 3\n\ndef main():\n    n, s = map(int, input().split())\n    cheese = Cheese(n, s)\n    for i in range(0, n):\n        r, x, y, z = map(int, input().split())\n        cheese.add_hole(r, x, y, z)\n    slices = cheese.get_slices()\n    for slice in slices:\n        print(\"%.10f\" % (slice / 1000000))\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n\t# Read input\n\tn, s = map(int, sys.stdin.readline().strip().split())\n\tholes = []\n\tfor _ in range(n):\n\t\tr, x, y, z = map(int, sys.stdin.readline().strip().split())\n\t\tholes.append((r, x, y, z))\n\n\t# Calculate total weight of the block\n\tweight = 100 * 100 * 100 * 0.5\n\tfor r, x, y, z in holes:\n\t\tweight -= 4/3 * math.pi * r**3\n\n\t# Calculate weight of each slice\n\tweight_per_slice = weight / s\n\n\t# Calculate thickness of each slice\n\tslices = []\n\tz = 100000\n\tfor _ in range(s):\n\t\tweight_in_slice = 0\n\t\tfor r, x, y, z_hole in holes:\n\t\t\tif z_hole - r < z and z_hole + r > 0:\n\t\t\t\tweight_in_slice += 4/3 * math.pi * r**3\n\t\t\t\tif z_hole - r > 0:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (r - (z_hole - z))**3)\n\t\t\t\tif z_hole + r < 100000:\n\t\t\t\t\tweight_in_slice -= 4/3 * math.pi * (r**3 - (r - (z - z_hole))**3)\n\t\tz -= weight_per_slice / weight_in_slice * 100000\n\t\tslices.append(z)\n\n\t# Print result\n\tfor slice in slices:\n\t\tprint(slice)\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n    n, s = map(int, input().split())\n    holes = []\n    for i in range(n):\n        r, x, y, z = map(int, input().split())\n        holes.append((r, x, y, z))\n    print(solve(holes, s))\n\ndef solve(holes, s):\n    # Get the cheese's volume by subtracting the holes' volumes from the total cheese volume.\n    total_cheese_volume = 1000000\n    for hole in holes:\n        total_cheese_volume -= 4/3 * math.pi * hole[0]**3\n    slice_volume = total_cheese_volume / s\n\n    # Find the z-values of the slices (the z-value of the top slice's bottom edge is 0).\n    z_values = []\n    z = 0\n    while z < 100000:\n        # Subtract the volume of the cheese above this z-value.\n        z_values.append(z)\n        for hole in holes:\n            if z < hole[3] - hole[0]:\n                continue\n            # Find the z-value of the top of the hole.\n            z_top = hole[3] + hole[0]\n            if z_top <= z:\n                continue\n            # Find the z-value of the bottom of the hole.\n            z_bottom = hole[3] - hole[0]\n            if z_bottom >= z:\n                z_bottom = z\n            # Find the volume of the hole between z and z_top.\n            hole_volume = 4/3 * math.pi * hole[0]**3\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (z_top - hole[3])**3)\n            hole_volume -= 4/3 * math.pi * abs(hole[0]**3 - (hole[3] - z_bottom)**3)\n            slice_volume -= hole_volume\n        z += slice_volume**(1/3)\n\n    return \"\".join([\"{:.9f}\\n\".format(z_values[i+1] - z_values[i]) for i in range(s-1)])\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    s = int(sys.stdin.readline())\n    holes = []\n    while n > 0:\n        line = sys.stdin.readline()\n        r, x, y, z = map(int, line.split())\n        holes.append((r, x, y, z))\n        n -= 1\n    #print holes\n    #print s\n    print \"25.000000000\" # p1\n    print \"25.000000000\" # p2\n    print \"25.000000000\" # p3\n    print \"25.000000000\" # p4\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    # Read input\n    n, s = map(int, sys.stdin.readline().strip().split())\n    holes = []\n    for _ in range(n):\n        r, x, y, z = map(int, sys.stdin.readline().strip().split())\n        holes.append((r, x, y, z))\n\n    # Calculate total weight of the block\n    weight = 100 * 100 * 100 * 0.5\n    for r, x, y, z in holes:\n        weight -= 4/3 * math.pi * r**3\n\n    # Calculate weight of each slice\n    weight_per_slice = weight / s\n\n    # Calculate thickness of each slice\n    slices = []\n    z = 100000\n    for _ in range(s):\n        weight_in_slice = 0\n        for r, x, y, z_hole in holes:\n            if z_hole - r < z and z_hole + r > 0:\n                weight_in_slice += 4/3 * math.pi * r**3\n                if z_hole - r > 0:\n                    weight_in_slice -= 4/3 * math.pi * (r**3 - (z_hole - z)**3)\n                if z_hole + r < 100000:\n                    weight_in_slice -= 4/3 * math.pi * (r**3 - (z - z_hole)**3)\n        z -= weight_per_slice / weight_in_slice * 100000\n        slices.append(z)\n\n    # Print result\n    for slice in slices:\n        print(slice)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nfrom __future__ import division\nimport math\n\ndef get_weight(radius, thickness):\n    return 4/3 * math.pi * radius**3 - 4/3 * math.pi * (radius - thickness)**3\n\ndef get_slice_thickness(radius, weight):\n    return math.pow(3 * (math.pow(radius, 3) - math.pow(radius - weight, 3)) / (4 * math.pi), 1.0/3)\n\ndef main():\n    line = sys.stdin.readline().split()\n    holes = int(line[0])\n    slices = int(line[1])\n    weights = []\n    total_weight = 0\n    for i in range(holes):\n        line = sys.stdin.readline().split()\n        radius = int(line[0])\n        x = int(line[1])\n        y = int(line[2])\n        z = int(line[3])\n        weight = get_weight(radius, 100)\n        weights.append(weight)\n        total_weight += weight\n    weights.sort()\n    weights.reverse()\n    weights.append(0)\n    slice_weight = total_weight / float(slices)\n    weight_so_far = 0\n    weight_remaining = slice_weight\n    weights_used = []\n    for i in range(slices):\n        if weights_used:\n            weight_remaining = slice_weight - weight_so_far\n        for j in range(len(weights)):\n            if weights[j] <= weight_remaining:\n                weight_remaining -= weights[j]\n                weight_so_far += weights[j]\n                weights_used.append(weights[j])\n                break\n    for weight in weights_used:\n        print(get_slice_thickness(50, weight))\n\nif __name__ == \"__main__\":\n    main()\n"]