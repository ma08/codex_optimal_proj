["import sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\ndef NIJIGEN(H): return [list(input()) for i in range(H)]\ndef dfs(j):\n  if j not in finish:\n    finish.add(j)\n    for k in L[j]:\n      dfs(k)\nN,M=MAP()\ns=list()\nL=[[] for _ in range(N)]\nfor i in range(M):\n  a,b=MAP()\n  a-=1\n  b-=1\n  L[a].append(b)\n  L[b].append(a)\n  s.append([a,b])\nans=0\nfor i in range(M):\n  a,b=s[i]\n  L[a].remove(b)\n  L[b].remove(a)\n  finish=set()\n  dfs(a)\n  if len(finish)!=N:\n    ans+=1\n  L[a].append(b)\n  L[b].append(a)\nprint(ans)", "class UnionFind():\n    \"\"\"\n    parents\n        \u5404\u8981\u7d20\u306e\u89aa\u8981\u7d20\u306e\u756a\u53f7\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n        \u8981\u7d20\u304c\u6839\uff08\u30eb\u30fc\u30c8\uff09\u306e\u5834\u5408\u306f-(\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u8981\u7d20\u6570)\u3092\u683c\u7d0d\u3059\u308b\n    find(x)\n        \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u6839\u3092\u8fd4\u3059\n    union(x, y)\n        \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u8981\u7d20y\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u3068\u3092\u4f75\u5408\u3059\u308b\n    size(x)\n        \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\uff08\u8981\u7d20\u6570\uff09\u3092\u8fd4\u3059\n    same(x, y)\n        \u8981\u7d20x, y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\n    members(x)\n        \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n        \u95a2\u9023\u8a18\u4e8b: Python\u30ea\u30b9\u30c8\u5185\u5305\u8868\u8a18\u306e\u4f7f\u3044\u65b9\n    roots()\n        \u3059\u3079\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\n    group_count()\n        \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059\n    all_group_members\n        {\u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8], ...}\u306e\u8f9e\u66f8\u3092\u8fd4\u3059\n        \u95a2\u9023\u8a18\u4e8b: Python\u3067\u8f9e\u66f8\u3092\u4f5c\u6210\u3059\u308bdict()\u3068\u6ce2\u62ec\u5f27\u3001\u8f9e\u66f8\u5185\u5305\u8868\u8a18\n    __str__()\n        print()\u3067\u306e\u8868\u793a\u7528\n        \u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8]\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3059\n    \"\"\"\n    \n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN,M=list(map(int,input().split()))\nab=[tuple(map(int,input().split())) for _ in range(M)]\nans=0\n\nfor i in range(M):\n    uf = UnionFind(N)\n    \n    for j in range(M):\n        if i!=j:\n            a,b=ab[j][0],ab[j][1]\n            uf.union(a-1,b-1)\n    #print(i)\n    if uf.group_count()!=1:\n        ans+=1\n        \nprint(ans)\n\n", "from collections import deque\ndef BFS(N,M,List):\n    Edge = [[] for TN in range(N+1)]\n    for TM in range(0,M):\n        Edge[List[TM][0]].append(List[TM][1])\n        Edge[List[TM][1]].append(List[TM][0])\n\n    Distance = [-1]*(N+1)\n    Distance[0] = 0\n    Distance[1] = 0\n    \n    From = [0]*(N+1)\n    From[1] = 1\n\n    Deque = deque()\n    Deque.append(1)\n    while Deque:\n        Now = Deque.popleft()\n        for Con in Edge[Now]:\n            if Distance[Con]==-1:\n                Distance[Con] = Distance[Now]+1\n                Deque.append(Con)\n                From[Con] = Now\n\n    return Distance[1:],From[1:]\n\nimport copy\nN,M = (int(T) for T in input().split())\nList = [[] for TM in range(0,M)]\nfor TM in range(0,M):\n    List[TM] = [int(T) for T in input().split()]\nCount = 0\nfor TM in range(0,M):\n    ListCopy = copy.deepcopy(List)\n    del ListCopy[TM]\n    Distance,From = BFS(N,M-1,ListCopy)\n    if -1 in Distance:\n        Count += 1\nprint(Count)", "n, m = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(m)]\n\ndef find(x):\n    if root[x] < 0:\n        return x\n    else:\n        root[x] = find(root[x])\n        return root[x]\n\ndef unit(x, y):\n    gx = find(x)\n    gy = find(y)\n\n    if gx == gy:\n        return\n\n    if root[gx] > root[gy]:\n        gx, gy = gy, gx\n\n    root[gx] += root[gy]\n    root[gy] = gx\n\ncnt = 0\nfor i in range(m):\n    root = [-1] * n\n    for j in range(m):\n        if i == j:continue\n        unit(AB[j][0]-1, AB[j][1]-1)\n    roots = [i for i in root if i < 0]\n    cnt += (len(roots) != 1)\nprint(cnt)", "from collections import deque\nfrom sys import stdin\ninput = stdin.readline\n\nN,M = map(int, input().split())\nneighbor = [[] for _ in range(N)]\nA = [-1]*M; B = [-1]*M\nfor i in range(M):\n    a,b = map(lambda x: int(x) - 1, input().split())\n    A[i] = a; B[i] = b\n    neighbor[a].append(b)\n    neighbor[b].append(a)\n\ncnt = 0\nfor i in range(M):\n    a,b = A[i],B[i]\n    neighbor[a].remove(b)\n    neighbor[b].remove(a)\n    visited = [False]*N\n    queue = deque()\n    queue.append(0)\n    visited[0] = True\n    \n    while queue:\n        x = queue.popleft()\n        \n        for z in neighbor[x]:\n            if not visited[z]:\n                visited[z] = True\n                queue.append(z)\n    \n    \n    if False in visited:\n        cnt += 1\n    \n    neighbor[a].append(b)\n    neighbor[b].append(a)\n\nprint(cnt)", "class DisjointSet:\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n\nN, M, *ab = list(map(int, open(0).read().split()))\nedges = [(a - 1, b - 1) for a, b in zip(*[iter(ab)] * 2)]\n\nans = 0\nfor i in range(M):\n    ds = DisjointSet(N)\n    for j in range(M):\n        if i == j:\n            continue\n        ds.union(*edges[j])\n    if len([-p for p in ds.parents if p < 0]) > 1:\n        ans += 1\nprint(ans)\n", "N,M = map(int,input().split())\nG = [[] for _ in range(N)]\nH = []\nfor i in range(M):\n  a,b = map(int,input().split())\n  a-=1;b-=1 #0index\n  G[a].append([b,i]);G[b].append([a,i]) #i\u3092\u8fba\u306eID\u3068\u3057\u3066\u4fdd\u5b58\n  H.append([a,b])\nans = 0\n \ndef dfs(v,ID): #ID\u306e\u8fba\u3092\u4f7f\u3048\u306a\u3044\n  visited.add(v)\n  for u,idx in G[v]:\n    if idx == ID or u in visited:\n      continue\n    dfs(u,ID)\n \nfor i in range(M):\n  visited = set([])\n  start = H[i][0]\n  goal = H[i][1]\n  dfs(start,i)\n  if goal not in visited:\n    ans +=1\nprint(ans)", "class UnionFindWithSize:\n    def __init__(self, size):\n        self.parent = [i for i in range(size)]\n        self.size = [1]*size\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def unite(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return\n        if self.size[x] < self.size[y]:\n            self.size[y] += self.size[x]\n            self.parent[x] = y\n        else:\n            self.size[x] += self.size[y]\n            self.parent[y] = x\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def sizeofset(self, x):\n        return self.size[self.find(x)]\ndef __starting_point():\n    N,M = map(int,input().split())\n    edges = [tuple(map(lambda x:int(x)-1,input().split())) for _ in range(M)]\n    ans = 0\n    for i in range(M):\n        uf = UnionFindWithSize(N)\n        for j in range(M):\n            if j != i:\n                a,b = edges[j]\n                uf.unite(a,b)\n        if uf.sizeofset(0) != N:\n            ans += 1\n    print(ans)\n__starting_point()", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.para = [-1] * (n + 1)\n    \n    def find(self, x):\n        if self.para[x] < 0:\n            return x\n        else:\n            self.para[x] = self.find(self.para[x])\n            return self.para[x]\n    \n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x > y:\n            x, y = y, x\n        if x == y:\n            return\n        else:\n            self.para[x] += self.para[y]\n            self.para[y] = x\n    def isSame(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    def count(self,x):\n        return -self.para[self.find(x)]\nN, M = map(int, input().split())\nun_orginal = UnionFind(N)\nA = [tuple(map(int, input().split())) for _ in range(M)]\nfor a,b in A:\n    un_orginal.unite(a,b)\nans = 0\nfor i in range(M):\n    un = UnionFind(N)\n    for k in range(M):\n        if i == k:\n            continue\n        else:\n            un.unite(A[k][0], A[k][1])\n    cnt = 0\n    for k in range(N+1):\n        if un_orginal.count(k) == un.count(k):\n            cnt += 1\n    if cnt == N+1:\n        ans += 1\nprint(M-ans)", "from networkx import *\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(m)]\ng = Graph(a)\nans = 0\nfor x in a:\n  g.remove_edges_from([x])\n  if not is_connected(g):\n    ans += 1\n  g.add_edges_from([x])\nprint(ans)", "N,M = map(int,input().split())\nAB = [tuple(map(int,input().split())) for i in range(M)]\n\nclass UnionFind:\n    def __init__(self,N):\n        self.parent = [i for i in range(N)]\n        self._size = [1] * N\n        self.count = 0\n    def root(self,a):\n        if self.parent[a] == a:\n            return a\n        else:\n            self.parent[a] = self.root(self.parent[a])\n            return self.parent[a]\n    def is_same(self,a,b):\n        return self.root(a) == self.root(b)\n    def unite(self,a,b):\n        ra = self.root(a)\n        rb = self.root(b)\n        if ra == rb: return\n        if self._size[ra] < self._size[rb]: ra,rb = rb,ra\n        self._size[ra] += self._size[rb]\n        self.parent[rb] = ra\n        self.count += 1\n    def size(self,a):\n        return self._size[self.root(a)]\n\nans = 0\nfor i in range(M):\n    uf = UnionFind(N)\n    for j,(a,b) in enumerate(AB):\n        if i==j: continue\n        a,b = a-1,b-1\n        if uf.is_same(a,b): continue\n        uf.unite(a,b)\n    if uf.size(0) != N:\n        ans += 1\nprint(ans)", "3\n# coding: utf-8\nfrom collections import defaultdict\n\nclass UnionFind(object):\n    def __init__(self, N):\n        self.parent = [x for x in range(N)] \n\n    def root(self, x):\n        if self.parent[x] == x: return x\n        return self.root(self.parent[x]) \n\n    def unite(self, x, y):\n        root_x = self.root(x)\n        root_y = self.root(y)\n        if root_x != root_y:\n            self.parent[root_x] = root_y\n    \n    def same(self, x, y):\n        root_x = self.root(x)\n        root_y = self.root(y)\n        return root_x == root_y\n    \n    def num_group(self):\n        return sum(1 for i in range(len(self.parent)) if self.parent[i] == i)\n\nN, M = (int(x) for x in input().split())\nB = [[int(x) -1 for x in input().split()] for _ in range(M)]\n\ndef isBridge(nth):\n    union_find = UnionFind(N)\n    for i in range(M): \n        if i == nth: continue\n        union_find.unite(B[i][0], B[i][1])\n    if union_find.num_group() != 1:\n        return 1\n\nret = 0\nfor i in range(M):\n    if isBridge(i):\n        ret += 1\nprint(ret)\n\n", "N,M=map(int,input().split())\nAB=[list(map(int,input().split())) for i in range(M)]\nr=0\nfor m in range(M):\n    c=[[] for i in range(N)]\n    for i,(a,b) in enumerate(AB):\n        if i!=m:\n            c[a-1].append(b-1)\n            c[b-1].append(a-1)\n    q=[0]\n    v=[1]+[0]*(N-1)\n    while q:\n        p=q.pop()\n        for n in c[p]:\n            if v[n]==0:\n                v[n]=1\n                q.append(n)\n    if 0 in v:\n        r+=1\nprint(r)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n \n    def unite(self, x, y):# UF.unite(a-1,b-1)\n        x = self.find(x)\n        y = self.find(y)\n \n        if x == y:\n            return\n \n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n \n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n \n    def size(self, x):#\u4eca\u56de\u306f\u4f7f\u3063\u3066\u3044\u306a\u3044\n        return -self.parents[self.find(x)]\n \n    def same(self, x, y):#UF.same(a-1,b-1) True/False\n        return self.find(x) == self.find(y)\n\nN,M=map(int,input().split())\n\nA=[0]*M;t=0;B=[0]*M\n\nfor i in range(M):\n  a,b=map(int,input().split())\n  A[i]=[a-1,b-1]\nfor t in range(M):\n  UF=UnionFind(N)\n  for i in range(M):\n    if i!=t:\n      UF.unite(A[i][0],A[i][1])\n  if UF.same(A[t][0],A[t][1])==False:\n    B[t]=1\nprint(sum(B))", "class UnionFind():\n    def __init__(self, n):\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\nn,m = map(int,input().split())\na = [list(map(int,input().split())) for i in range(m)]\nans = 0\nfor i in range(m):\n    uf = UnionFind(n+1)\n    cnt = 0\n    for j in range(m):\n        if i == j:\n            continue\n        else:\n            uf.union(a[j][0],a[j][1])\n    for k in uf.parents:\n        if k < 0:\n            cnt += 1\n    if cnt != 2:\n        ans += 1\n\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\nN, M = [int(i) for i in input().split()]\nABS = [[int(i) for i in input().split()] for _ in range(M)]\n\ncnt = 0\nfor i in range(M):\n  uf = UnionFind(N+1)\n  for a, b in [*ABS[:i], *ABS[i+1:]]:\n    uf.union(a, b)\n  if uf.group_count() > 2:\n    cnt += 1\n\nprint(cnt)\n", "class UnionFind:\n  def __init__(self,n):\n    self.nodes=n\n    self.parents=[i for i in range(n)]\n    self.sizes=[1]*n\n    self.rank=[0]*n\n\n  def find(self,x):\n    if self.parents[x]==x:\n      return x\n    else:\n      self.parents[x]=self.find(self.parents[x])\n      return self.parents[x]\n\n  def unite(self,x,y):\n    x=self.find(x)\n    y=self.find(y)\n    if x!=y:\n      if self.rank[x]<self.rank[y]:\n        self.sizes[y]+=self.sizes[x]\n        self.parents[x]=y\n      else:\n        self.sizes[x]+=self.sizes[y]\n        self.parents[y]=x\n        if self.rank[x]==self.rank[y]:\n          self.rank[x]+=1\n  def same(self,x,y):\n    return self.find(x)==self.find(y)\n\n  def get_parents(self):\n    for n in range(self.nodes):\n      self.find(n)\n    return self.parents\n\nadj = []\nN, M = map(int,input().split())\nfor m in range(M):\n  a,b = map(int,input().split())\n  adj.append([a-1,b-1])\n\nans=0\nfor i in range(M):\n  uf = UnionFind(N)\n  for j in range(M):\n    if i==j:\n      continue\n    uf.unite(*adj[j])  \n  if len(set(uf.get_parents()))!=1:\n    ans += 1\nprint(ans)", "import copy\nN, M = map(int, input().split())\nl = []\nfor i in range(M):\n  l.append(list(map(int, input().split())))\n  \ndef bfs(l, tmp, came):\n  t = []\n  for n in tmp:\n    for s in l:\n      if (s[0]==n) and (s[1] not in came):\n        t.append(s[1])\n        came.append(s[1])\n      elif (s[1]==n) and (s[0] not in came):\n        t.append(s[0])\n        came.append(s[0])\n  if t == []:\n    came = set(came)\n    return came\n  else:\n    return bfs(l, t, came)\n  \nans = 0\nfor i in range(M):\n  x = copy.copy(l)\n  x.pop(i)\n  a = bfs(x, [1], [1])\n  if len(a) < N:\n    ans += 1\nprint(ans)", "class union_find():\n    def __init__(self, n):\n        # self.n = n\n        self.root = [-1]*(n+1)\n        self.rank = [0]*(n+1)\n        self.siz = n\n\n    def find_root(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.find_root(self.root[x])\n            return self.root[x]\n\n    def unite(self, x, y):\n        x = self.find_root(x)\n        y = self.find_root(y)\n        if x == y:\n            return\n        elif self.rank[x] > self.rank[y]:\n            self.root[x] += self.root[y]\n            self.root[y] = x\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[y] += 1\n        self.siz -= 1\n\n    def same(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def size(self):\n        return self.siz\n\n\nn, m = list(map(int, input().split()))\n\nab = []\nfor _ in range(m):\n    ab.append(list(map(int, input().split())))\n\ng = union_find(n)\nans = 0\nfor i in range(len(ab)):\n    for j in range(len(ab)):\n        if i == j:\n            continue\n        a, b = ab[j]\n        g.unite(a, b)\n\n    if g.size() != 1:\n        ans += 1\n    g = union_find(n)\n\n\nprint(ans)\n", "N, M = list(map(int, input().split()))\n\nedge = []\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = [int(x) - 1 for x in input().split()]\n    edge.append((a, b))\n    graph[a].append(b); graph[b].append(a)\n\ndef dfs(now):\n    searched[now] = True\n    for next in graph[now]:\n        if searched[next]:\n            continue\n        if min(now, next) == a and max(now, next) == b:\n            continue\n        dfs(next)\n\nans = M\nfor i in range(M):\n    a, b = edge[i]\n    searched = [False] * N\n    dfs(0)\n    if sum(searched) == N:\n        ans -= 1\n\nprint(ans)\n", "#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\nn,m = list(map(int,input().split()))\ndata = [list(map(int, input().split())) for i in range(m)]\n\ndef dfs(pos):\n  if visit[pos] == 1:\n    return\n  visit[pos] = 1\n  \n  for i in range(n):\n    if graph[pos][i] == 1:\n      dfs(i)\n\ncount = 0\nfor hen in range(m):\n  graph = [[0]*n for i in range(n)]\n  visit = [0]*n\n\n  for i in range(m):\n    pos1 = data[i][0] - 1\n    pos2 = data[i][1] - 1\n    if i != hen:\n      graph[pos1][pos2] = 1\n      graph[pos2][pos1] = 1\n  dfs(0)\n  connected = True\n  for i in range(n):\n    if visit[i] == 0:\n      connected = False\n  if not connected:\n    count += 1\nprint(count)\n\n\n# In[ ]:\n\n\n\n\n", "#Union Find\n\n#x\u306e\u6839\u3092\u6c42\u3081\u308b\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        tank = []\n        while par[x] >= 0:\n            tank.append(x)\n            x = par[x]\n        for elt in tank:\n            par[elt] = x\n        return x\n#x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    \n    if x == y:\n        return False\n    else:\n        #size\u306e\u5927\u304d\u3044\u307b\u3046\u304cx\n        if par[x] > par[y]:\n            x,y = y,x\n        par[x] += par[y]\n        par[y] = x\n        return True\n\n#x\u3068y\u304c\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u306e\u5224\u5b9a\ndef same(x,y):\n    return find(x) == find(y)\n\n#x\u304c\u5c5e\u3059\u308b\u96c6\u5408\u306e\u500b\u6570\ndef size(x):\n    return -par[find(x)]\n\nn,m=list(map(int,input().split()))\nedge=[]\nfor _ in range(m):\n    a,b=list(map(int,input().split()))\n    a,b=a-1,b-1\n\n    edge.append([a,b])\n\n\nans=0\nfor j in range(m):\n    #\u521d\u671f\u5316 \n    #\u6839\u306a\u3089-size,\u5b50\u306a\u3089\u89aa\u306e\u9802\u70b9\n    par = [-1]*n\n    cnt=0\n    for p in range(m):\n        if p==j:\n            continue\n    \n        e=edge[p]\n        unite(e[0],e[1])  \n          \n    for k in range(n):\n        if par[k]<0:\n            cnt+=1\n\n    if cnt>=2:\n        ans+=1\n    \n    \n\n    \n\n\nprint(ans)\n\n", "N, M = map(int, input().split())\nto1 = [[0] for i in range(N)]\nab = [[0, 0] for i in range(M)]\n\nfor i in range(M):\n    ab[i][0], ab[i][1] = map(int, input().split())\n    to1[ab[i][0]-1].append(ab[i][1]-1)\n    to1[ab[i][1]-1].append(ab[i][0]-1)\n\nans = 0\n\ndef DFS(n):\n    nonlocal v\n    if v[n] == 1:\n        return\n    v[n] = 1\n    for i in to1[n]:\n        DFS(i)\n\nfor i in range(M):\n    v = [0] * N\n    p = ab[i]\n    p[0] -= 1\n    p[1] -= 1\n    to1[p[0]].remove(p[1])\n    to1[p[1]].remove(p[0])\n    DFS(0)\n    if sum(v) != N:\n        ans += 1\n    to1[p[0]].append(p[1])\n    to1[p[1]].append(p[0])\n\nprint(ans)", "import copy\n\ndef main():\n\tN, M = [int(n) for n in input().split(\" \")]\n\tedges = [[] for i in range(N)]\n\t# edges[i] : edges from vertex i \n\tr = []\n\tfor i in range(M):\n\t\ta, b = [int(x) for x in input().split(\" \")]\n\t\tedges[a - 1].append(b - 1)\n\t\tedges[b - 1].append(a - 1)\n\t\tr.append([a - 1, b - 1])\n\tcnt = 0\n\tfor i in range(len(r)):\n\t\tif not isConnected(edges, r[i]):\n\t\t\tcnt += 1\n\tprint(cnt)\n\ndef isConnected(edges, remove_edge):\n\tn_v = len(edges)\n\tchecked = [0] * n_v\n\tto_check = [0]\n\te = copy.deepcopy(edges)\n\te[remove_edge[0]].remove(remove_edge[1])\n\te[remove_edge[1]].remove(remove_edge[0])\n\twhile len(to_check) > 0:\n\t\tchecking = to_check.pop(0)\n\t\tchecked[checking] = 1\n\t\tfor i in e[checking]:\n\t\t\tif checked[i] == 1:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tto_check.append(i)\n\tif n_v == sum(checked):\n\t\treturn True\n\telse:\n\t\treturn False\n\n\nmain()", "n, m = map(int, input().split())\nlist_AB = [ list(map(int,input().split(\" \"))) for _ in range(m)]\nans = 0\n\nfor i in range(m):\n    route = [[] for _ in range(n)]\n    for j in range(m):\n        if j != i:\n            a, b = list_AB[j][0], list_AB[j][1]\n            route[a-1].append(b-1)\n            route[b-1].append(a-1)\n\n    q = [0]\n    l = {0}\n\n    while q:\n        x = q.pop(0)\n        for p in route[x]:\n            if p not in l:\n                l.add(p)\n                q.append(p)\n\n    if len(list(l)) != n:\n        ans += 1\n\nprint(ans)", "N,M = list(map(int,input().split()))\nG = [[] for _ in range(N)]\nH = []\nfor i in range(M):\n  a,b = list(map(int,input().split()))\n  a-=1;b-=1 #0index\n  G[a].append([b,i]);G[b].append([a,i]) #i\u3092\u8fba\u306eID\u3068\u3057\u3066\u4fdd\u5b58\n  H.append([a,b])\nans = 0\n\ndef dfs(v,ID): #ID\u306e\u8fba\u3092\u4f7f\u3048\u306a\u3044\n  visited.add(v)\n  for u,idx in G[v]:\n    if idx == ID or u in visited:\n      continue\n    dfs(u,ID)\n\nfor i in range(M):\n  visited = set([])\n  start = H[i][0]\n  goal = H[i][1]\n  dfs(start,i)\n  if goal not in visited:\n    ans +=1\nprint(ans)\n", "from collections import Counter\nN, M = map(int, input().split())\n\nclass UnionFind:\n    def __init__(self, N):\n        self.root = list(range(N + 1))\n        self.size = [1] * (N + 1)\n\n    def __getitem__(self, x):\n        root = self.root\n        while root[x] != x:\n            root[x] = root[root[x]]\n            x = root[x]\n        return x\n\n    def merge(self, x, y):\n        x = self[x]\n        y = self[y]\n        if x == y:\n            return\n        sx, sy = self.size[x], self.size[y]\n        if sx < sy:\n            x, y = y, x\n            sx, sy = sy, sx\n        self.root[y] = x\n        self.size[x] += sy\n\n\nA, B = [], []\nfor i in range(M):\n    a, b = map(int, input().split())\n    A.append(a)\n    B.append(b)\n\ncount = 0\nfor i in range(M):\n    uni = UnionFind(N)\n    for j in range(M):\n        if j == i:\n            continue\n        uni.merge(A[j], B[j])\n    # UnionFind\u306e\u9023\u7d50\u6210\u5206\u306e\u500b\u6570\u3092\u6570\u3048\u308b\n    roots = [uni[x] for x in uni.root[1:]]\n    counter = Counter(roots)\n    if len(counter) > 1:\n        count += 1\n\nprint(count)", "class UnionFind():\n    def __init__(self,n):\n        self.parents = [-1]*n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        \n\nN,M = map(int, input().split())\nAB = []\nfor _ in range(M):\n    AB.append(list(map(int, input().split())))\nans = 0\nfor i in range(M):\n    if i == M-1:\n        ab = AB[:M-1]\n    else:\n        ab = AB[:i]+AB[i+1:]\n    uf = UnionFind(N)\n    for j in ab:\n        uf.union(j[0]-1,j[1]-1)\n    if uf.parents[uf.find(0)] != - N:\n        ans += 1\nprint(ans)", "N,M=map(int,input().split())\ngraph = [[] for i in range(N)]\n\nfor i in range(M):\n  a, b = map(int, input().split())\n  a, b = a-1, b-1\n  graph[a].append(b)\n  graph[b].append(a) \n    \ndef dfs(x,g):\n    if vis[x]:return\n    vis[x]=1\n    for i in g[x]:\n     dfs(i,g)\n    return\n\nans=0\nfor i in range(len(graph)):\n    for j in range(len(graph[i])):\n        t=graph[i]\n        gn=graph[0:i]+[t[0:j]+t[j+1:]]+graph[i+1:]\n        vis=[0]*N\n        dfs(0,gn)\n        if not(all(vis)):\n            # print(i+1, graph[i][j]+1,gn,vis)\n            ans+=1\nprint(ans)", "n,m = map(int, input().split())\nreach = [0]*(n+1)\nl = [[] for i in range(n+1)]\nfor i in range(m):\n  a,b = map(int, input().split())\n  l[a].append(b)\n  l[b].append(a)\n  \ndef dfs(s, parent):\n  reach[s] = 1\n  for i in l[s]:\n    if i == parent: continue\n    if reach[i] == 0:\n      dfs(i, s)\n    else:\n      reach[i] += 1\n\nloop = [0]*(n+1)\nfor i in range(1, n+1):\n  reach = [0]*(n+1)\n  dfs(i, 0)\n  if reach[i] != 1:\n    loop[i] = 1\nans = 0\nfor i in range(1, n+1):\n  for j in l[i]:\n    if loop[i] == 1 and loop[j] == 1:\n      ans += 1\nprint(m - ans//2)", "\nclass node:\n    def __init__(self, id):\n        self.id = id\n        self.root = self\n\n    def findRoot(self):\n        if self == self.root:\n            return self\n        else:\n            self.root = self.root.findRoot()\n            return self.root\n\n    def resetRoot(self):\n        self.root = self\n\nclass Tree:\n    def __init__(self, num):\n        self.nodes = {i:node(i) for i in range(num)}\n\n    def union(self, one, other):\n        root1 = one.findRoot()\n        root2 = other.findRoot()\n        root1.root = root2.root = self.nodes[min(root1.id, root2.id)]\n\n    def resetTree(self):\n        for n in self.nodes.values():\n            n.resetRoot()\n\n    def makeTree(self, Edge):\n        self.edge = Edge\n        for x,y in Edge:\n            self.union(self.nodes[x-1], self.nodes[y-1])\n\n\ndef main():\n    with open(0) as f:\n        N, M = map(int, f.readline().split())\n        Edge = [tuple(map(int, line.split())) for line in f.readlines()]\n    \n    tree = Tree(N)\n    ans = 0\n    for i in range(M):\n        edge = [v for  v in Edge if v != Edge[i]]\n        tree.makeTree(edge)\n        if any(x.findRoot().id != 0 for x in tree.nodes.values()):\n            ans += 1\n        tree.resetTree()\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import copy\nN,M=map(int,input().split())\npath_matrix=[[0 for i in range(N)] for j in range(N)]\nL=[[] for i in range(M)]\n\nfor i in range(M):\n    a,b=map(int,input().split())\n    path_matrix[a-1][b-1]=1\n    path_matrix[b-1][a-1]=1\n    L[i].append(a)\n    L[i].append(b)\n\ncolor_white=[\"W\" for i in range(N)]\ncolor_black=[\"B\" for i in range(N)]\nvisited=copy.deepcopy(color_white)\n\ndef path(x,y):\n    path_matrix[x-1][y-1]=0\n    path_matrix[y-1][x-1]=0\n    return DFS(x,path_matrix)\n\ndef DFS(x,tim):\n    visited[x-1]=\"B\"\n    if visited==color_black:\n        return True\n    total_ans=0\n    for i in range(N):\n        if tim[x-1][i]==1 and visited[i]==\"W\":\n            total_ans=int(DFS(i+1,tim))\n\n    return total_ans\n    \nans=0\nfor i in range(M):\n    visited=copy.deepcopy(color_white)\n    if path(L[i][0],L[i][1])==0:\n        ans+=1\n    path_matrix[L[i][0]-1][L[i][1]-1]=1\n    path_matrix[L[i][1]-1][L[i][0]-1]=1\n\nprint(ans)", "import itertools\n#\u5165\u529b\nN,M = list(map(int, input().split()))\nABs = [list(map(int, input().split())) for _ in range(M)]\n\n#\u6a4b\u306fMAX50\u672c\u306a\u306e\u3067\u30011\u672c\u305a\u3064\u53d6\u308a\u9664\u3044\u3066\u5168\u3066\u304c\u7e4b\u304c\u308b\u304b\u3069\u3046\u304b\u3092\u8a66\u884c\u3059\u308b\u3002\n\n#UnionFind\u6728\n\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x]\ndef same(x,y):\n    return find(x) == find(y)\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n    size[y] = size[x] + size[y]\n    size[x] = 0\n\n#\u6a4b\u306e\u7d44\u307f\u5408\u308f\u305b\nloop_list = list(itertools.combinations(ABs, M-1))\n#print(loop_list)\n\nans = 0\nfor loop in loop_list:\n    #\u30eb\u30fc\u30d7\u6bce\u306b\u30ea\u30bb\u30c3\u30c8\u3059\u308b\u306e\u3067\u3002\u826f\u304f\u306a\u3044\u6c17\u304c\u3059\u308b\u3002\n    par = [i for i in range(N+1)]\n    size = [1 for _ in range(N+1)]\n\n    for bridge in loop:\n        unite(bridge[0], bridge[1])\n    \n#    print(par)\n#    print(size)\n    if(max(size) != N):\n        ans += 1\n\nprint(ans)", "N,M=map(int,input().split())\nab=[list(map(int,input().split()))for _ in range(M)]\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nans=0\nfor i in range(M):\n    uf=UnionFind(N)\n    for j in range(M):\n        if i==j:\n            continue\n        a,b=ab[j]\n        uf.union(a-1,b-1)\n    ans+=(uf.group_count()>1)\nprint(ans)", "from collections import deque\nnumber,m = list(map(int,input().split()))\n\nh = deque([])\n\nfor _ in range(m):\n    l = list(map(int,input().split()))\n    h.append(l)\ncount = 0\n\nfor i in range(m):\n    if i != 0:\n        h.append([a1,b1])\n    a1,b1 = h.popleft()\n    g = [[] for _ in range(number)]\n    for a,b in h:\n\n        g[a-1].append(b)\n        g[b-1].append(a)\n\n    q = deque([a1])\n    pre = [0]*number\n    pre[a1-1] = 1\n    while q:\n        now = q.popleft()\n\n        for n in g[now-1]:\n\n            if pre[n-1] == 0:\n                q.append(n)\n                pre[n-1] = 1\n            else:\n                continue\n    \n    if sum(pre) != number:\n        count+=1\n\nprint(count)\n\n", "class UnionFind():\n  def __init__(self,n):\n    self.n = n\n    self.parents = [-1]*n\n  def find(self,x):\n    if self.parents[x]<0:\n      return x\n    else:\n      self.parents[x]=self.find(self.parents[x])\n      return self.parents[x]\n  def unite(self,x,y):\n    x = self.find(x)\n    y = self.find(y)\n    if x == y:\n      return\n    if self.parents[x]>self.parents[y]:\n      x,y=y,x\n    self.parents[x]+=self.parents[y]\n    self.parents[y]=x\n  def same(self,x,y):\n    return self.find(x)==self.find(y)\nN,M = map(int,input().split())\nA = [0]*M\nt=0\nB=[0]*M\nfor i in  range(M):\n  a,b=map(int,input().split())\n  A[i]=[a-1,b-1]\nfor t in range(M):\n  UF = UnionFind(N)\n  for i in range(M):\n    if i!=t:\n      UF.unite(A[i][0],A[i][1])\n  if UF.same(A[t][0],A[t][1])==False:\n    B[t]=1\nprint(sum(B))", "class UnionFind():\n    def __init__(self, n):\n        self.parents = list(range(n))\n        self.size = [1] * n\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.size[x] < self.size[y]:\n            self.size[y] += self.size[x]\n            self.parents[x] = y\n        else:\n            self.size[x] += self.size[y]\n            self.parents[y] = x\n    def size(self, x):\n        return -self.parents[self.find(x)]\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n    def group_count(self):\n        return len(self.roots())\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\nn,m=list(map(int,input().split()))\nnum=[list(map(int,input().split())) for _ in range(m)]\nans=0\nfor i in range(m):\n    uf=UnionFind(n)\n    for j in range(m):\n        if i!=j:\n            uf.union(num[j][0]-1,num[j][1]-1)\n    if uf.size[uf.find(0)]!=n:\n        ans+=1\nprint(ans)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(m)]\nans = 0\nfor i in range(m):\n    uf = UnionFind(n)\n    for j in range(m):\n        if i != j:\n            uf.union(a[j][0]-1, a[j][1]-1)\n    if uf.size(0) != n:\n        ans += 1\nprint(ans)", "N, M = list(map(int, input().split()))\nAB = [tuple(map(int, input().split())) for _ in range(M)]\n\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\n\ncnt = 0\nfor i in range(M):\n    par = [i for i in range(N+1)]\n    k = 0\n    for a, b in AB:\n        if k != i:\n            unite(a,b)\n        k += 1\n    \n    res = []\n    for j in range(1,N+1):\n        res.append(find(j))\n    \n    if len(set(res)) >= 2:\n        cnt += 1\nprint(cnt)\n", "class UnionFind:\n    def __init__(self, N):\n        self.N = N\n\n        # the parent of all node is itself\n        # self.parent = list(range(N))\n        self.parent = [-1] * N\n\n    def root(self, i):\n        if self.parent[i] < 0:\n            return i\n\n        r = self.root(self.parent[i])\n        self.parent[i] = r\n        return r\n\n    def unite(self, i, j):\n        i = self.root(i)\n        j = self.root(j)\n\n        if i == j:\n            return\n\n        if i > j:\n            i, j = j, i\n\n        self.parent[i] += self.parent[j]\n        self.parent[j] = i\n        # print(self.parent)\n\n    def same(self, i, j):\n        return self.root(i) == self.root(j)\n\n    def size(self, i):\n        return -self.parent[self.root(i)]\n\n    def roots(self):\n        return [self.root(i) for i in range(self.N)]\n\n    def groupcount(self):\n        return len(set(self.roots()))\n\nN, M = map(int, input().split())\nedges = [[int(x) - 1 for x in input().split()] for _ in range(M)]\n\nans = 0\n\n# \u5168\u3066\u306eedge\u306b\u5bfe\u3057\u3066\nfor i in range(M):\n    # UnionFind\u6728\u3092\u521d\u671f\u5316\n    forest = UnionFind(N)\n\n    # i\u756a\u76ee\u306e\u30a8\u30c3\u30b8\u3092\u9664\u3044\u305f\u3082\u306e\u3092\u3064\u306a\u3050\n    for i, j in edges[:i] + edges[i+1:]:\n        forest.unite(i, j)\n\n    # \u5168\u3066\u306e\u30ce\u30fc\u30c9\u304c\u3064\u306a\u304c\u3063\u3066\u3044\u308b <=> \u30b0\u30eb\u30fc\u30d7\u6570\u306f1\n    # \u30b0\u30eb\u30fc\u30d7\u6570\uff08\u5cf6\u306e\u6570\uff09\u304c\uff11\u3067\u306f\u306a\u3044 <=> \u30b0\u30e9\u30d5\u306f\uff12\u3064\u4ee5\u4e0a\u306e\u5cf6\u304b\u3089\u6210\u308b\n    if forest.groupcount() != 1:\n        ans += 1\n\nprint(ans)", "from collections import deque\nfrom sys import stdin\ninput = stdin.readline\n\nclass Unionfind():\n    def __init__(self, n):\n        self.n = n\n        self.parent = [-1]*n\n    \n    def find(self, x):\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return\n        if self.parent[x] < self.parent[y]:\n            x,y = y,x\n        \n        self.parent[x] += self.parent[y]\n        self.parent[y] = x\n        \n\nN,M = map(int, input().split())\nA = [-1]*M; B = [-1]*M\nfor i in range(M):\n    a,b = map(lambda x: int(x) - 1, input().split())\n    A[i] = a; B[i] = b\n\nans = 0\nfor exclude_idx in range(M):\n    uf = Unionfind(N)\n    for i in range(M):\n        if i == exclude_idx:\n            continue\n        uf.union(A[i],B[i])\n    \n    cnt = 0\n    for parent in uf.parent:\n        if parent < 0:\n            cnt += 1\n    if cnt >= 2:\n        ans += 1\n\nprint(ans)", "class UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n\n    def root(self, x):\n        if self.parent[x] == x:\n            return x\n        else:\n            self.parent[x] = self.root(self.parent[x])\n            return self.parent[x]\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x != y:\n            self.parent[x] = y\n            self.size[y] += self.size[x]\n\n    def same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return self.size[self.root(x)]\n\nN, M = list(map(int, input().split()))\nAB = [list([int(x)-1 for x in input().split()]) for _ in range(M)]\nans = 0\nfor i in range(M):\n    un = UnionFind(N)\n    for j in range(M):\n        if i != j:\n            un.unite(AB[j][0], AB[j][1])\n    if un.count(0) != N:\n        ans += 1\nprint(ans)\n", "n,m = map(int, input().split())\ns =[set() for i in range(n)]\ne = []\nfor i in range(m):\n  a,b = map(int, input().split())\n  a-=1\n  b-=1\n  s[a].add(b)\n  s[b].add(a)\n  e.append([a,b])\ndef dfs(u,v,c):\n  visited[u] = 1\n  c += 1\n  if u == v:\n    d.append(c)\n    return True\n  for i in s[u]:\n    if visited[i]:\n      continue\n    if c == 1:\n      if i == v:\n        continue\n    dfs(i,v,c)\n\ncnt = 0\nfor i in range(m):\n  x,y = e[i][0],e[i][1]\n  visited = [0 for i in range(n)]\n  d = []\n  dfs(x,y,0)\n  if len(d) > 0:\n    cnt += 1\nprint (m-cnt)", "class UnionFind():\n  def __init__(self,n):\n    self.n=n\n    self.parents =[-1]*n\n\n  def find(self, x):\n    if self.parents[x]<0:\n      return x\n    else:\n      self.parents[x]=self.find(self.parents[x])\n      return self.parents[x]\n\n  def union(self, x, y):\n    x=self.find(x)\n    y=self.find(y)\n    if x==y:\n      return\n    if self.parents[x]>self.parents[y]:\n      x,y=y,x\n    self.parents[x]+=self.parents[y]\n    self.parents[y]=x\n    \n  def size(self, x):\n    return -self.parents[self.find(x)]\n\n  def same(self, x, y):\n    return self.find(x)==self.find(y)\n\n  def members(self, x):\n    root=self.find(x)\n    return list(i for i in range(self.n) if self.find(i) == root)\n\n  def roots(self):\n    return list(i for i, x in enumerate(self.parents) if x < 0)\n\n  def group_count(self):\n    return len(self.roots)\n\n  def all_group_members(self):\n    return {r: self.members(r) for r in self.roots()}\n\n  def __str__(self):\n    return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nadj=[]\nN, M = map(int, input().split())\nfor m in range(M):\n  a,b=map(int, input().split())\n  adj.append([a-1,b-1])\n\nans = 0\nfor i in range(M):\n  uf = UnionFind(N)\n  for j in range(M):\n    if i == j:\n      continue\n    uf.union(*adj[j])\n  if len(set(uf.roots()))!=1:\n    ans += 1\nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x): #\u89aa\u3092\u8fd4\u3059\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y): #\u548c\u96c6\u5408\u306e\u751f\u6210\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x): #\u6240\u5c5e\u3059\u308b\u96c6\u5408\u306e\u5927\u304d\u3055\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y): #\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u308b\u304b\u5224\u5b9a\n        return self.find(x) == self.find(y)\n\n    def members(self, x): #\u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u8981\u7d20\u5168\u5217\u6319\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self): #\u96c6\u5408\u306e\u30ea\u30fc\u30c0\u30fc\u5168\u5217\u6319\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self): #\u96c6\u5408\u306e\u6570\n        return len(self.roots())\n\n    def all_group_members(self): #\u8f9e\u66f8\u578b,{(\u30ea\u30fc\u30c0\u30fc\u306e\u756a\u53f7):(\u305d\u306e\u96c6\u5408\u306e\u8981\u7d20\u5168\u5217\u6319)}\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nn,m=map(int,input().split())\nl=[]\nfor i in range(m):\n    l.append(list(map(int,input().split())))\nans=0\nfor i in range(m):\n    a=UnionFind(n)\n    for j in range(m):\n        if i==j:\n            continue\n        a.union(l[j][0]-1,l[j][1]-1)\n    if a.group_count()==2:\n        ans+=1\nprint(ans)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Oct 12 00:49:45 2020\n\n@author: liang\n\"\"\"\nfrom collections import deque\n\ndef isBridge(start, goal):\n    visited = [False]*N\n    q = deque()\n    q.append(start)\n    visited[start] = True\n    while q:\n        cur = q.popleft()\n        if cur == goal:\n            return False\n        for nex in adj[cur]:\n            if not visited[nex]:\n                visited[nex] = True\n                q.append(nex)\n    return True     \n\nN, M = map(int, input().split())\nadj = list()\n\n\nfor i in range(N):\n    adj.append(list())\n\nE = list()\nfor i in range(M):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    E.append((a,b))\n    adj[a].append(b)\n    adj[b].append(a)\nans = 0\nfor e in E:\n    a, b = e\n    adj[a].remove(b)\n    adj[b].remove(a)\n    if isBridge(a,b):\n        ans += 1\n    adj[a].append(b)\n    adj[b].append(a)\nprint(ans)", "from itertools import combinations\n\nclass unionfind:\n    def __init__(self,n):\n        self.par=[i for i in range(n)]\n        self.rank=[1]*n\n\n    def root(self,a):\n        if self.par[a]==a : return a\n        parent=self.root(self.par[a])\n        self.par[a]=parent\n        return parent\n\n    def unite(self,a,b):\n        ra,rb=self.root(a),self.root(b)\n        if ra==rb : return\n        if self.rank[ra]>self.rank[rb]:\n            ra,rb=rb,ra\n        self.par[rb]=ra\n        self.rank[ra]+=1\n\n    def same(self,a,b):\n        return self.root(a)==self.root(b)\n\n\ndef main():\n    n,m=map(int,input().split())\n    edges=[tuple(map(int,input().split())) for _ in range(m)]\n\n    sm=0\n    for e_remove in edges:\n        uf=unionfind(n)\n        for e in edges:\n            if e==e_remove : continue\n            uf.unite(e[0]-1,e[1]-1)\n\n        for a in combinations(range(n),2):\n            if not uf.same(a[0],a[1]):\n                break\n        else : continue\n        sm+=1\n\n    print(sm)\n\nmain()", "N,M = map(int,input().split())\ns = [[] for i in range(N)]\nm = []\nfor i in range(M):\n    a,b = map(int,input().split())\n    s[a-1].append(b)\n    s[b-1].append(a)\n    m.append([a,b])\nans = 0\nfrom collections import deque\nimport copy\nd = deque()\nfor i in range(M):\n    n = [0] * N\n    a = m[i][0]\n    b = m[i][1]\n    c = s[a-1].copy()\n    c.remove(b)\n    d.append(c)\n    n[a-1] = 1\n    while len(d) > 0:\n        e = d.popleft()\n        for j in e:\n            if n[j-1] == 0:\n                n[j-1] = 1\n                d.append(s[j-1])\n    if 0 in n:\n        ans += 1\nprint(ans)", "def root(i):\n    if par[i] < 0:\n        return i\n    else:\n        return root(par[i])\n\ndef size(a):\n    return -par[root(a)]\n\ndef union(a,b):\n    a = root(a)\n    b = root(b)\n    if a == b:#\u89aa\u304c\u7b49\u3057\u3044\n        return False\n    if size(a) < size(b):#\u30b5\u30a4\u30ba\u304c\u5927\u304d\u3044\u65b9\u306b\u7e4b\u3052\u308b\n        a,b = b,a\n    par[a] += par[b]\n    par[b] = a\n    return True\n\nn,m = map(int,input().split())\nbridge = []\nfor i in range(m):\n    bridge.append([int(j)-1 for j in input().split()])\nans = 0\nfor i in range(m):\n    par = [-1 for _ in range(n)]\n    for j in range(m):\n        if j != i:\n            union(bridge[j][0],bridge[j][1])\n    cnt = [ i for i in par if i < 0]\n    if len(cnt) > 1:\n        ans += 1\nprint(ans)", "class UnionFind():\n    def __init__(self,N):\n        self.par=[-1]*N\n    \n    def unite(self,x,y):\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return False\n        if self.par[x] > self.par[y]:\n            x,y = y,x\n        self.par[x] += self.par[y]\n        self.par[y] = x\n        return True\n    \n    def root(self,x):\n        if self.par[x]<0:\n            return x\n        self.par[x] = self.root(self.par[x])\n        return self.par[x]\n    \n    def size(self,x):\n        return -self.par[self.root(x)]\n\nN,M = map(int,input().split())\nEdge = []\nfor _ in range(M):\n    u,v = map(int,input().split())\n    Edge.append((u-1,v-1))\n\nans = 0\n\nfor e in Edge:\n    uf = UnionFind(N)\n    for _e in Edge:\n        if e == _e:\n            continue\n        uf.unite(_e[0],_e[1])\n    if uf.size(0) != N:\n        ans += 1\n\nprint(ans)", "import copy\nimport sys\nsys.setrecursionlimit(10**7)\n\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nside = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    a -= 1; b -= 1\n    G[a].append(b)\n    G[b].append(a)\n    side.append((a,b))\n\ndef dfs(v,G):\n    seen[v] = True\n    for next_v in G[v]:\n        if seen[next_v] == True:\n             continue\n        dfs(next_v,G)\n\nbridge = 0\n# \u5404\u8fba\u3092\u53d6\u308a\u9664\u304f\nfor a,b in side:\n    Gc = copy.deepcopy(G)\n    Gc[a].remove(b)\n    Gc[b].remove(a)\n    seen = [False]*N\n    cnt = 0\n    # \u9023\u7d50\u6210\u5206\u306e\u30ab\u30a6\u30f3\u30c8\n    for s in range(N):\n        if seen[s] == True:\n            continue\n        cnt += 1\n        dfs(s,Gc)\n    # \u9023\u7d50\u6210\u5206\u304c 2 \u500b\u4ee5\u4e0a\u306a\u3089\u305d\u306e\u8fba\u306f\u6a4b    \n    if cnt>=2:\n        bridge += 1\nprint(bridge)", "import copy\nfrom collections import deque\nN,M = map(int,input().split())\nlsside = [[] for i in range(N+1)]\nlsline = []\nfor i in range(M):\n    a,b = map(int,input().split())\n    lsside[a].append(b)\n    lsside[b].append(a)\n    lsline.append([a,b])\n\nans = 0\nlsloop = []\nfor i in range(M):\n    graph = copy.deepcopy(lsside)\n    a = lsline[i][0]\n    b = lsline[i][1]\n    graph[a].remove(b)\n    graph[b].remove(a)\n    used = [False for i in range(N+1)]\n    ii = 1\n    d = deque()\n    d.append(a)\n    used[a] = True\n    while d:\n        v = d.popleft()\n        for i in graph[v]:\n            if used[i]:\n                continue\n            ii += 1\n            d.append(i)\n            used[i] = True\n    lsloop.append(ii)\nans = M - lsloop.count(N)\nprint(ans)", "from collections import deque\nN, M = map(int, input().split())\n\nh = [[]*N for _ in range(N)]\nAB = []\n\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    h[a].append(b)\n    h[b].append(a)\n    AB.append([a, b])\n\nans = 0\n\nfor i in range(M):\n    a, b = AB[i]\n    h[a].remove(b)\n    h[b].remove(a)\n    \n    fl = [False]*N\n\n    q = deque([0])\n    while q:\n        t = q.popleft()\n        if fl[t]:\n            continue\n        fl[t] = True\n        for tt in h[t]:\n            q.append(tt)\n    \n    if not all(fl):\n        ans += 1\n\n    h[a].append(b)\n    h[b].append(a)\n\nprint(ans)", "import queue\nn, m = list(map(int, input().split()))\nroute = [[] for _ in range(n)]\nvals = []\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    route[a-1].append(b-1)\n    route[b-1].append(a-1)\n    vals.append([a-1, b-1])\nans = m\nfor i in range(m):\n    route2 = set()\n    q = queue.Queue()\n    q.put(0)\n    route[vals[i][0]].remove(vals[i][1])\n    route[vals[i][1]].remove(vals[i][0])\n    while not q.empty():\n        a = q.get()\n        if not a in route2:\n            route2.add(a)\n            for j in route[a]:\n                q.put(j)\n        if len(route2) == n:\n            ans -= 1\n            break\n    route[vals[i][0]].append(vals[i][1])\n    route[vals[i][1]].append(vals[i][0])\nprint(ans)\n        \n", "class union_find():\n    def __init__(self,n):\n        self.n=n\n        ##\u89aa\u8981\u7d20\u306e\u30ce\u30fc\u30c9\u756a\u53f7\u3092\u683c\u7d0d\u3002par[x]==x\u306e\u3068\u304d\u305d\u306e\u30ce\u30fc\u30c9\u306f\u6839\n        ##\u89aa\u3068\u306f\u305d\u306e\u4e0a\u306b\u30ce\u30fc\u30c9\u306a\u3057\uff01\uff01\u3000\n        self.par=[i for i in range(n+1)]\n        self.rank=[0]*(n+1)\n\n    def find(self,x):\n        if self.par[x]==x:\n            return x\n        else:\n            self.par[x]=self.find(self.par[x])\n            return self.par[x]\n\n    def union(self,x,y):\n        x=self.find(x)\n        y=self.find(y)\n\n        ##\u6728\u306e\u9ad8\u3055\u3092\u6bd4\u8f03\u3057\u3001\u4f4e\u3044\u65b9\u304b\u3089\u9ad8\u3044\u65b9\u3078\u8fba\u3092\u306f\u308b\n\n        if self.rank[x]<self.rank[y]:\n          self.par[x]=y\n        else:\n          self.par[y]=x\n          ##\u540c\u3058\u306a\u3089\u7247\u65b9\u3092\u4f38\u3070\u3059\n          if self.rank[x]==self.rank[y]:\n            self.rank[y]+=1\n\n    def same(self,x,y):\n        return self.find(x) == self.find(y)\n      \nn,m=map(int,input().split())\nuf=union_find(n)\nans=0\ns=[]\nfor _ in range(m):\n  a=list(map(int,input().split()))\n  s.append(a)\n  uf.union(a[0],a[1])\n  \n  \n\nfor e in range(m):\n  uf1=union_find(n)\n  ch=0\n  for d in range(m):\n    if d!=e:\n      uf1.union(s[d][0],s[d][1])\n      \n  for i in range(1,n):\n    for j in range(i+1,n+1):\n      if not uf1.same(i,j):\n        ch+=1\n  if ch>0:\n    ans+=1\n\n    \nprint(ans)", "# Union Find\n# x\u306e\u6839\u3092\u6c42\u3081\u308b\ndef find(x):\n    if par[x] < 0:\n        return x\n    else:\n        par[x] = find(par[x])\n        return par[x]\n\n\n# x\u3068y\u306e\u5c5e\u3059\u308b\u96c6\u5408\u306e\u4f75\u5408\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n\n    if x == y:\n        return False\n    else:\n        # x < y \u306b\u3059\u308b\n        if par[x] > par[y]:\n            x, y = y, x\n        par[x] += par[y]\n        par[y] = x\n        return True\n\n\n# \u6839\u306e\u500b\u6570\u3092\u8fd4\u3059\ndef group_count():\n    return sum(x < 0 for x in par)\n\n\nn, m = map(int, input().split())\nl = []\nfor _ in range(m):\n    l.append(tuple(map(int, input().split())))\n\nans = 0\nfor j in range(m):\n    par = [-1] * n\n    for i, ab in enumerate(l):\n        if i != j:\n            unite(ab[0] - 1, ab[1] - 1)\n    if group_count() == 2:\n        ans += 1\n\nprint(ans)", "n , m = list(map(int, input().split()))\nc = [[0]*n for i in range(n)]\nfor i in range(m):\n    a , b = list(map(int, input().split()))\n    c[a-1][b-1]=1\n    c[b-1][a-1]=1\nans = 0\nfor k in range(n):\n    for i in range(n):\n        if sum(c[i])==1:\n            ans+=1\n            for j in range(n):\n                if c[i][j]==1:\n                    c[i][j]=0\n                    c[j][i]=0\nprint(ans)\n", "from networkx import *\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(m)]\ng = Graph(a)\nprint(len(tuple(bridges(g))))", "from collections import deque\n\nn, m = list(map(int, input().split()))\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    graph[u].append([i,v])\n    graph[v].append([i,u])\n    \ncnt = 0\nfor i in range(m):\n    d = deque()\n    d.append(0)\n    visited = [False]*n\n    visited[0] = True\n    while d:\n        cf = d.pop()\n        for ci, ct in graph[cf]:\n            if ci == i:\n                continue\n            if not visited[ct]:\n                d.append(ct)\n                visited[ct] = True\n    if False in visited:\n        cnt += 1\nprint(cnt)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN, M = list(map(int, input().split()))\nuf = UnionFind(N)\nab_list = []\nans =0\nfor i in range(M):\n    a,b = list(map(int, input().split()))\n    a, b = a-1, b-1\n    ab_list.append([a, b])\n\nfor i in range(M):\n    uf = UnionFind(N)\n    for j in range(M):\n        if i == j:\n            continue\n        uf.union(ab_list[j][0], ab_list[j][1])\n    if not uf.same(ab_list[i][0], ab_list[i][1]):\n        ans += 1\nprint(ans)\n", "n, m = map(int, input().split())\ng = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    g[a].append(b)\n    g[b].append(a)\n\ndef lowlink(g, root=0):\n    n = len(g)\n    order = [n]*n\n    low = [n]*n\n\n    s = [root]\n    cnt = 1\n    par = [-1]*n\n    seq = []\n    while s:\n        v = s.pop()\n        if order[v] != n:\n            continue\n        order[v] = cnt\n        seq.append(v)\n        low[v] = cnt\n        cnt += 1\n        for u in g[v]:\n            if order[u] < cnt:\n                if par[v] != u:\n                    low[v] = min(low[v], order[u])\n                    continue\n            else:\n                par[u] = v\n                s.append(u)\n    child = [[] for _ in range(n)]\n    for v in range(n):\n        if par[v] != -1:\n            child[par[v]].append(v)\n    seq.reverse()\n    for v in seq:\n        for u in child[v]:\n            low[v] = min(low[v], low[u])\n    # bridge\n    bridge = []\n    for p in range(n):\n        for c in child[p]:\n            if order[p] < low[c]:\n                bridge.append((p, c))\n\n    # articulation points\n    AP = []\n    for v in range(n):\n        if v == root:\n            if len(child[v]) >= 2:\n                AP.append(v)\n        else:\n            for c in child[v]:\n                if order[v] <= low[c]:\n                    AP.append(v)\n                    break\n    return AP, bridge\n\n_, bridge = lowlink(g, 0)\nprint(len(bridge))", "class UnionFind:\n    def __init__(self, n):\n        self._n = n\n        self._table = [-1]*n\n\n    def _root(self, x):\n        stack = []\n        while self._table[x] >= 0:\n            stack.append(x)\n            x = self._table[x]\n        for y in stack:\n            self._table[y] = x\n        return x\n    \n    def unite(self, x, y):\n        x, y = self._root(x), self._root(y)\n        if x == y:\n            return\n        if x > y:\n            x, y = y, x\n        self._table[x] += self._table[y]\n        self._table[y] = x\n    \n    def same(self, x, y):\n        return self._root(x) == self._root(y)\n\n    def count_members(self, x):\n        return -self._table[self._root(x)]\n    \n    def count_groups(self):\n        return len({self._root(i) for i in range(self._n)})\n    \n    def __str__(self):\n        return str([self._root(i) for i in range(self._n)])\n    \n    def __repr__(self):           \n        return repr([self._root(i) for i in range(self._n)])\n\nn, m, *AB = map(int, open(0).read().split())\nans = 0\nfor i in range(m):\n    uf = UnionFind(n)\n    for j, (a, b) in enumerate(zip(AB[::2], AB[1::2])):\n        if i == j:\n            continue\n        uf.unite(a-1, b-1)\n    ans += uf.count_groups() != 1\nprint(ans)", "class UnionFind():\n  def __init__(self,n):\n    self.parents=[-1]*n\n  \n  def find(self,x):\n    if self.parents[x]<0:\n      return x\n    self.parents[x]=self.find(self.parents[x])\n    return self.parents[x]\n  \n  def union(self,x,y):\n    x = self.find(x)\n    y = self.find(y)\n    if x==y:\n      return\n    \n    if self.parents[x]>self.parents[y]:\n      x,y=y,x\n    \n    self.parents[x]+=self.parents[y]\n    self.parents[y]=x\n\nN,M=map(int,input().split())\nans=0\nA=[]\nB=[]\n\nfor _ in range(M):\n  a,b=map(int,input().split())\n  A.append(a)\n  B.append(b)\n  \nfor i in range(M):\n  uf=UnionFind(N+1)\n  for j in range(M):\n    if i==j:\n      continue\n    uf.union(A[j],B[j])\n  else:\n    if abs(min(uf.parents[1:]))!=N:\n      ans+=1\nprint(ans)", "import networkx as nx\n\nn, m, *AB = map(int, open(0).read().split())\nG = nx.Graph()\nG.add_edges_from(zip(AB[::2], AB[1::2]))\nprint(len(list(nx.bridges(G))))", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\nfrom collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\n\ndef solve():\n    N, M = MI()\n    V = [[] for _ in range(N)]\n    E = []\n    for i in range(M):\n        a, b = MI1()\n        V[a].append(b)\n        V[b].append(a)\n        E.append((a, b))\n\n    ans = 0\n    for a, b in E:\n        used = [0] * N\n        flag = True\n        q = deque([a])\n        used[a] = 1\n        while q:\n            cur = q.popleft()\n\n            for nv in V[cur]:\n                if (a, b) == (cur, nv) or (a, b) == (nv, cur):\n                    continue\n\n                if used[nv]:\n                    continue\n\n                if nv == b:\n                    flag = False\n                    q = []\n                    break\n\n                q.append(nv)\n                used[nv] = 1\n            # print(a, b, q)\n\n        if flag:\n            ans += 1\n    print(ans)\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    \"\"\"Union Find class.\n\n    \"Path compression\" and \"Union by rank\" are used.\n\n    References:\n        <https://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n    \"\"\"\n\n    def __init__(self, N):\n        self.N = N\n        self.__make_set()\n\n    def __make_set(self):\n        self._parent = list(range(self.N + 1))\n        self._rank = [0] * (self.N + 1)\n        self._size = [1] * (self.N + 1)\n\n    def find(self, x):\n        if self._parent[x] != x:\n            self._parent[x] = self.find(self._parent[x])\n        return self._parent[x]\n\n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n\n        if x_root == y_root:\n            return\n\n        x_rank = self._rank[x_root]\n        y_rank = self._rank[y_root]\n        if x_rank > y_rank:\n            self._parent[y_root] = x_root\n            self._size[x_root] += self._size[y_root]\n        elif x_rank < y_rank:\n            self._parent[x_root] = y_root\n            self._size[y_root] += self._size[x_root]\n        else:\n            self._parent[y_root] = x_root\n            self._rank[x_root] += 1\n            self._size[x_root] += self._size[y_root]\n\n    def same_set(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        return self._size[self.find(x)]\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    a = [None] * M\n    b = [None] * M\n    for i in range(M):\n        a[i], b[i] = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(M):\n        uf = UnionFind(N)\n        for j in range(M):\n            if j == i:\n                continue\n            uf.union(a[j], b[j])\n        if not uf.same_set(a[i], b[i]):\n            ans += 1\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class UnionFind():    \n    def __init__(self, n):\n        self.n = n\n        self.root = [-1] * n\n        self.rnk = [0] * n\n        \n    def findRoot(self, x):\n        if self.root[x] < 0:\n            return x\n        else:\n            self.root[x] = self.findRoot(self.root[x])  #; print('root[x]', self.root[x])\n            return self.root[x]\n\n    def unite(self, x, y):\n        x = self.findRoot(x)\n        y = self.findRoot(y)\n        if x == y:\n            return \n        elif self.rnk[x] > self.rnk[y]:\n            self.root[y] = x\n        else:\n            self.root[x] = y\n            if self.rnk[x] == self.rnk[y]:\n                self.rnk[y] += 1\n\n    def isSame(self, x, y):\n        return self.findRoot(x) == self.findRoot(y)\n\n\nN, M =  map(int, input().split())\nedge = [tuple(map(int, input().split())) for _ in range(M)]  #;print(edge)\n\ncnt = 0\nfor i in range(M):\n    uf = UnionFind(N+1)\n    for j in range(M):\n        if j != i:\n            uf.unite(edge[j][0], edge[j][1])\n    #print(i, edge[i][0], edge[i][1], uf.isSame(edge[i][0], edge[i][1]))\n    if not uf.isSame(edge[i][0], edge[i][1]):\n        cnt += 1\nprint(cnt)", "from collections import deque, defaultdict\nimport sys\nsys.setrecursionlimit(2**20)\nclass LowLink:\n    \"\"\"\n    \u4e0e\u3048\u3089\u308c\u305f\u30b0\u30e9\u30d5\u306e\u95a2\u7bc0\u70b9\u3068\u6a4b\u3092\u6c42\u3081\u308b\n    Attributes:\n    size:\u30b0\u30e9\u30d5\u306e\u9802\u70b9\n    pre:oreorder\u3067\u306e\u8a2a\u554f\u9806\n    low: ###1. prenum[u]\n         ###2.G\u306eBackEdge(u,v)\u304c\u5b58\u5728\u3059\u308b\u5834\u5408prenum[v]\n         ###3.u\u3092\u3059\u3079\u3066\u306e\u5b50child\u306b\u5bfe\u3057\u3066lowest[child]\n    \"\"\"\n    def __init__(self, v):\n        self.size = len(v) + 1\n        self.v = v\n        self.pre = [None]*self.size\n        self.low = [None]*self.size\n        self.articulations = []\n        self.bridges = []\n        for x in range(self.size):\n            if self.pre[x] is None:\n                self.cnt = 0\n                self.dfs(x, None)\n    \n    def dfs(self, x, prev):\n        self.pre[x] = self.low[x] = self.cnt\n        self.cnt += 1\n        is_articulation = False\n        n = 0\n        for y in self.v[x]:\n            if self.pre[y] is None:\n                n += 1\n                low_y = self.dfs(y, x)\n                if low_y < self.low[x]:\n                    self.low[x] = low_y\n                if self.pre[x] <= low_y:\n                    if self.pre[x]:\n                        is_articulation = True\n                    if self.pre[x] < low_y:\n                        self.bridges.append(\n                            (min(x,y), max(x, y))\n                        )\n            else:\n                if y != prev and self.pre[y] < self.low[x]:\n                    self.low[x] = self.pre[y]\n        if prev is None and n > 1:\n            is_articulation = True\n        \n        if is_articulation:\n            self.articulations.append(x)\n        \n        return self.low[x]\n\ndef solve():\n    V, E = map(int, input().split())\n    G = defaultdict(lambda: [])\n    for _ in range(E):\n        s, t= map(int, input().split())\n        G[s].append(t)\n        G[t].append(s)\n    \n    #initialize\n    lowlink = LowLink(G)\n    #bridges\n    bridges = lowlink.bridges\n    print(len(bridges))\n \ndef __starting_point():\n    solve()\n__starting_point()", "# \u5e45\u512a\u5148\u63a2\u7d22\u3067\u9023\u7d50\u6210\u5206\u3092\u6c42\u3081\u308b\u30d7\u30ed\u30b0\u30e9\u30e0\nfrom collections import deque\n\n# n = int(input())# \u30ce\u30fc\u30c9\u306e\u6570\nn, m = map(int, input().split())\n\nl = [list(map(int, input().split())) for _ in range(m)]\n\nans = 0\n\n\ndef bfs(start_node, color_id):  # start_node\u306f\u63a2\u7d22\u306e\u958b\u59cb\u70b9\n    nonlocal color, d\n    q = deque([start_node])\n    d[start_node] = 0\n    color[start_node] = color_id\n    while len(q) != 0:\n        u = q.popleft()\n        for v in adjl[u]:\n            if color[v] == NIL:\n                d[v] = d[u]+1\n                color[v] = color_id\n                q.append(v)\n\n\n#print(l)\nfor k in range(1, m+1):\n\n    # \u96a3\u63a5\u30ea\u30b9\u30c8\u3067\u683c\u7d0d\u3059\u308b\n    adjl = [[] for _ in range(n+1)]\n    for i in range(1, m+1):  # \u96a3\u63a5\u95a2\u4fc2\u3092\u53d7\u3051\u53d6\u308b\n        if i == k:\n            continue\n        s, t = l[i-1]\n        adjl[s].append(t)\n        adjl[t].append(s)\n\n    NIL = -1  # \u672a\u767a\u898b\u3092\u793a\u3059\u5024\n    d = [-1 for i in range(n+1)]  # \u9802\u70b91\u304b\u3089\u306e\u8ddd\u96e2\u3092\u683c\u7d0d\u3059\u308b\u30ea\u30b9\u30c8\n    color = [NIL for i in range(n+1)]  # \u672a\u5230\u9054\u304b\u3092\u793a\u3059\u30ea\u30b9\u30c8\n\n    #print(adjl)\n\n    color_id = 0\n    for u in range(1, n+1):  # node\u5168\u3066\u304b\u3089\u30b9\u30bf\u30fc\u30c8\u3059\u308b\n        if color[u] == NIL:\n            color_id += 1\n            bfs(u, color_id)\n\n    #print(color)\n    if len(set(color)) >= 3:\n        ans += 1\nprint(ans)", "def FindParent(X):\n    if Parent[X]==X:\n        return X\n    else:\n        Parent[X] = FindParent(Parent[X])\n        return Parent[X]\n\ndef CheckParent(X,Y):\n    return FindParent(X)==FindParent(Y)\n\ndef UniteParent(X,Y):\n    X = FindParent(X)\n    Y = FindParent(Y)\n    if X==Y:\n        return 0\n    if Rank[X]<Rank[Y]:\n        Parent[X] = Y\n    else:\n        Parent[Y] = X\n        if Rank[X]==Rank[Y]:\n            Rank[X] += 1\n\nimport copy\nN,M = (int(T) for T in input().split())\nList = [[] for TM in range(0,M)]\nfor TM in range(0,M):\n    List[TM] = [int(T) for T in input().split()]\n    \nCount = 0\nfor TM in range(0,M):\n    ListCopy = copy.deepcopy(List)\n    del ListCopy[TM]\n    \n    Parent = [I for I in range(N+1)]\n    Rank = [0]*(N+1)\n    for TTM in range(0,M-1):\n        UniteParent(ListCopy[TTM][0],ListCopy[TTM][1])\n\n    if not CheckParent(List[TM][0],List[TM][1]):\n        Count += 1\nprint(Count)", "class UnionFind: #\u5f15\u6570\u306f\u9802\u70b9\u306e\u6570\u30011\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    def __init__(self, n):\n        self.parents = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n\n    # \u691c\u7d22\n    def find(self, x):\n        if self.parents[x] == x:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    # \u4f75\u5408\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if self.rank[x] < self.rank[y]:\n            self.parents[x] = y\n        else:\n            self.parents[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    # \u540c\u3058\u96c6\u5408\u306b\u5c5e\u3059\u308b\u304b\u5224\u5b9a\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n\n\ndef __starting_point():\n    N, M = list(map(int, input().split()))\n    bridges = [tuple(map(int, input().split())) for _ in range(M)]\n\n    count = 0\n    for i in range(M):\n        union_find = UnionFind(N)\n        for j in range(M):\n            if i == j:\n                continue\n            a, b = bridges[j]\n            union_find.union(a, b)\n\n        for j in range(1, N):\n            if union_find.find(j) != union_find.find(j+1):\n                count += 1\n                break\n\n    print(count)\n        \n    \n\n\n\n\n\n\n\n__starting_point()", "#\n# abc075 c\n#\nimport sys\nfrom io import StringIO\nimport unittest\nfrom collections import deque\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"7 7\n1 3\n2 7\n3 4\n4 5\n4 6\n5 6\n6 7\"\"\"\n        output = \"\"\"4\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"3 3\n1 2\n1 3\n2 3\"\"\"\n        output = \"\"\"0\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"6 5\n1 2\n2 3\n3 4\n4 5\n5 6\"\"\"\n        output = \"\"\"5\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    N, M = list(map(int, input().split()))\n    AB = [list(map(int, input().split())) for _ in range(M)]\n\n    ans = 0\n    for i in range(M):\n        Target = AB[:]\n        Target.pop(i)\n\n        G = [[i+1, 0] for i in range(N)]\n        for ab in Target:\n            a, b = ab\n            G[a-1][1] += 1\n            G[b-1][1] += 1\n            G[a-1].append(b)\n            G[b-1].append(a)\n\n        F = [False] * N\n        Q = deque()\n        Q.append(1)\n        F[0] = True\n\n        while Q:\n            p = Q.pop()\n            if G[p-1][1] == 0:\n                continue\n\n            for np in G[p-1][2:]:\n                if F[np-1]:\n                    continue\n                Q.append(np)\n                F[np-1] = True\n\n        for f in F:\n            if f == False:\n                ans += 1\n                break\n\n    print(ans)\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "from typing import List, Tuple\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    g = []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        g.append((a, b))\n    print((br(n, m, g)))\n\n\ndef br(n: int, m: int, g: List[Tuple[int, int]]):\n    ret = 0\n    for i in range(m):\n        v = set()\n        w = [1]\n        while w:\n            now = w.pop()\n            v.add(now)\n            for j, node in enumerate(g):\n                if j == i:\n                    continue\n                if node[0] == now and node[1] not in v:\n                    w.append(node[1])\n                elif node[1] == now and node[0] not in v:\n                    w.append(node[0])\n        if len(v) != n:\n            ret += 1\n    return ret\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from typing import List, Tuple\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    g = []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        g.append((a, b))\n    print((bb(n, m, g)))\n\n\ndef bb(n: int, m: int, g: List[Tuple[int, int]]):\n    ret = 0\n    for i in range(m):\n        v = set()\n        w = [1]\n        while w:\n            now = w.pop()\n            v.add(now)\n            for j, node in enumerate(g):\n                if j == i:\n                    continue\n                if node[0] == now and node[1] not in v:\n                    w.append(node[1])\n                elif node[1] == now and node[0] not in v:\n                    w.append(node[0])\n        if len(v) != n:\n            ret += 1\n    return ret\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def FindParent(X):\n    if Parent[X]==X:\n        return X\n    else:\n        Parent[X] = FindParent(Parent[X])\n        return Parent[X]\n\ndef UniteParent(X,Y):\n    X = FindParent(X)\n    Y = FindParent(Y)\n    if X==Y:\n        return 0\n    if Rank[X]<Rank[Y]:\n        Parent[X] = Y\n    else:\n        Parent[Y] = X\n        if Rank[X]==Rank[Y]:\n            Rank[X] += 1\n\nimport copy\nN,M = (int(T) for T in input().split())\nList = [[] for TM in range(0,M)]\nfor TM in range(0,M):\n    List[TM] = [int(T) for T in input().split()]\n    \nCount = 0\nfor TM in range(0,M):\n    ListCopy = copy.deepcopy(List)\n    del ListCopy[TM]\n    \n    Parent = [I for I in range(N+1)]\n    Rank = [0]*(N+1)\n    for TTM in range(0,M-1):\n        UniteParent(ListCopy[TTM][0],ListCopy[TTM][1])\n    for TN in range(1,N+1):\n        FindParent(TN)\n    if len(set(Parent[1:]))>1:\n        Count += 1\nprint(Count)", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parent = [i for i in range(self.n)]\n    self.rank = [0] * self.n\n  \n  def find_root(self, x):\n    if self.parent[x] == x:\n      return x\n    else:\n      self.parent[x] = self.find_root(self.parent[x])\n      return self.parent[x]\n  \n  def unite(self, x, y):\n    rx = self.find_root(x)\n    ry = self.find_root(y)\n    if rx == ry:\n      return\n    if self.rank[rx] < self.rank[ry]:\n      self.parent[rx] = ry\n    else:\n      self.parent[ry] = rx\n      if self.rank[rx] == self.rank[ry]:\n        self.rank[rx] += 1\n  \n  def is_same(self, x, y):\n    return self.find_root(x) == self.find_root(y)\n\nN, M = map(int, input().split())\nedge = []\nbridge = 0\nfor _ in range(M):\n  e = list(map(lambda x: int(x)-1, input().split()))\n  edge.append(e)\n\nfor i in range(M):\n  uf = UnionFind(N)\n  for j in range(M):\n    if j == i:\n      continue\n    uf.unite(edge[j][0], edge[j][1])\n  if uf.find_root(edge[i][0]) != uf.find_root(edge[i][1]):\n    bridge += 1\n\nprint(bridge)", "N, M = (int(x) for x in input().split())\nedge = [tuple(int(x) for x in input().split()) for _ in range(M)]\n\nimport numpy as np\nfrom scipy.sparse.csgraph import floyd_warshall\nINF = 100\ntmpl_graph = [[INF if i != j else 0 for j in range(N)] for i in range(N)]\n\nans = 0\nfor E in edge:\n    edgeWithoutE = edge.copy()\n    edgeWithoutE.remove(E)\n    graph = np.array(tmpl_graph)\n    for x in edgeWithoutE:\n        graph[x[0]-1,x[1]-1] = 1\n        graph[x[1]-1,x[0]-1] = 1\n    graph = floyd_warshall(graph,directed=False)\n    if len(graph[graph == 100]) > 0:\n        ans += 1\nprint(ans)", "#https://atcoder.jp/contests/abc075/submissions/15509548\n\nn, m = list(map(int, input().split()))\ng = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a, b = a-1, b-1\n    g[a].append(b)\n    g[b].append(a)\n\ndef lowlink(g, root=0):\n    n = len(g)\n    order = [n]*n\n    low = [n]*n\n\n    s = [root]\n    cnt = 0\n    par = [-1]*n\n    seq = []\n    while s:\n        v = s.pop()\n        if order[v] != n:\n            continue\n        order[v] = cnt\n        seq.append(v)\n        low[v] = cnt\n        cnt += 1\n        for u in g[v]:\n            if order[u] < cnt:\n                if par[v] != u:\n                    low[v] = min(low[v], order[u])\n                    continue\n            else:\n                par[u] = v\n                s.append(u)\n    child = [[] for _ in range(n)]\n    for v in range(n):\n        if par[v] != -1:\n            child[par[v]].append(v)\n    seq.reverse()\n    for v in seq:\n        for u in child[v]:\n            low[v] = min(low[v], low[u])\n    # bridge\n    bridge = []\n    for p in range(n):\n        for c in child[p]:\n            if order[p] < low[c]:\n                bridge.append((p, c))\n\n    # articulation points\n    AP = []\n    for v in range(n):\n        if v == root:\n            if len(child[v]) >= 2:\n                AP.append(v)\n        else:\n            for c in child[v]:\n                if order[v] <= low[c]:\n                    AP.append(v)\n                    break\n    return AP, bridge\n\n_, bridge = lowlink(g, 0)\nprint((len(bridge)))\n", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\n# from collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\n\n\"\"\"\nhttps://note.nkmk.me/python-union-find/\n\u7d20\u96c6\u5408\u30c7\u30fc\u30bf\u69cb\u9020\n\n:parameter\nunion(x, y): 2\u3064\u306e\u96c6\u5408\u3092\u4e00\u3064\u306b\u4f75\u5408\u3059\u308b\nfind(x): x\u304c\u3069\u306e\u96c6\u5408\u306b\u5c5e\u3057\u3066\u3044\u308b\u304b\u3092\u5224\u5b9a\u3059\u308b\nsize(x): \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\uff08\u8981\u7d20\u6570\uff09\u3092\u8fd4\u3059\nsame(x, y): \u8981\u7d20x, y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u304b\u3069\u3046\u304b\u3092\u8fd4\u3059\nmembers(x): \u8981\u7d20x\u304c\u5c5e\u3059\u308b\u30b0\u30eb\u30fc\u30d7\u306b\u5c5e\u3059\u308b\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\nroots(): \u5168\u3066\u306e\u6839\u306e\u8981\u7d20\u3092\u30ea\u30b9\u30c8\u3067\u8fd4\u3059\ngroup_count(): \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059\nall_group_members(): \u8f9e\u66f8\u3092\u8fd4\u3059\u3002\u3000key = \u30eb\u30fc\u30c8\u8981\u7d20, value = \u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8\n__str__(): print()\u3067\u306e\u8868\u793a\u7528\u3002\u30eb\u30fc\u30c8\u8981\u7d20: [\u305d\u306e\u30b0\u30eb\u30fc\u30d7\u306b\u542b\u307e\u308c\u308b\u8981\u7d20\u306e\u30ea\u30b9\u30c8]\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3059\n\"\"\"\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def all_group_count(self):\n        return [self.size(r) for r in self.roots()]\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\ndef solve():\n    N, M = MI()\n    E = []\n    for i in range(M):\n        a, b = MI1()\n        E.append((a, b))\n\n    ans = 0\n    for a, b in E:\n        uf = UnionFind(N)\n        for v1, v2 in E:\n            if (v1, v2) == (a, b):\n                continue\n            uf.union(v1, v2)\n        # print(uf.group_count())\n        if uf.group_count() > 1:\n            ans += 1\n    print(ans)\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "n, m = list(map(int, input().split()))\nadj = [[0]*(n+1) for _ in range(n+1)] #idx; 1~n\nedges = [tuple(map(int, input().split())) for _ in range(m)]\ncnt = 0\n\nfor e in edges:\n    x, y = e\n    adj[x][y] = 1\n    adj[y][x] = 1\n\ndef dfs(s):\n        seen[s] = 1\n        for nx in range(1, n+1):\n            if adj[s][nx]:\n                if seen[nx]:\n                    continue\n                dfs(nx)\n                \nfor bridge in edges:\n    bx, by = bridge\n    adj[bx][by] = 0 #\u9053\u3092\u9664\u304f\n    adj[by][bx] = 0\n    seen = [0]*(n+1)\n    dfs(1) #1\u304b\u3089\u6df1\u3055\u512a\u5148\u63a2\u7d22seen\u3092\u57cb\u3081\u308b\n    is_ok = 1\n    if any(seen[i] == 0 for i in range(1, n+1)):\n        is_ok = 0\n    if not is_ok:\n        cnt += 1\n    adj[bx][by] = 1 #\u9053\u3092\u623b\u3059\n    adj[by][bx] = 1\n\nprint(cnt)\n", "import queue\n\nn, m = list(map(int, input().split()))\nam_bm = []\nside_map = dict()\nfor i in range(m):\n    ai, bi = list(map(int, input().split()))\n    if ai not in side_map:\n        side_map[ai] = set()\n        side_map[ai].add(bi)\n    else:\n        side_map[ai].add(bi)\n    if bi not in side_map:\n        side_map[bi] = set()\n        side_map[bi].add(ai)\n    else:\n        side_map[bi].add(ai)\n    am_bm.append((ai, bi))\n\ncounter = 0\nfor i in range(m):\n    a, b = am_bm[i]\n    q = queue.Queue()\n    q.put(1)\n    node_passed = set()\n    node_passed.add(1)\n    while not q.empty():\n        a_tmp = q.get()\n        for b_tmp in side_map[a_tmp]:\n            if a_tmp == a and b_tmp == b or a_tmp == b and b_tmp == a:\n                pass\n            elif b_tmp not in node_passed:\n                q.put(b_tmp)\n                node_passed.add(b_tmp)\n    if len(node_passed) == n:\n        counter += 1\nprint((m - counter))\n", "# \u3069\u306e2\u70b9\u9593\u3082\u8fba\u3092\u8fbf\u308c\u3070\u5230\u9054\u3067\u304d\u308b\u3000\uff1d\u3000\u9023\u7d50\u30b0\u30e9\u30d5\n# \u3069\u3046\u9811\u5f35\u3063\u3066\u3082\u305f\u3069\u308a\u7740\u3051\u306a\u3044\u3000\uff1d\u3000\u975e\u9023\u7d50\u30b0\u30e9\u30d5\nN, M = list(map(int, input().split()))\nAB = [list(map(int, input().split())) for i in range(M)]\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\n\n# 1\u8fba\u3092\u7701\u3044\u3066UnionFind\u3057\u305f\u3068\u304d\u3001\u30b0\u30eb\u30fc\u30d7\u6570\u304c\uff12\u4ee5\u4e0a\u306b\u306a\u3063\u305f\u3089\u305d\u306e\u8fba\u306f\u300c\u6a4b\u300d\nans = 0\nfor i in range(M):\n    u = UnionFind(N)\n    for j, ab in enumerate(AB):\n        if i == j:\n            continue\n        else:\n            a, b = ab\n            u.union(a - 1, b - 1)\n    if u.group_count() != 1:\n        ans += 1\n\nprint(ans)\n", "n, m = list(map(int, input().split()))\nedges = [[] for _ in range(n)]\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n\n    edges[a-1].append(b-1)\n    edges[b-1].append(a-1)\n\nind = 1\nqueue = [0]\nvisitedOrder = {}\nvisited = {}\ncnt = 0\n\nwhile queue:\n    cur = queue[-1]\n\n    if cur not in visited:\n        visited[cur] = ind\n        visitedOrder[cur] = ind\n        ind += 1\n\n    neighbours = False\n    for nei in edges[cur]:\n        if nei not in visited:\n            neighbours = True\n            queue.append(nei)\n            break\n\n    if not neighbours:\n        queue.pop()\n\n        if cur != 0:\n            connected = visited[cur]\n\n            for nei in edges[cur]:\n                if nei != queue[-1]:\n                    connected = min(connected, visited[nei])\n\n            visited[cur] = connected\n            if connected > visitedOrder[queue[-1]]:\n                cnt += 1\n\nprint(cnt)", "def dfs(current):\n    for maps in Graph[current]:\n        if maps in already:\n            continue\n        else:\n            already.append(maps)\n            dfs(maps)\n\nn,m = map(int,input().split())\nans = 0\nEdges = []\nfor _ in range(m):\n    Edges.append([int(j)-1 for j in input().split()])\n\nfor i in range(m):\n    egdes = Edges[0:i]+Edges[i+1:]\n    Graph = [[] for _ in range(n)]\n    for edge in egdes:\n        Graph[edge[0]].append(edge[1])\n        Graph[edge[1]].append(edge[0])\n    already = []\n    dfs(0)\n    if len(already) != n:\n        ans += 1\nprint(ans)", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return list(map(int, input().split()))\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n    n,m = i_map()\n    ab = [i_list() for i in range(m)]\n\n    def dfs(table):\n        visited = [1]\n        que = [1]\n\n        while que != []:\n            now = que[0]\n            del que[0]\n\n            for index, e in enumerate(table[now]):\n                if (e==1) & (index not in visited):\n                    visited.append(index)\n                    que.append(index)\n        if len(visited) == n:\n            return 0\n        else:\n            return 1\n\n    ans = 0\n    for i in range(m):\n        graph = ab.copy()\n        del graph[i]\n        table = [[0]*(n+1) for i in range(n+1)]\n        for a,b in graph:\n            table[a][b] = 1\n            table[b][a] = 1\n\n        ans += dfs(table)\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import networkx as nx\n\nN, M = map(int, input().split())\nG = nx.Graph()\nG.add_nodes_from(range(1, N + 1))\nG.add_edges_from([tuple(map(int, input().split())) for _ in range(M)])\n\nprint(len(tuple(nx.bridges(G))))# nx.bridges\u2026\u2026\u6a4b\u3068\u306a\u308b\u8fba\u3092\u30a4\u30c6\u30ec\u30fc\u30bf\u3068\u3057\u3066\u8fd4\u3059", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            x,  y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n    \n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return list(i for i in range(self.n) if self.find(i) == root)\n\n    def roots(self):\n        return list(i for i, x in enumerate(self.parents) if x < 0)\n\n    def group_count(self):\n        return len(self.roots)\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nadj =  []\nN, M = list(map(int, input().split()))\nfor m in range(M):\n    a,b = list(map(int, input().split()))\n    adj.append([a-1, b-1])\n\nans = 0\nfor i in range(M): # \u53d6\u308a\u9664\u304f\u8fba\u306e\u756a\u53f7\n    uf = UnionFind(N)\n    for j in range(M): # \u8fba\u3092\u8ffd\u52a0\u3057\u306a\u3044\uff08\u53d6\u308a\u9664\u304f\uff09\n        if i == j:\n            continue\n        uf.union(*adj[j])\n    if len(set(uf.roots())) != 1:\n        ans += 1\nprint(ans)\n\n", "from collections import defaultdict\n\nN, M = list(map(int, input().split()))\n\nG = defaultdict(list)\n\nAB = []\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    a, b = a, b\n    G[a].append(b)\n    G[b].append(a)\n    AB.append((a, b))\n\n# print(f'{G=}')\n\n\ndef f(a, b):\n    S = set([])\n    Q = [1]\n    while True:\n        QQ = []\n        for q in Q:\n            S.add(q)\n            for j in G[q]:\n                if q == a and j == b:\n                    continue\n                if q == b and j == a:\n                    continue\n                if j not in S:\n                    QQ.append(j)\n        if len(QQ) == 0:\n            break\n        Q = QQ\n        # print(f'{QQ=}')\n    # print(f'{a=}, {b=}, {S=}')\n    return 1 if len(S) != N else 0\n\n\ncnt = 0\nfor a, b in AB:\n    cnt += f(a, b)\n\n# print(f'{cnt=}')\nprint(cnt)\n", "import sys\nsys.setrecursionlimit(10**9)\nclass UnionFind:\n  def __init__(self, n):\n    self.n = [-1]*n\n    self.r = [0]*n\n    self.siz = n\n\n  def find_root(self, x):\n    if self.n[x] < 0:\n      return x\n    else:\n      self.n[x] = self.find_root(self.n[x])\n      return self.n[x]\n\n  def unite(self, x, y):\n    x = self.find_root(x)\n    y = self.find_root(y)\n    if x == y:\n      return\n    elif self.r[x] > self.r[y]:\n      self.n[x] += self.n[y]\n      self.n[y] = x\n    else:\n      self.n[y] += self.n[x]\n      self.n[x] = y\n      if self.r[x] == self.r[y]:\n        self.r[y] += 1\n    self.siz -= 1\n\n  def root_same(self, x, y):\n    return self.find_root(x) == self.find_root(y)\n\n  def count(self, x):\n    return -self.n[self.find_root(x)]\n\n  def size(self):\n    return self.siz\n\nn,m=list(map(int,input().split()))\nedges=[list(map(int,input().split()))for _ in range(m)]\nans=0\nfor i in range(m):\n  u=UnionFind(n)\n  for j in range(m):\n    if j==i:continue\n    a,b=edges[j]\n    a-=1\n    b-=1\n    u.unite(a,b)\n  if u.size()!=1:ans+=1\nprint(ans)\n", "N, M = map(int, input().split())\nAB = [list(map(int, input().split())) for _ in range(M)]\n\n\nclass Union_Find:\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.siz = [1] * n\n\n    def root(self, x):\n        if self.par[x] == -1:\n            return x\n        else:\n            return self.root(self.par[x])\n\n    def issame(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n\n        if x == y:\n            return False\n\n        if self.siz[x] < self.siz[y]:\n            tmp = x\n            x = y\n            y = tmp\n\n        self.par[y] = x\n        self.siz[x] += self.siz[y]\n        return True\n\n    def size(self, x):\n        return self.siz[x]\n\n\nans = 0\nfor m in range(M):\n    uf = Union_Find(N)\n    for i in range(M):\n        if i == m:\n            continue\n        \n        a, b = AB[i]\n        a -= 1\n        b -= 1\n        uf.unite(a, b)\n\n    ans += len(set([uf.root(x) for x in range(N)])) != 1\n\nprint(ans)", "class UnionFind():\n  def __init__(self, n):\n    self.n = n\n    self.parent = [i for i in range(self.n)]\n    self.rank = [0] * self.n\n  \n  def find_root(self, x):\n    if self.parent[x] == x:\n      return x\n    else:\n      self.parent[x] = self.find_root(self.parent[x])\n      return self.parent[x]\n  \n  def unite(self, x, y):\n    rx = self.find_root(x)\n    ry = self.find_root(y)\n    if rx == ry:\n      return\n    if self.rank[rx] < self.rank[ry]:\n      self.parent[rx] = ry\n    else:\n      self.parent[ry] = rx\n      if self.rank[rx] == self.rank[ry]:\n        self.rank[rx] += 1\n  \n  def is_same(self, x, y):\n    return self.find_root(x) == self.find_root(y)\n\nN, M = map(int, input().split())\nedge = []\nbridge = 0\nfor _ in range(M):\n  e = list(map(lambda x: int(x)-1, input().split()))\n  edge.append(e)\n\nfor i in range(M):\n  uf = UnionFind(N)\n  for j in range(M):\n    if j == i:\n      continue\n    uf.unite(edge[j][0], edge[j][1])\n  \n  root = uf.find_root(0)\n  for i in range(1, N):\n    if root != uf.find_root(i):\n      bridge += 1\n      break\n\nprint(bridge)", "from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\nfrom collections import deque\nfrom copy import deepcopy\n\nn,m=nii()\nl=[lnii() for i in range(m)]\n\ndef BFS(t_l):\n  tree=[[] for i in range(n)]\n  for a,b in t_l:\n    a-=1\n    b-=1\n    tree[a].append(b)\n    tree[b].append(a)\n\n  dist=[-1 for i in range(n)]\n  dist[0]=0\n\n  que=deque()\n  que.append(0)\n\n  while que:\n    x=que.popleft()\n    for i in tree[x]:\n      if dist[i]==-1:\n        que.append(i)\n        dist[i]=dist[x]+1\n\n  return dist\n\nans=0\nfor i in range(m):\n  t_l=deepcopy(l)\n  del t_l[i]\n  dist=BFS(t_l)\n  if -1 in dist:\n    ans+=1\n\nprint(ans)", "N,M=list(map(int,input().split()))\na=[]\nb=[]\nfor e in range(M):\n    x,y=list(map(int,input().split()))\n    x-=1\n    y-=1\n    a.append(x)\n    b.append(y)\n\ndef solve(e):\n    parent=[i for i in range(N)]\n    def find(x,parent):\n        y=parent[x]\n        while y!=parent[y]:\n            y=find(y,parent)\n        parent[x]=y\n        return y\n    def unite(a,b,parent):\n        x=find(a,parent)\n        y=find(b,parent)\n        if x!=y:\n            parent[x]=y\n\n    for i in range(M):\n        if i==e:\n            continue\n        unite(a[i],b[i],parent)\n    cnt=[0 for _ in range(N)]\n    for i in range(N):\n        cnt[find(i,parent)]=1\n    if cnt.count(1)>1:\n        return 1\n    else:\n        return 0\nans=0\nfor i in range(M):\n    ans+=solve(i)\nprint(ans)\n", "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\nN, M = map(int, input().split())\n\nedges = [[] for _ in range(N)]\nedge_set = set()\nfor _ in range(M):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\n    edge_set.add((a, b))\n\nans = 0\nfor a, b in edge_set:\n    q = deque()\n    q.append(0)\n    visited = set()\n    while q:\n        p = q.popleft()\n        if p in visited:\n            continue\n        visited.add(p)\n        for np in edges[p]:\n            if (p, np) == (a, b) or (np, p) == (a, b):\n                continue\n            q.append(np)\n    if len(visited) != N:\n        ans += 1\n\nprint(ans)", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nbridges = [None] * M\nG = [[] for i in range(N)]\n\nfor i in range(M):\n  a,b = map(int,readline().split())\n  G[a - 1].append(b - 1)\n  G[b - 1].append(a - 1)\n  bridges[i] = (a - 1, b - 1)\n  \nfrom collections import deque\n\nans = 0\nfor i in range(M):\n  q = deque([])\n  q.append(0)\n  seen = set()\n  while q:\n    v = q.popleft()\n    if v in seen:\n      continue\n    seen.add(v)\n    for child in G[v]:\n      if (v, child) == bridges[i] or (child, v) == bridges[i]:\n        continue\n      q.append(child)\n  if len(seen) != N:\n    ans += 1\n    \nprint(ans)", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())\n\nN,M = list(map(int,input().split()))\nedges = []\nfor i in range(M):\n    x = list(map(int,input().split()))\n    edges.append(x)\nans = 0\nfor i in range(M):\n    uf = UnionFind(N)\n    for j in range(M):\n        if j != i:\n            uf.union(edges[j][0]-1,edges[j][1]-1)\n        if j == M-1 and uf.group_count() != 1:\n            ans += 1\nprint(ans)\n", "n,m = map(int,input().split())\npar = [i for i in range(n+1)]\ndef find(x):\n    if par[x] == x:\n        return x\n    else:\n        par[x] = find(par[x]) #\u7d4c\u8def\u5727\u7e2e\n        return par[x]\ndef same(x,y):\n    return find(x) == find(y)\ndef unite(x,y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return 0\n    par[x] = y\nls = [list(map(int,input().split())) for _ in range(m)]\nans = 0\nfor i in ls:\n    for k in ls:\n        if i != k:\n            [a,b] = k\n            unite(a,b)\n    flag = True\n    for p in range(1,n+1):\n        for q in range(1,n+1):\n            if not same(p,q):\n                flag = False\n                break\n        if flag == False:\n            break\n    if flag == False:\n        ans += 1\n    par = [i for i in range(n+1)]\nprint(ans)"]