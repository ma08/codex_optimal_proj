["\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] > 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n): # O(n)\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p)) # O(n)\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] < 0:\n        return 0\n    print(p)\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] > 0:\n        return 0\n    p[i] = -2\n    return 1 + check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p, c):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + solve_cycle(p[i] - 1, p, c)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    c = [0] * n\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p, c))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return True\n    if p[i] > 0:\n        return False\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\ndef check_cycle(i, p, visited):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] < 0:\n        return 0\n    p[i] = -1\n    return check_cycle(p[i] - 1, p, visited)\n\ndef find_cycle_length(i, p, visited):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p, visited)\n\ndef solve_cycle(i, p, visited):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p, visited)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    visited = [0] * n\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n            visited[i] = 1\n        else:\n            if visited[i]:\n                res.append(0)\n            else:\n                res.append(solve_cycle(i, p, visited))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if p[i] > 0:\n    if i == p[i] - 1:\n        return 1\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p) + 1\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    return 0\n    return find_cycle_length(p[i] - 1, p) + 1\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 0\n    return solve_cycle(p[i] - 1, p) + 1\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations and each union operation takes O(log N) time due to path compression.\n# The space complexity is O(N) since we store N elements in the union-find structure. \n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)] # to initialize the parent array\n        self.rank = [0] * N # to initialize the rank array\n        self.size = [1] * N # to initialize the size array\n        self.cycle = [1] * N # to initialize the cycle array\n\n            # path compression\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n        return self.parent[i]\n\n    def union(self, x, y):\n        i_id, j_id = self.find(x), self.find(y)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            # union by rank\n            i_id, j_id = j_id, i_id \n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print() # to print the result\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N # the cycle length of each book\n        \"\"\"\n        Returns the parent of the set containing i.\n        \"\"\"\n\n    def find(self, i):\n        if self.parent[i] != i:\n        \"\"\"\n        Unions the sets containing i and j.\n        \"\"\"\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id] # update the cycle length of j's set\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n# The space complexity is O(N) since we store N elements in the union-find structure.\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles\n# of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current\n# cycle length for each book. This allows us to quickly update the cycle\n# length of a book when the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\n# SOLUTION\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length\n# for each book. This allows us to quickly update the cycle length of a book when\n# the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1 or p[i] < 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1 or p[i] < 0:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1 or p[i] < 0:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef check_cycle(i, p):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    if p[i] > 0:\n        return 0\n    p[i] = -2\n    return check_cycle(p[i] - 1, p)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    n = len(p)\n    res = []\n    for i in range(n):\n        if p[i] == i + 1:\n            res.append(1)\n        else:\n            res.append(solve_cycle(i, p))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# SOLUTION 1\n# The idea is to use a union-find structure to keep track of the cycles of the permutation.\n# The cycle length is the number of days it takes for a book to return to its owner.\n# We can use the union-find structure to quickly find the cycle length of a book.\n\n# In addition to the union-find structure, we keep track of the current cycle length for each book.\n# This allows us to quickly update the cycle length of a book when the book is given to another child.\n\n# The time complexity is O(N log N) since we perform at most N union operations\n# and each union operation takes O(log N) time due to path compression.\n\n# The space complexity is O(N) since we store N elements in the union-find structure.\n\nclass UnionFind:\n    def __init__(self, N):\n        self.parent = [i for i in range(N)]\n        self.rank = [0] * N\n        self.size = [1] * N\n        self.cycle = [1] * N\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        i_id, j_id = self.find(i), self.find(j)\n        if i_id == j_id:\n            return\n        if self.rank[i_id] > self.rank[j_id]:\n            i_id, j_id = j_id, i_id\n        self.parent[i_id] = j_id\n        self.size[j_id] += self.size[i_id]\n        self.cycle[j_id] = self.cycle[i_id] + self.cycle[j_id]\n        if self.rank[i_id] == self.rank[j_id]:\n            self.rank[j_id] += 1\n\n\ndef solve():\n    q = int(input())\n    for _ in range(q):\n        N = int(input())\n        p = list(map(int, input().split()))\n        uf = UnionFind(N)\n        for i in range(N):\n            uf.union(i, p[i] - 1)\n            print(uf.cycle[uf.find(i)], end=\" \")\n        print()\n\n# I/O\n\nif __name__ == \"__main__\":\n    solve()\n", "\n\n# SOLUTION\n\n\n# I/O\n\nif __name__ == \"__main__\":\n    pass\n", "\n\ndef check_cycle(i, p, visited):\n    \"\"\"\n    Checks if there is a cycle starting from index i.\n    \"\"\"\n    if visited[i]:\n        return 0\n    visited[i] = 1\n    return check_cycle(p[i] - 1, p, visited)\n\ndef find_cycle_length(i, p):\n    \"\"\"\n    Finds the length of a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return 1 + find_cycle_length(p[i] - 1, p)\n\ndef solve_cycle(i, p):\n    \"\"\"\n    Solves a cycle starting from index i.\n    \"\"\"\n    if i == p[i] - 1:\n        return 1\n    return solve_cycle(p[i] - 1, p)\n\ndef solve_query(n, p):\n    \"\"\"\n    Solves a query.\n    \"\"\"\n    res = []\n    visited = [0 for _ in range(n)]\n    for i in range(n):\n        if p[i] == i + 1:\n            visited[i] = 1\n            res.append(1)\n        else:\n            res.append(check_cycle(i, p, visited))\n    return res\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        p = list(map(int, input().split()))\n        res = solve_query(n, p)\n        print(*res)\n\nif __name__ == \"__main__\":\n    main()\n"]