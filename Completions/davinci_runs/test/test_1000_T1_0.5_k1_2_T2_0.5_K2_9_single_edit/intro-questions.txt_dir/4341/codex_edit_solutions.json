["#!/usr/bin/env python\n\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def is_cycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.is_cycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def count_cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.is_cycle(i, visited, -1) == True:\n                    count += 1\n        return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.count_cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for child in graph[node]:\n        if child not in visited:\n            dfs(graph, child, visited)\n\ndef count_cycles(graph):\n    visited = set()\n    cycles = 0\n\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            cycles += 1\n    return cycles\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    print(count_cycles(graph))\n\nif __name__ == '__main__':\n    main()\n", "from collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    count += 1\n        return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for child in graph[node]:\n        if child not in visited:\n            dfs(graph, child, visited)\n\ndef count_cycles(graph):\n    visited = set()\n    cycles = 0\n\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            cycles += 1\n    return cycles\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    print(count_cycles(graph))\n\nif __name__ == '__main__':\n    main() \n", "\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if not visited[v]:\n                if self.isCycle(v, visited, u):\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if not visited[i]:\n                if self.isCycle(i, visited, -1):\n                    count += 1\n        return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for child in graph[node]:\n        if child not in visited:\n            dfs(graph, child, visited)\n\ndef count_components(graph):\n    visited = set()\n    components = 0\n\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            components += 1\n    return components\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    print(count_components(graph))\n\nif __name__ == '__main__':\n    main()\n", "\n#\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    count += 1\n        return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for child in graph[node]:\n        if child not in visited:\n            dfs(graph, child, visited)\ndef count_cycles(graph):\n    visited = set()\n    cycles = 0\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            cycles += 1\n    return cycles\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n\n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    print(count_cycles(graph))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef count_cycles(graph):\n    visited = set()\n    count = 0\n\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            count += 1\n    return count\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    for child in graph[node]:\n        if child not in visited:\n            dfs(graph, child, visited)\n", "# -*- coding: utf-8 -*-\n\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    count += 1\n        return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport collections\n\nclass Graph:\n    def __init__(self):\n        self.graph = collections.defaultdict(set)\n\n    def addEdge(self, u, v):\n        self.graph[u].add(v)\n        self.graph[v].add(u)\n\n    def isCycle(self, u, visited, parent):\n        visited[u] = True\n        for v in self.graph[u]:\n            if visited[v] == False:\n                if self.isCycle(v, visited, u) == True:\n                    return True\n            elif v != parent:\n                return True\n        return False\n\n    def cycle(self):\n        visited = [False] * (len(self.graph) + 1)\n        count = 0\n        for i in range(1, len(self.graph) + 1):\n            if visited[i] == False:\n                if self.isCycle(i, visited, -1) == True:\n                    count += 1\n        return count\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n    g = Graph()\n    for i in range(m):\n        u, v = [int(x) for x in input().split()]\n        g.addEdge(u, v)\n    print(g.cycle())\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def is_cyclic_util(self, v, visited, rec_stack):\n        visited[v] = True\n        rec_stack[v] = True\n\n        for neighbour in self.graph[v]:\n            if visited[neighbour] == False:\n                if self.is_cyclic_util(neighbour, visited, rec_stack) == True:\n                    return True\n            elif rec_stack[neighbour] == True:\n                return True\n\n        rec_stack[v] = False\n        return False\n\n    def is_cyclic(self):\n        visited = [False] * self.V\n        rec_stack = [False] * self.V\n        for node in range(self.V):\n            if visited[node] == False:\n                if self.is_cyclic_util(node, visited, rec_stack) == True:\n                    return True\n        return False\n\ndef main():\n    g = Graph(4)\n    g.add_edge(0, 1)\n    g.add_edge(0, 2)\n    g.add_edge(1, 2)\n    g.add_edge(2, 0)\n    g.add_edge(2, 3)\n    g.add_edge(3, 3)\n\n    if g.is_cyclic() == 1:\n        print(\"Graph has a cycle\")\n    else:\n        print(\"Graph has no cycle\")\n", "\nimport sys\n\ndef dfs(graph, node, visited):\n    if node not in visited:\n        visited.add(node)\n        for child in graph[node]:\n            dfs(graph, child, visited)\n\ndef count_cycles(graph):\n    visited = set()\n    cycles = 0\n\n    for node in graph:\n        if node not in visited:\n            dfs(graph, node, visited)\n            cycles += 1\n    return cycles\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for _ in range(m):\n        v, u = map(int, sys.stdin.readline().split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    print(count_cycles(graph))\n\nif __name__ == '__main__':\n    main()\n"]