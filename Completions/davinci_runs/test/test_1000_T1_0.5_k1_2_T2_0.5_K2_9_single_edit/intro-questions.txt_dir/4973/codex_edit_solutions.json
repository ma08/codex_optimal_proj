["\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i - 2, j - 1, N):\n        x = min(x, findMinSteps(i - 2, j - 1, N, board, dp))\n    if isValid(i - 2, j + 1, N):\n        x = min(x, findMinSteps(i - 2, j + 1, N, board, dp))\n    if isValid(i + 2, j - 1, N):\n        x = min(x, findMinSteps(i + 2, j - 1, N, board, dp))\n    if isValid(i + 2, j + 1, N):\n        x = min(x, findMinSteps(i + 2, j + 1, N, board, dp))\n    if isValid(i - 1, j - 2, N):\n        x = min(x, findMinSteps(i - 1, j - 2, N, board, dp))\n    if isValid(i - 1, j + 2, N):\n        x = min(x, findMinSteps(i - 1, j + 2, N, board, dp))\n    if isValid(i + 1, j - 2, N):\n        x = min(x, findMinSteps(i + 1, j - 2, N, board, dp))\n    if isValid(i + 1, j + 2, N):\n        x = min(x, findMinSteps(i + 1, j + 2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N + 1):\n        board.append(input())\n    dp = [[-1 for i in range(N + 1)] for j in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if board[i - 1][j - 1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\n\nmain()\n", "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\nimport sys\nsys.setrecursionlimit(1000000)\n\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "\ndef check(n):\n    if n == 0:\n        return False\n    while n != 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\nprint(check(8))\nprint(check(7))\n", "\n\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == n - 1 and c == n - 1:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-1, -1, -2, -2, 1, 1, 2, 2]\ndc = [-2, 2, -1, 1, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n\tfor _ in range(size):\n\t\tr, c = q.get()\n\n\t\tif (r,c) == (0,0):\n\t\t\tprint(distance)\n\t\t\texit()\n\n\t\tif board[r][c] == '#':\n\t\t\tcontinue\n\n\t\tvisited.add((r,c))\n\n\t\tif r+1 < n and (r+1,c) not in visited:\n\t\t\tq.put((r+1,c))\n\t\tif r-1 >= 0 and (r-1,c) not in visited:\n\t\t\tq.put((r-1,c))\n\t\tif c+1 < n and (r,c+1) not in visited:\n\t\t\tq.put((r,c+1))\n\t\tif c-1 >= 0 and (r,c-1) not in visited:\n\t\t\tq.put((r,c-1))\n\n\tdistance += 1\n\nprint(-1)\n", "\n\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Sep  8 11:45:01 2017\n\n@author: antonialarranaga\n\"\"\"\n\nimport numpy as np\n\ndef knightlOnAChessboard(n, a, b):\n    if a == b:\n        return knightlOnAChessboard(n, a, b)\n    else:\n        return knightlOnAChessboard(n, a, b)\n    \nn = 5\na = 1\nb = 2\n\n    n = int(input())\n\n    result = knightlOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(sys.stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    return 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\"\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "\n\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightlOnAChessboard function below.\n#\ndef knightlOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightlOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result])\n    fptr.write('\\n')\n\n    fptr.close()\n", "\nimport queue\nn = int(input())\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\nvisited = set()\ndistance = 0\nwhile not q.empty():\n    size = q.qsize()\n    for _ in range(size):\n        r, c = q.get()\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\nimport queue\nn = int(input())\nboard = [input() for _ in range(n)]\nq = queue.Queue()\nq.put((n-1,n-1))\nvisited = set()\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n \n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "from queue import Queue\nfrom sys import stdin\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while not q.empty():\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(stdin.readline())\nboard = []\nfor _ in range(n):\n    board.append(list(stdin.readline()))\nprint(min_steps(board))\n", "n = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\n\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\n\n# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n    \ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n    \ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n    \ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n    \ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n    \ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n    \nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n            \n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n    \ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n    \ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n    \ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n    \ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n    \ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n    \nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "\nimport queue\nn = int(input())\nboard = [input() for _ in range(n)]\nq = queue.Queue()\nq.put((n-1,n-1))\nvisited = set()\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n\n# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef main():\n    N = int(input())\n\nmain()\n", "\n#!/bin/python3\n\nimport os\nimport sys\n#\n# Complete the knightlOnAChessboard function below.\n#\ndef knightlOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightlOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n#\n\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "\ndef isValid(r, c):\n    return r >= 0 and r < n and c >= 0 and c < n\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\n\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightlOnAChessboard function below.\n#\ndef knightlOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    # fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    # n = int(input())\n\n    # result = knightlOnAChessboard(n)\n\n    # fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    # fptr.write('\\n')\n\n    # fptr.close()\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n# Function to check if the move is valid\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\nmain()\n", "dr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\n\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\n\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\n#\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n - 1, n - 1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport queue \n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\n#!/bin/python3\n\nimport os\nimport sys\n\n#\n# Complete the knightlOnAChessboard function below.\n#\ndef knightlOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightlOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n", "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board[0]) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))                \n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            print(board)\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n\n\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i - 2, j - 1, N):\n        x = min(x, findMinSteps(i - 2, j - 1, N, board, dp))\n    if isValid(i - 2, j + 1, N):\n        x = min(x, findMinSteps(i - 2, j + 1, N, board, dp))\n    if isValid(i + 2, j - 1, N):\n        x = min(x, findMinSteps(i + 2, j - 1, N, board, dp))\n    if isValid(i + 2, j + 1, N):\n        x = min(x, findMinSteps(i + 2, j + 1, N, board, dp))\n    if isValid(i - 1, j - 2, N):\n        x = min(x, findMinSteps(i - 1, j - 2, N, board, dp))\n    if isValid(i - 1, j + 2, N):\n        x = min(x, findMinSteps(i - 1, j + 2, N, board, dp))\n    if isValid(i + 1, j - 2, N):\n        x = min(x, findMinSteps(i + 1, j - 2, N, board, dp))\n    if isValid(i + 1, j + 2, N):\n        x = min(x, findMinSteps(i + 1, j + 2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N): board.append(input())\n    dp = [[-1 for i in range(N + 1)] for j in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if board[i - 1][j - 1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize: print(-1)\n                else: print(x)\n\n\nmain()\n", "\n# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "import Queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = Queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\n\n#!/usr/bin/env python3\n\nimport os\nimport sys\n\n#\n# Complete the knightlOnAChessboard function below.\n#\ndef knightlOnAChessboard(n):\n    #\n    # Write your code here.\n    #\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightlOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n\n# Solution 1\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'k'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'k'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans, n\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Dec  4 10:45:18 2018\n\n@author: shane\n\"\"\"\n\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\ndef isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j] and board[i][j] != 'K'\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\nimport sys\nfrom collections import deque\n\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n\ndef min_steps(start):\n    queue = deque()\n    queue.append((start, 0))\n\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "import sys\nimport queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board[0]) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\n\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor _ in range(N):\n    board.append(list(input().strip()))\n\n# find the starting point of the knight\nfor row in range(N):\n    for col in range(N):\n        if board[row][col] == \"K\":\n            start = (row, col)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "\n\nimport queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for i in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] != '#':\n            if r+1 < n and (r+1,c) not in visited:\n                q.put((r+1,c))\n            if r-1 >= 0 and (r-1,c) not in visited:\n                q.put((r-1,c))\n            if c+1 < n and (r,c+1) not in visited:\n                q.put((r,c+1))\n            if c-1 >= 0 and (r,c-1) not in visited:\n                q.put((r,c-1))\n\n        visited.add((r,c))\n\n\n    distance += 1\n\nprint(-1)\n", "\n#!/bin/python3\n\nimport os\nimport sys\nprint(\"Hello World\")\n", "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j] \n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\nimport queue\nn = int(input())\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\nvisited = set()\ndistance = 0\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\n\n#!/bin/python3\n\nimport os\nimport sys\n\ndef knightlOnAChessboard(n, a, b):\n    moves = [[a, b], [a, -b], [b, a], [b, -a], [-a, b], [-a, -b], [-b, a], [-b, -a]]\n    board = [[0] * n for j in range(n)]\n    board[0][0] = 1\n    q = [[0, 0]]\n    while len(q) > 0:\n        x, y = q.pop(0)\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board[-1][-1]\n\nif __name__ == '__main__':\n    fptr = sys.stdout\n\n    n = int(input())\n\n    result = [[knightlOnAChessboard(n, a, b) for a in range(1, n)] for b in range(1, n)]\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n - 1, n - 1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "\nimport queue\nn = int(input())\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\nvisited = set()\ndistance = 0\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        x, y = q.get()\n        if (x,y) == (0,0):\n            print(distance)\n            exit()\n        if board[x][y] == '#':\n            continue\n        visited.add((x,y))\n        if x+1 < n and (x+1,y) not in visited:\n            q.put((x+1,y))\n        if x-1 >= 0 and (x-1,y) not in visited:\n            q.put((x-1,y))\n        if y+1 < n and (x,y+1) not in visited:\n            q.put((x,y+1))\n        if y-1 >= 0 and (x,y-1) not in visited:\n            q.put((x,y-1))\n    distance += 1\nprint(-1)\n"]