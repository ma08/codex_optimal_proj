2022-04-16 13:32:51.896318 num operations 1
2022-04-16 13:32:51.896332 size on input set 1
2022-04-16 13:33:08.959396 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif node.val < min_edge[0].val:\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    # elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                    #     min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n\n    def __str__(self):\n        return str(self.val)\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\n# def get_distance(node1, node2):\n#     return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\": \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    # elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for _ in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0).val)\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in graph.get_nodes():\n            for child in node.children:\n                if child.val not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1].val)\n        mst.add_node(min_edge[0].val.val)\n        mst.add_node(min_edge[1].val.val)\n        mst.add_edge(mst.get_node(min_edge[0].val.val), mst.get_node(min_edge[1].val.val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\n# import math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\n# def get_distance(node1, node2):\n#     return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\" \")\n        for child in node.children:\n            print(child.val, end=\" \")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = (None, None)\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    # if min_edge is None:\n                    #     min_edge = (node, child)\n                    # elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                    #     min_edge = (node, child)\n                    if min_edge[0] is None:\n                        min_edge = (node, child)\n                    elif child.val < min_edge[1].val:\n                        min_edge = (node, child)\n        visited.add(min_edge[1]) # add new node to visited\n        mst.add_node(min_edge[0].val) # add new nodes to mst\n        mst.add_node(min_edge[1].val) # add new nodes to mst\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val)) # add new edges to mst\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=\"\\n\")\n        for child in node.children:\n            print(child.val, end=\"\\n\")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650115972,
  "object": "edit"
}
2022-04-16 13:33:08.959824 fix syntax errors 9 ['\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif node.val < min_edge[0].val:\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    # elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                    #     min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n\n    def __str__(self):\n        return str(self.val)\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\n# def get_distance(node1, node2):\n#     return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=": ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    # elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for _ in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.val - node2.val)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0).val)\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in graph.get_nodes():\n            for child in node.children:\n                if child.val not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1].val)\n        mst.add_node(min_edge[0].val.val)\n        mst.add_node(min_edge[1].val.val)\n        mst.add_edge(mst.get_node(min_edge[0].val.val), mst.get_node(min_edge[1].val.val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\n\n# import math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\n# def get_distance(node1, node2):\n#     return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end=" ")\n        for child in node.children:\n            print(child.val, end=" ")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = (None, None)\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    # if min_edge is None:\n                    #     min_edge = (node, child)\n                    # elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                    #     min_edge = (node, child)\n                    if min_edge[0] is None:\n                        min_edge = (node, child)\n                    elif child.val < min_edge[1].val:\n                        min_edge = (node, child)\n        visited.add(min_edge[1]) # add new node to visited\n        mst.add_node(min_edge[0].val) # add new nodes to mst\n        mst.add_node(min_edge[1].val) # add new nodes to mst\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val)) # add new edges to mst\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = []\n\nclass Graph:\n    def __init__(self):\n        self.nodes = []\n        self.size = 0\n\n    def add_node(self, val):\n        node = Node(val)\n        self.nodes.append(node)\n        self.size += 1\n\n    def add_edge(self, node1, node2):\n        node1.children.append(node2)\n        node2.children.append(node1)\n\n    def get_node(self, val):\n        for node in self.nodes:\n            if node.val == val:\n                return node\n        return None\n\n    def get_size(self):\n        return self.size\n\n    def get_node_at(self, index):\n        return self.nodes[index]\n\n    def get_nodes(self):\n        return self.nodes\n\ndef get_distance(node1, node2):\n    return math.sqrt((node1.x - node2.x)**2 + (node1.y - node2.y)**2)\n\ndef print_graph(graph):\n    for node in graph.get_nodes():\n        print(node.val, end="\\n")\n        for child in node.children:\n            print(child.val, end="\\n")\n        print()\n\ndef prims(graph):\n    mst = Graph()\n    visited = set()\n    visited.add(graph.get_node_at(0))\n    while len(visited) < graph.get_size():\n        min_edge = None\n        for node in visited:\n            for child in node.children:\n                if child not in visited:\n                    if min_edge is None:\n                        min_edge = (node, child)\n                    elif get_distance(node, child) < get_distance(min_edge[0], min_edge[1]):\n                        min_edge = (node, child)\n        visited.add(min_edge[1])\n        mst.add_node(min_edge[0].val)\n        mst.add_node(min_edge[1].val)\n        mst.add_edge(mst.get_node(min_edge[0].val), mst.get_node(min_edge[1].val))\n    return mst\n\ndef main():\n    n = int(input())\n    graph = Graph()\n    for node in range(n):\n        graph.add_node(node+1)\n    for i in range(n):\n        for j in range(n):\n            if j != i:\n                graph.add_edge(graph.get_node(i+1), graph.get_node(j+1))\n    mst = prims(graph)\n    print_graph(mst)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-16 13:33:08.960065 size on output set 9
2022-04-16 13:33:08.960081 num operations 1
2022-04-16 13:33:08.960086 size on input set 1
2022-04-16 13:33:22.713117 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main(): \n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n): \n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim's_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)] \n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = [] \n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0: \n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges (add 1 to each index so that they are 1-indexed)\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = list(range(n))\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(range(n))\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()[1:]])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = set([i for i in range(n)])\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = vertices.copy()\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 1:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n\n            # remove the vertex from the not visited set\n            not_visited.remove(min_vertex)\n\n            # add the vertex to the visited set\n            visited.add(min_vertex)\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n            edges.append((current_vertex, min_vertex))\n\n            # move to the next vertex\n            current_vertex = min_vertex\n        else:\n            # move to the next vertex\n            current_vertex = visited.pop()\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    # for edge in edges:\n    #     print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here: https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = list(range(n))\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim's algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float(\"inf\")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650115989,
  "object": "edit"
}
2022-04-16 13:33:22.713498 fix syntax errors 9 ['\ndef main(): \n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n): \n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim\'s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)] \n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = [] \n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0: \n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges (add 1 to each index so that they are 1-indexed)\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = list(range(n))\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(range(n))\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()[1:]])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = set([i for i in range(n)])\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = vertices.copy()\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 1:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n\n            # remove the vertex from the not visited set\n            not_visited.remove(min_vertex)\n\n            # add the vertex to the visited set\n            visited.add(min_vertex)\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n            edges.append((current_vertex, min_vertex))\n\n            # move to the next vertex\n            current_vertex = min_vertex\n        else:\n            # move to the next vertex\n            current_vertex = visited.pop()\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    # for edge in edges:\n    #     print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\n\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here: https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = list(range(n))\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n', '\ndef main():\n    # read in the number of villages\n    n = int(input())\n\n    # read in the distances between each pair of villages\n    distances = []\n    for i in range(n):\n        distances.append([int(x) for x in input().split()])\n\n    # find the minimum spanning tree of the graph\n    # the algorithm we use is Prim\'s algorithm\n    # the algorithm is explained in detail here:\n    # https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    # a good visualization of the algorithm can be found here:\n    # https://www.cs.usfca.edu/~galles/visualization/Prim.html\n\n    # create a list of all the vertices\n    vertices = [i for i in range(n)]\n\n    # the set of vertices that have been visited\n    visited = set()\n\n    # the set of vertices that have not been visited\n    not_visited = set(vertices)\n\n    # the set of edges that have been visited\n    # each edge is represented as a tuple (u, v)\n    # where u is the vertex that is already in the visited set\n    # and v is the vertex that is being added to the visited set\n    edges = []\n\n    # start at vertex 0\n    current_vertex = 0\n\n    # while there are still vertices to visit\n    while len(not_visited) > 0:\n        # add the current vertex to the visited set\n        visited.add(current_vertex)\n        not_visited.remove(current_vertex)\n\n        # find the vertex that is closest to the current vertex\n        # that has not been visited yet\n        min_distance = float("inf")\n        min_vertex = None\n        for vertex in not_visited:\n            if distances[current_vertex][vertex] < min_distance:\n                min_distance = distances[current_vertex][vertex]\n                min_vertex = vertex\n\n        # if a vertex has been found, then add it to the visited set\n        # and add the edge that connects it to the current vertex\n        # to the set of edges\n        if min_vertex is not None:\n            visited.add(min_vertex)\n            not_visited.remove(min_vertex)\n            edges.append((current_vertex, min_vertex))\n\n        # move to the next vertex\n        current_vertex = min_vertex\n\n    # output the edges\n    for edge in edges:\n        print(edge[0] + 1, edge[1] + 1)\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-16 13:33:22.713708 size on output set 8
2022-04-16 13:33:22.713719 num operations 1
2022-04-16 13:33:22.713724 size on input set 1
2022-04-16 13:33:37.023807 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    distances = [[0 for i in range(n)] for j in range(n)]\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().strip().split())\n        distances[a - 1][b - 1] = c\n        distances[b - 1][a - 1] = c\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j])\n    for i in range(n):\n        for j in range(i + 1, n):\n            if distances[i][j] > 1000000000:\n                print(-1)\n            else:\n                print(distances[i][j])\n\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\ndef main(self):\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\n\nmain(sys.argv)\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(1, n):\n        for j in range(1, n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split(' '))))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    },
    {
      "index": 5,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    result = []\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if distances[i - 1][j - 1] == 1:\n                result.append((i, j))\n    result.sort()\n    print(len(result))\n    for r in result:\n        print(r[0], r[1])\n\nmain()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n"
    }
  ],
  "created": 1650116002,
  "object": "edit"
}
2022-04-16 13:33:37.024053 fix syntax errors 9 ['\nimport sys\n\n\ndef main():\n    n, m = map(int, sys.stdin.readline().strip().split())\n    distances = [[0 for i in range(n)] for j in range(n)]\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().strip().split())\n        distances[a - 1][b - 1] = c\n        distances[b - 1][a - 1] = c\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distances[i][j] = min(distances[i][j], distances[i][k] + distances[k][j])\n    for i in range(n):\n        for j in range(i + 1, n):\n            if distances[i][j] > 1000000000:\n                print(-1)\n            else:\n                print(distances[i][j])\n\n\nmain()\n', '\nimport sys\n\n\ndef main(self):\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\n\nmain(sys.argv)\n', 'import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(1, n):\n        for j in range(1, n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n', "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split(' '))))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nif __name__ == '__main__':\n    main()\n", '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    result = []\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if distances[i - 1][j - 1] == 1:\n                result.append((i, j))\n    result.sort()\n    print(len(result))\n    for r in result:\n        print(r[0], r[1])\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                distances[i][j] = 0\n            elif distances[i][j] == 0:\n                distances[i][j] = distances[j][i]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                distances[j][k] = min(distances[j][k], distances[j][i] + distances[i][k])\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] == 1:\n                print(i + 1, j + 1)\n\nmain()\n']
2022-04-16 13:33:37.024195 size on output set 8
2022-04-16 13:33:37.024207 num operations 1
2022-04-16 13:33:37.024212 size on input set 1
2022-04-16 13:33:45.059387 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[sys.maxint for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split()) # map(int, [1, 2]) -> [1, 2]\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[sys.maxint for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())[:n]\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 6,
      "text": "import sys\n\n\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\n\nmain()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    },
    {
      "index": 8,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n"
    }
  ],
  "created": 1650116017,
  "object": "edit"
}
2022-04-16 13:33:45.059728 fix syntax errors 9 ['\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', '#!/usr/bin/env python\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', '\n\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[sys.maxint for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split()) # map(int, [1, 2]) -> [1, 2]\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[sys.maxint for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())[:n]\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', 'import sys\n\n\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\n\nmain()\n', '\nimport sys\n\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n    \n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n    \n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    dists = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        dists[i] = map(int, sys.stdin.readline().strip().split())\n\n    # preprocess dists\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])\n\n    # find two nodes that are not adjacent\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if dists[i][j] == dists[i][0] + dists[0][j]:\n                print i + 1, j + 1\n                return\n\nmain()\n']
2022-04-16 13:33:45.059928 size on output set 8
2022-04-16 13:33:45.059948 num operations 1
2022-04-16 13:33:45.059956 size on input set 1
2022-04-16 13:34:01.800148 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([float(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = 0\n    min_j = 0\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 5,
      "text": "#!/usr/bin/python3\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 7,
      "text": "import sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    },
    {
      "index": 8,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"
    }
  ],
  "created": 1650116025,
  "object": "edit"
}
2022-04-16 13:34:01.800402 fix syntax errors 9 ["import sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([float(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = 0\n    min_j = 0\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "#!/usr/bin/python3\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "import sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n", "#!/usr/bin/env python3\n\nimport sys\n\n# read input\nn = int(sys.stdin.readline())\ndistances = []\nfor i in range(n):\n    distances.append([int(x) for x in sys.stdin.readline().split()])\n\n# calculate the minimum spanning tree\nmst = []\nvisited = [False]*n\nvisited[0] = True\nwhile False in visited:\n    min_dist = float('inf')\n    min_i = -1\n    min_j = -1\n    for i in range(n):\n        if visited[i]:\n            for j in range(n):\n                if not visited[j] and distances[i][j] < min_dist:\n                    min_dist = distances[i][j]\n                    min_i = i\n                    min_j = j\n    mst.append((min_i+1, min_j+1))\n    visited[min_j] = True\n\n# print the minimum spanning tree\nfor road in mst:\n    print(road[0], road[1])\n"]
2022-04-16 13:34:01.800549 size on output set 5
2022-04-16 13:34:01.800563 num operations 1
2022-04-16 13:34:01.800568 size on input set 1
2022-04-16 13:34:33.289599 fix syntax errors {
  "choices": [
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 0
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]: print(i+1, j+1); print(i+1, k+1); print(j+1, k+1); return\n                if distances[i][j] == distances[i][k] - distances[j][k]: print(i+1, j+1); print(k+1, j+1); print(i+1, k+1); return\n                if distances[i][j] == distances[k][j] - distances[i][k]: print(i+1, k+1); print(i+1, j+1); print(k+1, j+1); return\n                if distances[i][j] + distances[i][k] == distances[j][k]: print(j+1, k+1); print(i+1, j+1); print(i+1, k+1); return\n                if distances[i][j] + distances[k][j] == distances[i][k]: print(i+1, k+1); print(j+1, k+1); print(i+1, j+1); return\n                if distances[i][k] + distances[j][k] == distances[i][j]: print(i+1, j+1); print(i+1, k+1); print(j+1, k+1); return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = [[0 for j in range(n)] for i in range(n)]\n    for i in range(n):\n        distances[i] = list(map(int, sys.stdin.readline().split()))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i + 1, j + 1)\n                    print(i + 1, k + 1)\n                    print(j + 1, k + 1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i + 1, j + 1)\n                    print(k + 1, j + 1)\n                    print(i + 1, k + 1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i + 1, k + 1)\n                    print(i + 1, j + 1)\n                    print(k + 1, j + 1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j + 1, k + 1)\n                    print(i + 1, j + 1)\n                    print(i + 1, k + 1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i + 1, k + 1)\n                    print(j + 1, k + 1)\n                    print(i + 1, j + 1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i + 1, j + 1)\n                    print(i + 1, k + 1)\n                    print(j + 1, k + 1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = {}\n    for i in range(n):\n        distances[i] = list(map(int, sys.stdin.readline().split()))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n# \n# import sys\n#\n# def main():\n#     n = int(sys.stdin.readline())\n#     distances = []\n#     for i in range(n):\n#         distances.append(list(map(int, sys.stdin.readline().split())))\n#     for i in range(n):\n#         for j in range(i+1, n):\n#             for k in range(j+1, n):\n#                 if distances[i][j] == distances[i][k] + distances[k][j]:\n#                     print(i+1, j+1)\n#                     print(i+1, k+1)\n#                     print(j+1, k+1)\n#                     return\n#                 if distances[i][j] == distances[i][k] - distances[j][k]:\n#                     print(i+1, j+1)\n#                     print(k+1, j+1)\n#                     print(i+1, k+1)\n#                     return\n#                 if distances[i][j] == distances[k][j] - distances[i][k]:\n#                     print(i+1, k+1)\n#                     print(i+1, j+1)\n#                     print(k+1, j+1)\n#                     return\n#                 if distances[i][j] + distances[i][k] == distances[j][k]:\n#                     print(j+1, k+1)\n#                     print(i+1, j+1)\n#                     print(i+1, k+1)\n#                     return\n#                 if distances[i][j] + distances[k][j] == distances[i][k]:\n#                     print(i+1, k+1)\n#                     print(j+1, k+1)\n#                     print(i+1, j+1)\n#                     return\n#                 if distances[i][k] + distances[j][k] == distances[i][j]:\n#                     print(i+1, j+1)\n#                     print(i+1, k+1)\n#                     print(j+1, k+1)\n#                     return\n#\n# if __name__ == '__main__':\n#     main()\n"
    },
    {
      "index": 7,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    exit()\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    exit()\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    exit()\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    exit()\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    exit()\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    exit()\n    print(-1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j] and distances[i][k] != 0 and distances[k][j] != 0:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k] and distances[i][k] != 0 and distances[j][k] != 0:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k] and distances[i][k] != 0 and distances[j][k] != 0:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650116041,
  "object": "edit"
}
2022-04-16 13:34:33.289969 NO RESULT
2022-04-16 13:34:33.289980 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 0
}
2022-04-16 13:34:33.290056 fix syntax errors 8 ["\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]: print(i+1, j+1); print(i+1, k+1); print(j+1, k+1); return\n                if distances[i][j] == distances[i][k] - distances[j][k]: print(i+1, j+1); print(k+1, j+1); print(i+1, k+1); return\n                if distances[i][j] == distances[k][j] - distances[i][k]: print(i+1, k+1); print(i+1, j+1); print(k+1, j+1); return\n                if distances[i][j] + distances[i][k] == distances[j][k]: print(j+1, k+1); print(i+1, j+1); print(i+1, k+1); return\n                if distances[i][j] + distances[k][j] == distances[i][k]: print(i+1, k+1); print(j+1, k+1); print(i+1, j+1); return\n                if distances[i][k] + distances[j][k] == distances[i][j]: print(i+1, j+1); print(i+1, k+1); print(j+1, k+1); return\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = [[0 for j in range(n)] for i in range(n)]\n    for i in range(n):\n        distances[i] = list(map(int, sys.stdin.readline().split()))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i + 1, j + 1)\n                    print(i + 1, k + 1)\n                    print(j + 1, k + 1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i + 1, j + 1)\n                    print(k + 1, j + 1)\n                    print(i + 1, k + 1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i + 1, k + 1)\n                    print(i + 1, j + 1)\n                    print(k + 1, j + 1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j + 1, k + 1)\n                    print(i + 1, j + 1)\n                    print(i + 1, k + 1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i + 1, k + 1)\n                    print(j + 1, k + 1)\n                    print(i + 1, j + 1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i + 1, j + 1)\n                    print(i + 1, k + 1)\n                    print(j + 1, k + 1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = {}\n    for i in range(n):\n        distances[i] = list(map(int, sys.stdin.readline().split()))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n", "\n# \n# import sys\n#\n# def main():\n#     n = int(sys.stdin.readline())\n#     distances = []\n#     for i in range(n):\n#         distances.append(list(map(int, sys.stdin.readline().split())))\n#     for i in range(n):\n#         for j in range(i+1, n):\n#             for k in range(j+1, n):\n#                 if distances[i][j] == distances[i][k] + distances[k][j]:\n#                     print(i+1, j+1)\n#                     print(i+1, k+1)\n#                     print(j+1, k+1)\n#                     return\n#                 if distances[i][j] == distances[i][k] - distances[j][k]:\n#                     print(i+1, j+1)\n#                     print(k+1, j+1)\n#                     print(i+1, k+1)\n#                     return\n#                 if distances[i][j] == distances[k][j] - distances[i][k]:\n#                     print(i+1, k+1)\n#                     print(i+1, j+1)\n#                     print(k+1, j+1)\n#                     return\n#                 if distances[i][j] + distances[i][k] == distances[j][k]:\n#                     print(j+1, k+1)\n#                     print(i+1, j+1)\n#                     print(i+1, k+1)\n#                     return\n#                 if distances[i][j] + distances[k][j] == distances[i][k]:\n#                     print(i+1, k+1)\n#                     print(j+1, k+1)\n#                     print(i+1, j+1)\n#                     return\n#                 if distances[i][k] + distances[j][k] == distances[i][j]:\n#                     print(i+1, j+1)\n#                     print(i+1, k+1)\n#                     print(j+1, k+1)\n#                     return\n#\n# if __name__ == '__main__':\n#     main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    exit()\n                if distances[i][j] == distances[i][k] - distances[j][k]:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    exit()\n                if distances[i][j] == distances[k][j] - distances[i][k]:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    exit()\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    exit()\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    exit()\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    exit()\n    print(-1)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    distances = []\n    for i in range(n):\n        distances.append(list(map(int, sys.stdin.readline().split())))\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if distances[i][j] == distances[i][k] + distances[k][j] and distances[i][k] != 0 and distances[k][j] != 0:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n                if distances[i][j] == distances[i][k] - distances[j][k] and distances[i][k] != 0 and distances[j][k] != 0:\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] == distances[k][j] - distances[i][k] and distances[i][k] != 0 and distances[j][k] != 0:\n                    print(i+1, k+1)\n                    print(i+1, j+1)\n                    print(k+1, j+1)\n                    return\n                if distances[i][j] + distances[i][k] == distances[j][k]:\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    return\n                if distances[i][j] + distances[k][j] == distances[i][k]:\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    print(i+1, j+1)\n                    return\n                if distances[i][k] + distances[j][k] == distances[i][j]:\n                    print(i+1, j+1)\n                    print(i+1, k+1)\n                    print(j+1, k+1)\n                    return\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 13:34:33.290190 size on output set 8
2022-04-16 13:34:33.290200 num operations 1
2022-04-16 13:34:33.290206 size on input set 1
2022-04-16 13:34:43.483387 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(str(i+1) + ' ' + str(j+1))\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(\"{} {}\".format(i+1, j+1))\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i + 1, j + 1)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i + 1, j + 1)\n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1) \n\nif __name__ == '__main__':\n\tmain()\n"
    },
    {
      "index": 7,
      "text": "\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\n\n\ndef solve(matrix):\n\tn = len(matrix)\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1)\n\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tsolve(matrix)\n\nif __name__ == '__main__':\n\tmain()\n"
    }
  ],
  "created": 1650116073,
  "object": "edit"
}
2022-04-16 13:34:43.483632 fix syntax errors 9 ["\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(str(i+1) + ' ' + str(j+1))\n\nif __name__ == '__main__':\n\tmain()\n", '\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint("{} {}".format(i+1, j+1))\n\nif __name__ == \'__main__\':\n\tmain()\n', "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i + 1, j + 1)\n\nif __name__ == '__main__':\n\tmain()\n", "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i + 1, j + 1)\n\nif __name__ == '__main__':\n\tmain()\n", "\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1) \n\nif __name__ == '__main__':\n\tmain()\n", "\ndef main():\n    n = int(input())\n    matrix = []\n    for _ in range(n):\n        matrix.append([int(x) for x in input().split()])\n    for i in range(n):\n        for j in range(i+1, n):\n            if matrix[i][j] == 1:\n                print(i+1, j+1)\n\nif __name__ == '__main__':\n    main()\n", "\n\n\ndef solve(matrix):\n\tn = len(matrix)\n\tfor i in range(n):\n\t\tfor j in range(i+1, n):\n\t\t\tif matrix[i][j] == 1:\n\t\t\t\tprint(i+1, j+1)\n\n\ndef main():\n\tn = int(input())\n\tmatrix = []\n\tfor _ in range(n):\n\t\tmatrix.append([int(x) for x in input().split()])\n\tsolve(matrix)\n\nif __name__ == '__main__':\n\tmain()\n"]
2022-04-16 13:34:43.483681 size on output set 7
2022-04-16 13:34:43.483693 num operations 1
2022-04-16 13:34:43.483698 size on input set 1
2022-04-16 13:34:58.889584 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# import sys\n\n# def main():\n#     n = int(sys.stdin.readline())\n#     villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n#     roads = []\n#     for i in range(1, n):\n#         roads.append((i, i+1))\n#         villages[i][i+1] = 0\n#         villages[i+1][i] = 0\n#     for i in range(1, n):\n#         for j in range(i+2, n):\n#             if villages[i][j] == villages[i][1] + villages[1][j]:\n#                 roads.append((i, j))\n#                 villages[i][j] = 0\n#                 villages[j][i] = 0\n#     for road in roads:\n#         print(road[0], road[1])\n\n# if __name__ == '__main__':\n#     main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n-1):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 8,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i-1][j-1] == villages[i-1][0] + villages[0][j-1]:\n                roads.append((i, j))\n                villages[i-1][j-1] = 0\n                villages[j-1][i-1] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650116083,
  "object": "edit"
}
2022-04-16 13:34:58.889928 fix syntax errors 9 ["\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n", "\n\n# import sys\n\n# def main():\n#     n = int(sys.stdin.readline())\n#     villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n#     roads = []\n#     for i in range(1, n):\n#         roads.append((i, i+1))\n#         villages[i][i+1] = 0\n#         villages[i+1][i] = 0\n#     for i in range(1, n):\n#         for j in range(i+2, n):\n#             if villages[i][j] == villages[i][1] + villages[1][j]:\n#                 roads.append((i, j))\n#                 villages[i][j] = 0\n#                 villages[j][i] = 0\n#     for road in roads:\n#         print(road[0], road[1])\n\n# if __name__ == '__main__':\n#     main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i + 1] = 0\n        villages[i + 1][i] = 0\n    for i in range(1, n):\n        for j in range(i + 2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n-1):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i][i+1] = 0\n        villages[i+1][i] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i][j] == villages[i][1] + villages[1][j]:\n                roads.append((i, j))\n                villages[i][j] = 0\n                villages[j][i] = 0\n    for road in roads:\n        print(road[0], road[1])\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    villages = [list(map(int, sys.stdin.readline().split())) for i in range(n)]\n    roads = []\n    for i in range(1, n):\n        roads.append((i, i+1))\n        villages[i-1][i] = 0\n        villages[i][i-1] = 0\n    for i in range(1, n):\n        for j in range(i+2, n):\n            if villages[i-1][j-1] == villages[i-1][0] + villages[0][j-1]:\n                roads.append((i, j))\n                villages[i-1][j-1] = 0\n                villages[j-1][i-1] = 0\n    for road in roads:\n        print(road[0], road[1], sep=' ')\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-16 13:34:58.889997 size on output set 9
