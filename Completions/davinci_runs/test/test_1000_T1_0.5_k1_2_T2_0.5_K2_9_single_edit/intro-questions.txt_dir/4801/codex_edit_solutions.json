["\nfrom sys import stdin\n\nN = int(stdin.readline())\n\nA = [int(x) for x in stdin.readline().split()]\n\ndef gis(A):\n    g = []\n    for a in A:\n        if not g or a > g[-1]:\n            g.append(a)\n    return g\n\ng = gis(A)\n\nprint(len(g))\nprint(*g)\n", "\n\ndef main():\n    n = int(input())\n    permutation = list(map(int, input().split()))\n\n    lis = [permutation[0]]\n\n    for i in range(1, n):\n        if permutation[i] > lis[-1]:\n            lis.append(permutation[i])\n\n    print(len(lis))\n    print(*lis)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    gis = [a[0]]\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    print(len(gis))\n    print(*gis)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())\n    permutation = list(map(int, input().split()))\n\n    gis = [permutation[0]]\n\n\n    for i in range(1, n):\n        if permutation[i] > gis[-1]:\n\n            gis.append(permutation[i])\n\n    print(len(gis))\n    print(*gis)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Solution\n\n# we are looking for the longest increasing subsequence\n# the idea is to store the longest increasing subsequence that ends at a certain index\n# the longest subsequence that ends at i is the longest subsequence that ends at i-1 and a_i\n# we are looking for the longest subsequence that ends at the last index\n# we store the length of the longest subsequence that ends at index i in dp[i]\n# we also store the index of the last element of the longest subsequence that ends at index i in last[i]\n# dp[0] = 1, last[0] = 0\n# dp[i] = dp[i-1] + 1 if a[i] > a[last[i-1]] else dp[i-1]\n# last[i] = i if dp[i] > dp[i-1] else last[i-1]\n# the longest subsequence ends at the index of the longest subsequence that ends at the last index\n# we use the last array to backtrack and find the elements of the longest subsequence\n# we start at last[last[n-1]] and add the element at that index to the subsequence\n# then we move to the index that is stored at last[last[n-1]]\n# and so on until we reach 0\n\n# read the input\nn = int(input())  # the length of the sequence\na = list(map(int, input().split()))  # the sequence\n\n# initialise the arrays\ndp = [1 for _ in range(n)]\nlast = [i for i in range(n)]\n\n# loop over the array\nfor i in range(1, n):\n    # if the current element is greater than the last element of the longest subsequence that ends at i-1\n    # then the longest subsequence that ends at i is the longest subsequence that ends at i-1 plus the current element\n    # otherwise it is the same as the longest subsequence that ends at i-1\n    if a[i] > a[last[i-1]]:\n        dp[i] = dp[i-1] + 1\n    else:\n        dp[i] = dp[i-1]\n    # if the length of the longest subsequence that ends at i is greater than the length of the longest subsequence that ends at i-1\n    # then the last element of the longest subsequence that ends at i is the current element\n    # otherwise it is the same as the last element of the longest subsequence that ends at i-1\n    if dp[i] > dp[i-1]:\n        last[i] = i\n    else:\n        last[i] = last[i-1]\n\n# print the length of the longest subsequence\nprint(dp[n-1])\n\n# backtrack to find the elements of the longest subsequence\n# start at the index of the last element of the longest subsequence that ends at the last index\ni = last[n-1]\n# initialise the subsequence\nsubseq = []\n# loop over the array\nwhile i >= 0:\n    # add the element at the current index to the subsequence\n    subseq.append(a[i])\n    # move to the index of the last element of the longest subsequence that ends at the current index\n    i = last[i]\n# reverse the subsequence\nsubseq.reverse()\n# print the subsequence\nprint(\" \".join(map(str, subseq)))\n", "\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    gis = [a[0]]\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    print(len(gis))\n    print(*gis)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]  # list comprehension\n    gis = []\n    gis.append(a[0])\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    print(len(gis))\n    print(*gis)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# Solution\n\n# we are looking for the longest increasing subsequence\n# the idea is to store the longest increasing subsequence that ends at a certain index\n# the longest subsequence that ends at i is the longest subsequence that ends at i-1 and a_i\n# we are looking for the longest subsequence that ends at the last index\n# we store the length of the longest subsequence that ends at index i in dp[i]\n# we also store the index of the last element of the longest subsequence that ends at index i in last[i]\n# dp[0] = 1, last[0] = 0\n# dp[i] = dp[i-1] + 1 if a[i] > a[last[i-1]] else dp[i-1]\n# last[i] = i if dp[i] > dp[i-1] else last[i-1]\n# the longest subsequence ends at the index of the longest subsequence that ends at the last index\n# we use the last array to backtrack and find the elements of the longest subsequence\n# we start at last[last[n-1]] and add the element at that index to the subsequence\n# then we move to the index that is stored at last[last[n-1]]\n# and so on until we reach 0\n\n# read input\nn = int(input())\na = list(map(int, input().split()))\n\n# initialise the arrays\ndp = [1 for _ in range(n)]\nlast = [i for i in range(n)]\n\n# loop over the array\nfor i in range(1, n):\n    # if the current element is greater than the last element of the longest subsequence that ends at i-1\n    # then the longest subsequence that ends at i is the longest subsequence that ends at i-1 plus the current element\n    # otherwise it is the same as the longest subsequence that ends at i-1\n    if a[i] > a[last[i-1]]:\n        dp[i] = dp[i-1] + 1\n    else:\n        dp[i] = dp[i-1]\n    # if the length of the longest subsequence that ends at i is greater than the length of the longest subsequence that ends at i-1\n    # then the last element of the longest subsequence that ends at i is the current element\n    # otherwise it is the same as the last element of the longest subsequence that ends at i-1\n    if dp[i] > dp[i-1]:\n        last[i] = i\n    else:\n        last[i] = last[i-1]\n\n# print the length of the longest subsequence\nprint(dp[n-1])\n\n# backtrack to find the elements of the longest subsequence\n# start at the index of the last element of the longest subsequence that ends at the last index\ni = last[n-1]\n# initialise the subsequence\nsubseq = []\n# loop over the array\nwhile i >= 0:\n    # add the element at the current index to the subsequence\n    subseq.append(a[i])\n    # move to the index of the last element of the longest subsequence that ends at the current index\n    i = last[i]\n# reverse the subsequence\nsubseq.reverse()\n# print the subsequence\nprint(\" \".join(map(str, subseq)))\n\n# Submission\n#\n# Accepted\n#\n#\n", "\nn = int(input())\na = list(map(int, input().split()))\ng = [0] * n\ng[0] = a[0]\nfor i in range(1, n):\n    if a[i] > g[-1]:\n        g.append(a[i])\n    else:\n        for j in range(len(g)):\n            if a[i] <= g[j]:\n                g[j] = a[i]\n                break\n\nprint(len(g))\nprint(*g)\n", "\n\ndef main():\n    n = int(input())\n    permutation = list(map(int, input().split()))\n\n    gis = [permutation[0]]\n\n        else:\n            for j in range(len(gis)):\n                if gis[j] >= permutation[i]:\n                    gis[j] = permutation[i]\n                    break\n    for i in range(1, n):\n        if gis[-1] < permutation[i]:\n            gis.append(permutation[i])\n\n    print(len(gis))\n    print(*gis)\n\nif __name__ == '__main__':\n    main()\n", "\nfrom sys import stdin\n\nN = int(stdin.readline())\nA = [int(x) for x in stdin.readline().split()]\ng = []\nfor a in A:\n    if not g or a > g[-1]:\n        g.append(a)\nprint(len(g))\nprint(*g)\n", "\n\ndef greedy_inc_subseq(arr):\n    \"\"\"\n    Return the length of the longest increasing subsequence in arr.\n    \"\"\"\n    # Keep track of the last element in the increasing subsequence\n    # (initially assume the first element is the last element)\n    last_element = [arr[0]]\n    for element in arr[1: ]:\n        if element > last_element[-1]:\n            last_element.append(element)\n    return len(last_element)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(greedy_inc_subseq(arr))\n", "\n\n# solution\n\n# we are looking for the longest increasing subsequence\n# the idea is to store the longest increasing subsequence that ends at a certain index\n# the longest subsequence that ends at i is the longest subsequence that ends at i-1 and a_i\n# we are looking for the longest subsequence that ends at the last index\n# we store the length of the longest subsequence that ends at index i in dp[i]\n# we also store the index of the last element of the longest subsequence that ends at index i in last[i]\n# dp[0] = 1, last[0] = 0\n# dp[i] = dp[i-1] + 1 if a[i] > a[last[i-1]] else dp[i-1]\n# last[i] = i if dp[i] > dp[i-1] else last[i-1]\n# the longest subsequence ends at the index of the longest subsequence that ends at the last index\n# we use the last array to backtrack and find the elements of the longest subsequence\n# we start at last[last[n-1]] and add the element at that index to the subsequence\n# then we move to the index that is stored at last[last[n-1]]\n# and so on until we reach 0\n\n# read input\nn = int(input())\na = list(map(int, input().split()))\n\n# initialise the arrays\ndp = [1 for _ in range(n)]\nlast = [i for i in range(n)]\n\n# loop over the array\nfor i in range(1, n):\n    # if the current element is greater than the last element of the longest subsequence that ends at i-1\n    # then the longest subsequence that ends at i is the longest subsequence that ends at i-1 plus the current element\n    # otherwise it is the same as the longest subsequence that ends at i-1\n    if a[i] > a[last[i-1]]:\n        dp[i] = dp[i-1] + 1\n    else:\n        dp[i] = dp[i-1]\n    # if the length of the longest subsequence that ends at i is greater than the length of the longest subsequence that ends at i-1\n    # then the last element of the longest subsequence that ends at i is the current element\n    # otherwise it is the same as the last element of the longest subsequence that ends at i-1\n    if dp[i] > dp[i-1]:\n        last[i] = i\n    else:\n        last[i] = last[i-1]\n\n# print the length of the longest subsequence\nprint(dp[n-1])\n\n# backtrack to find the elements of the longest subsequence\n# start at the index of the last element of the longest subsequence that ends at the last index\ni = last[n-1]\n# initialise the subsequence\nsubseq = []\n# loop over the array\nwhile i >= 0:\n    # add the element at the current index to the subsequence\n    subseq.append(a[i])\n    # move to the index of the last element of the longest subsequence that ends at the current index\n    i = last[i]\n# reverse the subsequence\nsubseq.reverse()\n# print the subsequence\nprint(\" \".join(map(str, subseq)))\n", "\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [a[0]]\n    for i in range(1, n):\n        if a[i] > dp[-1]:\n            dp.append(a[i])\n        else:\n            for j in range(len(dp)):\n                if dp[j] >= a[i]:\n                    dp[j] = a[i]\n                    break\n    print(len(dp))\n    print(\" \".join(map(str, dp)))\n\nsolve()\n", "\n\ndef get_input():\n    \"\"\"\n    Gets and returns input from stdin.\n    \"\"\"\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    return n, a\n\ndef get_gis(a):\n    \"\"\"\n    Returns the GIS of the given sequence.\n    \"\"\"\n    n = len(a)\n    gis = [a[0]]\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    return gis\n\ndef print_gis(gis):\n    \"\"\"\n    Prints the given GIS.\n    \"\"\"\n    print(len(gis))\n    print(\" \".join([str(x) for x in gis]))\n\nn, a = get_input()\ngis = get_gis(a)\nprint_gis(gis)\n", "\n\n\n# ---=== FUNCTIONS ===---\ndef get_input():\n    \"\"\"\n    Gets and returns input from stdin.\n    \"\"\"\n    n = int(input())\n    a = [int(x) for x in input().split()]\n\n    return n, a\n\ndef get_gis(a):\n    \"\"\"\n    Returns the GIS of the given sequence.\n    \"\"\"\n    n = len(a)\n    gis = [a[0]]\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    return gis\n\n\ndef print_gis(gis):\n    \"\"\"\n    Prints the given GIS.\n    \"\"\"\n    print(len(gis))\n    print(\" \".join([str(x) for x in gis]))\n\n\n# ---=== MAIN ===---\nn, a = get_input()\ngis = get_gis(a)\nprint_gis(gis)\n", "\n\n# Solution\n\n# we are looking for the longest increasing subsequence\n# the idea is to store the longest increasing subsequence that ends at a certain index\n# the longest subsequence that ends at i is the longest subsequence that ends at i-1 and a_i\n# we are looking for the length of the longest subsequence that ends at the last index\n# we store the length of the longest subsequence that ends at index i in dp[i]\n# we also store the index of the last element of the longest subsequence that ends at index i in last[i]\n# dp[0] = 1, last[0] = 0\n# dp[i] = dp[i-1] + 1 if a[i] > a[last[i-1]] else dp[i-1]\n# last[i] = i if dp[i] > dp[i-1] else last[i-1]\n# the longest subsequence ends at the last index of the longest subsequence that ends at the last index\n# we use the last array to backtrack and find the elements of the longest subsequence\n# we start at last[n-1] and add the element at that index to the subsequence\n# then we move to the index that is stored at last[last[n-1]], i.e. the index of the last element of the longest subsequence that ends at the index of the last element of the longest subsequence that ends at the last index\n# and so on until we reach 0\n\n# read input\nn = int(input())\na = list(map(int, input().split()))\n\n# initialise the arrays\ndp = [1 for _ in range(n)]\nlast = [i for i in range(n)]\n\n# loop over the array\nfor i in range(1, n):\n    # if the current element is greater than the last element of the longest subsequence that ends at i-1\n    # then the longest subsequence that ends at i is the longest subsequence that ends at i-1 plus the current element\n    # otherwise it is the same as the longest subsequence that ends at i-1\n    if a[i] > a[last[i-1]]:\n        dp[i] = dp[i-1] + 1\n    else:\n        dp[i] = dp[i-1]\n    # if the length of the longest subsequence that ends at i is greater than the length of the longest subsequence that ends at i-1\n    # then the last element of the longest subsequence that ends at i is the current element\n    # otherwise it is the same as the last element of the longest subsequence that ends at i-1\n    if dp[i] > dp[i-1]:\n        last[i] = i\n    else:\n        last[i] = last[i-1]\n\n# print the length of the longest subsequence\nprint(dp[n-1])\n\n# backtrack to find the elements of the longest subsequence\n# start at the index of the last element of the longest subsequence that ends at the last index\ni = last[n-1]\n# initialise the subsequence\nsubseq = []\n# loop over the array\nwhile i >= 0:\n    # add the element at the current index to the subsequence\n    subseq.append(a[i])\n    # move to the index of the last element of the longest subsequence that ends at the current index\n    i = last[i]\n# reverse the subsequence\nsubseq.reverse()\n# print the subsequence\nprint(\" \".join(map(str, subseq)))\n", "\n\nn = int(input())\na = list(map(int, input().split()))\ng = [0] * n\ng[0] = a[0]\n\nfor i in range(1, n):\n    if a[i] > g[-1]:\n        g.append(a[i])\n    else:\n        for j in range(len(g)):\n            if a[i] <= g[j]:\n                g[j] = a[i]\n                break\n\nprint(len(g))\nprint(*g)\n", "\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    gis = []\n    gis.append(a[0])  # first element is always included\n    for i in range(1, n):\n        if a[i] > gis[-1]:  # if current element is greater than the last element in gis\n            gis.append(a[i])\n    print(len(gis))\n    print(*gis)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())  # number of elements in the sequence\n    permutation = list(map(int, input().split()))  # read the permutation\n\n    gis = [permutation[0]]  # create a list with the first element of the permutation\n\n    for i in range(1, n):  # iterate from the second element to the last one\n        if permutation[i] > gis[-1]:  # if the current element is greater than the last one in the list\n            gis.append(permutation[i])  # add the current element to the list\n\n    print(len(gis))  # print the length of the list\n    print(*gis)  # print the list\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [a[0]]\n    for i in range(1, n):\n        if a[i] > dp[-1]:\n            dp.append(a[i])\n        else: \n            dp[bisect.bisect_left(dp, a[i])] = a[i]\n    print(len(dp))\n    print(*dp)\n\nsolve()\n", "\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [a[0]]\n    for i in range(1, n):\n        if a[i] > dp[-1]:\n            dp.append(a[i])\n        else:\n            for j in range(len(dp)):\n                if dp[j] >= a[i]:\n                    dp[j] = a[i]\n                    break\n    print(len(dp))\n    print(*dp)\n\nsolve()\n", "\n# ---=== FUNCTIONS ===---\ndef get_input():\n    \"\"\"\n    Gets and returns input from stdin.\n    \"\"\"\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    return n, a\n\ndef get_gis(a):\n    \"\"\"\n    Returns the GIS of the given sequence.\n    \"\"\"\n    n = len(a)\n    gis = [a[0]]\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    return gis\n\ndef print_gis(gis):\n    \"\"\"\n    Prints the given GIS.\n    \"\"\"\n    print(len(gis))\n    print(\" \".join([str(x) for x in gis]))\n\n# ---=== MAIN ===---\nn, a = get_input()\ngis = get_gis(a)\nprint_gis(gis)\n", "\nn = int(input())\na = list(map(int, input().split()))\n\ng = [0] * n\ng[0] = a[0]\n\nfor i in range(1, n):\n    if a[i] >= g[-1]:\n        g.append(a[i])\n    else:\n        for j in range(len(g)):\n            if a[i] <= g[j]:\n                g[j] = a[i]\n                break\n\nprint(len(g))\nprint(*g)\n", "\ndef main():\n    n = int(input())\n    permutation = list(map(int, input().split()))\n\n    gis = [permutation[0]]\n\n    for i in range(1, n):\n        if permutation[i] > gis[-1]:\n            gis.append(permutation[i])\n\n    print(len(gis))\n    print(*gis)\n\nif __name__ == '__main__':\n    main()\n", "\ndef greedy_inc_subseq(arr):\n    \"\"\"\n    Return the length of the longest increasing subsequence in arr.\n    \"\"\"\n    # Keep track of the last element in the increasing subsequence\n    # (initially assume the first element is the last element)\n    last_element = arr[0]\n    length = 1\n    for element in arr[1:]:\n        if element > last_element:\n            last_element = element\n            length += 1\n    return length\n\n\nif __name__ == \"__main__\":\n    n = int(input(\"Enter the size of the array: \"))\n    arr = [int(x) for x in input(\"Enter the elements of the array: \").split()]\n    print(greedy_inc_subseq(arr))\n", "\n\n# Solution\n\n# we are looking for the longest increasing subsequence\n# the idea is to store the longest increasing subsequence that ends at a certain index\n# the longest subsequence that ends at i is the longest subsequence that ends at i-1 and a_i\n# we are looking for the longest subsequence that ends at the last index\n# we store the length of the longest subsequence that ends at index i in dp[i]\n# we also store the index of the last element of the longest subsequence that ends at index i in last[i]\n# dp[0] = 1, last[0] = 0\n# dp[i] = dp[i-1] + 1 if a[i] > a[last[i-1]] else dp[i-1]\n# last[i] = i if dp[i] > dp[i-1] else last[i-1]\n# the longest subsequence ends at the index of the longest subsequence that ends at the last index\n# we use the last array to backtrack and find the elements of the longest subsequence\n# we start at last[n-1] and add the element at that index to the subsequence\n# then we move to the index that is stored at last[n-1]\n# and so on until we reach 0\n\n# read input\nn = int(input())\na = list(map(int, input().split()))\n\n# initialise the arrays\ndp = [1 for _ in range(n)]\nlast = [i for i in range(n)]\n\n# loop over the array\nfor i in range(1, n):\n    # if the current element is greater than the last element of the longest subsequence that ends at i-1\n    # then the longest subsequence that ends at i is the longest subsequence that ends at i-1 plus the current element\n    # otherwise it is the same as the longest subsequence that ends at i-1\n    if a[i] > a[last[i-1]]:\n        dp[i] = dp[i-1] + 1\n    else:\n        dp[i] = dp[i-1]\n    # if the length of the longest subsequence that ends at i is greater than the length of the longest subsequence that ends at i-1\n    # then the last element of the longest subsequence that ends at i is the current element\n    # otherwise it is the same as the last element of the longest subsequence that ends at i-1\n    if dp[i] > dp[i-1]:\n        last[i] = i\n    else:\n        last[i] = last[i-1]\n\n# print the length of the longest subsequence\nprint(dp[n-1])\n\n# backtrack to find the elements of the longest subsequence\n# start at the index of the last element of the longest subsequence that ends at the last index\ni = last[n-1]\n# initialise the subsequence\nsubseq = []\n# loop over the array\nwhile i >= 0:\n    # add the element at the current index to the subsequence\n    subseq.append(a[i])\n    # move to the index of the last element of the longest subsequence that ends at the current index\n    i = last[i]\n# reverse the subsequence\nsubseq.reverse()\n# print the subsequence\nprint(\" \".join(map(str, subseq)))\n", "\n\ndef greedy_inc_subseq(arr):\n    \"\"\"\n    Return the length of the longest increasing subsequence in arr.\n    \"\"\"\n    # Keep track of the last element in the increasing subsequence\n    # (initially assume the first element is the last element)\n    last_element = arr[0] # O(1)\n    length = 1\n    for element in arr[1:]: # O(n)\n        if element > last_element:\n            last_element = element # O(1)\n            length += 1\n    return length # O(1)\n\n# Total runtime: O(n)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(greedy_inc_subseq(arr))\n", "\nfrom sys import stdin\n\nN = int(stdin.readline())\nA = [int(x) for x in stdin.readline().split()]\n\ndef gis(A):\n    g = []\n    for a in A:\n        if not g or a > g[-1]:\n            g.append(a)\n    return g\n\ng = gis(A)\n\nprint(len(g))\nprint(*g)\n", "\n\ndef inc_subseq(arr):\n    \"\"\"\n    Return the length of the longest increasing subsequence in arr.\n    \"\"\"\n    # Keep track of the last element in the increasing subsequence\n    # (initially assume the first element is the last element)\n    last_element = arr[0]\n    length = 1\n    for element in arr[1:]:\n        if element > last_element:\n            last_element = element\n            length += 1\n    return length\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(inc_subseq(arr))\n", "\n\n# Solution\n\n# we are looking for the longest increasing subsequence\n# the idea is to store the longest increasing subsequence that ends at a certain index\n# the longest subsequence that ends at i is the longest subsequence that ends at i-1 and a_i\n# we are looking for the longest subsequence that ends at the last index\n# we store the length of the longest subsequence that ends at index i in dp[i]\n# we also store the index of the last element of the longest subsequence that ends at index i in last[i]\n# dp[0] = 1, last[0] = 0\n# dp[i] = dp[i-1] + 1 if a[i] > a[last[i-1]] else dp[i-1]\n# last[i] = i if dp[i] > dp[i-1] else last[i-1]\n# the longest subsequence ends at the index of the longest subsequence that ends at the last index\n# we use the last array to backtrack and find the elements of the longest subsequence\n# we start at last[last[n-1]] and add the element at that index to the subsequence\n# then we move to the index that is stored at last[last[n-1]]\n# and so on until we reach 0\n\n# read input\nn = int(input())\na = list(map(int, input().split()))\n\n# initialise the arrays\ndp = [1 for _ in range(n)]\nlast = [i for i in range(n)]\n\n# loop over the array\nfor i in range(1, n):\n    # if the current element is greater than the last element of the longest subsequence that ends at i-1\n    # then the longest subsequence that ends at i is the longest subsequence that ends at i-1 plus the current element\n    # otherwise it is the same as the longest subsequence that ends at i-1\n    if a[i] > a[last[i-1]]:\n        dp[i] = dp[i-1] + 1\n    else:\n        dp[i] = dp[i-1]\n    # if the length of the longest subsequence that ends at i is greater than the length of the longest subsequence that ends at i-1\n    # then the last element of the longest subsequence that ends at i is the current element\n    # otherwise it is the same as the last element of the longest subsequence that ends at i-1\n    if dp[i] > dp[i-1]:\n        last[i] = i\n    else:\n        last[i] = last[i-1]\n\n# print the length of the longest subsequence\nprint(dp[n-1])\n\n# backtrack to find the elements of the longest subsequence\n# start at the index of the last element of the longest subsequence that ends at the last index\ni = last[n-1]\n# initialise the subsequence\nsubseq = []\n# loop over the array\nwhile i >= 0:\n    # add the element at the current index to the subsequence\n    subseq.append(a[i])\n    # move to the index of the last element of the longest subsequence that ends at the current index minus 1\n    i = last[i]-1\n# reverse the subsequence\nsubseq.reverse()\n# print the subsequence\nprint(\" \".join(map(str, subseq)))\n", "\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [a[0]]\n    for i in range(1, n):\n        if a[i] > dp[-1]:\n            dp.append(a[i])\n        else:\n            for j in range(len(dp)):\n                if dp[j] >= a[i]:\n                    dp[j] = a[i]\n                    break\n    print(len(dp))\n    print(*dp)\n\n\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [a[0]]\n    for i in range(1, n):\n        if a[i] > dp[-1]:\n            dp.append(a[i])\n        else:\n            for j in range(len(dp)):\n                if dp[j] >= a[i]:\n                    dp[j] = a[i]\n                    break\n    print(len(dp))\n    print(*dp)\n\nsolve()\n", "\nn = int(input())\na = list(map(int, input().split()))\n\ng = [0] * n\ng[0] = a[0]\n\nfor i in range(1, n):\n    if a[i] > g[-1]:\n        g.append(a[i])\n    else:\n        for j in range(len(g)):\n            if a[i] <= g[j]:\n                g[j] = a[i]\n                break\n\nprint(len(g))\nprint(*g)\n", "\n#\n# def main():\n#     n = int(input())\n#     a = [int(x) for x in input().split()]\n#     gis = []\n#     gis.append(a[0])\n#     for i in range(1, n):\n#         if a[i] > gis[-1]:\n#             gis.append(a[i])\n#     print(len(gis))\n#     print(*gis)\n#\n# if __name__ == \"__main__\":\n#     main()\n", "\nfrom sys import stdin\n\nN = int(stdin.readline())\nA = [int(x) for x in stdin.readline().split()]\n\ndef gis(A):\n    g = []\n    for a in A:\n        if not g or a > g[-1]:\n            g.append(a)\n    return g\ng = gis(A)\n\nprint(len(g))\nprint(*g)\n", "\n\n\ndef greedy_inc_subseq(arr):\n    \"\"\"\n    Return the length of the longest increasing subsequence in arr.\n    \"\"\"\n    # Keep track of the last element in the increasing subsequence\n    # (initially assume the first element is the last element)\n    last_element = arr[0]\n    length = 1\n    for element in arr[1:]:\n        if element > last_element:\n            last_element = element\n            length += 1\n    return length\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(greedy_inc_subseq(arr))\n", "\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    dp = [arr[0]]\n    for i in range(1, n):\n        if arr[i] > dp[-1]:\n            dp.append(arr[i])\n        else:\n            for j in range(len(dp)):\n                if dp[j] >= arr[i]:\n                    dp[j] = arr[i]\n                    break\n    print(len(dp))\n    print(*dp)\n\nsolve()\n", "\ndef greedy_inc_subseq(arr):\n    \"\"\"\n    Return the length of the longest increasing subsequence in arr.\n    \"\"\"\n    # Keep track of the last element in the increasing subsequence\n    # (initially assume the first element is the last element)\n    last_element = arr[0]\n    length = 1\n    for element in arr[1:]:\n        if element > last_element:\n            last_element = element\n            length += 1\n    return length\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(greedy_inc_subseq(arr))\n", "\n\nfrom sys import stdin\n\n# N = int(stdin.readline())\n# A = [int(x) for x in stdin.readline().split()]\n\n# def gis(A):\n#     g = []\n#     for a in A:\n#         if not g or a > g[-1]:\n#             g.append(a)\n#     return g\n\n# g = gis(A)\n\n# print(len(g))\n# print(*g)\n\ndef f(n):\n    if n == 0:\n        return 1\n    else:\n        return n * f(n-1)\n\nprint(f(5))\n", "\n\ndef greedy_inc_subseq(arr)\n    \"\"\"\n    Return the length of the longest increasing subsequence in arr.\n    \"\"\"\n    # Keep track of the last element in the increasing subsequence\n    # (initially assume the first element is the last element)\n    last_element = arr[0]\n    length = 1\n    for element in arr[1:]:\n        if element > last_element:\n            last_element = element\n            length += 1\n    return length\n\n\nif __name__ == \"__main__\"\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(greedy_inc_subseq(arr))\n", "\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    gis = []\n    gis.append(a[0])\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    print(len(gis))\n    print(*gis)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())  # number of elements\n    a = [int(x) for x in input().split()]  # array\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [a[0], a[1]]\n    for i in range(1, n):\n        if a[i] >= dp[-1]:\n            dp.append(a[i])\n        else:\n            dp[bisect.bisect_left(dp, a[i])] = a[i]\n    print(len(dp))\n    print(*dp)\n\nsolve()\n", "\n\ndef main():\n    n = int(input())\n    permutation = list(map(int, input().split()))\n\n    gis = [permutation[0]]\n\n    for i in range(1, n):\n        if permutation[i] >= gis[-1]:\n            gis.append(permutation[i])\n\n    print(len(gis))\n    print(*gis)\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    gis = []\n    gis.append(a[0])\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    print(len(gis))\n    print(*gis)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n# ---=== FUNCTIONS ===---\ndef get_input():\n    \"\"\"\n    Gets and returns input from stdin.\n    \"\"\"\n    n, a = input().split()\n    n = int(n)\n    a = [int(x) for x in a.split()]\n    return n, a\n\ndef get_gis(a):\n    \"\"\"\n    Returns the GIS of the given sequence.\n    \"\"\"\n    n = len(a)\n    gis = [a[0]]\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    return gis\n\ndef print_gis(gis):\n    \"\"\"\n    Prints the given GIS.\n    \"\"\"\n    print(len(gis))\n    print(\" \".join([str(x) for x in gis]))\n\n# ---=== MAIN ===---\nn, a = get_input()\ngis = get_gis(a)\nprint_gis(gis)\n", "\ndef greedy_inc_subseq(arr):\n    \"\"\"\n    Return the length of the longest increasing subsequence in arr.\n    \"\"\"\n    # Keep track of the last element in the increasing subsequence\n    # (initially assume the first element is the last element)\n    last_element = arr[0]\n    length = 1\n    for element in arr[1:]:\n        if element > last_element:\n            last_element = element\n            length += 1\n    return length\n\n\nif __name__ == \"__main__\":\n    arr = [int(x) for x in input().split()]\n    print(greedy_inc_subseq(arr))\n", "\nfrom sys import stdin\n\nN = int(stdin.readline())\nA = [int(x) for x in stdin.readline().split()]\n\ndef gis(A):\n    g = list()\n    for a in A:\n        if not g or a > g[-1]:\n            g.append(a) \n    return g\n\ng = gis(A)\n\nprint(len(g))\nprint(*g)\n", "\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    dp = [a[0]]\n    for i in range(1, n):  # i = 1 to n-1\n        if a[i] > dp[-1]:\n            dp.append(a[i])\n        else:\n            for j in range(len(dp)):\n                if dp[j] >= a[i]:\n                    dp[j] = a[i]\n                    break\n    print(len(dp))\n    print(*dp)\n\nsolve()\n", "\n\n# ---=== FUNCTIONS ===--- #\ndef get_input():\n    \"\"\"\n    Gets and returns input from stdin.\n    \"\"\"\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    return n, a\n\ndef get_gis(a):\n    \"\"\"\n    Returns the GIS of the given sequence.\n    \"\"\"\n    n = len(a)\n    gis = [a[0]]\n    for i in range(1, n):\n        if a[i] > gis[-1]:\n            gis.append(a[i])\n    return gis\n\ndef print_gis(gis):\n    \"\"\"\n    Prints the given GIS.\n    \"\"\"\n    print(len(gis))\n    print(\" \".join([str(x) for x in gis]))\n\n# ---=== MAIN ===--- #\nn, a = get_input()\ngis = get_gis(a)\nprint_gis(gis)\n", "\n\ndef greedy_inc_subseq(arr):\n    \"\"\"\n    Return the length of the longest increasing subsequence in arr.\n    \"\"\"\n    # Keep track of the last element in the increasing subsequence\n    # (initially assume the first element is the last element)\n    last_element = [arr[0]]\n    for element in arr[1:]:  # for each element in the array\n        if element > last_element[-1]:  # if element is greater than the last element in increasing subsequence\n            last_element.append(element)  # append the element to the increasing subsequence\n    return len(last_element)\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = [int(x) for x in input().split()]\n    print(greedy_inc_subseq(arr))\n", "\nfrom sys import stdin\n\nN = int(stdin.readline())\n\nA = [int(x) for x in stdin.readline().split()]\n\ndef gis(A):\n    g = []\n    for a in A:\n        if not g or a > g[-1]:\n            g.append(a)\n    return g\n\n\ng = gis(A)\n\nprint(len(g))\nprint(*g)\n"]