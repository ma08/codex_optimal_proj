["\n\ndef main():\n\t# get input\n\tn, q = map(int, input().split())\n\tqueries = []\n\tfor i in range(q):\n\t\tqueries.append(input().split())\n\n\t# initialize\n\tgroup_sizes = [1]*n\n\tgroup_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 'M':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\n\nimport sys\n\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\nimport sys\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    p = [i for i in range(n+1)]\n\n    def find(x):\n        while x != p[x]:\n            x = p[x]\n        return x\n\n    def union(x, y):\n        p1 = find(x)\n        p2 = find(y)\n        if p1 != p2:\n            p[p1] = p2\n\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))) - 1)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "import sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 'u':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n#!/usr/bin/env python3\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1) # size of each set\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 1\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n", "\n\n# union find\n\n# find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n# union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n# read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n# run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n\n#union find for disjoint set\n\n#find root of node (with path compression)\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes (by size)\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1]) - 1, int(query[2]) - 1)\n    else:\n        print(sizes[find(int(query[1]) - 1)])\n", "\n\ndef find(node, parent):\n    if parent[node] != node:\n        parent[node] = find(parent[node], parent)    \n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1    \n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import defaultdict\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = defaultdict(int)\n        self.size = defaultdict(int)\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set(node1)\n        parent2 = self.find_set(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(ds.map[int(line[1])]).rank + 1)\n", "\n\nimport sys\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in xrange(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n", "import sys\nsys.setrecursionlimit(10**6)\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = sys.stdin.readline().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    # get input from file\n    input_file = open(\"input.txt\", 'r')\n    n, q = map(int, input_file.readline().split())\n    queries = []\n    for i in range(q):\n        queries.append(input_file.readline().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            output_file.write(str(group_sizes[leader_a]) + \"\\n\")\n\n    input_file.close()\n    output_file.close()\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\nimport sys\n\nclass DisjointSet:\n    def __init__(self):\n        self.parent = {}\n        self.rank = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n", "\ndef find(node, parent):\n\tif node != parent[node]:\n\t\tparent[node] = find(parent[node], parent)\n\treturn parent[node]\n\ndef merge(node1, node2, parent, size):\n\troot1 = find(node1, parent)\n\troot2 = find(node2, parent)\n\tif root1 == root2:\n\t\treturn\n\tif size[root1] < size[root2]:\n\t\troot1, root2 = root2, root1\n\tparent[root2] = root1\n\tsize[root1] += size[root2]\n\ndef main():\n\tn, q = map(int, input().split())\n\tparent = [i for i in range(n + 1)]\n\tsize = [1 for i in range(n + 1)]\n\tfor _ in range(q):\n\t\tquery = input().split()\n\t\tif query[0] == 't':\n\t\t\tmerge(int(query[1]), int(query[2]), parent, size)\n\t\telse:\n\t\t\tprint(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n\tmain()\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1] * n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1]) - 1\n            b = int(query[2]) - 1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1]) - 1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\n\nmain()\n", "\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 'q':\n            print(size[find(int(query[1]), parent)])\n        else:\n            merge(int(query[1]), int(query[2]), parent, size)\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()[0]\n        if query == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n", "\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n# read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n# run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1]) - 1, int(query[2]) - 1)\n    else:\n        print(sizes[find(int(query[1]) - 1)])\n", "import sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n + 1)]\n        self.size = [1 for i in range(n + 1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "import sys\n\ndef find(x):\n\twhile x != p[x]:\n\t\tx = p[x]\n\treturn x\n\ndef union(x, y):\n\tp1 = find(x)\n\tp2 = find(y)\n\tif p1 != p2:\n\t\tp[p1] = p2\n\ndef main():\n\tn, q = map(int, sys.stdin.readline().split())\n\tglobal p\n\tp = [i for i in range(n+1)]\n\tfor i in range(q):\n\t\tline = sys.stdin.readline().strip().split()\n\t\tif line[0] == 't':\n\t\t\tunion(int(line[1]), int(line[2]))\n\t\telse:\n\t\t\tprint(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n\tmain()\n", "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = [None]*q\n    for i in range(q):\n        queries[i] = input().split()\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\n\ndef main():\n    with open('input.txt', 'r') as f:\n        # get input\n        n, q = map(int, f.readline().split())\n        queries = []\n        for i in range(q):\n            queries.append(f.readline().split())\n\n        # initialize\n        group_sizes = [1]*n\n        group_leader = [i for i in range(n)]\n\n        # process queries\n        for query in queries:\n            # merge groups\n            if query[0] == 't':\n                a = int(query[1])-1\n                b = int(query[2])-1\n                leader_a = find_leader(a, group_leader)\n                leader_b = find_leader(b, group_leader)\n                if leader_a != leader_b:\n                    group_sizes[leader_b] += group_sizes[leader_a]\n                    group_leader[leader_a] = leader_b\n            # print size of group\n            else:\n                a = int(query[1])-1\n                leader_a = find_leader(a, group_leader)\n                print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == 's':\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n + 1)]\n        self.size = [1 for i in range(n + 1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_size = [1]*n\n    group_leader = [i for i in range(n)] \n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_size[leader_b] += group_size[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_size[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank \n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n", "#!/usr/bin/env python3\n\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[node.val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val]).val\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])))\n", "\n\n\nparent = []\nsize = []\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))) - 1)\n\nif __name__ == '__main__':\n    main()\n", "\n\n#union find for problem 7\n\n#find root of node\ndef find(n):\n    if n == parents[n]:\n        return n\n    parents[n] = find(parents[n])\n    return parents[n]\n\n#union two nodes\ndef union(n1, n2):\n    n1 = find(n1)\n    n2 = find(n2)\n    if n1 != n2:\n        parents[n1] = n2\n        sizes[n2] += sizes[n1]\n        sizes[n1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in xrange(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'q':\n            print(p.count(find(int(line[1]))))\n        else:\n            union(int(line[1]), int(line[2]))\n\nif __name__ == '__main__':\n    main()\n", "\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\n\n# union find\n\n\n# find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n\n# union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n\n# read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n# run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1]) - 1, int(query[2]) - 1)\n    else:\n        print(sizes[find(int(query[1]) - 1)])\n", "\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split() # python3\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"c\":\n        print dsu.size[dsu.find(int(line[1])-1)]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n", "\n\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = list(range(n))\nsizes = [1] * n\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\nimport sys\n\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split()) # number of students and queries\n    queries = [] # list of queries\n    for i in range(q): # get queries\n        queries.append(input().split()) # query is list of query type and query parameters\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n", "import sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.size = 1\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.size >= parent2.size:\n            parent1.size = (parent1.size + 1) if (parent1.size == parent2.size) else parent1.size\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).size)\n", "\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n)]\n        self.size = [1 for i in range(n)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\n\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n", "\n#https://open.kattis.com/problems/filefixit\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 1\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] = size[find(int(line[1]))] + 1\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p \n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"]