["\n\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)", "\nimport sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()", "\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()", "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()", "\n\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))", "\n\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])", "\n\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()", "\n\n#union find\n\n#find root of node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])"]