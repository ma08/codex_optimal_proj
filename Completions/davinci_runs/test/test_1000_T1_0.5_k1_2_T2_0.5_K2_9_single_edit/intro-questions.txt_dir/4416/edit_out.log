2022-04-16 07:11:08.637801 num operations 1
2022-04-16 07:11:08.637830 size on input set 1
2022-04-16 07:11:21.626896 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)  # noqa\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])[:k]\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    # alice_likes = [t for t, a, b in books if a == 1]\n    # if len(alice_likes) >= k:\n    #     print(sum(alice_likes[:k]))\n    #     return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    # bob_likes = [t for t, a, b in books if b == 1]\n    # num_extra_bob = k - len(alice_likes)\n    # print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\n    sys.stdin = open('input.txt')\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Bob likes, then the optimal solution\n    # will be the k books that Bob likes with the smallest cost\n    bob_likes = [t for t, a, b in books if b == 1]\n    if len(bob_likes) >= k:\n        print(sum(bob_likes[:k]))\n        return \n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    alice_likes = [t for t, a, b in books if a == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines())\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[0:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[0:num_extra_bob]))\n\nmain()\n"
    },
    {
      "index": 8,
      "text": "import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"
    }
  ],
  "created": 1650093068,
  "object": "edit"
}
2022-04-16 07:11:21.627171 fix syntax errors 9 ['import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', '#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)  # noqa\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', 'import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', '\n\nimport sys\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])[:k]\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    # alice_likes = [t for t, a, b in books if a == 1]\n    # if len(alice_likes) >= k:\n    #     print(sum(alice_likes[:k]))\n    #     return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    # bob_likes = [t for t, a, b in books if b == 1]\n    # num_extra_bob = k - len(alice_likes)\n    # print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', "\nimport sys\n\n    sys.stdin = open('input.txt')\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Bob likes, then the optimal solution\n    # will be the k books that Bob likes with the smallest cost\n    bob_likes = [t for t, a, b in books if b == 1]\n    if len(bob_likes) >= k:\n        print(sum(bob_likes[:k]))\n        return \n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    alice_likes = [t for t, a, b in books if a == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n", '\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', '\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n', '\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin.readlines())\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[0:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[0:num_extra_bob]))\n\nmain()\n', 'import sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n']
2022-04-16 07:11:21.627368 size on output set 6
2022-04-16 07:11:21.627386 num operations 1
2022-04-16 07:11:21.627391 size on input set 1
2022-04-16 07:12:02.027335 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums, if both are >= k.\n\t  Else, we return -1.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\t\tmin_sum = -1\n\t\t\tbreak\n\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\t\t\tmin_sum2 = -1\n\t\t\tbreak\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\tif min_sum == -1 or min_sum2 == -1:\n\t\treturn -1\n\telse:\n\t\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 2,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 3,
      "text": "\n#\n# \"\"\"\n# Solution outline\n# \t- Let X and Y be the number of books liked by Alice and Bob respectively.\n# \t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n# \t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n# \t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n# \t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n# \t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n# \t  This can be done in linear time.\n# \t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n# \t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n# \t  This can be done in linear time.\n# \t- We return the minimum of the two sums.\n# \"\"\"\n# def min_books_to_read(t, a, b, k):\n# \t# Find minimum sum of t_i, such that sum(a_i) >= k\n# \tmin_sum = sum(t[:k])\n# \ta_sum = sum(a[:k])\n# \tif a_sum < k:\n# \t\treturn -1\n#\n# \tfor i in xrange(k, len(t)):\n# \t\ta_sum += a[i] - a[i-k]\n# \t\tif a_sum < k:\n# \t\t\tbreak\n#\n# \t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n#\n# \t# Find minimum sum of t_i, such that sum(b_i) >= k\n# \tmin_sum2 = sum(t[:k])\n# \tb_sum = sum(b[:k])\n# \tif b_sum < k:\n# \t\treturn -1\n#\n# \tfor i in xrange(k, len(t)):\n# \t\tb_sum += b[i] - b[i-k]\n# \t\tif b_sum < k:\n# \t\t\tbreak\n#\n# \t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n#\n# \treturn min(min_sum, min_sum2)\n#\n# if __name__ == '__main__':\n# \tn,k = map(int, raw_input().strip().split())\n# \tt = []\n# \ta = []\n# \tb = []\n# \tfor i in xrange(n):\n# \t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n# \t\tt.append(t_i)\n# \t\ta.append(a_i)\n# \t\tb.append(b_i)\n#\n# \tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 4,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 5,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 6,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k]) if len(t) >= k else -1\n\ta_sum = sum(a[:k]) if len(a) >= k else 0\n\tif a_sum < k or min_sum == -1:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k]) if len(t) >= k else -1\n\tb_sum = sum(b[:k]) if len(b) >= k else 0\n\tif b_sum < k or min_sum2 == -1:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 7,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += (a[i] - a[i-k])\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += (b[i] - b[i-k])\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    },
    {
      "index": 8,
      "text": "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n"
    }
  ],
  "created": 1650093081,
  "object": "edit"
}
2022-04-16 07:12:02.027835 fix syntax errors 9 ['\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums, if both are >= k.\n\t  Else, we return -1.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\t\tmin_sum = -1\n\t\t\tbreak\n\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\t\t\tmin_sum2 = -1\n\t\t\tbreak\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\tif min_sum == -1 or min_sum2 == -1:\n\t\treturn -1\n\telse:\n\t\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n#\n# """\n# Solution outline\n# \t- Let X and Y be the number of books liked by Alice and Bob respectively.\n# \t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n# \t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n# \t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n# \t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n# \t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n# \t  This can be done in linear time.\n# \t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n# \t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n# \t  This can be done in linear time.\n# \t- We return the minimum of the two sums.\n# """\n# def min_books_to_read(t, a, b, k):\n# \t# Find minimum sum of t_i, such that sum(a_i) >= k\n# \tmin_sum = sum(t[:k])\n# \ta_sum = sum(a[:k])\n# \tif a_sum < k:\n# \t\treturn -1\n#\n# \tfor i in xrange(k, len(t)):\n# \t\ta_sum += a[i] - a[i-k]\n# \t\tif a_sum < k:\n# \t\t\tbreak\n#\n# \t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n#\n# \t# Find minimum sum of t_i, such that sum(b_i) >= k\n# \tmin_sum2 = sum(t[:k])\n# \tb_sum = sum(b[:k])\n# \tif b_sum < k:\n# \t\treturn -1\n#\n# \tfor i in xrange(k, len(t)):\n# \t\tb_sum += b[i] - b[i-k]\n# \t\tif b_sum < k:\n# \t\t\tbreak\n#\n# \t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n#\n# \treturn min(min_sum, min_sum2)\n#\n# if __name__ == \'__main__\':\n# \tn,k = map(int, raw_input().strip().split())\n# \tt = []\n# \ta = []\n# \tb = []\n# \tfor i in xrange(n):\n# \t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n# \t\tt.append(t_i)\n# \t\ta.append(a_i)\n# \t\tb.append(b_i)\n#\n# \tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k]) if len(t) >= k else -1\n\ta_sum = sum(a[:k]) if len(a) >= k else 0\n\tif a_sum < k or min_sum == -1:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k]) if len(t) >= k else -1\n\tb_sum = sum(b[:k]) if len(b) >= k else 0\n\tif b_sum < k or min_sum2 == -1:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += (a[i] - a[i-k])\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += (b[i] - b[i-k])\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n', '\n\n"""\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books like by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books like by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n"""\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == \'__main__\':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n']
2022-04-16 07:12:02.028121 size on output set 9
