["\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n", "\n# import the required modules\nfrom sys import stdin\nfrom collections import deque\n# read the input\ninput_lines = deque(stdin.read().splitlines())\n# read the number of vertices\nn = int(input_lines.popleft())\n# read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n# read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n# initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n# initialize the parent array\nparent = [-1 for _ in range(n)]\n# initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n# initialize the queue\nqueue = deque()\n# start with the first vertex\nqueue.append(0)\n# perform BFS\nwhile len(queue) > 0:\n    # get the next vertex\n    u = queue.popleft()\n    # set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    # visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # skip the parent vertex\n        if v == parent[u]:\n            continue\n        # set the parent of the neighbor\n        parent[v] = u\n        # add the neighbor to the queue\n        queue.append(v)\n# initialize the result array\nresult = [0 for _ in range(n)]\n# start with the last vertex\nqueue.append(n - 1)\n# perform BFS\nwhile len(queue) > 0:\n    # get the next vertex\n    u = queue.popleft()\n    # update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    # visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # skip the parent vertex\n        if v == parent[u]:\n            continue\n        # update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        # add the neighbor to the queue\n        queue.append(v)\n# print the result\nprint(' '.join(map(str, result)))\n", "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result \nprint(' '.join(map(str, result)))\n", "# https://codeforces.com/contest/1324/problem/C\n\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices.\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices.\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges.\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list.\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array.\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays.\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue.\nqueue = deque()\n\n# Start with the first vertex.\nqueue.append(0)\n\n# Perform BFS.\nwhile len(queue) > 0:\n    # Get the next vertex.\n    u = queue.popleft()\n    \n    # Set the count of the vertex.\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex.\n    for v in adj_list[u]:\n        # Skip the parent vertex.\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor.\n        parent[v] = u\n        \n        # Add the neighbor to the queue.\n        queue.append(v)\n\n# Initialize the result array.\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex.\nqueue.append(n - 1)\n\n# Perform BFS.\nwhile len(queue) > 0:\n    # Get the next vertex.\n    u = queue.popleft()\n    \n    # Update the result of the vertex.\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex.\n    for v in adj_list[u]:\n        # Skip the parent vertex.\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor.\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue.\n        queue.append(v)\n\n# Print the result.\nprint(' '.join(map(str, result)))\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split()) - 1\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2*10**5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v-1] == 1 else 0\n    black[v] = 1 if a[v-1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i-1] = max(ans[i-1],\n                           abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n#\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\n\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n", "\n# https://codeforces.com/problemset/problem/1325/C\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the subtree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n", "\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split()\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v) \n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays\nwhite_count = [0 for _ in range(n)]\nblack_count = [0 for _ in range(n)]\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(black_count[u] - white_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"]