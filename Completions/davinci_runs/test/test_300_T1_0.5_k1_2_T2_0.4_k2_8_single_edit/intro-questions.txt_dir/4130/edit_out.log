2022-04-20 02:24:50.668738 num operations 1
2022-04-20 02:24:50.668757 size on input set 1
2022-04-20 02:24:50.668976 using api key gabby
2022-04-20 02:25:06.975696 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION 1\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(N).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, N):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\n# The idea is to sort the weights and then go over them. If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight. If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight. Otherwise, we can't change the weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\n# SOLUTION \n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\n# The idea is to sort the weights and then go over them. If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight. If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight. Otherwise, we can't change the weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\n# The idea is to sort the weights and then go over them. If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight. If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight. Otherwise, we can't change the weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\n# The idea is to sort the weights and then go over them. If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight. If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight. Otherwise, we can't change the weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650421490,
  "object": "edit"
}
2022-04-20 02:25:06.976047 fix syntax errors 8 ["\n\n# SOLUTION 1\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(N).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, N):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# The idea is to sort the weights and then go over them. If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight. If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight. Otherwise, we can't change the weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION \n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# The idea is to sort the weights and then go over them. If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight. If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight. Otherwise, we can't change the weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# The idea is to sort the weights and then go over them. If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight. If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight. Otherwise, we can't change the weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# The idea is to sort the weights and then go over them. If we are at a weight that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous weight. If we are at a weight that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous weight. Otherwise, we can't change the weight at all. We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 02:25:06.976242 size on output set 5
2022-04-20 02:25:06.976264 num operations 1
2022-04-20 02:25:06.976275 size on input set 1
2022-04-20 02:25:06.976517 using api key sourya
2022-04-20 02:25:12.765302 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 2,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()  # sort the list\n\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i - 1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 3,
      "text": "#!/usr/bin/env python3\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 4,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 5,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 6,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 7,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\n\n#\nprint(count)\n"
    }
  ],
  "created": 1650421507,
  "object": "edit"
}
2022-04-20 02:25:12.765583 fix syntax errors 8 ['\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()  # sort the list\n\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i - 1]:\n        count += 1\n\nprint(count)\n', '#!/usr/bin/env python3\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\n\n#\nprint(count)\n']
2022-04-20 02:25:12.765627 size on output set 5
