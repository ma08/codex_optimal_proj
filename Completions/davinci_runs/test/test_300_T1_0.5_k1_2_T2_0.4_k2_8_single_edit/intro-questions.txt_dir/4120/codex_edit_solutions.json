["# Solution\n\n\n#!/usr/bin/python3\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff), '\\n' + '\\n'.join(['1' * (i + 1) + '0' * (m - i - 1) for i in diff]))\n    else:\n        print(k, '\\n' + '\\n'.join(['1' * (diff[i] + 1) + '0' * (m - diff[i] - 1) for i in range(k)]))\n\n\nfunc(inp(), inp(), inp())\n", "\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):  # n: number of nodes, m: number of edges, k: number of edges to remove\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))  # number of edges to remove\n        for i in diff:  # number of edges to remove\n            print('1' * (i + 1) + '0' * (m - i - 1))  # binary string\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n", "\n\n# Solution:\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u, graph):\n        visited = [False] * n\n        stack = [u]\n        while stack:\n            u = stack.pop()\n            if visited[u]:\n                continue\n            visited[u] = True\n            for v in graph[u]:\n                stack.append(v)\n        return visited\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1].copy()\n        tmp2 = graph[b - 1].copy()\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n\n# Solution 1\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n\n# Solution 2\n\n#!/usr/bin/python3\n\nimport sys\nimport math\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for i in range(n)]\n        self.dist = [0 for i in range(n)]\n        self.best = 0\n        self.ans = []\n\n    def add_edge(self, a, b):\n        self.edges[a].append(b)\n        self.edges[b].append(a)\n\n    def dfs(self, v, p):\n        self.dist[v] = self.dist[p] + 1\n        self.best += self.dist[v]\n        for i in range(len(self.edges[v])):\n            if (self.edges[v][i] != p):\n                self.dfs(self.edges[v][i], v)\n\n    def calc(self):\n        self.dfs(0, -1)\n\n    def remove_edge(self, a, b):\n        self.edges[a].remove(b)\n        self.edges[b].remove(a)\n\n    def is_connected(self):\n        used = [0 for i in range(self.n)]\n        q = [0]\n        used[0] = 1\n        while (len(q) > 0):\n            cur = q[0]\n            q = q[1:]\n            for i in range(len(self.edges[cur])):\n                if (not used[self.edges[cur][i]]):\n                    used[self.edges[cur][i]] = 1\n                    q.append(self.edges[cur][i])\n        for i in range(self.n):\n            if (not used[i]):\n                return False\n        return True\n\n    def get_answer(self, m, k):\n        self.calc()\n        for i in range(1 << m):\n            if (bin(i).count('1') == self.n - 1):\n                cur = Graph(self.n)\n                cur.edges = [deepcopy(self.edges[i]) for i in range(self.n)]\n                cur.dist = [deepcopy(self.dist[i]) for i in range(self.n)]\n                for j in range(m):\n                    if ((i >> j) % 2 == 1):\n                        cur.remove_edge(self.edges[j][0], self.edges[j][1])\n                if (cur.is_connected()):\n                    cur.calc()\n                    if (cur.best < self.best):\n                        self.best = cur.best\n                        self.ans = []\n                        self.ans.append(i)\n                    elif (cur.best == self.best):\n                        self.ans.append(i)\n\nn, m, k = list(map(int, input().split()))\ng = Graph(n)\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g.add_edge(a - 1, b - 1)\ng.get_answer(m, k)\nprint(len(g.ans))\nfor i in range(len(g.ans)):\n    print(bin(g.ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n", "\n\n# Solution \n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n", "# Solution\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n", "\n```\n# Solution\n\n#!/usr/bin/python3\n\nfrom copy import deepcopy\n\nn, m, k = list(map(int, input().split()))\ng = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a - 1].append(b - 1)\n    g[b - 1].append(a - 1)\n\ndef dfs(v, g, used):\n    used[v] = 1\n    for i in range(len(g[v])):\n        if (not used[g[v][i]]):\n            dfs(g[v][i], g, used)\n\ndef is_connected(g):\n    used = [0 for i in range(n)]\n    dfs(0, g, used)\n    for i in range(n):\n        if (not used[i]):\n            return False\n    return True\n\ndef get_dist(g):\n    dist = [0 for i in range(n)]\n    used = [0 for i in range(n)]\n    q = [0]\n    used[0] = 1\n    while (len(q) > 0):\n        cur = q[0]\n        q = q[1:]\n        for i in range(len(g[cur])):\n            if (not used[g[cur][i]]):\n                used[g[cur][i]] = 1\n                q.append(g[cur][i])\n                dist[g[cur][i]] = dist[cur] + 1\n    return sum(dist)\n\ndef get_answer(g, m, k):\n    dist = get_dist(g)\n    best = dist\n    ans = []\n    for i in range(1 << m):\n        if (bin(i).count('1') == n - 1):\n            cur = deepcopy(g)\n            for j in range(m):\n                if ((i >> j) % 2 == 1):\n                    cur[g[j][0]].remove(g[j][1])\n                    cur[g[j][1]].remove(g[j][0])\n            if (is_connected(cur)):\n                cur_dist = get_dist(cur)\n                if (cur_dist < best):\n                    best = cur_dist\n                    ans = []\n                    ans.append(i)\n                elif (cur_dist == best):\n                    ans.append(i)\n    return ans\n\nans = get_answer(g, m, k)\nprint(len(ans))\nfor i in range(len(ans)):\n    print(bin(ans[i])[2:].zfill(m))\n\n# Reference: https://github.com/jaehyunp/stanfordacm/blob/master/code/RoadsNotOnlyInBerland.cpp\n```\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n\nimport sys\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    def dfs(u):\n        if visited[u]:\n            return\n        visited[u] = True\n        for v in graph[u]:\n            dfs(v)\n\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        a, b = inp_list()\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    visited = [False] * n\n    dfs(0)\n    if False in visited:\n        print(0)\n        return\n\n    diff = []\n    for i in range(m):\n        a, b = inp_list()\n        tmp1 = graph[a - 1][:]\n        tmp2 = graph[b - 1][:]\n        graph[a - 1].remove(b - 1)\n        graph[b - 1].remove(a - 1)\n\n        visited = [False] * n\n        dfs(0)\n        if False in visited:\n            diff.append(i)\n\n        graph[a - 1] = tmp1\n        graph[b - 1] = tmp2\n\n    if len(diff) < k:\n        print(len(diff))\n        for i in diff:\n            print('1' * (i + 1) + '0' * (m - i - 1))\n    else:\n        print(k)\n        for i in range(k):\n            print('1' * (diff[i] + 1) + '0' * (m - diff[i] - 1))\n\n\nfunc(inp(), inp(), inp())\n", "\n\nimport sys\nimport re\nimport math\nimport string\nimport itertools\nimport collections\nimport bisect\nimport queue\nimport heapq\nimport time\nimport random\nimport copy\n\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\n\n\ndef inp(): return int(sys.stdin.readline())\n\n\ndef inp_list(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef lcm(x, y): return (x * y) // math.gcd(x, y)\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef sieve(n):\n    prime = [True] * (n + 1)\n    prime[0] = False\n    prime[1] = False\n    for i in range(2, int(n**0.5)+1):\n        if prime[i]:\n            for j in range(i * 2, n + 1, i):\n                prime[j] = False\n    return prime\n\n\ndef eratosthenes_sieve(n):\n    prime = [True] * (n + 1)\n    prime[0] = False\n    prime[1] = False\n    for i in range(2, int(n**0.5)+1):\n        if prime[i]:\n            for j in range(i * i, n + 1, i):\n                prime[j] = False\n    return prime\n\n\ndef get_primes(n):\n    return [i for i in range(2, n + 1) if is_prime(i)]\n\n\ndef divisor(n):\n    i = 1\n    table = []\n    while i * i <= n:\n        if n % i == 0:\n            table.append(i)\n            table.append(n // i)\n        i += 1\n    table = list(set(table))\n    return table\n\n\ndef prime_factor(n):\n    i = 2\n    table = []\n    while i * i <= n:\n        while n % i == 0:\n            n /= i\n            table.append(i)\n        i += 1\n    if n > 1:\n        table.append(n)\n    return table\n\n\ndef gcd(x, y):\n    if x < y:\n        x, y = y, x\n    while y > 0:\n        x, y = y, x % y\n    return x\n\n\ndef lcm(x, y):\n    return (x * y) // gcd(x, y)\n\n\ndef comb(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r):\n    return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\n\n\ndef comb(n, r): return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\n\n\ndef perm(n, r): return math.factorial(n) // math.factorial(n - r)\n\n\ndef dist(x1, y1, x2, y2): return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n\ndef func(n, m, k):\n    pass\n\n\nfunc(inp(), inp(), inp())\n"]