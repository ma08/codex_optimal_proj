["\n\ndef solve(n, m, grid):\n    return 0\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, grid))\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)] # 3d array\n  dp[1][1][grid[0][0]] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n", "\n# Solution by Andrew Xing\ndef main():\n\n    n, m, k = [int(x) for x in input().split()]\n    grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n    dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n    dp[1][1][grid[0][0]] = 1\n  \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if i == 1 and j == 1:\n                continue\n            for x in range(k+1):\n                if i > 1:\n                    dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n                if j > 1:\n                    dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n  \n    print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef solve(n, m, k, grid):\n    return 1\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef solve(n, m, grid):\n    return max(sum(grid[i][j] for i in range(n)) for j in range(m))\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, grid))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef solve(n, m, k, grid):\n    return k\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == '__main__':\n    main()\n", "\n# Solution by Andrew Xing\n\ndef main():\n\n    n, m, k = [int(x) for x in input().split()]\n    grid = [[int(x) for x in input().split()] for i in range(n)]\n\n    dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n    dp[1][1][grid[0][0]] = 1\n\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if i == 1 and j == 1:\n                continue\n            for x in range(k+1):\n                if i > 1:\n                    dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n                if j > 1:\n                    dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n\n    print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef solve(n, m, k):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k))\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Solution by Andrew Xing, edited by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()] # n rows, m columns, k target\n  grid = [[int(x) for x in input().split()] for i in range(n)] # grid\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)] # dp table\n  dp[1][1][grid[0][0]] = 1 # base case\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1: # base case\n        continue\n      for x in range(k+1):\n        if i > 1: # if not on first row\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x] # add number of ways to get to previous cell\n        if j > 1: # if not on first column\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x] # add number of ways to get to previous cell\n  \n  print(dp[n][m][k]) # number of ways to get to bottom right cell with target k\n\nif __name__ == \"__main__\":\n  main()\n", "\n\n# Solution by Andrew Xing\n\ndef main():\n\n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]\n  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)] # dp[i][j][k] = number of ways to get to (i,j) with a value of k\n  dp[1][1][grid[0][0]] = 1\n  \n  for i in range(1, n+1):\n    for j in range(1, m+1):\n      if i == 1 and j == 1:\n        continue\n      for x in range(k+1):\n        if i > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n        if j > 1:\n          dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n  \n  print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n  main()\n", "\n#\n#\n#\n# Solution by Andrew Xing\n\ndef main():\n\n    n, m, k = [int(x) for x in input().split()]\n    grid = [[int(x) for x in input().split()] for i in range(n)]\n\n    dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n    dp[1][1][grid[0][0]] = 1\n\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if i == 1 and j == 1:\n                continue\n            for x in range(k+1):\n                if i > 1:\n                    dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n                if j > 1:\n                    dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n\n    print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef solve(n, m, grid):\n    return n * m\n\ndef main():\n    n, m = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n    print(solve(n, m, k, grid))\n\nif __name__ == '__main__':\n    main()\n", "\n# Solution by Andrew Xing\ndef main():\n\n    n, m, k = [int(x) for x in input().split()]\n    grid = [[int(x) for x in input().split()] for i in range(n)]\n    \n    dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n    dp[1][1][grid[0][0]] = 1\n    \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if i == 1 and j == 1:\n                continue\n            for x in range(k+1):\n                if i > 1:\n                    dp[i][j][x^grid[i-1][j-1]] += dp[i-1][j][x]\n                if j > 1:\n                    dp[i][j][x^grid[i-1][j-1]] += dp[i][j-1][x]\n    \n    print(dp[n][m][k])\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef solve(n, m, k):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    print(solve(n, m, k))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef solve(n, m, k, grid):\n    return 0\n\ndef main():\n    n, m, k = map(int, input().split())\n    grid = [list(map(int, input().split())) for _ in range(n)] # noqa\n    print(solve(n, m, k, grid))\n\nif __name__ == '__main__':\n    main()\n", "\n\n\ndef main():  \n  n, m, k = [int(x) for x in input().split()]\n  grid = [[int(x) for x in input().split()] for i in range(n)]  \n  dp = [[[0 for x in range(k+1)] for y in range(m+1)] for z in range(n+1)]\n  dp[0][0][grid[0][0]] = 1  \n  for i in range(n):\n    for j in range(m):\n      for x in range(k+1):\n        if i > 0:\n          dp[i][j][x^grid[i][j]] += dp[i-1][j][x]\n        if j > 0:\n          dp[i][j][x^grid[i][j]] += dp[i][j-1][x]\n  print(dp[n-1][m-1][k])\n\nif __name__ == \"__main__\":  \n  main()\n"]