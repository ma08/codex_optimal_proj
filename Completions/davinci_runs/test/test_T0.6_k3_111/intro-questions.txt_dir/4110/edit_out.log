2022-04-10 14:01:50.390219 num operations 2
2022-04-10 14:01:50.390257 size on input set 1
2022-04-10 14:01:57.895488 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# \u554f\u984c\u6587\u3092\u6574\u7406\u3059\u308b\u3068\u3001\n# \u3042\u308b1\u3064\u306e100\u70b9\u554f\u984c\u3092\u89e3\u3044\u305f\u3068\u304d\u3001\u30dc\u30fc\u30ca\u30b91\u3064\u306b\u3088\u3063\u3066\u5f97\u3089\u308c\u308b\u70b9\u306f\u3001\n# 100\u70b9\u554f\u984c\u3092\u89e3\u304f\u306e\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570+1\u3088\u308a\u30011\u70b9\u5c11\u306a\u3044\u3053\u3068\u304c\u5206\u304b\u308b\u3002\n# \u3053\u308c\u3092\u5229\u7528\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3057\u3066\u3001\n# \u6700\u5f8c\u306b\u4e0a\u9650\u5024\u3092\u8d85\u3048\u308b\u307e\u3067\u554f\u984c\u6570\u3092\u5897\u3084\u3057\u3066\u3044\u304f\u3002\n# \u3053\u306e\u65b9\u91dd\u3067\u89e3\u304f\u3068\u3001\u89e3\u7b54\u304c\u7c21\u5358\u306b\u6c42\u307e\u308b\u3002 \n# \u305f\u3060\u3057\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u304f\u306a\u308b\u5834\u5408\u304c\u3042\u308b\u3002\n# \u3053\u306e\u3068\u304d\u306f\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u305d\u306e\u307e\u307e\u52a0\u7b97\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3059\u308b\u3002\n# \u3053\u308c\u3067\u89e3\u7b54\u304c\u6c42\u307e\u308b\u3002\n# \u307e\u305f\u3001\u3053\u306e\u65b9\u91dd\u3060\u3068\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3001\n# \u305d\u308c\u3092\u8003\u616e\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3059\u308b\u3002\n\n# \u5165\u529b\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# \u5408\u8a08\u70b9\u6570\ntotal_score = 0\n\n# \u554f\u984c\u6570\ncount = 0\n\n# \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\nfor i in range(D):\n    perfect_bonus_count = 0\n    # \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u306e\u8a08\u7b97\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n    if perfect_bonus_count > problem_list[i][1]:\n        # \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u52a0\u7b97\n        total_score += problem_list[i][1]\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += problem_list[i][0]\n        # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n        else:\n            # \u554f\u984c\u6570\u3092\u66f4\u65b0\n            count += int(perfect_bonus_count)\n            # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n            if total_score >= G:\n                break\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n    else:\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n        total_score += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\n\n# \u554f\u984c\u6587\u3092\u6574\u7406\u3059\u308b\u3068\u3001\n# \u3042\u308b1\u3064\u306e100\u70b9\u554f\u984c\u3092\u89e3\u3044\u305f\u3068\u304d\u3001\u30dc\u30fc\u30ca\u30b91\u3064\u306b\u3088\u3063\u3066\u5f97\u3089\u308c\u308b\u70b9\u306f\u3001\n# 100\u70b9\u554f\u984c\u3092\u89e3\u304f\u306e\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570+1\u3088\u308a\u30011\u70b9\u5c11\u306a\u3044\u3053\u3068\u304c\u5206\u304b\u308b\u3002\n# \u3053\u308c\u3092\u5229\u7528\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3057\u3066\u3001\n# \u6700\u5f8c\u306b\u4e0a\u9650\u5024\u3092\u8d85\u3048\u308b\u307e\u3067\u554f\u984c\u6570\u3092\u5897\u3084\u3057\u3066\u3044\u304f\u3002\n# \u3053\u306e\u65b9\u91dd\u3067\u89e3\u304f\u3068\u3001\u89e3\u7b54\u304c\u7c21\u5358\u306b\u6c42\u307e\u308b\u3002\n# \u305f\u3060\u3057\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u304f\u306a\u308b\u5834\u5408\u304c\u3042\u308b\u3002\n# \u3053\u306e\u3068\u304d\u306f\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u305d\u306e\u307e\u307e\u52a0\u7b97\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3059\u308b\u3002\n# \u3053\u308c\u3067\u89e3\u7b54\u304c\u6c42\u307e\u308b\u3002\n# \u307e\u305f\u3001\u3053\u306e\u65b9\u91dd\u3060\u3068\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3001\n# \u305d\u308c\u3092\u8003\u616e\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3059\u308b\u3002\n\n# \u5165\u529b\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# \u5408\u8a08\u70b9\u6570\ntotal_score = 0\n\n# \u554f\u984c\u6570\ncount = 0\n\n# \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\nfor i in range(D):\n    perfect_bonus_count = 0\n    # \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u306e\u8a08\u7b97\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n    if perfect_bonus_count > problem_list[i][1]:\n        # \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u52a0\u7b97\n        total_score += problem_list[i][1]\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += problem_list[i][0]\n        # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n        else:\n            # \u554f\u984c\u6570\u3092\u66f4\u65b0\n            count += int(perfect_bonus_count)\n            # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n            if total_score >= G:\n                break\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n    else:\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n        total_score += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n\nprint(count)\n"
    }
  ],
  "created": 1649613710,
  "object": "edit"
}
2022-04-10 14:01:57.896099 fix spelling mistakes 2 ['\n\n# 問題文を整理すると、\n# ある1つの100点問題を解いたとき、ボーナス1つによって得られる点は、\n# 100点問題を解くのに必要な問題数+1より、1点少ないことが分かる。\n# これを利用して、ボーナスを得るために必要な問題数を計算して、\n# 最後に上限値を超えるまで問題数を増やしていく。\n# この方針で解くと、解答が簡単に求まる。 \n# ただし、ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きくなる場合がある。\n# このときは、ボーナス獲得点数をそのまま加算して、ボーナスを得るために必要な問題数を計算する。\n# これで解答が求まる。\n# また、この方針だと、ボーナス獲得点数が大きい順にボーナスを得る必要があるので、\n# それを考慮して、ボーナス獲得点数が大きい順にソートする。\n\n# 入力\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# ボーナス獲得点数が大きい順にソート\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# 合計点数\ntotal_score = 0\n\n# 問題数\ncount = 0\n\n# 各ボーナスを得るために必要な問題数\nfor i in range(D):\n    perfect_bonus_count = 0\n    # 各ボーナスを得るために必要な問題数の計算\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きい場合\n    if perfect_bonus_count > problem_list[i][1]:\n        # ボーナス獲得点数を加算\n        total_score += problem_list[i][1]\n        # 問題数を更新\n        count += problem_list[i][0]\n        # ボーナスを得るために必要な問題数を計算\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n        # 合計点数が、目標点数より小さい場合\n        else:\n            # 問題数を更新\n            count += int(perfect_bonus_count)\n            # 合計点数を更新\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # 合計点数が、目標点数より大きい場合\n            if total_score >= G:\n                break\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より小さい場合\n    else:\n        # 問題数を更新\n        count += int(perfect_bonus_count)\n        # 合計点数を更新\n        total_score += int(perfect_bonus_count)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n\nprint(count)\n', '\n\n# 問題文を整理すると、\n# ある1つの100点問題を解いたとき、ボーナス1つによって得られる点は、\n# 100点問題を解くのに必要な問題数+1より、1点少ないことが分かる。\n# これを利用して、ボーナスを得るために必要な問題数を計算して、\n# 最後に上限値を超えるまで問題数を増やしていく。\n# この方針で解くと、解答が簡単に求まる。\n# ただし、ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きくなる場合がある。\n# このときは、ボーナス獲得点数をそのまま加算して、ボーナスを得るために必要な問題数を計算する。\n# これで解答が求まる。\n# また、この方針だと、ボーナス獲得点数が大きい順にボーナスを得る必要があるので、\n# それを考慮して、ボーナス獲得点数が大きい順にソートする。\n\n# 入力\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# ボーナス獲得点数が大きい順にソート\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# 合計点数\ntotal_score = 0\n\n# 問題数\ncount = 0\n\n# 各ボーナスを得るために必要な問題数\nfor i in range(D):\n    perfect_bonus_count = 0\n    # 各ボーナスを得るために必要な問題数の計算\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きい場合\n    if perfect_bonus_count > problem_list[i][1]:\n        # ボーナス獲得点数を加算\n        total_score += problem_list[i][1]\n        # 問題数を更新\n        count += problem_list[i][0]\n        # ボーナスを得るために必要な問題数を計算\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n        # 合計点数が、目標点数より小さい場合\n        else:\n            # 問題数を更新\n            count += int(perfect_bonus_count)\n            # 合計点数を更新\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # 合計点数が、目標点数より大きい場合\n            if total_score >= G:\n                break\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より小さい場合\n    else:\n        # 問題数を更新\n        count += int(perfect_bonus_count)\n        # 合計点数を更新\n        total_score += int(perfect_bonus_count)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n\nprint(count)\n']
2022-04-10 14:01:57.896213 size on output set 2
2022-04-10 14:01:57.896235 size on input set 2
2022-04-10 14:02:03.859483 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# \u554f\u984c\u6587\u3092\u6574\u7406\u3059\u308b\u3068\u3001\n# \u3042\u308b1\u3064\u306e100\u70b9\u554f\u984c\u3092\u89e3\u3044\u305f\u3068\u304d\u3001\u30dc\u30fc\u30ca\u30b91\u3064\u306b\u3088\u3063\u3066\u5f97\u3089\u308c\u308b\u70b9\u306f\u3001\n# 100\u70b9\u554f\u984c\u3092\u89e3\u304f\u306e\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570+1\u3088\u308a\u30011\u70b9\u5c11\u306a\u3044\u3053\u3068\u304c\u5206\u304b\u308b\u3002\n# \u3053\u308c\u3092\u5229\u7528\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3057\u3066\u3001\n# \u6700\u5f8c\u306b\u4e0a\u9650\u5024\u3092\u8d85\u3048\u308b\u307e\u3067\u554f\u984c\u6570\u3092\u5897\u3084\u3057\u3066\u3044\u304f\u3002\n# \u3053\u306e\u65b9\u91dd\u3067\u89e3\u304f\u3068\u3001\u89e3\u7b54\u304c\u7c21\u5358\u306b\u6c42\u307e\u308b\u3002\n# \u305f\u3060\u3057\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u304f\u306a\u308b\u5834\u5408\u304c\u3042\u308b\u3002\n# \u3053\u306e\u3068\u304d\u306f\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u305d\u306e\u307e\u307e\u52a0\u7b97\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3059\u308b\u3002\n# \u3053\u308c\u3067\u89e3\u7b54\u304c\u6c42\u307e\u308b\u3002\n# \u307e\u305f\u3001\u3053\u306e\u65b9\u91dd\u3060\u3068\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3001\n# \u305d\u308c\u3092\u8003\u616e\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3059\u308b\u3002\n\n# \u5165\u529b\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# \u5408\u8a08\u70b9\u6570\ntotal_score = 0\n\n# \u554f\u984c\u6570\ncount = 0\n\n# \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\nfor i in range(D):\n    perfect_bonus_count = 0\n    # \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u306e\u8a08\u7b97\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n    if perfect_bonus_count > problem_list[i][1]:\n        # \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u52a0\u7b97\n        total_score += problem_list[i][1]\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += problem_list[i][0]\n        # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n        else:\n            # \u554f\u984c\u6570\u3092\u66f4\u65b0\n            count += int(perfect_bonus_count)\n            # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n            if total_score >= G:\n                break\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n    else:\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n        total_score += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\n\n# \u554f\u984c\u6587\u3092\u6574\u7406\u3059\u308b\u3068\u3001\n# \u3042\u308b1\u3064\u306e100\u70b9\u554f\u984c\u3092\u89e3\u3044\u305f\u3068\u304d\u3001\u30dc\u30fc\u30ca\u30b91\u3064\u306b\u3088\u3063\u3066\u5f97\u3089\u308c\u308b\u70b9\u306f\u3001\n# 100\u70b9\u554f\u984c\u3092\u89e3\u304f\u306e\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570+1\u3088\u308a\u30011\u70b9\u5c11\u306a\u3044\u3053\u3068\u304c\u5206\u304b\u308b\u3002\n# \u3053\u308c\u3092\u5229\u7528\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3057\u3066\u3001\n# \u6700\u5f8c\u306b\u4e0a\u9650\u5024\u3092\u8d85\u3048\u308b\u307e\u3067\u554f\u984c\u6570\u3092\u5897\u3084\u3057\u3066\u3044\u304f\u3002\n# \u3053\u306e\u65b9\u91dd\u3067\u89e3\u304f\u3068\u3001\u89e3\u7b54\u304c\u7c21\u5358\u306b\u6c42\u307e\u308b\u3002\n# \u305f\u3060\u3057\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u304f\u306a\u308b\u5834\u5408\u304c\u3042\u308b\u3002\n# \u3053\u306e\u3068\u304d\u306f\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u305d\u306e\u307e\u307e\u52a0\u7b97\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3059\u308b\u3002\n# \u3053\u308c\u3067\u89e3\u7b54\u304c\u6c42\u307e\u308b\u3002\n# \u307e\u305f\u3001\u3053\u306e\u65b9\u91dd\u3060\u3068\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3001\n# \u305d\u308c\u3092\u8003\u616e\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3059\u308b\u3002\n\n# \u5165\u529b\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# \u5408\u8a08\u70b9\u6570\ntotal_score = 0\n\n# \u554f\u984c\u6570\ncount = 0\n\n# \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\nfor i in range(D):\n    perfect_bonus_count = 0\n    # \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u306e\u8a08\u7b97\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n    if perfect_bonus_count > problem_list[i][1]:\n        # \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u52a0\u7b97\n        total_score += problem_list[i][1]\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += problem_list[i][0]\n        # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n        else:\n            # \u554f\u984c\u6570\u3092\u66f4\u65b0\n            count += int(perfect_bonus_count)\n            # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n            if total_score >= G:\n                break\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n    else:\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n        total_score += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n\nprint(count)\n"
    }
  ],
  "created": 1649613718,
  "object": "edit"
}
2022-04-10 14:02:03.859865 fix syntax errors 2 ['\n\n# 問題文を整理すると、\n# ある1つの100点問題を解いたとき、ボーナス1つによって得られる点は、\n# 100点問題を解くのに必要な問題数+1より、1点少ないことが分かる。\n# これを利用して、ボーナスを得るために必要な問題数を計算して、\n# 最後に上限値を超えるまで問題数を増やしていく。\n# この方針で解くと、解答が簡単に求まる。\n# ただし、ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きくなる場合がある。\n# このときは、ボーナス獲得点数をそのまま加算して、ボーナスを得るために必要な問題数を計算する。\n# これで解答が求まる。\n# また、この方針だと、ボーナス獲得点数が大きい順にボーナスを得る必要があるので、\n# それを考慮して、ボーナス獲得点数が大きい順にソートする。\n\n# 入力\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# ボーナス獲得点数が大きい順にソート\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# 合計点数\ntotal_score = 0\n\n# 問題数\ncount = 0\n\n# 各ボーナスを得るために必要な問題数\nfor i in range(D):\n    perfect_bonus_count = 0\n    # 各ボーナスを得るために必要な問題数の計算\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きい場合\n    if perfect_bonus_count > problem_list[i][1]:\n        # ボーナス獲得点数を加算\n        total_score += problem_list[i][1]\n        # 問題数を更新\n        count += problem_list[i][0]\n        # ボーナスを得るために必要な問題数を計算\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n        # 合計点数が、目標点数より小さい場合\n        else:\n            # 問題数を更新\n            count += int(perfect_bonus_count)\n            # 合計点数を更新\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # 合計点数が、目標点数より大きい場合\n            if total_score >= G:\n                break\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より小さい場合\n    else:\n        # 問題数を更新\n        count += int(perfect_bonus_count)\n        # 合計点数を更新\n        total_score += int(perfect_bonus_count)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n\nprint(count)\n', '\n\n# 問題文を整理すると、\n# ある1つの100点問題を解いたとき、ボーナス1つによって得られる点は、\n# 100点問題を解くのに必要な問題数+1より、1点少ないことが分かる。\n# これを利用して、ボーナスを得るために必要な問題数を計算して、\n# 最後に上限値を超えるまで問題数を増やしていく。\n# この方針で解くと、解答が簡単に求まる。\n# ただし、ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きくなる場合がある。\n# このときは、ボーナス獲得点数をそのまま加算して、ボーナスを得るために必要な問題数を計算する。\n# これで解答が求まる。\n# また、この方針だと、ボーナス獲得点数が大きい順にボーナスを得る必要があるので、\n# それを考慮して、ボーナス獲得点数が大きい順にソートする。\n\n# 入力\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# ボーナス獲得点数が大きい順にソート\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# 合計点数\ntotal_score = 0\n\n# 問題数\ncount = 0\n\n# 各ボーナスを得るために必要な問題数\nfor i in range(D):\n    perfect_bonus_count = 0\n    # 各ボーナスを得るために必要な問題数の計算\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きい場合\n    if perfect_bonus_count > problem_list[i][1]:\n        # ボーナス獲得点数を加算\n        total_score += problem_list[i][1]\n        # 問題数を更新\n        count += problem_list[i][0]\n        # ボーナスを得るために必要な問題数を計算\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n        # 合計点数が、目標点数より小さい場合\n        else:\n            # 問題数を更新\n            count += int(perfect_bonus_count)\n            # 合計点数を更新\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # 合計点数が、目標点数より大きい場合\n            if total_score >= G:\n                break\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より小さい場合\n    else:\n        # 問題数を更新\n        count += int(perfect_bonus_count)\n        # 合計点数を更新\n        total_score += int(perfect_bonus_count)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n\nprint(count)\n']
2022-04-10 14:02:23.255507 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\n# \u5165\u529b\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# \u5408\u8a08\u70b9\u6570\ntotal_score = 0\n\n# \u554f\u984c\u6570\ncount = 0\n\n# \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\nfor i in range(D):\n    perfect_bonus_count = 0\n    # \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u306e\u8a08\u7b97\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n    if perfect_bonus_count > problem_list[i][1]:\n        # \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u52a0\u7b97\n        total_score += problem_list[i][1]\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += problem_list[i][0]\n        # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n        else:\n            # \u554f\u984c\u6570\u3092\u66f4\u65b0\n            count += int(perfect_bonus_count)\n            # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n            if total_score >= G:\n                break\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n    else:\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n        total_score += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\n\n# \u554f\u984c\u6587\u3092\u6574\u7406\u3059\u308b\u3068\u3001\u3042\u308b1\u3064\u306e100\u70b9\u554f\u984c\u3092\u89e3\u3044\u305f\u3068\u304d\u3001\u30dc\u30fc\u30ca\u30b91\u3064\u306b\u3088\u3063\u3066\u5f97\u3089\u308c\u308b\u70b9\u306f\u3001\n# 100\u70b9\u554f\u984c\u3092\u89e3\u304f\u306e\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570+1\u3088\u308a\u30011\u70b9\u5c11\u306a\u3044\u3053\u3068\u304c\u5206\u304b\u308b\u3002\n# \u3053\u308c\u3092\u5229\u7528\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3057\u3066\u3001\n# \u6700\u5f8c\u306b\u4e0a\u9650\u5024\u3092\u8d85\u3048\u308b\u307e\u3067\u554f\u984c\u6570\u3092\u5897\u3084\u3057\u3066\u3044\u304f\u3002\n# \u3053\u306e\u65b9\u91dd\u3067\u89e3\u304f\u3068\u3001\u89e3\u7b54\u304c\u7c21\u5358\u306b\u6c42\u307e\u308b\u3002\n# \u305f\u3060\u3057\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u304f\u306a\u308b\u5834\u5408\u304c\u3042\u308b\u3002\n# \u3053\u306e\u3068\u304d\u306f\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u305d\u306e\u307e\u307e\u52a0\u7b97\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3059\u308b\u3002\n# \u3053\u308c\u3067\u89e3\u7b54\u304c\u6c42\u307e\u308b\u3002\n# \u307e\u305f\u3001\u3053\u306e\u65b9\u91dd\u3060\u3068\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3001\n# \u305d\u308c\u3092\u8003\u616e\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3059\u308b\u3002\n\n# \u554f\u984c\u6587\u3092\u6574\u7406\u3059\u308b\u3068\u3001\u3042\u308b1\u3064\u306e100\u70b9\u554f\u984c\u3092\u89e3\u3044\u305f\u3068\u304d\u3001\u30dc\u30fc\u30ca\u30b91\u3064\u306b\u3088\u3063\u3066\u5f97\u3089\u308c\u308b\u70b9\u306f\u3001\n# \u3042\u308b1\u3064\u306e100\u70b9\u554f\u984c\u3092\u89e3\u3044\u305f\u3068\u304d\u3001\u30dc\u30fc\u30ca\u30b91\u3064\u306b\u3088\u3063\u3066\u5f97\u3089\u308c\u308b\u70b9\u306f\u3001\n# 100\u70b9\u554f\u984c\u3092\u89e3\u304f\u306e\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570+1\u3088\u308a\u30011\u70b9\u5c11\u306a\u3044\u3053\u3068\u304c\u5206\u304b\u308b\u3002\n# \u3053\u308c\u3092\u5229\u7528\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3057\u3066\u3001\n# \u6700\u5f8c\u306b\u4e0a\u9650\u5024\u3092\u8d85\u3048\u308b\u307e\u3067\u554f\u984c\u6570\u3092\u5897\u3084\u3057\u3066\u3044\u304f\u3002\n# \u3053\u306e\u65b9\u91dd\u3067\u89e3\u304f\u3068\u3001\u89e3\u7b54\u304c\u7c21\u5358\u306b\u6c42\u307e\u308b\u3002\n# \u305f\u3060\u3057\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u304f\u306a\u308b\u5834\u5408\u304c\u3042\u308b\u3002\n# \u3053\u306e\u3068\u304d\u306f\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u305d\u306e\u307e\u307e\u52a0\u7b97\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\u3059\u308b\u3002\n# \u3053\u308c\u3067\u89e3\u7b54\u304c\u6c42\u307e\u308b\u3002\n# \u307e\u305f\u3001\u3053\u306e\u65b9\u91dd\u3060\u3068\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u5fc5\u8981\u304c\u3042\u308b\u306e\u3067\u3001\n# \u305d\u308c\u3092\u8003\u616e\u3057\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\u3059\u308b\u3002\n\n# \u5165\u529b\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u304c\u5927\u304d\u3044\u9806\u306b\u30bd\u30fc\u30c8\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# \u5408\u8a08\u70b9\u6570\ntotal_score = 0\n\n# \u554f\u984c\u6570\ncount = 0\n\n# \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\nfor i in range(D):\n    perfect_bonus_count = 0\n    # \u5404\u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u306e\u8a08\u7b97\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n    if perfect_bonus_count > problem_list[i][1]:\n        # \u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3092\u52a0\u7b97\n        total_score += problem_list[i][1]\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += problem_list[i][0]\n        # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u3092\u8a08\u7b97\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n        else:\n            # \u554f\u984c\u6570\u3092\u66f4\u65b0\n            count += int(perfect_bonus_count)\n            # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n            if total_score >= G:\n                break\n    # \u30dc\u30fc\u30ca\u30b9\u3092\u5f97\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u554f\u984c\u6570\u304c\u3001\u30dc\u30fc\u30ca\u30b9\u7372\u5f97\u70b9\u6570\u3088\u308a\u5c0f\u3055\u3044\u5834\u5408\n    else:\n        # \u554f\u984c\u6570\u3092\u66f4\u65b0\n        count += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u3092\u66f4\u65b0\n        total_score += int(perfect_bonus_count)\n        # \u5408\u8a08\u70b9\u6570\u304c\u3001\u76ee\u6a19\u70b9\u6570\u3088\u308a\u5927\u304d\u3044\u5834\u5408\n        if total_score >= G:\n            break\n\nprint(count)\n"
    }
  ],
  "created": 1649613724,
  "object": "edit"
}
2022-04-10 14:02:23.255821 fix syntax errors 2 ['\n\n\n# 入力\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# ボーナス獲得点数が大きい順にソート\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# 合計点数\ntotal_score = 0\n\n# 問題数\ncount = 0\n\n# 各ボーナスを得るために必要な問題数\nfor i in range(D):\n    perfect_bonus_count = 0\n    # 各ボーナスを得るために必要な問題数の計算\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きい場合\n    if perfect_bonus_count > problem_list[i][1]:\n        # ボーナス獲得点数を加算\n        total_score += problem_list[i][1]\n        # 問題数を更新\n        count += problem_list[i][0]\n        # ボーナスを得るために必要な問題数を計算\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n        # 合計点数が、目標点数より小さい場合\n        else:\n            # 問題数を更新\n            count += int(perfect_bonus_count)\n            # 合計点数を更新\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # 合計点数が、目標点数より大きい場合\n            if total_score >= G:\n                break\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より小さい場合\n    else:\n        # 問題数を更新\n        count += int(perfect_bonus_count)\n        # 合計点数を更新\n        total_score += int(perfect_bonus_count)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n\nprint(count)\n', '\n\n# 問題文を整理すると、ある1つの100点問題を解いたとき、ボーナス1つによって得られる点は、\n# 100点問題を解くのに必要な問題数+1より、1点少ないことが分かる。\n# これを利用して、ボーナスを得るために必要な問題数を計算して、\n# 最後に上限値を超えるまで問題数を増やしていく。\n# この方針で解くと、解答が簡単に求まる。\n# ただし、ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きくなる場合がある。\n# このときは、ボーナス獲得点数をそのまま加算して、ボーナスを得るために必要な問題数を計算する。\n# これで解答が求まる。\n# また、この方針だと、ボーナス獲得点数が大きい順にボーナスを得る必要があるので、\n# それを考慮して、ボーナス獲得点数が大きい順にソートする。\n\n# 問題文を整理すると、ある1つの100点問題を解いたとき、ボーナス1つによって得られる点は、\n# ある1つの100点問題を解いたとき、ボーナス1つによって得られる点は、\n# 100点問題を解くのに必要な問題数+1より、1点少ないことが分かる。\n# これを利用して、ボーナスを得るために必要な問題数を計算して、\n# 最後に上限値を超えるまで問題数を増やしていく。\n# この方針で解くと、解答が簡単に求まる。\n# ただし、ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きくなる場合がある。\n# このときは、ボーナス獲得点数をそのまま加算して、ボーナスを得るために必要な問題数を計算する。\n# これで解答が求まる。\n# また、この方針だと、ボーナス獲得点数が大きい順にボーナスを得る必要があるので、\n# それを考慮して、ボーナス獲得点数が大きい順にソートする。\n\n# 入力\nD, G = map(int, input().split())\nproblem_list = []\nfor i in range(D):\n    p, c = map(int, input().split())\n    problem_list.append([p, c])\n\n# ボーナス獲得点数が大きい順にソート\nproblem_list.sort(key=lambda x:x[1], reverse=True)\n\n# 合計点数\ntotal_score = 0\n\n# 問題数\ncount = 0\n\n# 各ボーナスを得るために必要な問題数\nfor i in range(D):\n    perfect_bonus_count = 0\n    # 各ボーナスを得るために必要な問題数の計算\n    if problem_list[i][1] != 0:\n        perfect_bonus_count = ((i+1) * 100 * problem_list[i][0]) + problem_list[i][1]\n\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より大きい場合\n    if perfect_bonus_count > problem_list[i][1]:\n        # ボーナス獲得点数を加算\n        total_score += problem_list[i][1]\n        # 問題数を更新\n        count += problem_list[i][0]\n        # ボーナスを得るために必要な問題数を計算\n        perfect_bonus_count = problem_list[i][1] / ((i+1) * 100)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n        # 合計点数が、目標点数より小さい場合\n        else:\n            # 問題数を更新\n            count += int(perfect_bonus_count)\n            # 合計点数を更新\n            total_score += int(perfect_bonus_count) * ((i+1) * 100)\n            # 合計点数が、目標点数より大きい場合\n            if total_score >= G:\n                break\n    # ボーナスを得るために必要な問題数が、ボーナス獲得点数より小さい場合\n    else:\n        # 問題数を更新\n        count += int(perfect_bonus_count)\n        # 合計点数を更新\n        total_score += int(perfect_bonus_count)\n        # 合計点数が、目標点数より大きい場合\n        if total_score >= G:\n            break\n\nprint(count)\n']
2022-04-10 14:02:23.255874 size on output set 3
2022-04-10 14:02:23.255891 num operations 2
2022-04-10 14:02:23.255896 size on input set 1
2022-04-10 14:02:28.947499 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Here's a solution that passes all the test cases, but does not pass the performance test. \n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n"
    },
    {
      "index": 1,
      "text": "\n\n# Here's a solution that passes all the test cases, but does not pass the performance test\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n"
    }
  ],
  "created": 1649613743,
  "object": "edit"
}
2022-04-10 14:02:28.947750 fix spelling mistakes 2 ["\n\n# Here's a solution that passes all the test cases, but does not pass the performance test. \n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n", "\n\n# Here's a solution that passes all the test cases, but does not pass the performance test\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n"]
2022-04-10 14:02:28.947784 size on output set 2
2022-04-10 14:02:28.947789 size on input set 2
2022-04-10 14:02:59.847493 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]  # list of lists\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])  # itertools.product\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n"
    },
    {
      "index": 1,
      "text": "\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\ndef solve(d, g, pc):\n    import itertools\n    p = itertools.product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nif __name__ == '__main__':\n    d, g = map(int, input().split())\n    pc = [list(map(int, input().split())) for _ in range(d)]\n    print(solve(d, g, pc))\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\ndef solve(d, g, pc):\n    import itertools\n    p = itertools.product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nif __name__ == '__main__':\n    d, g = map(int, input().split())\n    pc = [list(map(int, input().split())) for _ in range(d)]\n    print(solve(d, g, pc))\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\ndef solve(d, g, pc):\n    import itertools\n    p = itertools.product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nif __name__ == '__main__':\n    d, g = map(int, input().split())\n    pc = [list(map(int, input().split())) for _ in range(d)]\n    print(solve(d, g, pc))\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n"
    }
  ],
  "created": 1649613749,
  "object": "edit"
}
2022-04-10 14:02:59.847827 fix syntax errors 2 ["\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]  # list of lists\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])  # itertools.product\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n", "\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\ndef solve(d, g, pc):\n    import itertools\n    p = itertools.product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nif __name__ == '__main__':\n    d, g = map(int, input().split())\n    pc = [list(map(int, input().split())) for _ in range(d)]\n    print(solve(d, g, pc))\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\ndef solve(d, g, pc):\n    import itertools\n    p = itertools.product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nif __name__ == '__main__':\n    d, g = map(int, input().split())\n    pc = [list(map(int, input().split())) for _ in range(d)]\n    print(solve(d, g, pc))\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\ndef solve(d, g, pc):\n    import itertools\n    p = itertools.product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nif __name__ == '__main__':\n    d, g = map(int, input().split())\n    pc = [list(map(int, input().split())) for _ in range(d)]\n    print(solve(d, g, pc))\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n"]
2022-04-10 14:03:18.607450 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\n# Here's a solution that passes all the test cases, but does not pass the performance test\n# def solve(d, g, pc):\n#     from itertools import product\n#     p = product(*[range(pc[i][0] + 1) for i in range(d)])\n#     res = float('inf')\n#     for i in p:\n#         s = 0\n#         for j in range(d):\n#             s += 100 * (j + 1) * i[j]\n#             if i[j] == pc[j][0]:\n#                 s += pc[j][1]\n#         if s >= g:\n#             res = min(res, sum(i))\n#             continue\n#         if s < g:\n#             for j in range(d - 1, -1, -1):\n#                 if i[j] < pc[j][0]:\n#                     s += 100 * (j + 1)\n#                     i[j] += 1\n#                     break\n#                 elif i[j] == pc[j][0]:\n#                     i[j] = 0\n#             if s >= g:\n#                 res = min(res, sum(i))\n#     return res\n\n# print(solve(d, g, pc))\n"
    },
    {
      "index": 1,
      "text": "\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n"
    }
  ],
  "created": 1649613780,
  "object": "edit"
}
2022-04-10 14:03:18.607607 fix syntax errors 2 ["\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\n# Here's a solution that passes all the test cases, but does not pass the performance test\n# def solve(d, g, pc):\n#     from itertools import product\n#     p = product(*[range(pc[i][0] + 1) for i in range(d)])\n#     res = float('inf')\n#     for i in p:\n#         s = 0\n#         for j in range(d):\n#             s += 100 * (j + 1) * i[j]\n#             if i[j] == pc[j][0]:\n#                 s += pc[j][1]\n#         if s >= g:\n#             res = min(res, sum(i))\n#             continue\n#         if s < g:\n#             for j in range(d - 1, -1, -1):\n#                 if i[j] < pc[j][0]:\n#                     s += 100 * (j + 1)\n#                     i[j] += 1\n#                     break\n#                 elif i[j] == pc[j][0]:\n#                     i[j] = 0\n#             if s >= g:\n#                 res = min(res, sum(i))\n#     return res\n\n# print(solve(d, g, pc))\n", "\n\n# Here's a solution that passes all the test cases, but does not pass the performance test.\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\ndef solve(d, g, pc):\n    from itertools import product\n    p = product(*[range(pc[i][0] + 1) for i in range(d)])\n    res = float('inf')\n    for i in p:\n        s = 0\n        for j in range(d):\n            s += 100 * (j + 1) * i[j]\n            if i[j] == pc[j][0]:\n                s += pc[j][1]\n        if s >= g:\n            res = min(res, sum(i))\n            continue\n        if s < g:\n            for j in range(d - 1, -1, -1):\n                if i[j] < pc[j][0]:\n                    s += 100 * (j + 1)\n                    i[j] += 1\n                    break\n                elif i[j] == pc[j][0]:\n                    i[j] = 0\n            if s >= g:\n                res = min(res, sum(i))\n    return res\n\nprint(solve(d, g, pc))\n"]
2022-04-10 14:03:18.607710 size on output set 4
2022-04-10 14:03:18.607722 num operations 2
2022-04-10 14:03:18.607728 size on input set 1
2022-04-10 14:03:24.211945 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total problem\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == \"__main__\":\n  main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == \"__main__\":\n  main()\n"
    }
  ],
  "created": 1649613798,
  "object": "edit"
}
2022-04-10 14:03:24.212224 fix spelling mistakes 2 ['\n\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total problem\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == "__main__":\n  main()\n', '\n\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == "__main__":\n  main()\n']
2022-04-10 14:03:24.212260 size on output set 2
2022-04-10 14:03:24.212267 size on input set 2
2022-04-10 14:03:28.959786 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total problem\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == \"__main__\":\n  main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total problem\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == \"__main__\":\n  main()\n"
    }
  ],
  "created": 1649613804,
  "object": "edit"
}
2022-04-10 14:03:28.959912 fix syntax errors 2 ['\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total problem\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == "__main__":\n  main()\n', '\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total problem\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == "__main__":\n  main()\n']
2022-04-10 14:03:47.106103 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    # get input\n    D, G = map(int, sys.stdin.readline().split())\n    p_c = []\n    for i in range(D):\n        p, c = map(int, sys.stdin.readline().split())\n        p_c.append((p, c))\n  \n    # find max possible score\n    max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n    # print(max_score)\n  \n    # initialize\n    total_prob = 0\n    total_score = 0\n  \n    # loop through problems\n    for i in range(D-1, -1, -1):\n        # if max score is enough, no need to solve\n        if max_score >= G:\n            print(total_prob)\n            return\n    \n        # solve all problems of this score and add to total\n        total_prob += p_c[i][0]\n        total_score += p_c[i][1] + p_c[i][0] * (i+1)\n        # print(total_score)\n    \n        # if total score is enough, no need to solve\n        if total_score >= G:\n            print(total_prob)\n            return\n  \nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == \"__main__\":\n  main()\n"
    }
  ],
  "created": 1649613809,
  "object": "edit"
}
2022-04-10 14:03:47.106311 fix syntax errors 2 ['\n\nimport sys\n\ndef main():\n    # get input\n    D, G = map(int, sys.stdin.readline().split())\n    p_c = []\n    for i in range(D):\n        p, c = map(int, sys.stdin.readline().split())\n        p_c.append((p, c))\n  \n    # find max possible score\n    max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n    # print(max_score)\n  \n    # initialize\n    total_prob = 0\n    total_score = 0\n  \n    # loop through problems\n    for i in range(D-1, -1, -1):\n        # if max score is enough, no need to solve\n        if max_score >= G:\n            print(total_prob)\n            return\n    \n        # solve all problems of this score and add to total\n        total_prob += p_c[i][0]\n        total_score += p_c[i][1] + p_c[i][0] * (i+1)\n        # print(total_score)\n    \n        # if total score is enough, no need to solve\n        if total_score >= G:\n            print(total_prob)\n            return\n  \nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n  # get input\n  D, G = map(int, sys.stdin.readline().split())\n  p_c = []\n  for i in range(D):\n    p, c = map(int, sys.stdin.readline().split())\n    p_c.append((p, c))\n  \n  # find max possible score\n  max_score = p_c[-1][1] + p_c[-1][0] * (D+1)\n  # print(max_score)\n  \n  # initialize\n  total_prob = 0\n  total_score = 0\n  \n  # loop through problems\n  for i in range(D-1, -1, -1):\n    # if max score is enough, no need to solve\n    if max_score >= G:\n      print(total_prob)\n      return\n    \n    # solve all problems of this score and add to total\n    total_prob += p_c[i][0]\n    total_score += p_c[i][1] + p_c[i][0] * (i+1)\n    # print(total_score)\n    \n    # if total score is enough, no need to solve\n    if total_score >= G:\n      print(total_prob)\n      return\n  \nif __name__ == "__main__":\n  main()\n']
2022-04-10 14:03:47.106349 size on output set 3
