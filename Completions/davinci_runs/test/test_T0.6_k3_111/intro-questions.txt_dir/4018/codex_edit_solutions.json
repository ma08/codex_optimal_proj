["#!/usr/bin/env python3\n\nn, k = map(int, input().split())\ns = input()\n\nif k > n*(n+1)//2:\n    print(-1)\nelse:\n    sm = 0\n    p = 0\n    for i in range(1, n+1):\n        sm += i\n        if sm >= k:\n            p = i\n            break\n    print(n*(n+1)//2 - (p*(p+1)//2)) \n", "\n\ndef main():\n    \"\"\"\n    The idea is to use dynamic programming to calculate sub-problems.\n    For each character in the string, find the minimum cost to create a set of size k.\n    \"\"\"\n    n, k = map(int, input().split())\n    s = input()\n    dp = [0] * (k + 1)  # dp[i] is the minimum cost to create a set of size i.\n    for i in range(n):\n        for j in range(k, 0, -1):\n            if j == 1:\n                dp[j] = dp[j] + 1  # Add the current character to the set.\n            else:\n                dp[j] = min(dp[j], dp[j - 1])  # Either add the current character to the set or not.\n    result = dp[k]\n    print(result if result <= n else -1)\n\nif __name__ == '__main__':\n    main()\n", "\n#Solution\n\nn,k=map(int,input().split())\ns=input()\nl=[]\nfor i in range(n):\n    for j in range(i+1,n+1):\n        l.append(s[i:j])\nl.sort(key=len)\ns=set()\nc=0\nfor i in l:\n    if len(s)==k:\n        break\n    if i not in s:\n        s.add(i)\n        c+=n-len(i)\nif len(s)==k:\n    print(c)\nelse:\n    print(-1)\n", "import sys\nsys.setrecursionlimit(10**6)\n\nn, k = map(int, input().split())\ns = input()\nans = 0\ndef dfs(i, sm):\n    global ans\n    if i == n:\n        if sm == k:\n            ans += 1\n        return\n    if sm > k:\n        return\n    dfs(i+1, sm)\n    dfs(i+1, sm+int(s[i]))\ndfs(0, 0)\nprint(ans)\n", "\n\ndef main():\n    \"\"\"\n    The idea is to use dynamic programming to calculate sub problems.\n    For each character in the string, find the minimum cost to create a set of size k. \n    \"\"\"\n    n, k = map(int, input().split())\n    s = input()\n    dp = [0] * (k + 1) # dp[i] is the minimum cost to create a set of size i\n    for i in range(n):\n        for j in range(k, 0, -1):\n            if j == 1:\n                dp[j] = dp[j] + 1 # if we have a set of size 1, then the cost is the number of characters we have seen so far\n            else:\n                dp[j] = min(dp[j], dp[j - 1]) # the cost is the minimum of the cost of the previous set or the cost of the current set\n    result = dp[k]\n    print(result if result <= n else -1)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    \"\"\"\n    The idea is to use dynamic programming to calculate sub-problems.\n    For each character in the string, find the minimum cost to create a set of size k.\n    \"\"\"\n    n, k = map(int, input().split())\n    s = input()\n    dp = [0] * (k + 1)  # dp[i] is the minimum cost to create a set of size i\n    for i in range(n):\n        for j in range(k, 0, -1):\n            if j == 1:\n                dp[j] += 1\n            else:\n                dp[j] = min(dp[j], dp[j - 1])\n    result = dp[k]\n    print(result if result <= n else -1)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Solution\n\nn,k=map(int,input().split())\ns=input()\nl=[]\nfor i in range(n):\n    for j in range(i+1,n+1):\n        l.append(s[i:j])\nl.sort(key=len)\ns=set()\nc=0\nfor i in l:\n    if len(s)==k:\n        break\n    if i not in s:\n        s.add(i)\n        c+=n-len(i)\nif len(s)==k:\n    print(c)\nelse:\n    print(-1)\n", "\n\ndef main():\n    \"\"\"\n    The idea is to use dynamic programming to calculate sub problems.\n    For each character in the string, find the minimum cost to create a set of size k.\n    \"\"\"\n    n, k = map(int, input().split())\n    s = input()\n    dp = [0] * (k + 1)  # dp[i] is the minimum cost to create a set of size i.\n    for i in range(n):\n        for j in range(k, 0, -1):\n            if j == 1:\n                dp[j] += 1\n            else:\n                dp[j] = min(dp[j], dp[j - 1])\n    result = dp[k]\n    print(result if result <= n else -1)\n\nif __name__ == '__main__':\n    main()\n"]