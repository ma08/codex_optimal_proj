2022-04-10 13:46:47.767898 num operations 2
2022-04-10 13:46:47.767926 size on input set 1
2022-04-10 13:46:59.830818 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\ndef solve(n, m, p):\n    \"\"\"\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    \"\"\"\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count) * (n - i) ** (right_count_r - left_count)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    \"\"\"\n    return nCr\n    \"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n"
    },
    {
      "index": 1,
      "text": "\ndef solve(n, m, p):\n    \"\"\"\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    \"\"\"\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count_r)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count_r) * (n - i - 1) ** (right_count_r - left_count_r)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    \"\"\"\n    return nCr\n    \"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n"
    }
  ],
  "created": 1649612808,
  "object": "edit"
}
2022-04-10 13:46:59.831638 fix spelling mistakes 2 ['\ndef solve(n, m, p):\n    """\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    """\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count) * (n - i) ** (right_count_r - left_count)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    """\n    return nCr\n    """\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n', '\ndef solve(n, m, p):\n    """\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    """\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count_r)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count_r) * (n - i - 1) ** (right_count_r - left_count_r)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    """\n    return nCr\n    """\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n']
2022-04-10 13:46:59.831867 size on output set 2
2022-04-10 13:46:59.831879 size on input set 2
2022-04-10 13:47:09.050765 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef solve(n, m, p):\n    \"\"\"\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    \"\"\"\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count_r)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count_r) * (n - i - 1) ** (right_count_r - left_count_r)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, j) * (n - i - 1) ** j for j in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, j) * (i - 1) ** j for j in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    \"\"\"\n    return nCr\n    \"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n"
    },
    {
      "index": 1,
      "text": "\ndef solve(n, m, p):\n    \"\"\"\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    \"\"\"\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count_r)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count_r}\n                count += nCr(right_count_r, right_count_r - left_count_r) * (n - i - 1) ** (right_count_r - left_count_r)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    \"\"\"\n    return nCr\n    \"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n"
    }
  ],
  "created": 1649612820,
  "object": "edit"
}
2022-04-10 13:47:09.051074 fix syntax errors 2 ['\ndef solve(n, m, p):\n    """\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    """\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count_r)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count_r) * (n - i - 1) ** (right_count_r - left_count_r)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, j) * (n - i - 1) ** j for j in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, j) * (i - 1) ** j for j in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    """\n    return nCr\n    """\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n', '\ndef solve(n, m, p):\n    """\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    """\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count_r)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count_r}\n                count += nCr(right_count_r, right_count_r - left_count_r) * (n - i - 1) ** (right_count_r - left_count_r)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    """\n    return nCr\n    """\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n']
2022-04-10 13:47:13.874743 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import math\n\ndef solve(n, m, p):\n    \"\"\"\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    \"\"\"\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count) * (n - i) ** (right_count_r - left_count)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    \"\"\"\n    return nCr\n    \"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n"
    },
    {
      "index": 1,
      "text": "import math\n\ndef solve(n, m, p):\n    \"\"\"\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    \"\"\"\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count) * (n - i) ** (right_count_r - left_count)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    \"\"\"\n    return nCr\n    \"\"\"\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n"
    }
  ],
  "created": 1649612829,
  "object": "edit"
}
2022-04-10 13:47:13.875017 fix syntax errors 2 ['import math\n\ndef solve(n, m, p):\n    """\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    """\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count) * (n - i) ** (right_count_r - left_count)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    """\n    return nCr\n    """\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n', 'import math\n\ndef solve(n, m, p):\n    """\n    count number of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    """\n    # count the number of elements < m, the number of elements == m, the number of elements > m\n    left, mid, right = 0, 0, 0\n    # record the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n    left_count, mid_count, right_count = 0, 0, 0\n    for i in range(n):\n        if p[i] < m:\n            left += 1\n            left_count += 1\n        elif p[i] > m:\n            right += 1\n            right_count += 1\n        else:\n            mid += 1\n            mid_count += 1\n    # record the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n    left_count_r, mid_count_r, right_count_r = left, mid, right\n    # record the number of combinations of pairs of indices (l, r) (1 <= l <= r <= n) where the median of p_l, p_{l+1}, ..., p_r is exactly the given number m\n    count = 0\n    # loop through each index i\n    for i in range(n):\n        # if p[i] == m, then for each index j >= i, we have a pair of indices (i, j) where the median of p_i, p_{i+1}, ..., p_j is exactly the given number m\n        if p[i] == m:\n            count += n - i\n        # if p[i] < m, then we need to find the number of elements > m after p[i]\n        elif p[i] < m:\n            # if there exists at least one element > m after p[i]\n            if right_count_r > 0:\n                # we need to find the number of elements > m after p[i] such that the number of elements < m before p[i] is exactly the number of elements > m after p[i]\n                # the number of ways to choose the number of elements > m after p[i] from the number of elements > m after p[i] is C(right_count_r, right_count_r - left_count)\n                # for each of the chosen number of elements > m after p[i], we can choose the positions of these elements from the number of elements > m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements > m after p[i] from the number of elements > m after p[i] is (n - i - 1)^{right_count_r - left_count}\n                count += nCr(right_count_r, right_count_r - left_count) * (n - i) ** (right_count_r - left_count)\n            # if there exists at least one element == m after p[i]\n            if mid_count_r > 0:\n                # we need to find the number of elements == m after p[i]\n                # for each number of elements == m after p[i] from 1 to mid_count_r, we can choose the positions of these elements from the number of elements == m after p[i] in n - i ways\n                # the number of ways to choose the positions of the number of elements == m after p[i] from the number of elements == m after p[i] is (n - i - 1)^{mid_count_r}\n                count += sum(nCr(mid_count_r, i) * (n - i - 1) ** i for i in range(1, mid_count_r + 1))\n        # if p[i] > m, then we need to find the number of elements < m before p[i]\n        else:\n            # if there exists at least one element < m before p[i]\n            if left_count > 0:\n                # we need to find the number of elements < m before p[i] such that the number of elements > m after p[i] is exactly the number of elements < m before p[i]\n                # the number of ways to choose the number of elements < m before p[i] from the number of elements < m before p[i] is C(left_count, left_count - right_count_r)\n                # for each of the chosen number of elements < m before p[i], we can choose the positions of these elements from the number of elements < m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements < m before p[i] from the number of elements < m before p[i] is (i - 1)^{left_count - right_count_r}\n                count += nCr(left_count, left_count - right_count_r) * (i - 1) ** (left_count - right_count_r)\n            # if there exists at least one element == m before p[i]\n            if mid_count > 0:\n                # we need to find the number of elements == m before p[i]\n                # for each number of elements == m before p[i] from 1 to mid_count, we can choose the positions of these elements from the number of elements == m before p[i] in i - 1 ways\n                # the number of ways to choose the positions of the number of elements == m before p[i] from the number of elements == m before p[i] is (i - 1)^{mid_count}\n                count += sum(nCr(mid_count, i) * (i - 1) ** i for i in range(1, mid_count + 1))\n        # update the number of elements < m in p[:i], the number of elements == m in p[:i], the number of elements > m in p[:i]\n        if p[i] < m:\n            left_count -= 1\n        elif p[i] > m:\n            right_count -= 1\n        else:\n            mid_count -= 1\n        # update the number of elements < m in p[i:], the number of elements == m in p[i:], the number of elements > m in p[i:]\n        if p[i] < m:\n            right_count_r -= 1\n        elif p[i] > m:\n            left_count_r -= 1\n        else:\n            mid_count_r -= 1\n    return count\n\ndef nCr(n, r):\n    """\n    return nCr\n    """\n    f = math.factorial\n    return f(n) // f(r) // f(n - r)\n\n# read the input\nn, m = map(int, input().split())\np = list(map(int, input().split()))\n\n# solve the problem\nres = solve(n, m, p)\n\n# print the result\nprint(res)\n']
2022-04-10 13:47:13.875154 size on output set 3
2022-04-10 13:47:13.875167 num operations 2
2022-04-10 13:47:13.875174 size on input set 1
2022-04-10 13:47:18.370776 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\n\nsorted_arr = sorted(arr)\n\nif (n % 2 == 0):\n    median = (sorted_arr[n // 2 - 1] + sorted_arr[n // 2]) / 2\nelse:\n    median = sorted_arr[n // 2]\n\nif (median != m):\n    print(0)\n    exit()\n\ncount = 0\n\nleft_pointer = 0\nright_pointer = n - 1\n\nwhile (left_pointer <= right_pointer):\n    if (arr[left_pointer] == m):\n        count += 1\n        left_pointer += 1\n    elif (arr[right_pointer] == m):\n        count += 1\n        right_pointer -= 1\n    else:\n        left_pointer += 1\n        right_pointer -= 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\n\nsorted_arr = sorted(arr)\n\nif (n % 2 == 0):\n    median = (sorted_arr[n // 2 - 1] + sorted_arr[n // 2]) / 2\nelse:\n    median = sorted_arr[n // 2]\n\nif (median != m):\n    print(0)\n    exit()\n\ncount = 0\n\nleft_pointer = 0\nright_pointer = n - 1\n\nwhile (left_pointer <= right_pointer):\n    if (arr[left_pointer] == m):\n        count += 1\n        left_pointer += 1\n    elif (arr[right_pointer] == m):\n        count += 1\n        right_pointer -= 1\n    else:\n        left_pointer += 1\n        right_pointer -= 1\n\nprint(count)\n"
    }
  ],
  "created": 1649612834,
  "object": "edit"
}
2022-04-10 13:47:18.370916 fix spelling mistakes 2 ['\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\n\nsorted_arr = sorted(arr)\n\nif (n % 2 == 0):\n    median = (sorted_arr[n // 2 - 1] + sorted_arr[n // 2]) / 2\nelse:\n    median = sorted_arr[n // 2]\n\nif (median != m):\n    print(0)\n    exit()\n\ncount = 0\n\nleft_pointer = 0\nright_pointer = n - 1\n\nwhile (left_pointer <= right_pointer):\n    if (arr[left_pointer] == m):\n        count += 1\n        left_pointer += 1\n    elif (arr[right_pointer] == m):\n        count += 1\n        right_pointer -= 1\n    else:\n        left_pointer += 1\n        right_pointer -= 1\n\nprint(count)\n', '\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\n\nsorted_arr = sorted(arr)\n\nif (n % 2 == 0):\n    median = (sorted_arr[n // 2 - 1] + sorted_arr[n // 2]) / 2\nelse:\n    median = sorted_arr[n // 2]\n\nif (median != m):\n    print(0)\n    exit()\n\ncount = 0\n\nleft_pointer = 0\nright_pointer = n - 1\n\nwhile (left_pointer <= right_pointer):\n    if (arr[left_pointer] == m):\n        count += 1\n        left_pointer += 1\n    elif (arr[right_pointer] == m):\n        count += 1\n        right_pointer -= 1\n    else:\n        left_pointer += 1\n        right_pointer -= 1\n\nprint(count)\n']
2022-04-10 13:47:18.370934 size on output set 1
2022-04-10 13:47:18.370938 size on input set 1
2022-04-10 13:47:29.122738 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "n, m = map(int, input().split())\narr = list(map(int, input().split()))\n\nsorted_arr = sorted(arr)\n\nif n % 2 == 0:\n    median = (sorted_arr[n // 2 - 1] + sorted_arr[n // 2]) / 2\nelse:\n    median = sorted_arr[n // 2]\n\nif median != m:\n    print(0)\n    exit()\n\ncount = 0\n\nleft_pointer = 0\nright_pointer = n - 1\n\nwhile left_pointer <= right_pointer:\n    if arr[left_pointer] == m:\n        count += 1\n        left_pointer += 1\n    elif arr[right_pointer] == m:\n        count += 1\n        right_pointer -= 1\n    else:\n        left_pointer += 1\n        right_pointer -= 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "print(\"Hello World\")\n"
    }
  ],
  "created": 1649612838,
  "object": "edit"
}
2022-04-10 13:47:29.122915 fix syntax errors 2 ['n, m = map(int, input().split())\narr = list(map(int, input().split()))\n\nsorted_arr = sorted(arr)\n\nif n % 2 == 0:\n    median = (sorted_arr[n // 2 - 1] + sorted_arr[n // 2]) / 2\nelse:\n    median = sorted_arr[n // 2]\n\nif median != m:\n    print(0)\n    exit()\n\ncount = 0\n\nleft_pointer = 0\nright_pointer = n - 1\n\nwhile left_pointer <= right_pointer:\n    if arr[left_pointer] == m:\n        count += 1\n        left_pointer += 1\n    elif arr[right_pointer] == m:\n        count += 1\n        right_pointer -= 1\n    else:\n        left_pointer += 1\n        right_pointer -= 1\n\nprint(count)\n', 'print("Hello World")\n']
2022-04-10 13:47:29.122941 size on output set 2
2022-04-10 13:47:29.122952 num operations 2
2022-04-10 13:47:29.122958 size on input set 1
2022-04-10 13:47:36.322908 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, m, p):\n    temp_list = []\n    for index in range(n):\n        temp_list.append(index)\n    temp_list.sort(key=lambda i: p[i])\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    # print(median, median_2)\n    # print(temp_list)\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, m, p))\n"
    },
    {
      "index": 1,
      "text": "\n\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, p):\n    temp_list = []\n    for index in range(n):\n        temp_list.append(index)\n    temp_list.sort(key=lambda i: p[i])\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    # print(median, median_2)\n    # print(temp_list)\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, m, p))\n"
    }
  ],
  "created": 1649612849,
  "object": "edit"
}
2022-04-10 13:47:36.323147 fix spelling mistakes 2 ["\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, m, p):\n    temp_list = []\n    for index in range(n):\n        temp_list.append(index)\n    temp_list.sort(key=lambda i: p[i])\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    # print(median, median_2)\n    # print(temp_list)\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, m, p))\n", "\n\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, p):\n    temp_list = []\n    for index in range(n):\n        temp_list.append(index)\n    temp_list.sort(key=lambda i: p[i])\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    # print(median, median_2)\n    # print(temp_list)\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, m, p))\n"]
2022-04-10 13:47:36.323299 size on output set 2
2022-04-10 13:47:36.323311 size on input set 2
2022-04-10 13:47:42.050710 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, p):\n    temp_list = []\n    for index in range(n):\n        temp_list.append(index)\n    temp_list.sort(key=lambda i: p[i])\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    # print(median, median_2)\n    # print(temp_list)\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, p))\n"
    },
    {
      "index": 1,
      "text": "\n\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, p):\n    temp_list = []\n    for index in range(n):\n        temp_list.append(index)\n    temp_list.sort(key=lambda i: p[i])\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    # print(median, median_2)\n    # print(temp_list)\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, p))\n"
    }
  ],
  "created": 1649612856,
  "object": "edit"
}
2022-04-10 13:47:42.050865 fix syntax errors 2 ["\n\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, p):\n    temp_list = []\n    for index in range(n):\n        temp_list.append(index)\n    temp_list.sort(key=lambda i: p[i])\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    # print(median, median_2)\n    # print(temp_list)\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, p))\n", "\n\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, p):\n    temp_list = []\n    for index in range(n):\n        temp_list.append(index)\n    temp_list.sort(key=lambda i: p[i])\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    # print(median, median_2)\n    # print(temp_list)\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, p))\n"]
2022-04-10 13:47:50.906752 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, m, p):\n    temp_list = list(range(n))\n    temp_list.sort(key=lambda i: p[i])\n    median = temp_list[n // 2]\n    if n % 2 == 0:\n        median_2 = temp_list[n // 2 - 1]\n    else:\n        median_2 = median\n    result = 0\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, m, p))\n"
    },
    {
      "index": 1,
      "text": "\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, m, p):\n    temp_list = list(range(n))\n    temp_list.sort(key=lambda i: p[i])  # sort by p[i]\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, m, p))\n"
    }
  ],
  "created": 1649612862,
  "object": "edit"
}
2022-04-10 13:47:50.906954 fix syntax errors 2 ["\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, m, p):\n    temp_list = list(range(n))\n    temp_list.sort(key=lambda i: p[i])\n    median = temp_list[n // 2]\n    if n % 2 == 0:\n        median_2 = temp_list[n // 2 - 1]\n    else:\n        median_2 = median\n    result = 0\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, m, p))\n", "\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\n\ndef read_single_int():\n    return int(input())\n\n\ndef get_number_of_pairs(n, m, p):\n    temp_list = list(range(n))\n    temp_list.sort(key=lambda i: p[i])  # sort by p[i]\n    median_index = n // 2\n    median = temp_list[median_index]\n    if n % 2 == 0:\n        median_2 = temp_list[median_index - 1]\n    else:\n        median_2 = median\n    result = 0\n    for index in range(n):\n        if p[index] == median:\n            result += temp_list.index(index) + 1\n    for index in range(n):\n        if p[index] == median_2:\n            result += temp_list.index(index) + 1\n    return result\n\n\nif __name__ == '__main__':\n    n, m = read_list_int()\n    p = read_list_int()\n    print(get_number_of_pairs(n, m, p))\n"]
2022-04-10 13:47:50.907120 size on output set 3
