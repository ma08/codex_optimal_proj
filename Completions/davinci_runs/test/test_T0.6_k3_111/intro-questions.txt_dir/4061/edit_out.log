2022-04-10 13:11:09.602335 num operations 2
2022-04-10 13:11:09.602377 size on input set 1
2022-04-10 13:11:16.071698 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef subseq(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n    return i == len(t)\n\ndef main():\n    s = input()\n    t = input()\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subseq(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef subseq(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n    return i == len(t)\n\ndef main():\n    s = input()\n    t = input()\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subseq(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649610669,
  "object": "edit"
}
2022-04-10 13:11:16.072027 fix spelling mistakes 2 ["\n\ndef subseq(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n    return i == len(t)\n\ndef main():\n    s = input()\n    t = input()\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subseq(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef subseq(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n    return i == len(t)\n\ndef main():\n    s = input()\n    t = input()\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subseq(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-10 13:11:16.072198 size on output set 1
2022-04-10 13:11:16.072235 size on input set 1
2022-04-10 13:11:22.142709 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef subseq(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n    return i == len(t)\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    t = sys.stdin.readline().rstrip()\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subseq(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef subseq(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n\n    return i == len(t)\n    # s = input()\n    # t = input()\n\ndef main():\n    s = input()\n    t = \"abc\"\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subseq(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649610676,
  "object": "edit"
}
2022-04-10 13:11:22.142937 fix syntax errors 2 ["import sys\n\ndef subseq(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n    return i == len(t)\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    t = sys.stdin.readline().rstrip()\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subseq(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\nif __name__ == '__main__':\n    main()\n", '\ndef subseq(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n\n    return i == len(t)\n    # s = input()\n    # t = input()\n\ndef main():\n    s = input()\n    t = "abc"\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subseq(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-10 13:11:22.142988 size on output set 2
2022-04-10 13:11:22.143007 num operations 2
2022-04-10 13:11:22.143014 size on input set 1
2022-04-10 13:11:27.650989 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a sub-sequence of s\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\"\"\"\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a subsequence of s.\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\"\"\"\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649610682,
  "object": "edit"
}
2022-04-10 13:11:27.651235 fix spelling mistakes 2 ['\n\n"""\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a sub-sequence of s\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n"""\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == \'__main__\':\n    main()\n', '\n\n"""\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a subsequence of s.\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n"""\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-10 13:11:27.651495 size on output set 2
2022-04-10 13:11:27.651527 size on input set 2
2022-04-10 13:11:36.199002 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Approach:\n# 1. Find all the indices where the character in t is found in s\n# 2. Now, the elements between these indices(inclusive) should be removed, so that t is a subsequence of s.\n# 3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\"\"\"\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a subsequence of s.\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\"\"\"\n\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649610687,
  "object": "edit"
}
2022-04-10 13:11:36.199644 fix syntax errors 2 ["\n\n# Approach:\n# 1. Find all the indices where the character in t is found in s\n# 2. Now, the elements between these indices(inclusive) should be removed, so that t is a subsequence of s.\n# 3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == '__main__':\n    main()\n", '\n"""\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a subsequence of s.\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n"""\n\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-10 13:11:42.990881 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\"\"\"\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a sub-sequence of s\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\n\"\"\"\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\"\"\"\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a sub-sequence of s\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\"\"\"\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649610696,
  "object": "edit"
}
2022-04-10 13:11:42.991144 fix syntax errors 2 ['\n"""\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a sub-sequence of s\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\n"""\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == \'__main__\':\n    main()\n', '\n"""\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a sub-sequence of s\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n"""\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == \'__main__\':\n    main()\n']
2022-04-10 13:11:42.991169 size on output set 4
2022-04-10 13:11:42.991185 num operations 2
2022-04-10 13:11:42.991190 size on input set 1
2022-04-10 13:11:50.262721 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef find_substring_length(s, t):\n    \"\"\"\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    \"\"\"\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord('a')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord('a')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord('a')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef find_substring_length(s, t):\n    \"\"\"\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    \"\"\"\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord('a')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord('a')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord('a')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))\n"
    }
  ],
  "created": 1649610703,
  "object": "edit"
}
2022-04-10 13:11:50.263035 fix spelling mistakes 2 ['\n\nimport sys\n\ndef find_substring_length(s, t):\n    """\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    """\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord(\'a\')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord(\'a\')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord(\'a\')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == "__main__":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))\n', '\n\nimport sys\n\ndef find_substring_length(s, t):\n    """\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    """\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord(\'a\')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord(\'a\')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord(\'a\')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == "__main__":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))\n']
2022-04-10 13:11:50.263117 size on output set 1
2022-04-10 13:11:50.263125 size on input set 1
2022-04-10 13:12:05.718727 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef find_substring_length(s, t):\n    \"\"\"\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    \"\"\"\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord('a')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord('a')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord('a')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef find_substring_length(s, t):\n    \"\"\"\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    \"\"\"\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letters in $s$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letters in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1, i.e. the letter is not in the current substring)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letters in $s$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord('a')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord('a')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord('a')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))\n"
    }
  ],
  "created": 1649610710,
  "object": "edit"
}
2022-04-10 13:12:05.718986 fix syntax errors 2 ['\nimport sys\n\ndef find_substring_length(s, t):\n    """\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    """\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letter in $s$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord(\'a\')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord(\'a\')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord(\'a\')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == "__main__":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))\n', '\n\nimport sys\n\ndef find_substring_length(s, t):\n    """\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    """\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letters in $s$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letters in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1, i.e. the letter is not in the current substring)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letters in $s$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord(\'a\')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord(\'a\')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord(\'a\')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == "__main__":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))\n']
2022-04-10 13:12:05.719033 size on output set 2
