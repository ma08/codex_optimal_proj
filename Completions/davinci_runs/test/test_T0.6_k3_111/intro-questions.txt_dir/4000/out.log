"""
You are given an unweighted tree with $n$ vertices. Recall that a tree is a connected undirected graph without cycles.

Your task is to choose three distinct vertices $a, b, c$ on this tree such that the number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$ is the maximum possible. See the notes section for a better understanding.

The simple path is the path that visits each vertex at most once.


-----Input-----

The first line contains one integer number $n$ ($3 \le n \le 2 \cdot 10^5$) — the number of vertices in the tree. 

Next $n - 1$ lines describe the edges of the tree in form $a_i, b_i$ ($1 \le a_i$, $b_i \le n$, $a_i \ne b_i$). It is guaranteed that given graph is a tree.


-----Output-----

In the first line print one integer $res$ — the maximum number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$.

In the second line print three integers $a, b, c$ such that $1 \le a, b, c \le n$ and $a \ne, b \ne c, a \ne c$.

If there are several answers, you can print any.


-----Example-----
Input
8
1 2
2 3
3 4
4 5
4 6
3 7
3 8

Output
5
1 8 6



-----Note-----

The picture corresponding to the first example (and another one correct answer):

[Image]

If you choose vertices $1, 5, 6$ then the path between $1$ and $5$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 5)$, the path between $1$ and $6$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 6)$ and the path between $5$ and $6$ consists of edges $(4, 5), (4, 6)$. The union of these paths is $(1, 2), (2, 3), (3, 4), (4, 5), (4, 6)$ so the answer is $5$. It can be shown that there is no better answer.
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\nimport heapq\nfrom collections import deque, defaultdict\nfrom itertools import permutations, combinations, product\nfrom operator import itemgetter\nfrom copy import deepcopy\nimport random\n\ndef reverse_int(x):\n    y, res = 0, 0\n    while x > 0:\n        y = x % 10\n        res = res * 10 + y\n        x /= 10\n    return res\n\ndef read_list(t): return [t(x) for x in sys.stdin.readline().split()]\ndef read_line(t): return t(sys.stdin.readline().strip())\ndef read_lines(t, N): return [t(sys.stdin.readline().strip()) for _ in range(N)]\n\n\n# n = read_line(int)\n# adj = defaultdict(list)\n# for _ in range(n-1):\n#     a, b = read_list(int)\n#     adj[a].append(b)\n#     adj[b].append(a)\n# print adj\nn = read_line(int)\nadj = defaultdict(list)\nfor _ in range(n-1):\n    a, b = read_list(int)\n    adj[a].append(b)\n    adj[b].append(a)\n\ndef dfs(adj, v, parent, dist):\n    for n in adj[v]:\n        if n != parent:\n            dist[n] = dist[v] + 1\n            dfs(adj, n, v, dist)\n\ndef find_parent(adj, dist, v):\n    maxdist = 0\n    maxv = 0\n    for n in adj[v]:\n        if dist[n] > maxdist:\n            maxdist = dist[n]\n            maxv = n\n    return maxv\n\ndef find_max_dist(adj, dist, v):\n    q = deque([v])\n    while q:\n        v = q.popleft()\n        if dist[v] == 0:\n            continue\n        for n in adj[v]:\n            if dist[n] == 0:\n                q.append(n)\n                dist[n] = dist[v] + 1\n\na = 1\ndist = defaultdict(int)\ndist[a] = 1\ndfs(adj, a, 0, dist)\nb = find_parent(adj, dist, a)\ndist = defaultdict(int)\ndist[b] = 1\ndfs(adj, b, 0, dist)\nc = find_parent(adj, dist, b)\n\ndist = defaultdict(int)\ndist[a] = 1\nfind_max_dist(adj, dist, a)\ndist[b] = 1\nfind_max_dist(adj, dist, b)\ndist[c] = 1\nfind_max_dist(adj, dist, c)\n\nprint max(dist.values())\nprint a, c, b"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n# Solution\n\nimport queue\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor i in range(N - 1):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\ndef bfs(graph, start):\n    dist = [None for i in graph]\n    dist[start] = 0\n    q = queue.Queue()\n    q.put(start)\n    while not q.empty():\n        cur = q.get()\n        for neighbor in graph[cur]:\n            if dist[neighbor] is None:\n                dist[neighbor] = dist[cur] + 1\n                q.put(neighbor)\n    return dist\n\ndist_from_1 = bfs(graph, 0)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_1[i] > dist_from_1[max_vertex]:\n        max_vertex = i\n\na = 0\nb = max_vertex\ndist_from_b = bfs(graph, max_vertex)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_b[i] > dist_from_b[max_vertex]:\n        max_vertex = i\nc = max_vertex\n\nres = dist_from_1[b] + dist_from_b[c]\nprint(res)\nprint(a + 1, b + 1, c + 1)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nimport queue\n\ndef bfs(tree, root, visited):\n    visited[root] = True\n    q = queue.Queue()\n    q.put(root)\n    while not q.empty():\n        curr = q.get()\n        for neighbor in tree[curr]:\n            if not visited[neighbor]:\n                q.put(neighbor)\n                visited[neighbor] = True\n\ndef get_connected_components(tree, n):\n    visited = [False] * (n + 1)\n    cc = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            bfs(tree, i, visited)\n            cc += 1\n    return cc\n\ndef main():\n    nextint = iter(map(int, sys.stdin.read().split())).__next__\n    n = nextint()\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = nextint(), nextint()\n        tree[a].append(b)\n        tree[b].append(a)\n    # No need to check if the input is a tree, since it's guaranteed to be a tree.\n    cc = get_connected_components(tree, n)\n    if cc == 1:\n        res = n - 1\n        a = 1\n        b = 2\n        c = 3\n    elif cc == 2:\n        res = n - 2\n        a = b = c = 1\n    else:\n        res = n - 3\n        a = b = 1\n        c = 2\n    print(res)\n    print('{} {} {}'.format(a, b, c))\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1648691875,
  "id": "cmpl-4reMNb5pieehgfZasw8Nt7jCyvoMW",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\nimport heapq\nfrom collections import deque, defaultdict\nfrom itertools import permutations, combinations, product\nfrom operator import itemgetter\nfrom copy import deepcopy\nimport random\n\ndef reverse_int(x):\n    y, res = 0, 0\n    while x > 0:\n        y = x % 10\n        res = res * 10 + y\n        x /= 10\n    return res\n\ndef read_list(t): return [t(x) for x in sys.stdin.readline().split()]\ndef read_line(t): return t(sys.stdin.readline().strip())\ndef read_lines(t, N): return [t(sys.stdin.readline().strip()) for _ in range(N)]\n\n\n# n = read_line(int)\n# adj = defaultdict(list)\n# for _ in range(n-1):\n#     a, b = read_list(int)\n#     adj[a].append(b)\n#     adj[b].append(a)\n# print adj\nn = read_line(int)\nadj = defaultdict(list)\nfor _ in range(n-1):\n    a, b = read_list(int)\n    adj[a].append(b)\n    adj[b].append(a)\n\ndef dfs(adj, v, parent, dist):\n    for n in adj[v]:\n        if n != parent:\n            dist[n] = dist[v] + 1\n            dfs(adj, n, v, dist)\n\ndef find_parent(adj, dist, v):\n    maxdist = 0\n    maxv = 0\n    for n in adj[v]:\n        if dist[n] > maxdist:\n            maxdist = dist[n]\n            maxv = n\n    return maxv\n\ndef find_max_dist(adj, dist, v):\n    q = deque([v])\n    while q:\n        v = q.popleft()\n        if dist[v] == 0:\n            continue\n        for n in adj[v]:\n            if dist[n] == 0:\n                q.append(n)\n                dist[n] = dist[v] + 1\n\na = 1\ndist = defaultdict(int)\ndist[a] = 1\ndfs(adj, a, 0, dist)\nb = find_parent(adj, dist, a)\ndist = defaultdict(int)\ndist[b] = 1\ndfs(adj, b, 0, dist)\nc = find_parent(adj, dist, b)\n\ndist = defaultdict(int)\ndist[a] = 1\nfind_max_dist(adj, dist, a)\ndist[b] = 1\nfind_max_dist(adj, dist, b)\ndist[c] = 1\nfind_max_dist(adj, dist, c)\n\nprint max(dist.values())\nprint a, c, b"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n# Solution\n\nimport queue\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor i in range(N - 1):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\ndef bfs(graph, start):\n    dist = [None for i in graph]\n    dist[start] = 0\n    q = queue.Queue()\n    q.put(start)\n    while not q.empty():\n        cur = q.get()\n        for neighbor in graph[cur]:\n            if dist[neighbor] is None:\n                dist[neighbor] = dist[cur] + 1\n                q.put(neighbor)\n    return dist\n\ndist_from_1 = bfs(graph, 0)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_1[i] > dist_from_1[max_vertex]:\n        max_vertex = i\n\na = 0\nb = max_vertex\ndist_from_b = bfs(graph, max_vertex)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_b[i] > dist_from_b[max_vertex]:\n        max_vertex = i\nc = max_vertex\n\nres = dist_from_1[b] + dist_from_b[c]\nprint(res)\nprint(a + 1, b + 1, c + 1)"
}
REASON stop
2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nimport queue\n\ndef bfs(tree, root, visited):\n    visited[root] = True\n    q = queue.Queue()\n    q.put(root)\n    while not q.empty():\n        curr = q.get()\n        for neighbor in tree[curr]:\n            if not visited[neighbor]:\n                q.put(neighbor)\n                visited[neighbor] = True\n\ndef get_connected_components(tree, n):\n    visited = [False] * (n + 1)\n    cc = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            bfs(tree, i, visited)\n            cc += 1\n    return cc\n\ndef main():\n    nextint = iter(map(int, sys.stdin.read().split())).__next__\n    n = nextint()\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = nextint(), nextint()\n        tree[a].append(b)\n        tree[b].append(a)\n    # No need to check if the input is a tree, since it's guaranteed to be a tree.\n    cc = get_connected_components(tree, n)\n    if cc == 1:\n        res = n - 1\n        a = 1\n        b = 2\n        c = 3\n    elif cc == 2:\n        res = n - 2\n        a = b = c = 1\n    else:\n        res = n - 3\n        a = b = 1\n        c = 2\n    print(res)\n    print('{} {} {}'.format(a, b, c))\n\nif __name__ == '__main__':\n    main()"
}
REASON stop
