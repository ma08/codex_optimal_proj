["\nimport sys\nimport math\nimport heapq\nfrom collections import deque, defaultdict\nfrom itertools import permutations, combinations, product\nfrom operator import itemgetter\nfrom copy import deepcopy\nimport random\n\ndef reverse_int(x):\n    y, res = 0, 0\n    while x > 0:\n        y = x % 10\n        res = res * 10 + y\n        x /= 10\n    return res\n\ndef read_list(t): return [t(x) for x in sys.stdin.readline().split()]\ndef read_line(t): return t(sys.stdin.readline().strip())\ndef read_lines(t, N): return [t(sys.stdin.readline().strip()) for _ in range(N)]\n#\n\n# n = read_line(int)\n# adj = defaultdict(list)\n# for _ in range(n-1):\n#     a, b = read_list(int)\n#     adj[a].append(b)\n#     adj[b].append(a)\n# print adj\nn = read_line(int)\nadj = defaultdict(list)\nfor _ in range(n-1):\n    a, b = read_list(int)\n    adj[a].append(b)\n    adj[b].append(a)\n\ndef dfs(adj, v, parent, dist):\n    for n in adj[v]:\n        if n != parent:\n            dist[n] = dist[v] + 1\n            dfs(adj, n, v, dist)\n\ndef find_parent(adj, dist, v):\n    maxdist = 0\n    maxv = 0\n    for n in adj[v]:\n        if dist[n] > maxdist:\n            maxdist = dist[n]\n            maxv = n\n    return maxv\n\ndef find_max_dist(adj, dist, v):\n    q = deque([v])\n    while q:\n        v = q.popleft()\n        if dist[v] == 0:\n            continue\n        for n in adj[v]:\n            if dist[n] == 0:\n                q.append(n)\n                dist[n] = dist[v] + 1\n\na = 1\ndist = defaultdict(int)\ndist[a] = 1\ndfs(adj, a, 0, dist)\nb = find_parent(adj, dist, a)\ndist = defaultdict(int)\ndist[b] = 1\ndfs(adj, b, 0, dist)\nc = find_parent(adj, dist, b)\n\ndist = defaultdict(int)\ndist[a] = 1\nfind_max_dist(adj, dist, a)\ndist[b] = 1\nfind_max_dist(adj, dist, b)\ndist[c] = 1\nfind_max_dist(adj, dist, c)\n\nprint max(dist.values())\nprint a, c, b\n", "\n\nimport sys\nimport queue\n\ndef bfs(tree, root, visited):\n    visited[root] = True\n    q = queue.Queue()\n    q.put(root)\n    while not q.empty():\n        curr = q.get()\n        for neighbor in tree[curr]:\n            if not visited[neighbor]:\n                q.put(neighbor)\n                visited[neighbor] = True\n\ndef get_connected_components(tree, n):\n    visited = [False] * (n + 1)\n    cc = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            bfs(tree, i, visited)\n            cc += 1\n    return cc\n\ndef main():\n    nextint = iter(map(int, sys.stdin.read().split())).__next__()\n    n = nextint()\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = nextint(), nextint()\n        tree[a].append(b)\n        tree[b].append(a)\n    # No need to check if the input is a tree, since it's guaranteed to be one.\n    cc = get_connected_components(tree, n)\n    if cc == 1:\n        res = n - 1\n        a = 1\n        b = 2\n        c = 3\n    elif cc == 2:\n        res = n - 2\n        a = b = c = 1\n    else:\n        res = n - 3\n        a = b = 1\n        c = 2\n    print(res)\n    print('{} {} {}'.format(a, b, c))\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Solution\n\nimport queue\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor i in range(N - 1):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\ndef bfs(graph, start):\n    dist = [None for i in graph]\n    dist[start] = 0\n    q = queue.Queue()\n    q.put(start)\n    while not q.empty():\n        cur = q.get()\n        for neighbor in graph[cur]:\n            if dist[neighbor] is None:\n                dist[neighbor] = dist[cur] + 1\n                q.put(neighbor)\n    return dist\n\ndist_from_1 = bfs(graph, 0)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_1[i] > dist_from_1[max_vertex]:\n        max_vertex = i\n\na = 0\nb = max_vertex\ndist_from_b = bfs(graph, max_vertex)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_b[i] > dist_from_b[max_vertex]:\n        max_vertex = i\nc = max_vertex\n\nres = dist_from_1[b] + dist_from_b[c]\nprint(res)\nprint(a + 1, b + 1, c + 1)\n", "\n# Solution \nimport queue\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor i in range(N - 1):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\ndef bfs(graph, start):\n    dist = [None for i in graph]\n    dist[start] = 0\n    q = queue.Queue()\n    q.put(start)\n    while not q.empty():\n        cur = q.get()\n        for neighbor in graph[cur]:\n            if dist[neighbor] is None:\n                dist[neighbor] = dist[cur] + 1\n                q.put(neighbor)\n    return dist\n\ndist_from_1 = bfs(graph, 0)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_1[i] > dist_from_1[max_vertex]:\n        max_vertex = i\n\na = 0\nb = max_vertex\ndist_from_b = bfs(graph, max_vertex)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_b[i] > dist_from_b[max_vertex]:\n        max_vertex = i\nc = max_vertex\n\nres = dist_from_1[b] + dist_from_b[c]\nprint(res)\nprint(a + 1, b + 1, c + 1)\n", "\nimport sys\nimport math\nimport heapq\nfrom collections import deque, defaultdict\nfrom itertools import permutations, combinations, product\nfrom operator import itemgetter\nfrom copy import deepcopy\nimport random\n\ndef read_list(t): return [t(x) for x in sys.stdin.readline().split()]\ndef read_line(t): return t(sys.stdin.readline().strip())\ndef read_lines(t, N): return [t(sys.stdin.readline().strip()) for _ in range(N)]\n\n\nn = read_line(int)\nadj = defaultdict(list)\nfor _ in range(n-1):\n    a, b = read_list(int)\n    adj[a].append(b)\n    adj[b].append(a)\n\ndef dfs(adj, v, parent, dist):\n    for n in adj[v]:\n        if n != parent:\n            dist[n] = dist[v] + 1\n            dfs(adj, n, v, dist)\n\ndef find_parent(adj, dist, v):\n    maxdist = 0\n    maxv = 0\n    for n in adj[v]:\n        if dist[n] > maxdist:\n            maxdist = dist[n]\n            maxv = n\n    return maxv\n\ndef find_max_dist(adj, dist, v):\n    q = deque([v])\n    while q:\n        v = q.popleft()\n        if dist[v] == 0:\n            continue\n        for n in adj[v]:\n            if dist[n] == 0:\n                q.append(n)\n                dist[n] = dist[v] + 1\n\na = 1\ndist = defaultdict(int)\ndist[a] = 1\ndfs(adj, a, 0, dist)\nb = find_parent(adj, dist, a)\ndist = defaultdict(int)\ndist[b] = 1\ndfs(adj, b, 0, dist)\nc = find_parent(adj, dist, b)\n\ndist = defaultdict(int)\ndist[a] = 1\nfind_max_dist(adj, dist, a)\ndist[b] = 1\nfind_max_dist(adj, dist, b)\ndist[c] = 1\nfind_max_dist(adj, dist, c)\n\nprint max(dist.values())\nprint a, c, b\n", "\nimport sys\nimport queue\n\ndef bfs(tree, root, visited):\n    visited[root] = True\n    q = queue.Queue()\n    q.put(root)\n    while not q.empty():\n        curr = q.get()\n        for neighbor in tree[curr]:\n            if not visited[neighbor]:\n                q.put(neighbor)\n                visited[neighbor] = True\n\ndef get_connected_components(tree, n):\n    visited = [False] * (n + 1)\n    cc = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            bfs(tree, i, visited)\n            cc += 1\n    return cc\n\ndef main():\n    nextint = iter(map(int, sys.stdin.read().split())).__next__()\n    n = nextint()\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = nextint(), nextint()\n        tree[a].append(b)\n        tree[b].append(a)\n    # No need to check if the input is a tree, since it's guaranteed to be a tree\n    cc = get_connected_components(tree, n)\n    if cc == 1:\n        res = n - 1\n        a = 1\n        b = 2\n        c = 3\n    elif cc == 2:\n        res = n - 2\n        a = b = c = 1\n    else:\n        res = n - 3\n        a = b = 1\n        c = 2\n    print(res)\n    print('{} {} {}'.format(a, b, c))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport queue\n\ndef bfs(tree, root, visited):\n    visited[root] = True\n    q = queue.Queue()\n    q.put(root)\n    while not q.empty():\n        curr = q.get()\n        for neighbor in tree[curr]:\n            if not visited[neighbor]:\n                q.put(neighbor)\n                visited[neighbor] = True\n\ndef get_connected_components(tree, n):\n    visited = [False] * (n + 1)\n    cc = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            bfs(tree, i, visited)\n            cc += 1\n    return cc\n\ndef main():\n    nextint = iter(map(int, sys.stdin.read().split())).__next__()\n    n = nextint()\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = nextint(), nextint()\n        tree[a].append(b)\n        tree[b].append(a)\n    # No need to check if the input is a tree, since it's guaranteed to be a tree\n    cc = get_connected_components(tree, n)\n    if cc == 1:\n        res = n - 1\n        a = 1\n        b = 2\n        c = 3\n    elif cc == 2:\n        res = n - 2\n        a = b = c = 1\n    else:\n        res = n - 3\n        a = b = 1\n        c = 2\n    print(res)\n    print('{} {} {}'.format(a, b, c))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\nimport heapq\nfrom collections import deque, defaultdict\nfrom itertools import permutations, combinations, product\nfrom operator import itemgetter\nfrom copy import deepcopy\nimport random\n\ndef reverse_int(x):\n    y, res = 0, 0\n    while x > 0:\n        y = x % 10\n        res = res * 10 + y\n        x /= 10\n    return res\n\ndef read_list(t): return [t(x) for x in sys.stdin.readline().split()]\ndef read_line(t): return t(sys.stdin.readline().strip())\ndef read_lines(t, N): return [t(sys.stdin.readline().strip()) for _ in range(N)]\n#\n\n# n = read_line(int)\n# adj = defaultdict(list)\n# for _ in range(n-1):\n#     a, b = read_list(int)\n#     adj[a].append(b)\n#     adj[b].append(a)\n# print adj\nn = read_line(int)\nadj = defaultdict(list)\nfor _ in range(n-1):\n    a, b = read_list(int)\n    adj[a].append(b)\n    adj[b].append(a)\n\ndef dfs(adj, v, parent, dist):\n    for n in adj[v]:\n        if n != parent:\n            dist[n] = dist[v] + 1\n            dfs(adj, n, v, dist)\n\ndef find_parent(adj, dist, v):\n    maxdist = 0\n    maxv = 0\n    for n in adj[v]:\n        if dist[n] > maxdist:\n            maxdist = dist[n]\n            maxv = n\n    return maxv\n\ndef find_max_dist(adj, dist, v):\n    q = deque([v])\n    while q:\n        v = q.popleft()\n        if dist[v] == 0:\n            continue\n        for n in adj[v]:\n            if dist[n] == 0:\n                q.append(n)\n                dist[n] = dist[v] + 1\n\na = 1\ndist = defaultdict(int)\ndist[a] = 1\ndfs(adj, a, 0, dist)\nb = find_parent(adj, dist, a)\ndist = defaultdict(int)\ndist[b] = 1\ndfs(adj, b, 0, dist)\nc = find_parent(adj, dist, b)\n\ndist = defaultdict(int)\ndist[a] = 1\nfind_max_dist(adj, dist, a)\ndist[b] = 1\nfind_max_dist(adj, dist, b)\ndist[c] = 1\nfind_max_dist(adj, dist, c)\n\nprint max(dist.values())\nprint a, c, b\n", "\n\nimport sys\nimport queue\n\ndef bfs(tree, root, visited):\n    visited[root] = True\n    q = queue.Queue()\n    q.put(root)\n    while not q.empty():\n        curr = q.get()\n        for neighbor in tree[curr]:\n            if not visited[neighbor]:\n                q.put(neighbor)\n                visited[neighbor] = True\n\ndef get_connected_components(tree, n):\n    visited = [False] * (n + 1)\n    cc = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            bfs(tree, i, visited)\n            cc += 1\n    return cc\n\ndef main():\n    nextint = iter(map(int, sys.stdin.read().split())).next\n    n = nextint()\n    tree = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = nextint(), nextint()\n        tree[a].append(b)\n        tree[b].append(a)\n    # No need to check if the input is a tree, since it's guaranteed to be one.\n    cc = get_connected_components(tree, n)\n    if cc == 1:\n        res = n - 1\n        a = 1\n        b = 2\n        c = 3\n    elif cc == 2:\n        res = n - 2\n        a = b = c = 1\n    else:\n        res = n - 3\n        a = b = 1\n        c = 2\n    print(res)\n    print('{} {} {}'.format(a, b, c))\n\nif __name__ == '__main__':\n    main()\n", "\n# Solution \nimport queue\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor i in range(N - 1):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\ndef bfs(graph, start):\n    dist = [None for i in graph]\n    dist[start] = 0\n    q = queue.Queue()\n    q.put(start)\n    while not q.empty():\n        cur = q.get()\n        for neighbor in graph[cur]:\n            if dist[neighbor] is None:\n                dist[neighbor] = dist[cur] + 1\n                q.put(neighbor)\n    return dist\ndist_from_1 = bfs(graph, 0)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_1[i] > dist_from_1[max_vertex]:\n        max_vertex = i\na = 0\nb = max_vertex\ndist_from_b = bfs(graph, max_vertex)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_b[i] > dist_from_b[max_vertex]:\n        max_vertex = i\nc = max_vertex\n\nres = dist_from_1[b] + dist_from_b[c]\nprint(res)\nprint(a + 1, b + 1, c + 1)\n", "\n#\n# Solution1\n\nimport queue\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nfor i in range(N - 1):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\ndef bfs(graph, start):\n    dist = [None for i in graph]\n    dist[start] = 0\n    q = queue.Queue()\n    q.put(start)\n    while not q.empty():\n        cur = q.get()\n        for neighbor in graph[cur]:\n            if dist[neighbor] is None:\n                dist[neighbor] = dist[cur] + 1\n                q.put(neighbor)\n    return dist\n\ndist_from_1 = bfs(graph, 0)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_1[i] > dist_from_1[max_vertex]:\n        max_vertex = i\n\na = 0\nb = max_vertex\ndist_from_b = bfs(graph, max_vertex)\nmax_vertex = 0\nfor i in range(1, N):\n    if dist_from_b[i] > dist_from_b[max_vertex]:\n        max_vertex = i\nc = max_vertex\n\nres = dist_from_1[b] + dist_from_b[c]\nprint(res)\nprint(a + 1, b + 1, c + 1)\n", "\nimport sys\nimport math\nimport heapq\nfrom collections import deque, defaultdict\nfrom itertools import permutations, combinations, product\nfrom operator import itemgetter\nfrom copy import deepcopy\nimport random\ndef read_list(t): return [t(x) for x in sys.stdin.readline().split()]\ndef read_line(t): return t(sys.stdin.readline().strip())\ndef read_lines(t, N): return [t(sys.stdin.readline().strip()) for _ in range(N)]\n\nn = read_line(int)\nadj = defaultdict(list)\nfor _ in range(n-1):\n    a, b = read_list(int)\n    adj[a].append(b)\n    adj[b].append(a)\ndef dfs(adj, v, parent, dist):\n    for n in adj[v]:\n        if n != parent:\n            dist[n] = dist[v] + 1\n            dfs(adj, n, v, dist)\ndef find_parent(adj, dist, v):\n    maxdist = 0\n    maxv = 0\n    for n in adj[v]:\n        if dist[n] > maxdist:\n            maxdist = dist[n]\n            maxv = n\n    return maxv\ndef find_max_dist(adj, dist, v):\n    q = deque([v])\n    while q:\n        v = q.popleft()\n        if dist[v] == 0:\n            continue\n        for n in adj[v]:\n            if dist[n] == 0:\n                q.append(n)\n                dist[n] = dist[v] + 1\na = 1\ndist = defaultdict(int)\ndist[a] = 1\ndfs(adj, a, 0, dist)\nb = find_parent(adj, dist, a)\ndist = defaultdict(int)\ndist[b] = 1\ndfs(adj, b, 0, dist)\nc = find_parent(adj, dist, b)\ndist = defaultdict(int)\ndist[a] = 1\nfind_max_dist(adj, dist, a)\ndist[b] = 1\nfind_max_dist(adj, dist, b)\ndist[c] = 1\nfind_max_dist(adj, dist, c)\nprint max(dist.values())\nprint a, c, b\n"]