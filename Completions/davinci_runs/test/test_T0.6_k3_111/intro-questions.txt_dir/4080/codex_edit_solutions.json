["\n\nimport sys\nimport numpy as np\n\n# The key observation is that the optimal solution can be obtained by choosing\n# segments which have the most extreme endpoints.\n# Thus, we can compute the min/max values of all endpoints of segments, then\n# find the optimal solution by choosing the right segments.\n# If we manage to find the optimal solution, then it is unique.\n\nn, m = map(int, sys.stdin.readline().strip().split())\na = list(map(int, sys.stdin.readline().strip().split()))\n\nmin_vals = np.zeros(n)\nmax_vals = np.zeros(n)\nmin_vals[:] = np.inf\nmax_vals[:] = -np.inf\n\nfor i in range(m):\n    l, r = map(int, sys.stdin.readline().strip().split())\n    min_vals[l-1] = min(min_vals[l-1], a[l-1])\n    max_vals[r-1] = max(max_vals[r-1], a[r-1])\n\nfor i in range(1, n):\n    min_vals[i] = min(min_vals[i-1], min_vals[i])\n    max_vals[n-1-i] = max(max_vals[n-i], max_vals[n-1-i])\n\nd = 0\nselected_segments = []\nfor i in range(m):\n    l, r = map(int, sys.stdin.readline().strip().split())\n    d_opt = max(max_vals[r-1], a[r-1]) - min(min_vals[l-1], a[l-1])\n    if d_opt > d:\n        d = d_opt\n        selected_segments = [i+1]\n    elif d_opt == d:\n        selected_segments.append(i+1)\n\nprint(d)\nprint(len(selected_segments))\nprint(' '.join(map(str, selected_segments)))\n", "\n#!/usr/bin/env python3\n\nimport sys\n\ndef read_ints():\n    return tuple(map(int, sys.stdin.readline().strip().split()))\n\ndef read_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\n#\n#\n#\n\ndef read_segments():\n    n, m = read_ints()\n    a = read_array()\n    segments = [(l-1, r-1) for l, r in [read_ints() for i in range(m)]]\n    return a, segments\n\n#\n#\n#\n\ndef max_diff(a, segments):\n    n = len(a)\n\n    a_min = min(a)\n    a_max = max(a)\n\n    if a_min == a_max:\n        return 0, ()\n\n    s_min = [0] * n\n    s_max = [0] * n\n\n    for l, r in segments:\n        s_min[l] += 1\n        s_max[r] += 1\n\n    d_min = 0\n    d_max = 0\n    for i in range(n):\n        d_min += s_min[i]\n        d_max += s_max[i]\n        s_min[i] = d_min\n        s_max[i] = d_max\n\n    d_min = 0\n    d_max = 0\n    j = 0\n\n    for i in range(n):\n        if a[i] == a_min:\n            d_min = s_min[i]\n        if a[i] == a_max:\n            d_max = s_max[i]\n            j = i\n            break\n\n    return d_max - d_min, s_max[:j]\n\na, segments = read_segments()\n\nd, s = max_diff(a, segments)\n\nprint(d)\nprint(len(s))\nprint(' '.join(map(str, s)))\n", "\n\nimport sys\n\ndef get_min_max(l, r):\n    \"\"\"\n    returns the smallest and largest value of the array between l and r, inclusive.\n    \"\"\"\n    min_val = min(arr[l : r+1])\n    max_val = max(arr[l : r+1])\n    return (min_val, max_val)\n\ndef get_max_diff(segment):\n    \"\"\"\n    returns the difference between the largest and smallest values within a segment.\n    \"\"\"\n    min_val, max_val = get_min_max(segment[0] - 1, segment[1] - 1)\n    return max_val - min_val\n\ndef get_segments_to_use(segments):\n    \"\"\"\n    returns the indices of the segments that should be used to get the largest\n    difference between the largest and smallest values in the array.\n    \"\"\"\n    segments_to_use = []\n    for segment in segments:\n        l, r = segment\n        min_val, max_val = get_min_max(l - 1, r - 1)\n        max_diff = max_val - min_val\n        if max_diff > largest_diff:\n            largest_diff = max_diff\n            segments_to_use = [segment]\n        elif max_diff == largest_diff:\n            segments_to_use.append(segment)\n    return segments_to_use\n\ndef main():\n    global arr, largest_diff\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    arr = [int(x) for x in sys.stdin.readline().split()]\n    # initialize the largest difference to the difference between the max and min\n    # of the entire array.\n    largest_diff = max(arr) - min(arr)\n    segments = []\n    for i in range(m):\n        segments.append([int(x) for x in sys.stdin.readline().split()])\n    # sort the segments by the largest difference between the smallest and largest\n    # values in the segment\n    segments.sort(key=get_max_diff, reverse=True)\n    # get the indices of the segments to use\n    segments_to_use = get_segments_to_use(segments)\n    # print the largest difference\n    print(largest_diff)\n    # print the number of segments to use\n    print(len(segments_to_use))\n    # print the indices of the segments to use\n    for segment in segments_to_use:\n        print(segments.index(segment) + 1, end=\" \")\n\nif __name__ == \"__main__\":\n    main()\n", "\n#!/usr/bin/env python3\n\nimport sys\n\ndef read_ints():\n    return tuple(map(int, sys.stdin.readline().strip().split()))\n\ndef read_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\n# \n#\n#\n\ndef read_segments():\n    n, m = read_ints()\n    a = read_array()\n    segments = [(l-1, r-1) for l, r in [read_ints() for i in range(m)]]\n    return a, segments\n\n#\n#\n#\n\ndef max_diff(a, segments):\n    n = len(a)\n    \n    a_min = min(a)\n    a_max = max(a)\n    \n    if a_min == a_max:\n        return 0, ()\n    \n    s_min = [0] * n\n    s_max = [0] * n\n\n    for l, r in segments:\n        s_min[l] += 1\n        s_max[r] += 1\n\n    d_min = 0\n    d_max = 0\n    for i in range(n):\n        d_min += s_min[i]\n        d_max += s_max[i]\n        s_min[i] = d_min\n        s_max[i] = d_max\n\n    d_min = 0\n    d_max = 0\n    j = 0\n    \n    for i in range(n):\n        if a[i] == a_min:\n            d_min = s_min[i]\n        if a[i] == a_max:\n            d_max = s_max[i]\n            j = i\n            break\n\n    return d_max - d_min, s_max[:j]\n\na, segments = read_segments()\n\nd, s = max_diff(a, segments)\n\nprint(d)\nprint(len(s))\nprint(' '.join(map(str, s)))\n", "\n\nimport sys\n\ndef get_min_max(l, r):\n    \"\"\"\n    returns the smallest and largest value of the array between l and r, inclusive.\n    \"\"\"\n    min_val = min(arr[l:r])\n    max_val = max(arr[l:r])\n    return (min_val, max_val)\n\ndef get_max_diff(segment):\n    \"\"\"\n    returns the difference between the largest and smallest values within a segment.\n    \"\"\"\n    min_val, max_val = get_min_max(segment[0]-1, segment[1])\n    return max_val - min_val\n\ndef get_segments_to_use(segments):\n    \"\"\"\n    returns the indices of the segments that should be used to get the largest\n    difference between the largest and smallest values in the array.\n    \"\"\"\n    segments_to_use = []\n    for segment in segments:\n        l, r = segment\n        min_val, max_val = get_min_max(l-1, r)\n        max_diff = max_val - min_val\n        if max_diff > largest_diff:\n            largest_diff = max_diff\n            segments_to_use = [segment]\n        elif max_diff == largest_diff:\n            segments_to_use.append(segment)\n    return segments_to_use\n\ndef main():\n    global arr, largest_diff\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    arr = [int(x) for x in sys.stdin.readline().split()]\n    # initialize the largest difference to the difference between the max and min\n    # of the entire array.\n    largest_diff = max(arr) - min(arr)\n    segments = []\n    for i in range(m):\n        segments.append([int(x) for x in sys.stdin.readline().split()])\n    # sort the segments by the largest difference between the smallest and largest\n    # values in the segment\n    segments.sort(key=get_max_diff, reverse=True)\n    # get the indices of the segments to use\n    segments_to_use = get_segments_to_use(segments)\n    # print the largest difference\n    print(largest_diff)\n    # print the number of segments to use\n    print(len(segments_to_use))\n    # print the indices of the segments to use\n    for segment in segments_to_use:\n        print(segments.index(segment)+1, end=\" \")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport numpy as np\n\n# The key observation is that the optimal solution can be obtained by\n# choosing segments which have the most extreme endpoints.\n# Thus, we can compute the min/max values of all endpoints of segments,\n# then find the optimal solution by choosing the right segments.\n# If we manage to find the optimal solution, then it is unique.\n\nn, m = map(int, sys.stdin.readline().strip().split())\na = list(map(int, sys.stdin.readline().strip().split()))\n\nmin_vals = np.zeros(n)\nmax_vals = np.zeros(n)\nmin_vals[:] = np.inf\nmax_vals[:] = -np.inf\n\nfor i in range(m):\n    l, r = map(int, sys.stdin.readline().strip().split())\n    min_vals[l-1] = min(min_vals[l-1], a[l-1])\n    max_vals[r-1] = max(max_vals[r-1], a[r-1])\n\nfor i in range(1, n):\n    min_vals[i] = min(min_vals[i-1], min_vals[i])\n    max_vals[n-1-i] = max(max_vals[n-i], max_vals[n-1-i])\n\nd = 0\nselected_segments = []\nfor i in range(m):\n    l, r = map(int, sys.stdin.readline().strip().split())\n    d_opt = max(max_vals[r-1], a[r-1]) - min(min_vals[l-1], a[l-1])\n    if d_opt > d:\n        d = d_opt\n        selected_segments = [i+1]\n    elif d_opt == d:\n        selected_segments.append(i+1)\n\nprint(d)\nprint(len(selected_segments))\nprint(' '.join(map(str, selected_segments)))\n"]