["\n\n# from statistics import mode\nimport sys, math\n\n# def find_mode(list):\n#     try:\n#         return mode(list)\n#     except:\n#         return 1\n\ndef find_mode(list):\n    num_dict = {}\n    for num in list:\n        if num in num_dict:\n            num_dict[num] += 1\n        else:\n            num_dict[num] = 1\n    return max(num_dict, key=lambda key: num_dict[key]) if num_dict else 1\n\ndef find_median(list):\n    list.sort()\n    return list[int(math.floor(len(list) / 2))] if list else 1\n\n# def find_median(list):\n#     return sorted(list)[int(math.floor(len(list) / 2))]\n\ndef find_mean(list):\n    return int(sum(list) / len(list)) if list else 1\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    print(find_mode(a) + find_median(a) + find_mean(a))\n\nif __name__ == '__main__':\n    main()\n\n\n\"\"\"\n# DO NOT READ THIS.\n\n# I'm just writing down my thoughts during the problem-solving process\n\n# The problem is asking for the sum of the mode, median and mean of the input.\n# It's the same as finding the mode.\n# Then the median + mean of the mode\n\n# I think that the mode is the most frequent number in the list\n# Maybe use a hash table?\n# Maybe I can just sort it and find the most frequent number\n\n# I think that the median is the middle number in the list\n# I think that the mean is the average of the list\n\n# I think that I can just use the statistics module to find this\n# But that's cheating\n# I should try to solve it on my own\n\n# I think that I can just sort the list and find the number that repeats the most\n# But what if there are no repeated numbers?\n# I guess I can just return 1\n\n# I think that I can just sort the list and find the middle number\n# I can just use the floor of the length of the list divided by 2\n\n# I think that I can just find the sum of the list and divide it by the length of the list\n# I think that I should use floor division\n\"\"\"\n", "\ndef main():\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    print(n - A.count(A[0]))\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom functools import wraps\n\ndef memoize(f):\n    memo = {}\n    @wraps(f)\n    def helper(x):\n        if x not in memo:\n            memo[x] = f(x)\n        return memo[x]\n    return helper\n\n@memoize\ndef fibonacci(n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\nnum = int(raw_input())\narray = map(int, raw_input().split())\n\nfib_array = [fibonacci(i) for i in range(max(array)+1)]\n\ntotal = 0\nfor i in array:\n    total += fib_array[i-1]\nprint total % 1000000007\n", "\n\ndef main():\n    n = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    if A[0] == 1 or A[0] == 2:\n        print(n)\n    else:\n        print(n - 1)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    if a[0] == 1 or a[0] == 2 or a[0] == 3:\n        print(n)\n    else:\n        print(n - 1)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom functools import wraps\n\ndef memoize(f):\n    memo = {}\n    @wraps(f)\n    def helper(x):\n        if x not in memo:\n            memo[x] = f(x)\n        return memo[x]\n    return helper\n\n@memoize\ndef fibonacci(n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\nnum = int(input())\narray = map(int, input().split())\n\nfib_array = [fibonacci(i) for i in range(max(array))]\n\ntotal = 0\nfor i in array:\n    total += fib_array[i-1]\nprint total % 1000000007\n", "\n\nimport sys, math\n\ndef find_mode(list):\n    num_dict = {}\n    for num in list:\n        if num in num_dict:\n            num_dict[num] += 1\n        else:\n            num_dict[num] = 1\n    return max(num_dict, key=lambda key: num_dict[key])\n\ndef find_median(list):\n    list.sort()\n    return list[int(math.floor(len(list) / 2))]\n\ndef find_mean(list):\n    return int(sum(list) / len(list))\n\ndef main():\n    n = int(sys.stdin.readline())\n    num_list = list(map(int, sys.stdin.readline().split()))\n    print(find_mode(num_list) + find_median(num_list) + find_mean(num_list))\n\nif __name__ == '__main__':\n    main()\n\n\n\"\"\"\n# DO NOT READ THIS.\n\n# I'm just writing down my thoughts during the problem-solving process\n\n# The problem is asking for the sum of the mode, median and mean of the input.\n# It's the same as finding the mode.\n# Then the median + mean of the mode\n\n# I think that the mode is the most frequent number in the list\n# Maybe use a hash table?\n# Maybe I can just sort it and find the most frequent number\n\n# I think that the median is the middle number in the list\n# I think that the mean is the average of the list\n\n# I think that I can just use the statistics module to find this\n# But that's cheating\n# I should try to solve it on my own\n\n# I think that I can just sort the list and find the number that repeats the most\n# But what if there are no repeated numbers?\n# I guess I can just return 1\n\n# I think that I can just sort the list and find the middle number\n# I can just use the floor of the length of the list divided by 2\n\n# I think that I can just find the sum of the list and divide it by the length of the list\n# I think that I should use floor division\n\"\"\"\n", "\n\nfrom functools import wraps\n\ndef memoize(f):\n    memo = {}\n    @wraps(f)\n    def helper(x):\n        if x not in memo:\n            memo[x] = f(x)\n        return memo[x]\n    return helper\n\n@memoize\ndef fibonacci(n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\nnum = int(raw_input())\narray = map(int, raw_input().split())\n\nfib_array = [fibonacci(i) for i in range(max(array))]\n\ntotal = 0\nfor i in array:\n    total += fib_array[i-1]\nprint total % 1000000007\n"]