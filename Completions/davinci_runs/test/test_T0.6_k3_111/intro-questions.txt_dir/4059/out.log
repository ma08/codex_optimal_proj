"""
Given is a positive integer N.
How many tuples (A,B,C) of positive integers satisfy A \times B + C = N?

-----Constraints-----
 -  2 \leq N \leq 10^6
 - All values in input are integers.

-----Input-----
Input is given from Standard Input in the following format:
N

-----Output-----
Print the answer.

-----Sample Input-----
3

-----Sample Output-----
3

There are 3 tuples of integers that satisfy A \times B + C = 3: (A, B, C) = (1, 1, 2), (1, 2, 1), (2, 1, 1).
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nn = int(input())\n\nans = 0\nfor a in range(1, n+1):\n    for b in range(1, n+1):\n        c = n - a * b\n        if c <= 0:\n            break\n        ans += 1\n\nprint(ans)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\nimport math\n\ndef main():\n    N = int(input())\n    \n    # The number of tuples that satisfy A \\times B + C = N.\n    ans = 0\n    \n    # We enumerate all possible values of A and B.\n    # Note that A \\times B + C = N.\n    # Thus, in order to maximize the value of A \\times B,\n    # it is enough to consider A = B.\n    # This is because A \\times B + C = A \\times A + C = (A+C)(A-C)\n    for a in range(1, math.ceil(math.sqrt(N))+1):\n        # If a*a+1 == N, then a+1 is a factor of N.\n        # Thus, a+1 is a factor of (a*a+1-N),\n        # and the number of factors of N that are not a+1 is\n        # the number of factors of (a*a+1-N) that are not a+1.\n        if a*a + 1 == N:\n            ans += len(factors(N))-1\n        # If a*a == N, then a is a factor of N.\n        # Thus, a is a factor of (a*a-N),\n        # and the number of factors of N that are not a is\n        # the number of factors of (a*a-N) that are not a.\n        elif a*a == N:\n            ans += len(factors(N))-1\n        # Otherwise, a*a < N < (a+1)*(a+1).\n        # Thus, a*a < N < a*a+2*a+1.\n        # We can show that N-a*a is a factor of N.\n        # This is because a*a < N < a*a+2*a+1,\n        # so N-a*a = 2*a+1.\n        # It is also easy to show that a is a factor of N.\n        # Thus, the number of factors of N that are not a or N-a*a is\n        # the number of factors of (a*a-N) that are not a.\n        else:\n            ans += len(factors(a*a-N))-1\n    \n    print(ans)\n\n# Returns the list of all factors of n.\ndef factors(n):\n    factors = []\n    for i in range(1, math.ceil(math.sqrt(n))+1):\n        if n % i == 0:\n            factors.append(i)\n            factors.append(n//i)\n    return sorted(factors)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport math\n\nn = int(input())\n\nif n <= 2:\n    print(0)\n    exit()\n\n# n = 2*x + 2*y + 2*z + x*y + y*z + z*x\n# n = 2*(x+y+z) + x*y + y*z + z*x\n# n = 2*(x+y+z) + (x+y)(y+z)(z+x)\n# n = 2*(x+y+z) + (x+y+z)(xy+yz+zx)\n# We want to find (x+y+z) s.t. 2*(x+y+z) <= n and (x+y+z)(xy+yz+zx) <= n\n# For each possible value of (x+y+z) we can find (xy+yz+zx) and check\n# if that value is <= n.\n# This is similar to the \"sum of divisors\" problem.\n\n# We can make this faster by only looking at divisors of n.\n# x+y+z has to divide n and xy+yz+zx has to divide n.\n# If we look at all the divisors of n, we can check if there is a triple\n# that satisfies the condition in O(1) time.\n\n# For each divisor, we can find the number of ordered triples that add up to that divisor.\n# To do this, we can use the \"stars and bars\" method.\n# We have to find all the ways to split n stars into 3+1 bars.\n# For each divisor, we can get the number of ways to split n stars into 3+1 bars in O(1) time.\n\n# We can make this even faster by only looking at divisors of n that are less than sqrt(n).\n# For each divisor, we can find a partner divisor that satisfies the condition in O(1) time.\n\ndivisors = [1]\nfor i in range(2, int(math.sqrt(n))+1):\n    if n % i == 0:\n        divisors.append(i)\n        if i * i != n:\n            divisors.append(n // i)\n\n# n = n + (n-1) + (n-2) + ... + (n-(n-1))\n# n = n * (n+1) / 2\n# We can also find the number of ordered triples that add up to n in O(1) time.\n\nnum_triples = n * (n+1) // 2\n\nfor divisor in divisors:\n    # We can find the number of ways to split n stars into 3+1 bars in O(1) time.\n    num_triples -= n // divisor * (n // divisor + 1) // 2 * (n // divisor + 2) // 3\n    # We can find the number of ways to split n stars into 3+1 bars in O(1) time.\n    num_triples -= n // divisor * (n // divisor + 1) // 2 * (n // divisor + 2) // 3 * (n // divisor + 3) // 4\n\nprint(num_triples)"
    }
  ],
  "created": 1648693106,
  "id": "cmpl-4regENJlkg2sErmPFzAbN6hsYDqCG",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nn = int(input())\n\nans = 0\nfor a in range(1, n+1):\n    for b in range(1, n+1):\n        c = n - a * b\n        if c <= 0:\n            break\n        ans += 1\n\nprint(ans)"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\nimport math\n\ndef main():\n    N = int(input())\n    \n    # The number of tuples that satisfy A \\times B + C = N.\n    ans = 0\n    \n    # We enumerate all possible values of A and B.\n    # Note that A \\times B + C = N.\n    # Thus, in order to maximize the value of A \\times B,\n    # it is enough to consider A = B.\n    # This is because A \\times B + C = A \\times A + C = (A+C)(A-C)\n    for a in range(1, math.ceil(math.sqrt(N))+1):\n        # If a*a+1 == N, then a+1 is a factor of N.\n        # Thus, a+1 is a factor of (a*a+1-N),\n        # and the number of factors of N that are not a+1 is\n        # the number of factors of (a*a+1-N) that are not a+1.\n        if a*a + 1 == N:\n            ans += len(factors(N))-1\n        # If a*a == N, then a is a factor of N.\n        # Thus, a is a factor of (a*a-N),\n        # and the number of factors of N that are not a is\n        # the number of factors of (a*a-N) that are not a.\n        elif a*a == N:\n            ans += len(factors(N))-1\n        # Otherwise, a*a < N < (a+1)*(a+1).\n        # Thus, a*a < N < a*a+2*a+1.\n        # We can show that N-a*a is a factor of N.\n        # This is because a*a < N < a*a+2*a+1,\n        # so N-a*a = 2*a+1.\n        # It is also easy to show that a is a factor of N.\n        # Thus, the number of factors of N that are not a or N-a*a is\n        # the number of factors of (a*a-N) that are not a.\n        else:\n            ans += len(factors(a*a-N))-1\n    \n    print(ans)\n\n# Returns the list of all factors of n.\ndef factors(n):\n    factors = []\n    for i in range(1, math.ceil(math.sqrt(n))+1):\n        if n % i == 0:\n            factors.append(i)\n            factors.append(n//i)\n    return sorted(factors)\n\nif __name__ == '__main__':\n    main()"
}
REASON stop
2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport math\n\nn = int(input())\n\nif n <= 2:\n    print(0)\n    exit()\n\n# n = 2*x + 2*y + 2*z + x*y + y*z + z*x\n# n = 2*(x+y+z) + x*y + y*z + z*x\n# n = 2*(x+y+z) + (x+y)(y+z)(z+x)\n# n = 2*(x+y+z) + (x+y+z)(xy+yz+zx)\n# We want to find (x+y+z) s.t. 2*(x+y+z) <= n and (x+y+z)(xy+yz+zx) <= n\n# For each possible value of (x+y+z) we can find (xy+yz+zx) and check\n# if that value is <= n.\n# This is similar to the \"sum of divisors\" problem.\n\n# We can make this faster by only looking at divisors of n.\n# x+y+z has to divide n and xy+yz+zx has to divide n.\n# If we look at all the divisors of n, we can check if there is a triple\n# that satisfies the condition in O(1) time.\n\n# For each divisor, we can find the number of ordered triples that add up to that divisor.\n# To do this, we can use the \"stars and bars\" method.\n# We have to find all the ways to split n stars into 3+1 bars.\n# For each divisor, we can get the number of ways to split n stars into 3+1 bars in O(1) time.\n\n# We can make this even faster by only looking at divisors of n that are less than sqrt(n).\n# For each divisor, we can find a partner divisor that satisfies the condition in O(1) time.\n\ndivisors = [1]\nfor i in range(2, int(math.sqrt(n))+1):\n    if n % i == 0:\n        divisors.append(i)\n        if i * i != n:\n            divisors.append(n // i)\n\n# n = n + (n-1) + (n-2) + ... + (n-(n-1))\n# n = n * (n+1) / 2\n# We can also find the number of ordered triples that add up to n in O(1) time.\n\nnum_triples = n * (n+1) // 2\n\nfor divisor in divisors:\n    # We can find the number of ways to split n stars into 3+1 bars in O(1) time.\n    num_triples -= n // divisor * (n // divisor + 1) // 2 * (n // divisor + 2) // 3\n    # We can find the number of ways to split n stars into 3+1 bars in O(1) time.\n    num_triples -= n // divisor * (n // divisor + 1) // 2 * (n // divisor + 2) // 3 * (n // divisor + 3) // 4\n\nprint(num_triples)"
}
REASON stop
