["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\n\ndef main():\n    if len(sys.argv) < 2:\n        print(\"Usage: %s file\" % sys.argv[0])\n        sys.exit(1)\n\n    fname = sys.argv[1]\n    if not os.path.exists(fname):\n        print(\"File %s does not exist\" % fname)\n        sys.exit(1)\n\n    f = open(fname, 'r')\n    lines = f.readlines()\n    f.close()\n\n    f = open(fname, 'w')\n    for line in lines:\n        line = line.replace('\\r', '')\n        f.write(line)\n    f.close()\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n\tn, d, k = [int(x) for x in input().split()]\n\tif d == 1:\n\t\tprint(\"YES\")\n\t\tfor i in range(1, n):\n\t\t\tprint(i, i + 1)\n\telif d == 2:\n\t\tif k < 2:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(2, 3)\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tfor i in range(2, n + 1):\n\t\t\t\tprint(1, i)\n\telif d == 3:\n\t\tif k < 2:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(2, 3)\n\t\t\tprint(2, 5)\n\t\t\tfor i in range(2, n + 1):\n\t\t\t\tprint(1, i)\n\telif d == 4:\n\t\tif k < 2:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(2, 3)\n\t\t\tprint(2, 5)\n\t\t\tprint(2, 6)\n\t\t\tfor i in range(2, n + 1):\n\t\t\t\tprint(1, i)\n\telif d == 5:\n\t\tif k < 3:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(1, 2)\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tfor i in range(2, n + 1):\n\t\t\t\tprint(1, i)\n\nif __name__ == '__main__':\n\tmain()\n", "import sys, heapq, math\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.parent = self\n        self.children = []\n\ndef find(x):\n    if x.parent != x:\n        x.parent = find(x.parent)\n    return x.parent\n\ndef union(x, y):\n    xRoot = find(x)\n    yRoot = find(y)\n    if xRoot != yRoot:\n        if len(xRoot.children) > len(yRoot.children):\n            xRoot.children.append(yRoot)\n            yRoot.parent = xRoot\n        else:\n            yRoot.children.append(xRoot)\n            xRoot.parent = yRoot\n    return xRoot\n\ndef dfs(root, edges, k):\n    if len(root.children) == 0:\n        return\n    root_num = root.value\n    if len(root.children) < k:\n        if len(edges) < k - len(root.children):\n            print(\"NO\")\n            sys.exit()\n        for i in range(k - len(root.children)):\n            if edges[i][0] == root.value or edges[i][1] == root.value:\n                print(\"NO\")\n                sys.exit()\n            root.children.append(union(nodes[edges[i][0]], nodes[edges[i][1]]))\n        edges = edges[i + 1:]\n    for child in root.children:\n        dfs(child, edges, k)\n\nn, d, k = list(map(int, input().split()))\nnodes = [Node(i) for i in range(1, n + 1)]\nedges = defaultdict(list)\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        weight = math.sqrt((i - j) ** 2)\n        edges[weight].append((i, j))\n\nif d > math.sqrt(n) or k >= n:\n    print(\"NO\")\n    sys.exit()\n\n# make a spanning tree\nedges = sorted(edges.items())\nfor i in range(n - 1):\n    if edges[i][1][0] == 1 or edges[i][1][1] == 1:\n        print(\"NO\")\n        sys.exit()\n    union(nodes[edges[i][1][0]], nodes[edges[i][1][1]])\nedges = edges[n - 1:]\n\n# dfs to find k-ary tree\ndfs(nodes[1], edges, k)\n\n# print the edges\nprint(\"YES\")\nfor i in range(2, n + 1):\n    print(find(nodes[i]).value, i)\n", "import sys, heapq, math\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.parent = self\n        self.children = []\n\ndef find(x):\n    if x.parent != x:\n        x.parent = find(x.parent)\n    return x.parent\n\ndef union(x, y):\n    xRoot = find(x)\n    yRoot = find(y)\n    if xRoot != yRoot:\n        if len(xRoot.children) > len(yRoot.children):\n            xRoot.children.append(yRoot)\n            yRoot.parent = xRoot\n        else:\n            yRoot.children.append(xRoot)\n            xRoot.parent = yRoot\n    return xRoot\n\ndef dfs(root, edges, k):\n    if len(root.children) == 0:\n        return\n    if len(edges) == 0:\n        print(\"NO\")\n        sys.exit()\n    root_num = root.value\n    if len(root.children) < k:\n        edges = sorted(edges)\n        for i in range(k - len(root.children)):\n            if edges[i][0] == root.value or edges[i][1] == root.value:\n                print(\"NO\")\n                sys.exit()\n            root.children.append(union(nodes[edges[i][0]], nodes[edges[i][1]]))\n        edges = edges[k - len(root.children):]\n    for child in root.children:\n        dfs(child, edges, k)\n\nn, d, k = list(map(int, input().split()))\nnodes = [Node(i) for i in range(1, n + 1)]\nedges = defaultdict(list)\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        weight = math.sqrt((i - j) ** 2 + d ** 2)\n        edges[weight].append((i, j))\n\nif d > math.sqrt(n) or k >= n - 1:\n    print(\"NO\")\n    sys.exit()\n\n# make a spanning tree\nedges = sorted(edges)\nfor i in range(n - 2):\n    if edges[i][0] == 1 or edges[i][1] == 1:\n        print(\"NO\")\n        sys.exit()\n    union(nodes[edges[i][0]], nodes[edges[i][1]])\nedges = edges[n - 2:]\n\n# dfs\ndfs(nodes[1], edges, k)\n\n# print the edges\nprint(\"YES\")\nfor i in range(2, n + 1):\n    print(find(nodes[i]).value, i)\n", "var fs = require('fs');\n\nfs.readFile('file.txt', 'utf8', function(err, data) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log(data);\n    }\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "import sys, heapq, math\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.parent = self\n        self.children = []\n\ndef find(x):\n    if x.parent != x:\n        x.parent = find(x.parent)\n    return x.parent\n\ndef union(x, y):\n    xRoot = find(x)\n    yRoot = find(y)\n    if xRoot != yRoot:\n        if len(xRoot.children) > len(yRoot.children):\n            xRoot.children.append(yRoot)\n            yRoot.parent = xRoot\n        else:\n            yRoot.children.append(xRoot)\n            xRoot.parent = yRoot\n    return xRoot\n\ndef dfs(root, edges, k):\n    if len(root.children) == 0:\n        return\n    root_num = root.value\n    if len(root.children) < k:\n        if len(edges) < k - len(root.children):\n            print(\"NO\")\n            sys.exit()\n        edges = sorted(edges)\n        for i in range(k - len(root.children)):\n            if edges[i][0] == root.value or edges[i][1] == root.value:\n                print(\"NO\")\n                sys.exit()\n            root.children.append(union(nodes[edges[i][0]], nodes[edges[i][1]]))\n        edges = edges[k - len(root.children) + 1:]\n    for child in root.children:\n        dfs(child, edges, k)\n\nn, d, k = list(map(int, input().split()))\nnodes = [Node(i) for i in range(1, n + 1)]\nedges = defaultdict(list)\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        weight = math.sqrt((i - j) ** 2)\n        edges[weight].append((i, j))\n\nif d > math.sqrt(n) or k >= n:\n    print(\"NO\")\n    sys.exit()\n\n# make a spanning tree\nedges = sorted(edges)\nfor i in range(n - 1):\n    if edges[i][0] == 1 or edges[i][1] == 1:\n        print(\"NO\")\n        sys.exit()\n    union(nodes[edges[i][0]], nodes[edges[i][1]])\nedges = edges[n - 1 + 1:]\n\n# dfs\ndfs(nodes[1], edges, k)\n\n# print the edges\nprint(\"YES\")\nfor i in range(2, n + 1):\n    print(find(nodes[i]).value, i)\n", "\nimport sys, heapq, math\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.parent = self\n        self.children = []\n\ndef find(x):\n    if x.parent != x:\n        x.parent = find(x.parent)\n    return x.parent\n\ndef union(x, y):\n    xRoot = find(x)\n    yRoot = find(y)\n    if xRoot != yRoot:\n        if len(xRoot.children) > len(yRoot.children):\n            xRoot.children.append(yRoot)\n            yRoot.parent = xRoot\n        else:\n            yRoot.children.append(xRoot)\n            xRoot.parent = yRoot\n    return xRoot\n\ndef dfs(root, edges, k):\n    if len(root.children) == 0:\n        return\n    if len(edges) == 0:\n        print(\"NO\")\n        sys.exit()\n    root_num = root.value\n    if len(root.children) < k:\n        edges = sorted(edges)\n        for i in range(k - len(root.children)): # add k - len(root.children) edges\n            if edges[i][0] == root.value or edges[i][1] == root.value:\n                print(\"NO\")\n                sys.exit()\n            root.children.append(union(nodes[edges[i][0]], nodes[edges[i][1]])) # union the two nodes\n        edges = edges[k - len(root.children):]\n    for child in root.children: # dfs\n        dfs(child, edges, k)\n\nn, d, k = list(map(int, input().split()))\nnodes = [Node(i) for i in range(1, n + 1)]\nedges = defaultdict(list)\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        weight = math.sqrt((i - j) ** 2)\n        edges[weight].append((i, j))\n\nif d > math.sqrt(n) or k >= n:\n    print(\"NO\")\n    sys.exit()\n\n# make a spanning tree\nedges = sorted(edges)\nfor i in range(n - 1):\n    if edges[i][0] == 1 or edges[i][1] == 1:\n        print(\"NO\")\n        sys.exit()\n    union(nodes[edges[i][0]], nodes[edges[i][1]])\nedges = edges[n - 1:]\n\n# dfs to find k-ary tree\ndfs(nodes[1], edges, k)\n\n# print the edges\nprint(\"YES\")\nfor i in range(2, n + 1):\n    print(find(nodes[i]).value, i)\n", "\n\ndef main():\n\tn, d, k = [int(x) for x in input().split()]\n\tif d == 1:\n\t\tprint(\"YES\")\n\t\tfor i in range(1, n):\n\t\t\tprint(i, i + 1)\n\telif d == 2:\n\t\tif k < 3:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(2, 3)\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(1, 2)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\telif d == 3:\n\t\tif k < 3:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(2, 3)\n\t\t\tprint(2, 5)\n\t\t\tprint(1, 2)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\telif d == 4:\n\t\tif k < 3:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(2, 3)\n\t\t\tprint(2, 5)\n\t\t\tprint(2, 6)\n\t\t\tprint(1, 2)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\telif d == 5:\n\t\tif k < 3:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(1, 2)\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\nif __name__ == '__main__':\n\tmain()\n"]