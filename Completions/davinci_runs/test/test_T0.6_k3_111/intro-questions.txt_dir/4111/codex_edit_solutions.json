["\n\ndef solve(n, a, b):\n    odd_sum, even_sum = 0, 0\n    for i, v in enumerate(b):\n        if i % 2 == 0:\n            even_sum += v\n        else:\n            odd_sum += v\n    soln = 0\n    for i, v in enumerate(b):\n        if i % 2 == 0:\n            even_sum -= v\n        else:\n            odd_sum -= v\n        if odd_sum == even_sum:\n            soln += 1\n    return soln\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    assert len(a) == n\n    print(solve(n, a, b))\n", "\n\ndef solve(n, a):\n    # preprocess and build a segment tree\n    seg_tree = [0] * (4 * n)\n    for i in range(n):\n        update(i, a[i], seg_tree, 0, n - 1, 1)\n\n    # check if the sum of odd and even days are equal or not\n    ans = 0\n    for i in range(n):\n        if i == 0:\n            if query(0, n - 2, 0, n - 1, 1, seg_tree, 0) == query(1, n - 1, 0, n - 1, 1, seg_tree, 0):\n                ans += 1\n        elif i == n - 1:\n            if query(0, n - 3, 0, n - 1, 1, seg_tree, 0) == query(1, n - 2, 0, n - 1, 1, seg_tree, 0):\n                ans += 1\n        else:\n            if query(0, i - 1, 0, n - 1, 1, seg_tree, 0) == query(i + 1, n - 1, 0, n - 1, 1, seg_tree, 0):\n                ans += 1\n\n    return ans\n\n\ndef update(i, new_val, seg_tree, start, end, node):\n    # base case\n    if start == end:\n        seg_tree[node] = new_val\n        return\n    # recurse\n    mid = (start + end) // 2\n    if start <= i <= mid:     # if in left half\n        update(i, new_val, seg_tree, start, mid, node * 2)\n    else:                     # if in right half\n        update(i, new_val, seg_tree, mid + 1, end, node * 2 + 1)\n\n    # update the current sum\n    seg_tree[node] = seg_tree[node * 2] + seg_tree[node * 2 + 1]\n\n\ndef query(i, j, start, end, node, seg_tree, sum=0):\n    # base case\n    if start > j or end < i:\n        return 0\n    if start >= i and end <= j:\n        return seg_tree[node]\n    # recurse\n    mid = (start + end) // 2\n    p1 = query(i, j, start, mid, node * 2, seg_tree)\n    p2 = query(i, j, mid + 1, end, node * 2 + 1, seg_tree)\n    return p1 + p2\n\n\nif __name__ == '__main__':\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))\n", "\n\ndef solve(n, a):\n    # pre-process and build segment tree\n    seg_tree = [0] * (n * 4)\n    for i in range(n):\n        update(i, a[i], seg_tree, 0, n-1, 1)\n\n    # check if the sum of odd and even days are equal\n    ans = 0\n    for i in range(n):\n        if i == 0:\n            if query(0, n-2, 0, n-1, 1, seg_tree) == query(1, n-1, 0, n-1, 1, seg_tree):\n                ans += 1\n        elif i == n - 1:\n            if query(0, n-3, 0, n-1, 1, seg_tree) == query(1, n-2, 0, n-1, 1, seg_tree):\n                ans += 1\n        else:\n            if query(0, i - 1, 0, n-1, 1, seg_tree) == query(i + 1, n-1, 0, n-1, 1, seg_tree):\n                ans += 1\n\n    return ans\n\n\ndef update(i, new_val, seg_tree, start, end, node):\n    # base case\n    if start == end:\n        seg_tree[node] = new_val\n        return\n    # recurse\n    mid = (start + end) // 2\n    if start <= i <= mid:     # if in left half\n        update(i, new_val, seg_tree, start, mid, node * 2)\n    else:                     # if in right half\n        update(i, new_val, seg_tree, mid + 1, end, node * 2 + 1)\n\n    # update the current sum\n    seg_tree[node] = seg_tree[node * 2] + seg_tree[node * 2 + 1]\n\n\ndef query(i, j, start, end, node, seg_tree, sum=0):\n    # base case\n    if start > j or end < i:\n        return 0\n    if start >= i and end <= j:\n        return seg_tree[node]\n    # recurse\n    mid = (start + end) // 2\n    p1 = query(i, j, start, mid, node * 2, seg_tree)\n    p2 = query(i, j, mid + 1, end, node * 2 + 1, seg_tree)\n    return p1 + p2\n\n\nif __name__ == '__main__':\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))\n", "\n\ndef solve(n, candies):\n    # find the even and odd sums of the candies.\n    even_sum = 0\n    odd_sum = 0\n    for i in range(n):\n        if i % 2 == 0:\n            even_sum += candies[i]\n        else:\n            odd_sum += candies[i]\n    # count the number of good candies.\n    c = 0\n    if even_sum == odd_sum:\n        c = 1\n    # check the remaining candies\n    for i in range(1, n-1):\n        # if even sum is greater\n        if even_sum > odd_sum:\n            even_sum -= candies[i-1]\n            odd_sum += candies[i-1]\n            if even_sum == odd_sum:\n                c += 1\n        # if odd sum is greater\n        else:\n            odd_sum -= candies[i-1]\n            even_sum += candies[i-1]\n            if even_sum == odd_sum:\n                c += 1\n    return c\n\nif __name__ == '__main__':\n    n = int(input())\n    candy = list(map(int, input().split()))\n    print(solve(n, candy))\n", "\n\ndef solve(n, a):\n    # pre-process and build segment tree.\n    seg_tree = [0] * (n * 4)\n    for i in range(n):\n        update(i, a[i], seg_tree, 0, n-1, 1)\n\n    # check if the sum of odd and even days are equal.\n    ans = 0\n    for i in range(n):\n        if i == 0:\n            if query(0, n-2, 0, n-1, 1, seg_tree, 0) == query(1, n-1, 0, n-1, 1, seg_tree, 0):\n                ans += 1\n        elif i == n - 1:\n            if query(0, n-3, 0, n-1, 1, seg_tree, 0) == query(1, n-2, 0, n-1, 1, seg_tree, 0):\n                ans += 1\n        else:\n            if query(0, i - 1, 0, n-1, 1, seg_tree, 0) == query(i + 1, n-1, 0, n-1, 1, seg_tree, 0):\n                ans += 1\n\n    return ans\n\n\ndef update(i, new_val, seg_tree, start, end, node):\n    # base case.\n    if start == end:\n        seg_tree[node] = new_val\n        return\n    # recurse.\n    mid = (start + end) // 2\n    if start <= i <= mid:     # if in left half.\n        update(i, new_val, seg_tree, start, mid, node * 2)\n    else:                     # if in right half.\n        update(i, new_val, seg_tree, mid + 1, end, node * 2 + 1)\n\n    # update the current sum.\n    seg_tree[node] = seg_tree[node * 2] + seg_tree[node * 2 + 1]\n\n\ndef query(i, j, start, end, node, seg_tree, sum=0):\n    # base case\n    if start > j or end < i:\n        return 0\n    if start >= i and end <= j:\n        return seg_tree[node]\n    # recurse\n    mid = (start + end) // 2\n    p1 = query(i, j, start, mid, node * 2, seg_tree)\n    p2 = query(i, j, mid + 1, end, node * 2 + 1, seg_tree)\n    return p1 + p2\n\n\nif __name__ == '__main__':\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))\n", "\n\ndef solve(n, a):\n    # preprocess and build a segment tree\n    seg_tree = [0] * (n * 4)\n    for i in range(n): \n        update(i, a[i], seg_tree, 0, n-1, 1)\n\n    # check if the sum of odd and even days are equal or not\n    ans = 0\n    for i in range(n):\n        if i == 0:\n            if query(0, n-2, 0, n-1, 1, seg_tree, 0) == query(1, n-1, 0, n-1, 1, seg_tree, 0):\n                ans += 1\n        elif i == n - 1:\n            if query(0, n-3, 0, n-1, 1, seg_tree, 0) == query(1, n-2, 0, n-1, 1, seg_tree, 0):\n                ans += 1\n        else:\n            if query(0, i - 1, 0, n-1, 1, seg_tree, 0) == query(i + 1, n-1, 0, n-1, 1, seg_tree, 0):\n                ans += 1\n\n    return ans\n\n\ndef update(i, new_val, seg_tree, start, end, node):\n    # base case\n    if start == end:\n        seg_tree[node] = new_val\n        return\n    # recurse\n    mid = (start + end) // 2\n    if start <= i <= mid:     # if in left half\n        update(i, new_val, seg_tree, start, mid, node * 2)\n    else:                     # if in right half\n        update(i, new_val, seg_tree, mid + 1, end, node * 2 + 1)\n\n    # update the current sum\n    seg_tree[node] = seg_tree[node * 2] + seg_tree[node * 2 + 1]\n\n\ndef query(i, j, start, end, node, seg_tree, sum=0):\n    # base case\n    if start > j or end < i:\n        return 0\n    if start >= i and end <= j:\n        return seg_tree[node]\n    # recurse\n    mid = (start + end) // 2\n    p1 = query(i, j, start, mid, node * 2, seg_tree)\n    p2 = query(i, j, mid + 1, end, node * 2 + 1, seg_tree)\n    return p1 + p2\n\n\nif __name__ == '__main__':\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))\n", "\ndef solve(n, a):\n    odd_sum, even_sum = 0, 0\n    for i, v in enumerate(a):\n        if i % 2 == 0:\n            even_sum += v\n        else:\n            odd_sum += v\n    soln = 0\n    for i, v in enumerate(a):\n        if i % 2 == 0:\n            even_sum -= v\n        else:\n            odd_sum -= v\n        if odd_sum == even_sum:\n            soln += 1\n    return soln\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    print(solve(n, a))\n", "\n\ndef solve(n, candies):\n    # find the even and odd sums of the candies.\n    even_sum = 0\n    odd_sum = 0\n    for i in range(n):\n        if i % 2 == 0:\n            even_sum += candies[i]\n        else:\n            odd_sum += candies[i]\n    # count the number of good candies.\n    c = 0\n    if even_sum == odd_sum:\n        c = 1\n    # check the remaining candies.\n    for i in range(1, n):\n        # if even sum is greater.\n        if even_sum > odd_sum:\n            even_sum -= candies[i-1]\n            odd_sum += candies[i-1]\n            if even_sum == odd_sum:\n                c += 1\n        # if odd sum is greater.\n        else:\n            odd_sum -= candies[i-1]\n            even_sum += candies[i-1]\n            if even_sum == odd_sum:\n                c += 1\n    return c\n\nif __name__ == '__main__':\n    n = int(input())\n    candies = list(map(int, input().split()))\n    print(solve(n, candies))\n"]