2022-04-10 12:33:15.547045 num operations 2
2022-04-10 12:33:15.547075 size on input set 1
2022-04-10 12:33:26.201925 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef check_rows_for_symmetry(rows, m):\n    # check if rows are symmetric (m x m)\n    for i, row in enumerate(rows):\n        for j, value in enumerate(row):\n            if rows[j][i] != value or i >= m or j >= m:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid, m):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid, m):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid, m):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid, m):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\ndef check_rows_for_symmetry(tile_grid):\n    # check if rows are symmetric\n    for i, row in enumerate(tile_grid):\n        for j, value in enumerate(row):\n            if tile_grid[j][i] != value:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
    }
  ],
  "created": 1649608395,
  "object": "edit"
}
2022-04-10 12:33:26.202203 fix spelling mistakes 2 ['\n\ndef check_rows_for_symmetry(rows, m):\n    # check if rows are symmetric (m x m)\n    for i, row in enumerate(rows):\n        for j, value in enumerate(row):\n            if rows[j][i] != value or i >= m or j >= m:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid, m):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid, m):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid, m):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid, m):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print("YES")\n    else:\n        print("NO")\n', '\n\ndef check_rows_for_symmetry(tile_grid):\n    # check if rows are symmetric\n    for i, row in enumerate(tile_grid):\n        for j, value in enumerate(row):\n            if tile_grid[j][i] != value:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print("YES")\n    else:\n        print("NO")\n']
2022-04-10 12:33:26.202256 size on output set 2
2022-04-10 12:33:26.202263 size on input set 2
2022-04-10 12:33:38.422017 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef check_rows_for_symmetry(tile_grid):\n    # check if rows are symmetric\n    for i, row in enumerate(tile_grid): # for each row\n        for j, value in enumerate(row): # for each value in the row\n            if tile_grid[j][i] != value:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid from tiles\n    tile_grid = []\n    for i in range(m): # for each row\n        row = []\n        for j in range(m): # for each column\n            row.append(tiles[i%2][j%2]) # get the tile\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list: # for each tile\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n): # for each tile\n        tile = []\n        for j in range(2): # for each row\n            tile.append(list(map(int, input().split()))) # get the row\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\ndef check_rows_for_symmetry(tile_grid):\n    # check if rows are symmetric\n    for i, row in enumerate(tile_grid):\n        for j, value in enumerate(row):\n            if tile_grid[j][i] != value:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations of tiles\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
    }
  ],
  "created": 1649608406,
  "object": "edit"
}
2022-04-10 12:33:38.422385 fix syntax errors 2 ['\n\ndef check_rows_for_symmetry(tile_grid):\n    # check if rows are symmetric\n    for i, row in enumerate(tile_grid): # for each row\n        for j, value in enumerate(row): # for each value in the row\n            if tile_grid[j][i] != value:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid from tiles\n    tile_grid = []\n    for i in range(m): # for each row\n        row = []\n        for j in range(m): # for each column\n            row.append(tiles[i%2][j%2]) # get the tile\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list: # for each tile\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n): # for each tile\n        tile = []\n        for j in range(2): # for each row\n            tile.append(list(map(int, input().split()))) # get the row\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print("YES")\n    else:\n        print("NO")\n', '\n\ndef check_rows_for_symmetry(tile_grid):\n    # check if rows are symmetric\n    for i, row in enumerate(tile_grid):\n        for j, value in enumerate(row):\n            if tile_grid[j][i] != value:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations of tiles\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print("YES")\n    else:\n        print("NO")\n']
2022-04-10 12:33:48.209958 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef check_rows_for_symmetry(rows):\n    # check if rows are symmetric (m x m)\n    for i, row in enumerate(rows):\n        for j, value in enumerate(row):\n            if rows[j][i] != value:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\ndef check_rows_for_symmetry(rows, m):\n    # check if rows are symmetric (m x m)\n    for i, row in enumerate(rows):\n        for j, value in enumerate(rows):\n            if rows[j][i] != value or i >= m or j >= m:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid, m):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid, m):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid, m):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid, m):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
    }
  ],
  "created": 1649608418,
  "object": "edit"
}
2022-04-10 12:33:48.210375 fix syntax errors 2 ['\n\ndef check_rows_for_symmetry(rows):\n    # check if rows are symmetric (m x m)\n    for i, row in enumerate(rows):\n        for j, value in enumerate(row):\n            if rows[j][i] != value:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print("YES")\n    else:\n        print("NO")\n', '\n\ndef check_rows_for_symmetry(rows, m):\n    # check if rows are symmetric (m x m)\n    for i, row in enumerate(rows):\n        for j, value in enumerate(rows):\n            if rows[j][i] != value or i >= m or j >= m:\n                return False\n    return True\n\ndef check_for_symmetry(tile_grid, m):\n    # check the rows for symmetry\n    if check_rows_for_symmetry(tile_grid, m):\n        # check the columns for symmetry\n        col_grid = [[row[i] for row in tile_grid] for i in range(len(tile_grid))]\n        if check_rows_for_symmetry(col_grid, m):\n            return True\n    return False\n\ndef get_tile_grid(tiles, m):\n    # make grid\n    tile_grid = []\n    for i in range(m):\n        row = []\n        for j in range(m):\n            row.append(tiles[i%2][j%2])\n        tile_grid.append(row)\n    return tile_grid\n\ndef solve(n, m, tiles_list):\n    # check all combinations\n    for tiles in tiles_list:\n        tile_grid = get_tile_grid(tiles, m)\n        if check_for_symmetry(tile_grid, m):\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    tiles_list = []\n    for i in range(n):\n        tile = []\n        for j in range(2):\n            tile.append(list(map(int, input().split())))\n        tiles_list.append(tile)\n    if solve(n, m, tiles_list):\n        print("YES")\n    else:\n        print("NO")\n']
2022-04-10 12:33:48.210409 size on output set 4
2022-04-10 12:33:48.210432 num operations 2
2022-04-10 12:33:48.210437 size on input set 1
2022-04-10 12:33:55.681842 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    l = []\n    for j in range(n):\n        a = input().split()\n        b = input().split()\n        l.append(a + b)\n    l.sort()\n    x = 0\n    flag = False\n    while x < n:\n        if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n            flag = True\n            break\n        x += 1\n    if flag:\n        print(\"YES\") \n    else:\n        print(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    l = []  # list to store input\n    for j in range(n):\n        a = input().split()  # taking input as list\n        b = input().split()\n        l.append(a + b)\n    l.sort()  # sorting the list\n    x = 0\n    flag = False\n    while x < n:\n        if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n            flag = True\n            break\n        x += 1\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
    }
  ],
  "created": 1649608428,
  "object": "edit"
}
2022-04-10 12:33:55.682046 fix spelling mistakes 2 ['\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    l = []\n    for j in range(n):\n        a = input().split()\n        b = input().split()\n        l.append(a + b)\n    l.sort()\n    x = 0\n    flag = False\n    while x < n:\n        if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n            flag = True\n            break\n        x += 1\n    if flag:\n        print("YES") \n    else:\n        print("NO")\n', '\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    l = []  # list to store input\n    for j in range(n):\n        a = input().split()  # taking input as list\n        b = input().split()\n        l.append(a + b)\n    l.sort()  # sorting the list\n    x = 0\n    flag = False\n    while x < n:\n        if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n            flag = True\n            break\n        x += 1\n    if flag:\n        print("YES")\n    else:\n        print("NO")\n']
2022-04-10 12:33:55.682078 size on output set 2
2022-04-10 12:33:55.682171 size on input set 2
2022-04-10 12:34:10.277994 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    l = []  # list to store input\n    for j in range(n):\n        a = input().split()  # taking input as list\n        b = input().split()\n        l.append(a + b)\n    l.sort()  # sorting the list\n    x = 0\n    flag = False\n    while x < n:\n        if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n            flag = True\n            break\n        x += 1\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\n#\n# t = int(input())\n# for i in range(t):\n#     n, m = map(int, input().split())\n#     l = []  # list to store input\n#     for j in range(n):\n#         a = input().split()  # taking input as list\n#         b = input().split()\n#         l.append(a + b)\n#     l.sort()  # sorting the list\n#     x = 0\n#     flag = False\n#     while x < n:\n#         if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n#             flag = True\n#             break\n#         x += 1\n#     if flag:\n#         print(\"YES\")\n#     else:\n#         print(\"NO\")\n"
    }
  ],
  "created": 1649608435,
  "object": "edit"
}
2022-04-10 12:34:10.278238 fix syntax errors 2 ['#\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    l = []  # list to store input\n    for j in range(n):\n        a = input().split()  # taking input as list\n        b = input().split()\n        l.append(a + b)\n    l.sort()  # sorting the list\n    x = 0\n    flag = False\n    while x < n:\n        if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n            flag = True\n            break\n        x += 1\n    if flag:\n        print("YES")\n    else:\n        print("NO")\n', '\n#\n# t = int(input())\n# for i in range(t):\n#     n, m = map(int, input().split())\n#     l = []  # list to store input\n#     for j in range(n):\n#         a = input().split()  # taking input as list\n#         b = input().split()\n#         l.append(a + b)\n#     l.sort()  # sorting the list\n#     x = 0\n#     flag = False\n#     while x < n:\n#         if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n#             flag = True\n#             break\n#         x += 1\n#     if flag:\n#         print("YES")\n#     else:\n#         print("NO")\n']
2022-04-10 12:34:22.769946 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# cook your dish here\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    l = set()\n    for j in range(n):\n        a = input().split()\n        b = input().split()\n        l.add(tuple(a+b))\n    if len(l) == n:\n        print(\"NO\")\n    else:\n        print(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    t = int(input())\n    for i in range(t):\n        n, m = map(int, input().split())\n        l = []\n        for j in range(n):\n            a = input().split()\n            b = input().split()\n            l.append(a + b)\n        l.sort()\n        x = 0\n        flag = False\n        while x < n:\n            if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n                flag = True\n                break\n            x += 1\n        if flag:\n            print(\"YES\") \n        else:\n            print(\"NO\")\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649608450,
  "object": "edit"
}
2022-04-10 12:34:22.770319 fix syntax errors 2 ['# cook your dish here\n\nt = int(input())\nfor i in range(t):\n    n, m = map(int, input().split())\n    l = set()\n    for j in range(n):\n        a = input().split()\n        b = input().split()\n        l.add(tuple(a+b))\n    if len(l) == n:\n        print("NO")\n    else:\n        print("NO")\n', '\ndef main():\n    t = int(input())\n    for i in range(t):\n        n, m = map(int, input().split())\n        l = []\n        for j in range(n):\n            a = input().split()\n            b = input().split()\n            l.append(a + b)\n        l.sort()\n        x = 0\n        flag = False\n        while x < n:\n            if l[x][0] == l[x][2] and l[x][1] == l[x][3]:\n                flag = True\n                break\n            x += 1\n        if flag:\n            print("YES") \n        else:\n            print("NO")\nif __name__ == \'__main__\':\n    main()\n']
2022-04-10 12:34:22.770354 size on output set 4
2022-04-10 12:34:22.770369 num operations 2
2022-04-10 12:34:22.770375 size on input set 1
2022-04-10 12:34:30.461992 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a,b)].append((c,d))\n        tiles[(c,d)].append((a,b))\n    return tiles\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles = build_tiles()\n    m = build_matrix(tiles, len(tiles))\n    if m:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a, b)].append((c, d))\n        tiles[(c, d)].append((a, b))\n\n    return tiles\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles = build_tiles()\n    m = build_matrix(tiles, m)\n    if m:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"
    }
  ],
  "created": 1649608462,
  "object": "edit"
}
2022-04-10 12:34:30.462584 fix spelling mistakes 2 ['\n\nimport sys\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a,b)].append((c,d))\n        tiles[(c,d)].append((a,b))\n    return tiles\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles = build_tiles()\n    m = build_matrix(tiles, len(tiles))\n    if m:\n        return "YES"\n    else:\n        return "NO"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == "__main__":\n    sys.exit(main())\n', '\n\nimport sys\n\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a, b)].append((c, d))\n        tiles[(c, d)].append((a, b))\n\n    return tiles\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles = build_tiles()\n    m = build_matrix(tiles, m)\n    if m:\n        return "YES"\n    else:\n        return "NO"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == "__main__":\n    sys.exit(main())\n']
2022-04-10 12:34:30.462857 size on output set 2
2022-04-10 12:34:30.462881 size on input set 2
2022-04-10 12:34:36.697944 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a, b)].append((c, d))\n        tiles[(c, d)].append((a, b))\n\n    return tiles, m\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles, m = build_tiles()\n    m = build_matrix(tiles, m)\n    if m:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a, b)].append((c, d))\n        tiles[(c, d)].append((a, b))\n\n    return tiles, m\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles, m = build_tiles()\n    m = build_matrix(tiles, m) \n    if m:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"
    }
  ],
  "created": 1649608470,
  "object": "edit"
}
2022-04-10 12:34:36.698251 fix syntax errors 2 ['\n\nimport sys\n\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a, b)].append((c, d))\n        tiles[(c, d)].append((a, b))\n\n    return tiles, m\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles, m = build_tiles()\n    m = build_matrix(tiles, m)\n    if m:\n        return "YES"\n    else:\n        return "NO"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == "__main__":\n    sys.exit(main())\n', '\n\nimport sys\n\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a, b)].append((c, d))\n        tiles[(c, d)].append((a, b))\n\n    return tiles, m\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles, m = build_tiles()\n    m = build_matrix(tiles, m) \n    if m:\n        return "YES"\n    else:\n        return "NO"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == "__main__":\n    sys.exit(main())\n']
2022-04-10 12:34:42.197857 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a,b)].append((c,d))\n        tiles[(c,d)].append((a,b))\n    return tiles\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles = build_tiles()\n    matrix = build_matrix(tiles, len(tiles))\n    if matrix:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a,b)].append((c,d))\n        tiles[(c,d)].append((a,b))\n    return tiles\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles = build_tiles()\n    m = build_matrix(tiles, max(tiles.keys())[0]+1)\n    if m:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"
    }
  ],
  "created": 1649608476,
  "object": "edit"
}
2022-04-10 12:34:42.198405 fix syntax errors 2 ['\n\nimport sys\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a,b)].append((c,d))\n        tiles[(c,d)].append((a,b))\n    return tiles\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles = build_tiles()\n    matrix = build_matrix(tiles, len(tiles))\n    if matrix:\n        return "YES"\n    else:\n        return "NO"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == "__main__":\n    sys.exit(main())\n', '\n\nimport sys\nfrom collections import defaultdict\n\ndef build_tiles():\n    tiles = defaultdict(list)\n    n = int(input())\n    m = int(input())\n    for i in range(n):\n        a, b = [int(x) for x in input().split()]\n        c, d = [int(x) for x in input().split()]\n        tiles[(a,b)].append((c,d))\n        tiles[(c,d)].append((a,b))\n    return tiles\n\ndef build_matrix(tiles, m):\n    matrix = [[-1 for _ in range(m)] for _ in range(m)]\n    i, j = 0, 0\n    while i < m:\n        if matrix[i][j] != -1:\n            i += 1\n            j = 0\n            continue\n        a, b = tiles[(i,j)]\n        if matrix[a][b] != -1:\n            return None\n        matrix[i][j] = matrix[j][i] = 0\n        matrix[a][b] = matrix[b][a] = 0\n        j += 1\n    return matrix\n\ndef solve():\n    tiles = build_tiles()\n    m = build_matrix(tiles, max(tiles.keys())[0]+1)\n    if m:\n        return "YES"\n    else:\n        return "NO"\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        print(solve())\n\nif __name__ == "__main__":\n    sys.exit(main())\n']
2022-04-10 12:34:42.198478 size on output set 4
