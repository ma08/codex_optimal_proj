["\n\ndef f(n, s, k):\n    dp = [0 for i in range(k+1)]\n    dp[0] = 1\n    for i in range(len(s)):\n        if(s[i]=='('):\n            for j in range(i+1, k+1):\n                dp[j]+=dp[j-1]\n                dp[j]%=1000000007\n        else:\n            for j in range(i+1, k+1):\n                dp[j]+=dp[j-1]*2\n                dp[j]%=1000000007\n    return dp[k]\n\nn = int(input())\ns = input()\nprint(f(n, s, 2*n))\n", "\n\ndef main():\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n\ndef solve(n, s):\n    num_ways = [1,1]\n    for i in range(2,2*n+1):\n        num_ways.append(num_ways[i-1]+num_ways[i-2])\n    if s[0] == '(':\n        s_left_parens = 1\n    else:\n        s_left_parens = 0\n    s_right_parens = len(s) - s_left_parens\n    if s_left_parens > s_right_parens:\n        return 0\n    if s_left_parens > n:\n        return 0\n    if s_right_parens > n:\n        return 0\n    if s_left_parens == s_right_parens:\n        return num_ways[s_left_parens]\n    if s_left_parens == n:\n        return num_ways[s_right_parens]\n    if s_right_parens == n:\n        return num_ways[s_left_parens]\n    return (num_ways[s_left_parens] * num_ways[s_right_parens]) % (10**9+7)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef f(n, s, m):\n\tdp = [0 for i in range(m+1)]\n\tdp[0] = 1\n\tfor i in range(len(s)):\n\t\tif(s[i]=='('):\n\t\t\tfor j in range(i+1, m+1):\n\t\t\t\tdp[j]+=dp[j-2]\n\t\t\t\tdp[j]%=1000000007\n\t\telse:\n\t\t\tfor j in range(i+1, m+1):\n\t\t\t\tdp[j]+=dp[j-2]\n\t\t\t\tdp[j]%=1000000007\n\treturn dp[m]\n\nn = int(input())\ns = input()\nprint(f(n, s, 2*n))\n", "\n\n# TODO: WA\n\nimport sys\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    mod = 1000000007\n    # dp[i][j] = number of sequences ending with j, i-th bracket matches,\n    # where i is the number of brackets, j is the number of '('\n    dp = [[0 for i in range(len(s)+1)] for j in range(2*n+1)]\n    dp[0][0] = 1\n    for i in range(1, 2*n+1):\n        for j in range(len(s)+1):\n            if i-1-j < 0 or 2*n-i < j:\n                continue\n            if dp[i-1][j] > 0:\n                if s[j] == '(':\n                    dp[i][j+1] = (dp[i][j+1] + dp[i-1][j]) % mod\n                else:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                    dp[i][j+2] = (dp[i][j+2] + dp[i-1][j]) % mod\n    ans = dp[2*n][len(s)] % mod\n    print(ans)\n", "\n\ndef main():\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n\ndef solve(n, s):\n    num_ways = [1,1]\n    for i in range(2,2*n+1):\n        num_ways.append(num_ways[i-1]+num_ways[i-2])\n    if s[0] == '(':\n        s_left_parens = 1\n    else:\n        s_left_parens = 0\n    s_right_parens = len(s) - s_left_parens\n    if s_left_parens < s_right_parens or s_left_parens > n or s_right_parens > n:\n        return 0    \n    if s_left_parens == s_right_parens or s_left_parens == n or s_right_parens == n:\n        return num_ways[s_left_parens]    \n    return (num_ways[s_left_parens] * num_ways[s_right_parens]) % (10**9+7)    \n\nif __name__ == \"__main__\":\n    main()\n", "\n# TODO: TLE, WA\n\nimport sys\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    mod = 1000000007\n    # dp[i][j] = number of sequences ending with j, i-th bracket matches,\n    # where i is the number of brackets, j is the number of '('\n    dp = [[0 for i in range(len(s)+1)] for j in range(2*n+1)]\n    dp[0][0] = 1\n    for i in range(1, 2*n+1):\n        for j in range(len(s)+1):\n            if i-1-j < 0 or 2*n-i < j:\n                continue\n            if dp[i-1][j] > 0:\n                if s[j] == '(':\n                    dp[i][j+1] = (dp[i][j+1] + dp[i-1][j]) % mod\n                else:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                    dp[i][j+2] = (dp[i][j+2] + dp[i-1][j]) % mod\n    ans = dp[2*n][len(s)] % mod\n    print(ans)\n", "\n\n# TODO: TLE, O(n^2)\n\nimport sys\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    mod = 1000000007\n    # dp[i][j] = number of sequences ending with j, i-th bracket matches\n    dp = [[0 for i in range(len(s)+1)] for j in range(2*n+1)] # O(n^2)\n    dp[0][0] = 1\n    for i in range(1, 2*n+1):\n        for j in range(len(s)+1):\n            if i-1-j < 0 or 2*n-i < j:\n                continue\n            if dp[i-1][j] > 0:\n                if s[j] == '(':\n                    dp[i][j+1] = (dp[i][j+1] + dp[i-1][j]) % mod\n                else:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                    dp[i][j+2] = (dp[i][j+2] + dp[i-1][j]) % mod\n    ans = dp[2*n][len(s)] % mod\n    print(ans)\n", "\n\ndef f(n, s, m):\n\tdp = [0 for i in range(m+1)]\n\tdp[0] = 1\n\tfor i in range(len(s)):\n\t\tif(s[i]=='('):\n\t\t\tfor j in range(i+1, m+1):\n\t\t\t\tdp[j]+=dp[j-1]\n\t\t\t\tdp[j]%=1000000007 \n\t\telse:\n\t\t\tfor j in range(i+1, m+1):\n\t\t\t\tdp[j]+=dp[j-1]\n\t\t\t\tdp[j]%=1000000007\n\treturn dp[m]\n\nn = int(input())\ns = input()\nprint(f(n, s, 2*n))\n", "\n\ndef main():\n    n = int(input())\n    s = input()\n    print(solve(n, s))\n\ndef solve(n, s):\n    num_ways = [1,1]\n    for i in range(2,2*n+1):\n        num_ways.append(num_ways[i-1]+num_ways[i-2])\n    if s[0] == '(':\n        s_left_parens = 1\n    else:\n        s_left_parens = 0\n    s_right_parens = len(s) - s_left_parens\n    if s_left_parens == s_right_parens: # balanced\n        return num_ways[s_left_parens] % (10**9+7)\n    if s_left_parens == n: # left is full\n        return num_ways[s_right_parens] % (10**9+7)\n    if s_right_parens == n: # right is full\n        return num_ways[s_left_parens] % (10**9+7)\n    return (num_ways[s_left_parens] * num_ways[s_right_parens]) % (10**9+7) # unbalanced\n\nif __name__ == \"__main__\":\n    main()\n", "\n# TODO: TLE, O(n^2)\n\nimport sys\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline())\n    s = sys.stdin.readline().strip()\n    mod = 1000000007\n    # dp[i][j] = number of sequences ending with j, i-th bracket matches\n    dp = [[0 for i in range(len(s) + 1)] for j in range(2 * n + 1)]\n    dp[0][0] = 1\n    for i in range(1, 2 * n + 1):\n        for j in range(len(s) + 1):\n            if i - 1 - j < 0 or 2 * n - i < j:\n                continue\n            if dp[i-1][j] > 0:\n                if s[j] == '(':\n                    dp[i][j+1] = (dp[i][j+1] + dp[i-1][j]) % mod\n                else:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j]) % mod\n                    dp[i][j+2] = (dp[i][j+2] + dp[i-1][j]) % mod\n    ans = dp[2*n][len(s)] % mod\n    print(ans)\n"]