["class Segment:\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\ndef main():\n    segments = []\n    n = int(input())\n    for _ in range(n):\n        left, right = [int(i) for i in input().split()]\n        segments.append(Segment(left, right))\n    print(solve(segments))\n\ndef solve(segments):\n    segments = sorted(segments, key=lambda x: (x.left, x.right))\n    max_length = 0\n    for i in range(len(segments)):\n        left = segments[i].left\n        right = segments[i].right\n        max_right = right\n        for j in range(i+1, len(segments)):\n            if segments[j].left <= right:\n                max_right = max(max_right, segments[j].right)\n            else:\n                break\n        max_length = max(max_length, max_right - left)\n    return max_length\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nclass Segment:\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\ndef main():\n    segments = []\n    n = int(input())\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append(Segment(l, r))\n    print(solve(segments))\n\ndef solve(segments):\n    segments = sorted(segments, key=lambda x: (x.left, x.right))\n    max_length = 0\n    for i in range(len(segments)):\n        left = segments[i].left\n        right = segments[i].right\n        max_right = right\n        for j in range(i+1, len(segments)):\n            if segments[j].left <= right:\n                max_right = max(max_right, segments[j].right)\n            else:\n                break\n        max_length = max(max_length, max_right - left)\n    return max_length\n\nif __name__ == \"__main__\":\n    main()\n", "\n#\n\ndef main():\n    n = int(input())\n    seq = []\n    for i in range(n):\n        line = [int(x) for x in input().split()]\n        seq.append(line)\n    seq.sort(key=lambda x: x[0])\n    ans = 0\n    for i in range(n):\n        if i == 0:\n            ans = max(ans, seq[i+1][0] - seq[i][1])\n        elif i == n-1:\n            ans = max(ans, seq[i][0] - seq[i-1][1])\n        else:\n            ans = max(ans, seq[i+1][0] - seq[i][1])\n            ans = max(ans, seq[i][0] - seq[i-1][1])\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n# \n\ndef main():\n    n = int(input())\n    seq = []\n    for i in range(n):\n        line = [int(x) for x in input().split()]\n        seq.append(line)\n    seq.sort(key=lambda x: x[1])\n    ans = 0\n    for i in range(n):\n        if i == 0:\n            ans = max(ans, seq[i][1] - seq[i+1][0])\n        elif i == n-1:\n            ans = max(ans, seq[i][0] - seq[i-1][1])\n        else:\n            ans = max(ans, seq[i][0] - seq[i-1][1])\n            ans = max(ans, seq[i][1] - seq[i+1][0])\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        a, b = [int(x) for x in input().split()]\n        if a == b:\n            print(0)\n        elif a < b:\n            if (b - a) % 2 == 0:\n                print(2)\n            else:\n                print(1)\n        else:\n            if (a - b) % 2 == 0:\n                print(1)\n            else:\n                print(2)\n\n\nmain()\n", "\n\n# If you remove a segment, you can only do one of two things: \n# 1. remove a segment that is entirely contained within another segment \n# 2. remove a segment that contains another segment entirely \n# \n# If you remove a segment that is entirely contained within another segment, the maximum length of the resulting intersection is the length of the smallest remaining segment \n# \n# If you remove a segment that contains another segment entirely, the maximum length of the resulting intersection is the length of the largest remaining segment \n# \n# This means that the maximum length of the intersection is the maximum of the length of the smallest remaining segment and the length of the largest remaining segment \n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        segments.append([int(x) for x in input().split()])\n    segments.sort(key=lambda x: x[0])\n\n    largest = segments[0][1]\n    smallest = segments[0][1] - segments[0][0]\n    for i in range(1, n):\n        if segments[i][0] >= segments[i - 1][0]:\n            largest = max(largest, segments[i][1] - segments[i - 1][0])\n        else:\n            smallest = min(smallest, segments[i][1] - segments[i][0])\n    print(max(largest, smallest))\n\nmain()\n", "\n\n# If you remove a segment, you can only do one of two things:\n# 1. remove a segment that is entirely contained within another segment\n# 2. remove a segment that contains another segment entirely\n#\n# If you remove a segment that is entirely contained within another segment, the maximum length of the resulting intersection is the length of the smallest remaining segment\n#\n# If you remove a segment that contains another segment entirely, the maximum length of the resulting intersection is the length of the largest remaining segment\n#\n# This means that the maximum length of the intersection is the maximum of the length of the smallest remaining segment and the length of the largest remaining segment\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        segments.append([int(x) for x in input().split()])\n    segments.sort(key=lambda x: x[0])\n\n    largest = segments[0][1]\n    smallest = segments[0][1] - segments[0][0]\n    for i in range(1, n):\n        if segments[i][0] >= segments[i - 1][0]:\n            largest = max(largest, segments[i][1] - segments[i - 1][0])\n        else:\n            smallest = min(smallest, segments[i][1] - segments[i][0])\n    print(max(largest, smallest))\n\nmain()\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Oct  2 00:00:00 2018\n\n@author: kkrista\n\"\"\"\n\n\ndef main():\n    n = int(input())\n    seq = []\n    for i in range(n):\n        line = [int(x) for x in input().split()]\n        seq.append(line)\n    seq.sort(key=lambda x: x[0])\n    ans = 0\n    for i in range(n):\n        if i == 0:\n            ans = max(ans, seq[i+1][0] - seq[i][1])\n        elif i == n-1:\n            ans = max(ans, seq[i][0] - seq[i-1][1])\n        else:\n            ans = max(ans, seq[i][0] - seq[i-1][1])\n            ans = max(ans, seq[i+1][0] - seq[i][1])\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Oct  2 00:00:00 2018\n\n@author: kkrista\n\"\"\"\n\n\ndef main():\n    n = int(input())\n    seq = [0]\n    for i in range(n):\n        seq.append(int(input()))\n    seq.append(10**9+1)\n    seq.sort()\n    ans = 0\n    for i in range(n):\n        if i == 0:\n            ans = max(ans, seq[i+1] - seq[i])\n        elif i == n-1:\n            ans = max(ans, seq[i] - seq[i-1])\n        else:\n            ans = max(ans, seq[i] - seq[i-1])\n            ans = max(ans, seq[i+1] - seq[i])\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\nclass Segment:\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n\ndef main():\n    segments = []\n    n = int(input())\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append(Segment(l, r))\n    print(solve(segments))\n\ndef solve(segments):\n    segments = sorted(segments, key=lambda x: (x.left, -x.right))\n    max_length = 0\n    i = 0\n    while i < len(segments):\n        left = segments[i].left\n        right = segments[i].right\n        max_right = right\n        while i < len(segments) and segments[i].left <= right:\n            max_right = max(max_right, segments[i].right)\n            i += 1\n        max_length = max(max_length, max_right - left)\n    return max_length\n\nif __name__ == \"__main__\":\n    main()\n"]