["#      \nimport collections, atexit, math, sys\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\nimport bisect \ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept ModuleNotFoundError:\n    def dprint(*args, **kwargs):\n        pass\n\n\ndef memo(func):  \n    cache={}  \n    def wrap(*args):  \n        if args not in cache:  \n            cache[args]=func(*args)  \n        return cache[args]  \n    return wrap\n\n@memo\ndef comb (n,k):\n    if k==0: return 1\n    if n==k: return 1\n    return comb(n-1,k-1) + comb(n-1,k)\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\ns = input()\nt = input()\n\nzs = list(s)\nzt = list(t)\nzs.sort()\nzt.sort()\nif zs != zt:\n    print(-1)\n    return\n\nzs = list(s)\n\nres = []\nfor i in range(N):\n    if zs[i] == t[i]: continue\n    for j in range(i+1,N):\n        if zs[j] == t[i]: break\n    for k in range(j-1,i-1, -1):\n        res.append(k)\n        zs[k],zs[k+1] = zs[k+1],zs[k]\n\nprint(len(res))\nfor x in res:\n    print(x+1,end = ' ')\n\n    \n\n\n\n\n\n\n\n", "def go():\n    from collections import Counter\n    n = int(input())\n    a = [i for i in input()]\n    b = [i for i in input()]\n    if Counter(a) != Counter(b):\n        return -1\n    i = 0\n    o = []\n    for i in range(n):\n        if a[i] == b[i]:\n            continue\n        else:\n            j = i + 1\n            while j < n and a[j] != b[i]:\n                j += 1\n            for k in range(j, i, -1):\n                a[k], a[k - 1] = a[k - 1], a[k]\n                o.append(k)\n    print(len(o))\n    return ' '.join(str(i) for i in o)\n\nprint(go())\n", "n = int(input())\nst1 = list(input())\nst2 = list(input())\nans = 0\nanslist = []\nfor i in range(n):\n    if st1[i] != st2[i]:\n        f = True\n        for j in range(i + 1, n):\n            if st1[j] == st2[i]:\n                ans += j - i\n                anslist += [k + 1 for k in reversed(range(i, j))]\n                f = False\n                st1 = st1[:i] + st1[j:j + 1] + st1[i:j] + st1[j + 1:]\n                break\n        if f:\n            print(-1)\n            quit()\nprint(ans)\nfor i in anslist:\n    print(i, end = \" \")\nprint()\n", "n = int(input())\ns = list(input())\nt = list(input())\nif sorted(s) != sorted(t):\n    print(-1)\nelse:\n    steps = []\n    for i in range(n):\n        needed = i\n        for j in range(i, n):\n            if s[j]==t[i]:\n                needed = j\n                break\n        while needed > i:\n            steps.append(needed)\n            needed -= 1\n            s[needed], s[needed+1] = s[needed+1], s[needed]\n    print(len(steps))\n    print(' '.join(map(str, steps)))\n", "n=int(input())\ns=input()\nt=input()\nt1=True\nans=[]\nfor i in range(n):\n    if s[i]!=t[i]:\n        t2=False\n        y=[]\n        y.append(i+1)\n        for j in range(i+1,n):\n            if s[j]==t[i]:\n                t2=True\n                x=j\n                break\n            y.append(1+j)\n        if t2:\n            y=y[::-1]\n            ans+=y\n            s=s[0:i]+t[i]+s[i:j]+s[j+1::]\n        else:\n            t1=False\n            break\nif t1:\n    print(len(ans))\n    for i in ans:\n        print(i,end=\" \")\nelse:\n    print(-1)\n", "n = int(input())\na = list(input())\nb = list(input())\nans = 0\nansl = []\nfor i in range(len(b)):\n    flag = True\n    for j in range(i, len(a)):\n        if a[j] == b[i]:\n            for k in range(j - i):\n                ans += 1\n                a[j-k], a[j-k-1] = a[j-k-1], a[j-k]\n                ansl.append(j - k)\n            flag = False\n            break\n    if flag:\n        print(-1)\n        return\nprint(ans)\nprint(*ansl)", "n = int(input())\ns = list(input())\nt = list(input())\n\nc = []\nfor i in range(n):\n    m = i\n    while (m < n) and (s[m] != t[i]):\n        m += 1\n    if m >= n:\n        c = None\n        break\n    for j in range(m - 1, i - 1, -1):\n        c.append(j + 1)\n        s[j], s[j + 1] = s[j + 1], s[j]\nif c == None:\n    print(-1)\nelse:\n    print(len(c))\n    print(*c)\n", "\ndef mi():\n\treturn map(int, input().split())\n\nn = int(input())\ns = list(input())\nt = list(input())\ninp1 = s.copy()\ninp2 = t.copy()\nif sorted(s)!=sorted(t):\n\tprint(-1)\nelse:\n\tout1 = []\n\tc1 = 0\n\tc2 = 0\n\tout2 = []\n\tfor i in range(n):\n\t\tif s[i]==t[i]:\n\t\t\tcontinue\n\t\tfor j in range(i+1, n):\n\t\t\tif s[j]==t[i]:\n\t\t\t\tindex = j\n\t\t\t\tbreak\n\t\ts[i+1:index+1] = s[i:index]\n\t\ts[i] = t[i]\n\t\tfor j in range(index,i,-1):\n\t\t\tc1+=1\n\t\t\tout1.append(j)\n\tprint (c1)\n\tfor i in out1:\n\t\tprint (i, end = ' ')", "n = int(input())\ns = input()\na = []\nt = input()\nif sorted(s) != sorted(t):\n    print(-1)\n\nelse:\n    for i in range(len(t)):\n        j = i\n        if s[j] == t[i]:\n            continue\n        while s[j] != t[i]:\n            j += 1\n        for x in range(j - 1, i - 1, -1):\n            a.append(x + 1)\n        s = s[:i] + s[j] + s[i:j] + s[j + 1:]\n    print(len(a))\n    for i in a:\n        print(i, end = ' ')", "n = int(input())\n\ns = input()\nt = input()\n\nif sorted(s) != sorted(t):\n    print( -1 )\nelse:\n    moves = []\n    s = list(s)\n    t = list(t)\n    for ind_t, val_t in enumerate(t):\n        i = ind_t + s[ind_t:].index(val_t)\n        for j in range(i-1, ind_t-1, -1):\n            moves.append(j+1)\n            s[j], s[j+1] = s[j+1], s[j]\n    print(len(moves))\n    print(\" \".join(str(x) for x in moves))\n\n\n\n", "import sys\n\nout = list()\nvalid = True\nl = int(sys.stdin.readline())\ns = [char for char in sys.stdin.readline()]\nt = [char for char in sys.stdin.readline()]\nfor loop in range(l):\n    #print(s, t)\n    i = loop\n    while i < l and s[i] != t[loop]:\n        i+=1\n    #print(i)\n    if s[i] != t[loop]:\n        print(-1)\n        valid = False\n        break\n    for loop2 in range(i, loop, -1):\n        out.append(loop2)\n        x = s[loop2-1]\n        s[loop2-1] = s[loop2]\n        s[loop2] = x\nif valid:\n    print(len(out))\n    print(*out)", "n = int(input())\ns = list(input())\nt = list(input())\na = []\ncount = 0\nfor i in range(n):\n    if s[i] != t[i]:\n        for j in range(i+1, n):\n            if s[j] == t[i]:\n                c = [str(k+1) for k in range(j-1, i-1, -1)]\n                count += len(c)\n                a += c\n                s.insert(i, s[j])\n                del s[j+1]\n                break\n        else:\n            print(-1)\n            break\nelse:\n    print(count)\n    print(' '.join(a))", "# from math import ceil\n#from sys import stdout\n\nt = 1#int(input())\nfor test in range(1,t+1):\n    n = int(input())\n    s = list(input())\n    t = list(input())\n    s1 = list(s)\n    t1 = list(t)\n    s1.sort();t1.sort()\n    if s1!=t1:\n        print(-1)\n        continue\n    count = 0\n    moves = []\n    for i in range(n):\n        tmp = i+s[i:].index(t[i])\n        count+=tmp-i\n        for j in range(tmp-1, i-1, -1):\n            s[j], s[j+1] = s[j+1], s[j]\n            moves.append(j+1)\n    print(count)\n    print(*moves)\n        \n\n\n\n\n\n\n\n\n\n    \n", "from collections import Counter\nn = int(input())\ns = input().strip()[:n]\nt = input().strip()[:n]\nif Counter(s) != Counter(t):\n    print(-1)\n    return\n\nres = []\nfor i in range(n):\n    pos = s[i:].find(t[i])\n    for k in range(i+pos, i, -1):\n        res.append(k)\n    # print(s)\n    s = s[i+pos] + s[:i+pos]  + s[i+pos +1 :]\nprint(len(res))\nprint(*res)\n", "n = int(input())\ns = input()\nt = input()\na = []\nfor i in range(n):\n\ta.append(s[i])\ns1 = dict()\nt1 = dict()\nfor j in s:\n\tif j not in s1:\n\t\ts1[j] = 1\n\telse:\n\t\ts1[j] += 1\nfor j in t:\n\tif j not in t1:\n\t\tt1[j] = 1\n\telse:\n\t\tt1[j] += 1\nif (s1 != t1):\n\tprint(-1)\nelse:\n\tans = []\n\tind = 0\n\twhile ind != n:\n\t\tq = ind\n\t\twhile a[q] != t[ind]:\n\t\t\tq += 1\n\t\twhile q != ind:\n\t\t\ta[q], a[q - 1] = a[q - 1], a[q]\n\t\t\tans.append(q)\n\t\t\tq -= 1\n\t\tind += 1\n\tprint(len(ans))\n\tprint(\" \".join(map(str, ans)))\t\n\t\t\t\n\n\n", "from collections import Counter\n\ndef get_index(first, ch, i, n):\n    for j in range(i, n):\n        if first[j] == ch:\n            return j\n    return -1\n\nn = int(input())\n\nfirst = input()\nsecond = input()\n\ntemp1 = Counter(first)\ntemp2 = Counter(second)\n\nif temp1 != temp2:\n    print(-1)\nelse:\n    first = list(first)\n    second = list(second)\n    ans, finalAns = 0, []\n    for i in range(n):\n        if first[i] == second[i]: continue\n        ind = get_index(first, second[i], i, n)\n        ans += ind - i\n##        print(i, ind)\n        for j in range(ind, i, -1): finalAns.append(j)\n        temp = first.pop(ind)\n        first.insert(i, temp)\n##        print(first)\n\n    print(ans)\n    print(*finalAns)\n    \n    \n", "n = int(input())\ns = input()\nt = input()\ns = list(s)\nt = list(t)\nA = [0] * 26\nB = [0] * 26\nfor i in range(n):\n    x = ord(t[i]) - ord('a')\n    y = ord(s[i]) - ord('a')\n    A[x] += 1\n    B[y] += 1\nif A == B:\n    M = []\n    for i in range(n):\n        if s[i] == t[i]:\n            continue\n        for j in range(i, n):\n            f = j\n            if s[j] == t[i]:\n                break\n        for k in range(f, i, -1):\n            M.append(k)\n            s[k], s[k - 1] = s[k - 1], s[k]\n    print(len(M))\n    print(*M)\nelse:\n    print(-1)\n", "def go():\n\n    n = int(input())\n\n    s_raw = input()\n    t_raw = input()\n\n    s = []\n    t = []\n\n    for i in range(0, n):\n\n        s.append(s_raw[i])\n        t.append(t_raw[i])\n\n        if s_raw.count(s[i]) != t_raw.count(s[i]) or s_raw.count(t[i]) != t_raw.count(t[i]):\n\n            ##print(s_raw.count(s[i]), t_raw.count(s[i]), s_raw.count(t[i]), t_raw.count(t[i]))\n\n            print(-1)\n            return\n\n    moves = []\n\n    for i in range(0, n): ##indices in s\n\n        if s[i] == t[i]: continue\n\n        for j in range(i+1, n):\n\n            if t[i] == s[j]: ##s[i] == t[j]:\n\n                for k in range(j-1, i-1, -1):\n\n                    moves.append(k+1)\n\n                    old_s_k = s[k]\n                    s[k] = s[k+1]\n                    s[k+1] = old_s_k\n\n                    ## print(s)\n\n                break\n\n    print(len(moves))\n\n    for m in moves:\n        print(m, end = ' ')\n    print()\n\n    return\n\ngo()\n", "def check():\n    nonlocal arr1,arr2,s1,s2\n    for i in range(26):\n        if arr1[i] != arr2[i]:\n            print(-1)\n            return\n    \n    start = 0\n    out = []\n    while start < len(s1):\n        if s1[start] == s2[start]:\n            start += 1\n            continue\n        \n        if s2[start] != s1[start]:\n            req_index = -1\n            for i in range(start+1,len(s2)):\n                if s1[i] == s2[start]:\n                    req_index = i\n                    break\n            for i in range(req_index,start,-1):\n                s1[i],s1[i-1] = s1[i-1],s1[i]\n                out.append(i)\n        start += 1\n\n    if s1 == s2:\n        if len(out) <= 10000:\n            print(len(out))\n            for o in out:\n                print(o,end=\" \")\n            print()\n        else:\n            print(-1)\n    else:\n        print(-1)\n\n\n\n\n\nn = int(input())\n\ns1 = list(input())\ns2 = list(input())\n\narr1 = [0]*26\narr2 = [0]*26\n\nfor i in range(len(s1)):\n    arr1[ord(s1[i])-97] += 1\n    arr2[ord(s2[i])-97] += 1\n\n\ncheck()", "n = int(input())\ns = input()\nt = input()\nres = []\ncount = 0\nfor i in range(n):\n    if t[i] not in s:\n        print(-1)\n        return\n    else:\n        ind = s.index(t[i])\n        for j in range(ind, 0, -1):\n            res.append(count + j)\n        s = s[:ind] + s[ind+1:]\n        count+=1\n\nk = len(res)\nif k>10**4: print(-1)\nelse:\n    print(k)\n    print(*res)\n", "n = int(input())\ns = list(input())\nt = list(input())\na, b = sorted(s), sorted(t)\nif a != b:\n    print(-1)\nelse:\n    k = 0\n    rec = []\n    while k < n:\n        while s[k] != t[k]:\n            f = s[k:].index(t[k]) + k - 1\n            rec.append(f + 1)\n            s[f], s[f + 1] = s[f + 1], s[f]\n\n        k += 1\n\n    print(len(rec))\n    print(\" \".join(map(str, rec)))", "\nn = int(input())\ns = input()\nt = input()\n\nres = []\nflag = 0\nfor i in range(n):\n\tif s[i] == t[i]:\n\t\tcontinue\n\tk = s[i:]\n\t# print(k,i)\n\tidx = k.find(t[i])\n\t# print(i,idx)\n\tif(idx == -1):\n\t\tflag = 1\n\t\tbreak\n\tidx += i\n\ts = s[:i]+s[idx]+s[i:idx]+s[idx+1:]\n\tdum = []\n\tfor j in range(i,idx):\n\t\tdum.append(j+1)\n\tdum.reverse()\n\tres.extend(dum)\n\nif flag == 1:\n\tprint(\"-1\")\nelse:\n\tprint(len(res))\n\tfor i in res:\n\t\tprint(i,end=\" \")"]