["const fs = require('fs');\nconst path = require('path');\n\nfs.mkdir(path.join(__dirname, '/test'), {}, err => {\n    if(err) throw err;\n    console.log('Folder created');\n});\n\nfs.writeFile(path.join(__dirname, '/test', 'hello.txt'), 'Hello world', err => {\n    if(err) throw err;\n    console.log('File written to...');\n\n    //file append\n    fs.appendFile(path.join(__dirname, '/test', 'hello.txt'), ' I love Node.js', err => {\n        if(err) throw err;\n        console.log('File written to...');\n    });\n});\n\n// read file\nfs.readFile(path.join(__dirname, '/test', 'hello.txt'), 'utf8', (err, data) => {\n    if(err) throw err;\n    console.log(data);\n});\n\n// rename file\nfs.rename(path.join(__dirname, '/test', 'hello.txt'), path.join(__dirname, '/test', 'helloworld.txt'), (err) => {\n    if(err) throw err;\n    console.log('File renamed');\n});\n", "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = []\n    for i in range(m):\n        diff = 0\n        indices = set()\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.add(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n", "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = set()\n    for i in range(m):\n        diff = 0\n        indices = set()\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.add(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nint main(int argc, char **argv)\n{\n\tchar *src;\n\tchar *dst;\n\tint fd1, fd2, ret;\n\tchar buf[0x100];\n\tint len;\n\t\n\tif (argc != 3) {\n\t\tprintf(\"usage: %s src dst\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\t\n\tsrc = argv[1];\n\tdst = argv[2];\n\t\n\tfd1 = open(src, O_RDONLY);\n\tif (fd1 < 0) {\n\t\tprintf(\"open %s error\\n\", src);\n\t\treturn -1;\n\t}\n\t\n\tfd2 = open(dst, O_WRONLY | O_CREAT, 0644);\n\tif (fd2 < 0) {\n\t\tprintf(\"open %s error\\n\", dst);\n\t\treturn -1;\n\t}\n\t\n\twhile (1) {\n\t\tlen = read(fd1, buf, 0x100);\n\t\tif (len <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tret = write(fd2, buf, len);\n\t\tif (ret != len) {\n\t\t\tprintf(\"write error\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tclose(fd1);\n\tclose(fd2);\n\t\n\treturn 0;\n}\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nint main(int argc, char **argv)\n{\n\tchar *src, *dst;\n\tint fd1, fd2, ret;\n\tchar buf[0x100] = {0};\n\tint len;\n\t\n\tif (argc != 3) {\n\t\tprintf(\"usage: %s src dst\\n\", argv[0]);\n\t\texit(-1);\n\t}\n\t\n\tsrc = argv[1];\n\tdst = argv[2];\n\t\n\tfd1 = open(src, O_RDONLY);\n\tif (fd1 < 0) {\n\t\tprintf(\"open %s error\\n\", src);\n\t\texit(-1);\n\t}\n\t\n\tfd2 = open(dst, O_WRONLY | O_CREAT, 0644);\n\tif (fd2 < 0) {\n\t\tprintf(\"open %s error\\n\", dst);\n\t\texit(-1);\n\t}\n\t\n\twhile (1) {\n\t\tlen = read(fd1, buf, 0x100);\n\t\tif (len <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tret = write(fd2, buf, len);\n\t\tif (ret != len) {\n\t\t\tprintf(\"write error\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tclose(fd1);\n\tclose(fd2);\n\t\n\treturn 0;\n}\n", "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\nlogging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))  # n\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))  # m\n\n    max_diff = -1\n    max_indices = set()\n    for i in range(m):\n        diff = 0\n        indices = set()\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.add(j + 1)\n        if max_diff == -1 or diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout.buffer)\n    args = parser.parse_args()\n\n    main(args)\n", "const fs = require('fs');\nconst path = require('path');\n\nfs.mkdir(path.join(__dirname, '/test'), {}, err => {\n    if(err) throw err;\n    console.log('Folder created');\n});\n\nfs.writeFile(path.join(__dirname, '/test', 'hello.txt'), 'Hello world', err => {\n    if(err) throw err;\n    console.log('File written to...');\n\n    //file append\n    fs.appendFile(path.join(__dirname, '/test', 'hello.txt'), ' I love Node.js', err => {\n        if(err) throw err;\n        console.log('File written to...');\n    });\n});\n\n// read file\nfs.readFile(path.join(__dirname, '/test', 'hello.txt'), 'utf8', (err, data) => {\n    if(err) throw err;\n    console.log(data);\n});\n\n//rename file\nfs.rename(path.join(__dirname, '/test', 'hello.txt'), path.join(__dirname, '/test', 'helloworld.txt'), (err) => {\n    if(err) throw err;\n    console.log('File renamed');\n});\n", "\n\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n = int(lines[0])\n    b = list(map(int, lines[2].split()))[:n]\n    c = list(map(int, lines[3].split()))[:n - 1]\n\n    # print(a)\n    # print(b)\n    # print(c)\n\n    dp = [0] * n\n    dp[0] = a[0]\n    for i in range(1, n):\n        dp[i] = min(dp[i - 1] + a[i], dp[i - 1] + b[i])\n        if i > 1:\n            dp[i] = min(dp[i], dp[i - 2] + b[i] + c[i - 1])\n\n    # print(dp)\n    a = list(map(int, lines[1].split()))[:n]\n\n    max_diff = 0\n    for i in range(n):\n        max_diff = max(max_diff, dp[i])\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff))\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n"]