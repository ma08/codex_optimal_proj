["from copy import deepcopy\nn,m = map(int,input().split())\na = list(map(int,input().split()))\nb = [list(map(int,input().split())) for i in range(m)]\nbest1 = -1\nbest2 = -1\nbest3 = []\nfor i in range(n):\n    tmp = 0\n    tmp2 = 0\n    tmp3 = []\n    c = deepcopy(a)\n    for j in range(m):\n        x,y = b[j]\n        x-=1;y-=1\n        if x<= i and i <= y:\n            continue\n        for k in range(x,y+1):\n            c[k] -= 1\n        tmp3.append(j+1)\n        tmp2 += 1\n    kon = max(c)-min(c)\n    if best1 < kon:\n        best1 = kon\n        best2 = tmp2\n        best3 = tmp3\nprint(best1)\nprint(best2)\nprint(*best3)", "n, m = map(int, input().split())\nmass = list(map(int, input().split()))\nlr = []\nfor t in range(m):\n    l, r = map(int, input().split())\n    lr.append([l, r])\nmq = 0\nmdel = []\nmitog = 0\nfor a in range(len(mass)):\n    ma = mass[a]\n    for b in range(len(mass)):\n        mb = mass[b]\n        q = 0\n        delete = []\n        itog = 0\n        for x in range(len(lr)):\n            l, r = lr[x][0], lr[x][1]\n            if l <= b+1 <= r and (a+1 < l or a+1 > r):\n                q += 1\n                delete.append(x+1)\n        itog = ma + q - mb\n        if mitog < itog:\n            mitog = itog\n            mq = q\n            mdel = delete\nprint(mitog)\nprint(mq)\nif len(mdel):\n    print(' '.join(list(map(str, mdel))))\nelse:\n    print('')", "n, m = list(map(int, input().split()))\nmas = list(map(int, input().split()))\notmas = []\nfor i in range(m):\n    otmas.append(list(map(int, input().split())))\nfor i in range(m):\n    otmas[i][0] -= 1\n    otmas[i][1] -= 1\nans = -1\nmasotv = []\nfor i in range(n):\n    mascop = mas.copy()\n    masotvizc = []\n    for j in range(m):\n        if not (i >= otmas[j][0] and i <= otmas[j][1]):\n            masotvizc.append(j + 1)\n            for k in range(otmas[j][0], otmas[j][1] + 1):\n                mascop[k] -= 1\n    if max(mascop) - min(mascop) > ans:\n        masotv = masotvizc\n    ans = max(ans, max(mascop) - min(mascop))\nprint(ans)\nprint(len(masotv))\nprint(*masotv)\n", "n, m = map(int, input().split())\narr = [int(x) for x in input().split()]\nseg = []\nel = []\nel2 = []\nh = []\n\ndef cont(a, b, c):\n    return a <= c <= b\n\ndef count_delta():\n    return max(h) - min(h)\n\ndef decrement(l, r):\n    for i in range(l - 1, r):\n        h[i] -= 1\n\nfor i in range(m):\n    seg.append([int(x) for x in input().split()])\n\nfor i in range(len(arr)):\n    h = arr[:]\n    tmp = []\n    for j in range(len(seg)):\n        if cont(seg[j][0], seg[j][1], i + 1):\n            decrement(seg[j][0], seg[j][1])\n            tmp.append(j + 1)\n    el.append(count_delta())\n    el2.append(tmp)\n    \nprint(max(el))\nk = el.index(max(el))\nprint(len(el2[k]))\nprint(*el2[k])", "from sys import stdin,stdout\nfrom collections import defaultdict\nimport math\n#stdin = open('input.txt','r')\nI = stdin.readline\nP = stdout.write\n\nn,m = map(int,I().split())\narr = [int(x) for x in I().split()]\n\nindi = defaultdict(lambda : set())\nfor j in range(m):\n\tl,r = map(int,I().split())\n\tfor i in range(l-1,r):\n\t\t\n\t\tindi[i].add(j+1)\n\nans = 0\na,b = 0,0\ninter = set()\n#print(indi)\nfor i in range(n):\n\tfor j in range(n):\n\t\tnowint = indi[j].intersection(indi[i])\n\t\tnow = arr[i]-arr[j]+len(indi[j])-len(nowint)\n\n\t\t\n\t\tif(now>ans):\n\t\t\tans = now\n\t\t\ta = i\n\t\t\tb = j\n\t\t\tinter = nowint\n\nprint(ans)\n#print(indi[b],nowint)\nprint(len(indi[b]))\nfor i in indi[b]:\n\t\n\tprint(i,end = \" \")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n       \n    \n\n\n\n\n", "n,m=list(map(int,input().split()))\nb=list(map(int,input().split()))\nse=[]\nfor i in range(m):\n    se.append(list(map(int,input().split())))\nk=max(b)-min(b)\nans=[]\nfor i in range(n):\n    l=[]\n    r=b[:]\n    for j in range(m):\n        c,d=se[j][0],se[j][1]\n        if i not in list(range(c-1,d)):\n            for x in range(c-1,d):\n                r[x]-=1\n            l.append(j+1)\n    x=max(r)-min(r)\n    if x>k:\n        k=x\n        ans=l\nprint(k)\nprint(len(ans))\nprint(*ans)\n        \n                \n\n", "n, m = list(map(int,input().split()))\na = list(map(int,input().split()))\nb = []\nfor i in range(m):\n    b.append(list(map(int,input().split())))\nans = -1000000000\n\nfor i in range(n):\n    ac = a.copy()\n    for j in range(m):\n        if i+1 < b[j][0] or i+1 > b[j][1]:\n            for k in range(b[j][0]-1, b[j][1]):\n                ac[k] -= 1\n    if a[i] - min(ac) > ans:\n        ans = a[i] - min(ac)\n        ansi = i\n\nansh = []\ni = ansi\nac = a.copy()\nq = 0\nfor j in range(m):\n    if i+1 < b[j][0] or i+1 > b[j][1]:\n        q += 1\n        ansh.append(j+1)\n\nprint(ans)\nprint(q)\nprint(*ansh)\n\n", "def read_nums():\n    return [int(x) for x in input().split()]\n\n\ndef calculate_diff(i1, i2, nums, all_segments):\n    cur_diff = nums[i2] - nums[i1]\n    used_segments = []\n    for index, segment in enumerate(all_segments):\n        left, right = segment\n        if left <= i1 <= right and not (left <= i2 <= right):\n            used_segments.append(index)\n            cur_diff += 1\n    return cur_diff, used_segments\n\n\ndef main():\n    n, m = read_nums()\n    nums = read_nums()\n    segments = [[x-1 for x in read_nums()] for _ in range(m)]\n\n    if n == 1:\n        print(0)\n        print(0)\n        return\n\n    candidates = []\n    for i1, num1 in enumerate(nums):\n        for i2, num2 in enumerate(nums):\n            if i1 == i2:\n                continue\n            diff, used_segments = calculate_diff(i1, i2, nums, segments)\n            candidates.append((diff, used_segments))\n\n    res_diff, segment_indexes = max(candidates, key=lambda x: x[0])\n    print(res_diff)\n    print(len(segment_indexes))\n    if len(segment_indexes) > 0:\n        print(' '.join([str(x + 1) for x in segment_indexes]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput=sys.stdin.readline\n\nn,m=map(int,input().split())\nx=[*map(int,input().split())]\nseg=[]\nfor i in range(m):\n    a=[*map(int,input().split())]\n    seg.append(a)\n\nans=-1\nansi=[]\nfor i in range(len(x)):\n    tx=x[:]\n    oi=[]\n    for n,j in enumerate(seg):\n        a,b=j\n        if not (a-1<=i<=b-1):\n            oi.append(n+1)\n            for k in range(a-1,b):\n                tx[k]-=1\n    m=max(tx)-min(tx)\n    if m>ans:\n        ans=m\n        ansi=oi[:]\n\nprint(ans)\nprint(len(ansi))\nfor i in ansi:\n    print(i,end=\" \")", "def __starting_point():\n    n, subset = map(int, input().split(\" \"))\n    a = list(map(int, input().split(\" \")))\n    f = []\n    t = []\n\n    for i in range(subset):\n        x, y = map(int, input().split(\" \"))\n        f.append(x - 1)\n        t.append(y - 1)\n\n    diff = 0\n    answer = []\n\n    for ma in range(n):\n        for mi in range(n):\n            inside = 0\n            cur_answer = []\n            for sub in range(subset):\n                if f[sub] <= mi <= t[sub] and not (f[sub] <= ma <= t[sub]):\n                    inside += 1\n                    cur_answer.append(sub)\n            if a[ma] - (a[mi] - inside) > diff:\n                diff = a[ma] - (a[mi] - inside)\n                answer = cur_answer\n\n    print(diff)\n    print(len(answer))\n    print(' '.join(str(x + 1) for x in answer))\n__starting_point()", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nsegments = []\nfor i in range(m):\n    l, r = list(map(int, input().split()))\n    segments.append([l, r])\n\nans = 0\nflag = 0\nfor i in range(n):\n    for j in range(i, n):\n        ai = a[i]\n        aj = a[j]\n        seglist1 = []\n        seglist2 = []\n        for k in range(m):\n            if segments[k][0]-1 <= i <= segments[k][1]-1 and segments[k][1]-1 < j:\n                ai -= 1\n                seglist1.append(k+1)\n            if segments[k][0]-1 > i and segments[k][0]-1 <= j <= segments[k][1]-1:\n                aj -= 1\n                seglist2.append(k+1)\n\n        if ans < a[j] - ai:\n            anslist = seglist1\n            ans = a[j] - ai\n            flag = 1\n        if ans < a[i] - aj:\n            anslist = seglist2\n            ans = a[i] - aj\n            flag = 1\nif flag == 1 and len(anslist) >= 1:\n    ansseg = str(anslist[0])\n    for i in range(1, len(anslist)):\n        ansseg += \" \" + str(anslist[i])\nelse:\n    anslist = []\n    ansseg = \"\"\n\nprint(ans)\nprint(len(anslist))\nprint(ansseg)\n", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    try:\n        f = open('input'+ str(inId) + '.txt', 'r')\n        sys.stdin = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    except Exception:\n        dprint('invalid input file')\nif outId>0:\n    dprint('use output', outId)\n    try:\n        f = open('stdout'+ str(outId) + '.txt', 'w')\n        sys.stdout = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    except Exception:\n        dprint('invalid output file')\n        \n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, M= getIntList()\n#print(N)\nza =  getIntList()\nomin = min(za)\nsg = [0 for i in range(N*4) ]\nde = sg.copy()\ndef built_sg(root, left, right):\n    if left== right:\n        sg[root] = za[left]\n        return sg[root]\n    mid = (left+right)//2\n    a = built_sg(root*2+1, left, mid)\n    b = built_sg(root*2+2, mid+1, right)\n    sg[root] = min(a,b)\n    return sg[root]\n\ndef update(root, left, right, qleft, qright, dif):\n    if qright<left or right< qleft : return sg[root]\n \n    if qleft<= left and right <= qright:\n        de[root] += dif\n        sg[root] += dif\n        return sg[root]\n    if de[root] !=0:\n        t = de[root]\n        sg[root*2+1] += t\n        sg[root*2+2] += t\n        de[root*2+1] +=t\n        de[root*2+2] += t\n        de[root] =0\n    mid = (left+right)//2\n    a = update(root*2+1, left, mid, qleft, qright, dif)\n    b = update(root*2+2, mid+1,right, qleft, qright, dif)\n    sg[root] = min(a,b)\n    return sg[root]\n\nbuilt_sg(0,0,N-1)\nzm = []\nzz = [0,N]\nfor i in range(M):\n    l,r = getIntList()\n    l-=1\n    r-=1\n    zm.append((l,r) )\n    zz.append(l)\n    zz.append(r+1)\nzz.sort()\nr = max(za) - sg[0]\nzr = []\nfor i in range( len(zz) -1):\n    a = zz[i]\n    b = zz[i+1]\n    if a==b: continue\n    t = max(za[a:b])\n    tzr = []\n    for j in range(M):\n        x = zm[j]\n        if x[0] <= a <= x[1]: continue\n        tzr.append(j+1)\n        update(0,0,N-1, x[0],x[1],-1)\n    t1 = sg[0]\n    if r < t - t1:\n        r = t - t1\n        zr = tzr\n    for x in zm:\n        if x[0] <= a <= x[1]:  continue\n        update(0,0,N-1, x[0],x[1],1)\n    assert( omin == sg[0]) \n\n\n    \nprint(r)\nprint(len(zr))\nfor x in zr:\n    print(x, end = ' ')\n\n\n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = [list(map(int, input().split())) for i in range(m)]\ngl_ans = -1\ngl_mas = []\n\nfor num_i in range(n):\n    ma = -1e7\n    ans_m = []\n    o = []\n    for i in range(m):\n        if b[i][0] - 1 > num_i or b[i][1] - 1 < num_i:\n            o.append([b[i][0] - 1, -1])\n            o.append([b[i][1], 0])\n            ans_m.append(i + 1)\n    for i in range(n):\n        o.append([i, 1])\n\n    o.sort()\n    cnt = 0\n    mi = 1e7\n    for u in range(len(o)):\n        if o[u][1] == -1:\n            cnt -= 1\n        elif o[u][1] == 0:\n            cnt += 1\n        else:\n            if a[o[u][0]] + cnt < mi:\n                mi = a[o[u][0]] + cnt\n            # if a[o[u][0]] + cnt > ma:\n            #             #     ma = a[o[u][0]] + cnt\n            #             #     print(cnt)\n    ma = a[num_i]\n    # print(mi, ma, ans_m, o)\n\n    if ma - mi > gl_ans:\n        gl_ans = ma - mi\n        gl_mas = ans_m\n\nprint(gl_ans)\nprint(len(gl_mas))\nprint(*gl_mas)", "n, m = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nL = [0] * m\nR = [0] * m\nfor i in range(m):\n    l, r = list(map(int, input().split()))\n    L[i] = l-1\n    R[i] = r-1\n    \n    \n\nma = -1\nmai = -1\nfor i in range(n):\n    B = [a for a in A] # Copy of A\n    for j in range(m):\n        if L[j]>i or R[j] < i:\n            for k in range(L[j], R[j]+1):\n                B[k] -= 1\n                \n    d = B[i] - min(B)\n    # print(d, B)\n    \n    if d > ma:\n        ma = d\n        mai = i\n\nprint(ma)\nB = [a for a in A] # Copy of A\nX = []\nfor j in range(m):\n    if L[j]>mai or R[j] < mai:\n        X.append(str(j+1))\n\nprint(len(X))\nprint(\" \".join(X))\n", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nans=[]\npair=[]\nfor i in range(m):\n    x=list(map(int,input().split()))\n    #print(x)\n    pair.append(x)\nfor i in range(n):\n    for j in range(n):\n        d=[]\n        b=0\n        for k in range(m):\n            if j+1>=pair[k][0] and j+1<=pair[k][1] and (i+1<pair[k][0] or i+1>pair[k][1]) :\n                b+=1\n                d.append(k+1)\n        d=[a[i]-a[j]+b]+d\n        ans.append(d) \n        #print(*d)      \nans.sort()\nprint(ans[-1][0])\nsz=len(ans[-1])-1\nprint(sz)\nprint(*ans[-1][1:])", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nans=[]\npair=[]\nfor i in range(m):\n    x=list(map(int,input().split()))\n    #print(x)\n    pair.append(x)\nfor i in range(n):\n    for j in range(n):\n        d=[]\n        b=0\n        for k in range(m):\n            if j+1>=pair[k][0] and j+1<=pair[k][1] and (i+1<pair[k][0] or i+1>pair[k][1]) :\n                b+=1\n                d.append(k+1)\n        d=[a[i]-a[j]+b]+d\n        ans.append(d) \n        #print(*d)      \nans.sort()\nprint(ans[-1][0])\nsz=len(ans[-1])-1\nprint(sz)\nprint(*ans[-1][1:])", "n,m = [int(x) for x in input().split()]\n\nL = [int(x) for x in input().split()]\n\nlarge = max(L)\nR = []\nused = 0\nPairs = []\nbest = 0\nlol = []\nfor i in range(n):\n    if L[i] == large:\n        R.append(i)\n\n\nfor T in range(m):\n    l,j = [int(x) for x in input().split()]\n    Pairs.append((l,j))\n\nfor j in range(0,n):\n    S = L[:]\n    tu = 0\n    tuu = []\n    for i in range(m):\n        if (Pairs[i][0]-1 > j) or (Pairs[i][1] <= j):\n            tu += 1\n            tuu.append(i+1)\n            for k in range(Pairs[i][0]-1,Pairs[i][1]):\n                S[k] -= 1\n    t = max(S)-min(S)\n    if t > best:\n        best = t\n        used = tu\n        lol = tuu\n        \nprint(best)\nprint(used)\nprint(' '.join(str(i) for i in lol))\n", "\n\n\ndat = list(map(int, input().split()))\nl = list(map(int, input().split()))\n\n\nd = {}\ni = 1\nwhile i < dat[1] + 1:\n  inter = list(map(int, input().split()))\n  j = inter[0]\n  while j < inter[1] + 1:\n    if j not in d:\n      d[j] = set()\n    d[j].add(i)\n    j+=1\n  i+=1\n\n\nmax_res = -1 \nans = None\n\ni = 0\nwhile i  < len (l):\n  j = 0\n  while j < len (l):\n    ii = i + 1\n    jj = j + 1\n    res_i = l[i]\n    res_j = l[j]\n    if ii in d:\n      res_i = l[i] - len(d[ii])\n      \n      if jj in d:\n        for dd in d[ii]:\n          if dd in d[jj]:\n            res_j -= 1\n\n    res = res_j  - res_i\n    if res > max_res:\n      max_res = res\n      ans = ii\n    j += 1\n  i += 1\n  \nif max_res == -1:\n  print(0)\n  print(0)\nelse:\n  print(max_res)\n  if ans in d:\n    print(len(d[ans]))\n    print(' '.join(map(str, d[ans])))\n  else:\n    print(0)\n\n", "n, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\nlst = []\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    lst.append([a, b])\nanswer = 0\nanswer_1 = []\nfor i in range(n):\n    B = A.copy()\n    kek = []\n    for j in range(m):\n        a, b = lst[j][0], lst[j][1]\n        if a <= i + 1 <= b:\n            kek.append(j + 1)\n            for q in range(a - 1, b):\n                B[q] -= 1\n    elem = max(B)\n    if answer < elem - B[i]:\n        answer = elem - B[i]\n        answer_1 = kek.copy()\nprint(answer)\nprint(len(answer_1))\nprint(' '.join(map(str, answer_1)))", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [0]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(list(range(m))):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\ninter2 = []\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    inter2.append((r,l))\n\ninter_copy = inter[:]\n\ninter.sort()\ninter2.sort()\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nj1 = 0\nj2 = 0\nfor i in range(n):\n    # Only segments containing i should be active\n    # Activate\n    while j1<m and inter[j1][0]<=i:\n        l,r = inter[j1]\n        Aneg.add(l,r,1)\n        j1 += 1\n    # Deactivate\n    while j2<m and inter2[j2][0]<=i:\n        r,l = inter2[j2]\n        Aneg.add(l,r,-1)\n        j2 += 1\n    Amax = -Aneg.min(0,n)\n    Ai = -Aneg.min(i,i+1)\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [j for j in range(m) if inter_copy[j][0]<=besta_ind<inter_copy[j][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])\n", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [0]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(list(range(m))):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\ninter2 = []\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    inter2.append((r,l))\n\ninter_copy = inter[:]\n\ninter.sort()\ninter2.sort()\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nj1 = 0\nj2 = 0\nfor i in range(n):\n    # Only segments containing i should be active\n    # Activate\n    while j1<m and inter[j1][0]<=i:\n        l,r = inter[j1]\n        Aneg.add(l,r,1)\n        j1 += 1\n    # Deactivate\n    while j2<m and inter2[j2][0]<=i:\n        r,l = inter2[j2]\n        Aneg.add(l,r,-1)\n        j2 += 1\n    Amax = -Aneg.min(0,n)\n    Ai = -Aneg.min(i,i+1)\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [j for j in range(m) if inter_copy[j][0]<=besta_ind<inter_copy[j][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])\n", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(list(range(m))):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\ninter2 = []\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    inter2.append((r,l))\n\ninter_copy = inter[:]\n\ninter.sort()\ninter2.sort()\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nj1 = 0\nj2 = 0\nfor i in range(n):\n    # Only segments containing i should be active\n    # Activate\n    while j1<m and inter[j1][0]<=i:\n        l,r = inter[j1]\n        Aneg.add(l,r,1)\n        j1 += 1\n    # Deactivate\n    while j2<m and inter2[j2][0]<=i:\n        r,l = inter2[j2]\n        Aneg.add(l,r,-1)\n        j2 += 1\n    Amax = -Aneg.data[1]\n    Ai = A[i]-(j1-j2)\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter_copy[i][0]<=besta_ind<inter_copy[i][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])\n", "import sys\n\n# a very nice implementation of a minimum segment tree with \n# some inspiration taken from https://codeforces.com/blog/entry/18051\n# this implementation should be able to be modified to do pretty\n# much anything one would want to do with segment trees apart from\n# persistance.\n# note that especially in python this implementation is much much better\n# than most other approches because how slow python can be with function\n# calls.\n\n# currently it allows for two operations, both running in o(log n),\n# 'add(l,r,value)' adds value to [l,r)\n# 'find_min(l,r)' finds the index with the smallest value\n\nbig = 10**9\n\nclass super_seg:\n    def __init__(self,data):\n        n = len(data)\n        m = 1\n        while m<n: m *= 2\n        \n        self.n = n\n        self.m = m\n        self.data = [big]*(2*m)\n        for i in range(n):\n            self.data[i+m] = data[i]\n        for i in reversed(list(range(m))):\n            self.data[i] = min(self.data[2*i], self.data[2*i+1])\n        self.query = [0]*(2*m)\n    \n    # push the query on seg_ind to its children\n    def push(self,seg_ind):\n        # let the children know of the queries\n        q = self.query[seg_ind]\n\n        self.query[2*seg_ind]   += q\n        self.query[2*seg_ind+1] += q\n        \n        self.data[2*seg_ind]   += q\n        self.data[2*seg_ind+1] += q\n\n        # remove queries from seg_ind\n        self.data[seg_ind] = min(self.data[2*seg_ind],self.data[2*seg_ind+1])\n        self.query[seg_ind] = 0\n\n    # updates the node seg_ind to know of all queries\n    # applied to it via its ancestors\n    def update(self,seg_ind):\n        # find all indecies to be updated\n        seg_ind //= 2\n        inds = []\n        while seg_ind>0:\n            inds.append(seg_ind)\n            seg_ind//=2\n       \n        # push the queries down the segment tree\n        for ind in reversed(inds):\n            self.push(ind)\n\n    # make the changes to seg_ind be known to its ancestors\n    def build(self,seg_ind):\n        seg_ind//=2\n        while seg_ind>0:\n            self.data[seg_ind] = min(self.data[2*seg_ind], self.data[2*seg_ind+1]) + self.query[seg_ind]\n            seg_ind //= 2\n\n    # lazily add value to [l,r)\n    def add(self,l,r,value):\n        l += self.m\n        r += self.m\n        \n        l0 = l\n        r0 = r\n\n        while l<r:\n            if l%2==1:\n                self.query[l]+= value\n                self.data[l] += value\n                l+=1\n            if r%2==1:\n                r-=1\n                self.query[r]+= value\n                self.data[r] += value\n            l//=2\n            r//=2\n\n        # tell all nodes above of the updated\n        # area of the updates\n        self.build(l0)\n        self.build(r0-1)\n    \n    # min of data[l,r)\n    def min(self,l,r):\n        l += self.m\n        r += self.m\n\n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n        \n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        return min(self.data[ind] for ind in segs)\n\n\n    # find index of smallest value in data[l,r)\n    def find_min(self,l,r):\n        l += self.m\n        r += self.m\n        \n        # apply all the lazily stored queries\n        self.update(l)\n        self.update(r-1)\n\n        segs = []\n        while l<r:\n            if l%2==1:\n                segs.append(l)\n                l+=1\n            if r%2==1:\n                r-=1\n                segs.append(r)\n            l//=2\n            r//=2\n\n        ind = min(segs, key=lambda i:self.data[i])\n        mini = self.data[ind]\n       \n        # dig down in search of mini\n        while ind<self.m:\n            self.push(ind)\n\n            if self.data[2*ind]==mini:\n                ind *= 2\n            else:\n                ind = 2*ind+1\n        \n        return ind-self.m,mini\n\n\nn,m = [int(x) for x in input().split()]\n\nA = [int(x) for x in input().split()]\n\ninter = []\ninter2 = []\nfor _ in range(m):\n    l,r = [int(x) for x in input().split()]\n    l -= 1\n    inter.append((l,r))\n    inter2.append((r,l))\n\ninter_copy = inter[:]\n\ninter.sort()\ninter2.sort()\n\nAneg = super_seg([-a for a in A])\n\nbesta = -1\nbesta_ind = -1\n\nj1 = 0\nj2 = 0\nfor i in range(n):\n    # Only segments containing i should be active\n    # Activate\n    while j1<m and inter[j1][0]<=i:\n        l,r = inter[j1]\n        Aneg.add(l,r,1)\n        j1 += 1\n    # Deactivate\n    while j2<m and inter2[j2][0]<=i:\n        r,l = inter2[j2]\n        Aneg.add(l,r,-1)\n        j2 += 1\n    Amax = -Aneg.data[1]\n    Ai = A[i]-(j1-j2)\n    if Amax-Ai>besta:\n        besta = Amax-Ai\n        besta_ind = i\n\nints = [i for i in range(m) if inter_copy[i][0]<=besta_ind<inter_copy[i][1]]\n\nprint(besta)\nprint(len(ints))\nprint(*[x+1 for x in ints])\n", "n, m = list(map(int, input().split()))\nA = list(map(int, input().split()))\nif n > 300:\n    lst = []\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        lst.append([a, b])\n    answer = 0\n    answer_1 = []\n    m300 = [[-1, -10**6]]\n    for i in range(max(0, m-1)):\n        m300.append([-1, -10**6])\n    for u in range(n):\n        if A[u] > min(m300)[1]:\n            m300[m300.index(min(m300))] = [u, A[u]]\n    for i, mi in m300:\n        B = A.copy()\n        kek = []\n        for j in range(m):\n            a, b = lst[j][0], lst[j][1]\n            if a <= i + 1 <= b:\n                kek.append(j + 1)\n                for q in range(a - 1, b):\n                    B[q] -= 1\n        elem = max(B)\n        if answer < elem - mi:\n            answer = elem - mi\n            answer_1 = kek.copy()\n    print(answer)\n    print(len(answer_1))\n    print(' '.join(map(str, answer_1)))\nelse:\n    lst = []\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        lst.append([a, b])\n    answer = 0\n    answer_1 = []\n    for i in range(n):\n        B = A.copy()\n        kek = []\n        for j in range(m):\n            a, b = lst[j][0], lst[j][1]\n            if a <= i + 1 <= b:\n                kek.append(j + 1)\n                for q in range(a - 1, b):\n                    B[q] -= 1\n        elem = max(B)\n        if answer < elem - B[i]:\n            answer = elem - B[i]\n            answer_1 = kek.copy()\n    print(answer)\n    print(len(answer_1))\n    print(' '.join(map(str, answer_1)))"]