2022-04-24 07:11:07.651217 num operations 2
2022-04-24 07:11:07.651238 size on input set 1
2022-04-24 07:11:07.651395 using api key kouti
2022-04-24 07:11:16.880672 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be \n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The idea is to sort the numbers and then go over them.\n# If we are at a number that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be different from the previous number.\n# If we are at a number that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous number.\n# Otherwise, we can't change the number at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650784267,
  "object": "edit"
}
2022-04-24 07:11:16.880907 fix spelling mistakes 2 ["\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be \n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\n# The idea is to sort the numbers and then go over them.\n# If we are at a number that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be different from the previous number.\n# If we are at a number that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous number.\n# Otherwise, we can't change the number at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-24 07:11:16.880944 size on output set 2
2022-04-24 07:11:16.880951 size on input set 2
2022-04-24 07:11:16.881103 using api key soukgp
2022-04-24 07:11:29.125488 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# We can use a greedy algorithm to solve this problem.\n# The idea is to sort the numbers.\n# Then we go over them one by one.\n# If we are at a number that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous number.\n# If we are at a number that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous number.\n# Otherwise, we can't change the number at all, so we need to add another number.\n# We can do this in linear time, so overall complexity is O(n log n).\n\nimport sys, math\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The idea is to sort the numbers and then go over them.\n# If we are at a number that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be different from the previous number.\n# If we are at a number that is bigger than the previous one by more than one,\n# we can decrease it by one, and we are sure that it will be different from the previous number.\n# Otherwise, we can't change the number at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650784276,
  "object": "edit"
}
2022-04-24 07:11:29.125729 fix syntax errors 2 ["\n\n# SOLUTION\n# We can use a greedy algorithm to solve this problem.\n# The idea is to sort the numbers.\n# Then we go over them one by one.\n# If we are at a number that is the same as the previous one, we can increase it by one and then we are sure that it will be different from the previous number.\n# If we are at a number that is bigger than the previous one by more than one, we can decrease it by one, and we are sure that it will be different from the previous number.\n# Otherwise, we can't change the number at all, so we need to add another number.\n# We can do this in linear time, so overall complexity is O(n log n).\n\nimport sys, math\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\n# The idea is to sort the numbers and then go over them.\n# If we are at a number that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be different from the previous number.\n# If we are at a number that is bigger than the previous one by more than one,\n# we can decrease it by one, and we are sure that it will be different from the previous number.\n# Otherwise, we can't change the number at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-24 07:11:29.125973 using api key sunu
2022-04-24 07:11:35.149355 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650784289,
  "object": "edit"
}
2022-04-24 07:11:35.149567 fix syntax errors 2 ["\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-24 07:11:35.149602 size on output set 3
2022-04-24 07:11:35.149613 num operations 2
2022-04-24 07:11:35.149619 size on input set 1
2022-04-24 07:11:35.149788 using api key kouti
2022-04-24 07:11:40.525262 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\nprint(count)\n"
    }
  ],
  "created": 1650784295,
  "object": "edit"
}
2022-04-24 07:11:40.525443 fix spelling mistakes 2 ['\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\nprint(count)\n']
2022-04-24 07:11:40.525466 size on output set 2
2022-04-24 07:11:40.525473 size on input set 2
2022-04-24 07:11:40.525613 using api key sunu
2022-04-24 07:11:45.957024 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    }
  ],
  "created": 1650784300,
  "object": "edit"
}
2022-04-24 07:11:45.957191 fix syntax errors 2 ['\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n']
2022-04-24 07:11:45.957347 using api key derek
2022-04-24 07:11:51.575147 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# coding: utf-8\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n"
    },
    {
      "index": 1,
      "text": "\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\nprint(count)\n"
    }
  ],
  "created": 1650784305,
  "object": "edit"
}
2022-04-24 07:11:51.575337 fix syntax errors 2 ['# coding: utf-8\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n', '\nn = int(input())\na = list(map(int, input().split()))\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\nprint(count)\n']
2022-04-24 07:11:51.575360 size on output set 3
