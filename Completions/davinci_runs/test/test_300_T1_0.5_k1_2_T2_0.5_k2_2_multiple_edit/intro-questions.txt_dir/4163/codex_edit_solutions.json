["\nimport sys\n\ndef main():\n    N = int(sys.stdin.readline().rstrip())\n    D = []\n    for i in range(N):\n        D.append(list(map(int, sys.stdin.readline().rstrip().split()))\n    for i in range(N-2):\n        if D[i][0] == D[i][1] and D[i+1][0] == D[i+1][1] and D[i+2][0] == D[i+2][1]:\n            print(\"Yes\")\n            return 0\n    print(\"No\")\n    return 0\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    N = int(sys.stdin.readline().strip())\n    D = []\n    for i in range(N):\n        D.append(list(map(int, sys.stdin.readline().strip().split())))\n    for i in range(N-2):\n        if D[i][0] == D[i][1] and D[i+1][0] == D[i+1][1] and D[i+2][0] == D[i+2][1]:\n            print(\"Yes\")\n            return\n    print(\"No\")\n    return\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    N = int(sys.stdin.readline().rstrip())\n    D = []\n    for i in range(N):\n        D.append(list(map(int, sys.stdin.readline().rstrip().split())))\n    for i in range(N-2):\n        if D[i][0] == D[i][1] and D[i+1][0] == D[i+1][1] and D[i+2][0] == D[i+2][1]:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    N = int(sys.stdin.readline().strip())\n    D = [[0 for i in range(2)] for j in range(N)]\n    for i in range(N):\n        D[i][0], D[i][1] = map(int, sys.stdin.readline().strip().split())\n    for i in range(N-2):\n        if D[i][0] == D[i][1] and D[i+1][0] == D[i+1][1] and D[i+2][0] == D[i+2][1]:\n            print(\"Yes\")\n            return\n    print(\"No\")\n    return\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nsys.setrecursionlimit(10**7)\n\n\ndef bfs(graph, start):\n    visited = [False] * len(graph)\n    queue = [start]\n    while queue:\n        current = queue.pop(0)\n        if not visited[current]:\n            visited[current] = True\n            queue.extend(graph[current])\n    return visited\n\n\ndef dfs(graph, start):\n    visited = [False] * len(graph)\n    stack = [start]\n    while stack:\n        current = stack.pop()\n        if not visited[current]:\n            visited[current] = True\n            stack.extend(graph[current])\n    return visited\n\n\ndef dfs_recursive(graph, start, visited):\n    visited[start] = True\n    for next_node in graph[start]:\n        if not visited[next_node]:\n            dfs_recursive(graph, next_node, visited)\n\n\ndef dfs_recursive_all(graph):\n    visited = [False] * len(graph)\n    for i in range(len(graph)):\n        if not visited[i]:\n            dfs_recursive(graph, i, visited)\n\n\ndef topological_sort(graph):\n    stack = []\n    visited = [False] * len(graph)\n    for i in range(len(graph)):\n        if not visited[i]:\n            topological_sort_recursive(graph, i, visited, stack)\n    return stack[::-1]\n\n\ndef topological_sort_recursive(graph, start, visited, stack):\n    visited[start] = True\n    for next_node in graph[start]:\n        if not visited[next_node]:\n            topological_sort_recursive(graph, next_node, visited, stack)\n    stack.append(start)\n\n\ndef main():\n    v, e = map(int, input().split())\n    graph = [[] for _ in range(v)]\n    for i in range(e):\n        s, t = map(int, input().split())\n        graph[s].append(t)\n    print(topological_sort(graph))\n\n\nif __name__ == '__main__':\n    main()\n", "# -*- coding: utf-8 -*-\n\n\ndef main():\n    with open(\"input.txt\", \"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()\n        for line in lines:\n            print(line.strip())\n\n\nif __name__ == '__main__':\n    main()\n"]