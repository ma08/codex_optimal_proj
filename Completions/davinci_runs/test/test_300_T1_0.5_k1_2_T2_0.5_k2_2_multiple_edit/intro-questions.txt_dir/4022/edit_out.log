2022-04-24 05:36:28.465981 num operations 2
2022-04-24 05:36:28.466000 size on input set 1
2022-04-24 05:36:28.466130 using api key soukgp
2022-04-24 05:36:34.464775 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Solution\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    }
  ],
  "created": 1650778588,
  "object": "edit"
}
2022-04-24 05:36:34.465017 fix spelling mistakes 2 ['\n\n# Solution\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n']
2022-04-24 05:36:34.465053 size on output set 2
2022-04-24 05:36:34.465061 size on input set 2
2022-04-24 05:36:34.465180 using api key jaanu
2022-04-24 05:36:43.306442 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Solution\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution\n\nn = int(input())\n\ny = []\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n    y.append(x[i][0])\n\ny.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][1]\n    b = y[i]\n    if a - b > ans:\n        ans = a - b\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n# Solution\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    }
  ],
  "created": 1650778594,
  "object": "edit"
}
2022-04-24 05:36:43.306630 fix syntax errors 2 ['\n\n# Solution\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution\n\nn = int(input())\n\ny = []\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n    y.append(x[i][0])\n\ny.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][1]\n    b = y[i]\n    if a - b > ans:\n        ans = a - b\n\nprint(ans)\n', '\n\n# Solution\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n']
2022-04-24 05:36:43.306777 using api key soukgp
2022-04-24 05:36:55.841696 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a, b = x[i][0], x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n# Solution\n\nn = int(input())\n\nx = [0] * n\ny = [0] * n\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x[i] = a\n    y[i] = b\n\nx.sort()\ny.sort()\n\nprint(y[-1] - x[0])\n"
    }
  ],
  "created": 1650778603,
  "object": "edit"
}
2022-04-24 05:36:55.841880 fix syntax errors 2 ['\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a, b = x[i][0], x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n# Solution\n\nn = int(input())\n\nx = [0] * n\ny = [0] * n\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x[i] = a\n    y[i] = b\n\nx.sort()\ny.sort()\n\nprint(y[-1] - x[0])\n']
2022-04-24 05:36:55.842041 size on output set 4
2022-04-24 05:36:55.842055 num operations 2
2022-04-24 05:36:55.842060 size on input set 1
2022-04-24 05:36:55.842187 using api key jaanu
2022-04-24 05:37:10.559269 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# The problem is to find the interval with the least intersection length.\n# If we sort the intervals by their left endpoints, we can consider the\n# problem as finding the interval with the least intersection length with\n# the interval before it.\n\n# To do this, we can keep track of the right endpoint of the previous interval.\n# For the first interval, we just set the right endpoint to -infinity.  For the\n# next interval, we compute the intersection length and update the right\n# endpoint to the right endpoint of the current interval.  We can then keep\n# track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous interval\n# and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nintervals = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\nintervals.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in intervals:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length\n# with the segment before it.  If we sort the segments by their left\n# endpoints, we can consider the problem as finding the segment with the\n# least intersection length with the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    }
  ],
  "created": 1650778615,
  "object": "edit"
}
2022-04-24 05:37:10.559459 fix spelling mistakes 2 ["\n\n# SOLUTION\n# The problem is to find the interval with the least intersection length.\n# If we sort the intervals by their left endpoints, we can consider the\n# problem as finding the interval with the least intersection length with\n# the interval before it.\n\n# To do this, we can keep track of the right endpoint of the previous interval.\n# For the first interval, we just set the right endpoint to -infinity.  For the\n# next interval, we compute the intersection length and update the right\n# endpoint to the right endpoint of the current interval.  We can then keep\n# track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous interval\n# and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nintervals = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\nintervals.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in intervals:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length\n# with the segment before it.  If we sort the segments by their left\n# endpoints, we can consider the problem as finding the segment with the\n# least intersection length with the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"]
2022-04-24 05:37:10.559500 size on output set 2
2022-04-24 05:37:10.559507 size on input set 2
2022-04-24 05:37:10.559646 using api key kouti
2022-04-24 05:37:53.596824 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length\n# with the segment before it.  If we sort the segments by their left\n# endpoints, we can consider the problem as finding the segment with the\n# least intersection length with the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a min-heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the minimum.\n\nimport heapq\nimport sys\n\nn = int(sys.stdin.readline())\nsegments = []\nfor i in range(n):\n    l, r = map(int, sys.stdin.readline().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    }
  ],
  "created": 1650778630,
  "object": "edit"
}
2022-04-24 05:37:53.597119 fix syntax errors 2 ['\n\n# SOLUTION\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n', "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length\n# with the segment before it.  If we sort the segments by their left\n# endpoints, we can consider the problem as finding the segment with the\n# least intersection length with the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a min-heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the minimum.\n\nimport heapq\nimport sys\n\nn = int(sys.stdin.readline())\nsegments = []\nfor i in range(n):\n    l, r = map(int, sys.stdin.readline().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"]
2022-04-24 05:37:53.597307 using api key sunu
2022-04-24 05:38:06.239596 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# The problem is to find the interval with the least intersection length.  If\n# we sort the intervals by their left endpoints, we can consider the problem as\n# finding the interval with the least intersection length with the interval\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# interval.  For the first interval, we just set the right endpoint to\n# -infinity.  For the next interval, we compute the intersection length and\n# update the right endpoint to the right endpoint of the current interval.  We\n# can then keep track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# interval and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nintervals = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\nintervals.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in intervals:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION 1\n# The problem is to find the interval with the least intersection length.\n# If we sort the intervals by their left endpoints, we can consider the\n# problem as finding the interval with the least intersection length with\n# the interval before it.\n\n# To do this, we can keep track of the right endpoint of the previous interval.\n# For the first interval, we just set the right endpoint to -infinity.  For the\n# next interval, we compute the intersection length and update the right\n# endpoint to the right endpoint of the current interval.  We can then keep\n# track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous interval\n# and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nintervals = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\nintervals.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in intervals:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n\n# SOLUTION 2\n# The problem is to find the interval with the least intersection length.\n# If we sort the intervals by their left endpoints, we can consider the\n# problem as finding the interval with the least intersection length with\n# the interval before it.\n\n# To do this, we can keep track of the right endpoint of the previous interval.\n# For the first interval, we just set the right endpoint to -infinity.  For the\n# next interval, we compute the intersection length and update the right\n# endpoint to the right endpoint of the current interval.  We can then keep\n# track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous interval\n# and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nintervals = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\nintervals.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in intervals:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    }
  ],
  "created": 1650778673,
  "object": "edit"
}
2022-04-24 05:38:06.239789 fix syntax errors 2 ["\n\n# SOLUTION\n# The problem is to find the interval with the least intersection length.  If\n# we sort the intervals by their left endpoints, we can consider the problem as\n# finding the interval with the least intersection length with the interval\n# before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# interval.  For the first interval, we just set the right endpoint to\n# -infinity.  For the next interval, we compute the intersection length and\n# update the right endpoint to the right endpoint of the current interval.  We\n# can then keep track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# interval and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nintervals = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\nintervals.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in intervals:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", "\n\n# SOLUTION 1\n# The problem is to find the interval with the least intersection length.\n# If we sort the intervals by their left endpoints, we can consider the\n# problem as finding the interval with the least intersection length with\n# the interval before it.\n\n# To do this, we can keep track of the right endpoint of the previous interval.\n# For the first interval, we just set the right endpoint to -infinity.  For the\n# next interval, we compute the intersection length and update the right\n# endpoint to the right endpoint of the current interval.  We can then keep\n# track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous interval\n# and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nintervals = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\nintervals.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in intervals:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n\n# SOLUTION 2\n# The problem is to find the interval with the least intersection length.\n# If we sort the intervals by their left endpoints, we can consider the\n# problem as finding the interval with the least intersection length with\n# the interval before it.\n\n# To do this, we can keep track of the right endpoint of the previous interval.\n# For the first interval, we just set the right endpoint to -infinity.  For the\n# next interval, we compute the intersection length and update the right\n# endpoint to the right endpoint of the current interval.  We can then keep\n# track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous interval\n# and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nintervals = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\nintervals.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in intervals:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"]
2022-04-24 05:38:06.239906 size on output set 4
