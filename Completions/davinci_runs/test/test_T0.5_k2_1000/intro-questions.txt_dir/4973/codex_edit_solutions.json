["#!/usr/bin/python3\n\ndef is_valid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if is_valid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "import queue\nn = int(input())\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\nvisited = set()\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "import queue\n\nn = int(input())\n\nboard = [input() for _ in range(n)]\n\nq = queue.Queue()\nq.put((n-1,n-1))\n\nvisited = set()\n\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\nimport sys\nsys.setrecursionlimit(1000000)\n\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1: #if the knight is at the bottom left corner\n        return 0\n\n    if dp[i][j] != -1: #if the knight is at a cell that has already been visited\n        return dp[i][j]\n\n    if board[i][j] == '#': #if the knight is at a cell that has a block\n        return sys.maxsize\n\n    x = sys.maxsize #initialize x to infinity\n    #check if the knight can move to any of the 8 cells\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x #set the value of the cell to 1 + the minimum value of the 8 cells\n    return dp[i][j]\n\ndef main():\n    #input the dimensions of the board\n    N = int(input())\n    #input the board\n    board = []\n    for i in range(N):\n        board.append(input())\n    #initialize the dp array\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    #find the minimum number of steps needed to reach the cell (1, 1)\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K': #if the knight is at the cell\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "def isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set() \n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == n - 1 and c == n - 1:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8): \n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.': \n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2] \ndc = [-1, 1, -2, 2, -2, 2, -1, 1] \n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**6)\n\ndef is_valid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            return moves\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if is_valid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = 0\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\n# Function to check if the move is valid or not\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n# Function to find the minimum number of steps needed to reach the cell (1, 1)\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n    dp[i][j] = 1 + x\n    return dp[i][j]\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\nmain()\n", "\nimport sys\nsys.setrecursionlimit(1000000)\n\n\ndef isValid(i, j, N):\n    if i >= 1 and i <= N and j >= 1 and j <= N:\n        return True\n    return False\n\n\ndef findMinSteps(i, j, N, board, dp):\n    if i == 1 and j == 1:\n        return 0\n\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = sys.maxsize\n    if isValid(i-2, j-1, N):\n        x = min(x, findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N):\n        x = min(x, findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N):\n        x = min(x, findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N):\n        x = min(x, findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N):\n        x = min(x, findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N):\n        x = min(x, findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N):\n        x = min(x, findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N):\n        x = min(x, findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = 1 + x\n    return dp[i][j]\n\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[-1 for i in range(N+1)] for j in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if board[i-1][j-1] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == sys.maxsize:\n                    print(-1)\n                else:\n                    print(x)\n\n\nmain()\n", "import queue as q\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board))] for _ in range(len(board))]\n    q1 = q.Queue()\n    for i in range(len(board)):\n        for j in range(len(board)):\n            if board[i][j] == 'K':\n                q1.put((i, j, 0))\n                visited[i][j] = True\n\n    while q1.qsize() > 0:\n        x, y, steps = q1.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q1.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q1.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q1.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q1.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q1.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q1.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q1.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q1.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\n# bfs\nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "def isValid(r, c):\n    if r >= 0 and r < n and c >= 0 and c < n:\n        return True\n    return False\n\ndef bfs(r, c):\n    global ans\n    queue = [(r, c, 0)]\n    visited = set()\n    while queue:\n        r, c, moves = queue.pop(0)\n        if r == 0 and c == 0:\n            ans = moves\n            return\n        if (r, c) not in visited:\n            visited.add((r, c))\n            for i in range(8):\n                new_r = r + dr[i]\n                new_c = c + dc[i]\n                if isValid(new_r, new_c) and board[new_r][new_c] == '.':\n                    queue.append((new_r, new_c, moves + 1))\n\ndr = [-2, -2, -1, -1, 1, 1, 2, 2]\ndc = [-1, 1, -2, 2, -2, 2, -1, 1]\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\n\nans = -1\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == 'K':\n            bfs(i, j)\n\nprint(ans)\n", "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a square\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the squares to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the squares visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        square, steps = queue.popleft()\n        if square == (0, 0):\n            return steps\n        for move in get_valid_moves(square):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "\n# Solution 1:\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\n\n#!/usr/bin/env python3\n\nimport os\nimport sys\n\n# Complete the repeatedString function below.\ndef repeatedString(s, n):\n    count = 0\n    for i in range(len(s)):\n        if s[i] == 'a':\n            count += 1\n    count *= n // len(s)\n    for i in range(n % len(s)):\n        if s[i] == 'a':\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')  # os.environ['OUTPUT_PATH']\n\n    s = input()\n\n    n = int(input())  # int(input())\n\n    result = repeatedString(s, n)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()\n", "\n#!/bin/python\n\nimport os\nimport sys\n\ndef knightOnAChessboard(n):\n    moves = [[1, 2], [1, -2], [2, 1], [2, -1], [-1, 2], [-1, -2], [-2, 1], [-2, -1]]\n    board = [[0 for i in range(n)] for j in range(n)]\n    board[n-1][n-1] = 1\n    q = []\n    q.append([n-1, n-1])\n    while len(q) > 0:\n        cur = q.pop(0)\n        x = cur[0]\n        y = cur[1]\n        for move in moves:\n            newx = x + move[0]\n            newy = y + move[1]\n            if newx >= 0 and newx < n and newy >= 0 and newy < n and board[newx][newy] == 0:\n                board[newx][newy] = board[x][y] + 1\n                q.append([newx, newy])\n    return board\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    n = int(input())\n\n    result = knightOnAChessboard(n)\n\n    fptr.write('\\n'.join([' '.join(map(str, x)) for x in result]))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n# Solution 1 (BFS)\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2 (BFS)\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1),\n            (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\n\nimport sys\nsys.setrecursionlimit(1000000)\nimport math\n# Function to check if the move is valid.\ndef isValid(i, j, N):\n    if i >= 0 and i < N and j >= 0 and j < N:\n        return True\n    return False\n\n# Function to find the minimum number of steps needed to reach the cell (1, 1).\ndef findMinSteps(i, j, N, board, dp):\n    if i == 0 and j == 0:\n        return 0\n\n    if dp[i][j] != math.inf:\n        return dp[i][j]\n\n    if board[i][j] == '#':\n        return sys.maxsize\n\n    x = math.inf\n    if isValid(i-2, j-1, N) and board[i-2][j-1] != '#':\n        x = min(x, 1 + findMinSteps(i-2, j-1, N, board, dp))\n    if isValid(i-2, j+1, N) and board[i-2][j+1] != '#':\n        x = min(x, 1 + findMinSteps(i-2, j+1, N, board, dp))\n    if isValid(i+2, j-1, N) and board[i+2][j-1] != '#':\n        x = min(x, 1 + findMinSteps(i+2, j-1, N, board, dp))\n    if isValid(i+2, j+1, N) and board[i+2][j+1] != '#':\n        x = min(x, 1 + findMinSteps(i+2, j+1, N, board, dp))\n    if isValid(i-1, j-2, N) and board[i-1][j-2] != '#':\n        x = min(x, 1 + findMinSteps(i-1, j-2, N, board, dp))\n    if isValid(i-1, j+2, N) and board[i-1][j+2] != '#':\n        x = min(x, 1 + findMinSteps(i-1, j+2, N, board, dp))\n    if isValid(i+1, j-2, N) and board[i+1][j-2] != '#':\n        x = min(x, 1 + findMinSteps(i+1, j-2, N, board, dp))\n    if isValid(i+1, j+2, N) and board[i+1][j+2] != '#':\n        x = min(x, 1 + findMinSteps(i+1, j+2, N, board, dp))\n\n    dp[i][j] = x\n    return dp[i][j]\n\ndef main():\n    N = int(input())\n    board = []\n    for i in range(N):\n        board.append(input())\n    dp = [[math.inf for i in range(N)] for j in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 'K':\n                x = findMinSteps(i, j, N, board, dp)\n                if x == math.inf:\n                    print(-1)\n                else:\n                    print(x)\n\nmain()\n", "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n# define a function to check if a move is valid or not\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n# define a function to get all valid moves from a cell\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the cells to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the cells visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        cell, steps = queue.popleft()\n        if cell == (0, 0):\n            return steps\n        for move in get_valid_moves(cell):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "\n# \nimport sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "import queue\n\ndef isSafe(board, visited, i, j):\n    return i >= 0 and i < len(board) and j >= 0 and j < len(board[0]) and board[i][j] != '#' and not visited[i][j]\n\ndef min_steps(board):\n    visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n    q = queue.Queue()\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'K':\n                q.put((i, j, 0))\n                visited[i][j] = True\n\n    while q.qsize() > 0:\n        x, y, steps = q.get()\n        if x == 0 and y == 0:\n            return steps\n\n        if isSafe(board, visited, x + 2, y + 1):\n            q.put((x + 2, y + 1, steps + 1))\n            visited[x + 2][y + 1] = True\n\n        if isSafe(board, visited, x + 2, y - 1):\n            q.put((x + 2, y - 1, steps + 1))\n            visited[x + 2][y - 1] = True\n\n        if isSafe(board, visited, x - 2, y + 1):\n            q.put((x - 2, y + 1, steps + 1))\n            visited[x - 2][y + 1] = True\n\n        if isSafe(board, visited, x - 2, y - 1):\n            q.put((x - 2, y - 1, steps + 1))\n            visited[x - 2][y - 1] = True\n\n        if isSafe(board, visited, x + 1, y + 2):\n            q.put((x + 1, y + 2, steps + 1))\n            visited[x + 1][y + 2] = True\n\n        if isSafe(board, visited, x + 1, y - 2):\n            q.put((x + 1, y - 2, steps + 1))\n            visited[x + 1][y - 2] = True\n\n        if isSafe(board, visited, x - 1, y + 2):\n            q.put((x - 1, y + 2, steps + 1))\n            visited[x - 1][y + 2] = True\n\n        if isSafe(board, visited, x - 1, y - 2):\n            q.put((x - 1, y - 2, steps + 1))\n            visited[x - 1][y - 2] = True\n\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(list(input()))\nprint(min_steps(board))\n", "\nfrom queue import Queue\nn = int(input())\nboard = [input() for _ in range(n)]\n\nq = Queue()\nq.put((n-1,n-1))\nvisited = set()\ndistance = 0\n\nwhile not q.empty():\n    size = q.qsize()\n\n    for _ in range(size):\n        r, c = q.get()\n\n        if (r,c) == (0,0):\n            print(distance)\n            exit()\n\n        if board[r][c] == '#':\n            continue\n\n        visited.add((r,c))\n\n        if r+1 < n and (r+1,c) not in visited:\n            q.put((r+1,c))\n        if r-1 >= 0 and (r-1,c) not in visited:\n            q.put((r-1,c))\n        if c+1 < n and (r,c+1) not in visited:\n            q.put((r,c+1))\n        if c-1 >= 0 and (r,c-1) not in visited:\n            q.put((r,c-1))\n\n    distance += 1\n\nprint(-1)\n", "\n# Solution 1:\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n# Solution 2:\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "\n# Solution 1 (BFS)\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n\n\n# Solution 2 (BFS)\ndef get_moves(r, c):\n    return [(r + 2, c + 1), (r + 2, c - 1), (r - 2, c + 1), (r - 2, c - 1), (r + 1, c + 2), (r + 1, c - 2), (r - 1, c + 2), (r - 1, c - 2)]\n\ndef is_valid(r, c):\n    return r >= 1 and c >= 1 and r <= n and c <= n\n\ndef is_knight(r, c):\n    return board[r - 1][c - 1] == 'K'\n\ndef is_empty(r, c):\n    return board[r - 1][c - 1] == '.'\n\ndef is_blocked(r, c):\n    return board[r - 1][c - 1] == '#'\n\ndef bfs(r, c):\n    q = [(r, c, 0)]\n    while q:\n        r, c, d = q.pop(0)\n        if r == c == 1:\n            return d\n        for r1, c1 in get_moves(r, c):\n            if is_valid(r1, c1) and is_empty(r1, c1) and (r1, c1) not in vis:\n                vis.add((r1, c1))\n                q.append((r1, c1, d + 1))\n    return -1\n\nn = int(input())\nboard = []\nfor _ in range(n):\n    board.append(input())\nvis = set()\nfor i in range(n):\n    for j in range(n):\n        if is_knight(i + 1, j + 1):\n            print(bfs(i + 1, j + 1))\n            break\n", "import sys\n\ndef bfs(board, n):\n    queue = []\n    queue.append((n-1, n-1, 0))\n    while queue:\n        i, j, steps = queue.pop(0)\n        if board[i][j] == 'K':\n            return steps\n        if board[i][j] == '.':\n            board[i][j] = '#'\n            if i + 2 < n and j + 1 < n and board[i + 2][j + 1] != '#':\n                queue.append((i + 2, j + 1, steps + 1))\n            if i + 2 < n and j - 1 >= 0 and board[i + 2][j - 1] != '#':\n                queue.append((i + 2, j - 1, steps + 1))\n            if i - 2 >= 0 and j + 1 < n and board[i - 2][j + 1] != '#':\n                queue.append((i - 2, j + 1, steps + 1))\n            if i - 2 >= 0 and j - 1 >= 0 and board[i - 2][j - 1] != '#':\n                queue.append((i - 2, j - 1, steps + 1))\n            if i + 1 < n and j + 2 < n and board[i + 1][j + 2] != '#':\n                queue.append((i + 1, j + 2, steps + 1))\n            if i + 1 < n and j - 2 >= 0 and board[i + 1][j - 2] != '#':\n                queue.append((i + 1, j - 2, steps + 1))\n            if i - 1 >= 0 and j + 2 < n and board[i - 1][j + 2] != '#':\n                queue.append((i - 1, j + 2, steps + 1))\n            if i - 1 >= 0 and j - 2 >= 0 and board[i - 1][j - 2] != '#':\n                queue.append((i - 1, j - 2, steps + 1))\n    return -1\n\ndef main():\n    n = int(sys.stdin.readline())\n    board = []\n    for i in range(n):\n        board.append(sys.stdin.readline().strip())\n    print(bfs(board, n))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import deque\n\n# read the input\nN = int(sys.stdin.readline())\nboard = []\nfor i in range(N):\n    board.append(list(sys.stdin.readline().strip()))\n\n# find the starting point of the knight\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == \"K\":\n            start = (i, j)\n            break\n\n# define the valid moves\nmoves = [\n    (2, 1),\n    (2, -1),\n    (-2, 1),\n    (-2, -1),\n    (1, 2),\n    (1, -2),\n    (-1, 2),\n    (-1, -2),\n]\n\n\n# define a function to check if a move is valid\ndef valid_move(move):\n    if 0 <= move[0] < N and 0 <= move[1] < N and board[move[0]][move[1]] != \"#\":\n        return True\n    return False\n\n\n# define a function to get all valid moves from a square\ndef get_valid_moves(cell):\n    valid_moves = []\n    for move in moves:\n        if valid_move((cell[0] + move[0], cell[1] + move[1])):\n            valid_moves.append((cell[0] + move[0], cell[1] + move[1]))\n    return valid_moves\n\n# define a function to find the minimum steps\ndef min_steps(start):\n    # create a queue to store the squares to be visited\n    queue = deque()\n    queue.append((start, 0))\n\n    # create a set to store the squares visited\n    visited = set()\n    visited.add(start)\n\n    # use BFS to find the minimum steps\n    while queue:\n        square, steps = queue.popleft()\n        if square == (0, 0):\n            return steps\n        for move in get_valid_moves(square):\n            if move not in visited:\n                visited.add(move)\n                queue.append((move, steps + 1))\n\n    return -1\n\nprint(min_steps(start))\n", "\nimport sys\n\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\n\nboard = [list(map(int, input().split())) for _ in range(n)]\n\ndp = [[0] * m for _ in range(n)]\n\ndp[0][0] = 1\n\nfor i in range(n):\n    for j in range(m):\n        if i == 0 and j == 0:\n            continue\n\n        if board[i][j] == 0:\n            continue\n\n        if i-1 >= 0:\n            dp[i][j] += dp[i-1][j]\n        if j-1 >= 0:\n            dp[i][j] += dp[i][j-1]\n\nprint(dp[n-1][m-1])\n"]