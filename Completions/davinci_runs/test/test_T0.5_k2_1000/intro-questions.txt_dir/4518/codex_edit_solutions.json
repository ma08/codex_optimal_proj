["\ndef add(a,b):\n    return a+b\ndef sub(a,b):\n    return a-b\ndef mul(a,b):\n    return a*b\ndef div(a,b):\n    return a/b\ndef mod(a,b):\n    return a%b\ndef exp(a,b):\n    return a**b\n\ndef main():\n    a=int(input())\n    b=int(input())\n    print(add(a,b))\n    print(sub(a,b))\n    print(mul(a,b))\n    print(div(a,b))\n    print(mod(a,b))\n    print(exp(a,b))\n\nmain()\n", "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])) # 1-2\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])) # 1-3\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])) # 2-1\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])) # 2-3\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n", "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if(len(b)==len(d)==len(f)==len(h)):\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n            print(\"4 5\")\n            print(\"5 6\")\n        else:\n            print(\"NO\")\nmain()\n", "\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using BFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\n\t# use BFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0])\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1])\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n", "\n\ndef main():\n    n=int(input())\n    for i in range(n):\n        a=input()\n        b=input().split()\n        b=[int(x) for x in b]\n        c=int(input())\n        d=input().split()\n        d=[int(x) for x in d]\n        e=int(input())\n        f=input().split()\n        f=[int(x) for x in f]\n        g=int(input())\n        h=input().split()\n        h=[int(x) for x in h]\n        if(b==d==f==h):\n            print(\"YES\")\n            print(\"1 2\")\n            print(\"2 3\")\n            print(\"3 4\")\n            print(\"4 5\")\n            print(\"5 6\")\n        else:\n            print(\"NO\")\nmain()\n", "\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        a = input()\n        b = input().split()\n        b = [int(x) for x in b]\n        c = int(input())\n        d = input().split()\n        d = [int(x) for x in d]\n        e = int(input())\n        f = input().split()\n        f = [int(x) for x in f]\n        g = int(input())\n        h = input().split()\n        h = [int(x) for x in h]\n\n\nmain()\n", "\nimport random\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using DFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use DFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n", "import random\n\n\ndef check_roads(gangs, roads):\n\t# check if it's possible to connect all districts using given roads\n\t# using BFS\n\tconnected = set()\n\tfor road in roads:\n\t\tconnected.add(road[0])\n\t\tconnected.add(road[1])\n\n\tfor road in roads:\n\t\tif gangs[road[0]-1] == gangs[road[1]-1]:\n\t\t\treturn False\n\n\tqueue = list(connected)\n\twhile queue:\n\t\tcurr = queue.pop(0)\n\t\tfor road in roads:\n\t\t\tif curr in road:\n\t\t\t\tif road[0] not in connected:\n\t\t\t\t\tconnected.add(road[0])\n\t\t\t\t\tqueue.append(road[0])\n\t\t\t\tif road[1] not in connected:\n\t\t\t\t\tconnected.add(road[1])\n\t\t\t\t\tqueue.append(road[1])\n\n\treturn len(connected) == len(gangs)\n\n\ndef connect_gangs(gangs):\n\t# connect all gangs using DFS\n\t# find all possible roads\n\troads = []\n\tfor i in range(len(gangs)):\n\t\tfor j in range(i+1, len(gangs)):\n\t\t\tif gangs[i] != gangs[j]:\n\t\t\t\troads.append((i+1, j+1))\n\t# shuffle roads\n\trandom.shuffle(roads)\n\n\t# use DFS to find a solution\n\tqueue = [roads]\n\twhile queue:\n\t\troads = queue.pop(0)\n\t\tif check_roads(gangs, roads):\n\t\t\treturn roads\n\n\t\t# check all possible ways to extend the roads\n\t\tfor i in range(len(roads)):\n\t\t\tfor j in range(i+1, len(roads)):\n\t\t\t\tnew_roads = roads[:]\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][0]))  # 1-2\n\t\t\t\tnew_roads.append((roads[i][0], roads[j][1]))  # 1-3\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][0]))  # 2-3\n\t\t\t\tnew_roads.append((roads[i][1], roads[j][1]))  # 2-4\n\t\t\t\tqueue.append(new_roads)\n\n\treturn None\n\n\nt = int(input())\nfor i in range(t):\n\tn = int(input())\n\tgangs = list(map(int, input().split()))\n\troads = connect_gangs(gangs)\n\tif roads:\n\t\tprint(\"YES\")\n\t\tfor road in roads:\n\t\t\tprint(*road)\n\telse:\n\t\tprint(\"NO\")\n"]