["def sign(x):\n    return (x > 0) - (x < 0)\n\n\ndef key(ab):\n    a, b = ab\n    return (2, -a - b) if b < 0 else (1, a)\n\n\ndef main():\n    n, r = list(map(int, input().split()))\n    for a, b in sorted((tuple(map(int, input().split())) for _ in range(n)), key=key):\n        if r < a:\n            r = -1\n            break\n        r += b\n    if r < 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\n\nmain()\n", "n, r = map(int, input().split())\n\npt = []\nnt = []\nr2 = r\nfor _ in range(n):\n    a, b = map(int, input().split())\n    r2 += b\n    if b >= 0:\n        pt.append((a, b))\n    else:\n        nt.append((a, b))\n\nif r2 < 0:\n    print('NO')\n    return\n\npt.sort()\nnt.sort(key=lambda t: t[0]+t[1])\n\nfor a, b in pt:\n    if r<a:\n        print(\"NO\")\n        return\n    r += b\n\nfor a, b in nt:\n    if r2 < a+b:\n        print('NO')\n        return\n    r2 -= b\n\nprint('YES')", "n, r = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\npos = []\nneg = []\nfor x in a:\n    if x[1] > 0:\n        pos.append(x)\n    else:\n        neg.append(x)\npos.sort(key=lambda k: k[0])\nflg = 1\nfor x in pos:\n    if r < x[0]:\n        flg = 0\n    else:\n        r += x[1]\nneg.sort(key=lambda k: k[0]+k[1], reverse=True)\nfor x in neg:\n    if r < x[0]:\n        flg = 0\n    else:\n        r += x[1]\n        if r < 0:\n            flg = 0\nif flg == 1:\n    print('YES')\nelse:\n    print('NO')", "n, r = [int(i) for i in input().split()]\n\nproj = [[0 for i in range(2)] for j in range(n)]\nposb = 0\nsum_neg = 0\n\nfor i in range(n):\n    proj[i][0], proj[i][1] = [int(j) for j in input().split()]\n    if proj[i][1] >= 0: posb += 1\n    else: sum_neg += proj[i][1]\n        \nnegb = n-posb\n        \nproj = sorted(proj, key = lambda elem: elem[1])\n\nproj_pos = sorted(proj[negb:], key = lambda elem: elem[0])\n\nres = True\n\ni = 0\n\nwhile res and i < posb:\n    if r < proj_pos[i][0]: res = False\n    else:\n        r += proj_pos[i][1]\n        i += 1\n        \nif res:\n    proj_neg = sorted(proj[:negb], key = lambda elem: elem[0]+elem[1], reverse = True)\n    \n    i = 0\n    \n    while res and i < negb and r >= 0:\n        if r < proj_neg[i][0]: res = False\n        else:\n            r += proj_neg[i][1]\n            i += 1\n    \n    if r >= 0 and res: print(\"YES\")\n    else: print(\"NO\")\n    \n    \nelse: print(\"NO\")", "\nn,r = map(int, input().split())\naa = [0]*n\nbb = [0]*n\nfor i in range(n):\n    aa[i], bb[i] = map(int, input().split())\navail = set(range(n))\nfr = r + sum(bb)\nif fr < 0:\n    print(\"NO\")\n    return\nok = True\nfor i in range(n):\n    nxt = -1\n    for j in avail:\n        if aa[j] <= r and bb[j] >= 0:\n            nxt = j\n            break\n    if nxt == -1:\n        break\n    avail.remove(nxt)\n    r += bb[nxt]\nfor i in range(len(avail)):\n    nxt = -1\n    for j in avail:\n        if aa[j]+bb[j] <= fr and bb[j] < 0:\n            nxt = j\n            break\n    if nxt == -1:\n        ok = False\n        break\n    avail.remove(nxt)\n    fr -= bb[nxt]\nif ok:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "'''input\n5 20\n45 -6\n34 -15\n10 34\n1 27\n40 -45\n\n\n'''\nimport sys\nfrom collections import defaultdict as dd\n\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nn, r = ri()\n\neventspos = []\neventsneg = []\nfor i in range(n):\n\ttemp =ri()\n\tif temp[1]>=0:\n\t\teventspos.append(temp)\n\telse:\n\t\teventsneg.append(temp)\n\neventspos.sort()\neventsneg.sort(key = lambda x: x[0]+x[1])\neventsneg.reverse()\n\nstatus =1\n\nans=0 \n\nfor i in range(len(eventspos)):\n\tif eventspos[i][0] <= r:\n\t\tr+= eventspos[i][1]\n\t\tans+=1\n\telse:\n\t\tstatus = 0\n\n\ncheck = [0 for i in range(r+1)]\n\n#print(eventsneg)\n\nfor i in range(len(eventsneg)):\n\tfor j in range(eventsneg[i][0] , r+1):\n\t\tif j+eventsneg[i][1]>=0:\n\t\t\tcheck[j+eventsneg[i][1]] = max(check[j+eventsneg[i][1]] , check[j]+1) \n\n\n\nif max(check)+ ans  == n:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n\n#print(eventsneg,eventspos)\n\n", "n, r = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\npos = []\nneg = []\nfor x in a:\n    if x[1] > 0:\n        pos.append(x)\n    else:\n        neg.append(x)\npos.sort(key=lambda k: k[0])\nflg = 1\nfor x in pos:\n    if r < x[0]:\n        flg = 0\n    else:\n        r += x[1]\nneg.sort(key=lambda k: k[0]+k[1], reverse=True)\nfor x in neg:\n    if r < x[0]:\n        flg = 0\n    else:\n        r += x[1]\n        if r < 0:\n            flg = 0\nif flg == 1:\n    print('YES')\nelse:\n    print('NO')", "import sys\nfrom collections import defaultdict as dd\n \nmod=10**9+7\n \ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n \n \nn, r = ri()\n \neventspos = []\neventsneg = []\nfor i in range(n):\n\ttemp =ri()\n\tif temp[1]>=0:\n\t\teventspos.append(temp)\n\telse:\n\t\teventsneg.append(temp)\n \neventspos.sort()\neventsneg.sort(key = lambda x: x[0]+x[1])\neventsneg.reverse()\n \nstatus =1\n \nans=0 \n \nfor i in range(len(eventspos)):\n\tif eventspos[i][0] <= r:\n\t\tr+= eventspos[i][1]\n\t\tans+=1\n\telse:\n\t\tstatus = 0\n \n \ncheck = [0 for i in range(r+1)]\n \n#print(eventsneg)\n \nfor i in range(len(eventsneg)):\n\tfor j in range(eventsneg[i][0] , r+1):\n\t\tif j+eventsneg[i][1]>=0:\n\t\t\tcheck[j+eventsneg[i][1]] = max(check[j+eventsneg[i][1]] , check[j]+1) \n \n \n \nif max(check)+ ans  == n:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")\n \n#print(eventsneg,eventspos)\n", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport math\n\n#T = int(input())\n#N = int(input())\n#print(N)\nN,r = [int(x) for x in stdin.readline().split()]\n#arr = [int(x) for x in stdin.readline().split()]\n\nvisited = [0]*N\n\na = [0]*N\nb = [0]*N\n\npos = 0\n\nfor i in range(N):\n    arr = [int(x) for x in stdin.readline().split()]\n    a[i] = arr[0]\n    b[i] = arr[1]\n    \n    if b[i]>=0:\n        pos += 1\n\nfor i in range(pos):\n    idx = -1\n    start = 0\n    gain = -50000\n    for j in range(N):\n        # find available and largest gain\n        # if gain tie, find largest start r\n        if visited[j]==1 or b[j]<0:\n            continue\n            \n        if b[j]>gain and r>=a[j]:\n            gain = b[j]\n            idx = j\n            start = a[j]\n        elif b[j]==gain and r>=a[j]:\n            if a[j]>start:\n                idx = j\n                start = a[j]\n                \n    if idx==-1:\n        print('NO')\n        quit()\n    else:\n        visited[idx] = 1\n        r += b[idx]\n        #print(idx,r)\n        \n        \ntmp = []\nfor i in range(N):\n    if visited[i]==1 or b[i]>=0:\n        continue\n    tmp.append((a[i],b[i],i))\n    \ntmp.sort(key=lambda e: (e[0]+e[1],e[0]),reverse=True)\n\nfor i in range(len(tmp)):\n    require = tmp[i][0]\n    bias = tmp[i][1]\n    \n    if r>=require:\n        r += bias\n    else:\n        print('NO')\n        quit()\n        \n\nif r<0:\n    print('NO')\n    quit()\n        \nprint('YES')", "n, r = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\npos = []\nneg = []\nfor x in a:\n    if x[1] > 0:\n        pos.append(x)\n    else:\n        neg.append(x)\npos.sort(key=lambda k: k[0])\nflg = 1\nfor x in pos:\n    if r < x[0]:\n        flg = 0\n    else:\n        r += x[1]\nneg.sort(key=lambda k: k[0]+k[1], reverse=True)\nfor x in neg:\n    if r < x[0] or r<0:\n        flg = 0\n    else:\n        r += x[1]\nif flg == 1 and r>=0:\n    print('YES')\nelse:\n    print('NO')", "n, r = map(int, input().split())\n \npt = []\nnt = []\nr2 = r\nfor _ in range(n):\n    a, b = map(int, input().split())\n    r2 += b\n    if b >= 0:\n        pt.append((a, b))\n    else:\n        nt.append((a, b))\n \nif r2 < 0:\n    print('NO')\n    return\n \npt.sort()\nnt.sort(key=lambda t: t[0]+t[1])\n \nfor a, b in pt:\n    if r<a:\n        print(\"NO\")\n        return\n    r += b\n \nfor a, b in nt:\n    if r2 < a+b:\n        print('NO')\n        return\n    r2 -= b\n \nprint('YES')", "n,r = list(map(int,(input().split())))\n\nplus=[]\nminn=[]\n\nfor i in range (0,n):\n\n    temp = list(map(int,input().split()))\n\n    if temp[1] <=0:\n        temp.append(temp[0]+temp[1])\n        minn.append(temp)\n    else:\n        plus.append(temp)\n\nplus.sort()\nminn.sort(reverse=True,key = lambda x: x[2])\nflag = True\nfor i in plus:\n\n    if i[0] <= r:\n        r+= i[1]\n        #print(r)\n    else:\n        flag=False\n        break\n#print(\"GANTI\")\nif flag:\n    for i in minn:\n        if i[0] <= r:\n            r +=i[1]\n            #print(r)\n        else:\n            flag=False\n            break\n\n\nif flag and r>=0:\n    print(\"YES\")\nelse:\n    print(\"NO\")\n", "n,r=list(map(int,input().split()))\narr1=[]\narr2=[]\nfor i in range(n):\n\tx,y=list(map(int,input().split()))\n\tif(y>=0):\n\t\tarr1.append((x,y))\n\telse:\n\t\tarr2.append((x,y))\n \narr1.sort()\narr2.sort(reverse=True)\ncurrval=r\nflag=0\nfor i in range(len(arr1)):\n\t#print(arr1[i][0],currval)\n\tif(arr1[i][0]>currval):\n\t\tprint(\"NO\")\n\t\treturn\n\telse:\n\t\tcurrval+=arr1[i][1]\ntempval=currval\n \nmark=[0]*len(arr2)\ncountx=0\nfinalans=0\nwhile(countx<len(arr2)):\n\tflag=-1\n\tfor i in range(len(arr2)):\n\t\tif(mark[i]==0 and currval>=arr2[i][0]):\n\t\t\ttempflag=0\n\t\t\tfor j in range(len(arr2)):\n\t\t\t\tif(j!=i and mark[j]==0):\n\t\t\t\t\tif(currval+arr2[i][1]<arr2[j][0]):\n\t\t\t\t\t\ttempflag=1\n\t\t\t\t\t\tbreak\n\t\t\t#print(tempflag)\n\t\t\tif(tempflag==0):\n\t\t\t\tflag=i\n\t\t\t\tbreak\n\tif(flag==-1):\n\t\tfinalans=1\n\t\tbreak\n\telse:\n\t\tcurrval+=arr2[flag][1]\n\t\tmark[flag]=1\n\t\tcountx+=1\nif(currval<0):\n\tfinalans=1\nif(finalans==0):\n\tprint(\"YES\")\nelse:\n\tmark=[0]*len(arr2)\n\tcountx=0\n\tfinalans=0\n\tcurrval=tempval\n\twhile(countx<len(arr2)):\n\t\tflag=-1\n\t\tfor i in range(len(arr2)):\n\t\t\tif(mark[i]==0 and currval>=arr2[i][0]):\n\t\t\t\ttempflag=0\n\t\t\t\tfor j in range(len(arr2)):\n\t\t\t\t\tif(j!=i and mark[j]==0):\n\t\t\t\t\t\tif(currval+arr2[i][1]<arr2[j][0]):\n\t\t\t\t\t\t\ttempflag=1\n\t\t\t\t\t\t\tbreak\n\t\t\t\t#print(tempflag)\n\t\t\t\tif(tempflag==0):\n\t\t\t\t\tflag=i\n\t\t\t\t\t\n\t\tif(flag==-1):\n\t\t\tprint(\"NO\")\n\t\t\treturn\n\t\t\tbreak\n\t\telse:\n\t\t\tcurrval+=arr2[flag][1]\n\t\t\tmark[flag]=1\n\t\t\tcountx+=1\n\tif(currval<0):\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")\n\n", "n,r=list(map(int,input().split()))\narr1=[]\narr2=[]\nfor i in range(n):\n\tx,y=list(map(int,input().split()))\n\tif(y>=0):\n\t\tarr1.append((x,y))\n\telse:\n\t\tarr2.append((x,y))\n \narr1.sort()\narr2.sort(reverse=True)\ncurrval=r\nflag=0\nfor i in range(len(arr1)):\n\t#print(arr1[i][0],currval)\n\tif(arr1[i][0]>currval):\n\t\tprint(\"NO\")\n\t\treturn\n\telse:\n\t\tcurrval+=arr1[i][1]\ntempval=currval\n \nmark=[0]*len(arr2)\ncountx=0\nfinalans=0\nwhile(countx<len(arr2)):\n\tflag=-1\n\tfor i in range(len(arr2)):\n\t\tif(mark[i]==0 and currval>=arr2[i][0]):\n\t\t\ttempflag=0\n\t\t\tfor j in range(len(arr2)):\n\t\t\t\tif(j!=i and mark[j]==0):\n\t\t\t\t\tif(currval+arr2[i][1]<arr2[j][0]):\n\t\t\t\t\t\ttempflag=1\n\t\t\t\t\t\tbreak\n\t\t\t#print(tempflag)\n\t\t\tif(tempflag==0):\n\t\t\t\tflag=i\n\t\t\t\tbreak\n\tif(flag==-1):\n\t\tfinalans=1\n\t\tbreak\n\telse:\n\t\tcurrval+=arr2[flag][1]\n\t\tmark[flag]=1\n\t\tcountx+=1\nif(currval<0):\n\tfinalans=1\nif(finalans==0):\n\tprint(\"YES\")\nelse:\n\tmark=[0]*len(arr2)\n\tcountx=0\n\tfinalans=0\n\tcurrval=tempval\n\twhile(countx<len(arr2)):\n\t\tflag=-1\n\t\tfor i in range(len(arr2)):\n\t\t\tif(mark[i]==0 and currval>=arr2[i][0]):\n\t\t\t\ttempflag=0\n\t\t\t\tfor j in range(len(arr2)):\n\t\t\t\t\tif(j!=i and mark[j]==0):\n\t\t\t\t\t\tif(currval+arr2[i][1]<arr2[j][0]):\n\t\t\t\t\t\t\ttempflag=1\n\t\t\t\t\t\t\tbreak\n\t\t\t\t#print(tempflag)\n\t\t\t\tif(tempflag==0):\n\t\t\t\t\tflag=i\n\t\t\t\t\t\n\t\tif(flag==-1):\n\t\t\tprint(\"NO\")\n\t\t\treturn\n\t\t\tbreak\n\t\telse:\n\t\t\tcurrval+=arr2[flag][1]\n\t\t\tmark[flag]=1\n\t\t\tcountx+=1\n\tif(currval<0):\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")\n\n", "import math\nimport sys\nfrom collections import defaultdict\n#input = sys.stdin.readline\nnt = lambda: list(map(int, input().split()))\n\n\ndef main():\n    n, r = nt()\n    projects = [tuple(nt()) for _ in range(n)]\n    positive = [t for t in projects if t[1] > 0]\n    negative = [t for t in projects if t[1] <= 0]\n\n    ok = True\n    for p in sorted(positive):\n        if p[0] <= r:\n            r += p[1]\n        else:\n            ok = False\n            break\n    if ok:\n        for p in sorted(negative, key=lambda x: -x[0]-x[1]):\n            if p[0] <= r:\n                r += p[1]\n                if r < 0:\n                    ok = False\n                    break\n            else:\n                ok = False\n                break\n\n    print('YES' if ok else 'NO')\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nn,r=list(map(int,input().split()))\nABP,ABN=[],[]\nfor i in range(n):\n  a,b=list(map(int,input().split()))\n  if b>=0:\n    ABP.append([a,b])\n  else:\n    ABN.append([a,b])\nABP.sort(key=lambda x:(x[0],x[1]))\nchk=True\nfor i in range(len(ABP)):\n  if ABP[i][0]>r:\n    chk=False\n  else:\n    r+=ABP[i][1]\nif chk==False:\n  print(\"NO\")\nelse:\n  ABN.sort(key=lambda x:(x[0]+x[1],x[0]),reverse=True)\n  for i in range(len(ABN)):\n    a,b=ABN[i]\n    if r<a:\n      chk=False\n    else:\n      r+=b\n  if chk==False or r<0:\n    print(\"NO\")\n  else:\n    print(\"YES\")\n", "import sys\ninput = sys.stdin.readline\nn,r=list(map(int,input().split()))\nABP,ABN=[],[]\nfor i in range(n):\n  a,b=list(map(int,input().split()))\n  if b>=0:\n    ABP.append([a,b])\n  else:\n    ABN.append([a,b])\nABP.sort(key=lambda x:(x[0],x[1]))\nchk=True\nfor i in range(len(ABP)):\n  if ABP[i][0]>r:\n    chk=False\n  else:\n    r+=ABP[i][1]\nif chk==False:\n  print(\"NO\")\nelse:\n  ABN.sort(key=lambda x:(x[0]+x[1]),reverse=True)\n  for i in range(len(ABN)):\n    a,b=ABN[i]\n    if r<a:\n      chk=False\n    else:\n      r+=b\n  if chk==False or r<0:\n    print(\"NO\")\n  else:\n    print(\"YES\")\n", "n,r=list(map(int,input().split()))\na=[]\nb=[]\nfor _ in range(n):\n    c,d=list(map(int,input().split()))\n    if d<0:\n        b.append([c,d])\n    else:\n        a.append([c,d])\na.sort(key = lambda x: x[0])\nb.sort(key = lambda x: x[0]+x[1],reverse=True)\nz=1\nfor i in a:\n    if i[0]>r:\n        z=0\n        break\n    r+=i[1]\nfor i in b:\n    if i[0]>r:\n        z=0\n        break\n    r+=i[1]\nif z==0 or r<0:\n    print('NO')\nelse:\n    print('YES')\n#print(a,b)\n", "n,r = list(map(int,input().split()))\npl = []\nmi = []\nfor _ in range(n):\n\ta,b = list(map(int,input().split()))\n\tif b >= 0:\n\t\tpl.append((a,b))\n\telse:\n\t\tmi.append((a,b))\npl.sort()\nmi.sort(key=lambda t:t[0]+t[1])\nmi.reverse()\nfor i,j in pl:\n\tif(r < i):\n\t\tprint('NO')\n\t\treturn\n\telse:\n\t\tr += j\nfor i,j in mi:\n\tif(r<i):\n\t\tprint('NO')\n\t\treturn\n\telse:\n\t\tr += j\nif r < 0:\n\tprint('NO')\nelse:\n\tprint('YES')\n", "import sys\ninput = sys.stdin.readline\n\nfrom math import gcd, sqrt\n\nn, r = map(int, input().split())\nl = []\nfor _ in range(n):\n\tl.append(list(map(int, input().split())))\np = 0\nwhile (p < n):\n\tif l[p][0] <= r and l[p][1] >= 0:\n\t\tr += l[p][1]\n\t\tl = l[:p] + l[p + 1:]\n\t\tp = 0\n\t\tn -= 1\n\telse:\n\t\tp += 1\nif l == []:\n\tprint(\"YES\")\n\treturn\nans = True\nq = len(l)\nfor i in range(q):\n\tl[i][0] = max(l[i][0], -l[i][1])\nl = sorted(l, key = lambda x: x[0] + x[1])\nl.reverse()\n#print(l, r)\nfor i in range(len(l)):\n\tif l[i][0] > r:\n\t\tans = False\n\t\tbreak\n\telse:\n\t\tr += l[i][1]\nif ans and r >= 0:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")", "n, r = list(map(int, (input().split())))\n\nproj_list = []\nfor _ in range(n):\n    a, b = list(map(int, input().split()))\n    proj_list.append([b, a, True])\n\ndef check(proj_list):\n    nonlocal r\n\n    while len(proj_list) > 0:\n        i = 0\n        while True:\n            if i == len(proj_list):\n                for prj in proj_list:\n                    if prj[2]:\n                        return False\n                return True\n\n            proj = proj_list[i]\n            if r >= proj[1] and proj[2]:\n                proj[2] = False\n                r += proj[0]\n                if r < 0:\n                    return False\n                break\n            i += 1\n\n\n#proj_list.sort(reverse=True)\nraise_mmr = [x for x in proj_list if x[0] >= 0]\nhard_work = [x for x in proj_list if x[0] < 0]\nproj_list = sorted(raise_mmr, key=lambda x: x[0], reverse=True) + sorted(hard_work, key=lambda x: x[1] + x[0], reverse=True)\n\nprint(\"YES\" if check(proj_list) else \"NO\")\n", "n,r = map(int,input().split())\n\npt = []\nnt = []\nr2 = r \nfor _ in range(n):\n    a,b = map(int,input().split())\n    r2 += b \n    if b >= 0:\n        pt.append((a,b))\n    else:\n        nt.append((a,b))\n\nif r2<0:\n    print('NO');return\n\npt.sort()\nnt.sort(key=lambda t:t[0]+t[1])\n\nfor a,b in pt:\n    if r<a:\n        print('NO');return\n    r += b \n\nfor a,b in nt:\n    if r2 < a+b:\n        print('NO');return\n    r2 -= b \n\nprint(\"YES\")\n", "a,b = map(int,input().split())\nA = []\nB = []\nfor i in range(a):\n    q,w = map(int,input().split())\n    if w<0:\n        q = max(q,-w)\n        B.append([q+w,q,w])\n    else:\n        A.append([q,w])\nA.sort()\nB.sort()\nB.reverse()\nq = True\ni = 0\nw = len(A)\nwhile q == True and i<w:\n    if b>=A[i][0]:\n        b+=A[i][1]\n        i+=1\n    else:\n        q = False\ni = 0\nw = len(B)\nwhile q == True and i<w:\n    if b>=B[i][1]:\n        b+=B[i][2]\n        i+=1\n    else:\n        q = False\nif q == True and b>=0:\n    print('YES')\nelse:\n    print('NO')"]