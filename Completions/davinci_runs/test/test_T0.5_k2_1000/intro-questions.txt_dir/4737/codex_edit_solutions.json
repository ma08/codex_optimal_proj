["\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = map(int, sys.stdin.readline().split())\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        if times[i] + times[p] < 300:\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nmain()\n", "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))  # estimated time to solve each problem (in seconds)\n\n# If the first problem is estimated to take too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems\n    perms = permutations(range(N))\n    # Sort the list by the time it takes to solve the first problem\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem\n            time = 0\n            # Keep track of how many problems we've solved\n            ac = 0\n            # Try to solve each problem\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n", "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time and the penalty time\n    remaining_time = penalty_time = 300\n    # define the problem to solve\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems\n    for problem in range(N):\n        # check if the problem is the problem to solve\n        if problem == problem_to_solve:\n            # check if the problem can be solved\n            if time_est[problem] <= remaining_time:\n                # solve the problem\n                remaining_time -= time_est[problem]\n                num_ac += 1\n                # update the problem to solve\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved\n        elif time_est[problem] <= remaining_time:\n            # solve the problem\n            remaining_time -= time_est[problem]\n            num_ac += 1\n            # update the problem to solve\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = list(map(int, sys.stdin.readline().split()))\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time.\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time.\n    remaining_time = 300\n    # define the problem to solve.\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems.\n    for problem in range(N):\n        # check if the problem is the problem to solve.\n        if problem == problem_to_solve:\n            # check if the problem can be solved.\n            if time_est[problem] <= remaining_time:\n                # solve the problem.\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve.\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved.\n        elif time_est[problem] <= remaining_time:\n            # solve the problem.\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve.\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second problem,\n    # etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    print(N, penalty)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    first_problem_time = times[p]\n    times = times[:p] + times[p + 1:]\n    times.sort()\n    num_ac = 0\n    penalty_time = 0\n    while times:\n        num_ac += 1\n        penalty_time += times[0]\n        times = times[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))  # estimated time\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems.\n    perms = list(permutations(range(N)))\n    # Sort the list by the time it takes to solve the first problem.\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems.\n    max_ac = 0\n    min_time = 0\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it.\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem.\n            time = 0\n            # Keep track of how many problems we've solved.\n            ac = 0\n            # Try to solve each problem.\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it.\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it.\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took.\n            if ac > max_ac:\n                max_ac = ac\n                min_time = time\n    print(max_ac, min_time)\n", "\n\ndef main():\n    \"\"\"\n    1. Read input\n    2. Solve problem\n    3. Output result\n    \"\"\"\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    num_ac, penalty_time = solve(n, p, times)\n    print(\"{} {}\".format(num_ac, penalty_time))\n\ndef solve(n, p, times):\n    \"\"\"\n    Solve problem\n    \"\"\"\n    first_problem_time = times[p]\n    times_left = times[:p] + times[p+1:]\n    times_left.sort()\n    num_ac = 0\n    penalty_time = 0\n    while times_left:\n        num_ac += 1\n        penalty_time += times_left[0]\n        times_left = times_left[1:]\n    return num_ac, penalty_time + first_problem_time\n\n    # max_time = 300\n    # max_num_ac = 0\n    # max_penalty_time = 0\n    # for i in range(2**(n-1)):\n    #     num_ac = 0\n    #     penalty_time = 0\n    #     first_problem_time = times[p]\n    #     times_left = times[:p] + times[p+1:]\n    #     times_left.sort()\n    #     for j in range(n-1):\n    #         if i & (1 << j):\n    #             penalty_time += times_left[j]\n    #             times_left[j] = 0\n    #     for time in times_left:\n    #         if time <= max_time - penalty_time:\n    #             max_time -= penalty_time\n    #             penalty_time += time\n    #             num_ac += 1\n    #     penalty_time += first_problem_time\n    #     if penalty_time <= max_time:\n    #         if num_ac > max_num_ac:\n    #             max_num_ac = num_ac\n    #             max_penalty_time = penalty_time\n    #         elif num_ac == max_num_ac and penalty_time < max_penalty_time:\n    #             max_penalty_time = penalty_time\n    # return max_num_ac, max_penalty_time\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300: # time limit\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\nimport itertools\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(itertools.permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second problem, etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with `start`. Returns a tuple of the number of problems solved and the penalty time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    pass\n\nmain()\n", "\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p-1:] + times[:p-1]\n    max_solved = 0\n    min_penalties = 0\n    remaining = 300 - sum(times[:p-1])\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalties += t\n        else:\n            break\n    print(max_solved, min_penalties)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p-1:] + times[:p-1]\n    max_solved, min_penalty = 0, 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    n, p = [int(x) for x in input().split()]\n    times = [int(x) for x in input().split()]\n    times.sort()\n    if times[p] > 300:\n        print(\"0 0\")\n        return\n    ans = 0\n    for i in range(p, n):\n        if times[i] > 300:\n            break\n        ans += 1\n    print(ans, sum(times[:ans]))\n\nmain()\n", "\n\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))  # estimated time\n\n# If the first problem is estimated to be too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n    # Create a list of all the possible permutations of the problems.\n    perms = list(permutations(range(N)))\n    # Sort the list by the time it takes to solve the first problem.\n    perms = sorted(perms, key=lambda x: est[x[0]])\n    # Find the permutation that solves the most problems.\n    max_ac = 0\n    min_time = 300\n    for perm in perms:\n        # If the first problem is the one we want to solve first, then we can start solving it.\n        if perm[0] == p:\n            # Keep track of the time it takes to solve each problem.\n            time = 0\n            # Keep track of how many problems we've solved.\n            ac = 0\n            # Try to solve each problem.\n            for problem in perm:\n                # If we don't have enough time to solve the problem, then we can't solve it.\n                if time + est[problem] > 300:\n                    break\n                # Otherwise, we can solve it.\n                else:\n                    ac += 1\n                    time += est[problem]\n            # If we solved more problems, then update the number of problems solved and the time it took.\n            if ac > max_ac:\n                max_ac = ac\n                min_time = min(min_time, time)\n    print(max_ac, min_time)\n", "\ndef main():\n    n, p = map(int, input().split())\n    times = list(map(int, input().split()))\n    times = times[p:] + times[:p]\n    max_solved, min_penalty = 0, 0\n    remaining = 300\n    for t in times:\n        if remaining >= t:\n            remaining -= t\n            max_solved += 1\n            min_penalty += t\n        else:\n            break\n    print(max_solved, min_penalty)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300: # time limit\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n            #print(penalty_time)\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    N, p = map(int, sys.stdin.readline().split())\n    times = list(map(int, sys.stdin.readline().split()))\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        if times[i] + times[p] < 300:\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    # print(best)\n    print(best[0], best[1])\n\nmain()\n", "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second problem, etc.\n    # Any other order will be worse.\n    _, penalty = solve(estimations, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with `start`.\n    Returns a tuple of the number of problems solved and the penalty time.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom itertools import permutations\n\ndef solve(problem_list, first_problem_index):\n    problem_list.pop(first_problem_index - 1)\n    permutations_list = list(permutations(problem_list))\n    num_AC = 0\n    penalty_time = 0\n    for permutation in permutations_list:\n        permutation = list(permutation)\n        permutation.insert(0, first_problem_index - 1)\n        time_elapsed = 0\n        AC_count = 0\n        for problem_index in permutation:\n            time_elapsed += problem_list[problem_index]\n            if time_elapsed > 300:\n                break\n            AC_count += 1\n        if AC_count > num_AC:\n            num_AC = AC_count\n            penalty_time = time_elapsed\n        elif AC_count == num_AC:\n            if time_elapsed < penalty_time:\n                penalty_time = time_elapsed\n    return num_AC, penalty_time\n\ndef main():\n    N, p = [int(x) for x in input().split()]\n    problem_list = [int(x) for x in input().split()]\n    num_AC, penalty_time = solve(problem_list, p)\n    print(num_AC, penalty_time)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    N, p = map(int, input().split())\n    times = map(int, input().split())\n    best = [0, 0]\n    for i in range(N):\n        if i == p:\n            continue\n        if times[i] + times[p] < 300:\n            if best[0] == 0:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n            elif times[i] + times[p] < best[1]:\n                best[0] = 2\n                best[1] = times[i] + times[p]\n        else:\n            if best[0] == 0:\n                best[0] = 1\n                best[1] = times[p]\n            elif times[p] < best[1]:\n                best[0] = 1\n                best[1] = times[p]\n    print(best[0], best[1])\n\nif __name__ == '__main__':\n    main()\n", "\nimport fileinput\n\ndef main():\n    lines = fileinput.input()\n    N, p = map(int, lines[0].split())\n    estimations = list(map(int, lines[1].split()))\n\n    # The optimal solution is to solve the first problem, then the second problem,\n    # etc. Any other order will be worse.\n    _, penalty = solve(estimations, 0, 0)\n    if p == 0:\n        print(N, penalty)\n    else:\n        print(0, 0)\n\ndef solve(estimations, start, penalty):\n    \"\"\"\n    Solves the problem of solving `estimations` problems, starting with\n    `start`. Returns a tuple of the number of problems solved and the penalty\n    time. `penalty` is the penalty time of the problems solved so far.\n    \"\"\"\n    N = len(estimations)\n    if start == N:\n        return 0, 0\n\n    # If the first problem is not solvable, then there is no solution.\n    if estimations[start] > 300:\n        return 0, 0\n\n    # Try solving the first problem, and then solving the rest of the problems.\n    num_ac_1, penalty_1 = solve(estimations, start + 1, penalty)\n\n    # Try skipping the first problem, and then solving the rest of the problems.\n    num_ac_2, penalty_2 = solve(estimations, start + 2, penalty)\n\n    # Choose the better of the two.\n    if num_ac_1 + 1 > num_ac_2:\n        return num_ac_1 + 1, penalty_1 + estimations[start]\n    else:\n        return num_ac_2, penalty_2\n\nif __name__ == '__main__':\n    main()\n", "\nfrom sys import stdin\nfrom itertools import permutations\n\nN, p = map(int, stdin.readline().split())\nest = list(map(int, stdin.readline().split()))  # estimated time to solve each problem\n\n# If the first problem is estimated to take too long, then we can't solve any problems\nif est[p] > 300:\n    print(0, 0)\nelse:\n\t# Create a list of all the possible permutations of the problems\n\tperms = permutations(range(N))\n\t# Sort the list by the time it takes to solve the first problem\n\tperms = sorted(perms, key=lambda x: est[x[0]])\n\t# Find the permutation that solves the most problems\n\tmax_ac = 0\n\tmin_time = 0\n\tfor perm in perms:\n\t\t# If the first problem is the one we want to solve first, then we can start solving it\n\t\tif perm[0] == p:\n\t\t\t# Keep track of the time it takes to solve each problem\n\t\t\ttime = 0\n\t\t\t# Keep track of how many problems we've solved\n\t\t\tac = 0\n\t\t\t# Try to solve each problem\n\t\t\tfor problem in perm:\n\t\t\t\t# If we don't have enough time to solve the problem, then we can't solve it\n\t\t\t\tif time + est[problem] > 300:\n\t\t\t\t\tbreak\n\t\t\t\t# Otherwise, we can solve it\n\t\t\t\telse:\n\t\t\t\t\tac += 1\n\t\t\t\t\ttime += est[problem]\n\t\t\t# If we solved more problems, then update the number of problems solved and the time it took\n\t\t\tif ac > max_ac:\n\t\t\t\tmax_ac = ac\n\t\t\t\tmin_time = time\n\tprint(max_ac, min_time)\n", "\n\ndef main():\n    pass\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    \"\"\"\n    This function is the main entry point of the program.\n    \"\"\"\n    # read input\n    N, p = map(int, sys.stdin.readline().split())\n    time_est = map(int, sys.stdin.readline().split())\n    # solve problem\n    num_ac, penalty_time = solve_problem(N, p, time_est)\n    # print output\n    print(num_ac, penalty_time)\n\ndef solve_problem(N, p, time_est):\n    \"\"\"\n    This function solves the problem of finding the optimal number of accepted problems and penalty time\n    given the problem set and the problem to solve first.\n    \"\"\"\n    # define the number of accepted problems and the penalty time.\n    num_ac = 0\n    penalty_time = 0\n    # define the remaining time.\n    remaining_time = 300\n    # define the problem to solve.\n    problem_to_solve = (p + 1) % N\n    # iterate over all problems.\n    for problem in range(N):\n        # check if the problem is the problem to solve.\n        if problem == problem_to_solve:\n            # check if the problem can be solved.\n            if time_est[problem] <= remaining_time:\n                # solve the problem.\n                remaining_time -= time_est[problem]\n                penalty_time += time_est[problem]\n                num_ac += 1\n                # update the problem to solve.\n                problem_to_solve = (problem_to_solve + 1) % N\n        # check if the problem can be solved.\n        elif time_est[problem] <= remaining_time:\n            # solve the problem.\n            remaining_time -= time_est[problem]\n            penalty_time += remaining_time\n            num_ac += 1\n            # update the problem to solve.\n            problem_to_solve = (problem_to_solve + 1) % N\n    return num_ac, penalty_time\n\nif __name__ == \"__main__\":\n    main()\n"]