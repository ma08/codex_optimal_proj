["\n\ndef next_permutation(a):\n    # Read input\n    i = len(a) - 1\n\n        j = len(a) - 1\n        while a[j] <= a[i - 1]:\n            j -= 1\n        a[i - 1], a[j] = a[j], a[i - 1]\n\n        a[i:] = reversed(a[i:])\n        return True\n\ndef main():\n    # Read input\n    x = input()\n\n    # Convert to int array\n    x_arr = [int(c) for c in str(x)]\n\n    # Find next permutation\n    if next_permutation(x_arr):\n        print(int(''.join(map(str, x_arr))))\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()\n", "\nx = input()\n\ndef next_permutation(a):\n    i = len(a) - 1\n    while i > 0 and a[i - 1] >= a[i]:\n        i -= 1\n    if i <= 0:\n        return False\n    j = len(a) - 1\n    while a[j] <= a[i - 1]:\n        j -= 1\n    a[i - 1], a[j] = a[j], a[i - 1]\n    a[i:] = a[len(a) - 1:i - 1:-1]\n    return True\n\nif next_permutation(list(x)):\n    print(''.join(list(x)))\nelse:\n    print(0)\n", "\n\ndef next_permutation(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\n    for k in range(len(nums) - 2, -1, -1):\n        if nums[k] < nums[k + 1]:\n            break\n    else:\n        nums.reverse()\n        return\n\n    # Find the largest index l greater than k such that a[k] < a[l].\n    for l in range(len(nums) - 1, k, -1):\n        if nums[k] < nums[l]:\n            break\n\n    # Swap the value of a[k] with that of a[l].\n    nums[k], nums[l] = nums[l], nums[k]\n\n    # Reverse the sequence from a[k + 1] up to and including the final element a[n].\n    nums[k + 1:] = nums[:k:-1]\n\n\ndef main():\n    num = input()\n    num = [int(i) for i in num]\n    if next_permutation(num):\n\n        print(\"\".join([str(i) for i in num]))\n    else:\n        print(\"0\")\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef next_permutation(a): #\uc21c\uc5f4\uc744 \ub2e4\uc74c\uc73c\ub85c \ubc14\uafb8\ub294 \ud568\uc218\n    i = len(a) - 1\n    while i > 0 and a[i - 1] >= a[i]:\n        i -= 1\n    if i <= 0:\n        return False\n    j = len(a) - 1\n    while a[j] <= a[i - 1]:\n        j -= 1\n    a[i - 1], a[j] = a[j], a[i - 1]\n    a[i : ] = a[len(a) - 1 : i - 1 : -1]\n    return True\n\nif next_permutation(list(x)):\n    print(''.join(list(x)))\nelse:\n    print(0)\n", "\n\ndef next_permutation(a):  # \u6b21\u306e\u9806\u5217\u3092\u751f\u6210\u3059\u308b\n    n = len(a)\n    i = n - 1\n    while i > 0 and a[i - 1] >= a[i]:  # \u5f8c\u308d\u304b\u3089\u898b\u3066\u3044\u3063\u3066\u3001\u9006\u9806\u306b\u306a\u3063\u3066\u3044\u308b\u3068\u3053\u308d\u3092\u63a2\u3059\n        i -= 1\n    if i <= 0:\n        return False\n    j = n - 1\n    while a[j] <= a[i - 1]:  # \u5f8c\u308d\u304b\u3089\u898b\u3066\u3044\u3063\u3066\u3001a[i-1]\u3088\u308a\u5927\u304d\u3044\u6570\u5b57\u3092\u63a2\u3059\n        j -= 1\n    a[i - 1], a[j] = a[j], a[i - 1]  # \u305d\u306e\u6570\u5b57\u3068a[i-1]\u3092\u5165\u308c\u66ff\u3048\u308b\n    a[i:] = reversed(a[i:])  # \u305d\u308c\u4ee5\u964d\u3092\u9006\u9806\u306b\u3059\u308b\n\n    return True\n\ndef main():\n    s = input()\n    a = [int(x) for x in s]\n    if next_permutation(a):\n        print(''.join([str(x) for x in a]))\n    else:\n        print(0)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef next_permutation(a):  # \u6b21\u306e\u9806\u5217\u3092\u751f\u6210\u3059\u308b\n    n = len(a)\n    i = n - 1\n    while i > 0 and a[i-1] >= a[i]:  # \u5f8c\u308d\u304b\u3089\u898b\u3066\u3044\u3063\u3066\u3001\u9006\u9806\u306b\u306a\u3063\u3066\u3044\u308b\u3068\u3053\u308d\u3092\u63a2\u3059\n        i -= 1\n    if i <= 0:\n        return False\n    j = n - 1\n    while a[j] <= a[i-1]:  # \u5f8c\u308d\u304b\u3089\u898b\u3066\u3044\u3063\u3066\u3001a[i-1]\u3088\u308a\u5927\u304d\u3044\u6570\u5b57\u3092\u63a2\u3059\n        j -= 1\n    a[i-1], a[j] = a[j], a[i-1]  # \u305d\u306e\u6570\u5b57\u3068a[i-1]\u3092\u5165\u308c\u66ff\u3048\u308b\n    a[i:] = reversed(a[i:])  # \u305d\u308c\u4ee5\u964d\u3092\u9006\u9806\u306b\u3059\u308b\n    return True\n\ndef main():\n    s = input()\n    a = [int(x) for x in s]\n    if next_permutation(a):\n        print(''.join([str(x) for x in a]))\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef next_permutation(arr):\n    i = len(arr) - 1\n    while i > 0 and arr[i - 1] >= arr[i]:\n        i = i - 1\n    if i == 0:\n        return False \n\n    j = len(arr) - 1\n    while arr[j] <= arr[i - 1]:\n        j = j - 1\n    arr[i - 1], arr[j] = arr[j], arr[i - 1]\n\n    arr[i:] = reversed(arr[i:])\n    return True\n\ndef main():\n    # Read input\n    x = input(\"Enter a number: \")\n\n    # Convert to int array\n    x_arr = [int(c) for c in str(x)]\n\n    # Find next permutation\n    if next_permutation(x_arr):\n        print(int(''.join(map(str, x_arr)))) #convert list to string\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef next_permutation(arr):\n    i = len(arr) - 1\n    while i > 0 and arr[i - 1] >= arr[i]:\n        i = i - 1\n    if i == 0:\n        return False\n\n    j = len(arr) - 1\n    while arr[j] <= arr[i - 1]:\n        j = j - 1\n    arr[i - 1], arr[j] = arr[j], arr[i - 1]\n\n    arr[i:] = reversed(arr[i:])\n    return True\n\ndef main():\n    # Read input\n    x = input()\n\n    # Convert to int array\n    x_arr = [int(c) for c in x]\n\n    # Find next permutation\n    if next_permutation(x_arr):\n        print(''.join(map(str, x_arr)))\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main() \n", "\n\n#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n# Complete the climbingLeaderboard function below.\ndef climbingLeaderboard(scores, alice):\n    scores = sorted(set(scores), reverse=True)\n    index = 0\n    rank_list = []\n    n = len(scores)\n    for i in alice:\n        while (n > index and i >= scores[index]):\n            index += 1\n        rank_list.append(n+1-index)\n    return rank_list\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    scores_count = int(input())\n\n    scores = list(map(int, input().rstrip().split()))\n\n    alice_count = int(input())\n\n    alice = list(map(int, input().rstrip().split()))\n\n    result = climbingLeaderboard(scores, alice)\n\n    fptr.write('\\n'.join(map(str, result)))\n    fptr.write('\\n')\n\n    fptr.close()\n", "\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Feb  2 18:34:27 2019\n@author: nidhi\n\"\"\"\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import accuracy_score\ndata=pd.read_csv('/Users/nidhi/Desktop/knn/diabetes.csv')\ndata.head()\ndata.info()\ndata.describe()\ndata.isnull().sum()\ndata.corr()\nsns.heatmap(data.corr(),annot=True)\nsns.pairplot(data)\nsns.countplot(x='Outcome',data=data)\nsns.countplot(x='Pregnancies',data=data)\nsns.countplot(x='Glucose',data=data)\nsns.countplot(x='BloodPressure',data=data)\nsns.countplot(x='SkinThickness',data=data)\nsns.countplot(x='Insulin',data=data)\nsns.countplot(x='BMI',data=data)\nsns.countplot(x='DiabetesPedigreeFunction',data=data)\nsns.countplot(x='Age',data=data)\nx=data.iloc[:,0:8]\ny=data.iloc[:,8]\nx_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=0)\nsc=StandardScaler()\nx_train=sc.fit_transform(x_train)\nx_test=sc.transform(x_test)\nclassifier=KNeighborsClassifier(n_neighbors=11,p=2,metric='euclidean')\nclassifier.fit(x_train,y_train)\ny_pred=classifier.predict(x_test)\ncm=confusion_matrix(y_test,y_pred)\nprint(cm)\nprint(f1_score(y_test,y_pred))\nprint(accuracy_score(y_test,y_pred))\n", "\n\ndef next_permutation(a)\n    n = a.length\n    i = n - 1\n    while i > 0 and a[i-1] >= a[i]:\n        i -= 1\n    if i <= 0:\n        return False\n    j = n - 1\n    while a[j] <= a[i-1]:\n        j -= 1\n    a[i-1], a[j] = a[j], a[i-1]\n    a[i:] = a[i:].reverse()\n    return True\n\ndef main():\n    s = input()\n    a = [int(x) for x in s]\n    if next_permutation(a):\n        print(''.join([str(x) for x in a]))\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n# this is a test\nimport sys\n\ndef main():\n    print('hello world')\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    # Read input\n    x = input()\n\n    j = len(x) - 1\n    while x[j] <= x[i - 1]:\n        j -= 1\n    x[i - 1], x[j] = x[j], x[i - 1]\n\n    x[i:] = reversed(x[i:])\n    return True\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom __future__ import print_function\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    line = sys.stdin.readline()\n    x = int(line)\n    digits = list(line.strip())\n    digit_counts = defaultdict(int)\n    for digit in digits:\n        digit_counts[digit] += 1\n\n    # find the first digit that is smaller than the digit to its right\n    for i, digit in enumerate(digits[:-1]):\n        if digit < digits[i+1]:\n            # find the smallest digit that is larger than the digit to its left\n            smallest_digit = digits[i+1]\n            smallest_digit_index = i+1\n            for j in range(i+2, len(digits)):\n                if digits[j] < smallest_digit and digits[j] > digit:\n                    smallest_digit = digits[j]\n                    smallest_digit_index = j\n\n            # swap the two digits\n            digits[i], digits[smallest_digit_index] = digits[smallest_digit_index], digits[i]\n            break\n\n    # sort the digits to the right of the swapped digit in ascending order\n    digits[i+1:] = sorted(digits[i+1:])\n\n    # if the number is unchanged, then there is no next smallest number\n    if x == int(''.join(digits)):\n        print(0)\n    else:\n        print(''.join(digits))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\ndef next_permutation(arr): \n    # Find non-increasing suffix \n    i = len(arr) - 1\n    while i > 0 and arr[i - 1] >= arr[i]: \n        i -= 1\n    if i <= 0:\n        return False\n    \n    # Find successor to pivot\n    j = len(arr) - 1\n    while arr[j] <= arr[i - 1]:\n        j -= 1\n    arr[i - 1], arr[j] = arr[j], arr[i - 1]\n    \n    # Reverse suffix\n    arr[i : ] = arr[len(arr) - 1 : i - 1 : -1]\n    return True\n\ndef main():\n    num = input().strip()\n    num = [int(i) for i in num]\n    if next_permutation(num):\n        print(\"\".join([str(i) for i in num]))\n    else:\n        print(\"0\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    num = sys.stdin.readline().strip()\n    num = list(num)\n    for i in range(len(num) - 1, 0, -1):\n        if num[i] > num[i - 1]:\n            break\n    else:\n        print(0)\n        return\n    for j in range(len(num) - 1, i - 1, -1):\n        if num[j] > num[i - 1]:\n            break\n    num[i - 1], num[j] = num[j], num[i - 1]\n    num[i:] = sorted(num[i:])\n    print(''.join(num))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef main():\n    X = int(sys.stdin.readline())\n    digits = []\n    while X > 0:\n        digits.append(X % 10)\n        X = math.floor(X / 10)\n    digits.reverse()\n    for i in range(len(digits) - 1):\n        if digits[i] > digits[i + 1]:\n            digits[i], digits[i + 1] = digits[i + 1], digits[i]\n            break\n    else:\n        print(0)\n        return\n    for j in range(i + 1):\n        for k in range(j + 1, len(digits) - 1):\n            if digits[j] > digits[k + 1]:\n                digits[j], digits[k + 1] = digits[k + 1], digits[j]\n    result = 0\n    for i in range(len(digits)):\n        result += digits[i] * 10 ** i\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef next_largest(x):\n    # Start with the largest number that can be formed using the digits of x\n    n = 10 ** (len(str(x)) - 1)\n\n    # Find the largest number that can be formed using the digits of x\n    for i in range(9, 0, -1):\n        if str(i) in str(x):\n            n += i * 10 ** (len(str(x)) - str(x).index(str(i)) - 1)\n            break\n\n    # Find the next largest number using the same digits\n    for i in range(9, 0, -1):\n        if str(i) in str(n):\n            n += i * 10 ** (len(str(x)) - str(n).index(str(i)) - 1)\n            break\n\n    # If the number is larger than x, print it. Otherwise, print 0.\n    if n > x:\n        print(n)\n    else:\n        print(0)\n\n\nnext_largest(int(input()))\n", "\n\nimport sys\nimport math\n\ndef main():\n    X = int(sys.stdin.readline())\n    digits = []\n    while X > 0:\n        digits.append(X % 10)\n        X = math.floor(X / 10)\n    digits.reverse()\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] > digits[i + 1]:\n            digits[i], digits[i + 1] = digits[i + 1], digits[i]\n            for j in range(i):\n                for k in range(j + 1, len(digits)):\n                    if digits[j] > digits[k]:\n                        digits[j], digits[k] = digits[k], digits[j]\n            result = 0\n            for i in range(len(digits)):\n                result += digits[i] * 10 ** i\n            print(result)\n            return\n    else:\n        print(0)\n        return\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef next_permutation(arr): \n    # Find non-increasing suffix \n    i = len(arr) - 1\n    while i > 0 and arr[i - 1] >= arr[i]: \n        i -= 1\n    if i <= 0:\n        return False\n    \n    # Find successor to pivot\n    j = len(arr) - 1\n    while arr[j] <= arr[i - 1]:\n        j -= 1\n    arr[i - 1], arr[j] = arr[j], arr[i - 1]\n    \n    # Reverse suffix\n    arr[i : ] = arr[len(arr) - 1 : i - 1 : -1]\n    return True\n\ndef main():\n    num = input().strip()\n    num = [int(i) for i in num]\n    if next_permutation(num):\n        print(\"\".join([str(i) for i in num]))\n    else:\n        print(\"0\")\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nimport math\n\ndef main():\n    X = int(sys.stdin.readline())\n    digits = []\n    while X > 0:\n        digits.append(X % 10)\n        X = math.floor(X / 10)\n    digits.reverse()\n    for i in range(len(digits) - 1):\n        if digits[i] > digits[i + 1]:\n            digits[i], digits[i + 1] = digits[i + 1], digits[i]\n            break\n    else:\n        print(0)\n        return\n    for j in range(i):\n        for k in range(j + 1, len(digits)):\n            if digits[j] > digits[k]:\n                digits[j], digits[k] = digits[k], digits[j]\n    result = 0\n    for i in range(len(digits)):\n        result += digits[i] * 10 ** i\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    X = int(sys.stdin.readline())\n    digits = []\n    while X > 0:\n        digits.append(X % 10)\n        X = math.floor(X / 10)\n    digits.reverse()\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] > digits[i + 1]:\n            digits[i], digits[i + 1] = digits[i + 1], digits[i]\n            for j in range(i):\n                for k in range(j + 1, len(digits)):\n                    if digits[j] > digits[k]:\n                        digits[j], digits[k] = digits[k], digits[j]\n            result = 0\n            for l in range(len(digits)):\n                result += digits[l] * 10 ** l\n            print(result)\n            return\n    else:\n        print(0)\n        return\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef next_permutation(a)\n    n = len(a) # get the length of the array\n    i = n - 1\n    while i > 0 and a[i-1] >= a[i]: # find the first index where a[i-1] < a[i]\n        i -= 1\n    if i <= 0: # if not found, then the array is in descending order\n        return False\n    j = n - 1\n    while a[j] <= a[i-1]: # find the last index where a[j] > a[i-1]\n        j -= 1\n    a[i-1], a[j] = a[j], a[i-1] # swap a[i-1] and a[j]\n    a[i:] = reversed(a[i:]) # reverse the array from a[i] to the end\n    return True\n\ndef main():\n    s = input()\n    a = [int(x) for x in s]\n    if next_permutation(a):\n        print(''.join([str(x) for x in a]))\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\n\ndef main():\n    x = sys.stdin.readline().strip()\n    x = list(x)\n    for i in range(len(x) - 1, 0, -1):\n        if x[i] > x[i - 1]:\n            break\n    else:\n        print(0)\n        return\n    for j in range(len(x) - 1, i - 1, -1):\n        if x[j] > x[i - 1]:\n            break\n    x[i - 1], x[j] = x[j], x[i - 1]\n    x[i:] = sorted(x[i:])\n    print(''.join(x))\n\nif __name__ == '__main__':\n    main()\n", "\n\nx = input()\n\ndef next_permutation(a):\n    i = len(a) - 1\n    while i > 0 and a[i - 1] >= a[i]:\n        i -= 1\n    if i <= 0:\n        return False\n    j = len(a) - 1\n    while a[j] <= a[i - 1]:\n        j -= 1\n    a[i - 1], a[j] = a[j], a[i - 1]\n    a[i : ] = a[len(a) - 1 : i - 1 : -1]\n    return True\n\nif next_permutation(list(x)):\n    print(''.join(list(x)))\nelse:\n    print(0)\n", "\n\ndef next_permutation(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\n    for k in range(len(nums)-2, -1, -1):\n        if nums[k] < nums[k+1]:\n            break\n    else:\n        nums.reverse()\n        return \n\n    # Find the largest index l greater than k such that a[k] < a[l].\n    for l in range(len(nums)-1, k, -1):\n        if nums[k] < nums[l]:\n            break\n\n    # Swap the value of a[k] with that of a[l].\n    nums[k], nums[l] = nums[l], nums[k]\n\n    # Reverse the sequence from a[k + 1] up to and including the final element a[n].\n    nums[k+1:] = nums[:k:-1]\n\n\ndef main():\n    num = [1, 2, 3]\n    next_permutation(num)\n    print(num)\n\nif __name__ == \"__main__\":\n    main()\n"]