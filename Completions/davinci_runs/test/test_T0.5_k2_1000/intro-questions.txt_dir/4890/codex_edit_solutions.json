["\nimport itertools\n\ndef solve(n, m, s, d, c):\n    if n < m:\n        return \"impossible\"\n    n_slots = list(itertools.combinations(range(s), m)) # combinations of slots with m elements\n    n_new = list(itertools.combinations(range(n), m)) # combinations of new students with m elements\n    max_p = 0\n    max_p_scheme = []\n    for slots in n_slots:\n        for new in n_new:\n            p = 1\n            for i in range(m):\n                p *= (c[slots[i]] + new[i]) / d\n            if p > max_p:\n                max_p = p\n                max_p_scheme = [0] * s\n                for i in range(m):\n                    max_p_scheme[slots[i]] += new[i]\n    return \" \".join(map(str, max_p_scheme))\n\ndef main():\n    n, m, s, d = map(int, input().split(\" \"))\n    c = list(map(int, input().split(\" \")))\n    print(solve(n, m, s, d, c))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef is_possible(bottles, slots, students, capacity, new_bottles):  # check if it is possible to distribute bottles among students\n    for i in range(len(slots)):\n        slots[i] += new_bottles[i]\n    for j in range(students):\n        if sum(slots) == 0:\n            return False\n        for i in range(len(slots)):\n            if slots[i] > 0:\n                slots[i] -= 1\n                break\n    return True\n\ndef refill(bottles, slots, students, capacity, new_bottles):\n    while not is_possible(bottles, slots, students, capacity, new_bottles):\n        new_bottles[-1] -= 1\n        new_bottles[-2] += 1\n        if new_bottles[-1] == 0:\n            new_bottles[-1] = new_bottles[-2]\n            new_bottles[-2] = 0\n            if new_bottles[-2] == 0:\n                new_bottles[-2] = new_bottles[-3]\n                new_bottles[-3] = 0\n                if new_bottles[-3] == 0:\n                    new_bottles[-3] = new_bottles[-4]\n                    new_bottles[-4] = 0\n    return new_bottles\n\ndef main():\n    new_bottles, students, capacity = map(int, input().split())\n    bottles = list(map(int, input().split()))\n    new_bottles = list(map(int, input().split()))\n    slots = [capacity] * len(bottles)\n    if is_possible(bottles, slots, students, capacity, new_bottles):\n        print(*refill(bottles, slots, students, capacity, new_bottles))\n    else:\n        print(\"impossible\")\n\nif __name__ == '__main__':\n    main()\n", "\n\nn, m, s, d = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\n\n# First, we check if it is possible, i.e.\n# all the slots are full, and the number of\n# cold sodas is less than the number of students\n# that need to be served.\nif sum(c) < m:\n    print(\"impossible\")\n    exit()\n\n# We need to find a way to maximize the probability\n# that the next m students receive a cold soda.\n# We can do this by minimizing the probability that\n# a student receives a hot soda.\n#\n# We can calculate the probability of receiving a\n# hot soda by dividing the number of hot sodas by\n# the total number of sodas.\n#\n# We can minimize this probability by making the\n# number of hot sodas as small as possible, while\n# making the number of total sodas as large as possible.\n#\n# Suppose we have the following fridge:\n# [0, 1, 4]\n# If we put the new sodas in slot 0, then the\n# probability of receiving a hot soda is 5/9.\n# If we put the new sodas in slot 1, then the\n# probability of receiving a hot soda is 4/8.\n# If we put the new sodas in slot 2, then the\n# probability of receiving a hot soda is 1/5.\n#\n# We can see that the best place to put the new sodas\n# is in slot 2, since it has the minimum probability\n# of receiving a hot soda.\n#\n# In general, we can see that the best place to put the\n# new sodas is in the slot that has the minimum number\n# of hot sodas, and is not full.\n#\n# We can calculate the number of hot sodas in a slot\n# by taking the difference between the number of sodas\n# in the slot, and the number of cold sodas in the slot.\n#\n# We can calculate the number of total sodas in a slot\n# by taking the sum of the number of cold sodas in the slot,\n# and the number of new sodas in the slot.\n#\n# When we place the new sodas in a slot, we need to make\n# sure that there are still enough new sodas left to fill\n# the other slots.\n#\n# We can do this by checking that the number of new sodas\n# that we want to place in a slot is less than or equal\n# to the number of new sodas left to place.\n\n# First, we initialize the number of new sodas left to place as the number of new sodas\nnew_sodas_left = n\n\n# We also initialize the number of hot sodas in a slot as the difference between the number of sodas in a slot, and the number of cold sodas in a slot.\nhot_sodas_in_slot = [d - c[i] for i in range(s)]\n\n# We also initialize the number of total sodas in a slot as the sum of the number of cold sodas in a slot, and the number of new sodas in a slot.\ntotal_sodas_in_slot = [c[i] for i in range(s)]\n\n# We also initialize the number of new sodas to place in a slot as 0.\nnew_sodas_in_slot = [0 for i in range(s)]\n\n# We will put the new sodas in the slots in ascending order of the number of hot sodas in the slot, so we sort the list of hot sodas in the slot.\nhot_sodas_in_slot, total_sodas_in_slot, new_sodas_in_slot = zip(*sorted(zip(hot_sodas_in_slot, total_sodas_in_slot, new_sodas_in_slot)))\n\n# Next, we iterate over the slots in ascending order\n# of the number of hot sodas in the slot.\nfor i in range(s):\n    # We check if the slot is not full\n    if c[i] < d:\n        # We check if there are enough new sodas left to fill\n        # the slot.\n        if new_sodas_left >= d - c[i]:\n            # If there are enough new sodas left to fill the slot,\n            # we set the number of new sodas in the slot as the\n            # difference between the capacity of the slot, and the\n            # number of sodas in the slot.\n            new_sodas_in_slot[i] = d - c[i]\n            # We also update the number of new sodas left to place.\n            new_sodas_left -= new_sodas_in_slot[i]\n            # We also update the number of hot sodas in the slot.\n            hot_sodas_in_slot[i] = 0\n            # We also update the number of total sodas in the slot.\n            total_sodas_in_slot[i] = d\n        else:\n            # If there are not enough new sodas left to fill the slot,\n            # we set the number of new sodas in the slot as the number\n            # of new sodas left to place.\n            new_sodas_in_slot[i] = new_sodas_left\n            # We also update the number of new sodas left to place.\n            new_sodas_left = 0\n            # We also update the number of hot sodas in the slot.\n            hot_sodas_in_slot[i] = hot_sodas_in_slot[i] - new_sodas_in_slot[i]\n            # We also update the number of total sodas in the slot.\n            total_sodas_in_slot[i] = total_sodas_in_slot[i] + new_sodas_in_slot[i]\n\n# We sort the number of new sodas in the slot in descending order\n# so that the new sodas are added to the fridge in the correct order.\nnew_sodas_in_slot = list(reversed(new_sodas_in_slot))\n\n# We print the number of new sodas in the slot\nprint(*new_sodas_in_slot)\n", "\nimport sys\nimport random\n\ndef solve(n, m, s, d, c):\n    return None\n\nlines = sys.stdin.readlines()\nn, m, s, d = [int(x) for x in lines[0].split()]\nc = [int(x) for x in lines[1].split()]\n\nres = solve(n, m, s, d, c)\nif res is None:\n    print(\"impossible\")\nelse:\n    print(\" \".join([str(x) for x in res]))\n", "\nimport itertools\n\ndef solve(n, m, s, d, c):\n    if n < m:\n        return \"impossible\"\n    n_slots = list(itertools.combinations(range(s), m)) # all possible combinations of slots, each combination is a tuple\n    n_new = list(itertools.combinations(range(n), m)) # all possible combinations of new, each combination is a tuple\n    max_p = 0\n    max_p_scheme = [] # scheme with max probability, list of ints\n    for slots in n_slots:\n        for new in n_new:\n            p = 1\n            for i in range(m):\n                p *= (c[slots[i]] + new[i]) / d\n            if p > max_p:\n                max_p = p\n                max_p_scheme = [0]*s # reset\n                for i in range(m):\n                    max_p_scheme[slots[i]] += new[i] # add new to slots, slots[i] is an int\n    return \" \".join(map(str, max_p_scheme))\n\ndef main():\n    n, m, s, d = map(int, input().split(\" \"))\n    c = list(map(int, input().split(\" \")))\n    print(solve(n, m, s, d, c))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    input_line = input().split()\n    n, m, s, d = map(int, input_line)\n\n    input_line = input().split()\n    c = list(map(int, input_line))\n\n    # print(n)\n    # print(m)\n    # print(s)\n    # print(d)\n    # print(c)\n\n    #Calculate the total number of sodas in the fridge.\n    total_sodas = 0\n    for i in range(s):\n        total_sodas += c[i]\n\n    # print(total_sodas)\n\n    #Calculate the number of sodas needed to fill the fridge.\n    sodas_needed = 0\n    for i in range(s):\n        sodas_needed += d - c[i]\n\n    # print(sodas_needed)\n\n    #If the number of sodas needed is greater than the number of sodas available, then it is impossible to fill the fridge.\n    if sodas_needed > n:\n        print(\"impossible\")\n        return\n\n    #Calculate the number of sodas to put in each slot\n    sodas_in_each_slot = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot[i] = min(d - c[i], n)\n        n -= min(d - c[i], n)\n\n    # print(sodas_in_each_slot)\n\n    #Calculate the number of sodas in each slot after the m students have taken sodas\n    sodas_in_each_slot_after_m = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot_after_m[i] = max(c[i] - m, 0)\n\n    # print(sodas_in_each_slot_after_m)\n\n    #Calculate the number of cold sodas that the m students will get\n    cold_sodas_m = 0\n    for i in range(s):\n        cold_sodas_m += sodas_in_each_slot_after_m[i]\n\n    # print(cold_sodas_m)\n\n    #If the number of cold sodas that the m students get is less than m, then it is impossible for all m students to get cold sodas\n    if cold_sodas_m < m:\n        print(\"impossible\")\n        return\n\n    #Calculate the number of sodas in each slot after the n + m students have taken sodas\n    sodas_in_each_slot_after_n_m = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot_after_n_m[i] = max(c[i] - m + sodas_in_each_slot[i], 0)\n\n    # print(sodas_in_each_slot_after_n_m)\n\n    #Calculate the number of cold sodas that the n + m students will get\n    cold_sodas_n_m = 0\n    for i in range(s):\n        cold_sodas_n_m += sodas_in_each_slot_after_n_m[i]\n\n    # print(cold_sodas_n_m)\n\n    #Calculate the probability that all m students will get a cold soda\n    prob = cold_sodas_m / total_sodas\n\n    # print(prob)\n\n    #Calculate the probability that all n + m students will get a cold soda\n    prob2 = cold_sodas_n_m / (total_sodas + n)\n\n    # print(prob2)\n\n    #Calculate the probability that all m students will get a cold soda after the new sodas are added\n    prob3 = prob2 / (1 - prob)\n\n    # print(prob3)\n\n    #Print the output\n    for i in range(s):\n        print(sodas_in_each_slot[i], end = \" \")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    \"\"\"\n    This function is used to run the program.\n\n    Returns:\n        None\n    \"\"\"\n    # Read input\n    n, m, s, d = [int(i) for i in input().split()]\n    c = [int(i) for i in input().split()]\n\n    # Calculate the number of cold drinks in the fridge\n    cold_drinks_in_fridge = sum(c)\n\n    # If there are more cold drinks in the fridge than the number of students, then output the empty array\n    if cold_drinks_in_fridge >= n:\n        print(' '.join([str(0) for i in range(s)]))\n        return\n\n    # Calculate the number of empty slots\n    empty_slots = s - len(c)\n\n    # Calculate the number of drinks to add to the front of the fridge, which is the minimum of the number of drinks\n    # in the fridge and the number of students, and the number of empty slots\n    drinks_to_add = min(n, m - cold_drinks_in_fridge, empty_slots)\n\n    # If there are more empty slots than drinks to add, then output the drinks to add in each slot\n    if empty_slots >= drinks_to_add:\n        print(' '.join([str(1) if i < drinks_to_add else str(0) for i in range(s)]))\n        return\n\n    # Calculate the number of drinks to add to the back of the fridge\n    drinks_to_add = max(0, drinks_to_add - empty_slots)\n\n    # Calculate the number of drinks to add to each slot\n    drinks_to_add_per_slot = [0 for i in range(s)]\n    for i in range(s):\n        if c[i] < d:\n            drinks_to_add_per_slot[i] = min(d - c[i], drinks_to_add)\n            drinks_to_add -= drinks_to_add_per_slot[i]\n\n    # If there are still drinks to add, then output \"impossible\"\n    if drinks_to_add > 0:\n        print(\"impossible\")\n        return\n\n    # Output the drinks to add in each slot\n    print(' '.join([str(i) for i in drinks_to_add_per_slot]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef solve(n, m, s, d, c):\n    if sum(c) + n < m:\n        return \"impossible\"\n\n    # create a list of tuples (c, d) representing the capacities of each slot\n    slots = list(zip(c, [d]*s))\n    # sort the list of slots by capacity, descending\n    slots = sorted(slots, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c, d) representing the number of bottles to add to each slot\n    add = [(0,0)]*s\n\n    # add bottles to the slots with the most free space\n    for i in range(n):\n        # find the slot with the most free space\n        slot = max(slots, key=lambda x: x[1]-x[0])\n        # add a bottle to the slot\n        add[slots.index(slot)] = (add[slots.index(slot)][0]+1, add[slots.index(slot)][1])\n        # update the slot's capacity\n        slot = (slot[0]+1, slot[1])\n        slots[slots.index(slot)] = slot\n\n    # sort the list of bottles to add to each slot by the number of bottles in each slot, descending\n    add = sorted(add, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c, d) representing the updated capacities of each slot\n    slots = [(x[0]+y[0], x[1]) for x, y in zip(c, add)]\n    # sort the list of slots by capacity, descending\n    slots = sorted(slots, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c, d) representing the probability of getting a cold bottle from each slot\n    p = [(x[0]/float(x[1]), x[1]) for x in slots]\n    # sort the list of probabilities by probability, descending\n    p = sorted(p, key=lambda x: x[0], reverse=True)\n\n    # calculate the probability that the next m students get a cold bottle\n    prob = 1.0\n    for i in range(m):\n        prob *= p[i][0]\n\n    # if the probability is 0, return \"impossible\"\n    if prob == 0:\n        return \"impossible\"\n\n    # otherwise, return the list of bottles to add to each slot\n    return [x[0] for x in add]\n\nif __name__ == \"__main__\":\n    n, m, s, d = map(int, raw_input().split())\n    c = list(map(int, raw_input().split()))\n    print \" \".join(map(str, solve(n, m, s, d, c)))\n", "\n\ndef main():\n    input_line = input().split()\n    n, m, s, d = map(int, input_line)\n\n    input_line = input().split()\n    c = list(map(int, input_line))\n\n    #print(n)\n    #print(m)\n    #print(s)\n    #print(d)\n    #print(c)\n\n    #Calculate the total number of sodas in the fridge.\n    total_sodas = 0\n    for i in range(s):\n        total_sodas += c[i]\n\n    #print(total_sodas)\n\n    #Calculate the number of sodas needed to fill the fridge.\n    sodas_needed = 0\n    for i in range(s):\n        sodas_needed += d - c[i]\n\n    #print(sodas_needed)\n\n    #If the number of sodas needed is greater than the number of sodas available, then it is impossible to fill the fridge.\n    if sodas_needed > n:\n        print(\"impossible\")\n\n\n    #Calculate the number of sodas to put in each slot.\n    sodas_in_each_slot = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot[i] = min(d - c[i], n)\n        n -= min(d - c[i], n)\n\n    #print(sodas_in_each_slot)\n\n    #Calculate the number of sodas in each slot after the m students have taken sodas.\n    sodas_in_each_slot_after_m = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot_after_m[i] = max(c[i] - m, 0)\n\n    #print(sodas_in_each_slot_after_m)\n\n    #Calculate the number of cold sodas that the m students will get\n    cold_sodas_m = 0\n    for i in range(s):\n        cold_sodas_m += sodas_in_each_slot_after_m[i]\n\n    #print(cold_sodas_m)\n\n    #If the number of cold sodas that the m students get is less than m, then it is impossible for all m students to get cold sodas.\n    if cold_sodas_m < m:\n        print(\"impossible\")\n        return\n\n        return\n\n    #Calculate the number of sodas in each slot after the n + m students have taken sodas.\n    sodas_in_each_slot_after_n_m = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot_after_n_m[i] = max(c[i] - m + sodas_in_each_slot[i], 0)\n\n    #print(sodas_in_each_slot_after_n_m)\n\n    #Calculate the number of cold sodas that the n + m students will get.\n    cold_sodas_n_m = 0\n    for i in range(s):\n        cold_sodas_n_m += sodas_in_each_slot_after_n_m[i]\n\n    #print(cold_sodas_n_m)\n\n    #Calculate the probability that all m students will get a cold soda.\n    prob = cold_sodas_m / total_sodas\n\n    #print(prob)\n\n    #Calculate the probability that all n + m students will get a cold soda.\n    prob2 = cold_sodas_n_m / (total_sodas + n)\n\n    #print(prob2)\n\n    #Calculate the probability that all m students will get a cold soda after the new sodas are added.\n    prob3 = prob2 / (1 - prob)\n\n    #print(prob3)\n\n    #Print the output.\n    for i in range(s):\n        print(sodas_in_each_slot[i], end = \" \")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\nimport random\n\ndef solve(n, m, s, d, c):\n    # Write your code here\n    # return a list of length s with your solution, or None if impossible\n    return [0] * s\n\n\ndef main():\n    lines = sys.stdin.readlines()\n    n, m, s, d = [int(x) for x in lines[0].split()]\n    c = [int(x) for x in lines[1].split()]\n\n    res = solve(n, m, s, d, c)\n    if res == None:\n        print(\"impossible\")\n    else:\n        print(\" \".join([str(x) for x in res]))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef solve(n, m, s, d, c):\n    if sum(c) + n < m:\n        return \"impossible\"\n\n    # create a list of tuples (c, d) representing the capacities of each slot\n    slots = zip(c, [d]*s)\n    # sort the list of slots by capacity, descending\n    slots = sorted(slots, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c, d) representing the number of bottles to add to each slot\n    add = [(0,0)]*s\n\n    # add bottles to the slots with the most free space\n    for i in range(n):\n        # find the slot with the most free space\n        slot = max(slots, key=lambda x: x[1]-x[0])\n        # add a bottle to the slot\n        add[slots.index(slot)] = (add[slots.index(slot)][0]+1, add[slots.index(slot)][1])\n        # update the slot's capacity\n        slot = (slot[0]+1, slot[1])\n        slots[slots.index(slot)] = slot\n\n    # sort the list of bottles to add to each slot by the number of bottles in each slot, descending\n    add = sorted(add, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c, d) representing the updated capacities of each slot\n    slots = [(x[0]+y[0], x[1]) for x, y in zip(slots, add)]\n    # sort the list of slots by capacity, descending\n    slots = sorted(slots, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c, d) representing the probability of getting a cold bottle from each slot\n    p = [(x[0]/float(x[1]), x[1]) for x in slots]\n    # sort the list of probabilities by probability, descending\n    p = sorted(p, key=lambda x: x[0], reverse=True)\n\n    # calculate the probability that the next m students get a cold bottle\n    prob = 1.0\n    for i in range(m):\n        prob *= p[i][0]\n\n    # if the probability is 0, return \"impossible\"\n    if prob == 0:\n        return \"impossible\"\n\n    # otherwise, return the list of bottles to add to each slot\n    return [x[0] for x in add]\n\nif __name__ == \"__main__\":\n    n, m, s, d = map(int, raw_input().split())\n    c = map(int, raw_input().split())\n    print \" \".join(map(str, solve(n, m, s, d, c)))\n", "\n\ndef main():\n    input_line = input().split()\n    n, m, s, d = map(int, input_line)\n\n    input_line = input().split()\n    c = list(map(int, input_line))\n\n    #print(n)\n    #print(m)\n    #print(s)\n    #print(d)\n    #print(c)\n\n    #Calculate the total number of sodas in the fridge.\n    total_sodas = 0\n    for i in range(s):\n        total_sodas += c[i]\n\n    #print(total_sodas)\n\n    #Calculate the number of sodas needed to fill the fridge.\n    sodas_needed = 0\n    for i in range(s):\n        sodas_needed += d - c[i]\n\n    #print(sodas_needed)\n\n    #If the number of sodas needed is greater than the number of sodas available, then it is impossible to fill the fridge.\n    if sodas_needed > n:\n        print(\"impossible\")\n        return\n\n    #Calculate the number of sodas to put in each slot\n    sodas_in_each_slot = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot[i] = min(d - c[i], n)\n        n -= min(d - c[i], n)\n\n    #print(sodas_in_each_slot)\n\n    #Calculate the number of sodas in each slot after the m students have taken sodas\n    sodas_in_each_slot_after_m = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot_after_m[i] = max(c[i] - m, 0)\n\n    #print(sodas_in_each_slot_after_m)\n\n    #Calculate the number of cold sodas that the m students will get\n    cold_sodas_m = 0\n    for i in range(s):\n        cold_sodas_m += sodas_in_each_slot_after_m[i]\n\n    #print(cold_sodas_m)\n\n    #If the number of cold sodas that the m students get is less than m, then it is impossible for all m students to get cold sodas\n    if cold_sodas_m < m:\n        print(\"impossible\")\n        return\n\n    #Calculate the number of sodas in each slot after the n + m students have taken sodas\n    sodas_in_each_slot_after_n_m = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot_after_n_m[i] = max(c[i] - m + sodas_in_each_slot[i], 0)\n\n    #print(sodas_in_each_slot_after_n_m)\n\n    #Calculate the number of cold sodas that the n + m students will get\n    cold_sodas_n_m = 0\n    for i in range(s):\n        cold_sodas_n_m += sodas_in_each_slot_after_n_m[i]\n\n    #print(cold_sodas_n_m)\n\n    #Calculate the probability that all m students will get a cold soda\n    prob = cold_sodas_m / total_sodas #This is not correct\n\n    #print(prob)\n\n    #Calculate the probability that all n + m students will get a cold soda\n    prob2 = cold_sodas_n_m / (total_sodas + n) #This is not correct\n\n    #print(prob2)\n\n    #Calculate the probability that all m students will get a cold soda after the new sodas are added\n    prob3 = prob2 / (1 - prob) #This is not correct\n\n    #print(prob3)\n\n    #Print the output\n    for i in range(s):\n        print(sodas_in_each_slot[i], end = \" \")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef solve(n, m, s, d, c): \n    if sum(c) + n < m:\n        return \"impossible\"\n\n    # create a list of tuples (c,d) representing the capacities of each slot\n    slots = zip(c, [d]*s)\n    # sort the list of slots by capacity, descending\n    slots = sorted(slots, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c,d) representing the number of bottles to add to each slot\n    add = [(0,0)]*s\n\n    # add bottles to the slots with the most free space\n    for i in range(n):\n        # find the slot with the most free space\n        slot = max(slots, key=lambda x: x[1]-x[0])\n        # add a bottle to the slot\n        add[slots.index(slot)] = (add[slots.index(slot)][0]+1, add[slots.index(slot)][1])\n        # update the slot's capacity\n        slot = (slot[0]+1, slot[1])\n        slots[slots.index(slot)] = slot\n\n    # sort the list of bottles to add to each slot by the number of bottles in each slot, descending\n    add = sorted(add, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c,d) representing the updated capacities of each slot\n    slots = [(x[0]+y[0], x[1]) for x, y in zip(c, add)]\n    # sort the list of slots by capacity, descending\n    slots = sorted(slots, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c,d) representing the probability of getting a cold bottle from each slot\n    p = [(x[0]/float(x[1]), x[1]) for x in slots]\n    # sort the list of probabilities by probability, descending\n    p = sorted(p, key=lambda x: x[0], reverse=True)\n\n    # calculate the probability that the next m students get a cold bottle\n    prob = 1.0\n    for i in range(m):\n        prob *= p[i][0]\n\n    # if the probability is 0, return \"impossible\"\n    if prob == 0:\n        return \"impossible\"\n\n    # otherwise, return the list of bottles to add to each slot\n    return [x[0] for x in add]\n\nif __name__ == \"__main__\":\n    n, m, s, d = map(int, input().split())\n    c = map(int, input().split())\n    print \" \".join(map(str, solve(n, m, s, d, c)))\n", "\nimport itertools\n\ndef solve(n, m, s, d, c):\n    if n < m:\n        return \"impossible\"\n    n_slots = list(itertools.combinations(range(s), m)) # combinations of slots (m)\n    n_new = list(itertools.combinations(range(n), m)) # combinations of new students (m)\n    max_p = 0\n    max_p_scheme = []\n    for slots in n_slots:\n        for new in n_new:\n            p = 1\n            for i in range(m):\n                p *= (c[slots[i]] + new[i]) / d # probability of new students getting their first choice\n            if p > max_p:\n                max_p = p\n                max_p_scheme = [0]*s # reset\n                for i in range(m):\n                    max_p_scheme[slots[i]] += new[i] # add new students to slots\n    return \" \".join(map(str, max_p_scheme))\n\ndef main():\n    n, m, s, d = map(int, input().split(\" \"))\n    c = list(map(int, input().split(\" \")))\n    print(solve(n, m, s, d, c))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef is_possible(bottles, slots, students, capacity, new_bottles):  # check if it is possible to distribute bottles among students\n    for i in range(len(slots)):\n        slots[i] += new_bottles[i]\n    for j in range(students):\n        if sum(slots) == 0:\n            return False\n        for i in range(len(slots)):\n            if slots[i] > 0:\n                slots[i] -= 1\n                break\n    return True\n\ndef refill(bottles, slots, students, capacity, new_bottles):\n    while not is_possible(bottles, slots, students, capacity, new_bottles):\n        new_bottles[-1] -= 1\n        new_bottles[-2] += 1\n        if new_bottles[-1] == 0:\n            new_bottles[-1] = new_bottles[-2]\n            new_bottles[-2] = 0\n            if new_bottles[-2] == 0:\n                new_bottles[-2] = new_bottles[-3]\n                new_bottles[-3] = 0\n                if new_bottles[-3] == 0:\n                    new_bottles[-3] = new_bottles[-4]\n                    new_bottles[-4] = 0\n    return new_bottles\n\ndef main():\n    new_bottles, students, slots, capacity = map(int, input().split())  # read input\n    bottles = list(map(int, input().split()))  # read input\n    new_bottles = list(map(int, input().split()))  # read input\n    if is_possible(bottles, slots, students, capacity, new_bottles):\n        print(*refill(bottles, slots, students, capacity, new_bottles))\n    else:\n        print(\"impossible\")\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport random\n\ndef solve(n, m, s, d, c):\n    # Write your code here\n    # return a list of length s with your solution, or None if there is no solution\n    return [0]*s\n\nlines = sys.stdin.readlines()\nn, m, s, d = [int(x) for x in lines[0].split()]\nc = [int(x) for x in lines[1].split()]\n\nres = solve(n, m, s, d, c)\nif res == None:\n    print(\"impossible\")\nelse:\n    print(\" \".join([str(x) for x in res])\n", "\ndef is_possible(slots, students, capacity, new_bottles):\n    for i in range(len(slots)):\n        slots[i] += new_bottles[i]\n    for j in range(students):\n        if sum(slots) == 0:\n            return False\n        for i in range(len(slots)):\n            if slots[i] > 0:\n                slots[i] -= 1\n                break\n    return True\n\ndef refill(slots, students, capacity, new_bottles):\n    while not is_possible(slots, students, capacity, new_bottles):\n        new_bottles[-1] -= 1\n        new_bottles[-2] += 1\n        if new_bottles[-1] == 0:\n            new_bottles[-1] = new_bottles[-2]\n            new_bottles[-2] = 0\n            if new_bottles[-2] == 0:\n                new_bottles[-2] = new_bottles[-3]\n                new_bottles[-3] = 0\n                if new_bottles[-3] == 0:\n                    new_bottles[-3] = new_bottles[-4]\n                    new_bottles[-4] = 0\n    return new_bottles\n\ndef main():\n    new_bottles, students, slots, capacity = map(int, input().split())\n    bottles = list(map(int, input().split()))\n    new_bottles = list(map(int, input().split()))\n    if is_possible(bottles, students, capacity, new_bottles):\n        print(*refill(bottles, students, capacity, new_bottles))\n    else:\n        print(\"impossible\")\n\nif __name__ == '__main__':\n    main()\n", "\nimport itertools\n\ndef solve(n, m, s, d, c):\n    if n < m:\n        return \"impossible\"\n    n_slots = list(itertools.combinations(range(s), m)) # all possible combinations of slots\n    n_new = list(itertools.combinations(range(n), m)) # all possible combinations of new\n    max_p = 0\n    max_p_scheme = [] # scheme with max probability\n    for slots in n_slots:\n        for new in n_new:\n            p = 1\n            for i in range(m):\n                p *= (c[slots[i]] + new[i]) / d\n            if p > max_p:\n                max_p = p\n                max_p_scheme = [0]*s # reset scheme\n                for i in range(m):\n                    max_p_scheme[slots[i]] += new[i] # add new to slots\n    return \" \".join(map(str, max_p_scheme)) # return string of max_p_scheme\n\ndef main():\n    n, m, s, d = map(int, input().split(\" \"))\n    c = list(map(int, input().split(\" \")))\n    print(solve(n, m, s, d, c))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nn, m, s, d = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\n\n# First, we check if it is possible, i.e.\n# all the slots are full, and the number of\n# cold sodas is less than the number of students\n# that need to be served.\nif sum(c) < m:\n    print(\"impossible\")\n    exit()\n\n# We need to find a way to maximize the probability\n# that the next m students receive a cold soda.\n# We can do this by minimizing the probability that\n# a student receives a hot soda.\n#\n# We can calculate the probability of receiving a\n# hot soda by dividing the number of hot sodas by\n# the total number of sodas.\n#\n# We can minimize this probability by making the\n# number of hot sodas as small as possible, while\n# making the number of total sodas as large as possible.\n#\n# Suppose we have the following fridge:\n# [0, 1, 4]\n# If we put the new sodas in slot 0, then the\n# probability of receiving a hot soda is 5/9.\n# If we put the new sodas in slot 1, then the\n# probability of receiving a hot soda is 4/8.\n# If we put the new sodas in slot 2, then the\n# probability of receiving a hot soda is 1/5.\n#\n# We can see that the best place to put the new sodas\n# is in slot 2, since it has the minimum probability\n# of receiving a hot soda.\n#\n# In general, we can see that the best place to put the\n# new sodas is in the slot that has the minimum number\n# of hot sodas, and is not full.\n#\n# We can calculate the number of hot sodas in a slot\n# by taking the difference between the number of sodas\n# in the slot, and the number of cold sodas in the slot.\n#\n# We can calculate the number of total sodas in a slot\n# by taking the sum of the number of cold sodas in the slot,\n# and the number of new sodas in the slot.\n#\n# When we place the new sodas in a slot, we need to make\n# sure that there are still enough new sodas left to fill\n# the other slots.\n#\n# We can do this by checking that the number of new sodas\n# that we want to place in a slot is less than or equal\n# to the number of new sodas left to place.\n\n# First, we initialize the number of new sodas left to place\n# as the number of new sodas\nnew_sodas_left = n\n\n# We also initialize the number of hot sodas in a slot\n# as the difference between the number of sodas in a slot,\n# and the number of cold sodas in a slot.\nhot_sodas_in_slot = [d - c[i] for i in range(s)]\n\n# We also initialize the number of total sodas in a slot\n# as the sum of the number of cold sodas in a slot,\n# and the number of new sodas in a slot.\ntotal_sodas_in_slot = [c[i] for i in range(s)]\n\n# We also initialize the number of new sodas to place in a slot\n# as 0.\nnew_sodas_in_slot = [0 for i in range(s)]\n\n# We will put the new sodas in the slots in ascending order\n# of the number of hot sodas in the slot, so we sort the\n# list of hot sodas in the slot.\nhot_sodas_in_slot, total_sodas_in_slot, new_sodas_in_slot = zip(*sorted(zip(hot_sodas_in_slot, total_sodas_in_slot, new_sodas_in_slot), reverse=True))\n\n# Next, we iterate over the slots in ascending order\n# of the number of hot sodas in the slot.\nfor i in range(s):\n    # We check if the slot is not full\n    if c[i] < d:\n        # We check if there are enough new sodas left to fill\n        # the slot.\n        if new_sodas_left >= d - c[i]:\n            # If there are enough new sodas left to fill the slot,\n            # we set the number of new sodas in the slot as the\n            # difference between the capacity of the slot, and the\n            # number of sodas in the slot.\n            new_sodas_in_slot[i] = d - c[i]\n            # We also update the number of new sodas left to place.\n            new_sodas_left -= new_sodas_in_slot[i]\n            # We also update the number of hot sodas in the slot.\n            hot_sodas_in_slot[i] = 0\n            # We also update the number of total sodas in the slot.\n            total_sodas_in_slot[i] = d\n        else:\n            # If there are not enough new sodas left to fill the slot,\n            # we set the number of new sodas in the slot as the number\n            # of new sodas left to place.\n            new_sodas_in_slot[i] = new_sodas_left\n            # We also update the number of new sodas left to place.\n            new_sodas_left = 0\n            # We also update the number of hot sodas in the slot.\n            hot_sodas_in_slot[i] = hot_sodas_in_slot[i] - new_sodas_in_slot[i]\n            # We also update the number of total sodas in the slot.\n            total_sodas_in_slot[i] = total_sodas_in_slot[i] + new_sodas_in_slot[i]\n\n# We sort the number of new sodas in the slot in descending order\n# so that the new sodas are added to the fridge in the correct order.\nnew_sodas_in_slot = list(new_sodas_in_slot)\n\n# We print the number of new sodas in the slot\nprint(*new_sodas_in_slot)\n", "\ndef is_possible(slots, students, capacity, new_bottles):\n    for i in range(len(slots)):\n        slots[i] += new_bottles[i]\n    for j in range(students):\n        if sum(slots) == 0:\n            return False\n        for i in range(len(slots)):\n            if slots[i] > 0:\n                slots[i] -= 1\n                break\n    return True\n\ndef refill(slots, students, capacity, new_bottles):\n    while not is_possible(slots, students, capacity, new_bottles):\n        new_bottles[-1] -= 1\n        new_bottles[-2] += 1\n        if new_bottles[-1] == 0:\n            new_bottles[-1] = new_bottles[-2]\n            new_bottles[-2] = 0\n            if new_bottles[-2] == 0:\n                new_bottles[-2] = new_bottles[-3]\n                new_bottles[-3] = 0\n                if new_bottles[-3] == 0:\n                    new_bottles[-3] = new_bottles[-4]\n                    new_bottles[-4] = 0\n    return new_bottles\n\ndef main():\n    slots, students, capacity = map(int, input().split())\n    bottles = list(map(int, input().split()))\n    new_bottles = list(map(int, input().split()))\n    if is_possible(slots, students, capacity, new_bottles):\n        print(*refill(slots, students, capacity, new_bottles))\n    else:\n        print(\"impossible\")\n\nif __name__ == '__main__':\n    main()\n", "\n\nn, m, s, d = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\n\n# First, we check if it is possible, i.e.\n# all the slots are full, and the number of\n# cold sodas is less than the number of students\n# that need to be served\nif sum(c) < m:\n    print(\"impossible\")\n    exit()\n\n# We need to find a way to maximize the probability\n# that the next m students receive a cold soda.\n# We can do this by minimizing the probability that\n# a student receives a hot soda.\n#\n# We can calculate the probability of receiving a\n# hot soda by dividing the number of hot sodas by\n# the total number of sodas.\n#\n# We can minimize this probability by making the\n# number of hot sodas as small as possible, while\n# making the number of total sodas as large as possible.\n#\n# Suppose we have the following fridge:\n# [0, 1, 4]\n# If we put the new sodas in slot 0, then the\n# probability of receiving a hot soda is 5/9.\n# If we put the new sodas in slot 1, then the\n# probability of receiving a hot soda is 4/8.\n# If we put the new sodas in slot 2, then the\n# probability of receiving a hot soda is 1/5.\n#\n# We can see that the best place to put the new sodas\n# is in slot 2, since it has the minimum probability\n# of receiving a hot soda.\n#\n# In general, we can see that the best place to put the\n# new sodas is in the slot that has the minimum number\n# of hot sodas, and is not full.\n#\n# We can calculate the number of hot sodas in a slot\n# by taking the difference between the number of sodas\n# in the slot, and the number of cold sodas in the slot.\n#\n# We can calculate the number of total sodas in a slot\n# by taking the sum of the number of cold sodas in the slot,\n# and the number of new sodas in the slot.\n#\n# When we place the new sodas in a slot, we need to make\n# sure that there are still enough new sodas left to fill\n# the other slots.\n#\n# We can do this by checking that the number of new sodas\n# that we want to place in a slot is less than or equal\n# to the number of new sodas left to place.\n\n# First, we initialize the number of new sodas left to place\n# as the number of new sodas\nnew_sodas_left = n\n\n# We also initialize the number of hot sodas in a slot\n# as the difference between the number of sodas in a slot,\n# and the number of cold sodas in a slot\nhot_sodas_in_slot = [d - c[i] for i in range(s)]\n\n# We also initialize the number of total sodas in a slot\n# as the sum of the number of cold sodas in a slot,\n# and the number of new sodas in a slot\ntotal_sodas_in_slot = [c[i] for i in range(s)]\n\n# We also initialize the number of new sodas to place in a slot\n# as 0\nnew_sodas_in_slot = [0 for i in range(s)]\n\n# We will put the new sodas in the slots in ascending order\n# of the number of hot sodas in the slot, so we sort the\n# list of hot sodas in the slot\nhot_sodas_in_slot, total_sodas_in_slot, new_sodas_in_slot = zip(*sorted(zip(hot_sodas_in_slot, total_sodas_in_slot, new_sodas_in_slot), key = lambda x: x[0]))\n\n# Next, we iterate over the slots in ascending order\n# of the number of hot sodas in the slot\nfor i in range(s):\n    # We check if the slot is not full\n    if c[i] < d:\n        # We check if there are enough new sodas left to fill\n        # the slot\n        if new_sodas_left >= d - c[i]:\n            # If there are enough new sodas left to fill the slot,\n            # we set the number of new sodas in the slot as the\n            # difference between the capacity of the slot, and the\n            # number of sodas in the slot\n            new_sodas_in_slot[i] = d - c[i]\n            # We also update the number of new sodas left to place\n            new_sodas_left -= new_sodas_in_slot[i]\n            # We also update the number of hot sodas in the slot\n            hot_sodas_in_slot[i] = 0\n            # We also update the number of total sodas in the slot\n            total_sodas_in_slot[i] = d\n        else:\n            # If there are not enough new sodas left to fill the slot,\n            # we set the number of new sodas in the slot as the number\n            # of new sodas left to place\n            new_sodas_in_slot[i] = new_sodas_left\n            # We also update the number of new sodas left to place\n            new_sodas_left = 0\n            # We also update the number of hot sodas in the slot\n            hot_sodas_in_slot[i] -= new_sodas_in_slot[i]\n            # We also update the number of total sodas in the slot\n            total_sodas_in_slot[i] += new_sodas_in_slot[i]\n\n# We sort the number of new sodas in the slots in descending order\n# so that the new sodas are added to the fridge in the correct order\nnew_sodas_in_slot = list(reversed(new_sodas_in_slot))\n\n# We print the number of new sodas in the slots\nprint(*new_sodas_in_slot)\n", "\n\ndef main():\n    input_line = input().split()\n    n, m, s, d = map(int, input_line)\n\n    input_line = input().split()\n    c = list(map(int, input_line))\n\n    #print(n)\n    #print(m)\n    #print(s)\n    #print(d)\n    #print(c)\n\n    #Calculate the total number of sodas in the fridge.\n    total_sodas = 0\n    for i in range(s):\n        total_sodas += c[i]\n\n    #print(total_sodas)\n\n    #Calculate the number of sodas needed to fill the fridge.\n    sodas_needed = 0\n    for i in range(s):\n        sodas_needed += d - c[i]\n\n    #print(sodas_needed)\n\n    #If the number of sodas needed is greater than the number of sodas available, then it is impossible to fill the fridge.\n    if sodas_needed > n:\n        print(\"impossible\")\n        return\n\n\n    #Calculate the number of sodas to put in each slot.\n    sodas_in_each_slot = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot[i] = min(d - c[i], n)\n        n -= min(d - c[i], n)\n\n    #print(sodas_in_each_slot)\n\n    #Calculate the number of sodas in each slot after the m students have taken sodas.\n    sodas_in_each_slot_after_m = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot_after_m[i] = max(c[i] - m, 0)\n\n    #print(sodas_in_each_slot_after_m)\n\n    #Calculate the number of cold sodas that the m students will get\n    cold_sodas_m = 0\n    for i in range(s):\n        cold_sodas_m += sodas_in_each_slot_after_m[i]\n\n    #print(cold_sodas_m)\n\n    #If the number of cold sodas that the m students get is less than m, then it is impossible for all m students to get cold sodas.\n    if cold_sodas_m < m:\n        print(\"impossible\")\n        return\n\n\n    #Calculate the number of sodas in each slot after the n + m students have taken sodas.\n    sodas_in_each_slot_after_n_m = [0 for i in range(s)]\n\n    for i in range(s):\n        sodas_in_each_slot_after_n_m[i] = max(c[i] - m + sodas_in_each_slot[i], 0)\n\n    #print(sodas_in_each_slot_after_n_m)\n\n    #Calculate the number of cold sodas that the n + m students will get.\n    cold_sodas_n_m = 0\n    for i in range(s):\n        cold_sodas_n_m += sodas_in_each_slot_after_n_m[i]\n\n    #print(cold_sodas_n_m)\n\n    #Calculate the probability that all m students will get a cold soda.\n    prob = cold_sodas_m / total_sodas\n\n    #print(prob)\n\n    #Calculate the probability that all n + m students will get a cold soda.\n    prob2 = cold_sodas_n_m / (total_sodas + n)\n\n    #print(prob2)\n\n    #Calculate the probability that all m students will get a cold soda after the new sodas are added.\n    prob3 = prob2 / (1 - prob)\n\n    #print(prob3)\n\n    #Print the output.\n    for i in range(s):\n        print(sodas_in_each_slot[i], end = \" \")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nn, m, s, d = [int(i) for i in input().split()]\nc = [int(i) for i in input().split()]\n\n# First, we check if it is possible, i.e.\n# all the slots are full, and the number of\n# cold sodas is less than the number of students\n# that need to be served\nif sum(c) < m:\n    print(\"impossible\")\n    exit()\n\n# We need to find a way to maximize the probability\n# that the next m students receive a cold soda.\n# We can do this by minimizing the probability that\n# a student receives a hot soda.\n#\n# We can calculate the probability of receiving a\n# hot soda by dividing the number of hot sodas by\n# the total number of sodas.\n#\n# We can minimize this probability by making the\n# number of hot sodas as small as possible, while\n# making the number of total sodas as large as possible.\n#\n# Suppose we have the following fridge:\n# [0, 1, 4]\n# If we put the new sodas in slot 0, then the\n# probability of receiving a hot soda is 5/9.\n# If we put the new sodas in slot 1, then the\n# probability of receiving a hot soda is 4/8.\n# If we put the new sodas in slot 2, then the\n# probability of receiving a hot soda is 1/5.\n#\n# We can see that the best place to put the new sodas\n# is in slot 2, since it has the minimum probability\n# of receiving a hot soda.\n#\n# In general, we can see that the best place to put the\n# new sodas is in the slot that has the minimum number\n# of hot sodas, and is not full.\n#\n# We can calculate the number of hot sodas in a slot\n# by taking the difference between the number of sodas\n# in the slot, and the number of cold sodas in the slot.\n#\n# We can calculate the number of total sodas in a slot\n# by taking the sum of the number of cold sodas in the slot,\n# and the number of new sodas in the slot.\n#\n# When we place the new sodas in a slot, we need to make\n# sure that there are still enough new sodas left to fill\n# the other slots.\n#\n# We can do this by checking that the number of new sodas\n# that we want to place in a slot is less than or equal\n# to the number of new sodas left to place.\n\n# First, we initialize the number of new sodas left to place\n# as the number of new sodas\nnew_sodas_left = n\n\n# We also initialize the number of hot sodas in a slot\n# as the difference between the number of sodas in a slot,\n# and the number of cold sodas in a slot\nhot_sodas_in_slot = [d - c[i] for i in range(s)]\n\n# We also initialize the number of total sodas in a slot\n# as the sum of the number of cold sodas in a slot,\n# and the number of new sodas in a slot\ntotal_sodas_in_slot = [c[i] for i in range(s)]\n\n# We also initialize the number of new sodas to place in a slot\n# as 0\nnew_sodas_in_slot = [0 for i in range(s)]\n\n# We will put the new sodas in the slots in ascending order\n# of the number of hot sodas in the slot, so we sort the\n# lists of hot sodas in the slot, total sodas in the slot,\n# and new sodas in the slot\nhot_sodas_in_slot, total_sodas_in_slot, new_sodas_in_slot = zip(*sorted(zip(hot_sodas_in_slot, total_sodas_in_slot, new_sodas_in_slot)))\n\n# Next, we iterate over the slots in ascending order\n# of the number of hot sodas in the slot\nfor i in range(s):\n    # We check if the slot is not full\n    if c[i] < d:\n        # We check if there are enough new sodas left to fill\n        # the slot\n        if new_sodas_left >= d - c[i]:\n            # If there are enough new sodas left to fill the slot,\n            # we set the number of new sodas in the slot as the\n            # difference between the capacity of the slot, and the\n            # number of sodas in the slot\n            new_sodas_in_slot[i] = d - c[i]\n            # We also update the number of new sodas left to place\n            new_sodas_left -= new_sodas_in_slot[i]\n            # We also update the number of hot sodas in the slot\n            hot_sodas_in_slot[i] = 0\n            # We also update the number of total sodas in the slot\n            total_sodas_in_slot[i] = d\n        else:\n            # If there are not enough new sodas left to fill the slot,\n            # we set the number of new sodas in the slot as the number\n            # of new sodas left to place\n            new_sodas_in_slot[i] = new_sodas_left\n            # We also update the number of new sodas left to place\n            new_sodas_left = 0\n            # We also update the number of hot sodas in the slot\n            hot_sodas_in_slot[i] = hot_sodas_in_slot[i] - new_sodas_in_slot[i]\n            # We also update the number of total sodas in the slot\n            total_sodas_in_slot[i] = total_sodas_in_slot[i] + new_sodas_in_slot[i]\n\n# We sort the number of new sodas in the slots in descending order\n# so that the new sodas are added to the fridge in the correct order\nnew_sodas_in_slot = list(reversed(new_sodas_in_slot))\n\n# We print the number of new sodas in the slots\nprint(*new_sodas_in_slot)\n", "\n\ndef solve(n, m, s, d, c): \n    if sum(c) + n < m:\n        return \"impossible\"\n\n    # create a list of tuples (c,d) representing the capacities of each slot\n    slots = zip(c, [d]*s)\n    # sort the list of slots by capacity, descending\n    slots = sorted(slots, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c,d) representing the number of bottles to add to each slot\n    add = [(0,0)]*s\n\n    # add bottles to the slots with the most free space\n    for i in range(n):\n        # find the slot with the most free space\n        slot = max(slots, key=lambda x: x[1]-x[0])\n        # add a bottle to the slot\n        add[slots.index(slot)] = (add[slots.index(slot)][0]+1, add[slots.index(slot)][1])\n        # update the slot's capacity\n        slot = (slot[0]+1, slot[1])\n        slots[slots.index(slot)] = slot\n\n    # sort the list of bottles to add to each slot by the number of bottles in each slot, descending\n    add = sorted(add, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c,d) representing the updated capacities of each slot\n    slots = [(x[0]+y[0], x[1]) for x, y in zip(slots, add)]\n    # sort the list of slots by capacity, descending\n    slots = sorted(slots, key=lambda x: x[0], reverse=True)\n\n    # create a list of tuples (c,d) representing the probability of getting a cold bottle from each slot\n    p = [(x[0]/float(x[1]), x[1]) for x in slots]\n    # sort the list of probabilities by probability, descending\n    p = sorted(p, key=lambda x: x[0], reverse=True)\n\n    # calculate the probability that the next m students get a cold bottle\n    prob = 1.0\n    for i in range(m):\n        prob *= p[i][0]\n\n    # if the probability is 0, return \"impossible\"\n    if prob == 0:\n        return \"impossible\"\n\n    # otherwise, return the list of bottles to add to each slot\n    return [x[0] for x in add]\n\nif __name__ == \"__main__\":\n    n, m, s, d = map(int, input().split())\n    c = map(int, input().split())\n    print(\" \".join(map(str, solve(n, m, s, d, c))))\n", "\n\ndef main():\n    \"\"\"\n    This function is used to run the program.\n\n    Returns:\n        None\n    \"\"\"\n    # Read input\n    n, m, s, d = [int(i) for i in input().split()]\n    c = [int(i) for i in input().split()]\n\n    # Calculate the number of cold drinks in the fridge\n    cold_drinks_in_fridge = sum(c)\n\n    # If there are more cold drinks than the number of students, then output the empty array\n    if cold_drinks_in_fridge >= m:\n        print(' '.join([str(0) for i in range(s)]))\n        return\n\n    # Calculate the number of empty slots\n    empty_slots = s - len(c)\n\n    # Calculate the number of drinks to add to the fridge and the number of drinks to add to each slot\n    drinks_to_add_in_fridge = min(n, m - cold_drinks_in_fridge)\n    drinks_to_add_per_slot = [0 for i in range(s)]\n\n    # Calculate the number of drinks to add to each slot, if there are more empty slots than drinks to add\n    for i in range(s):\n        if c[i] < d:\n            drinks_to_add_per_slot[i] = min(d - c[i], drinks_to_add_in_fridge)\n            drinks_to_add_in_fridge -= drinks_to_add_per_slot[i]\n\n    # If there are still drinks to add, then output \"impossible\"\n    if drinks_to_add_in_fridge > 0:\n        print(\"impossible\")\n        return\n\n    # Output the drinks to add in each slot\n    print(' '.join([str(i) for i in drinks_to_add_per_slot]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    \"\"\"\n    This function is used to run the program.\n\n    Returns:\n        None\n    \"\"\"\n    # Read input and convert to integers\n    n, m, s, d = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    # Calculate the number of cold drinks in the fridge\n    cold_drinks_in_fridge = sum(c)\n\n    # If there are more cold drinks in the fridge than the number of students, then output the empty list\n    if cold_drinks_in_fridge >= m:\n        print(' '.join(map(str, [0] * s)))\n        return\n\n    # Calculate the number of empty slots\n    empty_slots = s - len(c)\n\n    # Calculate the number of drinks to add to the front of the fridge, which is the minimum of the number of drinks\n    # in the fridge and the number of students\n    drinks_to_add = min(n, m - cold_drinks_in_fridge)\n\n    # If there are more empty slots than drinks to add, then output the drinks to add in each slot\n    if empty_slots >= drinks_to_add:\n        print(' '.join(map(str, [1 if i < drinks_to_add else 0 for i in range(s)])))\n        return\n\n    # Calculate the number of drinks to add to the back of the fridge\n    drinks_to_add = max(0, drinks_to_add - empty_slots)\n\n    # Calculate the number of drinks to add to each slot\n    drinks_to_add_per_slot = [0] * s\n    for i in range(s):\n        if c[i] < d:\n            drinks_to_add_per_slot[i] = min(d - c[i], drinks_to_add)\n            drinks_to_add -= drinks_to_add_per_slot[i]\n\n    # If there are still drinks to add, then output \"impossible\"\n    if drinks_to_add > 0:\n        print(\"impossible\")\n        return\n\n    # Output the drinks to add in each slot\n    print(' '.join(map(str, drinks_to_add_per_slot)))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nimport random\n\ndef solve(n, m, s, d, c):\n    # Write your code here\n    # return a list of length s with your solution, or None if impossible\n    return [0] * s\n\nlines = sys.stdin.readlines()\nn, m, s, d = [int(x) for x in lines[0].split()]\nc = [int(x) for x in lines[1].split()]\n\nres = solve(n, m, s, d, c)\nif res == None:\n    print(\"impossible\")\nelse:\n    print(\" \".join([str(x) for x in res]))\n", "\n\ndef main():\n    \"\"\"\n    This function is used to run the program.\n\n    Returns:\n        None\n    \"\"\"\n    # Read input\n    n, m, s, d = [int(i) for i in input().split()]\n    c = [int(i) for i in input().split()]\n\n    # Calculate the number of cold drinks in the fridge\n    cold_drinks_in_fridge = sum(c)\n\n    # If there are more cold drinks than the number of students, then output the empty list\n    if cold_drinks_in_fridge >= m:\n        print(' '.join([str(0) for i in range(s)]))\n        return\n\n    # Calculate the number of empty slots\n    empty_slots = s - len(c)\n\n    # Calculate the number of drinks to add to the fridge\n    drinks_to_add = min(n, m - cold_drinks_in_fridge)\n\n    # If there are more empty slots than drinks to add, then output the drinks to add in each slot\n    if empty_slots >= drinks_to_add:\n        print(' '.join([str(1) if i < drinks_to_add else str(0) for i in range(s)]))\n        return\n\n    # Calculate the number of drinks to add to the fridge\n    drinks_to_add_in_fridge = max(0, drinks_to_add - empty_slots)\n\n    # Calculate the number of drinks to add to each slot\n    drinks_to_add_per_slot = [0 for i in range(s)]\n    for i in range(s):\n        if c[i] < d:\n            drinks_to_add_per_slot[i] = min(d - c[i], drinks_to_add_in_fridge)\n            drinks_to_add_in_fridge -= drinks_to_add_per_slot[i]\n\n    # If there are still drinks to add, then output \"impossible\"\n    if drinks_to_add_in_fridge > 0:\n        print(\"impossible\")\n        return\n\n    # Output the drinks to add in each slot\n    print(' '.join([str(i) for i in drinks_to_add_per_slot]))\n\nif __name__ == \"__main__\":\n    main()\n"]