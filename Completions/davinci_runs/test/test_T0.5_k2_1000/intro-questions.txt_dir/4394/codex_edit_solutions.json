["\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nsys.setrecursionlimit(10 ** 6)\n\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2])\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2])\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Implement the solution here\ndef solve(n, m, edges):\n    return 0\n\n# Inputs\nn, m = [int(x) for x in input().split()]\nedges = []\nfor i in range(m):\n    edges.append([int(x) for x in input().split()])\n\n# Solve the problem\nres = solve(n, m, edges)\n\n# Output\nprint(res)\n", "\n\n# Implement the solution here\ndef solve(n, m, edges):\n    return -1, -1\n\n# Inputs\nn, m = [int(x) for x in input().split()]\nedges = []\nfor i in range(m):\n    edges.append([int(x) for x in input().split()])\n\n# Solve the problem\nres, path = solve(n, m, edges)\n\n# Output\nprint(res)\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nsys.setrecursionlimit(10 ** 6)\n\ndef read_list():\n    return sys.stdin.readline().strip().split(' ')\n\n\ndef read_single_int():\n    return int(sys.stdin.readline().strip())\n\n\ndef read_single_str():\n    return sys.stdin.readline().strip()\n\n\ndef read_single_float():\n    return float(sys.stdin.readline().strip())\n\n\ndef read_list_int():\n    return list(map(int, read_list()))\n\n\ndef read_list_float():\n    return list(map(float, read_list()))\n\n\nclass Graph:\n    def __init__(self, n, m):\n        self.nodes = n\n        self.edges = m\n        self.graph = defaultdict(list)\n        self.weight = []\n        self.visited = [False] * n\n\n    def add_edge(self, u, v, w):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n        self.weight.append((u, v, w))\n\n    def find_mst(self):\n        self.visited = [False] * self.nodes\n        self.visited[0] = True\n        self.heap = []\n        for v in self.graph[0]:\n            heappush(self.heap, (self.find_weight(0, v), 0, v))\n        mst = []\n        while self.heap:\n            w, u, v = heappop(self.heap)\n            if not self.visited[v]:\n                self.visited[v] = True\n                mst.append((u, v, w))\n                for to in self.graph[v]:\n                    if not self.visited[to]:\n                        heappush(self.heap, (self.find_weight(v, to), v, to))\n        return mst\n\n    def find_weight(self, u, v):\n        for w in self.weight:\n            if w[0] == u and w[1] == v:\n                return w[2]\n            if w[1] == u and w[0] == v:\n                return w[2]\n\n    def find_mst_weight(self, mst):\n        return sum([w for u, v, w in mst])\n\n    def find_mst_count(self):\n        mst = self.find_mst()\n        mst_weight = self.find_mst_weight(mst)\n        self.weight.sort(key=lambda x: x[2])\n        for i in range(len(self.weight)):\n            u, v, w = self.weight[i]\n            self.weight[i] = (u, v, w + i)\n            mst = self.find_mst()\n            if mst_weight != self.find_mst_weight(mst):\n                self.weight[i] = (u, v, w)\n                return i\n        return i + 1\n\n\ndef main():\n    n, m = read_list_int()\n    g = Graph(n, m)\n    for i in range(m):\n        u, v, w = read_list_int()\n        g.add_edge(u - 1, v - 1, w)\n    print(g.find_mst_count())\n\n\nif __name__ == '__main__':\n    main()\n"]