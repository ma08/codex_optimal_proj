["#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\nza = getIntList()\n\nmh = max(za)\nza.append(mh)\n\nduo = [(mh,0)]\n\nfor i in range(N+1):\n    h = za[i]\n    while duo:\n        if i%2 != duo[-1][1]%2:\n            dprint(i )\n            print('NO')\n            return\n        if h >= duo[-1][0]:\n            lh = duo[-1][0]\n            duo.pop()\n            if h== lh:\n                break\n        else:\n            break\n    duo.append( (h,i+1))\n    #dprint(duo)\nprint('YES')\n            \n    \n    \n    \n\n\n\n\n\n\n", "n = int(input())\na = list(map(int, input().split()))\nb = [[a[0], 1]]\nfl = False\nfor i in range(1, n):\n    if fl:\n        break\n    if a[i] == b[-1][0]:\n        b[-1][1] += 1\n    elif a[i] < b[-1][0]:\n        b.append([a[i], 1])\n    else:\n        while len(b) != 0 and a[i] > b[-1][0]:\n            if b[-1][1] % 2 != 0:\n                print(\"NO\")\n                fl = True\n                break\n            b.pop()\n        if len(b) == 0 or a[i] < b[-1][0]:\n            b.append([a[i], 1])\n        else:\n            b[-1][1] += 1\nif not fl:\n    i = len(b) - 1\n    while i != 0:\n        if b[i][1] % 2 != 0:\n            fl = True\n            break\n        i -= 1\n    if fl:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n                             \n", "from collections import deque as d\nn,m,q=int(input()),0,d()\nfor i in map(int, input().split()):\n if q:\n  if i == q[-1]:q.pop()\n  elif i > q[-1]:q.append(i);break\n  else:q.append(i)\n else:q.append(i)\n m=max(m,i)\nif len(q)==0 or len(q)==1 and q[0]==m:print('YES')\nelse:print('NO')", "import collections as c\ni,p=input,print\nn,m,q=int(i()),0,c.deque()\nf,l=q.append,len\nfor a in map(int, i().split()):\n if q:\n  if a == q[-1]:q.pop()\n  elif a > q[-1]:f(a);break\n  else:f(a)\n else:f(a)\n m=max(m,a)\nif l(q)==0 or l(q)==1 and q[0]==m:p('YES')\nelse:p('NO')", "import collections as c\ni,p=input,print\nn,m,q=int(i()),0,c.deque()\nf,l=q.append,len\nfor a in map(int,i().split()):\n if q:\n  if a==q[-1]:q.pop()\n  elif a>q[-1]:f(a);break\n  else:f(a)\n else:f(a)\n m=max(m,a)\nif l(q)==0 or l(q)==1 and q[0]==m:p('YES')\nelse:p('NO')", "import collections as c\ni,p,l,j=input,print,len,int\nn,m,q=j(i()),0,c.deque()\nf=q.append\nfor a in map(j,i().split()):\n if q:\n  if a==q[-1]:q.pop()\n  elif a>q[-1]:f(a);break\n  else:f(a)\n else:f(a)\n m=max(m,a)\np('YES') if l(q)==0 or l(q)==1 and q[0]==m else p('NO')", "i,p,l,j=input,print,len,int\nn,m,q=j(i()),0,[]\nf=q.append\nfor a in map(j,i().split()):\n if q:\n  if a==q[-1]:q.pop()\n  elif a>q[-1]:f(a);break\n  else:f(a)\n else:f(a)\n m=max(m,a)\nif l(q)==0 or l(q)==1 and q[0]==m:p('YES')\nelse:p('NO')", "i,p,l=input,print,len\nn,m,q=int(i()),0,[]\nf=q.append\nfor a in map(int,i().split()):\n if q:\n  if a==q[-1]:q.pop()\n  elif a>q[-1]:f(a);break\n  else:f(a)\n else:f(a)\n m=max(m,a)\np('YES') if l(q)==0 or l(q)==1 and q[0]==m else p('NO')", "i,p=input,print\nn,m,q=int(i()),0,[]\nf=q.append\nfor a in map(int,i().split()):\n if q:\n  if a==q[-1]:q.pop()\n  elif a>q[-1]:f(a);break\n  else:f(a)\n else:f(a)\n m=max(m,a)\np('YES') if len(q)==0 or len(q)==1 and q[0]==m else p('NO')", "i = int(input())\ns = input().split()\nm = max (list(map(int,s)))\nl = []\nfor j in s:\n    if not l or  int(j) < l[-1] :\n        l.append(int(j))\n    elif int(j) == l[-1]:\n        l.pop()\n    else:\n        print('NO')\n        return\n\nif (len(l) ==1 and l[0] >= m) or len(l) == 0 :\n    print('YES')\nelse:\n    print('NO')\n\n\n", "i,p=input,print;n,m,q=int(i()),0,[];f=q.append\nfor a in map(int,i().split()):\n if q:\n  if a==q[-1]:q.pop()\n  elif a>q[-1]:f(a);break\n  else:f(a)\n else:f(a)\n m=max(m,a)\np('YES'if len(q)==0 or len(q)==1 and q[0]==m else'NO')", "i = int(input())\ns = input().split()\nm = max (list(map(int,s)))\nl = []\nfor j in s:\n    if not l or  int(j) < l[-1] :\n        l.append(int(j))\n    elif int(j) == l[-1]:\n        l.pop()\n    else:\n        print('NO')\n        return\n\nif (len(l) ==1 and l[0] >= m) or len(l) == 0 :\n    print('YES')\nelse:\n    print('NO')\n", "def f():\n    b = [a[0]]\n    for e in a[1:]:\n        if b != []:\n            if e > b[-1]:\n                print('NO')\n                return\n            elif e == b[-1]:\n                b.pop()\n            else:\n                b.append(e)\n        else:\n            b.append(e)\n\n    if len(b)==0:\n        print('YES')\n\n    else:\n        if len(set(b))==1 and b[0]==max(a):\n            print('YES')\n        else:\n            print('NO')\n\nn=int(input())\na=[int(i) for i in input().split()]\n\n\nf()", "from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import defaultdict\nfrom itertools import combinations\nimport functools\nimport sys\nimport math\nMAX = sys.maxsize\nMAXN = 10**6+10\nMOD = 998244353\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN():\n    return(list(map(int,sys.stdin.readline().strip().split())))\n\ndef charIN():\n    return(sys.stdin.readline().strip().split())\n\nt = [(-1,-1)]*1000010\n\ndef create(a):\n\tnonlocal t,n\n\tfor i in range(n,2*n):\n\t\tt[i] = (a[i-n],i-n)\n\tfor i in range(n-1,0,-1):\n\t\tx = [t[2*i],t[2*i+1]]\n\t\tx.sort(key = lambda x:x[0])\n\t\tt[i] = x[1]\n\ndef update(idx,value):\n\tnonlocal t,n\n\tidx = idx+n\n\tt[idx] = value\n\n\twhile(idx>1):\n\t\tidx = idx//2\n\t\tx = [t[2*idx],t[2*idx+1]]\n\t\tx.sort(key = lambda x:x[0])\n\t\tt[idx] = x[1]\n\n\ndef dis(a,b,k):\n\tans = 0\n\tfor i in range(k):\n\t\tans+=abs(a[i]-b[i])\n\treturn ans\n\n\ndef cal(n,k):\n\tres = 1\n\tc = [0]*(k+1)\n\tc[0]=1\n\tfor i in range(1,n+1):\n\t    for j in range(min(i,k),0,-1):\n\t        c[j] = (c[j]+c[j-1])%MOD\n\treturn c[k]\n\n\nn = int(input())\nl = list(numIN())\nx = []\nfor i in range(n):\n\tif x and x[-1]==l[i]:\n\t\tx.pop()\n\t\tcontinue\n\tif x and x[-1]<l[i]:\n\t\tprint('NO')\n\t\treturn\n\tx.append(l[i])\nif x and x[-1]!=max(l):\n\tprint('NO')\nelse:\n\tprint('YES')\n\n\n\n\n\n\n\n\n", "import sys\nsys.setrecursionlimit(3000)\n\nn = int(input())\na = list(map(int, input().split()))\nM = max(a)\nm = min(a)\na = list([x - m for x in a])\n\ndef build(begin, target):\n\tstack = []\n\tnonlocal n, a\n\ti = begin\n\tcurrenth = a[begin]\n\t# print(a, currenth)\n\twhile i < n:\n\t\twhile i + 1 < n and a[i + 1] == currenth:\n\t\t\ti += 1\n\t\tif i == n - 1:\n\t\t\tif not stack:\n\t\t\t\treturn i\n\t\t\telif (i - begin + 1) % 2 != 0 and a[i] != target:\n\t\t\t\treturn -1\n\t\t\telse:\n\t\t\t\ttarget, currenth, begin = stack.pop()\n\t\telif a[i + 1] > currenth:\n\t\t\tif (i - begin + 1) % 2 != 0:\n\t\t\t\treturn -1\n\t\t\telif a[i + 1] >= target:\n\t\t\t\tif not stack:\n\t\t\t\t\treturn i\n\t\t\t\telse:\n\t\t\t\t\ttarget, currenth, begin = stack.pop()\n\t\t\telse:\n\t\t\t\tcurrenth = a[i + 1]\n\t\t\t\ti += 1\n\t\telse: # a[i + 1] < currenth\n\t\t\tstack.append((target, currenth, begin))\n\t\t\t# print(stack, i)\n\t\t\ti += 1\n\t\t\ttarget = currenth\n\t\t\tcurrenth = a[i]\n\t\t\tbegin = i\n\nres = build(0, M)\n# print(res)\nwhile res != -1 and res < n - 1:\n\tres = build(res + 1, M)\n\tprint(res)\nif res == n - 1:\n\tprint('YES')\nelse:\n\t# print(build(0, M))\n\tprint('NO')\n", "import sys\nsys.setrecursionlimit(3000)\n\nn = int(input())\na = list(map(int, input().split()))\nM = max(a)\nm = min(a)\na = list([x - m for x in a])\n\ndef build(begin, target):\n\tstack = []\n\tnonlocal n, a\n\ti = begin\n\tcurrenth = a[begin]\n\t# print(a, currenth)\n\twhile i < n:\n\t\twhile i + 1 < n and a[i + 1] == currenth:\n\t\t\ti += 1\n\t\tif i == n - 1:\n\t\t\tif not stack:\n\t\t\t\treturn i\n\t\t\telif (i - begin + 1) % 2 != 0:\n\t\t\t\treturn -1\n\t\t\telse:\n\t\t\t\ttarget, currenth, begin = stack.pop()\n\t\telif a[i + 1] > currenth:\n\t\t\tif (i - begin + 1) % 2 != 0:\n\t\t\t\treturn -1\n\t\t\telif a[i + 1] >= target:\n\t\t\t\tif not stack:\n\t\t\t\t\treturn i\n\t\t\t\telse:\n\t\t\t\t\ttarget, currenth, begin = stack.pop()\n\t\t\telse:\n\t\t\t\tcurrenth = a[i + 1]\n\t\t\t\ti += 1\n\t\telse: # a[i + 1] < currenth\n\t\t\tstack.append((target, currenth, begin))\n\t\t\t# print(stack, i)\n\t\t\ti += 1\n\t\t\ttarget = currenth\n\t\t\tcurrenth = a[i]\n\t\t\tbegin = i\n\nres = build(0, M)\n# print(res)\nwhile res != -1 and res < n - 1:\n\tres = build(res + 1, M)\n\t# print(res)\nif res == n - 1:\n\tprint('YES')\nelse:\n\t# print(build(0, M))\n\tprint('NO')\n", "n=int(input())\nl=[int(x) for x in  input().split()]\nst=[]\nfor i in l:\n    d=i\n    if len(st) and st[-1]==d:\n        st.pop()\n    elif len(st)==0 or st[-1]>d:\n        st.append(d)\n    else:\n        print(\"NO\")\n        break\nelse:\n    if len(st)==0 or len(st)==1 and st[-1]==max(l):\n        print(\"YES\")\n    else:\n        print(\"NO\")", "n = int(input())\na = list(map(int, input().split()))\nk = max(a)\nf = -1\nq = (10 ** 6) * [-1]\npnt = -1\nans = \"YES\"\nfor i in range(n):\n    if pnt == -1:\n        pnt += 1\n        q[pnt] = a[i]\n        f = i\n    else :\n        if q[pnt] == a[i]:\n            q[pnt] = -1\n            pnt -= 1\n        elif q[pnt] < a[i]:\n            ans = \"NO\"\n        else:\n            pnt += 1\n            q[pnt] = a[i]\n            f = i\nif pnt == 0:\n    if q[0] != k:\n        ans = \"NO\"\nif pnt > 0 or(f == n -1 and a[-1] != k):\n    ans = \"NO\"\nprint(ans)\n", "n=int(input())\na=list(map(int,input().split()))\nm=max(a)\nb=[]\nfor i in a:\n    b.append(m-i)\nst=[b[0]]\nfor i in range(1,n):\n    if st and st[-1]==b[i]:\n        st.pop()\n    elif st and b[i]>st[-1]:\n        st.append(b[i])\n    elif st:\n        print('NO');return\n    else:\n        st.append(b[i])\nif len(st)==0 or st[-1]==0:\n    print('YES')\nelse:\n    print('NO')", "n=int(input())\nb=-1\na=input().split()\nl,r=[],True\nfor i in a:\n    tmp=int(i)\n    b=max(b,tmp)\n    if l==[] or l[-1]>tmp: l.append(tmp)\n    elif l[-1]==tmp: l.pop()\n    else: r=False;break;\n        \nprint(\"YES\" if r and (len(l)==0 or (len(l)==1 and l[0]>=b)) else \"NO\")", "n=int(input())\nl=list(map(int,input().split()))\nk=max(l)\ns=[]\ni=0\nd=0\nwhile(i<len(l)):\n    if(len(s)==0):\n        s.append(l[i])\n    elif(s[-1]==l[i]):\n        s.pop()\n    elif(s[-1]!=l[i]):\n        if(s[-1]<l[i]):\n            print(\"NO\")\n            d=1\n            break\n        s.append(l[i])\n    i+=1\nif(d==0):\n    if(len(s)==0 or (len(s)==1 and s[0]==k)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "n = int(input())\na = [i for i in map(int, input().split(' '))]\nmx = max(a)\nstack = [a[0]]\nq = True\nfor i in range(1, n):\n    if len(stack) != 0:\n        if a[i] == stack[-1]:\n            stack.pop()\n        elif a[i] > stack[-1]:\n            q = False\n            break\n        else:\n            stack.append(a[i])\n    else:\n        stack.append(a[i])\nif len(stack) > 1 or (len(stack) == 1 and stack.pop() != mx):\n    q = False\nif q:\n    print('YES')\nelse:\n    print('NO')\n", "n=int(input())\na=list(map(int,input().split()))\nb=[0]*1000000\nsp=-1\nmax=0\nf=True;       \nfor i in range(n):\n    sp=sp+1\n    b[sp]=a[i]\n    if b[sp]>max:\n        max=b[sp]\n    if sp>0:\n        if b[sp]>b[sp-1]:\n            f=False\n    \n        if b[sp]==b[sp-1]:\n            sp=sp-2\n\nif f==True  :\n    if sp==0:\n        if b[sp]>=max:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n            \n    elif sp<0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    \nelse:\n    print(\"NO\")\n             \n             \n             \n"]