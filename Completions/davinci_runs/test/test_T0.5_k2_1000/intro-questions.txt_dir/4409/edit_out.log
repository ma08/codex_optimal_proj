2022-04-11 19:57:35.313114 num operations 2
2022-04-11 19:57:35.313156 size on input set 1
2022-04-11 19:57:39.061105 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements in the array\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements in the array\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous subsequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous subsequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649721455,
  "object": "edit"
}
2022-04-11 19:57:39.061499 fix spelling mistakes 2 ["\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements in the array\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements in the array\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous subsequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous subsequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"]
2022-04-11 19:57:39.061760 size on output set 2
2022-04-11 19:57:39.061784 size on input set 2
2022-04-11 19:57:44.376623 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous subsequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous subsequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous subsequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous subsequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):  # initialize adjacency list\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649721459,
  "object": "edit"
}
2022-04-11 19:57:44.377294 fix syntax errors 2 ["\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous subsequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous subsequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    #print(a)\n    \n    # build list of indices of first and last element of each contiguous subsequence of equal elements\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    #print(indices)\n    \n    # build graph\n    # each node is a contiguous subsequence of equal elements\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):  # initialize adjacency list\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    #print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    #print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    #print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"]
2022-04-11 19:57:48.635932 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements in the array\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements in the array\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements in the array\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements in the array\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649721464,
  "object": "edit"
}
2022-04-11 19:57:48.636333 fix syntax errors 2 ["\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements in the array\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements in the array\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nfrom collections import deque\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = [int(x) for x in sys.stdin.readline().split()]\n    # print(a)\n    \n    # build list of indices of first and last element of each contiguous sequence of equal elements in the array\n    indices = []\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] == a[i]:\n            j += 1\n        indices.append((i, j - 1))\n        i = j\n    # print(indices)\n    \n    # build graph\n    # each node is a contiguous sequence of equal elements in the array\n    # edges are added between two nodes if the two nodes are adjacent in the array\n    # the weight of each edge is the distance between the two nodes\n    adj_list = {}\n    for i in range(len(indices)):\n        adj_list[i] = []\n    for i in range(len(indices) - 1):\n        (x1, y1) = indices[i]\n        (x2, y2) = indices[i + 1]\n        if y1 == x2 - 1:\n            adj_list[i].append((i + 1, a[y1] - a[x2]))\n        elif x1 == y2 + 1:\n            adj_list[i + 1].append((i, a[x1] - a[y2]))\n    # print(adj_list)\n    \n    # use dijkstra's algorithm to find the shortest path from any node to the node with the smallest value\n    # the shortest path from any node to the node with the smallest value is the path that results in the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    min_node = min(adj_list, key=lambda x: a[indices[x][0]])\n    dist = {}\n    for i in range(len(indices)):\n        dist[i] = float('inf')\n    dist[min_node] = 0\n    q = deque()\n    q.append(min_node)\n    while q:\n        u = q.popleft()\n        for v, w in adj_list[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append(v)\n    # print(dist)\n    \n    # generate output\n    # the output is the path from any node to the node with the smallest value\n    # the path from any node to the node with the smallest value can be found by starting from the node with the smallest value and going backwards\n    output = []\n    curr_node = min_node\n    while curr_node != 0:\n        for v, w in adj_list[curr_node]:\n            if dist[curr_node] == dist[v] + w:\n                if w > 0:\n                    output.append((1, curr_node + 1, v + 1))\n                else:\n                    output.append((2, curr_node + 1, v + 1))\n                curr_node = v\n                break\n    # print(output)\n    \n    print(len(output))\n    for op in output:\n        print(' '.join([str(x) for x in op]))\n    \nif __name__ == '__main__':\n    main()\n"]
2022-04-11 19:57:48.636392 size on output set 4
2022-04-11 19:57:48.636410 num operations 2
2022-04-11 19:57:48.636415 size on input set 1
2022-04-11 19:57:50.705766 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 1,
      "text": "\n# cook your dish here\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    }
  ],
  "created": 1649721468,
  "object": "edit"
}
2022-04-11 19:57:50.706237 fix spelling mistakes 2 ['\n\n# cook your dish here.\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '\n# cook your dish here\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n']
2022-04-11 19:57:50.706319 size on output set 2
2022-04-11 19:57:50.706334 size on input set 2
2022-04-11 19:57:55.605230 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 1,
      "text": "\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i,sep=\" \")\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2,sep=\" \")\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i,sep=\" \")\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2,sep=\" \")\n        c+=1\nprint(c)\n"
    }
  ],
  "created": 1649721471,
  "object": "edit"
}
2022-04-11 19:57:55.605894 fix syntax errors 2 ['\n\n# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i,sep=" ")\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2,sep=" ")\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i,sep=" ")\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2,sep=" ")\n        c+=1\nprint(c)\n']
2022-04-11 19:57:57.915335 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    },
    {
      "index": 1,
      "text": "# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n"
    }
  ],
  "created": 1649721475,
  "object": "edit"
}
2022-04-11 19:57:57.915693 fix syntax errors 2 ['# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n', '# cook your dish here\nt=int(input())\na=list(map(int,input().split()))\nc=0\nfor i in range(1,t-1):\n    if a[i]<a[i-1]:\n        a[i]=a[i]+abs(a[i]-a[i-1])\n        print(1,i+1,i)\n        c+=1\n    elif a[i]<a[i+1]:\n        a[i]=a[i]+abs(a[i]-a[i+1])\n        print(1,i+1,i+2)\n        c+=1\n    elif a[i]>a[i-1]:\n        a[i]=a[i]-abs(a[i]-a[i-1])\n        print(2,i+1,i)\n        c+=1\n    elif a[i]>a[i+1]:\n        a[i]=a[i]-abs(a[i]-a[i+1])\n        print(2,i+1,i+2)\n        c+=1\nprint(c)\n']
2022-04-11 19:57:57.915738 size on output set 3
