["\n\n# Accepted\n\nfrom math import factorial\n\ndef nCr(n, r):\n    return factorial(n) / (factorial(r) * factorial(n - r))\n\ndef main():\n    # Get input\n    n = [int(x) for x in input().split()]\n    k = int(input())\n\n    # Calculate number of ways to deal cards\n    ways = 0\n    for i in range(1, k + 1):\n        ways += n[i - 1] * nCr(sum(n) - i, k - i)\n\n    # Print number of ways\n    print(ways)\n\nif __name__ == '__main__':\n    main()", "\n\ndef get_factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    if num == 2:\n        return 2\n    return num * get_factorial(num - 1)\n\ndef get_n_choose_k(n, k):\n    return get_factorial(n) / (get_factorial(k) * get_factorial(n - k))\n\ndef get_num_ways(cards, k):\n    num_ways = 0\n    for i in range(k):\n        num_ways += cards[i] * get_n_choose_k(sum(cards) - cards[i], k - i - 1)\n    return num_ways\n\nif __name__ == \"__main__\":\n    cards = [int(i) for i in input().split()]\n    k = int(input())\n    print(get_num_ways(cards, k))", "\n\nn = [int(i) for i in input().split()]\nk = int(input())\n\ndef fact(n):\n    ans = 1\n    for i in range(1, n+1):\n        ans *= i\n    return ans\n\ndef ncr(n, r):\n    return int(fact(n)/(fact(r)*fact(n-r)))\n\nif k == 1:\n    print(sum(n))\nelse:\n    ans = 0\n    for i in range(1, k+1):\n        ans += n[i-1]*ncr(sum(n[i:]), k-i)\n    print(ans)", "\n\nimport math\nimport operator as op\nfrom functools import reduce\n\ndef ncr(n, r):\n    r = min(r, n-r)\n    if r == 0: return 1\n    numer = reduce(op.mul, range(n, n-r, -1))\n    denom = reduce(op.mul, range(1, r+1))\n    return numer//denom\n\ndef main():\n    card_counts = list(map(int, input().strip().split()))\n    k = int(input().strip())\n\n    # If there are not enough cards to deal, return 0\n    if sum(card_counts) < k:\n        print(0)\n        return\n\n    # If there are exactly k cards to deal, return 1\n    if sum(card_counts) == k:\n        print(1)\n        return\n\n    # If there are more cards to deal than numbers, return 0\n    if k > 10:\n        print(0)\n        return\n\n    # Find the number of combinations\n    combinations = 0\n    for i in range(k):\n        combinations += ncr(sum(card_counts[i:]), k-i)\n\n    print(combinations)\n\nif __name__ == '__main__':\n    main()", "\nfrom collections import Counter\n\ndef get_input():\n    n = [int(x) for x in input().split()]\n    k = int(input())\n    return n, k\n\ndef get_value(n, k, dp):\n    if n[0] == 0:\n        return 0\n    if dp[n[0]][k] == -1:\n        if k == 1:\n            dp[n[0]][k] = n[0]\n        elif k == 2:\n            dp[n[0]][k] = n[0] * (n[0] - 1) / 2\n        else:\n            dp[n[0]][k] = sum([get_value(n[1:], k-1, dp) * n[0] for i in range(k)])\n    return dp[n[0]][k]\n\ndef get_answer(n, k):\n    dp = [[-1 for i in range(k + 1)] for j in range(k + 1)]\n    return int(get_value(n, k, dp))\n\ndef main():\n    n, k = get_input()\n    print(get_answer(n, k))\n\nif __name__ == \"__main__\":\n    main()", "\n\n#Solution\nimport itertools\n\nnum_cards = [int(x) for x in input().split()]\nk = int(input())\n\ndef is_ascending(lst):\n    return all(lst[i] < lst[i+1] for i in range(len(lst)-1))\n\ndef count_ascending(deck, k):\n    count = 0\n    for hand in itertools.combinations(deck, k):\n        if is_ascending(hand):\n            count += 1\n    return count\n\nprint(count_ascending(num_cards, k))", "\nimport sys\n\ndef get_input():\n    \"\"\"\n    Reads the input from stdin and returns it as a list.\n\n    :return: int[]\n    \"\"\"\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef get_cards(numbers):\n    \"\"\"\n    Returns a list of cards based on the input list.\n\n    :param numbers: int[]\n    :return: int[]\n    \"\"\"\n    cards = []\n    for i in range(len(numbers)):\n        cards += [i+1] * numbers[i]\n    return cards\n\ndef get_num_permutations(cards, K):\n    \"\"\"\n    Returns the number of permutations of the cards.\n\n    :param cards: int[]\n    :param K: int\n    :return: int\n    \"\"\"\n    return len(get_permutations(cards, K))\n\ndef get_permutations(cards, K):\n    \"\"\"\n    Returns a list of permutations of the cards.\n\n    :param cards: int[]\n    :param K: int\n    :return: int[]\n    \"\"\"\n    if K == 1:\n        return cards\n    permutations = []\n    for i in range(len(cards)):\n        card = cards[i]\n        sub_cards = cards[:i] + cards[i+1:]\n        sub_permutations = get_permutations(sub_cards, K-1)\n        for sub_permutation in sub_permutations:\n            if card < sub_permutation[0]:\n                permutations.append([card] + sub_permutation)\n    return permutations\n\ndef main():\n    \"\"\"\n    Main function.\n    \"\"\"\n    numbers = get_input()\n    K = int(sys.stdin.readline().strip())\n    cards = get_cards(numbers)\n    num_permutations = get_num_permutations(cards, K)\n    print(num_permutations)\n\nif __name__ == \"__main__\":\n    main()", "\n\nimport sys\n\nnumbers = [int(n) for n in sys.stdin.readline().split()]\nK = int(sys.stdin.readline())\n\ndef count_ascending_combos(numbers, K):\n    # Base case: if there are no more cards left to deal, return 1\n    if K == 0:\n        return 1\n    # Base case: if there are more cards to deal than there are cards in the deck, return 0\n    elif sum(numbers) < K:\n        return 0\n    else:\n        # Initialize with the number of ways to deal a strictly ascending sequence without the first card\n        ways = count_ascending_combos([n - 1 for n in numbers], K - 1)\n        # Add the number of ways to deal a strictly ascending sequence with the first card\n        ways += sum([count_ascending_combos([n - 1 for n in numbers], K - 1 - i) for i in range(numbers[0])])\n        return ways\n\nprint(count_ascending_combos(numbers, K))"]