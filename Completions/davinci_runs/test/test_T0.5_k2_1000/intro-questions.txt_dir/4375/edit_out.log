2022-04-11 19:44:24.502442 num operations 2
2022-04-11 19:44:24.502495 size on input set 1
2022-04-11 19:44:29.023280 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)  # We don't choose the root\ndp[root][1] = max(dp[child][0] for child in children)  # We choose the root\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtrees of the root, and the root can't be in the subtrees.\n2. If we don't choose the root, then we can choose the root and the subtrees of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    }
  ],
  "created": 1649720664,
  "object": "edit"
}
2022-04-11 19:44:29.023877 fix spelling mistakes 2 ['\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)  # We don\'t choose the root\ndp[root][1] = max(dp[child][0] for child in children)  # We choose the root\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtrees of the root, and the root can\'t be in the subtrees.\n2. If we don\'t choose the root, then we can choose the root and the subtrees of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n']
2022-04-11 19:44:29.023979 size on output set 2
2022-04-11 19:44:29.023992 size on input set 2
2022-04-11 19:44:35.106095 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)  # We don't choose the root\ndp[root][1] = max(dp[child][0] for child in children)  # We choose the root\n\"\"\"\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]  # graph[i] is the children of i\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can't be in the subtree.\n2. If we don't choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)  # We don't choose the root\ndp[root][1] = max(dp[child][0] for child in children)  # We choose the root\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    }
  ],
  "created": 1649720669,
  "object": "edit"
}
2022-04-11 19:44:35.106427 fix syntax errors 2 ['\n\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)  # We don\'t choose the root\ndp[root][1] = max(dp[child][0] for child in children)  # We choose the root\n"""\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]  # graph[i] is the children of i\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtree of the root, and the root can\'t be in the subtree.\n2. If we don\'t choose the root, then we can choose the root and the subtree of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)  # We don\'t choose the root\ndp[root][1] = max(dp[child][0] for child in children)  # We choose the root\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n']
2022-04-11 19:44:37.331391 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtrees of the root, and the root can't be in the subtrees.\n2. If we don't choose the root, then we can choose the root and the subtrees of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\"\"\"\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtrees of the root, and the root can't be in the subtrees.\n2. If we don't choose the root, then we can choose the root and the subtrees of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n\"\"\"\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n"
    }
  ],
  "created": 1649720675,
  "object": "edit"
}
2022-04-11 19:44:37.331714 fix syntax errors 2 ['\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtrees of the root, and the root can\'t be in the subtrees.\n2. If we don\'t choose the root, then we can choose the root and the subtrees of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n', '\n"""\nThis is a tree problem.\n\nThere are 2 cases:\n1. If we choose the root, then we can only choose the subtrees of the root, and the root can\'t be in the subtrees.\n2. If we don\'t choose the root, then we can choose the root and the subtrees of the root.\n\nSo the recurrence is:\ndp[root][0] = max(dp[child][0] + dp[child][1] for child in children)\ndp[root][1] = max(dp[child][0] for child in children)\n"""\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(root):\n    dp[root][0] = 0\n    dp[root][1] = 0\n    for child in graph[root]:\n        dfs(child)\n        dp[root][0] += max(dp[child][0], dp[child][1])\n        dp[root][1] += dp[child][0]\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ndp = [[0, 0] for _ in range(n + 1)]\ndfs(1)\n\nans = max(dp[1][0], dp[1][1])\nprint(ans)\n']
2022-04-11 19:44:37.331768 size on output set 3
2022-04-11 19:44:37.331803 num operations 2
2022-04-11 19:44:37.331812 size on input set 1
2022-04-11 19:44:39.854406 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649720677,
  "object": "edit"
}
2022-04-11 19:44:39.854755 fix spelling mistakes 2 ["\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-11 19:44:39.854791 size on output set 1
2022-04-11 19:44:39.854802 size on input set 1
2022-04-11 19:44:42.363252 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649720680,
  "object": "edit"
}
2022-04-11 19:44:42.363699 fix syntax errors 2 ["\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef read_line_from_stdin() -> str:\n    return sys.stdin.readline().rstrip()\n\ndef main() -> None:\n    pass\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-11 19:44:42.363896 size on output set 1
