2022-04-11 20:21:09.030599 num operations 2
2022-04-11 20:21:09.030637 size on input set 1
2022-04-11 20:21:11.619331 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n# fopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n# fopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649722869,
  "object": "edit"
}
2022-04-11 20:21:11.619725 fix spelling mistakes 2 ['\n\nimport sys\nimport os\nimport heapq\nimport math\n\n# fopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, "input.txt"), "r")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == "L":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == "R":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport os\nimport heapq\nimport math\n\n# fopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, "input.txt"), "r")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == "L":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == "R":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-11 20:21:11.620018 size on output set 1
2022-04-11 20:21:11.620033 size on input set 1
2022-04-11 20:21:14.859216 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport os\nimport heapq\nimport math\n# fopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n#\n# fopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, \"input.txt\"), \"r\")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == \"L\":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == \"R\":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649722871,
  "object": "edit"
}
2022-04-11 20:21:14.859724 fix syntax errors 2 ['\nimport sys\nimport os\nimport heapq\nimport math\n# fopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, "input.txt"), "r")\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == "L":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == "R":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport os\nimport heapq\nimport math\n#\n# fopen equivalent\nabs_dir = os.path.dirname(os.path.abspath(__file__))\nsys.stdin = open(os.path.join(abs_dir, "input.txt"), "r")\n\n\nclass LinkedList:\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.prev = None\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_left(self, data):\n        new_node = self.Node(data)\n        new_node.next = self.head\n        if self.head:\n            self.head.prev = new_node\n        else:\n            self.tail = new_node\n        self.head = new_node\n\n    def insert_right(self, data):\n        new_node = self.Node(data)\n        new_node.prev = self.tail\n        if self.tail:\n            self.tail.next = new_node\n        else:\n            self.head = new_node\n        self.tail = new_node\n\n    def remove_left(self):\n        if self.head:\n            self.head = self.head.next\n            if self.head:\n                self.head.prev = None\n            else:\n                self.tail = None\n\n    def remove_right(self):\n        if self.tail:\n            self.tail = self.tail.prev\n            if self.tail:\n                self.tail.next = None\n            else:\n                self.head = None\n\n    def get_leftmost(self):\n        if self.head:\n            return self.head.data\n\n    def get_rightmost(self):\n        if self.tail:\n            return self.tail.data\n\n    def get_left_distance(self, data):\n        distance = 0\n        curr_node = self.head\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.next\n        return None\n\n    def get_right_distance(self, data):\n        distance = 0\n        curr_node = self.tail\n        while curr_node:\n            if curr_node.data == data:\n                return distance\n            distance += 1\n            curr_node = curr_node.prev\n        return None\n\n    def print_list(self):\n        curr_node = self.head\n        while curr_node:\n            print(curr_node.data)\n            curr_node = curr_node.next\n\n\ndef main():\n    num_queries = int(sys.stdin.readline().strip())\n    linked_list = LinkedList()\n    for _ in range(num_queries):\n        query = sys.stdin.readline().strip().split()\n        if query[0] == "L":\n            linked_list.insert_left(int(query[1]))\n        elif query[0] == "R":\n            linked_list.insert_right(int(query[1]))\n        else:\n            left_distance = linked_list.get_left_distance(int(query[1]))\n            right_distance = linked_list.get_right_distance(int(query[1]))\n            if left_distance is not None:\n                print(left_distance)\n            else:\n                print(right_distance)\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-11 20:21:14.859814 size on output set 2
2022-04-11 20:21:14.859850 num operations 2
2022-04-11 20:21:14.859857 size on input set 1
2022-04-11 20:21:16.922466 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    # Get the number of queries\n    q = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = input().split()\n\n        # If it's a left query\n        if query[0] == 'L':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it's a right query\n        elif query[0] == 'R':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    # Get the number of queries\n    q = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = input().split()\n\n        # If it's a left query\n        if query[0] == 'L':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it's a right query\n        elif query[0] == 'R':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it's a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649722875,
  "object": "edit"
}
2022-04-11 20:21:16.922842 fix spelling mistakes 2 ['\ndef main():\n    # Get the number of queries\n    q = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = input().split()\n\n        # If it\'s a left query\n        if query[0] == \'L\':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it\'s a right query\n        elif query[0] == \'R\':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it\'s a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    # Get the number of queries\n    q = int(input())\n\n    # Initialize the shelf\n    shelf = []\n\n    # Loop over the queries\n    for i in range(q):\n        # Get the query\n        query = input().split()\n\n        # If it\'s a left query\n        if query[0] == \'L\':\n            # Add it to the left of the shelf\n            shelf.insert(0, int(query[1]))\n\n        # If it\'s a right query\n        elif query[0] == \'R\':\n            # Add it to the right of the shelf\n            shelf.append(int(query[1]))\n\n        # If it\'s a question\n        else:\n            # Find the index of the book\n            index = shelf.index(int(query[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(shelf) - index - 1))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-11 20:21:16.923076 size on output set 1
2022-04-11 20:21:16.923086 size on input set 1
2022-04-11 20:21:33.501197 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the books\n    books = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input().split()\n\n        # If it's a left book\n        if book[0] == 'L':\n            # Add it to the left of the books\n            books.insert(0, int(book[1]))\n\n        # If it's a right book\n        elif book[0] == 'R':\n            # Add it to the right of the books\n            books.append(int(book[1]))\n\n            # Find the index of the book\n            index = books.index(int(book[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(books) - index - 1))\n\n\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the books\n    books = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input().split()\n\n        # If it's a left book\n        if book[0] == 'L':\n            # Add it to the left of the books\n            books.insert(0, int(book[1]))\n\n        # If it's a right book\n        elif book[0] == 'R':\n            # Add it to the right of the books\n            books.append(int(book[1]))\n\n        # If it's a book\n        else:\n            # Find the index of the book\n            index = books.index(int(book[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(books) - index - 1))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    print(\"Hello World\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649722877,
  "object": "edit"
}
2022-04-11 20:21:33.501338 fix syntax errors 2 ['\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the books\n    books = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input().split()\n\n        # If it\'s a left book\n        if book[0] == \'L\':\n            # Add it to the left of the books\n            books.insert(0, int(book[1]))\n\n        # If it\'s a right book\n        elif book[0] == \'R\':\n            # Add it to the right of the books\n            books.append(int(book[1]))\n\n            # Find the index of the book\n            index = books.index(int(book[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(books) - index - 1))\n\n\ndef main():\n    # Get the number of books\n    n = int(input())\n\n    # Initialize the books\n    books = []\n\n    # Loop over the books\n    for i in range(n):\n        # Get the book\n        book = input().split()\n\n        # If it\'s a left book\n        if book[0] == \'L\':\n            # Add it to the left of the books\n            books.insert(0, int(book[1]))\n\n        # If it\'s a right book\n        elif book[0] == \'R\':\n            # Add it to the right of the books\n            books.append(int(book[1]))\n\n        # If it\'s a book\n        else:\n            # Find the index of the book\n            index = books.index(int(book[1]))\n\n            # Print the minimum number of books to pop\n            print(min(index, len(books) - index - 1))\n\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    print("Hello World")\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-11 20:21:33.501362 size on output set 2
