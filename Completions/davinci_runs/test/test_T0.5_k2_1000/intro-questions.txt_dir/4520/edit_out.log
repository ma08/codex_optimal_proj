2022-04-11 20:44:43.469297 num operations 2
2022-04-11 20:44:43.469328 size on input set 1
2022-04-11 20:44:49.126732 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove(n))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove(n))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649724284,
  "object": "edit"
}
2022-04-11 20:44:49.127306 fix spelling mistakes 2 ['\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove(n))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove(n))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n']
2022-04-11 20:44:49.127448 size on output set 1
2022-04-11 20:44:49.127464 size on input set 1
2022-04-11 20:44:57.495594 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove(n))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k).remove(n)))\n    print(\" \".join(map(str, SegmentTree(segments, k).remove(n) + 1)))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649724289,
  "object": "edit"
}
2022-04-11 20:44:57.495928 fix syntax errors 2 ['\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove(n))))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    segments = []\n    for i in range(n):\n        segments.append(list(map(int, sys.stdin.readline().split())))\n    print(n - len(SegmentTree(segments, k).remove(n)))\n    print(" ".join(map(str, SegmentTree(segments, k).remove(n) + 1)))\n\nclass SegmentTree:\n    def __init__(self, segments, k):\n        self.segments = sorted(segments, key=lambda x: x[0])\n        self.k = k\n        self.tree = []\n        self.build(0, len(segments) - 1, 0)\n\n    def build(self, left, right, i):\n        if left == right:\n            self.tree.append(self.segments[left])\n            return\n        mid = (left + right) // 2\n        self.build(left, mid, 2 * i + 1)\n        self.build(mid + 1, right, 2 * i + 2)\n        self.tree.append(self.merge(self.tree[2 * i + 1], self.tree[2 * i + 2]))\n\n    def merge(self, s1, s2):\n        if s1[0] > s2[1]:\n            return s1\n        if s2[0] > s1[1]:\n            return s2\n        return [min(s1[0], s2[0]), max(s1[1], s2[1])]\n\n    def query(self, left, right, i, segment):\n        if segment[1] < left or segment[0] > right:\n            return 0\n        if left <= segment[0] and right >= segment[1]:\n            return 1\n        mid = (segment[0] + segment[1]) // 2\n        return self.query(left, right, 2 * i + 1, self.tree[2 * i + 1]) + self.query(left, right, 2 * i + 2, self.tree[2 * i + 2])\n\n    def remove(self, n):\n        removed = []\n        for i in range(len(self.tree)):\n            if self.query(self.tree[i][0], self.tree[i][1], 0, self.tree[0]) <= self.k:\n                removed.append(i + 1)\n        return removed\n\nif __name__ == "__main__":\n    main()\n']
2022-04-11 20:44:57.495996 size on output set 2
