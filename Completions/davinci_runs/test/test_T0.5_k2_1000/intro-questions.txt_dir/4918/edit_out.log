2022-04-12 02:57:18.052895 num operations 2
2022-04-12 02:57:18.052926 size on input set 1
2022-04-12 02:57:20.195024 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    },
    {
      "index": 1,
      "text": "\n#\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    }
  ],
  "created": 1649746638,
  "object": "edit"
}
2022-04-12 02:57:20.195252 fix spelling mistakes 2 ['\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n', '\n#\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n']
2022-04-12 02:57:20.195319 size on output set 2
2022-04-12 02:57:20.195329 size on input set 2
2022-04-12 02:57:23.205663 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 1\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 'M':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    },
    {
      "index": 1,
      "text": "\n# \nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    }
  ],
  "created": 1649746640,
  "object": "edit"
}
2022-04-12 02:57:23.205985 fix syntax errors 2 ['\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 1\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'M\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n', '\n# \nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n']
2022-04-12 02:57:26.417642 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't': \n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    },
    {
      "index": 1,
      "text": "import sys\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\nif __name__ == \"__main__\":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n"
    }
  ],
  "created": 1649746643,
  "object": "edit"
}
2022-04-12 02:57:26.417831 fix syntax errors 2 ['\nimport sys\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\n\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\': \n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n', 'import sys\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.rank = 0\n        self.parent = self\nclass DisjointSet:\n    def __init__(self):\n        self.map = {}\n    def make_set(self, val):\n        node = Node(val)\n        self.map[val] = node\n\n    def find_set(self, val):\n        return self.find_set_node(self.map[val])\n    def find_set_node(self, node):\n        parent = node.parent\n        if parent == node:\n            return parent\n        node.parent = self.find_set_node(node.parent)\n        return node.parent\n    def union(self, val1, val2):\n        node1 = self.map[val1]\n        node2 = self.map[val2]\n\n        parent1 = self.find_set_node(node1)\n        parent2 = self.find_set_node(node2)\n\n        if parent1.rank >= parent2.rank:\n            parent1.rank = (parent1.rank + 1) if (parent1.rank == parent2.rank) else parent1.rank\n            parent2.parent = parent1\n        else:\n            parent1.parent = parent2\n\nif __name__ == "__main__":\n    n, q = [int(x) for x in sys.stdin.readline().split()]\n    ds = DisjointSet()\n    for i in range(1, n+1):\n        ds.make_set(i)\n\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == \'t\':\n            ds.union(int(line[1]), int(line[2]))\n        else:\n            print(ds.find_set(int(line[1])).rank + 1)\n']
2022-04-12 02:57:26.417877 size on output set 4
2022-04-12 02:57:26.417900 num operations 2
2022-04-12 02:57:26.417907 size on input set 1
2022-04-12 02:57:30.428499 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef find(node):\n    while node != p[node]:\n        node = p[node]\n    return node\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649746646,
  "object": "edit"
}
2022-04-12 02:57:30.428697 fix spelling mistakes 2 ["import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(node):\n    while node != p[node]:\n        node = p[node]\n    return node\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 02:57:30.428835 size on output set 2
2022-04-12 02:57:30.428848 size on input set 2
2022-04-12 02:57:33.354730 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p \n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649746650,
  "object": "edit"
}
2022-04-12 02:57:33.354885 fix syntax errors 2 ["import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p \n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(x):\n    while x != p[x]:\n        x = p[x]\n    return x\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 02:57:36.278381 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\ndef find(node):\n    while node != p[node]:\n        node = p[node]\n    return node\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p = []\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ndef find(node):\n    while node != p[node]:\n        node = p[node]\n    return node\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649746653,
  "object": "edit"
}
2022-04-12 02:57:36.278567 fix syntax errors 2 ["import sys\n\ndef find(node):\n    while node != p[node]:\n        node = p[node]\n    return node\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p = []\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef find(node):\n    while node != p[node]:\n        node = p[node]\n    return node\n\ndef union(x, y):\n    p1 = find(x)\n    p2 = find(y)\n    if p1 != p2:\n        p[p1] = p2\n\ndef main():\n    n, q = map(int, sys.stdin.readline().split())\n    global p\n    p = [i for i in range(n+1)]\n    for i in range(q):\n        line = sys.stdin.readline().strip().split()\n        if line[0] == 'u':\n            union(int(line[1]), int(line[2]))\n        else:\n            print(p.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 02:57:36.278603 size on output set 4
2022-04-12 02:57:36.278618 num operations 2
2022-04-12 02:57:36.278626 size on input set 1
2022-04-12 02:57:46.530802 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef find(node, parents):\n    if node != parents[node]:\n        parents[node] = find(parents[node], parents)\n    return parents[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef find(node, parents):\n    if node != parents[node]:\n        parents[node] = find(parents[node], parents)\n    return parents[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649746656,
  "object": "edit"
}
2022-04-12 02:57:46.531179 fix spelling mistakes 2 ['\n\ndef find(node, parents):\n    if node != parents[node]:\n        parents[node] = find(parents[node], parents)\n    return parents[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef find(node, parents):\n    if node != parents[node]:\n        parents[node] = find(parents[node], parents)\n    return parents[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 02:57:46.531391 size on output set 1
2022-04-12 02:57:46.531399 size on input set 1
2022-04-12 02:57:55.661283 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef find(node, parents):\n    if node != parents[node]:\n        parents[node] = find(parents[node], parents)\n    return parents[node]\n\ndef merge(node1, node2, parents, size):\n    root1 = find(node1, parents)\n    root2 = find(node2, parents)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parents[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parents = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == 't':\n            merge(int(query[1]), int(query[2]), parents, size)\n        else:\n            print(size[find(int(query[1]), parents)])\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649746666,
  "object": "edit"
}
2022-04-12 02:57:55.661392 fix syntax errors 2 ['\n\ndef find(node, parent):\n    if node != parent[node]:\n        parent[node] = find(parent[node], parent)\n    return parent[node]\n\ndef merge(node1, node2, parent, size):\n    root1 = find(node1, parent)\n    root2 = find(node2, parent)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parent[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parent = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), parent, size)\n        else:\n            print(size[find(int(query[1]), parent)])\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef find(node, parents):\n    if node != parents[node]:\n        parents[node] = find(parents[node], parents)\n    return parents[node]\n\ndef merge(node1, node2, parents, size):\n    root1 = find(node1, parents)\n    root2 = find(node2, parents)\n    if root1 == root2:\n        return\n    if size[root1] < size[root2]:\n        root1, root2 = root2, root1\n    parents[root2] = root1\n    size[root1] += size[root2]\n\ndef main():\n    n, q = map(int, input().split())\n    parents = [i for i in range(n + 1)]\n    size = [1 for i in range(n + 1)]\n    for _ in range(q):\n        query = input().split()\n        if query[0] == \'t\':\n            merge(int(query[1]), int(query[2]), parents, size)\n        else:\n            print(size[find(int(query[1]), parents)])\n\nif __name__ == "__main__":\n    main()\n']
2022-04-12 02:57:55.661409 size on output set 2
2022-04-12 02:57:55.661415 num operations 2
2022-04-12 02:57:55.661418 size on input set 1
2022-04-12 02:57:57.834705 fix spelling mistakes {
  "choices": [
    {
      "error": {
        "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
        "type": "invalid_edit"
      },
      "index": 0
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups \n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"
    }
  ],
  "created": 1649746675,
  "object": "edit"
}
2022-04-12 02:57:57.834808 NO RESULT
2022-04-12 02:57:57.834811 {
  "error": {
    "message": "Could not edit text. Please sample again or try with a different temperature setting, input, or instruction.",
    "type": "invalid_edit"
  },
  "index": 0
}
2022-04-12 02:57:57.834829 fix spelling mistakes 1 ["\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups \n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"]
2022-04-12 02:57:57.834842 size on output set 1
2022-04-12 02:57:57.834845 size on input set 1
2022-04-12 02:58:03.737858 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1] * n\n    group_leader = [i for i in range(n)]  # leader of group i\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1]) - 1\n            b = int(query[2]) - 1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1]) - 1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    # get input, use readline() to read from file\n    n, q = map(int, sys.stdin.readline().split())\n    queries = []\n    for i in range(q):\n        queries.append(sys.stdin.readline().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups \n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a], end='')\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"
    }
  ],
  "created": 1649746678,
  "object": "edit"
}
2022-04-12 02:58:03.738035 fix syntax errors 2 ["\n\ndef main():\n    # get input\n    n, q = map(int, input().split())\n    queries = []\n    for i in range(q):\n        queries.append(input().split())\n\n    # initialize\n    group_sizes = [1] * n\n    group_leader = [i for i in range(n)]  # leader of group i\n\n    # process queries\n    for query in queries:\n        # merge groups\n        if query[0] == 't':\n            a = int(query[1]) - 1\n            b = int(query[2]) - 1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1]) - 1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a])\n\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\n\nmain()\n", "\n\ndef main():\n    # get input, use readline() to read from file\n    n, q = map(int, sys.stdin.readline().split())\n    queries = []\n    for i in range(q):\n        queries.append(sys.stdin.readline().split())\n\n    # initialize\n    group_sizes = [1]*n\n    group_leader = [i for i in range(n)]\n\n    # process queries\n    for query in queries:\n        # merge groups \n        if query[0] == 't':\n            a = int(query[1])-1\n            b = int(query[2])-1\n            leader_a = find_leader(a, group_leader)\n            leader_b = find_leader(b, group_leader)\n            if leader_a != leader_b:\n                group_sizes[leader_b] += group_sizes[leader_a]\n                group_leader[leader_a] = leader_b\n        # print size of group\n        else:\n            a = int(query[1])-1\n            leader_a = find_leader(a, group_leader)\n            print(group_sizes[leader_a], end='')\n\ndef find_leader(a, group_leader):\n    while group_leader[a] != a:\n        a = group_leader[a]\n    return a\n\nmain()\n"]
2022-04-12 02:58:03.738056 size on output set 2
2022-04-12 02:58:03.738064 num operations 2
2022-04-12 02:58:03.738072 size on input set 1
2022-04-12 02:58:05.974738 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n#fix spelling mistakes\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python\n\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    }
  ],
  "created": 1649746683,
  "object": "edit"
}
2022-04-12 02:58:05.975121 fix spelling mistakes 2 ['\n#fix spelling mistakes\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n', '#!/usr/bin/env python\n\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print dsu.size[dsu.find(int(line[1]))]\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n']
2022-04-12 02:58:05.975305 size on output set 2
2022-04-12 02:58:05.975313 size on input set 2
2022-04-12 02:58:08.848211 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/env python\n\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python\n\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    }
  ],
  "created": 1649746686,
  "object": "edit"
}
2022-04-12 02:58:08.848334 fix syntax errors 2 ['#!/usr/bin/env python\n\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n', '#!/usr/bin/env python\n\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n']
2022-04-12 02:58:12.258145 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    },
    {
      "index": 1,
      "text": "\n#fix syntax errors\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == \"s\":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n"
    }
  ],
  "created": 1649746689,
  "object": "edit"
}
2022-04-12 02:58:12.258602 fix syntax errors 2 ['\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n', '\n#fix syntax errors\nimport sys\n\nclass DSU:\n    def __init__(self):\n        self.parent = range(100001)\n        self.ranks = [0]*100001\n        self.size = [1]*100001\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr: return\n        elif self.ranks[xr] < self.ranks[yr]:\n            self.parent[xr] = yr\n            self.size[yr] += self.size[xr]\n        elif self.ranks[xr] > self.ranks[yr]:\n            self.parent[yr] = xr\n            self.size[xr] += self.size[yr]\n        else:\n            self.parent[yr] = xr\n            self.ranks[xr] += 1\n            self.size[xr] += self.size[yr]\n\ndsu = DSU()\n\nfor i in range(input()):\n    line = sys.stdin.readline().split()\n    if line[0] == "s":\n        print(dsu.size[dsu.find(int(line[1]))])\n    else:\n        dsu.union(int(line[1]), int(line[2]))\n']
2022-04-12 02:58:12.258713 size on output set 3
2022-04-12 02:58:12.258729 num operations 2
2022-04-12 02:58:12.258735 size on input set 1
2022-04-12 02:58:14.298707 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    }
  ],
  "created": 1649746692,
  "object": "edit"
}
2022-04-12 02:58:14.299095 fix spelling mistakes 2 ["\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"]
2022-04-12 02:58:14.299143 size on output set 1
2022-04-12 02:58:14.299149 size on input set 1
2022-04-12 02:58:27.002743 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 'u':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 'q':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n): \n        self.sets = [i for i in range(n+1)] \n        self.size = [1 for i in range(n+1)] \n\n    def find(self, i):\n        if self.sets[i] != i: \n            self.sets[i] = self.find(self.sets[i]) \n        return self.sets[i] \n\n    def union(self, i, j):\n        i = self.find(i) \n        j = self.find(j) \n        if i == j: \n            return \n        if self.size[i] < self.size[j]: \n            i, j = j, i \n        self.sets[j] = i \n        self.size[i] += self.size[j] \n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"
    }
  ],
  "created": 1649746694,
  "object": "edit"
}
2022-04-12 02:58:27.002902 fix syntax errors 2 ["\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n):\n        self.sets = [i for i in range(n+1)]\n        self.size = [1 for i in range(n+1)]\n\n    def find(self, i):\n        if self.sets[i] != i:\n            self.sets[i] = self.find(self.sets[i])\n        return self.sets[i]\n\n    def union(self, i, j):\n        i = self.find(i)\n        j = self.find(j)\n        if i == j:\n            return\n        if self.size[i] < self.size[j]:\n            i, j = j, i\n        self.sets[j] = i\n        self.size[i] += self.size[j]\n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 'u':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 'q':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n", "\nimport sys\n\nclass DisjointSets:\n    def __init__(self, n): \n        self.sets = [i for i in range(n+1)] \n        self.size = [1 for i in range(n+1)] \n\n    def find(self, i):\n        if self.sets[i] != i: \n            self.sets[i] = self.find(self.sets[i]) \n        return self.sets[i] \n\n    def union(self, i, j):\n        i = self.find(i) \n        j = self.find(j) \n        if i == j: \n            return \n        if self.size[i] < self.size[j]: \n            i, j = j, i \n        self.sets[j] = i \n        self.size[i] += self.size[j] \n\nn, q = map(int, input().split())\ndisjoint_sets = DisjointSets(n)\nfor _ in range(q):\n    query = input().split()\n    if query[0] == 't':\n        disjoint_sets.union(int(query[1]), int(query[2]))\n    elif query[0] == 's':\n        print(disjoint_sets.size[disjoint_sets.find(int(query[1]))])\n"]
2022-04-12 02:58:27.002918 size on output set 2
2022-04-12 02:58:27.002924 num operations 2
2022-04-12 02:58:27.002927 size on input set 1
2022-04-12 02:58:29.214656 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n# this is a comment\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef find(a):\n    # find root of a \n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649746707,
  "object": "edit"
}
2022-04-12 02:58:29.215077 fix spelling mistakes 2 ["\n# this is a comment\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef find(a):\n    # find root of a \n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 02:58:29.215111 size on output set 2
2022-04-12 02:58:29.215118 size on input set 2
2022-04-12 02:58:32.661568 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# this is a comment\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent, size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n# this is a comment\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649746709,
  "object": "edit"
}
2022-04-12 02:58:32.661841 fix syntax errors 2 ["\n# this is a comment\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent, size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\n# this is a comment\nimport sys\n\ndef find(a):\n    # find root of a\n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(parent.count(find(int(line[1]))))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 02:58:35.264754 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef find(a):\n    # find root of a \n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef find(a):\n    # find root of a \n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1649746712,
  "object": "edit"
}
2022-04-12 02:58:35.264861 fix syntax errors 2 ["\nimport sys\n\ndef find(a):\n    # find root of a \n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef find(a):\n    # find root of a \n    if parent[a] == a:\n        return a\n    else:\n        return find(parent[a])\n\ndef union(a, b):\n    # union of two sets\n    root1 = find(a)\n    root2 = find(b)\n    if root1 != root2:\n        parent[root2] = root1\n\ndef main():\n    global parent\n    global size\n    n, q = map(int, sys.stdin.readline().split())\n    parent = [i for i in range(n+1)]\n    size = [1] * (n+1)\n    for _ in range(q):\n        line = sys.stdin.readline().split()\n        if line[0] == 't':\n            union(int(line[1]), int(line[2]))\n        elif line[0] == 's':\n            print(size[find(int(line[1]))])\n            size[find(int(line[1]))] += 1\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-12 02:58:35.264878 size on output set 3
2022-04-12 02:58:35.264885 num operations 2
2022-04-12 02:58:35.264888 size on input set 1
2022-04-12 02:58:38.117798 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n#union-find\n\n#find the root of a node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes together\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    },
    {
      "index": 1,
      "text": "\n\n#union-find\n\n#find root of a node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes together\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    }
  ],
  "created": 1649746715,
  "object": "edit"
}
2022-04-12 02:58:38.117901 fix spelling mistakes 2 ["\n\n#union-find\n\n#find the root of a node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes together\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n\n#union-find\n\n#find root of a node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes together\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"]
2022-04-12 02:58:38.117969 size on output set 2
2022-04-12 02:58:38.117973 size on input set 2
2022-04-12 02:58:50.681508 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#union-find\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.sizes = [1 for i in range(n)]\n\n#union two nodes together\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n"
    },
    {
      "index": 1,
      "text": "\n\n#union-find (with path compression)\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.sizes = [1 for i in range(n)]\n\n    #find the root of a node\n    def find(self, node):\n        if node == self.parents[node]:\n            return node\n        self.parents[node] = self.find(self.parents[node])\n        return self.parents[node]\n\n    #union two nodes together\n    def union(self, node1, node2):\n        node1 = self.find(node1)\n        node2 = self.find(node2)\n        if node1 != node2:\n            self.parents[node1] = node2\n            self.sizes[node2] += self.sizes[node1]\n            self.sizes[node1] = 0\n\n    #return the size of a node\n    def size(self, node):\n        return self.sizes[self.find(node)]\n\n#read input\nn, q = map(int, input().split())\nuf = UnionFind(n)\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 'u':\n        uf.union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(uf.size(int(query[1])-1))\n"
    }
  ],
  "created": 1649746718,
  "object": "edit"
}
2022-04-12 02:58:50.681709 fix syntax errors 2 ["\n#union-find\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.sizes = [1 for i in range(n)]\n\n#union two nodes together\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(sizes[find(int(query[1])-1)])\n", "\n\n#union-find (with path compression)\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.sizes = [1 for i in range(n)]\n\n    #find the root of a node\n    def find(self, node):\n        if node == self.parents[node]:\n            return node\n        self.parents[node] = self.find(self.parents[node])\n        return self.parents[node]\n\n    #union two nodes together\n    def union(self, node1, node2):\n        node1 = self.find(node1)\n        node2 = self.find(node2)\n        if node1 != node2:\n            self.parents[node1] = node2\n            self.sizes[node2] += self.sizes[node1]\n            self.sizes[node1] = 0\n\n    #return the size of a node\n    def size(self, node):\n        return self.sizes[self.find(node)]\n\n#read input\nn, q = map(int, input().split())\nuf = UnionFind(n)\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 'u':\n        uf.union(int(query[1])-1, int(query[2])-1)\n    else:\n        print(uf.size(int(query[1])-1))\n"]
2022-04-12 02:58:56.214751 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# union-find\n\n# find root of a node\n\n\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n# union two nodes together\n\n\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n# read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n# run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1]) - 1, int(query[2]) - 1)\n    else:\n        print(sizes[find(int(query[1]) - 1)])\n"
    },
    {
      "index": 1,
      "text": "\n#union-find\n\n#find root of a node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes together\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1]) - 1, int(query[2]) - 1)\n    else:\n        print(sizes[find(int(query[1]) - 1)])\n"
    }
  ],
  "created": 1649746730,
  "object": "edit"
}
2022-04-12 02:58:56.215066 fix syntax errors 2 ["\n\n# union-find\n\n# find root of a node\n\n\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n# union two nodes together\n\n\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n# read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n# run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1]) - 1, int(query[2]) - 1)\n    else:\n        print(sizes[find(int(query[1]) - 1)])\n", "\n#union-find\n\n#find root of a node\ndef find(node):\n    if node == parents[node]:\n        return node\n    parents[node] = find(parents[node])\n    return parents[node]\n\n#union two nodes together\ndef union(node1, node2):\n    node1 = find(node1)\n    node2 = find(node2)\n    if node1 != node2:\n        parents[node1] = node2\n        sizes[node2] += sizes[node1]\n        sizes[node1] = 0\n\n#read input\nn, q = map(int, input().split())\nparents = [i for i in range(n)]\nsizes = [1 for i in range(n)]\n\n#run queries\nfor i in range(q):\n    query = input().split()\n    if query[0] == 't':\n        union(int(query[1]) - 1, int(query[2]) - 1)\n    else:\n        print(sizes[find(int(query[1]) - 1)])\n"]
2022-04-12 02:58:56.215245 size on output set 4
