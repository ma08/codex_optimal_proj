["\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open(\"input.txt\", \"r\")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\nprint(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\n# print(edges)\nprint(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [inf for i in range(n)]\n#     min_e[0] = 0\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == inf:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = min(min_e[to], d[v][to])\n#     return sel_e\n\n# edges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\n# def mst(n):\n#     used = [False for i in range(n)]\n#     min_e = [0 for i in range(n)]\n#     sel_e = []\n#     for i in range(n):\n#         v = -1\n#         for j in range(n):\n#             if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n#                 v = j\n#         if min_e[v] == 0:\n#             return sel_e\n#         used[v] = True\n#         sel_e.append((min_e[v], v))\n#         for to in range(n):\n#             min_e[to] = max(min_e[to], d[v][to])\n#     return sel_e\n\n\n# edges = mst(n)\n# print(sum(e for e, v in edges))\n# for e, v in edges:\n#     print(v, e)\n", "\n\nfrom math import inf\nfrom sys import stdin, stdout\n\nf = open(\"input.txt\", \"r\")\ninput = f.readline\nstdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[inf for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\nprint(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\n# print(edges)\n# print(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [inf for i in range(n)]\n    min_e[0] = 0\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == inf:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = min(min_e[to], d[v][to])\n    return sel_e\n\nedges = mst(n)\nprint(edges)\nprint(sum(e for e, v in edges))\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\n# print(sum(e for e, v in edges))\n# for e, v in edges:\n#     print(v, e)\n", "\n\n\ndef find(parent, child):\n    while parent[child] != child:\n        child = parent[child]\n    return child\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimum spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\ndef main():\n\n    n, k = map(int, input().split())\n    dna = [input() for i in range(n)]\n    dna_dict = dict()\n\n    for i in range(n):\n        for j in range(i+1, n):\n            count = 0\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    count += 1\n            dna_dict[(i, j)] = count\n\n    print(min(dna_dict.values()))\n\n    for key, value in dna_dict.items():\n        if value == min(dna_dict.values()):\n            print(*key)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    print(\"Hello World\")\n\n\nmain()\n", "#!/usr/bin/env python3\n\nimport heapq\nimport sys\n\n# Read input and build the graph\nn, k = map(int, sys.stdin.readline().split())\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    dna = sys.stdin.readline().strip()\n    for j in range(i):\n        u, v = i, j\n        graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b))) # add the edge to the graph\n        graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b))) # add the edge to the graph\n\n# Prim's Algorithm\nmin_tree = [] # store the minimum spanning tree\nmin_weight = 0 # store the weight of the minimum spanning tree\nvisited = [False] * n # store the visited nodes\npq = [(0, 0, dna)] # store the edges\nwhile pq:\n    weight, u, dna = heapq.heappop(pq) # get the edge with minimum weight\n    if not visited[u]:\n        visited[u] = True\n        min_tree.append((u, dna))\n        min_weight += weight\n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v, dna))\n\n# Print results\nprint(min_weight)\nfor u, dna in min_tree[1:]:\n    print(min_tree.index((u, dna)), u)\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna, key=lambda x: x[0])\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimum spanning tree\n    tree = []\n    edges = []\n    for i in range(n - 1):\n        for j in range(i + 1, n - 1):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimum spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n)] # minimum spanning tree\n    used = [False for i in range(n)]\n    mst[0][0] = 0 # first node\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSet(len(dna)) # Initialize the disjoint set \n    mst = [] # Initialize the minimum spanning tree as an empty list\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 for i in range(len(dna1)) if dna1[i] != dna2[i])\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\", encoding=\"utf-8\")\n# input = f.readline().strip\n# stdin = f.read().splitlines()\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v + 1, e)\n", "\n\nimport sys\n\ndef main():\n    n = int(input())\n    dna = [input() for _ in range(n)]\n    edges = []  # list of edges\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])  # sort edges by distance\n    components = {i: i for i in range(n)}\n    total_distance = 0  # total distance of MST\n    for i, j, d in edges:\n        if components[i] != components[j]:  # if not in the same component\n            total_distance += d\n            c1 = components[i]  # component of i\n            c2 = components[j]  # component of j\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1  # merge components\n    print(total_distance)\n    for i, j, d in edges: \n        if components[i] != components[j]: \n            print(i, j) \n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", "\nimport sys\ndef main():\n\n    n = int(input())\n    dna = [input() for i in range(n)] \n    dna_dict = {} \n\n    for i in range(n): \n        for j in range(i+1, n): \n            count = 0 \n            for x in range(len(dna[i])): \n                if dna[i][x] != dna[j][x]: \n                    count += 1 \n            dna_dict[(i,j)] = count \n\n    print(min(dna_dict.values())) \n\n    for key, value in dna_dict.items(): \n        if value == min(dna_dict.values()): \n            print(*key) \n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[float('inf') for i in range(n)] for j in range(n)] # minimum spanning tree\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != float('inf'):\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n", "\n\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeness(n, k, dna):\n    \"\"\"\n    Compute the minimal unlikeness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeness: the minimal unlikeness of the evolutionary tree\n    \"\"\"\n    unlikeness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeness += 1\n    return unlikeness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeness = min_unlikeness(n, k, dna)\n    print(unlikeness)\n\n    # Print the tree\n    print_tree(n)\n", "\n\ndef main():\n    n = int(input())\n    dna = [input() for _ in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, hamming(dna[i], dna[j])))\n    edges.sort(key=lambda x: x[2])\n    components = {i: i for i in range(n)}\n    total_distance = 0\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            total_distance += d\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n    print(total_distance)\n    for i, j, d in edges:\n        if components[i] != components[j]:\n            print(i + 1, j + 1)\n            c1 = components[i]\n            c2 = components[j]\n            for k in range(n):\n                if components[k] == c2:\n                    components[k] = c1\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", "\n\ndef main():\n    n = int(input())\n    dna = [input() for _ in range(n)]\n    total_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_distance += hamming(dna[i], dna[j])\n    print(total_distance)\n    for i in range(n):\n        for j in range(i + 1, n):\n            print(i, j)\n\ndef hamming(s1, s2):\n    return sum(a != b for a, b in zip(s1, s2))\n\nmain()\n", "\n\nfrom sys import stdin, stdout\n\n# f = open(\"input.txt\", \"r\")\n# input = f.readline\n# stdin = f\n\nn, k = map(int, input().split())\ndna = [input().strip() for i in range(n)]\n# dna = list(map(str, stdin.read().splitlines()))\n# print(dna)\n\nd = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(n):\n        d[i][j] = sum(1 for k in range(k) if dna[i][k] != dna[j][k])\n\n# print(d)\n\ndef mst(n):\n    used = [False for i in range(n)]\n    min_e = [0 for i in range(n)]\n    sel_e = []\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or min_e[j] < min_e[v]):\n                v = j\n        if min_e[v] == 0:\n            return sel_e\n        used[v] = True\n        sel_e.append((min_e[v], v))\n        for to in range(n):\n            min_e[to] = max(min_e[to], d[v][to])\n    return sel_e\n\n\nedges = mst(n)\nprint(sum(e for e, v in edges))\nfor e, v in edges:\n    print(v + 1, e)\n", "\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    mst = [[math.inf for i in range(n)] for j in range(n)] # minimum spanning tree\n    used = [False for i in range(n)]\n    mst[0][0] = 0\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]): # v is the next vertex to be added\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, i):\n        while parent[i] != i:\n            i = parent[i]\n        return i\n\n    parent = list(range(n))\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\nimport math\n\ndef solve(k, dna):\n    n = len(dna)\n    edge = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    edge[i][j] += 1\n                    edge[j][i] += 1\n    # print(edge)\n    mst = [[math.inf for i in range(n)] for j in range(n)] # minimum spanning tree\n    used = [False for i in range(n)]\n    mst[0][0] = 0 # first node\n    ans = 0\n    for i in range(n):\n        v = -1\n        for j in range(n):\n            if not used[j] and (v == -1 or mst[j][i] < mst[v][i]):\n                v = j\n        used[v] = True\n        ans += mst[v][i]\n        for j in range(n):\n            if mst[j][i] > edge[v][j]:\n                mst[j][i] = edge[v][j]\n    print(ans)\n    for i in range(n):\n        for j in range(n):\n            if mst[i][j] != math.inf:\n                print(i, j)\n\ndef main():\n    line = sys.stdin.readline()\n    n, k = [int(x) for x in line.split()]\n    dna = [sys.stdin.readline().strip() for i in range(n)]\n    solve(k, dna)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split(' '))\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint sets.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = []\n    for _ in range(n):\n        dna.append(input())\n    dna = sorted(dna)\n\n    # Construct a table of distances between each pair of strings\n    distances = [[0 for _ in range(n)] for _ in range(n)]  # noqa\n    for i in range(n):\n        for j in range(n):\n            for x in range(k):\n                if dna[i][x] != dna[j][x]:\n                    distances[i][j] += 1\n\n    # Compute the minimal spanning tree\n    tree = []\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j, distances[i][j]))\n    edges = sorted(edges, key=lambda x: x[2])\n\n    # Use Kruskal's algorithm to find the minimal spanning tree\n    def find(parent, child):\n        while parent[child] != child:\n            child = parent[child]\n        return child\n\n    parent = list(range(n))  # noqa\n    for i, j, dist in edges:\n        root_i, root_j = find(parent, i), find(parent, j)\n        if root_i != root_j:\n            tree.append((i, j, dist))\n            parent[root_i] = root_j\n\n    # Print the result\n    print(sum(dist for _, _, dist in tree))\n    for i, j, _ in tree:\n        print(i, j)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport heapq\nimport sys\n\ndef main():\n    # Read input and build the graph\n    n, k = map(int, sys.stdin.readline().split())\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        dna = sys.stdin.readline().strip()\n        for j in range(i):\n            u, v = i, j\n            graph[u].append((v, sum(1 for a, b in zip(dna, graph[j][0][1]) if a != b)))\n            graph[v].append((u, sum(1 for a, b in zip(dna, dna) if a != b)))\n\n    # Prim's Algorithm\n    min_tree = []\n    min_weight = 0\n    visited = [False] * n\n    pq = [(0, 0, dna)]\n    while pq:\n        weight, u, dna = heapq.heappop(pq)\n        if not visited[u]:\n            visited[u] = True\n            min_tree.append((u, dna))\n            min_weight += weight\n            for v, w in graph[u]:\n                if not visited[v]:\n                    heapq.heappush(pq, (w, v, dna))\n\n    # Print results\n    print(min_weight)\n    for u, dna in min_tree[1:]:\n        print(min_tree.index((u, dna)), u)\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna)[-1].weight)\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    # Initialize the disjoint sets\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight)[:len(dna) - 1]:\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint sets.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef get_input(f):\n    \"\"\"\n    Parse the input text file.\n    Arguments:\n        f: input file\n    Returns:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    \"\"\"\n    # Get the first line\n    line = f.readline()\n    try:\n        n, k = map(int, line.split())\n    except ValueError:\n        print(\"Invalid Input\")\n        sys.exit()\n\n    # Get the rest of the lines\n    dna = []\n    for i in range(n):\n        line = f.readline()\n        dna.append(line.strip())\n\n    return n, k, dna\n\ndef min_unlikeliness(n, k, dna): \n    \"\"\"\n    Compute the minimal unlikeliness of the evolutionary tree.\n    Arguments:\n        n: number of DNA samples\n        k: length of DNA samples\n        dna: list of strings representing the DNA samples\n    Returns:\n        unlikeliness: the minimal unlikeliness of the evolutionary tree\n    \"\"\"\n    unlikeliness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for c in range(k):\n                if dna[i][c] != dna[j][c]:\n                    unlikeliness += 1\n    return unlikeliness\n\ndef print_tree(n):\n    \"\"\"\n    Print the tree in the required format.\n    Arguments:\n        n: number of DNA samples\n    \"\"\"\n    for i in range(n - 1):\n        print(i, i + 1)\n\nif __name__ == \"__main__\":\n    # Get the input\n    f = open(sys.argv[1])\n    n, k, dna = get_input(f)\n\n    # Compute the minimal unlikeliness and print it\n    unlikeliness = min_unlikeliness(n, k, dna)\n    print(unlikeliness)\n\n    # Print the tree\n    print_tree(n)\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    dna = [input() for _ in range(n)]\n    print(kruskal(dna))\n\ndef kruskal(dna):\n    \"\"\"\n    Kruskal's algorithm for finding the minimum spanning tree of a graph.\n    \"\"\"\n    # Initialize the graph\n    graph = Graph(dna)\n    ds = DisjointSet(len(dna))\n    # Initialize the minimum spanning tree as an empty list\n    mst = []\n    # Iterate through the edges in the graph\n    for edge in sorted(graph.edges, key=lambda x: x.weight):\n        # If the edge does not create a cycle\n        if not ds.is_in_same_set(edge.vertex1, edge.vertex2):\n            # Add the edge to the minimum spanning tree\n            mst.append(edge)\n            # Merge the two sets\n            ds.union(edge.vertex1, edge.vertex2)\n    # Return the minimum spanning tree\n    return mst\n\nclass Graph:\n    \"\"\"\n    Class for representing a graph.\n    \"\"\"\n    def __init__(self, dna):\n        \"\"\"\n        Initialize the graph.\n        \"\"\"\n        self.edges = []\n        self.vertices = [i for i in range(len(dna))]\n        for vertex1 in range(len(dna)):\n            for vertex2 in range(vertex1 + 1, len(dna)):\n                self.edges.append(Edge(vertex1, vertex2, self.weight(dna[vertex1], dna[vertex2])))\n    \n    def weight(self, dna1, dna2):\n        \"\"\"\n        Compute the weight of an edge between two vertices.\n        \"\"\"\n        return sum(1 if dna1[i] != dna2[i] else 0 for i in range(len(dna1)))\n\nclass Edge:\n    \"\"\"\n    Class for representing an edge.\n    \"\"\"\n    def __init__(self, vertex1, vertex2, weight):\n        \"\"\"\n        Initialize the edge.\n        \"\"\"\n        self.vertex1 = vertex1\n        self.vertex2 = vertex2\n        self.weight = weight\n\nclass DisjointSet:\n    \"\"\"\n    Class for representing a disjoint set.\n    \"\"\"\n    def __init__(self, size):\n        \"\"\"\n        Initialize the disjoint set.\n        \"\"\"\n        self.size = size\n        self.parent = [i for i in range(size)]\n        self.rank = [0 for i in range(size)]\n    \n    def find(self, x):\n        \"\"\"\n        Find the root of a given vertex.\n        \"\"\"\n        if self.parent[x] == x:\n            return x\n        else:\n            return self.find(self.parent[x])\n    \n    def union(self, x, y):\n        \"\"\"\n        Merge the sets containing two given vertices.\n        \"\"\"\n        xroot = self.find(x)\n        yroot = self.find(y)\n        if self.rank[xroot] > self.rank[yroot]:\n            self.parent[yroot] = xroot\n        elif self.rank[xroot] < self.rank[yroot]:\n            self.parent[xroot] = yroot\n        else:\n            self.parent[yroot] = xroot\n            self.rank[xroot] += 1\n    \n    def is_in_same_set(self, x, y):\n        \"\"\"\n        Check if two given vertices are in the same set.\n        \"\"\"\n        return self.find(x) == self.find(y)\n\nif __name__ == \"__main__\":\n    main()\n"]