["\n\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):]\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])])))\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):]\n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])]))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# TODO: implement using a Trie instead of a hash map\n\nclass Node(object):\n    def __init__(self):\n        self.children = {}\n        self.count = 0\n\nclass Trie(object):\n    def __init__(self):\n        self.root = Node()\n\n    def add(self, word):\n        curr = self.root\n        for char in word:\n            if char not in curr.children:\n                curr.children[char] = Node()\n            curr.children[char].count += 1\n            curr = curr.children[char]\n        return curr\n\n    def find(self, word):\n        curr = self.root\n        for char in word:\n            if char in curr.children:\n                curr = curr.children[char]\n            else:\n                return 0\n        return curr.count\n\n\ndef main():\n    s = input()\n    q = int(input())\n\n    trie = Trie()\n    for char in s:\n        trie.add(char)\n\n    for _ in range(q):\n        query = input().split()\n        if query[0] == '1':\n            trie.add(query[2])\n        elif query[0] == '2':\n            print(trie.find(s[int(query[1]) - 1: int(query[2])]))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass LinkedList:\n    def __init__(self):\n        self.root = Node()\n\n        self.size = 0\n\n    def add(self, data):\n        new_node = Node(data)\n        if self.root is None:\n            self.root = new_node\n        else:\n            curr = self.root\n            while curr.next is not None:\n                curr = curr.next\n            curr.next = new_node\n        self.size += 1\n\n    def remove(self, data):\n        if self.root is None:\n            return\n        if self.root.data == data:\n            self.root = self.root.next\n            self.size -= 1\n            return\n        curr = self.root\n        while curr.next is not None:\n            if curr.next.data == data:\n                curr.next = curr.next.next\n                self.size -= 1\n                return\n            curr = curr.next\n\n    def find(self, data):\n        curr = self.root\n        while curr is not None:\n            if curr.data == data:\n                return True\n            curr = curr.next\n        return False\n\n    def print_list(self):\n        curr = self.root\n        while curr is not None:\n            print(curr.data)\n            curr = curr.next\n\n\ndef main():\n    ll = LinkedList()\n    ll.add(1)\n    ll.add(2)\n    ll.add(3)\n    ll.add(4)\n    ll.add(5)\n    ll.add(6)\n    ll.print_list()\n    print()\n    ll.remove(1)\n    ll.remove(4)\n    ll.remove(6)\n    ll.print_list()\n\n\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    s = input()\n    q = int(input())\n    for i in range(q):\n        query = input()\n        if query[0] == \"1\":\n            s = s[:int(query[2])-1] + query[4] + s[int(query[2]):] \n        elif query[0] == \"2\":\n            print(len(set(s[int(query[2])-1:int(query[4])])))\n\nif __name__ == \"__main__\":\n    main()\n"]