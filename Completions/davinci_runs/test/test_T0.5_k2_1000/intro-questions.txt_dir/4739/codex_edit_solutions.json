["\n\nimport sys\nimport math\n\ndef main():\n    # Read input\n    M, N = [int(x) for x in sys.stdin.readline().strip().split()]\n    T = [int(x) for x in sys.stdin.readline().strip().split()]\n    X = [int(x) for x in sys.stdin.readline().strip().split()]\n\n    # Calculate the differences in time and distance\n    time_diff = [T[i+1]-T[i] for i in range(len(T)-1)] # [1, 1, 1, 1]\n    distance_diff = [X[i+1]-X[i] for i in range(len(X)-1)] # [1, 1, 1, 1]\n\n    # Calculate the possible speeds\n    speeds = sorted(set(time_diff[i]/distance_diff[i] for i in range(len(time_diff)))) # [1.0]\n    print(len(speeds))\n    print(*speeds)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    \"\"\"\n    Calculates the number of possible speeds at which the car could have been traveling given the number of milestones seen,\n    the times at which they were seen, and the distances along the road of each milestone. Then, calculates the possible\n    distances between the first milestone seen and the second milestone seen.\n\n    :return: None\n    \"\"\"\n    # Get the number of milestones seen as well as the total number of milestones along the road\n    milestones_seen, total_milestones = map(int, input().split())\n\n    # Get the times at which the milestones were seen\n    times = list(map(int, input().split()))\n\n    # Get the distances along the road of each milestone\n    distances = list(map(int, input().split()))\n\n    # Get the number of possible speeds at which the car could have been traveling\n    num_speeds = get_num_speeds(milestones_seen, total_milestones, times, distances) + 1\n\n    # Get the possible distances between the first milestone seen and the second milestone seen\n    distances_between = get_distances_between(milestones_seen, total_milestones, times, distances)\n\n    # Print the number of possible speeds at which the car could have been traveling\n    print(num_speeds)\n\n    # Print the possible distances between the first milestone seen and the second milestone seen\n    print(\" \".join(map(str, distances_between)))\n\ndef get_num_speeds(milestones_seen, total_milestones, times, distances):\n    \"\"\"\n    Calculates the number of possible speeds at which the car could have been traveling given the number of milestones seen, the times at which they were seen, and the distances along the road of each milestone.\n\n    :param milestones_seen: The number of milestones seen\n    :param total_milestones: The total number of milestones along the road\n    :param times: The times at which the milestones were seen\n    :param distances: The distances along the road of each milestone\n    :return: The number of possible speeds at which the car could have been traveling\n    \"\"\"\n    # Define a set to store the possible speeds at which the car could have been traveling\n    speeds = set()\n\n    # For each milestone seen\n    for i in range(milestones_seen):\n        # For each milestone not seen\n        for j in range(milestones_seen, total_milestones):\n            # Calculate the speed at which the car could have been travelling\n            speed = (distances[j] - distances[i]) / (times[j] - times[i])\n\n            # Add the speed to the set of possible speeds at which the car could have been traveling\n            speeds.add(speed)\n\n    # Return the number of possible speeds at which the car could have been traveling\n    return len(speeds)\n\ndef get_distances_between(milestones_seen, total_milestones, times, distances):\n    \"\"\"\n    Calculates the possible distances between the first milestone seen and the second milestone seen given the number of milestones seen, the times at which they were seen, and the distances along the road of each milestone.\n\n    :param milestones_seen: The number of milestones seen\n    :param total_milestones: The total number of milestones along the road\n    :param times: The times at which the milestones were seen\n    :param distances: The distances along the road of each milestone\n    :return: The possible distances between the first milestone seen and the second milestone seen\n    \"\"\"\n    # Define a list to store the possible distances between the first milestone seen and the second milestone seen\n    distances_between = []\n\n    # For each milestone seen\n    for i in range(milestones_seen):\n        # For each milestone not seen\n        for j in range(milestones_seen, total_milestones):\n            # Calculate the distance between the first milestone seen and the second milestone seen\n            distance = distances[j] - distances[i]\n\n            # Add the distance to the list of possible distances between the first milestone seen and the second milestone seen\n            distances_between.append(distance)\n\n    # Return the possible distances between the first milestone seen and the second milestone seen\n    return sorted(distances_between)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef solve(M, N, T_list, X_list):\n    # print(\"M: \" + str(M))\n    # print(\"N: \" + str(N))\n    # print(\"T_list: \" + str(T_list))\n    # print(\"X_list: \" + str(X_list))\n    speeds = set()\n    for i in range(M - 1):\n        for j in range(i + 1, M):\n            speed = (X_list[j] - X_list[i]) / (T_list[j] - T_list[i])\n            # print(\"speed: \" + str(speed))\n            speeds.add(speed)\n    # print(\"speeds: \" + str(speeds))\n    distances = set()\n    for speed in speeds:\n        for i in range(M - 1):\n            for j in range(i + 1, M):\n                distance = (T_list[j] - T_list[i]) * speed + X_list[i]\n                # print(\"distance: \" + str(distance))\n                distances.add(distance)\n    # print(\"distances: \" + str(distances))\n    distances = list(distances)\n    distances.sort()\n    print(len(distances))\n    print(\" \".join(str(x) for x in distances))\n\n\nif __name__ == \"__main__\":\n    M, N = [int(x) for x in input().split()]\n    T_list = [int(x) for x in input().split()]\n    X_list = [int(x) for x in input().split()]\n    solve(M, N, T_list, X_list)\n", "\n\nimport sys\nsys.stdin = open('input.txt')\n\nM, N = map(int, input().split())\nT = [0] + list(map(int, input().split()))\nX = [0] + list(map(int, input().split()))\n\n# calculate the distance between each two milestones\nD = [X[i+1]-X[i] for i in range(M)]\n\n# calculate the time between each two milestones\nT = [T[i+1]-T[i] for i in range(N)]\n\n# calculate the speed between each two milestones\nS = [D[i]/T[i] for i in range(N)]\n\n# calculate the distance between the first milestone you saw and the other milestones\nD2 = [S[i]*T[0] for i in range(N)]\n\n# sort D2 in increasing order\nD2 = sorted(D2)\n\n# remove duplicate values\nD2 = list(set(D2))\n\n# print output\nprint(len(D2))\nprint(*D2)\n", "\n\n# TODO: fix the last test case\n\n# This is a dynamic programming problem.\n# For each stone, we can determine the possible speeds at which the car could have been traveling.\n# Then, we can iterate through the stones and determine the possible speeds\n# at which the car could have been traveling at that point.\n# We can do this by taking the union of the possible speeds at the previous stone and the possible speeds\n# at the current stone.\n\ndef get_possible_speeds(t, x):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible speeds at which the car could have been traveling\n    speeds = set()\n    for time in t:\n        for distance in x:\n            speeds.add(distance / (time * 1.0))\n    return speeds\n\ndef get_possible_distances(t, x):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible distances between the first milestone and the second milestone\n    distances = set()\n    for time in t:\n        for distance in x:\n            distances.add(distance - time)\n    return distances\n\ndef get_possible_speeds_at_stone(t, x, stone, speeds_before):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible speeds at which the car could have been traveling at that point\n    speeds_at_stone = get_possible_speeds(t, x)\n    speeds_at_stone.update(speeds_before)\n    return speeds_at_stone\n\ndef main():\n    m, n = map(int, input().split())\n    t = set(map(int, input().split()))\n    x = set(map(int, input().split()))\n    speeds = set()\n    distances = set()\n    for i in range(m):\n        if i == 0:\n            speeds_before = get_possible_speeds(t, x)\n            distances_before = get_possible_distances(t, x)\n        else:\n            speeds_before = speeds\n            distances_before = distances\n        speeds = get_possible_speeds_at_stone(t, x, i, speeds_before)\n        distances = get_possible_distances(t, x)\n        distances.update(distances_before)\n    print(len(speeds))\n    print(\" \".join(map(str, sorted(distances))))\n\n\nmain()\n", "\ndef speed_and_distance(stones, distances):\n    distance = [0]\n    for i in range(len(stones) - 1):\n        distance.append(stones[i + 1] - stones[i])\n\n    print(distance)\n\n    if len(set(distance)) == 1:\n        for i in range(len(distances)):\n            if distances[i] % distance[0] == 0:\n                print(1)\n                print(distances[i] // distance[0])\n                break\n            else:\n                print(0)\n    else:\n        for i in range(len(distances)):\n            print(0)\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    stones = list(map(int, input().split()))\n    distances = list(map(int, input().split()))\n    speed_and_distance(stones, distances)\n", "\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef solve(n, m, t, x):\n    speeds = set()\n    for i in range(n-1):\n        for j in range(i+1, n):\n            speed = (x[j] - x[i]) / (t[j] - t[i])\n            speeds.add(speed)\n    speeds = sorted(speeds)\n    print(len(speeds))\n    print(' '.join(map(str, speeds)))\n\nif __name__ == \"__main__\":\n    n, m = read_ints()\n    t = read_ints()\n    x = read_ints()\n    solve(m, n, t, x)\n", "\n\n# TODO: fix the last test case\n\n# This is a dynamic programming problem.\n# For each stone, we can determine the possible speeds at which the car could have been traveling.\n# Then, we can iterate through the stones and determine the possible speeds at which the car could have been traveling at that point.\n# We can do this by taking the union of the possible speeds at the previous stone and the possible speeds\n# at the current stone.\n\ndef get_possible_speeds(t, x):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible speeds at which the car could have been traveling\n    speeds = set()\n    for time in t:\n        for distance in x:\n            speeds.add(distance/(time*1.0))\n    return speeds\n\ndef get_possible_distances(t, x):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible distances between the first milestone and the second milestone\n    distances = set()\n    for time in t:\n        for distance in x:\n            distances.add(distance-time)\n    return distances\n\ndef get_possible_speeds_at_stone(t, x, stone, speeds_before):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible speeds at which the car could have been traveling at that point\n    speeds_at_stone = get_possible_speeds(t, x)\n    speeds_at_stone.update(speeds_before)\n    return speeds_at_stone\n\ndef main():\n    m, n = map(int, input().split())\n    t = set(map(int, input().split()))\n    x = set(map(int, input().split()))\n    speeds = set()\n    distances = set()\n    for i in range(m):\n        if i == 0:\n            speeds_before = get_possible_speeds(t, x)\n            distances_before = get_possible_distances(t, x)\n        else:\n            speeds_before = speeds\n            distances_before = distances\n        speeds = get_possible_speeds_at_stone(t, x, i, speeds_before)\n        distances = get_possible_distances(t, x)\n        distances.update(distances_before)\n    print(len(speeds))\n    print(\" \".join(map(str, sorted(distances))))\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n    # Read input\n    M, N = [int(x) for x in sys.stdin.readline().strip().split()]\n    T = [int(x) for x in sys.stdin.readline().strip().split()]\n    X = [int(x) for x in sys.stdin.readline().strip().split()]\n\n    # Calculate the differences in time and distance\n    time_diff = [T[i+1]-T[i] for i in range(len(T)-1)]\n    distance_diff = [X[i+1]-X[i] for i in range(len(X)-1)]\n\n    # Calculate the possible speeds\n    speeds = sorted(set(time_diff[i]/distance_diff[i] for i in range(len(time_diff))))\n    print(len(speeds))\n    for speed in speeds:\n        print(speed)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n#TODO: fix the last test case, it's wrong\n\n# This is a dynamic programming problem.\n# For each stone, we can determine the possible speeds at which the car could have been traveling.\n# Then, we can iterate through the stones and determine the possible speeds at which the car could have been traveling at that point.\n# We can do this by taking the union of the possible speeds at the previous stone and the possible speeds\n# at the current stone.\n\ndef get_possible_speeds(t, x):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible speeds at which the car could have been traveling\n    speeds = set()\n    for time in t:\n        for distance in x:\n            speeds.add(distance/(time*1.0))\n    return speeds\n\ndef get_possible_distances(t, x):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible distances between the first milestone and the second milestone\n    distances = set()\n    for time in t:\n        for distance in x:\n            distances.add(distance-time)\n    return distances\n\ndef get_possible_speeds_at_stone(t, x, stone, speeds_before):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible speeds at which the car could have been traveling at that point\n    speeds_at_stone = get_possible_speeds(t, x)\n    speeds_at_stone.update(speeds_before)\n    return speeds_at_stone\n\ndef main():\n    m, n = map(int, input().split())\n    t = set(map(int, input().split()))\n    x = set(map(int, input().split()))\n    speeds = set()\n    distances = set()\n    for i in range(m):\n        if i == 0:\n            speeds_before = get_possible_speeds(t, x)\n            distances_before = get_possible_distances(t, x)\n        else:\n            speeds_before = speeds\n            distances_before = distances\n        speeds = get_possible_speeds_at_stone(t, x, i, speeds_before)\n        distances = get_possible_distances(t, x)\n        distances.update(distances_before)\n    print(len(speeds), end=\" \")\n    print(\" \".join(map(str, sorted(distances))), end=\" \")\n\nmain()\n", "\n\n#import sys\n#sys.stdin = open('input.txt')\n\nM, N = map(int, input().split())\nT = list(map(int, input().split())) \nX = list(map(int, input().split()))\n\n# calculate the distance between each two milestones\nD = [X[i+1]-X[i] for i in range(M-1)]\n\n# calculate the time between each two milestones\nT = [T[i+1]-T[i] for i in range(M-1)]\n\n# calculate the speed between each two milestones\nS = [D[i]/T[i] for i in range(M-1)]\n\n# calculate the distance between the first milestone you saw and the other milestones\nD2 = [S[i]*T[0] for i in range(M-1)]\n\n# sort D2 in increasing order\nD2 = sorted(D2)\n\n# remove duplicate values\nD2 = list(set(D2))\n\n# print output\nprint(len(D2))\nprint(*D2)\n", "\n\n#TODO: fix the last test case (the one with the answer of 1)\n\n# This is a dynamic programming problem.\n# For each stone, we can determine the possible speeds at which the car could have been traveling.\n# Then, we can iterate through the stones and determine the possible speeds\n# at which the car could have been traveling at that point.\n# We can do this by taking the union of the possible speeds at the previous stone and the possible speeds\n# at the current stone.\n\ndef get_possible_speeds(t, x, speeds_before):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible speeds at which the car could have been traveling\n    speeds = set()\n    for time in t:\n        for distance in x:\n            speeds.add(distance/(time*1.0))\n    return speeds\n    speeds.update(speeds_before)\n    return speeds\n\ndef get_possible_distances(t, x, distances_before):\n    # given the time and distance at which the car passed a stone,\n    # returns the possible distances between the first milestone and the second milestone\n    distances = set()\n    for time in t:\n        for distance in x:\n            distances.add(distance-time)\n    return distances\n    distances.update(distances_before)\n    return distances\n\n\ndef main():\n    m, n = map(int, input().split())\n    t = set(map(int, input().split()))\n    x = set(map(int, input().split()))\n    speeds = set()\n    distances = set()\n    for i in range(m):\n        if i == 0:\n            speeds_before = set()\n            distances_before = set()\n        else:\n            speeds_before = speeds\n            distances_before = distances\n        speeds = get_possible_speeds(t, x, speeds_before)\n        distances = get_possible_distances(t, x, distances_before)\n    print(len(speeds))\n    print(\" \".join(map(str, sorted(distances))))\n\nmain()\n", "\n\nimport sys\nimport math\n\ndef main():\n    # Read input.\n    M, N = [int(x) for x in input().strip().split()]\n    T = [int(x) for x in input().strip().split()]\n    X = [int(x) for x in input().strip().split()]\n\n    # Calculate the differences in time and space.\n    time_diff = [T[i+1]-T[i] for i in range(len(T)-1)]\n    space_diff = [X[i+1]-X[i] for i in range(len(X)-1)]\n\n    # Calculate the possible speeds.\n    speeds = sorted(set(time_diff[i]/space_diff[i] for i in range(len(time_diff))))\n    print(len(speeds))\n    print(*speeds, sep=' ')\n\nif __name__ == \"__main__\":\n    main()\n", "def speed_and_distance(stones, distances):\n    distance = []\n    for i in range(len(stones) - 1):\n        distance.append(stones[i + 1] - stones[i])\n\n    if len(set(distance)) == 1:\n        print(1)\n        print(distance[0])\n    else:\n        print(0)\n\nif __name__ == \"__main__\":\n    M, N = map(int, input().split())\n    stones = list(map(int, input().split()))\n    distances = list(map(int, input().split()))\n    speed_and_distance(stones, distances)\n", "\n\ndef main():\n    \"\"\"\n    Calculates the number of possible speeds at which the car could have been traveling given the number of milestones seen,\n    the times at which they were seen, and the distances along the road of each milestone. Then, calculates the possible\n    distances between the first milestone seen and the second milestone seen.\n\n    :return: None\n    \"\"\"\n    # Get the number of milestones seen as well as the total number of milestones along the road\n    milestones_seen, total_milestones = map(int, input().split())\n\n    # Get the times at which the milestones were seen\n    times = list(map(int, input().split()))\n\n    # Get the distances along the road of each milestone\n    distances = list(map(int, input().split()))\n\n    # Get the number of possible speeds at which the car could have been traveling\n    num_speeds = get_num_speeds(milestones_seen, total_milestones, times, distances) + 1\n\n    # Get the possible distances between the first milestone seen and the second milestone seen\n    distances_between = get_distances_between(milestones_seen, total_milestones, times, distances)\n\n    # Print the number of possible speeds at which the car could have been traveling\n    print(num_speeds)\n\n    # Print the possible distances between the first milestone seen and the second milestone seen\n    print(\" \".join(map(str, distances_between)))\n\ndef get_num_speeds(milestones_seen, total_milestones, times, distances):\n    \"\"\"\n    Calculates the number of possible speeds at which the car could have been traveling given the number of milestones\n    seen, the times at which they were seen, and the distances along the road of each milestone.\n\n    :param milestones_seen: The number of milestones seen\n    :param total_milestones: The total number of milestones along the road\n    :param times: The times at which the milestones were seen\n    :param distances: The distances along the road of each milestone\n    :return: The number of possible speeds at which the car could have been traveling\n    \"\"\"\n    # Define a set to store the possible speeds at which the car could have been traveling\n    speeds = set()\n\n    # For each milestone seen\n    for i in range(milestones_seen):\n        # For each milestone not seen\n        for j in range(milestones_seen, total_milestones):\n            # Calculate the speed at which the car could have been travelling\n            speed = (distances[j] - distances[i]) / (times[j] - times[i])\n\n            # Add the speed to the set of possible speeds at which the car could have been traveling\n            speeds.add(speed)\n\n    # Return the number of possible speeds at which the car could have been traveling\n    return len(speeds)\n\ndef get_distances_between(milestones_seen, total_milestones, times, distances):\n    \"\"\"\n    Calculates the possible distances between the first milestone seen and the second milestone seen given the number of\n    milestones seen, the times at which they were seen, and the distances along the road of each milestone.\n\n    :param milestones_seen: The number of milestones seen\n    :param total_milestones: The total number of milestones along the road\n    :param times: The times at which the milestones were seen\n    :param distances: The distances along the road of each milestone\n    :return: The possible distances between the first milestone seen and the second milestone seen\n    \"\"\"\n    # Define a list to store the possible distances between the first milestone seen and the second milestone seen\n    distances_between = []\n\n    # For each milestone seen\n    for i in range(milestones_seen):\n        # For each milestone not seen\n        for j in range(milestones_seen, total_milestones):\n            # Calculate the distance between the first milestone seen and the second milestone seen\n            distance = distances[j] - distances[i]\n\n            # Add the distance to the list of possible distances between the first milestone seen and the second milestone seen\n            distances_between.append(distance)\n\n    # Return the possible distances between the first milestone seen and the second milestone seen\n    return sorted(distances_between)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# The problem is equivalent to finding all possible distances between the first and second milestones seen\n# Sort the list of milestones, and then find all differences between the first and second milestones seen\ndef main():\n    # Get the number of milestones seen and the total number of milestones\n    M, N = map(int, input().split())\n    # Get the times at which each milestone was seen\n    T = list(map(int, input().split()))\n    # Get the distances between each milestone\n    X = list(map(int, input().split()))\n    # Sort the list of milestones\n    X.sort()\n    # Find all possible distances between the first and second milestones seen\n    # Find the possible distances for each milestone seen\n    possible_distances = []\n    for i in range(M):\n        # Find the distances between the first milestone seen and the milestone seen at time T[i]\n        distances = [X[j] - X[0] for j in range(i+1)]\n        # If there is a distance that is greater than T[i], then it is not possible to reach the milestone\n        # by time T[i]\n        if distances[-1] > T[i]:\n            continue\n        # Otherwise, add the distances\n        possible_distances += distances\n    # Sort the possible distances and find the unique possible distances\n    possible_distances.sort()\n    possible_distances = list(set(possible_distances))\n    # Print the number of possible distances\n    print(len(possible_distances))\n    # Print the possible distances\n    print(*possible_distances)\n\nmain()\n", "\n\ndef solve(m, n, t_array, x_array):\n    # print(\"m: \" + str(m))\n    # print(\"n: \" + str(n))\n    # print(\"t_array: \" + str(t_array))\n    # print(\"x_array: \" + str(x_array))\n    speeds = set()\n    for i in range(m - 1):\n        for j in range(i + 1, m):\n            speed = (x_array[j] - x_array[i]) / (t_array[j] - t_array[i])\n            # print(\"speed: \" + str(speed))\n            speeds.add(speed)\n    # print(\"speeds: \" + str(speeds))\n    distances = set()\n    for speed in speeds:\n        for i in range(m - 1):\n            for j in range(i + 1, m):\n                distance = (t_array[j] - t_array[i]) * speed + x_array[i]\n                # print(\"distance: \" + str(distance))\n                distances.add(distance)\n    # print(\"distances: \" + str(distances))\n    distances = list(distances)\n    distances.sort()\n    print(len(distances))\n    print(\" \".join(str(x) for x in distances))\n\n\nif __name__ == \"__main__\":\n    m, n = [int(x) for x in input().split()]\n    t_array = [int(x) for x in input().split()]\n    x_array = [int(x) for x in input().split()]\n    solve(m, n, t_array, x_array)\n", "\n\n# SOLUTION 2\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef solve(n, k, a):\n    a = sorted(a)\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] - a[i] <= 5:\n            j += 1\n        if j - i > k:\n            return False\n        i = j\n    return True\n\nif __name__ == \"__main__\":\n    n, k = read_ints()\n    a = read_ints()\n    print('YES' if solve(n, k, a) else 'NO')\n", "\n\ndef solve(m, n, t_array, x_array):\n    speeds = set()\n    for i in range(m-1):\n        for j in range(i+1, m):\n            speed = (x_array[j] - x_array[i]) / (t_array[j] - t_array[i])\n            speeds.add(speed)\n    distances = set()\n    for speed in speeds:\n        for i in range(m-1):\n            for j in range(i+1, m):\n                distance = (t_array[j] - t_array[i]) * speed + x_array[i]\n                distances.add(distance)\n    distances = list(distances)\n    distances.sort()\n    print(len(distances))\n    print(\" \".join(str(x) for x in distances))\n\nif __name__ == \"__main__\":\n    m, n = [int(x) for x in input().split()]\n    t_array = [int(x) for x in input().split()]\n    x_array = [int(x) for x in input().split()]\n    solve(m, n, t_array, x_array)\n", "\n\ndef main():\n    \"\"\"\n    Calculates the number of possible speeds at which the car could have been travelling given the number of milestones\n    seen, the times at which they were seen, and the distances along the road of each milestone.\n\n    :return: None\n    \"\"\"\n    # Get the number of milestones seen as well as the total number of milestones along the road\n    milestones_seen, total_milestones = map(int, input().split())\n\n    # Get the times at which the milestones were seen\n    times = list(map(int, input().split()))\n\n    # Get the distances along the road of each milestone\n    distances = list(map(int, input().split()))\n\n    # Get the number of possible speeds at which the car could have been travelling\n    num_speeds = get_num_speeds(milestones_seen, total_milestones, times, distances)\n\n    # Get the possible distances between the first milestone seen and the last milestone seen\n    distances_between = get_distances_between(milestones_seen, total_milestones, distances)\n\n    # Print the number of possible speeds at which the car could have been travelling\n    print(num_speeds)\n\n    # Print the possible distances between the first milestone seen and the last milestone seen\n    print(\" \".join(map(str, distances_between)))\n\ndef get_num_speeds(milestones_seen, total_milestones, times, distances):\n    \"\"\"\n    Calculates the number of possible speeds at which the car could have been travelling given the number of milestones\n    seen, the times at which they were seen, and the distances along the road of each milestone.\n\n    :param milestones_seen: The number of milestones seen\n    :param total_milestones: The total number of milestones along the road\n    :param times: The times at which the milestones were seen\n    :param distances: The distances along the road of each milestone\n    :return: The number of possible speeds at which the car could have been travelling\n    \"\"\"\n    # Define a set to store the possible speeds at which the car could have been travelling\n    speeds = set()\n\n    # For each milestone seen\n    for i in range(milestones_seen):\n        # For each milestone not seen\n        for j in range(milestones_seen, total_milestones):\n            # Calculate the speed at which the car could have been travelling\n            speed = (distances[j] - distances[i]) / (times[j] - times[i])\n\n            # Add the speed to the set of possible speeds at which the car could have been travelling\n            speeds.add(speed)\n\n    # Return the number of possible speeds at which the car could have been travelling\n    return len(speeds)\n\ndef get_distances_between(milestones_seen, total_milestones, distances):\n    \"\"\"\n    Calculates the possible distances between the first milestone seen and the last milestone seen given the number of\n    milestones seen and the distances along the road of each milestone.\n\n    :param milestones_seen: The number of milestones seen\n    :param total_milestones: The total number of milestones along the road\n    :param distances: The distances along the road of each milestone\n    :return: The possible distances between the first milestone seen and the last milestone seen\n    \"\"\"\n    # Define a list to store the possible distances between the first milestone seen and the last milestone seen\n    distances_between = []\n\n    # For each milestone seen\n    for i in range(milestones_seen):\n        # For each milestone not seen\n        for j in range(milestones_seen, total_milestones):\n            # Calculate the distance between the first milestone seen and the last milestone seen\n            distance = distances[j] - distances[i]\n\n            # Add the distance to the list of possible distances between the first milestone seen and the last\n            # milestone seen\n            distances_between.append(distance)\n\n    # Return the possible distances between the first milestone seen and the last milestone seen\n    return sorted(distances_between)\n\nif __name__ == \"__main__\":\n    main()\n", "print(\"hello world\")\n", "\n\ndef main():\n    \"\"\"\n    Calculates the number of possible speeds at which the car could have been travelling given the number of milestones\n    seen, the times at which they were seen, and the distances along the road of each milestone.\n\n    :return: None\n    \"\"\"\n    # Get the number of milestones seen as well as the total number of milestones along the road\n    milestones_seen, total_milestones = map(int, input().split())\n\n    # Get the times at which the milestones were seen\n    times = list(map(int, input().split()))\n\n    # Get the distances along the road of each milestone\n    distances = list(map(int, input().split()))\n\n    # Get the number of possible speeds at which the car could have been travelling\n    num_speeds = get_num_speeds(milestones_seen, total_milestones, times, distances)\n\n    # Get the possible distances between the first milestone seen and the last milestone seen\n    distances_between = get_distances_between(milestones_seen, total_milestones, distances)\n\n    # Print the number of possible speeds at which the car could have been travelling\n    print(num_speeds)\n\n    # Print the possible distances between the first milestone seen and the last milestone seen\n    print(\" \".join(map(str, distances_between)))\n\ndef get_num_speeds(milestones_seen, total_milestones, times, distances):\n    \"\"\"\n    Calculates the number of possible speeds at which the car could have been travelling given the number of milestones\n    seen, the times at which they were seen, and the distances along the road of each milestone.\n\n    :param milestones_seen: The number of milestones seen\n    :param total_milestones: The total number of milestones along the road\n    :param times: The times at which the milestones were seen\n    :param distances: The distances along the road of each milestone\n    :return: The number of possible speeds at which the car could have been travelling\n    \"\"\"\n    # Define a set to store the possible speeds at which the car could have been travelling\n    speeds = set()\n\n    # For each milestone seen\n    for i in range(milestones_seen):\n        # For each milestone not seen\n        for j in range(milestones_seen, total_milestones):\n            # Calculate the speed at which the car could have been travelling\n            speed = (distances[j] - distances[i]) / (times[j] - times[i])\n\n            # Add the speed to the set of possible speeds at which the car could have been travelling\n            speeds.add(speed)\n\n    # Return the number of possible speeds at which the car could have been travelling\n    return len(speeds)\n\ndef get_distances_between(milestones_seen, total_milestones, distances):\n    \"\"\"\n    Calculates the possible distances between the first milestone seen and the last milestone seen given the number of\n    milestones seen and the distances along the road of each milestone.\n\n    :param milestones_seen: The number of milestones seen\n    :param total_milestones: The total number of milestones along the road\n    :param distances: The distances along the road of each milestone\n    :return: The possible distances between the first milestone seen and the last milestone seen\n    \"\"\"\n    # Define a list to store the possible distances between the first milestone seen and the last milestone seen\n    distances_between = []\n\n    # For each milestone seen\n    for i in range(milestones_seen):\n        # For each milestone not seen\n        for j in range(milestones_seen, total_milestones):\n            # Calculate the distance between the first milestone seen and the last milestone seen\n            distance = distances[j] - distances[i]\n\n            # Add the distance to the list of possible distances between the first milestone seen and the last milestone seen\n            distances_between.append(distance)\n\n    # Return the possible distances between the first milestone seen and the last milestone seen\n    return sorted(distances_between)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\nimport math\n\ndef main():\n    # Read input\n    M, N = [int(x) for x in sys.stdin.readline().strip().split()]\n    T = [int(x) for x in sys.stdin.readline().strip().split()]\n    X = [int(x) for x in sys.stdin.readline().strip().split()]\n\n    # Calculate the differences in time and space.\n    time_diff = [T[i+1]-T[i] for i in range(len(T)-1)]\n    space_diff = [X[i+1]-X[i] for i in range(len(X)-1)]\n\n    # Calculate the possible speeds.\n    speeds = sorted(set(time_diff[i]/space_diff[i] for i in range(len(time_diff)) if space_diff[i] != 0))\n    print(len(speeds))\n    print(*speeds)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# SOLUTION\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef solve(m, n, t, x):\n    t_min, t_max = t[0], t[-1]\n    x_min, x_max = x[0], x[-1]\n    x_diff = x_max - x_min\n    t_diff = t_max - t_min\n    speeds = set()\n    for i in range(m-1):\n        for j in range(i+1, m):\n            speed = (x[j] - x[i]) / (t[j] - t[i])\n            speeds.add(speed)\n    speeds = sorted(speeds)\n    print(len(speeds))\n    print(' '.join(map(str, speeds)))\n\nif __name__ == \"__main__\":\n    m, n = read_ints()\n    t = read_ints()\n    x = read_ints()\n    solve(m, n, t, x)\n", "\n\n\n# SOLUTION 1\nimport sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().split()]\n\ndef solve(m, n, t, x):\n    t_min, t_max = t[0], t[-1]\n    x_min, x_max = x[0], x[-1]\n    x_diff = x_max - x_min\n    t_diff = t_max - t_min\n    speeds = set()\n    for i in range(m-1):\n        for j in range(i+1, m):\n            speed = (x[j] - x[i]) / (t[j] - t[i])\n            speeds.add(speed)\n    speeds = sorted(speeds)\n    print(len(speeds))\n    print(' '.join(map(str, speeds)))\n\nif __name__ == \"__main__\":\n    m, n = read_ints()\n    t = read_ints()\n    x = read_ints()\n    solve(m, n, t, x)\n", "\n\n#import sys\n#sys.stdin = open('input.txt')\n\nM, N = map(int, input().split())\nT = list(map(float, input().split()))\nX = list(map(int, input().split()))\n\n# calculate the distance between each two milestones (D)\nD = [X[i+1]-X[i] for i in range(N-1)]\n\n# calculate the time between each two milestones (T)\nT = [T[i+1]-T[i] for i in range(M-1)]\n\n# calculate the speed between each two milestones (S)\nS = [D[i]/T[i] for i in range(M-1)]\n\n# calculate the distance between the first milestone you saw and the second milestone you saw (D2)\nD2 = [S[i]*T[0] for i in range(M-1)]\n\n# sort D2 in increasing order\nD2 = sorted(D2)\n\n# remove duplicate values\nD2 = list(set(D2))\n\n# print output\nprint(len(D2))\nprint(*D2)\n", "\n\n#import sys\n#sys.stdin = open('input.txt')\n\nM, N = map(int, input().split())\nT = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\n# calculate the distance between each two milestones (D) \nD = [X[i+1]-X[i] for i in range(N-1)]\n\n# calculate the time between each two milestones (T) \nT = [T[i+1]-T[i] for i in range(M-1)]\n\n# calculate the speed between each two milestones (S) \nS = [D[i]/T[i] for i in range(M-1)]\n\n# calculate the distance between the first milestone you saw and the second milestone you saw (D2) \nD2 = [S[i]*T[0] for i in range(M-1)]\n\n# sort D2 in increasing order\nD2 = sorted(D2)\n\n# remove duplicate values\nD2 = list(set(D2))\n\n# print output\nprint(len(D2))\nprint(*D2)\n"]