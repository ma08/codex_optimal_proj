["import sys\nfrom collections import defaultdict\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    n, k = read_ints()\n    x = read_ints()\n    y = read_ints()\n    points = list(zip(x, y))\n    points.sort()\n    left = [y for x, y in points if x < 0]\n    right = [y for x, y in points if x > 0]\n    left.sort(reverse=True)\n    right.sort(reverse=True)\n    i = 0\n    j = 0\n    ans = 0\n    while i < n and j < n:\n        if i < len(left) and j < len(right) and left[i] <= right[j]:\n            i += 1\n            ans += 1\n        elif i < len(left):\n            i += 1\n            ans += 1\n        else:\n            if j < len(right):\n                j += 1\n                ans += 1\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n# The idea is to sort the points by x-coordinate, and then process them in that order\n# When processing a point, we maintain a set of all the platforms that have already been placed\n# We can do this in O(log n) time by keeping the platforms sorted by y-coordinate\n# For each platform, we check if the point is above or below it\n# If it's above, we can safely ignore it\n# If it's below, we can add it to a count, and then check if the point is close enough to the platform that we should remove it\n# If we remove it, we also check if the point is close enough to the next platform that we should remove it too\n# This can be done by checking if the y-coordinate of the point plus the length of the platform is greater than the y-coordinate of the next platform\n# If it is, then we remove the next platform as well\n# Otherwise, we keep the platform\n# We then insert the new platform into the set\n# We repeat this process for all the points, and then we're done\n# This runs in O(n log n) time, which is fast enough for the time limit\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n, k = map(int, sys.stdin.readline().split())\n        xs = list(map(int, sys.stdin.readline().split()))\n        ys = list(map(int, sys.stdin.readline().split()))\n        points = [(x, y) for x, y in zip(xs, ys)]\n        points.sort()\n        platforms = []\n        count = 0\n        for x, y in points:\n            while platforms and y > platforms[0][1]:\n                platforms.pop(0)\n            if not platforms:\n                platforms.append((x, y))\n                continue\n            if y - platforms[0][1] <= k:\n                count += 1\n                if len(platforms) > 1 and y + k > platforms[1][1]:\n                    platforms.pop(0)\n                    continue\n            platforms.append((x, y))\n        print(count)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n# The idea is to sort the points by x-coordinate, and then process them in that order. When processing a point, we maintain a set of all the platforms that have already been placed. We can do this in O(log n) time by keeping the platforms sorted by y-coordinate. For each platform, we check if the point is above or below it. If it's above, we can safely ignore it. If it's below, we can add it to a count, and then check if the point is close enough to the platform that we should remove it. If we remove it, we also check if the point is close enough to the next platform that we should remove it too. This can be done by checking if the y-coordinate of the point plus the length of the platform is greater than the y-coordinate of the next platform. If it is, then we remove the next platform as well. Otherwise, we keep the platform. We then insert the new platform into the set. We repeat this process for all the points, and then we're done. This runs in O(n log n) time, which is fast enough for the time limit. \n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n, k = map(int, sys.stdin.readline().split())\n        xs = list(map(int, sys.stdin.readline().split()))\n        ys = list(map(int, sys.stdin.readline().split()))\n        points = [(x, y) for x, y in zip(xs, ys)]\n        points.sort()\n        platforms = []\n        count = 0\n        for x, y in points:\n            while platforms and y > platforms[0][1]:\n                platforms.pop(0)\n            if not platforms:\n                platforms.append((x, y))\n                continue\n            if y - platforms[0][1] <= k:\n                count += 1\n                if len(platforms) > 1 and y + k > platforms[1][1]:\n                    platforms.pop(0)\n                    continue\n            platforms.append((x, y))\n        print(count)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n# The idea is to sort the points by x-coordinate, and then process them in that order.\n# When processing a point, we maintain a set of all the platforms that have already been placed.\n# We can do this in O(log n) time by keeping the platforms sorted by y-coordinate.\n# For each platform, we check if the point is above or below it.\n# If it's above, we can safely ignore it.\n# If it's below, we can add it to a count, and then check if the point is close enough to the platform that we should remove it.\n# If we remove it, we also check if the point is close enough to the next platform that we should remove it too.\n# This can be done by checking if the y-coordinate of the point plus the length of the platform is greater than the y-coordinate of the next platform.\n# If it is, then we remove the next platform as well. Otherwise, we keep the platform.\n# We then insert the new platform into the set.\n# We repeat this process for all the points, and then we're done.\n# This runs in O(n log n) time, which is fast enough for the time limit.\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n, k = map(int, sys.stdin.readline().split())\n        xs = list(map(int, sys.stdin.readline().split()))\n        ys = list(map(int, sys.stdin.readline().split()))\n        points = [(x, y) for x, y in zip(xs, ys)]\n        points.sort()\n        platforms = []\n        count = 0\n        for x, y in points:\n            while platforms and y > platforms[0][1]:\n                platforms.pop(0)\n            if not platforms:\n                platforms.append((x, y))\n                continue\n            if y - platforms[0][1] <= k:\n                count += 1\n                if len(platforms) > 1 and y + k > platforms[1][1]:\n                    platforms.pop(0)\n                    continue\n            platforms.append((x, y))\n        print(count)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\n    \"\"\"read ints\"\"\"\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, k = read_ints()\n        x = read_ints()\n        y = read_ints()\n        points = list(zip(x, y))\n        points.sort()\n        left = [y for x, y in points]\n        right = [y for x, y in points]\n        left.sort()\n        right.sort()\n        i = 0\n        j = 0\n        ans = 0\n        while i < n and j < n:\n            if left[i] <= right[j]:\n                i += 1\n                ans += 1\n            else:\n                j += 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n, k = read_ints()\n        x = read_ints()\n        y = read_ints()\n        points = list(zip(x, y))\n        points.sort()\n        left = [y for x, y in points if x <= 0]\n        right = [y for x, y in points if x >= 0]\n        left.sort(reverse=True)\n        right.sort(reverse=True)\n        i = 0\n        j = 0\n        ans = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                i += 1\n                ans += 1\n            else:\n                j += 1\n                ans += 1\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"]