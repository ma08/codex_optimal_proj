["\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10**5)\n\n# read the input\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor i in range(n - 1):\n    edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub-tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v-1] == 1 else 0\n    black[v] = 1 if a[v-1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i-1] = max(ans[i-1],\n                           abs(white[i]-black[i]-(white[u]-black[u])))\nprint(*ans)\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count array\nwhite_count = [0 for _ in range(n)]  # white_count[i] is the number of white vertices in the subtree of vertex i\nblack_count = [0 for _ in range(n)]  # black_count[i] is the number of black vertices in the subtree of vertex i\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n\n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n\n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n\n        # Set the parent of the neighbor\n        parent[v] = u\n\n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Initialize the result array\nresult = [0 for _ in range(n)]\n\n# Start with the last vertex (the root of the tree)\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n\n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n\n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n\n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n\n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n", "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\ndef main():\n    # read the input\n    n = int(input())\n    a = list(map(int, input().split()))\n    edges = []\n    for i in range(n - 1):\n        edges.append(tuple(map(int, input().split())))\n\n# build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# dfs to find the number of white and black vertices in the sub-tree\nvisited = [False] * (n + 1)\nwhite = defaultdict(int)\nblack = defaultdict(int)\n\n\ndef dfs(v):\n    visited[v] = True\n    white[v] = 1 if a[v - 1] == 1 else 0\n    black[v] = 1 if a[v - 1] == 0 else 0\n    for u in graph[v]:\n        if not visited[u]:\n            dfs(u)\n            white[v] += white[u]\n            black[v] += black[u]\n\n\ndfs(1)\n\n# find the answer\nans = [0] * n\nfor i in range(1, n + 1):\n    for u in graph[i]:\n        if visited[u]:\n            ans[i - 1] = max(ans[i - 1],\n                             abs(white[i] - black[i] - (white[u] - black[u])))\nprint(*ans)\n", "\n\nfrom sys import stdin\nfrom collections import deque\n\ninput_lines = deque(stdin.read().splitlines())\n\n# Read the number of vertices\nn = int(input_lines.popleft())\n\n# Read the colors of the vertices\ncolors = list(map(int, input_lines.popleft().split()))\n\n# Read the edges\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input_lines.popleft().split())\n    edges.append((u - 1, v - 1))\n\n# Initialize the adjacency list\nadj_list = [[] for _ in range(n)]\nfor (u, v) in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Initialize the parent array\nparent = [-1 for _ in range(n)]\n\n# Initialize the white and black count arrays and the result array\nwhite_count = [0 for _ in range(n)] # The number of white vertices in the subtree of the vertex\nblack_count = [0 for _ in range(n)] # The number of black vertices in the subtree of the vertex\nresult = [0 for _ in range(n)] # The number of vertices that should be painted in the subtree of the vertex\n\n# Initialize the queue\nqueue = deque()\n\n# Start with the first vertex\nqueue.append(0)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Set the count of the vertex\n    white_count[u] = colors[u]\n    black_count[u] = 1 - colors[u]\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Set the parent of the neighbor\n        parent[v] = u\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Start with the last vertex\nqueue.append(n - 1)\n\n# Perform BFS\nwhile len(queue) > 0:\n    # Get the next vertex\n    u = queue.popleft()\n    \n    # Update the result of the vertex\n    result[u] = max(white_count[u] - black_count[u], 0)\n    \n    # Visit all the neighbors of the vertex\n    for v in adj_list[u]:\n        # Skip the parent vertex\n        if v == parent[u]:\n            continue\n        \n        # Update the white and black counts of the neighbor\n        white_count[v] += white_count[u]\n        black_count[v] += black_count[u]\n        \n        # Add the neighbor to the queue\n        queue.append(v)\n\n# Print the result\nprint(' '.join(map(str, result)))\n"]