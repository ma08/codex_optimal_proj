["\n#\n# Greedy Algorithm.\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n", "\n\n# Greedy Algorithm.\n#\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n", "\n# Greedy Algorithm \nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1])\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n", "\n\nfrom sys import stdin\n\ndef main():\n    t = int(stdin.readline())\n    for i in range(t):\n        n = int(stdin.readline())\n        segments = []\n        for j in range(n):\n            l, r = [int(x) for x in stdin.readline().split()]\n            segments.append([l, r])\n        # Sort segments in increasing order of left and right endpoints\n        segments.sort()\n        # Now, segments are in increasing order of left endpoint\n        # and in decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # Therefore, we need to reverse the list\n        # This is done because we will be using the list in decreasing order of right endpoint\n        segments.reverse()\n        # Maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        max_non_intersecting_segments = 0\n        # List that contains the right endpoint of the current segment\n        # and the maximum number of non-intersecting segments\n        # that are in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This is because the input is given in increasing order of left endpoint\n        # and decreasing order of right endpoint\n        # This list is sorted in increasing order of right endpoint\n        right_endpoint_and_max_non_intersecting_segments = []\n        for j in range(n):\n            # Check if the left endpoint of the current segment\n            # is greater than the right endpoint of the last segment\n            # in the right_endpoint_and_max_non_intersecting_segments list\n            if len(right_endpoint_and_max_non_intersecting_segments) > 0:\n                if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[-1][0]:\n                    # If yes, then this segment can be added to the list\n                    # of non-intersecting segments\n                    # Therefore, increase the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    max_non_intersecting_segments += 1\n                    # Add the right endpoint of the current segment\n                    # and the maximum number of non-intersecting segments\n                    # that are in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n                else:\n                    # If not, then we need to find the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    # This is the binary search algorithm\n                    # This is done because the list is sorted in increasing order of right endpoint\n                    left = 0\n                    right = len(right_endpoint_and_max_non_intersecting_segments) - 1\n                    while left < right:\n                        mid = (left + right) // 2\n                        if segments[j][1] > right_endpoint_and_max_non_intersecting_segments[mid][0]:\n                            left = mid + 1\n                        else:\n                            right = mid\n                    # This is the index of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # such that the right endpoint of the current segment\n                    # is less than or equal to the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # and the right endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # before it in the right_endpoint_and_max_non_intersecting_segments list\n                    # This is because the input is given in increasing order of left endpoint\n                    # and decreasing order of right endpoint\n                    index = right\n                    # Check if the left endpoint of the current segment\n                    # is greater than the right endpoint of the segment\n                    # in the right_endpoint_and_max_non_intersecting_segments list\n                    # at the index found above\n                    if segments[j][0] > right_endpoint_and_max_non_intersecting_segments[index][0]:\n                        # If yes, then this segment can be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        max_non_intersecting_segments += 1\n                        # Add the right endpoint of the current segment\n                        # and the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # This is because the input is given in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        right_endpoint_and_max_non_intersecting_segments.insert(index + 1, [segments[j][1], max_non_intersecting_segments])\n                    else:\n                        # If not, then this segment cannot be added to the list\n                        # of non-intersecting segments\n                        # Therefore, increase the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # by the maximum number of non-intersecting segments\n                        # that are in increasing order of left endpoint\n                        # and decreasing order of right endpoint\n                        # of the segment\n                        # in the right_endpoint_and_max_non_intersecting_segments list\n                        # at the index found above\n                        max_non_intersecting_segments += right_endpoint_and_max_non_intersecting_segments[index][1]\n            else:\n                # If not, then this segment can be added to the list\n                # of non-intersecting segments\n                # Therefore, increase the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                max_non_intersecting_segments += 1\n                # Add the right endpoint of the current segment\n                # and the maximum number of non-intersecting segments\n                # that are in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                # This is because the input is given in increasing order of left endpoint\n                # and decreasing order of right endpoint\n                right_endpoint_and_max_non_intersecting_segments.append([segments[j][1], max_non_intersecting_segments])\n        # Print the answer\n        print(max_non_intersecting_segments)\n\nif __name__ == \"__main__\":\n    main()\n", "\n# https://www.hackerrank.com/challenges/greedy-florist/problem\n# Greedy Algorithm \n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = []\n    for __ in range(n):\n        a.append(list(map(int, input().split())))\n    a.sort(key=lambda x: x[1], reverse=True)\n    count = 0\n    j = 0\n    for i in range(n):\n        if a[i][0] >= a[j][1]:\n            count += 1\n            j = i\n    print(count)\n"]