["\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n", "\ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n", "\n\ndef find_max_team_size(skills):\n    unique_skills = list(set(skills))\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1:\n        return 0\n    elif len(unique_skills) == 2:\n        return min(same_skills[unique_skills[0]], same_skills[unique_skills[1]], same_skills[unique_skills[2]])\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n", "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n", "\n\ndef find_max_team_size(skills):\n    unique_skills = set(skills) # set of unique skills\n    same_skills = {}\n    for skill in skills: # count the number of times each skill appears\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1: # if there is only one skill, no one can be paired\n        return 0\n    elif len(unique_skills) == 2: # if there are two skills, the minimum number of times that skill appears is the maximum team size\n        return min(same_skills.values())\n    else: # if there are more than two skills, the minimum number of times that skill appears is the maximum team size\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"]