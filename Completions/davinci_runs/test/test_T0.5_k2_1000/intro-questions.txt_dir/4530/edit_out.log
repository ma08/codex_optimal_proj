2022-04-11 20:49:53.060919 num operations 2
2022-04-11 20:49:53.060977 size on input set 1
2022-04-11 20:49:56.860089 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef find_max_team_size(skills):\n    unique_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1:\n        return 0\n    elif len(unique_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    },
    {
      "index": 1,
      "text": "\n\ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n"
    }
  ],
  "created": 1649724593,
  "object": "edit"
}
2022-04-11 20:49:56.860586 fix spelling mistakes 2 ['\n\ndef find_max_team_size(skills):\n    unique_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1:\n        return 0\n    elif len(unique_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n', '\n\ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n']
2022-04-11 20:49:56.860709 size on output set 2
2022-04-11 20:49:56.860725 size on input set 2
2022-04-11 20:50:02.280517 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef find_max_team_size(skills):\n    unique_skills = list(set(skills))\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1:\n        return 0\n    elif len(unique_skills) == 2:\n        return min(same_skills[unique_skills[0]], same_skills[unique_skills[1]], same_skills[unique_skills[2]])\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    },
    {
      "index": 1,
      "text": "\n\ndef find_max_team_size(skills):\n    unique_skills = set(skills) # set of unique skills\n    same_skills = {}\n    for skill in skills: # count the number of times each skill appears\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1: # if there is only one skill, no one can be paired\n        return 0\n    elif len(unique_skills) == 2: # if there are two skills, the minimum number of times that skill appears is the maximum team size\n        return min(same_skills.values())\n    else: # if there are more than two skills, the minimum number of times that skill appears is the maximum team size\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n"
    }
  ],
  "created": 1649724597,
  "object": "edit"
}
2022-04-11 20:50:02.280821 fix syntax errors 2 ['\n\ndef find_max_team_size(skills):\n    unique_skills = list(set(skills))\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1:\n        return 0\n    elif len(unique_skills) == 2:\n        return min(same_skills[unique_skills[0]], same_skills[unique_skills[1]], same_skills[unique_skills[2]])\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n', '\n\ndef find_max_team_size(skills):\n    unique_skills = set(skills) # set of unique skills\n    same_skills = {}\n    for skill in skills: # count the number of times each skill appears\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n    \n    if len(unique_skills) == 1: # if there is only one skill, no one can be paired\n        return 0\n    elif len(unique_skills) == 2: # if there are two skills, the minimum number of times that skill appears is the maximum team size\n        return min(same_skills.values())\n    else: # if there are more than two skills, the minimum number of times that skill appears is the maximum team size\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_max_team_size(skills))\n']
2022-04-11 20:50:05.003007 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n"
    },
    {
      "index": 1,
      "text": "\ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n"
    }
  ],
  "created": 1649724602,
  "object": "edit"
}
2022-04-11 20:50:05.003258 fix syntax errors 2 ['\ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n', '\ndef find_min_team_size(skills):\n    uniq_skills = set(skills)\n    same_skills = {}\n    for skill in skills:\n        if skill in same_skills:\n            same_skills[skill] += 1\n        else:\n            same_skills[skill] = 1\n\n    if len(uniq_skills) == 1:\n        return 0\n    elif len(uniq_skills) == 2:\n        return min(same_skills.values())\n    else:\n        return min(same_skills.values())\n\nif __name__ == "__main__":\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        skills = list(map(int, input().split()))\n        print(find_min_team_size(skills))\n']
2022-04-11 20:50:05.003453 size on output set 3
2022-04-11 20:50:05.003471 num operations 2
2022-04-11 20:50:05.003475 size on input set 1
2022-04-11 20:50:09.644527 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. \n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    }
  ],
  "created": 1649724605,
  "object": "edit"
}
2022-04-11 20:50:09.644824 fix spelling mistakes 2 ['\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. \n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n']
2022-04-11 20:50:09.644862 size on output set 2
2022-04-11 20:50:09.644866 size on input set 2
2022-04-11 20:50:14.868519 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    }
  ],
  "created": 1649724609,
  "object": "edit"
}
2022-04-11 20:50:14.868890 fix syntax errors 2 ['\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team. If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it. The answer is the size of the first team\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n']
2022-04-11 20:50:19.724210 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n"
    }
  ],
  "created": 1649724615,
  "object": "edit"
}
2022-04-11 20:50:19.724661 fix syntax errors 2 ['\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n', '\n\n# SOLUTION\n# This problem can be solved using a simple greedy approach. We will iterate over the skills and we will try to add them to the first team.\n# If the skill is already in the first team, we will add it to the second team. If the skill is already in the second team, we will skip it.\n# The answer is the size of the first team.\n#\n# TIME COMPLEXITY: O(n)\n# SPACE COMPLEXITY: O(n)\n\nt = int(input())\nfor _ in range(t):\n  n = int(input())\n  a = list(map(int, input().split()))\n  first_team = set()\n  second_team = set()\n  for i in range(n):\n    if a[i] not in first_team:\n      first_team.add(a[i])\n    elif a[i] not in second_team:\n      second_team.add(a[i])\n  print(len(first_team))\n']
2022-04-11 20:50:19.724709 size on output set 2
