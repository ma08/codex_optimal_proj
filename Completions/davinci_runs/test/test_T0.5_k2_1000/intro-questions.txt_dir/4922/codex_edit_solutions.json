["\n\ndef main():\n    m, n = map(int, input().split()) # number of clauses and variables\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))\n    if m < 9: # number of clauses\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport os\ndef main():\n    print(\"Current working directory is: \" + str(os.getcwd()))\n    os.chdir(\"C:\\\\Users\\\\Vikas\\\\Desktop\\\\Python\")\n    print(\"Current working directory is: \" + str(os.getcwd()))\n    print(\"List of files in directory: \" + str(os.getcwd()))\n    print(os.listdir(\"C:\\\\Users\\\\Vikas\\\\Desktop\\\\Python\"))\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()] # read first line\n\n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\nimport os\ndef main():\n    print(\"Current working directory is: \" + os.getcwd()) # current working directory\n    os.chdir(\"C:\\\\Users\\\\Vikas\\\\Desktop\\\\Python\") # change directory\n    print(\"Current working directory is: \" + os.getcwd()) # current working directory\n    print(\"List of files in directory: \" + os.getcwd()) # list of files in directory\n    print(os.listdir(\"C:\\\\Users\\\\Vikas\\\\Desktop\\\\Python\")) # list of files in directory\n\nif __name__ == '__main__':\n    main()\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable. \n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True. \n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied. \n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1\u2228x2\u2228x3)\u2227(\u00acx1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228\u00acx3)\u2227(x1\u2228x2\u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise. \n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)] # list of lists\n\ndef satisfiable(clauses, n):\n    for clause in clauses:\n        if clause[0] < 0:\n            if clause[1] < 0:\n                if clause[2] < 0:\n                    return False\n            else:\n                if clause[2] > 0:\n                    return False\n        else:\n            if clause[1] > 0:\n                if clause[2] > 0:\n                    return False\n    return True\n\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable. \n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1 \u2228x2 \u2228x3)\u2227(\u00acx1 \u2228\u00acx2 \u2228x3)\u2227(x1 \u2228\u00acx2 \u2228x3)\u2227(x1 \u2228\u00acx2 \u2228\u00acx3)\u2227(x1 \u2228x2 \u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    if m < n:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef main():\n    print(\"Hello World\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    # m = number of clauses\n    # n = number of variables\n    m, n = [int(x) for x in input().split()]\n\n    # if m < 8, it is unsatisfiable\n    if m < 8:\n        print(\"unsatisfiable\")\n    else:\n        print(\"satisfiable\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n# SOLUTION \nm, n = map(int, input().split())\nclauses = [list(map(int, input().split())) for _ in range(m)]\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\nimport sys\n\ndef main():\n    m, n = map(int, sys.stdin.readline().split())\n    if m < 8:\n        print(\"unsatisfied\")\n    else:\n        print(\"satisfied\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main():\n    m,n = map(int, sys.stdin.readline().split())\n    if m < n:\n        print(\"unsatisfied\")\n    else:\n        print(\"satisfied\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()] # m is the number of hours, n is the number of days.\n        \n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1 \u2228 x2 \u2228 x3)\u2227(\u00acx1 \u2228\u00acx2 \u2228 x3)\u2227(x1 \u2228\u00acx2 \u2228 x3)\u2227(x1 \u2228\u00acx2 \u2228\u00acx3)\u2227(x1 \u2228 x2 \u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\n# m = number of clauses\n# n = number of variables\nm, n = [int(x) for x in input().split()]\n\n# if m < 8, it is unsatisfiable\nif m < 8:\n    print(\"UNSATISFIABLE\")\nelse:\n    print(\"SATISFIABLE\")\n", "\n\ndef main():\n    m = int(input())\n    if m < 10 or m > 100:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n\"\"\"\nThe problem is to determine if a 3-SAT instance with m clauses and n variables is satisfiable.\n\nThe input is the number of clauses m, the number of variables n, and the m clauses. Each clause consists of 3 distinct space-separated integers in the range [\u2212n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True. \n\nA 3-SAT instance with m clauses and n variables is satisfiable if there is a way to assign values to the n variables such that all m clauses are satisfied.\n\nAn example of a 3-SAT instance is shown below (from sample input 1):\n\n(\u00acx1\u2228x2\u2228x3)\u2227(\u00acx1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228x3)\u2227(x1\u2228\u00acx2\u2228\u00acx3)\u2227(x1\u2228x2\u2228\u00acx3)\n\nThe output is \u201csatisfactory\u201d if the 3-SAT instance is satisfiable, and \u201cunsatisfactory\u201d otherwise.\n\nThe judge \u00d8yvind hates 3-SAT instances with less than eight clauses \u2013 as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever \u00d8yvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not \u2013 and therefore he will judge these problem instances to be satisfactory.\n\nGiven an instance of 3-SAT, can you help find \u00d8yvind\u2019s judgement?\n\"\"\"\n\n#n = number of variables\n#m = number of clauses\n\n#get input\nm, n = map(int, input().split())\nclauses = []\nfor i in range(m):\n    clauses.append(list(map(int, input().split())))\n\n#check if it is unsatisfactory\nif m < 8:\n    print(\"unsatisfactory\")\nelse:\n    print(\"satisfactory\")\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    if m < n:\n        print(\"unsatisfactory\") \n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()] # read first line\n        \n        if m < 8 or n < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\nimport sys\n\ndef main(filepath):\n    with open(filepath, 'r') as f:\n        m, n = [int(i) for i in f.readline().strip().split()] # m is the number of hours, n is the number of days\n\n        if m < 8:\n            print('unsatisfactory')\n        else:\n            print('satisfactory')\n\nif __name__ == '__main__':\n    main(sys.argv[1])\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    clauses = []\n    for i in range(m):\n        clauses.append(list(map(int, input().split())))\n    if m > 10:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    m, n = map(int, input().split())\n    clauses = [[] for i in range(m)]\n    for i in range(m):\n        clauses[i] = list(map(int, input().split()))\n    if m > 8:\n        print(\"unsatisfactory\")\n    else:\n        print(\"satisfactory\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    print(\"Hello World\")\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    print(\"Hello World!\")\n\nif __name__ == '__main__':\n    main()\n"]