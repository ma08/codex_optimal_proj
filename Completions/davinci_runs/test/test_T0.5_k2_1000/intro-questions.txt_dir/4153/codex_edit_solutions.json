["\n\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "\nimport sys\n\ndef main():\n\ts = sys.stdin.readline().rstrip()\n\tstack = []\n\tans = 0\n\tfor c in s:\n\t\tif c == '0':\n\t\t\tif len(stack) > 0 and stack[-1] == '1':\n\t\t\t\tstack.pop()\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tstack.append(c)\n\t\telse:\n\t\t\tstack.append(c)\n\tprint(ans)\n\nif __name__ == '__main__':\n\tmain()\n", "S = raw_input()\n\n# The number of cubes that can be removed is the maximum number of zeros that\n# are adjacent to ones. Since there can be at most 10^5 cubes, we can solve this\n# problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number\n# of zeros that are not adjacent to ones. The number of zeros that are not\n# adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros\n# minus the number of zeros that are not adjacent to other zeros. The number of\n# zeros that are not adjacent to other zeros is the number of zeros that are at\n# the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of\n# zeros minus the number of zeros that are at the beginning or end of the\n# string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\")) \nprint(zeros - zeros_at_beginning_or_end)\n", "\nS = input()\n\n# The number of cubes that can be removed is the maximum number of zeros that are adjacent to ones.\n# Since there can be at most 10^5 cubes, we can solve this problem in O(N) time.\n\n# The number of zeros adjacent to ones is the number of zeros minus the number of zeros that are not adjacent to ones.\n# The number of zeros that are not adjacent to ones is the number of zeros that are adjacent to other zeros.\n# The number of zeros that are adjacent to other zeros is the number of zeros minus the number of zeros that are not adjacent to other zeros.\n# The number of zeros that are not adjacent to other zeros is the number of zeros that are at the beginning or end of the string.\n\n# This means that the number of cubes that can be removed is the number of zeros minus the number of zeros that are at the beginning or end of the string.\n\nzeros = S.count(\"0\")\nzeros_at_beginning_or_end = len(S) - len(S.lstrip(\"0\").rstrip(\"0\"))\nprint(zeros - zeros_at_beginning_or_end)\n", "\nimport sys\n\ndef main():\n    s = sys.stdin.readline().rstrip()\n    stack = []\n    ans = 0\n    for c in s:\n        if c == '0':\n            if len(stack) > 0 and stack[-1] == '1':\n                stack.pop()\n                ans += 1\n            else:\n                stack.append(c)\n        else:\n            stack.append(c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    print(\"Hello World!\")\n\nif __name__ == '__main__':\n    main()\n"]