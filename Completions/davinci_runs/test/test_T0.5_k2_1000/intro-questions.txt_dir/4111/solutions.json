["n=int(input())\narr=list(map(int,input().split()))\narr1=[]\narr2=[]\ncount1=0\ncount2=0\nfor i in range(n):\n\tif(i%2==0):\n\t\tcount1+=arr[i]\n\telse:\n\t\tcount2+=arr[i]\nans=0\ntemp1=0\ntemp2=0\nfor i in range(n):\n\tif(i%2==0):\n\t\tval1=temp1+count2-temp2\n\t\tval2=temp2+count1-temp1-arr[i]\n\t\tif(val1==val2):\n\t\t\tans+=1\n\t\ttemp1+=arr[i]\n\telse:\n\t\tval1=temp1+count2-temp2-arr[i]\n\t\tval2=temp2+count1-temp1\n\t\tif(val1==val2):\n\t\t\tans+=1\n\t\ttemp2+=arr[i]\nprint(ans)\n", "n = int(input())\na = list(map(int, input().split()))\nb = [0]\nc = [0, 0]\nfor i in range(0, n, 2):\n    b.append(b[-1] + a[i])\n    b.append(b[-1])\n    if (i + 1 < n):\n        c.append(c[-1] + a[i + 1])\n        c.append(c[-1])\n#print(b)\n#print(c)\nans = 0\nfor i in range(n):\n    k1 = 0\n    k2 = 0\n    k1 += b[i] + c[n] - c[i + 1]\n    k2 += c[i] + b[n] - b[i + 1]\n    #print(i, k1, k2)\n    if (k1 == k2):\n        ans += 1\nprint(ans)", "def mi():\n    return list(map(int, input().split()))\n'''\n7\n5 5 4 5 5 5 6\n'''\nn = int(input())\na = list(mi())\n\nod = 0\nev = 0\n\nfor i in range(n):\n    if i%2:\n        od+=a[i]\n    else:\n        ev+=a[i]\n\ncnt = 0\nrod, rev = 0,0\n\nfor i in range(n-1,-1,-1):\n    if i%2==0:\n        ev-=a[i]\n    else:\n        od-=a[i]\n    if ev+rev==od+rod:\n        cnt+=1\n    if i%2==0:\n        rod+=a[i]\n    else:\n        rev+=a[i]\nprint (cnt)\n", "n = int(input())\nA = list(map(int, input().split()))\nsum_left_odd = [0] * (n + 1)\nsum_left_even = [0] * (n + 1)\nsum_right_odd = [0] * (n + 1)\nsum_right_even = [0] * (n + 1)\nfor i in range(n):\n    if i % 2 == 0:\n        sum_left_even[i] = sum_left_even[i - 1] + A[i]\n        sum_left_odd[i] = sum_left_odd[i - 1]\n    else:\n        sum_left_even[i] = sum_left_even[i - 1]\n        sum_left_odd[i] = sum_left_odd[i - 1] + A[i]\n\nB = A[::-1]\nfor i in range(n):\n    if i % 2 == 0:\n        sum_right_even[i] = sum_right_even[i - 1] + B[i]\n        sum_right_odd[i] = sum_right_odd[i - 1]\n    else:\n        sum_right_even[i] = sum_right_even[i - 1]\n        sum_right_odd[i] = sum_right_odd[i - 1] + B[i]\n\nanswer = 0\nfor i in range(n):\n    if n % 2:\n        answer += int(sum_left_odd[i] + sum_right_even[n - i - 1] == sum_left_even[i] + sum_right_odd[n - i - 1])\n    else:\n        answer += int(sum_left_odd[i] + sum_right_odd[n - i - 1] == sum_left_even[i] + sum_right_even[n - i - 1])\nprint(answer)\n", "n = int(input())\na = list(map(int, input().split()))\nf1 = s1 = f2 = s2 = 0\nfor i in range(len(a)):\n    if i % 2 == 0:\n        f2 += a[i]\n    else:\n        s2 += a[i]\nres = 0\nz = (n - 1) % 2\nfor i in range(len(a)):\n    if i % 2 == 0:\n        f2 -= a[i]\n        if f2 + s1 == s2 + f1:\n            res += 1\n        f1 += a[i]\n    else:\n        s2 -= a[i]\n        if f2 + s1 == s2 + f1:\n            res += 1\n        s1 += a[i]\nprint(res)", "n=int(input())\nL=[int(i) for i in input().split()]\ne=0\nd=0\nfor i in range(n):\n    if (i+1)%2==0:\n        e+=L[i]\n    else:\n        d+=L[i]\ns=0\ne1=0\nd1=0\n#print(e, d)\nfor i in range(n-1, -1, -1):\n    if (i+1)%2==0:\n        e=e-L[i]\n        if e+e1==d+d1:\n            s+=1\n        d1+=L[i]\n    else:\n        d=d-L[i]\n        if e+e1==d+d1:\n            s+=1\n        e1+=L[i]\n    #print(e, d, e1, d1)\nprint(s)\n", "n = int(input().strip())\nweights = list(map(int, input().strip().split()))\n\nres = 0\n\nsum_even = sum(weights[1::2])\nsum_odd = sum(weights[2::2])\n\nfor idx in range(n):\n    if sum_even == sum_odd:\n        res += 1\n    if idx == n-1:\n        break\n    if idx % 2 == 0:\n        sum_even += weights[idx]\n        sum_even -= weights[idx+1]\n    else:\n        sum_odd += weights[idx]\n        sum_odd -= weights[idx+1]\n\nprint(res)\n", "n = int(input())\narr = [int(x) for x in input().split()]\nevens = [0]\nodds = [0]\nfor i in range(len(arr)):\n    if i % 2 == 0:\n        evens.append(evens[-1] + arr[i])\n    else:\n        odds.append(odds[-1] + arr[i])\nevens += [evens[-1]]\nodds += [odds[-1]]\ncnt = 0\nfor i in range(len(arr)):\n    if i % 2 == 0:\n        if evens[i//2] + (odds[-1] - odds[i//2]) == odds[i//2] + (evens[-1] - evens[i//2 + 1]):\n            cnt += 1\n    else:\n        if evens[i//2 + 1] + (odds[-1] - odds[i//2 + 1]) == odds[i//2] + (evens[-1] - evens[i//2 + 1]):\n            cnt += 1        \nprint(cnt)", "n = int(input())\na = list(map(int, input().split()))\n\n\nc = [0]\nnc = [0]\n\nfnc = sum(a[::2])\nfc = sum(a[1::2])\n\nchet = False\n\nfor s in a:\n\n    if chet:\n        c.append(c[-1] + s)\n        nc.append(nc[-1])\n    else:\n        nc.append(nc[-1] + s)\n        c.append(c[-1])\n\n    chet = not chet\n\ngood = 0\nfor i in range(1, n+1):\n    sum_chet = c[i-1] + fnc - nc[i]\n    sum_nc = nc[i-1] + fc -c[i]\n    if sum_chet == sum_nc:\n        good+=1\n\n\nprint(good)\n", "n = int(input())\na = list(map(int, input().split()))\n\ns1 = sum(a[1::2])\ns2 = sum(a[2::2])\n\n#print(s1, s2)\n\n\nr = 0\nif s1 == s2:\n    r+=1\n\nfor i, aa in enumerate(a[1:], 1):\n    if i % 2 == 1:\n        s1 -= a[i]\n        s1 += a[i-1]\n    else:\n        s2 -= a[i]\n        s2 += a[i-1]\n\n    if s1 == s2:\n        r += 1\n\nprint(r)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\n\ndef main():\n    n = get_int()\n    li = get_list()\n    odd_sum = [0]\n    even_sum = [0]\n    for i,ele in enumerate(li):\n        if i%2==0:\n            even_sum.append(even_sum[-1]+ele)\n            odd_sum.append(odd_sum[-1])\n        else: \n            odd_sum.append(odd_sum[-1]+ele)\n            even_sum.append(even_sum[-1])\n    res = 0\n    #print(odd_sum)\n    #print(even_sum)\n    for i in range(1,n+1):\n        if even_sum[i-1]+odd_sum[-1]-odd_sum[i]==odd_sum[i-1]+even_sum[-1]-even_sum[i]:\n            res+=1\n    print(res)\n\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n=int(input())\na=list(map(int,input().split()))\nb=[[0,0]]\ne=o=0\nfor i in range(n):\n    if i%2==0:\n        o+=a[i]\n    else:\n        e+=a[i]\n    b.append([e,o])\nans=0\n#print(b)\nfor i in range(n):\n    if i%2==0:\n        o1=b[i][1]\n        e1=b[i][0]\n        o=b[-1][0]-e1+o1\n        e=b[-1][1]-a[i]-o1+e1\n    else:\n        o1=b[i][1]\n        e1=b[i][0]\n        o=b[-1][0]-e1+o1-a[i]\n        e=b[-1][1]-o1+e1\n    if o==e:\n        ans+=1\n    #print(o,e,o1,e1,ans)\nprint(ans)\n", "n = int(input())\nA = [int(i) for i in input().split()]\n\nans = 0\nS = [0, 0]\n\nfor i, a in enumerate(A):\n    S[i%2] += a\n\nS[0] -= A[0]\nif S[0] == S[1]:\n    ans += 1\n\nfor i in range(1, n):\n    S[i%2] -= A[i]\n    S[i%2] += A[i-1]\n    if S[0] == S[1]:\n        ans += 1\n\nprint(ans)", "n=int(input())\nl=list(map(int,input().split()))\nif n==1:\n\tprint(1)\nelse:\n\tleft=[0 for i in range(n)]\n\tright=[0 for i in range(n)]\n\tleft[0]=l[0]\n\tright[-1]=l[-1]\n\tleft[1]=l[1]\n\tright[-2]=l[-2]\n\tfor i in range(2,n):\n\t\tleft[i]=left[i-2]+l[i]\n\tfor i in range(n-3,-1,-1):\n\t\tright[i]=right[i+2]+l[i]\n\n\tans=0\n\tfor i in range(n):\n\t\ta=right[i+1] if i<n-1 else 0\n\t\tb=left[i-2] if i>=2 else 0\n\t\tlhs=a+b\n\t\ta=right[i+2] if i<n-2 else 0\n\t\tb=left[i-1] if i>=1 else 0\n\t\trhs=a+b\n\t\tif lhs==rhs:\n\t\t\tans+=1\n\tprint(ans)", "n = int(input())\na = list(map(int, input().split()))\nsum1 = [0]\nsum2 = [0]\nfor i in range(n):\n    if i % 2 == 0:\n        sum1.append(sum1[-1] + a[i])\n        sum2.append(sum2[-1])\n    else:\n        sum2.append(sum2[-1] + a[i])\n        sum1.append(sum1[-1])\nans = 0\nfor i in range(n):\n    if i % 2 == 0:\n        SUM1 = sum1[i]\n        SUM2 = sum2[i]\n        SUM1, SUM2 = SUM1 + sum2[-1] - SUM2, SUM2 + sum1[-1] - a[i] - SUM1\n        if SUM1 == SUM2:\n            ans += 1\n    else:\n        SUM1 = sum1[i]\n        SUM2 = sum2[i]\n        SUM1, SUM2 = SUM1 + sum2[-1] - a[i] - SUM2, SUM2 + sum1[-1] - SUM1\n        if SUM1 == SUM2:\n            ans += 1       \nprint(ans)", "n = int(input())\nl = [*map(int, input().split())]\n\ne_pre, o_pre = [0], [0]\nfor i, e in enumerate(l):\n    if i & 1:\n        e_pre.append(e_pre[-1] + e)\n        o_pre.append(o_pre[-1])\n    else:\n        o_pre.append(o_pre[-1] + e)\n        e_pre.append(e_pre[-1])\n\no_pre.append(o_pre[-1])\ne_pre.append(e_pre[-1])\n\n\nres = 0\n\nfor i, ele in enumerate(l):\n    e = e_pre[i] + (o_pre[-1] - o_pre[i + 1])\n    o = o_pre[i] + (e_pre[-1] - e_pre[i + 1])\n    if e == o:\n        res += 1\nprint(res)", "n=int(input())\na=[int(o) for o in input().split()]\nsa=[0]*n\nea=[0]*(n+3)\noa=[0]*(n+3)\nes=0\nos=0\nfor i in range(n):\n    if i%2==0:\n        es+=a[i]\n        sa[i]=es\n        \n    else:\n        os+=a[i]\n        sa[i]=os\n    oa[i]=os\n    ea[i]=es\ncount=0\nfor i in range(n):\n    if i%2==0:\n        if es-ea[i]+oa[i-1]==os-oa[i-1]+ea[i-1]:\n            count+=1\n    else:\n        if os-oa[i]+ea[i-1]==es-ea[i-1]+oa[i-1]:\n            count+=1\nprint(count)\n", "n = int(input())\na = list(map(int, input().split()))\na = [0] + a\nch = [0, 0]\nnech = [0, a[1]]\n\nfor i in range(2, n+1):\n    if i % 2 == 0:\n        ch.append(ch[i - 2] + a[i])\n        nech.append(nech[-1])\n    else:\n        nech.append(nech[i - 2] + a[i])\n        ch.append(ch[-1])\n\nans = 0\nfor i in range(1, n+1):\n    s1 = nech[i-1]\n    s2 = ch[i-1]\n    s1 += ch[n] - ch[i]\n    s2 += nech[n] - nech[i]\n    if s1 == s2:\n        ans += 1\n\nprint(ans)", "n = int(input())\nl = list(map(int, input().split()))\ns1 = 0\ns2 = 0\nfor i in range(1, n, 2):\n    s1 += l[i]\nfor i in range(2, n, 2):\n    s2 += l[i]\ncount = 0\nif s1 == s2:\n    count += 1\nfor i in range(1, n):\n    if i % 2:\n        s1 -= l[i]\n        s1 += l[i-1]\n    else:\n        s2 -= l[i]\n        s2 += l[i-1]\n    if s1 == s2:\n        count += 1\nprint(count)\n", "n=int(input())\na=list(map(int,input().split()))\no=[a[0]]\ne=[0]\nfor i in range(1,n):\n\to.append(o[i-1] if i%2==1 else o[i-1]+a[i])\n\te.append(e[i-1] if i%2==0 else e[i-1]+a[i])\n#print(o,e)\nc=0\nfor i in range(1,n):\n\tod=o[i]-a[i]+e[-1]-e[i-1]\n\tev=e[i]-a[i]+o[-1]-o[i-1]\n\t#print(od,ev)\n\tif od==ev:\n\t\tc+=1\nse=so=0\nfor i in range(n):\n\tse+=a[i] if i%2==1 else 0\n\tso+=a[i] if i%2==0 else 0\nif se==so-a[0]:\n\tc+=1\nprint(c)\n", "n = int(input())\na = input().split()\na = [int(i) for i in a]\nodd = []\neven = []\ns1 = 0\ns2 = 0\nfor i in range(n):\n    if i % 2 == 0:\n        s1 += a[i]\n        odd.append(s1)\n        even.append(s2)\n    else:\n        s2 += a[i]\n        odd.append(s1)\n        even.append(s2)\nans = 0\nfor i in range(n):\n    if i % 2 == 0:\n        if odd[i] - a[i] + even[n - 1] - even[i] == even[i] + odd[n - 1] - odd[i]:\n            ans += 1\n    else:\n        if even[i] - a[i] + odd[n - 1] - odd[i] == odd[i] + even[n - 1] - even[i]:\n            ans += 1\nprint(ans)", "n=int(input())\nkon=[int(x) for x in input().split()]\nh=n=0\ni=1\nfor item in kon:\n    if i%2==0:\n        h+=item\n    else:\n        n+=item\n    i+=1\nn1=h1=0\ncounter=0\nk=1\nfor item in kon:\n    if k%2==0:\n        i=h-h1-item+n1\n        j=n-n1+h1\n        h1+=item\n    else:\n        i=h-h1+n1\n        j=n-n1+h1-item\n        n1+=item\n    if i==j:\n        counter+=1\n    k+=1\nprint(counter)\n    \n        \n"]