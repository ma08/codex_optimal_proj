["from collections import defaultdict\n\ndef dfs(v, p):\n\tglobal max_d, max_v\n\td = 0\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\td_u = dfs(u, v)\n\t\t\td = max(d, d_u)\n\t\t\tif d_u > max_d:\n\t\t\t\tmax_d = d_u\n\t\t\t\tmax_v = u\n\treturn d + 1\n\ndef dfs2(v, p, d):\n\tglobal max_d\n\tmax_d = max(max_d, d)\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdfs2(u, v, d + 1)\n\ndef main():\n\tglobal graph, max_d, max_v\n\tn, m = map(int, input().split())\n\tgraph = defaultdict(list)\n\tfor _ in range(m):\n\t\tv, u = map(int, input().split())\n\t\tgraph[v].append(u)\n\t\tgraph[u].append(v)\n\n\tmax_d = 0\n\tmax_v = 0\n\tdfs(1, 0)\n\tmax_d = 0\n\tdfs2(max_v, 0, 0)\n\tprint(max_d)\n\n\tfor v in range(1, n + 1):\n\t\tfor u in graph[v]:\n\t\t\tif v < u:\n\t\t\t\tprint(v, u)\n\nmain()\n", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one\n    start = next(iter(graph))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    diameter = tree_diameter(edges)\n\n    # Print diameter\n    print(diameter)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import defaultdict\n\ndef dfs(v, p):\n\tglobal max_d, max_v\n\td = 0\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\td_u = dfs(u, v)\n\t\t\td = max(d, d_u)\n\t\t\tif d_u > max_d:\n\t\t\t\tmax_d = d_u\n\t\t\t\tmax_v = u\n\treturn d + 1\n\ndef dfs2(v, p, d):\n\tglobal max_d\n\tmax_d = max(max_d, d)\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdfs2(u, v, d + 1)\n\ndef main():\n\tglobal graph, max_d, max_v\n\tn, m = map(int, input().split())\n\tgraph = defaultdict(list)\n\tfor _ in range(m):\n\t\tv, u = map(int, input().split())\n\t\tgraph[v].append(u)\n\t\tgraph[u].append(v)\n\n\tmax_d = 0\n\tmax_v = 0\n\tdfs(1, 0)\n\tmax_d = 0\n\tdfs2(max_v, 0, 0)\n\tprint(max_d)\n\n\tfor v in range(1, n + 1):\n\t\tfor u in graph[v]:\n\t\t\tif v < u:\n\t\t\t\tprint(v, u, sep=\" \")\n\nmain()\n", "\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one.\n    start = next(iter(graph))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again.\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    diameter = tree_diameter(edges)\n\n    # Print diameter\n    print(diameter)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n\nif __name__ == \"__main__\":\n    main()\n", "\nfrom collections import defaultdict\n\ndef dfs(v, p):\n\tglobal max_d, max_v\n\td = 0\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\td = dfs(u, v) + 1\n\t\t\tif d > max_d:\n\t\t\t\tmax_d = d\n\t\t\t\tmax_v = u\n\treturn d\n\ndef dfs2(v, p, d):\n\tglobal max_d\n\tmax_d = max(max_d, d)\n\tfor u in graph[v]:\n\t\tif u != p:\n\t\t\tdfs2(u, v, d + 1)\n\ndef main():\n\tglobal graph, max_d, max_v\n\tn, m = map(int, input().split())\n\tgraph = defaultdict(list)\n\tfor _ in range(m):\n\t\tv, u = map(int, input().split())\n\t\tgraph[v].append(u)\n\t\tgraph[u].append(v)\n\n\tmax_d = 0\n\tmax_v = 0\n\tdfs(1, 0)\n\tmax_d = 0\n\tdfs2(max_v, 0, 0)\n\tprint(max_d)\n\n\tfor v in range(1, n + 1):\n\t\tfor u in graph[v]:\n\t\t\tif v < u:\n\t\t\t\tprint(v, u)\n\nmain()\n", "\n\nimport sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one\n    start = next(iter(graph))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again.\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    diameter = tree_diameter(edges)\n\n    # Print diameter\n    print(diameter)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\nfrom collections import defaultdict\n\nfrom heapq import heappop, heappush\n\ndef tree_diameter(edges):\n    \"\"\"\n    Given a list of edges, return the tree diameter\n    \"\"\"\n    # Create graph from edges\n    graph = defaultdict(set)\n    for a, b in edges:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Dijkstra from any node to find the farthest one.\n    start = next(iter(graph))\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # Dijkstra from the farthest node to find the farthest one again.\n    start = max(dist, key=dist.get)\n    queue = [(0, start)]\n    dist = {}\n    while queue:\n        d, node = heappop(queue)\n        if node not in dist:\n            dist[node] = d\n            for n in graph[node]:\n                heappush(queue, (d+1, n))\n\n    # The diameter is the maximum distance we found\n    return max(dist.values())\n\n\ndef main():\n    \"\"\"\n    Main function\n    \"\"\"\n    # Get input\n    n, m = [int(x) for x in sys.stdin.readline().strip().split()]\n    edges = []\n    for _ in range(m):\n        a, b = [int(x) for x in sys.stdin.readline().strip().split()]\n        edges.append((a, b))\n\n    # Get diameter\n    diameter = tree_diameter(edges)\n\n    # Print diameter\n    print(diameter)\n\n    # Add edges if possible\n    if m < n - 1:\n        for i in range(1, n+1):\n            for j in range(i+1, n+1):\n                if (i, j) not in edges:\n                    print(i, j)\n\n\nif __name__ == \"__main__\":\n    main()\n"]