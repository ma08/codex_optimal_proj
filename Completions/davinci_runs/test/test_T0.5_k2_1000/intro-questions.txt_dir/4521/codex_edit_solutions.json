["\n# SOLUTION 1\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n", "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate and speed of first point\nfirst_x, first_v = x_sorted[0]\n# Get coordinate and speed of last point\nlast_x, last_v = x_sorted[-1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t and last point at time t\nfirst_t, last_t = first_x + t * first_v, last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd points\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth points\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th points\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n", "\n\n# SOLUTION 1\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\nx = [x[i] + v[i] for i in range(n)]\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n", "\n# SOLUTION\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n", "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate and speed\nx_sorted = sorted(zip(x, v), key=lambda x: (x[0], x[1]))\n\n# Get coordinates of first point\nfirst_x = x_sorted[0][0]\n# Get coordinates of last point\nlast_x = x_sorted[-1][0]\n\n# Get speeds of first point\nfirst_v = x_sorted[0][1]\n# Get speeds of last point\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinates of first point at time t\nfirst_t = first_x + t * first_v\n# Get coordinates of last point at time t\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points\ns = 0\n\n# If first point overtakes last point, then minimum distance\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum\nprint(int(s))\n", "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate (ascending)\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed (ascending)\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinate of first point (smallest)\nfirst_x = x_sorted[0][0]\n# Get coordinate of last point (largest)\nlast_x = x_sorted[-1][0]\n\n# Get speed of first point (smallest)\nfirst_v = x_sorted[0][1]\n# Get speed of last point (largest)\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point (positive)\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinate of first point at time t (smallest)\nfirst_t = first_x + t * first_v\n# Get coordinate of last point at time t (largest)\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points (positive)\ns = 0\n\n# If first point overtakes last point, then minimum distance (positive)\n# between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point (positive)\n# is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance (positive)\n# between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point (positive)\n# is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd points (positive)\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth points (positive)\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th points (positive)\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group (positive)\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group (positive)\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group (positive)\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group (positive)\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group (positive)\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group (positive)\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum (positive)\nprint(int(s))\n", "\n# SOLUTION \nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nx = [x[i] + v[i] for i in range(n)]\n\nx.sort()\n\nd = 0\nfor i in range(n - 1):\n    d += x[i + 1] - x[i]\n\nprint(d)\n", "\n\nn = int(input())\nx = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Sort by coordinate (x)\nx_sorted = sorted(zip(x, v), key=lambda x: x[0])\n# Sort by speed (v)\nv_sorted = sorted(zip(x, v), key=lambda x: x[1])\n\n# Get coordinates of first point (x)\nfirst_x = x_sorted[0][0]\n# Get coordinates of last point (x)\nlast_x = x_sorted[-1][0]\n\n# Get speeds of first point (v)\nfirst_v = x_sorted[0][1]\n# Get speeds of last point (v)\nlast_v = x_sorted[-1][1]\n\n# Get time when first point will overtake last point\nt = (last_x - first_x) / (first_v - last_v)\n\n# Get coordinates of first point at time t (x)\nfirst_t = first_x + t * first_v\n# Get coordinates of last point at time t (x)\nlast_t = last_x + t * last_v\n\n# Sum of minimum distances over all pairs of points (s)\ns = 0\n\n# If first point overtakes last point, then minimum distance between 1st and 2nd point is 0\nif first_t < last_t:\n\ts += 0\n# Otherwise, minimum distance between 1st and 2nd point is distance between 1st and 2nd point at time t\nelse:\n\ts += (x_sorted[1][0] - x_sorted[0][0]) - (x_sorted[1][1] - x_sorted[0][1]) * t\n\n# If last point overtakes first point, then minimum distance between n-1th and nth point is 0\nif last_t < first_t:\n\ts += 0\n# Otherwise, minimum distance between n-1th and nth point is distance between n-1th and nth point at time t\nelse:\n\ts += (x_sorted[-1][0] - x_sorted[-2][0]) - (x_sorted[-1][1] - x_sorted[-2][1]) * t\n\n# Get number of points between 1st and 2nd point (n1)\nn1 = -1\nfor i in range(1, n):\n\tif x_sorted[i][0] < first_t:\n\t\tn1 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between n-1th and nth point (n2)\nn2 = -1\nfor i in range(1, n):\n\tif x_sorted[-i][0] > last_t:\n\t\tn2 += 1\n\telse:\n\t\tbreak\n\n# Get number of points between 2nd and n-1th point (n3)\nn3 = n - n1 - n2 - 2\n\n# Add distances between points in the first group\nfor i in range(n1):\n\ts += (x_sorted[i+1][0] - x_sorted[i][0]) - (x_sorted[i+1][1] - x_sorted[i][1]) * t\n\n# Add distances between points in the second group\nfor i in range(n2):\n\ts += (x_sorted[-i-1][0] - x_sorted[-i-2][0]) - (x_sorted[-i-1][1] - x_sorted[-i-2][1]) * t\n\n# Add distances between points in the third group\nfor i in range(n3):\n\ts += (x_sorted[n1+i+2][0] - x_sorted[n1+i+1][0]) - (x_sorted[n1+i+2][1] - x_sorted[n1+i+1][1]) * t\n\n# Add distances between points in the first and second group\nfor i in range(n1):\n\tfor j in range(n2):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[-j-1][0]) - abs(x_sorted[i+1][1] - x_sorted[-j-1][1]) * t\n\n# Add distances between points in the first and third group\nfor i in range(n1):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[i+1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[i+1][1] - x_sorted[n1+j+2][1]) * t\n\n# Add distances between points in the second and third group\nfor i in range(n2):\n\tfor j in range(n3):\n\t\ts += abs(x_sorted[-i-1][0] - x_sorted[n1+j+2][0]) - abs(x_sorted[-i-1][1] - x_sorted[n1+j+2][1]) * t\n\n# Print sum (s)\nprint(int(s))\n"]