2022-04-11 20:11:01.145058 num operations 2
2022-04-11 20:11:01.145084 size on input set 1
2022-04-11 20:11:20.321257 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order. \nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"
    },
    {
      "index": 1,
      "text": "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem. We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points. This is because we want to use\n# our secret technique on monsters that we can't kill in one turn. If we use our secret technique on a monster with\n# high health points, we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn. If we can kill a monster in one turn, we\n# don't need to use our secret technique on it. If we can't kill a monster in one turn, we will use our secret technique\n# on it. We start by assuming that we can kill every monster in one turn. If we later find out that we can't kill a\n# monster in one turn, we will change the corresponding value in this list to False. We will also keep track of the\n# number of points we will get from killing monsters. We start by assuming that we will get a point for killing every\n# monster. If we later find out that we won't get a point for killing a monster, we will decrease the value in this list\n# by one. We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters. We will check if we can kill the monster in one turn. If we can't, we will use\n# our secret technique on it. If we can, we will check if our opponent can kill the monster in one turn. If he can, we\n# will not get a point for killing the monster. If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"
    }
  ],
  "created": 1649722261,
  "object": "edit"
}
2022-04-11 20:11:20.321672 fix spelling mistakes 2 ["\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order. \nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem. We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points. This is because we want to use\n# our secret technique on monsters that we can't kill in one turn. If we use our secret technique on a monster with\n# high health points, we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn. If we can kill a monster in one turn, we\n# don't need to use our secret technique on it. If we can't kill a monster in one turn, we will use our secret technique\n# on it. We start by assuming that we can kill every monster in one turn. If we later find out that we can't kill a\n# monster in one turn, we will change the corresponding value in this list to False. We will also keep track of the\n# number of points we will get from killing monsters. We start by assuming that we will get a point for killing every\n# monster. If we later find out that we won't get a point for killing a monster, we will decrease the value in this list\n# by one. We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters. We will check if we can kill the monster in one turn. If we can't, we will use\n# our secret technique on it. If we can, we will check if our opponent can kill the monster in one turn. If he can, we\n# will not get a point for killing the monster. If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"]
2022-04-11 20:11:20.322113 size on output set 2
2022-04-11 20:11:20.322138 size on input set 2
2022-04-11 20:11:31.493404 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\nhp.sort(reverse=True)\n\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"
    },
    {
      "index": 1,
      "text": "\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem. We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points. This is because we want to use\n# our secret technique on monsters that we can't kill in one turn. If we use our secret technique on a monster with\n# high health points, we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn. If we can kill a monster in one turn, we\n# don't need to use our secret technique on it. If we can't kill a monster in one turn, we will use our secret technique\n# on it. We start by assuming that we can kill every monster in one turn. If we later find out that we can't kill a\n# monster in one turn, we will change the corresponding value in this list to False. We will also keep track of the\n# number of points we will get from killing monsters. We start by assuming that we will get a point for killing every\n# monster. If we later find out that we won't get a point for killing a monster, we will decrease the value in this list\n# by one. We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters. We will check if we can kill the monster in one turn. If we can't, we will use\n# our secret technique on it. If we can, we will check if our opponent can kill the monster in one turn. If he can, we\n# will not get a point for killing the monster. If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"
    }
  ],
  "created": 1649722280,
  "object": "edit"
}
2022-04-11 20:11:31.493541 fix syntax errors 2 ['\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\nhp.sort(reverse=True)\n\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n', "\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem. We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points. This is because we want to use\n# our secret technique on monsters that we can't kill in one turn. If we use our secret technique on a monster with\n# high health points, we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn. If we can kill a monster in one turn, we\n# don't need to use our secret technique on it. If we can't kill a monster in one turn, we will use our secret technique\n# on it. We start by assuming that we can kill every monster in one turn. If we later find out that we can't kill a\n# monster in one turn, we will change the corresponding value in this list to False. We will also keep track of the\n# number of points we will get from killing monsters. We start by assuming that we will get a point for killing every\n# monster. If we later find out that we won't get a point for killing a monster, we will decrease the value in this list\n# by one. We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters. We will check if we can kill the monster in one turn. If we can't, we will use\n# our secret technique on it. If we can, we will check if our opponent can kill the monster in one turn. If he can, we\n# will not get a point for killing the monster. If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"]
2022-04-11 20:11:34.462237 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order. \nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"
    },
    {
      "index": 1,
      "text": "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"
    }
  ],
  "created": 1649722291,
  "object": "edit"
}
2022-04-11 20:11:34.462497 fix syntax errors 2 ["\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order. \nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n", "\n\nn, a, b, k = map(int, input().split())\nhp = list(map(int, input().split()))\n\n# We will use a greedy approach to solve this problem.\n# We want to use our secret technique as many times as possible.\n# We also want to use our secret technique on the monsters with the lowest health points.\n# This is because we want to use our secret technique on monsters that we can't kill in one turn.\n# If we use our secret technique on a monster with high health points,\n# we will run out of secret technique uses before we can use it on a monster with low health points.\n# This is why we sort the monsters by their health points in descending order.\nhp.sort(reverse=True)\n\n# We will use a list to keep track of which monsters we can kill in one turn.\n# If we can kill a monster in one turn, we don't need to use our secret technique on it.\n# If we can't kill a monster in one turn, we will use our secret technique on it.\n# We start by assuming that we can kill every monster in one turn.\n# If we later find out that we can't kill a monster in one turn, we will change the corresponding value in this list to False.\n# We will also keep track of the number of points we will get from killing monsters.\n# We start by assuming that we will get a point for killing every monster.\n# If we later find out that we won't get a point for killing a monster, we will decrease the value in this list by one.\n# We will also keep track of the number of secret technique uses we have left.\ncan_kill_in_one_turn = [True for _ in range(n)]\npoints = n\nsecret_technique_uses_left = k\n\n# We will now loop through the monsters.\n# We will check if we can kill the monster in one turn.\n# If we can't, we will use our secret technique on it.\n# If we can, we will check if our opponent can kill the monster in one turn.\n# If he can, we will not get a point for killing the monster.\n# If he can't, we will get a point for killing the monster.\nfor i in range(n):\n    if hp[i] > a:\n        can_kill_in_one_turn[i] = False\n        if secret_technique_uses_left == 0:\n            break\n        secret_technique_uses_left -= 1\n    if hp[i] > b:\n        points -= 1\n\nprint(points)\n"]
2022-04-11 20:11:34.462679 size on output set 4
2022-04-11 20:11:34.462706 num operations 2
2022-04-11 20:11:34.462719 size on input set 1
2022-04-11 20:11:41.781286 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + (h[i] - 1) // b\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    s = input()\n    print(s[:3])\n\nmain()\n"
    }
  ],
  "created": 1649722294,
  "object": "edit"
}
2022-04-11 20:11:41.781602 fix spelling mistakes 2 ['\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + (h[i] - 1) // b\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n', '\n\ndef main():\n    s = input()\n    print(s[:3])\n\nmain()\n']
2022-04-11 20:11:41.781653 size on output set 2
2022-04-11 20:11:41.781686 size on input set 2
2022-04-11 20:11:44.378920 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    s = input()\n    print(s[:3]) \n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    s = input()\n    print(s[:3]) # print first 3 characters\n\nmain()\n"
    }
  ],
  "created": 1649722302,
  "object": "edit"
}
2022-04-11 20:11:44.379314 fix syntax errors 2 ['\n\ndef main():\n    s = input()\n    print(s[:3]) \n\nmain()\n', '\n\ndef main():\n    s = input()\n    print(s[:3]) # print first 3 characters\n\nmain()\n']
2022-04-11 20:11:53.457420 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "def main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + (h[i] - 1) // b\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + 1\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + 1 + (h[i] - 1) // b + 1\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n"
    }
  ],
  "created": 1649722304,
  "object": "edit"
}
2022-04-11 20:11:53.457843 fix syntax errors 2 ["def main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + (h[i] - 1) // b\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\n\nif __name__ == '__main__':\n    main()\n", '\ndef main():\n    n, a, b, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(n)]\n    for i in range(n):\n        for j in range(k + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + 1\n            else:\n                dp[i][j] = dp[i - 1][j] + (h[i] - 1) // a + 1 + (h[i] - 1) // b + 1\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + (h[i] - b) // a)\n    print(dp[n - 1][k])\n\nmain()\n']
2022-04-11 20:11:53.458076 size on output set 4
