["#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    times = []\n    for i in range(N):\n        times.append(list(map(int, sys.stdin.readline().split())))\n    times = sorted(times, key=lambda x: x[0]) # sort by first element\n    for i in range(1, M):\n        for j in range(N):\n            times[j][i] += times[j][i-1] # add previous element\n        times = sorted(times, key=lambda x: x[i]) # sort by current element\n    print(\" \".join(map(str, [times[i][M-1] for i in range(N)])))\n\nmain()\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    times = []\n    for i in range(N):\n        times.append(list(map(int, sys.stdin.readline().split())))\n    times = sorted(times, key=lambda x: x[0])\n    for i in range(1, M):\n        for j in range(N):\n            times[j][i] += times[j][i-1]\n        times = sorted(times, key=lambda x: x[i])\n    print(\" \".join(map(str, [times[i][M-1] for i in range(N)]))\n\nmain()\n", "\nN, M = [int(x) for x in input().split()] # N is the number of people, M is the number of stages\n\ntimes = [] # times is a list of lists, where each list is a person's times for each stage\nfor i in range(N):\n    times.append([int(x) for x in input().split()])\n\n#print(times) # for testing\n\n# sort the times by the first stage, then the second stage, then the third stage\ntimes.sort(key = lambda x: x[0])\ntimes.sort(key = lambda x: x[1])\ntimes.sort(key = lambda x: x[2])\n\n#print(times) # for testing\n\n# now we can just add up the times for each person\ntotal_times = []\nfor i in range(N):\n    total_time = 0\n    for j in range(M):\n        total_time += times[i][j]\n    total_times.append(total_time)\n\n# print the total times\nfor i in range(N):\n    print(total_times[i], end=\" \")\nprint()\n", "n, m = map(int, input().split())\np = []\nfor i in range(n):\n    p.append(list(map(int, input().split())))\nt = [0] * n\nfor j in range(m):\n    for i in range(n):\n        if j == 0:\n            t[i] = p[i][j]\n        else:\n            t[i] += p[i][j]\n        for k in range(n):\n            if k != i and t[k] + p[k][j] > t[i]:\n                t[k] = t[i] - p[k][j]\n\nprint(\" \".join(map(str, t)))\n", "\n\ndef main():\n    N, M = map(int, input().split())\n    P = []\n    for _ in range(N):\n        P.append(list(map(int, input().split())))\n    # print(P)\n    \"\"\"\n    P[i][j] = time for stage j, swather i\n    T[i][j] = time for stage j, swather i\n    \"\"\"\n    T = [[0] * M for _ in range(N)]\n    # print(T)\n    for i in range(N):\n        for j in range(M):\n            if j == 0:\n                T[i][j] = P[i][j]\n            else:\n                T[i][j] = T[i][j-1] + P[i][j]\n    # print(T)\n    T = sorted(T)\n    # print(T)\n    ans = []\n    for i in range(N):\n        ans.append(T[i][-1])\n    print(*ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\nN, M = [int(x) for x in input().split()]\n\ntimes = []\nfor i in range(N):\n    times.append([int(x) for x in input().split()])\n\n# print(times)\n\n# sort the times by the first stage, then by the second stage, then by the third stage\ntimes.sort(key=lambda x: x[0])\ntimes.sort(key=lambda x: x[1])\ntimes.sort(key=lambda x: x[2])\n\n# now we can just add up the times\ntotal_times = []\nfor i in range(N):\n    total_time = 0\n    for j in range(M):\n        total_time += times[i][j]\n    total_times.append(total_time)\n\nfor i in range(N):\n    print(total_times[i], end=\" \")\n", "n, m = map(int, input().split())\np = []\nfor i in range(n):\n    p.append(list(map(int, input().split())))\nt = [0] * n\nfor j in range(m):\n    for i in range(n):\n        if j == 0:\n            t[i] = p[i][j]\n        else:\n            t[i] += p[i][j]\n        for k in range(n):\n            if k != i and t[k] + p[k][j] > t[i]:\n                t[k] = t[i] - p[k][j]\nprint(\" \".join(map(str, t)))\n", "#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    n, m = [int(i) for i in sys.stdin.readline().split()]\n    times = [[int(i) for i in sys.stdin.readline().split()] for i in range(n)]\n    mowers = [[i,j] for i in range(n) for j in range(m)]\n    mowers = sorted(mowers, key=lambda x: times[x[0]][x[1]])\n    completed = [0]*n\n    while len(mowers) > 0:\n        mower = mowers.pop(0)\n        if mower[1] == 0:\n            completed[mower[0]] = times[mower[0]][0]\n        else:\n            completed[mower[0]] = max(completed[mower[0]], completed[mower[0]-1]) + times[mower[0]][mower[1]]\n    print(' '.join(str(i) for i in completed))\n\nif __name__ == '__main__':\n    main()\n", "\n#!/usr/bin/env python3\n\nimport sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    p = []\n    for i in range(N):\n        p.append(list(map(int, sys.stdin.readline().split())))\n\n    # the time a sawyer is completed\n    t = [0] * N\n\n    # the time stage j is completed\n    s = [0] * M\n\n    # the number of sawyers completed at stage j\n    c = [0] * M\n\n    # the number of sawyers completed\n    d = 0\n\n    # the sawyers completed at stage j\n    e = [[] for i in range(M)]\n\n    for i in range(N):\n        for j in range(M):\n            if i == 0:\n                s[j] = p[0][j]\n            else:\n                if j == 0:\n                    s[j] = s[j] + p[i][j]\n                elif c[j-1] == 0:\n                    s[j] = s[j] + p[i][j]\n                else:\n                    s[j] = max(s[j], e[j-1][0]) + p[i][j]\n\n            if j == M-1:\n                t[i] = s[j]\n            c[j] += 1\n            e[j].append(t[i])\n            if j > 0:\n                e[j-1].pop(0)\n            d += 1\n\n    print(' '.join(map(str, t)))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    workers, stages = [int(x) for x in input().split()]\n    times = []\n    for i in range(workers):\n        times.append([int(x) for x in input().split()])\n    times = sorted(times)\n    for i in range(1, len(times)):\n        for j in range(stages):\n            times[i][j] += times[i - 1][j]\n    for i in range(workers):\n        print(times[i][stages - 1], end=' ')\n\n\nmain()\n", "\n\ndef main():\n    swathers, stages = [int(x) for x in input().split()]  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u043e\u043c\u0430\u043d\u0434 \u0438 \u044d\u0442\u0430\u043f\u043e\u0432\n    times = []\n    for i in range(swathers):  # \u0432\u0432\u043e\u0434\u0438\u043c \u0432\u0440\u0435\u043c\u044f \u043d\u0430 \u043a\u0430\u0436\u0434\u043e\u043c \u044d\u0442\u0430\u043f\u0435\n        times.append([int(x) for x in input().split()])\n    times = sorted(times)  # \u0441\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0430 \u043f\u0435\u0440\u0432\u043e\u043c \u044d\u0442\u0430\u043f\u0435\n    for i in range(1, len(times)):  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u0440\u0435\u043c\u044f \u043d\u0430 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u043c \u044d\u0442\u0430\u043f\u0435 \u043a \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0430 \u0442\u0435\u043a\u0443\u0449\u0435\u043c\n        for j in range(stages):\n            times[i][j] += times[i - 1][j]\n    for i in range(swathers):\n        print(times[i][stages - 1], end=' ')\n\n\nmain()\n", "\n\nimport sys\n\ndef main():\n    n, m = [int(i) for i in sys.stdin.readline().split()]\n    times = [[int(i) for i in sys.stdin.readline().split()] for i in range(n)]\n    mowers = [[i,j] for i in range(n) for j in range(m) if i != 0 or j != 0]\n    mowers = sorted(mowers, key=lambda x: times[x[0]][x[1]])\n    completed = [0]*n\n    while len(mowers) > 0:\n        mower = mowers.pop(0)\n        if mower[1] == 0:\n            completed[mower[0]] = times[mower[0]][0]\n        else:\n            completed[mower[0]] = max(completed[mower[0]], completed[mower[0]-1]) + times[mower[0]][mower[1]]\n    print(' '.join([str(i) for i in completed]))\n\nif __name__ == '__main__':\n    main()\n", "\nN, M = [int(x) for x in input().split()]\n\ntimes = []\nfor i in range(N):\n    times.append([int(x) for x in input().split()])\n\n# print(times)\n\n# sort the times by the first stage, then by the second stage, then by the third stage\ntimes.sort(key=lambda x: x[0])\ntimes.sort(key=lambda x: x[1])\ntimes.sort(key=lambda x: x[2])\n\n# now we can just add up the times\ntotal_times = []\nfor i in range(N):\n    total_time = 0\n    for j in range(M):\n        total_time += times[i][j]\n    total_times.append(total_time)\n\nfor i in range(N):\n    print(total_times[i], end=\" \")\nprint()\n", "\n\ndef main():\n    workers, stages = [int(x) for x in input().split()]\n    times = []\n    for i in range(workers):\n        times.append([int(x) for x in input().split()])\n    times = sorted(times, key=lambda x: x[0])\n    for i in range(1, len(times)):\n        for j in range(stages):\n            times[i][j] += times[i - 1][j]\n    for i in range(workers):\n        print(times[i][stages-1], end=' ')\n\nmain()\n", "\n\ndef main():\n    N, M = map(int, input().split())\n    P = []\n    for _ in range(N):\n        P.append(list(map(int, input().split())))\n    # print(P)\n    \"\"\"\n    P[i][j] = time for stage j, swather i\n    T[i][j] = total time for stage j, swather i\n    \"\"\"\n    T = [[0] * M for _ in range(N)]\n    # print(T)\n    for i in range(N):\n        for j in range(M):\n            if j == 0:\n                T[i][j] = P[i][j]\n            else:\n                T[i][j] = T[i][j-1] + P[i][j]\n    # print(T)\n    T = sorted(T)\n    # print(T)\n    ans = []\n    for i in range(N):\n        ans.append(T[i][-1])\n    print(*ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    N, M = map(int, input().split())\n    P = []\n    for _ in range(N):\n        P.append(list(map(int, input().split())))\n    # print(P)\n    \"\"\"\n    P[i][j] = time for stage j, swather i\n    T[i][j] = time for stage j, swather i\n    \"\"\"\n    T = [[0] * M for _ in range(N)]\n    # print(T)\n    for i in range(N):\n        for j in range(M):\n            if j == 0:\n                T[i][j] = P[i][j]\n            else:\n                T[i][j] = T[i][j-1] + P[i][j]\n    # print(T)\n    T = sorted(T, key=lambda x: x[-1])\n    # print(T)\n    ans = []\n    for i in range(N):\n        ans.append(T[i][-1])\n    print(*ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef main():\n    n, m = map(int, input().split()) # n: number of people, m: number of tasks\n    p = [list(map(int, input().split())) for _ in range(m)] # p: time of each task\n    t = [0] * m # t: time of each person\n    for j in range(m): # for each task\n        for i in range(m): # for each person\n            if t[i] < max(t): # if the person is not the last one\n                t[i] = max(t) # wait until the last person finishes the task\n            t[i] += p[j][i] # the person finishes the task\n    print(*t) # print the time of each person\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    c = [int(i) for i in input().split()]\n    ans = 0\n    for i in range(n-1):\n        if a[i] == a[i+1] - 1:\n            ans += c[a[i]-1]\n    print(sum(b) + ans)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    times = []\n    for i in range(N):\n        times.append(list(map(int, sys.stdin.readline().split())))\n    times = sorted(times, key=lambda x: x[0])\n    for i in range(1, M): # i\ub294 \uc2dc\uac04\n        for j in range(N):\n            times[j][i] += times[j][i-1]\n        times = sorted(times, key=lambda x: x[i]) # i\ubc88\uc9f8 \uc2dc\uac04\uc5d0 \ub3c4\ucc29\ud558\ub294 \uc21c\uc11c\ub300\ub85c \uc815\ub82c\n    print(\" \".join(map(str, [times[i][-1] for i in range(N)])))\n\nmain()\n", "\nimport sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    times = []\n    for i in range(N):\n        times.append(list(map(int, sys.stdin.readline().split())))\n    times = sorted(times, key=lambda x: x[0]) # sort by first column\n    for i in range(1, M): # for each column\n        for j in range(N): # for each row\n            times[j][i] += times[j][i-1] # add previous column to current column\n        times = sorted(times, key=lambda x: x[i]) # sort by current column\n    print(\" \".join(map(str, [times[i][-1] for i in range(N)]))) # print last column\n\nmain()\n", "\n\ndef main():\n    n, m = map(int, input().split())\n    p = [list(map(int, input().split())) for _ in range(n)]\n    t = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if t[i] < max(t):\n                t[i] = max(t)\n            t[i] += p[j][i]\n    print(*t)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# This is the solution to the \"File\" problem on Kattis\n# https://open.kattis.com/problems/file\n\nN, M = [int(x) for x in input().split()] # N is the number of people, M is the number of stages\n\ntimes = [] # times is a list of lists, where each list is a person's times for each stage\nfor i in range(N):\n    times.append([int(x) for x in input().split()])\n\n#print(times) # for testing\n\n# sort the times by the first stage, then the second stage, then the third stage\ntimes.sort(key = lambda x: x[0])\ntimes.sort(key = lambda x: x[1])\ntimes.sort(key = lambda x: x[2])\n\n#print(times) # for testing\n\n# now we can just add up the times for each person\ntotal_times = []\nfor i in range(N):\n    total_time = 0\n    for j in range(M):\n        total_time += times[i][j]\n    total_times.append(total_time)\n\n# print the total times\nfor i in range(N):\n    print(total_times[i], end=\" \")\nprint()\n", "\n\ndef main():\n    swathers, stages = [int(x) for x in input().split()]  # \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u043e\u043c\u0430\u043d\u0434 \u0438 \u044d\u0442\u0430\u043f\u043e\u0432\n    times = []\n    for i in range(swathers):  # \u0432\u0432\u043e\u0434\u0438\u043c \u0432\u0440\u0435\u043c\u044f \u043d\u0430 \u043a\u0430\u0436\u0434\u043e\u043c \u044d\u0442\u0430\u043f\u0435\n        times.append([int(x) for x in input().split()])\n    times = sorted(times)  # \u0441\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0430 \u043f\u0435\u0440\u0432\u043e\u043c \u044d\u0442\u0430\u043f\u0435\n    for i in range(1, len(times)):  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u0440\u0435\u043c\u044f \u043d\u0430 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u043c \u044d\u0442\u0430\u043f\u0435 \u043a \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0430 \u0442\u0435\u043a\u0443\u0449\u0435\u043c\n        for j in range(stages):\n            times[i][j] += times[i - 1][j]\n    for i in range(swathers):\n        print(times[i][stages - 1], end=' ')\n\nmain()\n", "\n\ndef main():\n    N, M = map(int, input().split())\n    P = []\n    for _ in range(N):\n        P.append(list(map(int, input().split())))\n    # print(P)\n    \"\"\"\n    P[i][j] = time for stage j, swather i\n    T[i][j] = total time for stage j, swather i\n    \"\"\"\n    T = [[0 for _ in range(M)] for _ in range(N)]\n    # print(T)\n    for i in range(N):\n        for j in range(M):\n            if j == 0:\n                T[i][j] = P[i][j]\n            else:\n                T[i][j] = T[i][j-1] + P[i][j]\n    # print(T)\n    T.sort()\n    # print(T)\n    ans = []\n    for i in range(N):\n        ans.append(T[i][-1])\n    print(*ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"]