2022-04-11 18:52:30.535761 num operations 2
2022-04-11 18:52:30.535789 size on input set 1
2022-04-11 18:52:41.987338 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef inps():\n    return(input())\n\ndef invp():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invp()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1649717550,
  "object": "edit"
}
2022-04-11 18:52:41.987725 fix spelling mistakes 2 ["\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef inps():\n    return(input())\n\ndef invp():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invp()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-11 18:52:41.987947 size on output set 2
2022-04-11 18:52:41.987959 size on input set 2
2022-04-11 18:52:45.881509 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\ndef inlt():\n    return list(map(int,f.readline().split()))\n\ndef invr():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1649717562,
  "object": "edit"
}
2022-04-11 18:52:45.881632 fix syntax errors 2 ["\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return int(f.readline())\n\ndef inlt():\n    return list(map(int,f.readline().split()))\n\ndef invr():\n    return map(int,f.readline().split())\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef invr():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invr()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invr()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-11 18:52:48.195199 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef inps():\n    return(input())\n\ndef invp():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invp()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invp()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef inps():\n    return(input())\n\ndef invp():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invp()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invp()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"
    }
  ],
  "created": 1649717566,
  "object": "edit"
}
2022-04-11 18:52:48.195366 fix syntax errors 2 ["\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef inps():\n    return(input())\n\ndef invp():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invp()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invp()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n", "\n\nimport sys\nimport os\nimport heapq\nimport math\n\n#sys.stdin = open('input.txt','r')\n#sys.stdout = open('output.txt','w')\n\nf = sys.stdin\no = sys.stdout\n\ndef inp():\n    return(int(f.readline()))\n\ndef inlt():\n    return(list(map(int,f.readline().split())))\n\ndef inps():\n    return(input())\n\ndef invp():\n    return(map(int,f.readline().split()))\n\ndef dfs(V,G,vis,parent,child):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            parent[i] = V\n            child[V].append(i)\n            dfs(i,G,vis,parent,child)\n\ndef bfs(V,G,vis,parent,child):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                parent[i] = V\n                child[V].append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef dfs_path(V,G,vis,path):\n    vis[V] = 1\n    for i in G[V]:\n        if vis[i] == 0:\n            path.append(i)\n            dfs_path(i,G,vis,path)\n\ndef bfs_path(V,G,vis,path):\n    vis[V] = 1\n    q = [V]\n    while q:\n        V = q.pop(0)\n        for i in G[V]:\n            if vis[i] == 0:\n                path.append(i)\n                vis[i] = 1\n                q.append(i)\n\ndef solve():\n    n,m = invp()\n    G = [[] for i in range(n+1)]\n    parent = [0]*(n+1)\n    child = [[] for i in range(n+1)]\n    vis = [0]*(n+1)\n    for i in range(m):\n        u,v = invp()\n        G[u].append(v)\n        G[v].append(u)\n    dfs(1,G,vis,parent,child)\n    #bfs(1,G,vis,parent,child)\n    #print(child)\n    vis = [0]*(n+1)\n    path = []\n    dfs_path(1,G,vis,path)\n    #bfs_path(1,G,vis,path)\n    #print(path)\n    for i in range(len(path)-1):\n        if path[i+1] in child[path[i]]:\n            print('YES')\n            print('1'*(len(path)-1))\n            return\n    print('YES')\n    print('0'*(len(path)-1),end='')\n    for i in range(1,n+1):\n        if i not in path:\n            print('1',end='')\n\nsolve()\n"]
2022-04-11 18:52:48.195613 size on output set 3
2022-04-11 18:52:48.195664 num operations 2
2022-04-11 18:52:48.195674 size on input set 1
2022-04-11 18:52:53.183273 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n            return\n\n    # check if graph is acyclic (dfs)\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, i, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree (dfs)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (BFS)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (DFS)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1649717568,
  "object": "edit"
}
2022-04-11 18:52:53.183521 fix spelling mistakes 2 ['\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n            return\n\n    # check if graph is acyclic (dfs)\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, i, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree (dfs)\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n', '\n\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (BFS)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (DFS)\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-11 18:52:53.183762 size on output set 2
2022-04-11 18:52:53.183791 size on input set 2
2022-04-11 18:52:56.274480 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (BFS)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return \n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (DFS)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\" \")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\" \")\n\nif __name__ == \"__main__\":\n    solve()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (BFS)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return \n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (DFS)\n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1649717573,
  "object": "edit"
}
2022-04-11 18:52:56.274637 fix syntax errors 2 ['\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (BFS)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return \n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (DFS)\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end=" ")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end=" ")\n\nif __name__ == "__main__":\n    solve()\n', '\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (BFS)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return \n\n            return\n\n    # if graph is acyclic and connected, then it is a tree (DFS)\n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-11 18:53:00.318892 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return False\n\n    # check if graph is acyclic (bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return False\n\n            return False\n\n    # check if graph is acyclic (dfs)\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, i, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree (dfs)\n    # therefore, it is possible to orient all edges\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n    return True\n\nif __name__ == \"__main__\":\n    if solve():\n        print(\"YES\")\n    else:\n        print(\"NO\")\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # check if graph is acyclic (bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return \n\n            return\n\n    # check if graph is acyclic (dfs) \n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, i, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n\n    # if graph is acyclic and connected, then it is a tree (dfs) \n    # therefore, it is possible to orient all edges\n    print(\"YES\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print(\"0\", end=\"\")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print(\"1\", end=\"\")\n\nif __name__ == \"__main__\":\n    solve()\n"
    }
  ],
  "created": 1649717576,
  "object": "edit"
}
2022-04-11 18:53:00.319102 fix syntax errors 2 ['\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return False\n\n    # check if graph is acyclic (bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return False\n\n            return False\n\n    # check if graph is acyclic (dfs)\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, i, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree (dfs)\n    # therefore, it is possible to orient all edges\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n    return True\n\nif __name__ == "__main__":\n    if solve():\n        print("YES")\n    else:\n        print("NO")\n', '\nimport sys\nfrom collections import defaultdict\nfrom collections import deque\n\ndef dfs(graph, start, visited):\n    visited[start] = True\n    for next in graph[start]:\n        if not visited[next]:\n            dfs(graph, next, visited)\n\ndef bfs(graph, start, visited):\n    queue = deque()\n    visited[start] = True\n    queue.append(start)\n    while queue:\n        v = queue.popleft()\n        for i in graph[v]:\n            if not visited[i]:\n                visited[i] = True\n                queue.append(i)\n\ndef solve():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    visited = [False] * (n + 1)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # check if graph is connected\n    dfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # check if graph is acyclic (bfs)\n    bfs(graph, 1, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return \n\n            return\n\n    # check if graph is acyclic (dfs) \n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, i, visited)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            print("NO")\n            return\n\n    # if graph is acyclic and connected, then it is a tree (dfs) \n    # therefore, it is possible to orient all edges\n    print("YES")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i < j:\n                print("0", end="")\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            if i > j:\n                print("1", end="")\n\nif __name__ == "__main__":\n    solve()\n']
2022-04-11 18:53:00.319299 size on output set 4
