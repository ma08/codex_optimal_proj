["N, M, Q = map(int, input().split())\nA = []\nfor i in range(Q):\n  A.append(list(map(int, input().split())))\ndef f(B, n):\n  ans = 0\n  if len(B) < N:\n    for i in range(n, M+1):\n      ans = max(ans, f(B+[i], i))\n  else:\n    for j in range(Q):\n      if B[A[j][1]-1] - B[A[j][0]-1] == A[j][2]:\n        ans += A[j][3]\n    return ans\n  return ans\nprint(f([], 1))", "import bisect,collections,copy,itertools,math,string\nimport sys\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int,sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\ndef main():\n    n,m,q = LI()\n    require = [LI() for _ in range(q)]\n    itr = itertools.combinations_with_replacement(list(range(1,n+2)),m-1)     \n    ans = 0\n    for i in itr:\n        lst = [0 for _ in range(n+2)]\n        lst[0] = 1\n        cnt = 0\n        for j in i:\n            lst[j] += 1\n        lst = list(itertools.accumulate(lst))\n        for re in require:\n            if lst[re[1]]-lst[re[0]]==re[2]:\n                cnt += re[3]\n        ans = max(cnt,ans)\n    print(ans)\n\nmain()", "from itertools import combinations_with_replacement as comb_rplc\nN,M,Q = list(map(int,input().split()))\narray = [ list(map(int,input().split())) for _ in range(Q) ]\nans = 0\nfor seq in comb_rplc(list(range(1, M + 1)), N):\n  score = 0\n  for a,b,c,d in array:\n    if seq[b-1] - seq [a-1] == c:\n      score += d\n  ans = max(score,ans)\nprint(ans)\n    \n", "import sys\nimport itertools\n\nN,M,Q = map(int, input().split())\nA = []\nB = []\nC = []\nD = []\nfor i in range(Q):\n    a,b,c,d = map(int,input().split())\n    A.append(a)\n    B.append(b)\n    C.append(c)\n    D.append(d)\n\nnum = list(range(1,M+1))\nans = 0\nfor tpl in itertools.combinations_with_replacement(num,N):\n    point = 0\n    for i in range(Q):\n        if tpl[B[i]-1] - tpl[A[i]-1] == C[i]:\n            point += D[i]\n    \n    ans = max(ans,point)\n\nprint(ans)", "import sys\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\nfrom itertools import combinations_with_replacement\nimport numpy as np\ndef main():\n    n, m, q = map(int, input().split())\n    A = np.array(list(combinations_with_replacement(range(1, m + 1), n)))\n    numA = len(A)\n    score = np.zeros(numA, np.int32)\n    ma = map(int, read().split())\n    for a, b, c, d in zip(ma, ma, ma, ma):\n        a -= 1\n        b -= 1\n        eachA_is_equalOrNot = A[:, b] - A[:, a] == c\n        score += d * eachA_is_equalOrNot\n        # print(score)\n    print(score.max())\n\ndef __starting_point():\n    main()\n__starting_point()", "import itertools\nn,m,q=map(int,input().split())\nabcd=[list(map(int,input().split())) for _ in range(q)]\nans=0\nfor A in itertools.combinations_with_replacement(range(1,m+1),n):\n  score=0\n  for a,b,c,d in abcd:\n    if A[b-1]-A[a-1]==c:\n      score+=d\n  ans=max(ans,score)\nprint(ans)", "from itertools import combinations_with_replacement as c\nN, M, Q = map(int,input().split())\nl1 = list(list(map(int,input().split())) for _ in range(Q))\n\nans = 0\n\nfor l2 in c(range(1, M + 1), N):\n  total = 0\n  for i in range(Q):\n    if l2[l1[i][1] - 1] - l2[l1[i][0] - 1] == l1[i][2]:\n      total += l1[i][3]\n  ans = max(ans, total)\n\nprint(ans)", "from itertools import combinations_with_replacement\n\nn, m, q = map(int,input().split())\nconditions = []\nfor i in range(q): \n    conditions.append(list(map(int,input().split())))\n\ncands = []\nfor i in combinations_with_replacement(list(range(1,m+1)),n):\n    cands.append(i)\n\nmaxi = 0\nfor cand in cands:\n    score = 0\n    for condition in conditions:\n        if cand[condition[1]-1] - cand[condition[0]-1]  == condition[2]:\n            score += condition[3]\n    if score > maxi:\n        maxi = score\nprint(maxi)", "n,m,q=map(int,input().split())\nabcd=[list(map(int,input().split())) for _ in range(q)]\nans=0\n\ndef calc(A):\n  score=0\n  for a,b,c,d in abcd:\n    if A[b-1]-A[a-1]==c:\n      score+=d\n  return score\n\ndef dfs(A,i):\n  nonlocal ans\n  if len(A)==n:\n    ans=max(ans,calc(A))\n    return\n  for j in range(i,m+1):\n    A.append(j)\n    dfs(A,j)\n    A.pop()\n\ndfs([],1)\nprint(ans)", "def dfs(s):\n    nonlocal ans\n    if len(s) == n:\n        cnt = 0\n        for i in range(q):\n            if s[abcd[i][1]-1]-s[abcd[i][0]-1] == abcd[i][2]:\n                cnt += abcd[i][3]\n        ans = max(ans, cnt)\n        return\n    last = 1\n    if len(s) > 0:\n        last = s[-1]\n    for i in range(last, m+1):\n        dfs(s+[i])\n    return\n\nn, m, q = map(int, input().split())\nabcd = [list(map(int, input().split())) for i in range(q)]\nans = 0\ndfs([])\nprint(ans)", "import itertools\nN, M, Q = map(int,input().split())\nABCD_list = [[int(_) for _ in input().split()] for i in range(Q)]\ncombs = itertools.combinations_with_replacement(range(1,M+1),N)\npoints = []\nfor comb in combs:\n    A_list = list(comb)\n    point = 0\n    for inner in ABCD_list:\n        if A_list[inner[1]-1]-A_list[inner[0]-1] == inner[2]:\n            point += inner[3]\n        points.append(point)\nprint(max(points))", "import itertools\nn,m,q = map(int, input().split())\na,b,c,d = [0]*q,[0]*q,[0]*q,[0]*q\n\nfor i in range(q):\n    a[i],b[i],c[i],d[i] = map(int, input().split())\n\nans = 0\n\nfor C in itertools.combinations_with_replacement(range(1,m+1),n):\n    x = 0\n    for i in range(q):\n        if C[b[i]-1] - C[a[i]-1] == c[i]:\n            x += d[i]\n\n    ans = max(ans,x)\n\nprint(ans)", "import sys\n## io ##\ndef IS(): return sys.stdin.readline().rstrip()\ndef II(): return int(IS())\ndef MII(): return list(map(int, IS().split()))\n#======================================================#\n\ndef main():\n    n, m, q = MII()\n    query = [MII() for _ in range(q)]\n\n    def calc_point(lst):\n        sumv = 0\n        for a, b, c, d in query:\n            if lst[b-1] - lst[a-1] == c:\n                sumv += d\n        return sumv\n\n    def dfs(lst):\n        len_lst = len(lst)\n        if len_lst == n:\n            return calc_point(lst)\n        point = 0\n        last_elm = lst[-1] if len_lst > 0 else 1\n        for i in range(last_elm, m+1):\n            point = max(point, dfs(lst+[i]))\n        return point\n\n    print(dfs([]))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import combinations_with_replacement as combi\n\nN, M, Q = map(int, input().split())\n\na = [0] * 55\nb = [0] * 55\nc = [0] * 55\nd = [0] * 55\n\nfor i in range(Q):\n    a[i], b[i], c[i], d[i] = map(int, input().split())\n\ncandidate = combi(range(1, M+1), N)\n\nans = 0\n\nfor A in candidate:\n    score = 0\n    for i in range(Q):\n        if A[b[i]-1] - A[a[i]-1] == c[i]:\n            score += d[i]\n\n    ans = max(ans, score)\n\nprint(ans)", "import sys\n## io ##\ndef IS(): return sys.stdin.readline().rstrip()\ndef II(): return int(IS())\ndef MII(): return list(map(int, IS().split()))\n#======================================================#\n\ndef main():\n    n, m, q = MII()\n    query = [MII() for _ in range(q)]\n\n    def calc_point(lst):\n        sumv = 0\n        for a, b, c, d in query:\n            if lst[b-1] - lst[a-1] == c:\n                sumv += d\n        return sumv\n\n    def dfs(lst):\n        if len(lst) == n:\n            return calc_point(lst)\n        point = 0\n        last_elm = lst[-1] if lst else 1\n        for i in range(last_elm, m+1):\n            point = max(point, dfs(lst+[i]))\n        return point\n\n    print(dfs([]))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "# \u53c2\u8003 : https://atcoder.jp/contests/abc165/submissions/16921279\n# \u53c2\u8003 : https://atcoder.jp/contests/abc165/submissions/16832189\nfrom collections import deque\nn,m,q = list(map(int,input().split()))\nl = [list(map(int,input().split())) for i in range(q)]\na,b,c,d = [list(i) for i in zip(*l)]\n# \u6570\u5217 A \u306e\u57fa(\u6700\u521d\u306f1\u3092\u5165\u308c\u3066\u304a\u304f)\nqueue = deque([[1]])\nans = 0\n# \u6570\u5217 A \u306e\u5019\u88dc\u304c\u306a\u304f\u306a\u308b(\u30ad\u30e5\u30fc\u304c\u7a7a\u306b\u306a\u308b)\u307e\u3067\u63a2\u7d22\nwhile queue:\n    # \u6570\u5217 A \u3092\u524d\u304b\u3089\u4e00\u3064\u53d6\u308a\u51fa\u3059\n    x = queue.popleft()\n    # \u6570\u5217 A \u304c\u9577\u3055 N \u304b\n    if len(x) == n:\n        s = 0\n        # \u5b9f\u969b\u306b\u4f55\u70b9\u53d6\u5f97\u3067\u304d\u308b\u304b\n        for i in range(q):\n            if x[b[i]-1] - x[a[i]-1] == c[i]:\n                s += d[i]\n        ans = max(ans,s)\n    else:\n        # \u9055\u3046\u5834\u5408\u3001\u5f8c\u308d\u306b\u6570\u5b57\u3092\u4ed8\u3051\u8db3\u3059\n        # \u4ed8\u3051\u8db3\u3059\u6570\u5b57\u306f\u53d6\u308a\u51fa\u3057\u305f\u6570\u5217 A \u306e\u4e00\u756a\u5f8c\u308d\u306e\u5024\u304b\u3089 M \u307e\u3067\n        # \u6700\u7d42\u7684\u306b\u9577\u3055\u304c 1 , 2 ... N \u3068\u306a\u308a\u3001if \u306e\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3088\u3046\u306b\u306a\u308b\n        for j in range(x[-1],m+1):\n            y = x + [j]\n            queue.append(y)\nprint(ans)\n# \u5236\u7d04\n# 2 <= N <= 10\n# 1 <= M <= 50\n# 1 <= Q <= 50\n# \u306a\u306e\u3067\u3053\u306e\u63a2\u7d22\u306f\u9593\u306b\u5408\u3046\n# \u5165\u529b\u4f8b 1 \u306f A[1,3,4]\n# \u5165\u529b\u4f8b 2 \u306f A[1,1,1,4]\n# \u5165\u529b\u4f8b 3 \u306f A[1,1,1,1,1,1,1,1,1,10]\n# \u304c\u6700\u5927\u5f97\u70b9\u3068\u306a\u308b\n", "from itertools import combinations_with_replacement\n\nN, M, Q = map(int, input().split())\nABCD = [list(map(int, input().split())) for _ in range(Q)]\n\npoint_max = 0\nfor A in combinations_with_replacement(range(1, M+1), N):\n    point = 0\n    for a, b, c, d in ABCD:\n        if A[b-1]-A[a-1] == c:\n            point += d\n    point_max = max(point, point_max)\n\nprint(point_max)", "import itertools\n\nN, M, Q = map(int, input().split())\n\nseisu_list = []\n\nfor i in range(Q):\n    seisu = list(map(int, input().split()))\n    seisu_list.append(seisu)\n\nM_list = [i for i in range(1,M+1)]\nA_list = list(itertools.combinations_with_replacement(M_list,N))\n#print(A_list)\nans = 0\n\nfor i in range(len(A_list)):\n    ans_temp = 0\n    for j in range(Q):\n        if A_list[i][seisu_list[j][1]-1] - A_list[i][seisu_list[j][0]-1] == seisu_list[j][2]:\n            ans_temp += seisu_list[j][3]\n            ans = max(ans, ans_temp)\nprint(ans)", "N, M, Q = map(int, input().split())\nABCD = [[]for i in range(Q)]\nfor i in range(Q):\n    ABCD[i] = list(map(int, input().split()))\nans = 0\nimport itertools\nfor p in itertools.combinations_with_replacement([x for x in range(1, M + 1)], N):\n    point = 0\n    p = list(p)\n    for a, b, c, d in ABCD:\n        if p[b-1] - p[a-1] == c: point += d\n    ans = max(ans, point)\nprint(ans)", "from itertools import combinations_with_replacement\nN, M, Q = map(int,input().split())\nls = []\nfor _ in range(Q):\n    a,b,c,d = map(int,input().split())\n    ls.append((a-1,b-1,c,d))\nans = -1\nfor A in combinations_with_replacement(range(1,M+1),r=N):\n    sm = 0\n    for a,b,c,d in ls:\n        if A[b]-A[a] == c:\n            sm += d\n    ans = max(ans, sm)\nprint(ans)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Sep  3 23:43:13 2020\n\n@author: liang\n\"\"\"\n\nN ,M ,Q = map(int, input().split())\n\nA = list()\nlis = list()\nans = 0\n\ndef make_list(n,m):\n    if n == N:\n        A.append(lis.copy())\n        return \n    for i in range(m,M+1):\n        lis.append(i)\n        make_list(n+1,i)\n        lis.pop()\n\nmake_list(0,1)\n#print(A)\n\ncalc = [list(map(int,input().split())) for _ in range(Q)]\n\nfor a in A:\n    tmp = 0\n    for c in calc:\n        if a[c[1]-1] - a[c[0]-1] == c[2]:\n            tmp += c[3]\n    if tmp > ans:\n        ans = tmp\n       \nprint(ans)", "import copy\n\ndef main():\n\tN, M, Q = [int(n) for n in input().split(\" \")]\n\tq = [[int(a) for a in input().split(\" \")] for i in range(Q)]\n\tall_series = get_series(N, M)\n\tpoints = [0]\n\tfor l in all_series:\n\t\tpoints.append(get_score(l, q))\n\tprint(max(points))\n\ndef get_score(l, q):\n\treturn sum([q[i][3] if l[q[i][1] - 1] - l[q[i][0] - 1] == q[i][2] else 0 for i in range(len(q))])\n\ndef get_series(N, M):\n\t# N: number of elms\n\t# M: upper limit of val of elm\n\tall_series = []\n\tchecked = [[0] * M for i in range(N)]\n\tto_check = [[0, j + 1] for j in range(M)]\n\tseries = [0 for k in range(N)]\n\twhile len(to_check) > 0:\n\t\tchecking = to_check.pop(-1)\n\t\tseries[checking[0]] = checking[1]\n\t\tif checking[0] == N - 1:\n\t\t\tl = copy.deepcopy(series)\n\t\t\tall_series.append(l)\n\t\telse:\n\t\t\tto_check.extend([[checking[0] + 1, k] for k in range(checking[1], M + 1)])\n\treturn all_series\n\nmain()", "n, m, q = map(int, input().split())\nabcd = [list(map(int, input().split())) for _ in range(q)]\n\ndef check(x):\n    #print(x)\n    z = [0] * n\n    temp = 0\n    y = 0\n    for p in x:\n        if p == 0:\n            temp += 1\n        else:\n            z[y] = temp\n            y += 1\n    #print(z)\n    ans = 0\n    for a, b, c, d in abcd:\n        if z[b-1] - z[a-1] == c:\n            ans += d\n    return ans\n\ndef func(x, s, t):\n    if s == m:\n        temp = [] + x\n        while t < n:\n            temp.append(1)\n            t += 1\n        return check(temp)\n    ans = func(x + [0], s+1, t)\n    if t == n:\n        return ans\n    else:\n        return max(ans, func(x + [1], s, t+1))\n\nprint(func([0], 1, 0))", "#!/usr/bin/env python3\n#\u00a0\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306e\u6574\u6570\u306e\u5165\u529b\n\ndef dfs(seq):\n    ans = 0\n    if len(seq) == N:\n        score_ret = 0\n        for a, b, c, d in data:\n            if seq[b-1] - seq[a-1] == c:\n                score_ret += d\n        return score_ret\n    else:\n        for i in range(seq[-1], M+1):\n            seq_next = seq + (i,)\n            score = dfs(seq_next)\n            ans = max(ans, score)\n    \n    return ans\n\n#\u00a0\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306e\u6574\u6570\u306e\u5165\u529b\nN, M, Q = list(map(int, input().split()))\n#\u914d\u5217\u306e\u5165\u529b\ndata = [list(map(int, input().split())) for _ in range(Q)]\n\nans = -1\nscore = dfs((1,))\nans = max(ans, score)\nprint(ans)\n", "def backtrack(nums, N, cur_state, result):\n    if len(cur_state) == N:\n        result.append(cur_state[:])\n    else:\n        for i in range(len(nums)):\n            cur_state.append(nums[i])\n            backtrack(nums[i:], N, cur_state, result)\n            cur_state.pop()\n\ndef solve():\n    N,M,Q = [int(i) for i in input().split()]\n    quads = []\n    for i in range(Q):\n        quads.append([int(i) for i in input().split()])\n    candidates = []\n    backtrack(list(range(1, M+1)), N, [], candidates)\n\n    ans = 0\n    for candidate in candidates:\n        score = 0\n        for a,b,c,d in quads:\n            if candidate[b-1] - candidate[a-1] == c:\n                score += d\n        ans = max(score, ans)\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "#12653415\n#\u308f\u304b\u3089\u3093\u304c\u3001\u3068\u3066\u3082\u304d\u308c\u3044\u3067\u3059\u306d\n\nN, M, Q = list(map(int, input().split()))\n \nconditions = [list(map(int, input().split())) for _ in range(Q)]\n \ndef dfs(A, max_a):\n    if len(A) == N:\n        num = 0\n        for a, b, c, d in conditions:\n            if A[b-1] - A[a-1] == c:\n                num += d\n        return num\n    ans = 0\n    for i in range(max_a, M+1):\n        ans = max(ans, dfs(A + [i], i))\n    return ans\n \nprint(dfs([1], 1))", "import itertools\nn,m,q = map(int,input().split())\nl = []\nfor i in range(q):\n  tl = list(map(int,input().split()))\n  l.append(tl)\n#print(l)\n\nlis = [i+1 for i in range(m)]\nlis = list(itertools.combinations_with_replacement(lis, n))\n#print(lis)\nans = 0\nfor i in lis:\n  tmp = 0\n  for j in range(q):\n    a = l[j][1] - 1\n    b = l[j][0] - 1\n    if l[j][2] == i[a] - i[b]:\n      tmp += l[j][3]\n  ans = max(tmp,ans)\nprint(ans)", "N,M,Q=list(map(int,input().split()))\nfrom itertools import combinations_with_replacement as comb\nl=comb(range(1,M+1),N)\nq=[list(map(int,input().split())) for i in range(Q)]\nans=0\nfor i in l:\n   tmp=0\n   for a,b,c,d in q:\n      if i[b-1]-i[a-1]==c:\n         tmp+=d\n   ans=max(tmp,ans)\nprint(ans)", "#C - Many Requirements\n#\u518d\u5e30\u95a2\u6570(n\u91cd\u306efor\u6587)\nN,M,Q = map(int,input().split())\nabcd = []\nfor _ in range(Q):\n    a,b,c,d = map(int,input().split())\n    abcd.append((a,b,c,d))\nmax_score = 0\ndef dfs(A):\n    nonlocal max_score\n    if len(A) == N:\n        #\u51e6\u7406\n        score = 0\n        for ai,bi,ci,di in abcd:\n            if A[bi-1] -A[ai-1] == ci:\n                score += di\n        return score\n    #\u4e00\u3064\u524d\u306e\u5024\u3092\u4fdd\u6301\n    if len(A) >= 1:\n        prev_last = A[-1]\n    else:\n        prev_last = 1\n    #1\u3064\u524d\u306e\u5024\u3088\u308a\u5927\u304d\u3044\u5024\u306e\u7bc4\u56f2\n    for i in range(prev_last,M+1):\n        A.append(i)\n        max_score = max(max_score,dfs(A))\n        A.pop()\n    return max_score#\u30eb\u30fc\u30d7\u306e\u9014\u4e2d\u306edfs (len(A) != N \u306e\u3068\u304d) \u306b\u5024\u3092\u8fd4\u3059\ndfs([])\nprint(max_score)", "import sys\nimport math\nimport itertools\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n    \n    \ndef main():\n    N, M, Q = MI()\n    L = [LI() for i in range(Q)]\n    A = [i for i in range(1, M+1)]\n    ans = 0\n\n    for i in itertools.combinations_with_replacement(A, N):\n        temp = 0\n        for a,b,c,d in L:\n            if i[b-1] - i[a-1] == c:\n                temp+=d\n        if temp > ans:\n            ans = temp\n    \n    print(ans)\n\n    \ndef __starting_point():\n    main()\n__starting_point()", "import itertools\nN,M,Q=list(map(int,input().split()))\na=[0]*Q;b=[0]*Q;c=[0]*Q;d=[0]*Q\nfor i in range(Q):\n  a[i],b[i],c[i],d[i]=list(map(int,input().split()))\nl=list(range(1,M+1))\n\ni=0;D=[]\nfor v in itertools.combinations_with_replacement(l, N):\n  D.append(0)\n  for j in range(Q):\n    if v[b[j]-1]-v[a[j]-1]==c[j]:\n      D[i]+=d[j]\n  i+=1\nprint((max(D)))\n", "from itertools import combinations_with_replacement\nn,m,q = list(map(int, input().split()))\nabcd = [list(map(int, input().split())) for _ in range(q)]\n\nans = 0\nfor ary in combinations_with_replacement(range(1, m+1), n):\n    p = 0\n    for a,b,c,d in abcd:\n        if ary[b-1] - ary[a-1] == c:\n            p += d\n    ans = max(ans, p)\n\nprint(ans)", "import itertools\nn,m,q = map(int,input().split())\nabcd = [list(map(int,input().split())) for _ in range(q)]\nmaxpt = 0\nfor lis in itertools.combinations_with_replacement(range(1, m+1), n):\n    forpt = 0\n    for i in range(q):\n        if lis[abcd[i][1]-1] - lis[abcd[i][0]-1] == abcd[i][2]:\n            forpt += abcd[i][3]\n    maxpt = max(maxpt,forpt)\nprint(maxpt)", "import itertools\nfrom operator import mul\nfrom functools import reduce\n\ndef combinations_count(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, list(range(n, n - r, -1)), 1)\n    denom = reduce(mul, list(range(1, r + 1)), 1)\n    return numer // denom\n  \nN,M,Q=list(map(int,input().split()))\na=[0]*Q;b=[0]*Q;c=[0]*Q;d=[0]*Q\nfor i in range(Q):\n  a[i],b[i],c[i],d[i]=list(map(int,input().split()))\nl=list(range(1,M+1))\n\n\nh=combinations_count(M+N-1, N)\nH=[0]*h;i=0\nfor v in itertools.combinations_with_replacement(l, N):\n    H[i]=v\n    i+=1\n\nD=[0 for j in range(h)]\n\nfor i in range(h):\n  for j in range(Q):\n    if H[i][b[j]-1]-H[i][a[j]-1]==c[j]:\n      D[i]+=d[j]\n  \nprint((max(D)))\n", "import sys\nsys.setrecursionlimit(10 ** 6)\nN, M, Q = map(int, input().split())\nQ = [list(map(int,input().split())) for _ in range(Q)]\nans = 0\nA = []\n\n\ndef dfs():\n    nonlocal A\n    if len(A) == N:\n        return\n    nonlocal ans\n    if len(A) == 0:\n        start = 1\n    else:\n        start = A[-1]\n    for i in range(start, M + 1):\n        A.append(i)\n        dfs()\n        if len(A) != N:\n            A.pop()\n            continue\n        # print(A)\n        tmp_ans = 0\n        for a, b, c, d in Q:\n            if A[b - 1] - A[a - 1] == c:\n                tmp_ans += d\n        ans = max(ans, tmp_ans)\n        A.pop()\n\n\ndfs()\nprint(ans)", "from itertools import combinations_with_replacement as cwr\nN,M,Q=map(int,input().split())\nABCD=[]\nfor _ in range(Q):\n    ABCD.append(list(map(int,input().split())))\nmaxscore=0\nfor comb in cwr(range(1,M+1),N):\n    score=0\n    for row in ABCD:\n        if comb[row[1]-1]-comb[row[0]-1]==row[2]:\n            score+=row[3]\n    maxscore=max(maxscore,score)\nprint(maxscore)", "import itertools\n\nN, M, Q = list(map(int, input().split()))\nABCD = [[int(x) for x in input().split()] for i in range(Q)]\n\nans=0\nfor A in itertools.combinations_with_replacement([m for m in range(1,M+1)], N):\n  ans2=0\n  for (a,b,c,d) in ABCD:\n    if A[b-1]-A[a-1]==c:\n      ans2+=d\n  ans=max(ans, ans2)\nprint(ans)\n", "import itertools\n\nN, M, Q = list(map(int, input().split()))\nABCD = [[int(x) for x in input().split()] for i in range(Q)]\n\nans=0\nt=[m for m in range(1,M+1)]\nfor A in itertools.combinations_with_replacement(t, N):\n  ans2=0\n  for (a,b,c,d) in ABCD:\n    if A[b-1]-A[a-1]==c:\n      ans2+=d\n  ans=max(ans, ans2)\nprint(ans)\n", "n, m, q = map(int, input().split())\n\ncandidate = []\n\n\ndef gen(cur):\n    if len(cur) == n:\n        candidate.append(cur)\n    else:\n        t = cur[-1]\n        for tv in range(t, m + 1):\n            nex = cur[:]\n            nex.append(tv)\n            gen(nex)\n\n\nfor i in range(1, 10):\n    arr = [i]\n    gen(arr)\n\nask = []\nfor _ in range(q):\n    ask.append(list(map(int, input().split())))\n\nans = 0\nfor cv in candidate:\n    tmp = 0\n    for av in ask:\n        if cv[av[1] - 1] - cv[av[0] - 1] == av[2]:\n            tmp += av[3]\n    ans = max(ans, tmp)\nprint(ans)", "import itertools\nN, M, Q = map(int, input().split())\na = [0] * Q\nb = [0] * Q\nc = [0] * Q\nd = [0] * Q\nfor i in range(Q):\n    a[i], b[i], c[i], d[i] = map(int, input().split())\n\ncc = [i for i in range(1, M+1)]\nans = 0\n\nfor A in itertools.combinations_with_replacement(cc, N):\n    A = list(A)\n    t = 0\n    for i in range(Q):\n        if A[b[i]-1] - A[a[i]-1] == c[i]:\n            t += d[i]\n    ans = max(ans, t)\n\nprint(ans)", "import itertools\n\ndef main():\n    N, M, Q = list(map(int, input().split()))\n    a = []\n    b = []\n    c = []\n    d = []\n\n    for i in range(Q):\n        ai, bi, ci, di = list(map(int, input().split()))\n        a.append(ai)\n        b.append(bi)\n        c.append(ci)\n        d.append(di)\n\n    ans = 0\n    for A in list(itertools.combinations_with_replacement(list(range(1, M+1)), N)):\n#    print(A)                                                                                          \n        score = 0\n        for i in range(Q):\n            if A[b[i]-1] - A[a[i]-1] == c[i]:\n                score += d[i]\n        if ans < score:\n            ans = score\n\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m,q=map(int, input().split())\nabcd=[]\nfor i in range(q):\n  a,b,c,d=map(int, input().split())\n  abcd.append([a,b,c,d])\ndef dfs(i,j):\n  if i==0:\n    alist=[]\n    for k in range(j):\n      alist.append([k+1])\n    return alist\n  elif i>0 and i<=n:\n    blist=[]\n    for k in dfs(i-1,j):\n      last=k[-1]\n      for l in range(last,j+1):\n        clist=k.copy()\n        clist.append(l)\n        blist.append(clist)\n    return blist\nans=0\nfor alist in dfs(n-1,m):\n  cnt=0\n  for i in range(q):\n    if alist[abcd[i][1]-1]-alist[abcd[i][0]-1]==abcd[i][2]:\n      cnt+=abcd[i][3]\n  ans=max(ans,cnt)\nprint(ans)", "from itertools import combinations_with_replacement\n\nN, M, Q = map(int, input().split())\nT = []\nfor q in range(Q):\n    T.append(list(map(int, input().split())))\n\nA = list(combinations_with_replacement(list(range(1, M+1)), N))\nAlist = [list(a) for a in A]\n\n#print(Alist)\n\nMax = 0\n\nfor a in Alist:\n    cost = 0\n    for t in T:\n        if a[t[1]-1] - a[t[0]-1] == t[2]:\n            cost += t[3]\n    if cost > Max:\n        Max = cost\nprint(Max)", "import sys\n## io ##\ndef IS(): return sys.stdin.readline().rstrip()\ndef II(): return int(IS())\ndef MII(): return list(map(int, IS().split()))\n#======================================================#\n\ndef main():\n    n, m, q = MII()\n    query = [MII() for _ in range(q)]\n\n    def calc_point(lst):\n        sumv = 0\n        for a, b, c, d in query:\n            if lst[b-1] - lst[a-1] == c:\n                sumv += d\n        return sumv\n\n    def dfs(lst):\n        if len(lst) == n:\n            return calc_point(lst)\n        point = 0\n        last_elm = lst[-1] if len(lst) > 0 else 1\n        for i in range(last_elm, m+1):\n            point = max(point, dfs(lst+[i]))\n        return point\n\n    print(dfs([]))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import deque\ndef calc(seq):\n  score = 0\n  for a,b,c,d in array:\n    if seq[b-1] - seq[a-1] == c:\n      score += d\n  return score\n  \nN,M,Q = map(int,input().split())\narray = [ list(map(int,input().split())) for _ in range (Q) ]\nans = 0\nque = deque()\nfor i in range(1,M+1):\n  que.append([i])\n  \nwhile que:\n  seq = que.popleft()\n  if len(seq) == N:\n    score = calc(seq)\n    ans = max(ans,score)\n  else:\n    for i in range(seq[-1],M+1):\n      seq_next = seq + [i]\n      que.append(seq_next)\nprint(ans)", "import itertools\nn, m, q = map(int, input().split())\nabcd = [list(map(int, input().split())) for _ in range(q)]\n\nv = list(itertools.combinations_with_replacement(range(1, m+1), n))\nans = 0\nfor i in v:\n    s = 0\n    for a, b, c, d in abcd:\n        if i[b-1] - i[a-1] == c:\n            s += d\n    ans = max(ans, s)\nprint(ans)", "n,m,q=list(map(int,input().split()))\ndef dfs(seq):\n    u=0\n    if len(seq)==n:\n        ans=0\n        for a,b,c,d in data:\n            if seq[b-1]-seq[a-1]==c:\n                ans+=d\n        return ans\n    else:\n        for i in range(seq[-1],m+1):\n            seq_next=seq.copy()\n            seq_next.append(i)\n            u=max(u,dfs(seq_next))\n        return u\n\ndata=[]\nfor _ in range(q):\n    A=list(map(int,input().split()))\n    data.append(A)\nprint((dfs([1])))\n", "from itertools import combinations_with_replacement\nN, M, Q = map(int, input().split())\nABCD = [list(map(int, input().split())) for _ in range(Q)]\nans = 0\nfor t in combinations_with_replacement(range(1, M+1), N):\n    an = 0\n    for a, b, c, d in ABCD:\n        if t[b-1]-t[a-1] == c:\n            an += d\n    if ans < an:\n        ans = an\nprint(ans)", "import itertools\nimport sys\n\ndef score(abcd, A):\n  ans = 0\n  for a,b,c,d in abcd:\n    if(A[b-1]-A[a-1])==c:\n      ans += d\n  return ans\n\nN, M, Q = [int(x) for x in input().split()]\nabcd = [ [int(x) for x in input().split()] for i in range(Q)]\n\na = itertools.combinations_with_replacement(range(1,M+1), N)\na = list(a)\nAns = 0\nfor i in range(len(a)):\n  Ans = max(Ans,score(abcd,list(a[i])))\n            \nprint(Ans)", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\n\ndef solve():\n    N, M, Q = MAP()\n    A = [LIST() for _ in range(Q)]\n\n    ans = 0\n    for x in combinations_with_replacement(range(1, M+1), N):\n        score = 0\n        for a, b, c, d in A:\n            if x[b-1] - x[a-1] == c:\n                score += d\n        ans = max(ans, score)\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "from itertools import combinations_with_replacement\nn,m,q = map(int, input().split())\nabcd = [list(map(int, input().split())) for _ in range(q)]\n\nnums = combinations_with_replacement(range(1,m+1), n)\nans = 0\nfor a in nums:\n  t = 0\n  for i in abcd:\n    if a[i[1]-1] - a[i[0]-1] == i[2]: t += i[3]\n  if ans < t: ans = t\nprint(ans)", "import sys\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\nfrom itertools import combinations_with_replacement\ndef main():\n    n, m, q = list(map(int, input().split()))\n    qs = []\n    for _ in range(q):\n        abcd = tuple(map(int, input().split()))\n        qs.append(abcd)\n    A = tuple(combinations_with_replacement(list(range(1, m+1)), n))\n    r = 0\n    for Ae in A:\n        t0 = 0\n        for qe in qs:\n            if Ae[qe[1]-1] - Ae[qe[0]-1] == qe[2]:\n                t0 += qe[3]\n        r = max(r, t0)\n    print(r)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n## io ##\ndef IS(): return sys.stdin.readline().rstrip()\ndef II(): return int(IS())\ndef MII(): return list(map(int, IS().split()))\n#======================================================#\n\ndef main():\n    n, m, q = MII()\n    query = [MII() for _ in range(q)]\n\n    def calc_point(lst):\n        sumv = 0\n        for a, b, c, d in query:\n            if lst[b-1] - lst[a-1] == c:\n                sumv += d\n        return sumv\n\n    def dfs(lst):\n        if len(lst) == n:\n            return calc_point(lst)\n        point = 0\n        last_elm = lst[-1]\n        for i in range(last_elm, m+1):\n            point = max(point, dfs(lst+[i]))\n        return point\n\n    print(dfs([1]))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nN, M, Q = list(map(int, input().split()))\nabcd = [list(map(int, input().split())) for i in range(Q)]\nA = []\ndef rec(itr, lst):\n    if itr == N:\n        res = 0\n        for a, b, c, d in abcd:\n            if A[b-1] - A[a-1] == c:\n                res += d\n        return res\n    else:\n        res = 0\n        for i in range(lst, M):\n            A.append(i)\n            res = max(res, rec(itr + 1, i))\n            A.pop()\n        return res\nprint((rec(0, 0)))\n", "N, M, Q = list(map(int, input().split()))\nA = []\n\nfor i in range(Q):\n  A.append(list(map(int, input().split())))\n\ndef calc(B, n):\n  ans = 0\n  #not enough length\n  if len(B) < N:\n    for i in range(n, M + 1):\n      ans = max(ans, calc(B + [i], i))\n  #enough length\n  else:\n    #print(\"B:\", B)\n    for j in range(Q):\n      if B[A[j][1]-1] - B[A[j][0]-1] == A[j][2]:\n        ans += A[j][3]\n    #print(\"ans:\", ans)\n  return ans\n\n\n\nprint((calc([], 1)))\n", "import numpy as np\nimport itertools\nN, M, Q = list(map(int, input().split()))\nG = []\nfor i in range(Q):\n    a, b, c, d = list(map(int, input().split()))\n    G.append([a, b, c, d])\n\nans = 0\n\nA = np.array(list(itertools.combinations_with_replacement(list(range(1, M + 1)), N)))\n\nn = len(A)\nscore = np.zeros(n, np.int32)\nfor a, b, c, d in G:\n    cond = A[:, b - 1] - A[:, a - 1] == c\n    score += d * cond\n\nprint((score.max()))\n", "import itertools\nn,m,q=map(int,input().split())\nabcd=[list(map(int,input().split())) for _ in range(q)]\nans=0\nfor A in itertools.combinations_with_replacement(range(1,m+1),n):\n  score=0\n  for a,b,c,d in abcd:\n    if A[b-1]-A[a-1]==c:\n      score+=d\n  ans=max(ans,score)\nprint(ans)", "import itertools\n\nN, M, Q = list(map(int, input().split()))\na = []\nb = []\nc = []\nd = []\n\nfor i in range(Q):\n    ai, bi, ci, di = list(map(int, input().split()))\n    a.append(ai)\n    b.append(bi)\n    c.append(ci)\n    d.append(di)\n\nans = 0\nfor A in list(itertools.combinations_with_replacement(list(range(1, M+1)), N)):\n#    print(A)                                                                                          \n    score = 0\n    for i in range(Q):\n        if A[b[i]-1] - A[a[i]-1] == c[i]:\n            score += d[i]\n    if ans < score:\n        ans = score\n\n#    print(A, score)                                                                                   \nprint(ans)\n", "n,m,q=list(map(int,input().split()))\ndef dfs(seq):\n    u=0\n    if len(seq)==n:\n        ans=0\n        for a,b,c,d in data:\n            if seq[b-1]-seq[a-1]==c:\n                ans+=d\n        return ans\n    else:\n        for i in range(seq[-1],m+1):\n            seq_next=seq+[i]\n            u=max(u,dfs(seq_next))\n        return u\n\ndata=[]\nfor _ in range(q):\n    A=list(map(int,input().split()))\n    data.append(A)\nprint((dfs([1])))\n", "import itertools\nn,m,q=map(int,input().split())\nd=[list(map(int,input().split())) for i in range(q)]\nans=0\nfor i in list(itertools.combinations_with_replacement(list(range(1,m+1)), n)):\n  a=list(i)\n  hantei=0\n  for j in range(q):\n    if (a[d[j][1]-1]-a[d[j][0]-1])==d[j][2]:\n      hantei+=d[j][3]\n  ans=max(ans,hantei)\nprint(ans)", "# \u5165\u529b\nN, M, Q = map(int, input().split())\na = [0] * Q\nb = [0] * Q\nc = [0] * Q\nd = [0] * Q\nfor i in range(Q):\n    a[i], b[i], c[i], d[i] = map(int, input().split())\n    a[i] -= 1\n    b[i] -= 1\n\n# \u30b9\u30b3\u30a2\u8a08\u7b97\ndef score(A):\n    tmp = 0\n    for ai, bi, ci, di in zip(a, b, c, d):\n        if A[bi] - A[ai] == ci:\n            tmp += di\n    return tmp\n\n# DFS\ndef dfs(A):\n    if len(A) == N:\n        return score(A) # \u6570\u5217 A \u306e\u30b9\u30b3\u30a2\u3092\u8fd4\u3059\n    res = 0\n    prev_last = A[-1] if len(A) > 0 else 0\n    for v in range(prev_last, M):\n        A.append(v)\n        res = max(res, dfs(A)) # \u518d\u5e30\u547c\u51fa\u3057\u306a\u304c\u3089\u3001\u30b9\u30b3\u30a2\u6700\u5927\u5024\u3082\u66f4\u65b0\n        A.pop()\n    return res\n\n# \u6c42\u3081\u308b\nprint(dfs([]))", "import itertools\n\ndef abc165c_many_requirements():\n    n, m, q = map(int, input().split())\n    all_list = []\n    for _ in range(q):\n        all_list.append(list(map(int, input().split())))\n\n    pattern = itertools.combinations_with_replacement(range(1, m+1), n)\n    best = 0\n    for p in pattern:\n        cost = 0\n        for l in all_list:\n            if p[l[1]-1] - p[l[0]-1] == l[2]:\n                cost += l[3]\n        if cost > best:\n            best = cost\n    print(best)\n\nabc165c_many_requirements()", "n, m, q = map(int, input().split())\n\ncandidate = []\n\n\ndef gen(cur):\n    if len(cur) == n:\n        candidate.append(cur)\n    else:\n        t = cur[-1]\n        for tv in range(t, m + 1):\n            nex = cur[:]\n            nex.append(tv)\n            gen(nex)\n\n\nfor i in range(1, m + 1):\n    arr = [i]\n    gen(arr)\n\nask = []\nfor _ in range(q):\n    ask.append(list(map(int, input().split())))\n\nans = 0\nfor cv in candidate:\n    tmp = 0\n    for av in ask:\n        if cv[av[1] - 1] - cv[av[0] - 1] == av[2]:\n            tmp += av[3]\n    ans = max(ans, tmp)\nprint(ans)", "# -*- coding: utf-8 -*-\nfrom itertools import combinations_with_replacement\ndef main():\n    n, m, q = list(map(int, input().split()))\n    xs = []\n    for i in range(q):\n        xs.append(list(map(int, input().split())))\n    max = 0\n    for suretu in combinations_with_replacement(list(range(1, m + 1)), n):\n        wa = 0\n        for x in xs:\n            a, b, c, d = x\n            if suretu[b - 1] - suretu[a - 1] == c:\n                wa += d\n        if wa > max:\n            max = wa\n    print(max)\n    \n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, M, Q = list(map(int, input().split()))\nG = []\nfor i in range(Q):\n    a, b, c, d = list(map(int, input().split()))\n    G.append([a, b, c, d])\n\nans = 0\n\n\ndef dfs(s):\n    nonlocal ans\n    if len(s) == N:\n        now = 0\n        for a, b, c, d in G:\n            if s[b - 1] - s[a - 1] == c:\n                now += d\n        ans = max(ans, now)\n        return\n\n    for i in range(s[-1], M):\n        dfs(s + [i])\n\n\ns = [0]\ndfs(s.copy())\n\nprint(ans)\n", "def dfs(lst):\n    nonlocal ans\n    if len(lst) > n:\n        return\n    lowest = 1\n    if lst != []:\n        lowest = lst[-1]\n    for i in range(lowest, m+1):\n        lst.append(i)\n        dfs(lst)\n        lst.pop()\n    if len(lst) == n:\n        cnt = 0\n        for i in range(q):\n            a, b, c, d = ab[i]\n            if lst[b-1] - lst[a-1] == c:\n                cnt += d\n        ans = max(cnt, ans)\n\nn,m,q = map(int, input().split())\nab = [tuple(map(int, input().split())) for _ in range(q)]\nans = 0\ndfs([])\n\nprint(ans)", "N,M,Q = map(int, input().split())\na = [0]*Q\nb = [0]*Q\nc = [0]*Q\nd = [0]*Q\nfor i in range(Q):\n    a[i], b[i], c[i], d[i] = map(int, input().split())\n    \ndef dfs(n_list, o, l, L):\n    if o+l==0:\n        num = 1\n        pos = 0\n        \n        L_child = [0]*N\n        for i in range(N+M-1):\n            if n_list[i]==1:\n                num += 1\n            else:\n                L_child[pos] = num\n                pos += 1\n        L.append(L_child)\n    \n    if o>=1:\n        n_list[N+M-o-l-1] = 0\n        dfs(n_list, o-1,l, L)\n    if l>=1:\n        n_list[N+M-o-l-1] = 1\n        dfs(n_list, o, l-1, L)\n    \nA = [0]*(N+M-1)\nL =[]\ndfs(A,N,M-1,L)\n\nans = 0\nfor i in L:\n    score = 0\n    for j in range(Q):\n        if i[b[j]-1]-i[a[j]-1]==c[j]:\n            score += d[j]\n\n    if score > ans:\n        ans = score\n\nprint(ans)", "def dfs(cnt, lowest, lst):\n    nonlocal ans\n    if cnt > n:\n        return\n    for i in range(lowest, m+1):\n        lst.append(i)\n        dfs(cnt+1, i, lst)\n        lst.pop()\n    if cnt == n:\n        num = 0\n        for i in range(q):\n            a, b, c, d = ab[i]\n            if lst[b-1] - lst[a-1] == c:\n                num += d\n        ans = max(num, ans)\n\nn,m,q = map(int, input().split())\nab = [tuple(map(int, input().split())) for _ in range(q)]\nans = 0\ndfs(0, 1, [])\n\nprint(ans)", "from itertools import combinations_with_replacement\nn,m,q = map(int, input().split())\nabcd = [list(map(int, input().split())) for _ in range(q)]\n\nans = 0\nfor a in combinations_with_replacement(range(1,m+1), n):\n  t = 0\n  for i in abcd:\n    if a[i[1]-1] - a[i[0]-1] == i[2]: t += i[3]\n  if ans < t: ans = t\nprint(ans)", "import itertools\n\nN, M, Q = list(map(int, input().split()))\nABCD = [[int(x) for x in input().split()] for i in range(Q)]\n\nans=0\nfor A in itertools.combinations_with_replacement([m for m in range(1,M+1)], N):\n  ans2=0\n  for (a,b,c,d) in ABCD:\n    if A[b-1]-A[a-1]==c:\n      ans2+=d\n  ans=max(ans, ans2)\nprint(ans)\n", "import itertools\nn, m, q = map(int, input().split())\nabcd = [list(map(int, input().split())) for _ in range(q)]\nl = list(itertools.combinations_with_replacement(range(1, m+1), n))\nans = 0\nfor i in l:\n    w = 0\n    for j in abcd:\n        if i[j[1]-1] - i[j[0]-1] == j[2]:\n            w += j[3]\n    ans = max(ans, w)\nprint(ans)", "import itertools\n\nN,M,Q = map(int,input().split())\nX = [ list(map(int,input().split())) for i in range(Q) ]\n\nL = list(itertools.combinations_with_replacement(range(1,M+1), N))\np_list =  []\n\nfor l in L :\n    point = 0\n    for x in X :\n        if l[x[1]-1] - l[x[0]-1] == x[2] :\n            point += x[3]\n            \n    p_list.append(point)\n\n# print(X)\n# print(L)\n# print(p_list)\nprint(max(p_list))", "n,m,q = map(int,input().split())\nA = []\nB = []\nC = []\nD = []\nfor i in range(q):\n  a,b,c,d = map(int,input().split())\n  A.append(a-1)\n  B.append(b-1)\n  C.append(c)\n  D.append(d)\n  \nfrom collections import deque\nque = deque([[1]])\nM = 0\n\nwhile que:\n  \n  lst = que.popleft()\n  if len(lst) == n:\n    s = 0\n    for i in range(q):\n      if lst[B[i]] - lst[A[i]] == C[i]:\n        s += D[i]\n    if M < s:\n      M = s\n      \n  else:    \n    for j in range(lst[-1],m+1):\n      lst2 = lst +[j]\n      que.append(lst2)\n    \nprint(M)  ", "#!/usr/bin/env python3\nimport sys\nfrom itertools import chain\n\n# import numpy as np\n# from itertools import combinations as comb\n# from bisect import bisect_left, bisect_right, insort_left, insort_right\n# from collections import Counter\n\n\ndef solve(\n    N: int, M: int, Q: int, ABCD: \"List[(int,int,int,int)]\",\n):\n    def dfs(A, l, r, n):\n        if n > 0:\n            max_score = 0\n            for Ai in range(l, r + 1):\n                A.append(Ai)\n                score = dfs(A, Ai, r, n - 1)\n                if score > max_score:\n                    max_score = score\n                A.pop()\n            return max_score\n        else:\n            score = 0\n            for a, b, c, d in ABCD:\n                if A[b - 1] - A[a - 1] == c:\n                    score += d\n            return score\n\n    return dfs([], 1, M, N)\n\n\ndef main():\n    tokens = chain(*(line.split() for line in sys.stdin))\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    Q = int(next(tokens))  # type: int\n    ABCD = []\n    for i in range(Q):\n        a = int(next(tokens))\n        b = int(next(tokens))\n        c = int(next(tokens))\n        d = int(next(tokens))\n        ABCD.append((a, b, c, d))\n    answer = solve(N, M, Q, ABCD)\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import combinations_with_replacement as comb_r\nn,m,q=map(int,input().split())\nlst=[list(map(int,input().split())) for _ in range(q)]\n\nmx=0\nfor x in comb_r(range(1,m+1),n):\n    sm=0\n    for y in lst:\n        if x[y[1]-1]-x[y[0]-1]==y[2]:\n            sm+=y[3]\n    if mx<sm : mx=sm\n\nprint(mx)", "\ndef f(A, N, M, Q, conditions):\n    L = len(A) - 1\n\n    if L > N:\n        return\n\n    elif L < N:\n        fans = 0\n        for j in range(A[L], M + 1):\n            fans = max(fans ,f(A + [j], N, M, Q, conditions))\n\n    else: # L = N\n        fans = 0\n        for i in range(Q):\n            a, b, c, d = conditions[i]\n            if A[b] - A[a] == c:\n                fans += d\n        \n    return fans\n\nN, M, Q = [int(x) for x in input().split()]\n\nconditions = []\nfor i in range(Q):\n    c = [int(x) for x in input().split()]\n    conditions.append(c)\n\nans = f([1], N, M, Q, conditions)\n\nprint(ans)", "from itertools import combinations_with_replacement\n\nN,M,Q=map(int,input().split())\nabcd=[tuple(map(int,input().split())) for _ in range(Q)]\n\nans=0\nfor A in combinations_with_replacement(range(1,M+1),N):\n  score = 0\n  for i in range(Q):\n    a,b,c,d=abcd[i]\n    if A[b-1]-A[a-1]==c:\n      score += d\n  ans = max(ans,score)\n  \nprint(ans)", "from itertools import combinations_with_replacement as cwr\n[N, M, Q] = [int(i) for i in input().split()]\nreq = [list(map(int, input().split())) for _ in range(Q)]\n\nans = 0\nfor seq in cwr(range(1, M+1), N):\n    sco = 0\n    for i in range(Q):\n        if seq[req[i][1]-1] - seq[req[i][0]-1] == req[i][2]:\n            sco += req[i][3]\n    s = max(ans, sco)\n    ans = s\nprint(ans)", "def dfs(seq):\n    ans = 0\n    if len(seq) == n:\n        kou = 0\n        for u in data:\n            if seq[u[1]-1] - seq[u[0]-1] == u[2]:\n                kou+=u[3]\n        return kou\n    else:#len(seq)==N-1\u304b\u3089\u306e\u9077\u90fd\u3092\u8003\u3048\u308b\u3068\u826f\u3044\n        for i in range(seq[-1], m+1):\n            seq_next=seq+[i]\n            ans = max(ans, dfs(seq_next))\n        return ans\n\nn, m, q = list(map(int, input().split()))\ndata = [list(map(int, input().split())) for _ in range(q)]\n\nscore = dfs([1])\nprint(score)\n", "import sys\nN, M, Q = map(int, input().split())\nabcd = [tuple(map(int, sys.stdin.readline().split())) for _ in range(Q)]\nans = 0\ndone = set()\ntodo = [(i,) for i in range(1, M + 1)]\nwhile todo:\n    A = todo.pop()\n    done.add(A)\n    if len(A) == N:\n        total = 0\n        for a, b, c, d in abcd:\n            if A[b-1] - A[a-1] == c:\n                total += d\n        ans = max(ans, total)\n        continue\n    for i in range(A[-1], M + 1):\n        nA = A + (i,)\n        if not nA in done:\n            todo.append(nA)\nprint(ans)", "N,M,Q = map(int,input().split())\nabcd = [list(map(int,input().split())) for i in range(Q)]\nfrom itertools import combinations_with_replacement\nm = [i for i in range(1,M+1)]\nA = [i for i in combinations_with_replacement(m,N) if i[0] == 1]\nans = 0\nfor i in A:\n    an = 0\n    for a,b,c,d in abcd:\n        if i[b-1] - i[a-1] == c:\n            an += d\n    ans = max(ans,an)\nprint(ans)", "N, M, Q = map(int, input().split())\na = []\nb = []\nc = []\nd = []\nfor _ in range(Q):\n    ad, bd, cd, dd = map(int, input().split())\n    a.append(ad-1)\n    b.append(bd-1)\n    c.append(cd)\n    d.append(dd)\ndef score(A):\n    tmp = 0\n    for ai, bi, ci, di in zip(a, b, c, d):\n        if A[bi] - A[ai] == ci:\n            tmp += di\n    return tmp\ndef dfs(A):\n    if len(A) == N:\n        return score(A) \n    res = 0\n    prev_last = A[-1] if len(A) > 0 else 0\n    for v in range(prev_last, M):\n        A.append(v)\n        res = max(res, dfs(A)) \n        A.pop()\n    return res\nprint(dfs([]))", "n,m,q=map(int, input().split())\nabcd=[]\nfor i in range(q):\n  a,b,c,d=map(int, input().split())\n  abcd.append([a,b,c,d])\ndef dfs(i):\n  if i==0:\n    alist=[]\n    for k in range(m):\n      alist.append([k+1])\n    return alist\n  elif i>0:\n    blist=[]\n    for k in dfs(i-1):\n      last=k[-1]\n      for l in range(last,m+1):\n        clist=k.copy()\n        clist.append(l)\n        blist.append(clist)\n    return blist\nans=0\nfor alist in dfs(n-1):\n  cnt=0\n  for i in range(q):\n    if alist[abcd[i][1]-1]-alist[abcd[i][0]-1]==abcd[i][2]:\n      cnt+=abcd[i][3]\n  ans=max(ans,cnt)\nprint(ans)", "N,M,Q = map(int,input().split())\nabcd = [list(map(int,input().split())) for i in range(Q)]\nfrom itertools import combinations_with_replacement\nm = [i for i in range(1,M+1)]\nA = [i for i in combinations_with_replacement(m,N) if i[0] == 1]\nans = 0\nfor i in A:\n    an = 0\n    for a,b,c,d in abcd:\n        if i[b-1] - i[a-1] == c:\n            an += d\n    ans = max(ans,an)\nprint(ans)", "from collections import deque\n\nN, M, Q = map(int, input().split())\nlst = [list(map(int, input().split())) for _ in range(Q)]\nque = deque()\nfor i in range(1, M+1):\n  que.append([i])\nans = 0\n\nwhile que:\n  check = que.popleft()\n  tmp = 0\n  if len(check) == N:\n    for A in lst:\n      if check[A[1]-1] - check[A[0]-1] == A[2]:\n        tmp += A[3]\n    ans = max(ans, tmp)\n  else:\n    for j in range(check[-1], M+1):\n      que.append(check + [j])\n\nprint(ans)", "import itertools\nn,m,q=map(int,input().split())\nreq=[list(map(int,input().split())) for _ in range(q)]\na=itertools.combinations_with_replacement(range(1,m+1),n)\nans=0\nfor i in a:\n    point=0\n    for j in req:\n        if i[j[1]-1]-i[j[0]-1]==j[2]:\n            point+=j[3]\n    ans=max(ans,point)\nprint(ans)", "import itertools\n\nn, m, q = list(map(int, input().split()))\na = [list(map(int, input().split())) for _ in range(q)]\n\ndef check(A, Q):\n    if A[Q[1]-1] - A[Q[0]-1] == Q[2]:\n        return Q[3]\n    else:\n        return 0\n\nans = 0\nfor i in itertools.combinations_with_replacement(list(range(1, m+1)), n):\n    tmp = 0\n    for j in a:\n        tmp += check(i, j)\n    if ans < tmp:\n        ans = tmp\n\nprint(ans)\n", "import itertools\n \nn,m,q = map(int,input().split())\nabcd = [list(map(int,input().split())) for _ in range(q)]\n \nans = 0\nfor A in itertools.combinations_with_replacement(range(1,m+1),n):\n    tmp = 0\n    for i in range(q):\n        a,b,c,d = abcd[i]\n        if A[b-1] - A[a-1] == c:\n            tmp += d\n    ans = max(ans,tmp)\n \nprint(ans)", "abcd = []\nmax_ans = 0\n\ndef resolve(l):\n  total = 0\n  for a, b, c, d in abcd:\n    if l[b-1] - l[a-1] == c:\n      total += d\n\n  return total\n\ndef comb(l, start, end, now, suspend):\n  nonlocal max_ans\n  if now == suspend:\n    max_ans = max([max_ans, resolve(l)])\n    return\n\n  for i in range(start, end+1, 1):\n    comb(l + [i], i, end, now+1, suspend)\n\n\nn, m, q = list(map(int, input().split()))\n\nfor i in range(q):\n  abcd.append(list(map(int, input().split())))\n\ncomb([], 1, m, 0, n)\n\nprint(max_ans)\n\n", "import itertools\n\nn,m,q = list(map(int,input().split()))\nabcd = [list(map(int,input().split())) for _ in range(q)]\n\nans = 0\nfor A in itertools.combinations_with_replacement(list(range(1,m+1)),n):\n    tmp = 0\n    for i in range(q):\n        a,b,c,d = abcd[i]\n        if A[b-1] - A[a-1] == c:\n            tmp += d\n    ans = max(ans,tmp)\n\nprint(ans)\n", "import itertools\n\nN, M, Q = map(int, input().split())\na = [0] * Q\nb = [0] * Q\nc = [0] * Q\nd = [0] * Q\nfor i in range(Q):\n    a[i], b[i], c[i], d[i] = map(int, input().split())\n    a[i] -= 1\n    b[i] -= 1\n\nresult = 0\nfor A in itertools.combinations_with_replacement(range(1, M+1), N):\n    score = 0\n    for i in range(Q):\n        if A[b[i]] - A[a[i]] == c[i]:\n            score += d[i]\n    result = max(result, score)\nprint(result)", "from sys import stdin\nimport itertools\n\nN, M, Q = [int(x) for x in stdin.readline().rstrip().split()]\na = [0]*Q \nb = [0]*Q\nc = [0]*Q\nd = [0]*Q\n\nfor i in range(Q):\n  a[i], b[i], c[i], d[i] = [int(x) for x in stdin.readline().rstrip().split()]\n  a[i] -= 1\n  b[i] -= 1\n\nans = 0\n\n#print(list(itertools.combinations( list(range(1, M+1)), N)))\nfor A in itertools.combinations_with_replacement( list(range(1, M+1)), N ):\n  #print(\"A:\" + str(A))  # (1, 2, 3), (1, 2, 4) ...\n\n  cur = 0\n\n  for i in range(Q):\n    if ( A[b[i]] - A[a[i]] == c[i] ):\n      #print(\"a:\" + str(a[i]) + \" / b:\" + str(b[i]) + \" / A[b[i]]:\" + str(A[b[i]]) + \" / A[a[i]]:\" + str(A[a[i]]) + \" / c[i]:\" + str(c[i]) + \" / d[i]:\" + str(d[i]) + \" -> Matched\" )\n      cur += d[i]\n\n  #print(\"tmp ans for A:\" + str(cur))\n\n  if (ans < cur):\n    #print(\"Overwrite ans\")\n    ans = cur\n\nprint(ans)\n", "N, M, Q = map(int, input().split())\nL = [list(map(int, input().split())) for _ in range(Q)]\n\nans = 0\nfor a in range(M):\n    for b in range(a, M):\n        for c in range(b, M):\n            for d in range(c, M):\n                for e in range(d, M):\n                    for f in range(e, M):\n                        for g in range(f, M):\n                            for h in range(g, M):\n                                for i in range(h, M):\n                                    for j in range(i, M):\n                                        tmp = [a, b, c, d, e, f, g, h, i, j]\n                                        tmp_ans = 0\n                                        for q in range(Q):\n                                                if tmp[L[q][1]-1] - tmp[L[q][0]-1] == L[q][2]:\n                                                    tmp_ans += L[q][3]\n\n                                        ans = max(ans, tmp_ans)\n\nprint(ans)", "# coding: utf-8\nimport itertools\ndef main():\n    n, m, q = map(int, input().split())\n    matrix = []\n    for _ in range(q):\n        row = list(map(int, input().split()))\n        matrix.append(row)\n    # print(matrix)\n    A = list(range(1, m+1))\n    ans = 0\n    for tmp_A in itertools.combinations_with_replacement(A, n):\n        tmp_A = sorted(list(tmp_A))\n        tmp_ans = 0\n        for row in matrix:\n            # print(\"row\", row)\n            # print(\"tmp_A\", tmp_A)\n            tmp = tmp_A[row[1] - 1] - tmp_A[row[0]- 1]\n            if row[2] == tmp:\n                tmp_ans += row[3]\n        if tmp_ans >= ans:\n            ans = tmp_ans\n            \n    print(ans)\n    \nmain()", "from itertools import combinations_with_replacement as c\nN, M, Q = map(int, input().split())\nl1 = list(list(map(int, input().split())) for _ in range(Q))\nans = 0\n\nfor l2 in c(range(1, M + 1), N):\n    total = 0\n    for i in range(Q):\n        if l2[l1[i][1] - 1] - l2[l1[i][0] - 1] == l1[i][2]:\n            total += l1[i][3]\n    ans = max(ans, total)\n\nprint(ans)"]