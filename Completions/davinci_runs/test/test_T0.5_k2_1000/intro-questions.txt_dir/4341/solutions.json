["def connected_components(neighbors):\n    seen = set()\n    def component(node):\n        nodes = set([node])\n        while nodes:\n            node = nodes.pop()\n            seen.add(node)\n            nodes |= neighbors[node] - seen\n            yield node\n    for node in neighbors:\n        if node not in seen:\n            yield component(node)\nfrom collections import defaultdict\ngraph = defaultdict(set)\nn,m = map(int,input().split())\nfor _ in range(m):\n    u,v = map(int,input().split())\n    graph[u].add(v)\n    graph[v].add(u)\n\ntotal = 0\nfor component in connected_components(graph):\n    nodes = list(component)\n    size = len(nodes)\n    seen = set()\n    current = nodes[0]\n    while len(seen) < size:\n        choice = list(graph[current])\n        if len(choice) != 2:break\n        seen.add(current)\n        possible = [c for c in choice if c not in seen]\n        if not possible: break\n        current = possible[0]\n    if len(seen) == size:\n        total+=1\nprint (total)", "from collections import deque\n\nn, m = list(map(int, input().split()))\ndeg = [0] * (n + 1)\nG = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    u, v = list(map(int, input().split()))\n    deg[u] += 1\n    deg[v] += 1\n    G[u].append(v)\n    G[v].append(u)\n\nC = [0] * (n + 1)\ndef dfs(v, cc):\n    ok = True\n    q = [v]\n    C[v] = cc\n    sz = 1\n    while q:\n        v = q.pop()\n        if len(G[v]) != 2:\n            ok = False\n        for w in G[v]:\n            if C[w] == 0:\n                C[w] = cc\n                sz += 1\n                q.append(w)\n    return sz, ok\n\n\ncc = 0\ncycles = 0\nfor v in range(1, n + 1):\n    if C[v] == 0:\n        cc += 1\n        sz, ok = dfs(v, cc)\n        if ok and sz > 2:\n            cycles += 1\n\nprint(cycles)\n\n# print(C)\n", "T = input().split(' ')\nn = int(T[0])\nm = int(T[1])\nB = [0] * (n+1)\nS1 = [0] * (n+1)\nS2 = [0] * (n+1)\nfor i in range(m):\n    S = input().split(' ')\n    a = int(S[0])\n    b = int(S[1])\n    if S1[a]==0:\n        S1[a] = b\n    elif S2[a]==0:\n        S2[a] = b\n    else:\n        B[a] = 1\n        B[b] = 1\n    if S1[b]==0:\n        S1[b] = a\n    elif S2[b]==0:\n        S2[b] = a\n    else:\n        B[a] = 1\n        B[b] = 1\nfor i in range(1, n+1):\n    if S1[i] == 0 or S2[i] == 0:\n        B[i] = 1\nsol = 0\nfor ind in range(1, n+1):\n    if B[ind] == 0:\n        v = ind\n        w = S2[ind]\n        c = True\n        while w!=ind:\n            B[v] = 1\n            if B[w] == 0:\n                u = w\n                if S1[w]==v:\n                    w = S2[w]\n                else:\n                    w = S1[w]\n            else:\n                B[ind] = 0\n                c = False\n                break\n            v = u\n        if c:\n            B[v] = 1\n            sol+=1\nprint(sol)\n        \n", "import collections;\nn, m = map(int, input().split());\nrs=[];\nfor i in range(m):\n    u, v = map(int, input().split());\n    rs.append((u-1, v-1));\nd = dict();\nfor v in range(n):\n    d[v]=set();\nfor r in rs:\n    u=r[0];\n    v=r[1];\n    setU=d.get(u, set());\n    setV=d.get(v, set());\n    setU.add(v);\n    setV.add(u);\n    d[u]=setU;\n    d[v]=setV;\nseen=[False]*n;\nresult=0;\nfor v in range(n):\n    if seen[v]:\n        continue;\n    good=True;\n    deq=collections.deque([v]);\n    while len(deq)>0:\n        currV=deq.pop();\n        seen[currV]=True;\n        if len(d[currV])!=2:\n            good=False;\n        for u in d[currV]:\n            if seen[u]:\n                continue;\n            seen[u]=True;\n            deq.append(u);\n    if good:\n        result+=1;\nprint(result);", "n,m = [int(s) for s in input().split()]\ng = [[] for x in range(n)]\nfor i in range(m):\n    a,b = [int(s) for s in input().split()]\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\nseen = [False for x in range(n)]\nq = []\nans = 0\nfor i in range(len(g)):\n    if not seen[i]:\n        q.append(i)\n        seen[i] = True\n    is_cycle = True\n    first = i\n    cycle_len = 0\n    while len(q) > 0:\n        v = q.pop()\n        cycle_len += 1\n        if len(g[v]) != 2:\n            is_cycle = False\n        if len(g[v]) == 2 and (g[v][0] == first or g[v][1] == first) and cycle_len > 2 and is_cycle:\n            ans += 1\n            break\n        for vv in g[v]:\n            if not seen[vv]:\n                q.append(vv)\n                seen[vv] = True\n\nprint(ans)\n\n", "n,m=map(int,input().split())\nfriend=[[] for i in range(n)]\nfor i in range(m):\n    u,v=map(int,input().split())\n    friend[u-1].append(v-1)\n    friend[v-1].append(u-1)\nstep=[len(friend[i]) for i in range(n)]\ns=set()\nans=0\nass=s.add\nfor i in range(n):\n    if i in s:\n        continue\n    #print()\n    Q=i\n    k=1\n    ass(Q)\n    while True:\n        #print(Q,s,i)\n        if step[Q]!=2:\n            ass(Q)\n            break\n        elif friend[Q][0] not in s:\n            Q=friend[Q][0]\n            ass(Q)\n            k += 1\n        elif friend[Q][1] not in s:\n            Q=friend[Q][1]\n            ass(Q)\n            k += 1\n        elif friend[Q][0]==i or friend[Q][1]==i:\n            if k>2:\n                ans+=1\n\n            break\n        else:\n            ass(Q)\n            break\n\nprint(ans)", "v,e = list(map(int, input().strip().split()))\n\nedges = [[] for _ in range(v)]\nfor i in range(e):\n\tx,y = input().strip().split()\n\tx = int(x) - 1\n\ty = int(y) - 1\n\tedges[x].append(y)\n\tedges[y].append(x)\n\n\ndegreeTwo = [i for i in range(v) if len(edges[i]) == 2]\n\ncomponents = [-1] * v\nnumComp = 0\n\nans = 0\n\nfor x in degreeTwo:\n\tif components[x] == -1:\n\t\tflag = True\n\t\tqueue = [x]\n\t\twhile queue:\n\t\t\tcurr = queue.pop(0)\n\t\t\tflag = flag and len(edges[curr]) == 2\n\t\t\tcomponents[curr] = numComp\n\t\t\tfor neigh in edges[curr]:\n\t\t\t\tif components[neigh] == -1:\n\t\t\t\t\tqueue.append(neigh)\n\t\t\t\t\tcomponents[neigh] = numComp\n\t\tnumComp += 1\n\t\tans += int(flag)\n\nprint(ans)\n\n# components = [-1] * v\n\n# numComp = 0\n\n# for i in range(v):\n# \tif components[i] == -1:\n# \t\tqueue = [i]\n# \t\twhile queue:\n# \t\t\tcurr = queue.pop(0)\n# \t\t\tcomponents[curr] = numComp\n# \t\t\tfor neigh in edges[curr]:\n# \t\t\t\tif components[neigh] == -1:\n# \t\t\t\t\tqueue.append(neigh)\n# \t\tnumComp += 1\n\n# c = [[] for _ in range(numComp)]\n\n# for i in range(numComp):\n# \tfor j in range(v):\n# \t\tif components[j] == i:\n# \t\t\tc[i].append(j)\n\n# ans = 0\n# for comp in c:\n# \tif len(comp) >= 3:\n# \t\tflag = True\n# \t\tfor vertex in comp:\n# \t\t\tif len(edges[vertex]) != 2:\n# \t\t\t\tflag = False\n# \t\t\t\tbreak\n# \t\tif flag:\n# \t\t\tans += 1\n\n# print(ans)\n\t\n", "import sys\n#sys.stdin = open(\"e.txt\")\ninput = sys.stdin.readline\nN,M = map(int,input().split())\nG = {}\nfor _ in range(M):\n\ta,b = map(int,input().split())\n\tif a not in G:\n\t\tG[a] = set()\n\tif b not in G:\n\t\tG[b] = set()\n\tG[a].add(b)\n\tG[b].add(a)\n\nseen = set()\ndef dfs(graph, start):\n\tvisited = set()\n\tstack = [start]\n\twhile stack:\n\t\tnode = stack.pop()\n\t\tif node not in visited:\n\t\t\tvisited.add(node)\n\t\t\tstack.extend(graph[node])\n\treturn visited\n\ndef dfs_paths(graph, start, goal):\n\tstack = [(start, [start])]\n\twhile stack:\n\t\t(node, path) = stack.pop()\n\t\tfor next in graph[node] - set(path):\n\t\t\tif next == goal:\n\t\t\t\tyield path + [next]\n\t\t\telse:\n\t\t\t\tstack.append((next, path + [next]))\n\nCC = []\nfor x in G:\n\tif x not in seen:\n\t\tP = dfs(G,x)\n\t\tseen |= P\n\t\tCC.append((list(P)[0],P))\ncnt = 0\nfor x in CC:\n\tif x[0] in x[1] and all([len(G[y]) == 2 for y in x[1]]):\n\t\tcnt += 1\nprint(cnt)", "import sys\nsys.setrecursionlimit(10 ** 9)  \nimport threading\nthreading.stack_size(67108864)\ndef main():\n    n, m = [int(x) for x in input().split()]\n\n    graph = []\n\n    for i in range(n):\n        graph.append([])\n\n    deg = [0] * n\n\n    for i in range(m):\n        a, b = [int(x) - 1 for x in input().split()]\n        deg[a] += 1\n        deg[b] += 1\n        graph[a].append(b)\n        graph[b].append(a)\n\n    used = [0] * n\n\n    # print()\n    def dfs(v):\n        is_cir = 1\n        if deg[v] != 2:\n            is_cir = 0\n        for child in graph[v]:\n            if not used[child]:\n                used[child] = 1\n                is_cir = min(dfs(child), is_cir)\n        return is_cir\n\n\n    head = 0\n    count = 0\n    while 1:\n        #print(used, head)\n        used[head] = 1\n        is_cir = dfs(head)\n        count += is_cir\n        f = 0\n        for i in range(head, n):\n            if not used[i]:\n                head = i\n                f = 1\n                break\n                \n        if not f:\n            print(count)\n            return\n\n\n\nthread = threading.Thread(target=main)\nthread.start()\nthread.join()", "n,m = map(int, input().split())\nG = [0]*n\nparent = list(range(n))\n\ndef FindAncester(i):\n    if i == parent[i]:\n        pass\n    else:\n        parent[i] = FindAncester(parent[i])\n    return parent[i]\ndef MergeTwo(i,j):\n    A = FindAncester(i)\n    B = FindAncester(j)\n    parent[B] = parent[A]\n\nfor i in range(m):\n    a,b = map(int, input().split())\n    a,b = a-1,b-1\n    if a>b:\n        a,b = b,a\n    G[a]+=1\n    G[b]+=1\n    MergeTwo(a,b)\n\nR = {}\ncount = 0\nfor i in range(n):\n    a = FindAncester(i)\n    if a in R:\n        R[a].append(i)\n    else:\n        R[a] = [i]\n#print(parent)\n#print(G)\nfor i in R:\n    if len(R[i])>2:\n        x = 1\n        for j in R[i]:\n            if G[j]!=2:\n                x = 0\n                break\n        if x == 1:\n            count+=1\nprint(count)", "#!/usr/bin/env python3\n\n[n, m] = list(map(int, input().strip().split()))\nbis = [tuple(map(int, input().strip().split())) for _ in range(m)]\n\ntos = [[] for _ in range(n)]\nfor u, v in bis:\n\ttos[u - 1].append(v - 1)\n\ttos[v - 1].append(u - 1)\n\ncands = set(i for i in range(n) if len(tos[i]) == 2)\nres = 0\nwhile cands:\n\tv = cands.pop()\n\tR, L = tos[v]\n\twhile L in cands:\n\t\tcands.remove(L)\n\t\tV1, V2 = tos[L]\n\t\tif V1 in cands:\n\t\t\tL = V1\n\t\telif V2 in cands:\n\t\t\tL = V2\n\t\telse:\n\t\t\tbreak\n\t\tif L == R:\n\t\t\tres += 1\n\nprint (res)\n", "def bfs(a,i,visited,connected):\n\tvisited[i] = True\n\tq = list(a[i])\n\tj = 0\n\twhile (j < len(q)):\n\t\tcur = q[j]\n\t\tif (not visited[cur]):\n\t\t\tconnected.append(cur)\n\t\t\tvisited[cur] = True\n\t\t\tfor k in range(len(a[cur])):\n\t\t\t\tq.append(a[cur][k])\n\t\tj += 1\n\n\n\treturn connected\n\n\n\ndef check(connected,a,n):\n\tif (len(connected) < 3):\n\t\treturn False\n\tfor i in range(1,len(connected)):\n\t\tnode = connected[i]\n\t\tif (len(a[node]) != 2):\n\t\t\treturn False\n\treturn True\n\nn, m = map(int, input().split())\n\na = []\nvisited = []\n\nfor i in range(n):\n\ta.append([])\n\tvisited.append(False)\n\nfor i in range(m):\n\tu, v = map(int, input().split())\n\ta[u-1].append(v-1)\n\ta[v-1].append(u-1)\n\nres = 0\n\nfor i in range(n):\n\tif (not visited[i]):\n\t\tconnected = bfs(a,i,visited,[i])\n\t\tif (check(connected,a,n)):\n\t\t\tres += 1\n\nprint(res)", "[n, m] = map(int, input().strip().split())\nbis = [tuple(map(int, input().strip().split())) for _ in range(m)]\n\ntos = [[] for _ in range(n)]\nfor u, v in bis:\n\ttos[u - 1].append(v - 1)\n\ttos[v - 1].append(u - 1)\n\ncands = set(i for i in range(n) if len(tos[i]) == 2)\nres = 0\nwhile cands:\n\tv = cands.pop()\n\tR, L = tos[v]\n\twhile L in cands:\n\t\tcands.remove(L)\n\t\tV1, V2 = tos[L]\n\t\tif V1 in cands:\n\t\t\tL = V1\n\t\telif V2 in cands:\n\t\t\tL = V2\n\t\telse:\n\t\t\tbreak\n\t\tif L == R:\n\t\t\tres += 1\n\nprint (res)", "# coding=utf-8\n\nn, m = list(map(int, input().split()))\na = [[] for _ in range(n+1)]\nfor i in range(m):\n    a1, a2 = list(map(int, input().split()))\n    a[a2].append(a1)\n    a[a1].append(a2)\nans, f, flag = 0, [0]*(n+1), 1\n\ndef dfs(x):\n    f[x] = 1\n    mid = []\n    mid.append(x)\n    while mid:\n        v = mid.pop()\n        if len(a[v]) != 2: nonlocal flag;flag = 0\n        for i in a[v]:\n            if not f[i]: f[i] = 1;mid.append(i)\n\nfor i in range(1, n+1):\n    if not f[i]:\n        flag = 1\n        dfs(i)\n        ans += flag\nprint(ans)\n\n", "from collections import defaultdict\n\nV, E = input().split()\nV, E = int(V), int(E)\nG = defaultdict(set)\nfor _ in range(E):\n    v1, v2 = input().split()\n    v1, v2 = int(v1), int(v2)\n    G[v1].add(v2)\n    G[v2].add(v1)\n\ncycle_cnt = 0\nvisited = set()\nfor v in G:\n    if v in visited:\n        continue\n    stack = [v]\n    path = []\n    while stack:\n        node = stack.pop()\n        if node in visited:\n            continue\n        visited.add(node)\n        path.append(node)\n        stack.extend(G[node])\n    ok = True\n    for node in path:\n        if len(G[node]) != 2:\n            ok = False\n            break\n    cycle_cnt += ok\nprint(cycle_cnt)\n\n\n\n", "def go():\n    n, m = (int(i) for i in input().split(' '))\n    graph = {}\n    for _ in range(m):\n        a, b = (int(i) for i in input().split(' '))\n        graph.setdefault(a, [])\n        graph.setdefault(b, [])\n        graph[a].append(b)\n        graph[b].append(a)\n    output = 0\n    cands = set(i for i in graph if len(graph[i]) == 2)\n    while cands:\n        c = cands.pop()\n        r, l = graph[c]\n        while l in cands:\n            cands.remove(l)\n            c1, c2 = graph[l]\n            if c1 in cands:\n                l = c1\n            elif c2 in cands:\n                l = c2\n            else:\n                break\n            if l == r:\n                output += 1\n    return output\n\nprint(go())\n", "N,M = map(int,input().split())\nG = {}\nfor i in range(M):\n\ta,b = map(int,input().split())\n\tif a not in G:\n\t\tG[a] = set()\n\tif b not in G:\n\t\tG[b] = set()\n\tG[a].add(b)\n\tG[b].add(a)\n\ndef dfs(graph, start):\n\tvisited = set()\n\tstack = [start]\n\twhile stack:\n\t\tnode = stack.pop()\n\t\tif node not in visited:\n\t\t\tvisited.add(node)\n\t\t\tfor i in graph[node]:\n\t\t\t\tstack.append(i)\n\treturn visited\n\narr = []\nseen = set()\nfor x in G:\n\tif x not in seen:\n\t\tP = dfs(G,x)\n\t\tseen |= P\n\t\tarr.append((list(P)[0],P))\ncnt = 0\nfor x in arr:\n\tif x[0] in x[1] and all([len(G[y]) == 2 for y in x[1]]):\n\t\tcnt += 1\nprint(cnt)", "n,m=list(map(int,input().split()))\npar=[-1]*n\n\ndef find(x):\n    if par[x]!=-1:\n        x=find(par[x])\n        \n    return x\n\ndef union(x,y):\n    a=find(x)\n    b=find(y)\n    b,a=sorted([a,b])\n    if a==b:\n        return\n    par[a]=b\n\ndeg=[0]*n\n\nfor i in range(m):\n    u,v=list(map(int,input().split()))\n    deg[u-1]+=1\n    deg[v-1]+=1\n    union(u-1,v-1)\n\nR=dict()\nout=0\nfor i in range(n):\n    if par[i]==-1:\n        R[i]=[]\nfor i in range(n):\n    a=find(i)\n    R[a].append(i)\n    \nfor i in R:\n    if len(R[i])>2:\n        x=1\n        for j in R[i]:\n            if deg[j]!=2:\n                x=0\n                break\n        if x==1:\n            out+=1\nprint(out)\n", "n,m = list(map(int, input().split()))\ng = [[] for i in range(n)]\ndg = [0 for i in range(n)]\nfor i in range(m):\n    u,v = list(map(int, input().split()))\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\n    dg[u-1] +=1\n    dg[v-1]+=1\nvis = [0 for i in range(n)]\nans = 0\nfor i in range(n):\n    if vis[i] != 0:\n        continue\n    q = [i]\n    if dg[i] == 2:\n        ans1 = 1\n    else:\n        ans1 = 0\n    while len(q) > 0:\n        v = q[0]\n        for u in g[v]:\n            if vis[u] == 0:\n                vis[u] = 1\n                q.append(u)\n                if dg[u] != 2:\n                    ans1 = 0\n        del q[0]\n    ans += ans1\nprint(ans)\n", "rd = lambda: list(map(int, input().split()))\nn, m = rd()\nd = {}\ndef f(x):\n    d[x] = d.get(x, 0) + 1\nuf = [i for i in range(n)]\ndef find(i):\n    p = uf[i]\n    if i == p:\n        return p\n    else:\n        uf[i] = find(p)\n        return uf[i]\nfor _ in range(m):\n    u, v = sorted(rd())\n    u -= 1\n    v -= 1\n    f(u)\n    f(v)\n    uf[find(v)] = find(u)\nr = [1] * n\nfor i in range(n):\n    r[find(i)] &= d.get(i, 0) == 2\nprint(sum(i == uf[i] for i in range(n)) + sum(r) - n)\n", "from collections import deque\n\n\ndef bfs(v):\n    q = deque()\n    q.append(v)\n    w = []\n    while len(q):\n        cur = q.popleft()\n        w.append(cur)\n        p[cur] = c\n        for i in g[cur]:\n            if p[i] == 0:\n                q.append(i)\n                p[i] = c\n    k.append(w)\n\nn, m = list(map(int, input().split()))\n\ng = [[] for i in range(n + 1)]\np = [0] * (n + 1)\nk = [[]]\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    g[a].append(b)\n    g[b].append(a)\n\n\nc = 0\nfor v in range(1, n + 1):\n    if p[v] == 0:\n        c += 1\n        bfs(v)\n\n\nans = 0\nfor i in range(1, len(k)):\n    fl = True\n    for j in range(len(k[i])):\n        if len(g[k[i][j]]) != 2:\n            fl = False\n    if fl:\n        ans += 1\n\nprint(ans)\n", "def dfs(v, g, vis):\n    count = 1\n    first = v\n    st = [v]\n    vis[v] = True\n    while st:\n        v = st[-1]\n        st.pop()\n        if len(g[v]) != 2 or vis[g[v][0]] and vis[g[v][1]] and g[v][0] != first and g[v][1] != first:\n            count = 0\n        for i in range(len(g[v])):\n            if not vis[g[v][i]]:\n                vis[g[v][i]] = True\n                st.append(g[v][i])\n                if v == first and count:\n                    break\n    if len(g[first]) == 2 and not vis[g[first][1]]:\n        st.append(g[first][1])\n        while st:\n            v = st[-1]\n            st.pop()\n            for i in range(len(g[v])):\n                if not vis[g[v][i]]:\n                    vis[g[v][i]] = True\n                    st.append(g[v][i])            \n    return count\n\nv, e = list(map(int, input().split()))\ng = [[] for i in range(v)]\nfor i in range(e):\n    f, to = list(map(int, input().split()))\n    g[f-1].append(to-1)\n    g[to-1].append(f-1)\nvis = [False] * v\nans = 0\nfor i in range(v):\n    if not vis[i]:\n        ans += dfs(i, g, vis)\nprint(ans)\n", "import operator\ndata = list( map (int, input().split(' ')) )\nn = data[0]\nm = data[1]\nedge = {}\nfor i in range(n):\n    edge[i+1] = []\nfor _ in range(m):\n    data = list( map (int, input().split(' ')) )\n    i = data[0]\n    j = data[1]\n    edge[i].append(j)\n    edge[j].append(i)\ncandidate = [k for k,v in list(edge.items()) if len(v) == 2]\nresult = 0\nused = {}\ndef _iscircle(c, result):\n    n = edge[c][0]\n    used[c] = 1\n    last = c\n    while n not in used:\n        used[n] = 1\n        if len(edge[n]) != 2:\n            return result\n        t = edge[n][0]\n        if t != last:\n            last = n\n            if t == c:\n                return result + 1\n            n = t\n            continue\n        last = n\n\n        t = edge[n][1]\n        if t == c:\n            return result + 1\n        n = t\n    return result\n\n\nfor i in candidate:\n    result = _iscircle(i, result)\nprint (result)\n"]