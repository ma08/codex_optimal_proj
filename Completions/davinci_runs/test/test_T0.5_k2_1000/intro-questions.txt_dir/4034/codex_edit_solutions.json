["\n\nfrom collections import defaultdict, deque, chain\nfrom sys import stdin\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(set)\n    for i, c in enumerate(s[:-1]):\n        if s[i+1] == c:\n            graph[c].add(i)\n            graph[c].add(i+1)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('yes')\n    print('0' * n)\nelse:\n    print('yes')\n    print(solve(s))\n", "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_maximum_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x): # r, p, x are sets of vertices\n        nonlocal maximum_clique\n        if len(p) == 0 and len(x) == 0:\n            maximum_clique = max(maximum_clique, r, key=lambda clique: len(clique))\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    maximum_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return maximum_clique\n\ndef get_maximum_clique_size(graph):\n    return len(get_maximum_clique(graph))\n\ndef get_maximum_clique_indices(graph):\n    maximum_clique = get_maximum_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in maximum_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_maximum_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n", "import sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n", "import sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('yes')\n    print('0' * n)\nelse:\n    print('yes')\n    print(solve(s))\n", "\n\nfrom collections import defaultdict, deque\nfrom sys import stdin\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(s) else '1')\n    return colors\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(itertools.chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_maximum_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x): # r, p, x are sets of vertices\n        nonlocal maximum_clique\n        if len(p) == 0 and len(x) == 0:\n            maximum_clique = max(maximum_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    maximum_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return maximum_clique\n\ndef get_maximum_clique_size(graph):\n    return len(get_maximum_clique(graph))\n\ndef get_maximum_clique_indices(graph):\n    maximum_clique = get_maximum_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in maximum_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_maximum_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i + 1] for i in range(len(s) - 1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print('YES')\n    print(''.join(colors))\nelse:\n    print('NO')\n"]