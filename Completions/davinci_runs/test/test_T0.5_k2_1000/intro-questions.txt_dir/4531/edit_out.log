2022-04-11 20:50:20.394214 num operations 2
2022-04-11 20:50:20.394249 size on input set 1
2022-04-11 20:50:24.656543 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649724620,
  "object": "edit"
}
2022-04-11 20:50:24.656799 fix spelling mistakes 2 ['import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent):\n        children = self.adj[root]\n        res = 0\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root) + 1\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1) * a[i]\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-11 20:50:24.656853 size on output set 1
2022-04-11 20:50:24.656864 size on input set 1
2022-04-11 20:50:30.072486 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent, a):\n        children = self.adj[root]\n        res = a[root]\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root, a)\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1, a)\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root):\n        pass\n\n\ndef solve(n, a, tree):\n    pass\n\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1649724624,
  "object": "edit"
}
2022-04-11 20:50:30.072730 fix syntax errors 2 ['import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root, parent, a):\n        children = self.adj[root]\n        res = a[root]\n        for child in children:\n            if child != parent:\n                res += self.dfs(child, root, a)\n        return res\n\n\ndef solve(n, a, tree):\n    res = 0\n    for i in range(1, n + 1):\n        res += tree.dfs(i, -1, a)\n    return res\n\n\ndef main():\n    n = int(input())\n    a = [0] + [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\n\nclass Tree:\n    def __init__(self, n):\n        self.n = n\n        self.adj = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.adj[u].append(v)\n        self.adj[v].append(u)\n\n    def dfs(self, root):\n        pass\n\n\ndef solve(n, a, tree):\n    pass\n\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    tree = Tree(n)\n    for _ in range(n - 1):\n        u, v = [int(x) for x in input().split()]\n        tree.add_edge(u, v)\n    print(solve(n, a, tree))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-11 20:50:30.072783 size on output set 2
2022-04-11 20:50:30.072809 num operations 2
2022-04-11 20:50:30.072817 size on input set 1
2022-04-11 20:50:34.459903 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    }
  ],
  "created": 1649724630,
  "object": "edit"
}
2022-04-11 20:50:34.460149 fix spelling mistakes 2 ['\n\n\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n']
2022-04-11 20:50:34.460186 size on output set 2
2022-04-11 20:50:34.460193 size on input set 2
2022-04-11 20:50:38.594093 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size, subtree_sum = dfs(u, p)\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, p)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\nprint(solve(0, -1))\n"
    }
  ],
  "created": 1649724634,
  "object": "edit"
}
2022-04-11 20:50:38.594485 fix syntax errors 2 ['\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\nprint(solve(0, -1))\n', '\nimport sys\nimport math\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\nn = int(input())\na = list(map(int, input().split()))\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size, subtree_sum = dfs(u, p)\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, p)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\nprint(solve(0, -1))\n']
2022-04-11 20:50:40.874195 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n"
    }
  ],
  "created": 1649724638,
  "object": "edit"
}
2022-04-11 20:50:40.874315 fix syntax errors 2 ['import sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n', '\nimport sys\nimport math\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\na = list(map(int, input().split()))\n\nedges = []\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges.append((u - 1, v - 1))\n\nadj = defaultdict(list)\nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n\n\ndef dfs(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    return subtree_size, subtree_sum\n\n\ndef solve(u, p):\n    subtree_size = 1\n    subtree_sum = a[u]\n    for v in adj[u]:\n        if v != p:\n            subtree_size_v, subtree_sum_v = dfs(v, u)\n            subtree_size += subtree_size_v\n            subtree_sum += subtree_sum_v\n    max_cost = subtree_sum\n    for v in adj[u]:\n        if v != p:\n            max_cost = max(max_cost, solve(v, u) + subtree_sum - subtree_sum_v)\n    return max_cost\n\n\nprint(solve(0, -1))\n']
2022-04-11 20:50:40.874336 size on output set 4
