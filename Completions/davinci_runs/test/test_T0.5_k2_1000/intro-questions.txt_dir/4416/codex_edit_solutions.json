["\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest costs\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the minimum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n", "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized. This means, we need to find a set of books with X >= k and sum(t_i) is minimized. Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far. This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far. This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in xrange(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in xrange(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n", "\n\n\"\"\"\nSolution outline\n\t- Let X and Y be the number of books liked by Alice and Bob respectively.\n\t- We need to find a set of books with X >= k, Y >= k and sum(t_i) is minimized.\n\t  This means, we need to find a set of books with X >= k and sum(t_i) is minimized.\n\t  Then, we find a set of books with Y >= k and sum(t_i) is minimized.\n\t- For the first set, we can keep track of the number of books liked by Alice in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- For the second set, we can keep track of the number of books liked by Bob in a sliding window of size k.\n\t  We can keep track of the sum of t_i in the window as well, and keep track of the minimum sum seen so far.\n\t  This can be done in linear time.\n\t- We return the minimum of the two sums.\n\"\"\"\ndef min_books_to_read(t, a, b, k):\n\t# Find minimum sum of t_i, such that sum(a_i) >= k\n\tmin_sum = sum(t[:k])\n\ta_sum = sum(a[:k])\n\tif a_sum < k:\n\t\treturn -1\n\n\tfor i in range(k, len(t)):\n\t\ta_sum += a[i] - a[i-k]\n\t\tif a_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum = min(min_sum, sum(t[i-k+1:i+1]))\n\n\t# Find minimum sum of t_i, such that sum(b_i) >= k\n\tmin_sum2 = sum(t[:k])\n\tb_sum = sum(b[:k])\n\tif b_sum < k:\n\t\treturn -1\n\n\tfor i in range(k, len(t)):\n\t\tb_sum += b[i] - b[i-k]\n\t\tif b_sum < k:\n\t\t\tbreak\n\n\t\tmin_sum2 = min(min_sum2, sum(t[i-k+1:i+1]))\n\n\treturn min(min_sum, min_sum2)\n\nif __name__ == '__main__':\n\tn,k = map(int, raw_input().strip().split())\n\tt = []\n\ta = []\n\tb = []\n\tfor i in range(n):\n\t\tt_i, a_i, b_i = map(int, raw_input().strip().split())\n\t\tt.append(t_i)\n\t\ta.append(a_i)\n\t\tb.append(b_i)\n\n\tprint min_books_to_read(t, a, b, k)\n", "\nimport sys\n\ndef main():\n    reader = (tuple(map(int, line.split())) for line in sys.stdin)\n    n, k = next(reader)\n    books = sorted(reader, key=lambda x: x[0])\n\n    # if there are enough books that Alice likes, then the optimal solution\n    # will be the k books that Alice likes with the smallest cost\n    alice_likes = [t for t, a, b in books if a == 1]\n    if len(alice_likes) >= k:\n        print(sum(alice_likes[:k]))\n        return\n\n    # otherwise, we need to find the maximum number of books\n    # that Bob likes and add them to the books that Alice likes\n    bob_likes = [t for t, a, b in books if b == 1]\n    num_extra_bob = k - len(alice_likes)\n    print(sum(alice_likes) + sum(bob_likes[:num_extra_bob]))\n\nmain()\n"]