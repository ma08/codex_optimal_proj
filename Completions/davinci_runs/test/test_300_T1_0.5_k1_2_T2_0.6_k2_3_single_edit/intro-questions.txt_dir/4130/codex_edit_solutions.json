["from collections import defaultdict\n\n\n# n = int(input())\n# a = list(map(int, input().split()))\n#\n# a.sort()\n#\n# count = 1\n# for i in range(1, n):\n#     if a[i] != a[i-1]:\n#         count += 1\n#\n# print(count)\n\n# n = int(input())\n# a = list(map(int, input().split()))\n#\n# a.sort()\n#\n# count = 1\n# for i in range(1, n):\n#     if a[i] != a[i-1]:\n#         count += 1\n#\n# print(count)\n\n# n = int(input())\n# a = list(map(int, input().split()))\n#\n# a.sort()\n#\n# count = 1\n# for i in range(1, n):\n#     if a[i] != a[i-1]:\n#         count += 1\n#\n# print(count)\n\n# n = int(input())\n# a = list(map(int, input().split()))\n#\n# a.sort()\n#\n# count = 1\n# for i in range(1, n):\n#     if a[i] != a[i-1]:\n#         count += 1\n#\n# print(count)\n\nn = int(input())\na = list(map(int, input().split()))\n\ndict = defaultdict(int)\nfor x in a:\n    dict[x] += 1\n\ncount = len(dict)\n\nprint(count)\n", "\nn = int(input()) \na = list(map(int, input().split())) \n \na.sort() \n \ncount = 1 \nfor i in range(1, n): \n    if a[i] != a[i-1]: \n        count += 1 \n \nprint(count) \n", "\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\ncount = 1\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n", "\n# SOLUTION\n# The idea is to sort the weights and then go over them.\n# If we are at a weight that is the same as the previous one,\n# we can increase it by one and then we are sure that it will be\n# different from the previous weight.\n# If we are at a weight that is bigger than the previous one\n# by more than one, we can decrease it by one, and we are sure\n# that it will be different from the previous weight.\n# Otherwise, we can't change the weight at all.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "\n\n# Let's sort the list and then go over it.\n# Let's assume that we are at the i-th element in the list.\n# If it is the first element, we will just choose it.\n# If it is not the first, we will compare it with the previous element.\n# If the previous element is bigger, we will choose the current element.\n# If the previous element is smaller, we will choose the previous element again.\n# We can do this in linear time, so overall complexity is O(n).\n\nimport sys\nreadline = sys.stdin.readline\n\ndef main():\n    n = int(readline())\n    a = list(map(int, readline().split()))\n    a.sort()\n    ans = 1\n    prev = a[0]\n    for i in range(1, n):\n        if a[i] == prev:\n            prev += 1\n        elif a[i] > prev + 1:\n            prev = a[i] - 1\n        ans += 1\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n"]