["import sys\ninput = sys.stdin.readline # for speed up\n#sys.setrecursionlimit(10**9)\n\nn=int(input())\na=list(map(int,input().split()))\n\nl=[0]*(n+2)\nr=[0]*(n+2)\nl[1]=a[0]\nr[n]=a[n-1]\nimport math \nfor ii in range(1,n):\n  l[ii+1]=math.gcd(l[ii],a[ii])\n  r[n-ii]=math.gcd(r[n-ii+1],a[n-1-ii])\n#print(r)\n#print(l)\nans=0\nfor ii in range(1,n+1):\n  ans=max(ans,math.gcd(l[ii-1],r[ii+1]))\n  #print(l[ii-1],r[ii+1])\nprint(ans)\n", "import math\n\nN = int(input())\nA = list(map(int,input().split()))\ngcd1 = [A[0]]\ngcd2 = [A[N-1]]\nans_list = []\n\nfor i in range(1,N-1):\n  gcd1.append(math.gcd(gcd1[-1],A[i]))\n  gcd2.append(math.gcd(gcd2[-1],A[N-i-1]))\n\nans_list.append(gcd1[-1])\nfor j in range(N-2):\n  ans_list.append(math.gcd(gcd1[j],gcd2[N-j-3]))\nans_list.append(gcd2[-1])\n\nprint(max(ans_list))", "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time, copy,bisect\nfrom operator import itemgetter\n#from heapq import heappush, heappop\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\n#from scipy.sparse import csr_matrix\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nnf = lambda: float(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnb = lambda: list(map(float, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nN = ni()\nA = na()\nb = [0] * N\nc = [0] * N\nb[0] = A[0]\nc[-1] = A[-1]\nfor i in range(N-1):\n    b[i+1] = math.gcd(b[i], A[i+1])\n    c[-(i+2)] = math.gcd(c[-(i+1)], A[-(i+2)])\n\nans = 1\nans = max(c[1], ans)\nans = max(b[-2], ans)\nfor i in range(1, N-1):\n    ans = max(math.gcd(b[i-1], c[i+1]), ans)\nprint(ans)\n", "from math import gcd\nN = int(input())\nA = list(map(int, input().split()))\nB = [0 for i in range(N)]\nC = [0 for i in range(N)]\nB[0] = A[0]\nC[0] = A[N - 1]\nfor i in range(1, N):\n    B[i] = gcd(B[i - 1], A[i])\n    C[i] = gcd(C[i - 1], A[N - i - 1])\n\n\nans = 0\nfor i in range(N):\n    if i != 0 and i != N - 1:\n        ans = max(ans, gcd(B[i - 1], C[N - i - 2]))\n    elif i == 0:\n        ans = max(ans, C[N - 2])\n    else:\n        ans = max(ans, B[N - 2])\n\nprint(ans)\n", "from typing import Callable, Iterator, Optional, TypeVar\n\nS = TypeVar(\"S\")\n\n\nclass SegmentTree:\n    \"\"\"Segment Tree\n    References:\n        https://github.com/atcoder/ac-library/blob/master/atcoder/segtree.hpp\n    \"\"\"\n\n    __slots__ = [\"_e\", \"_op\", \"_n\", \"_size\", \"_tree\"]\n\n    def __init__(\n        self,\n        initial_values: Optional[Iterator[S]],\n        n: int,\n        e: S,\n        op: Callable[[S, S], S],\n    ) -> None:\n        self._e = e\n        self._op = op\n        self._n = n\n        self._size = 1 << (self._n - 1).bit_length()\n\n        self._tree = [e] * 2 * self._size\n        if initial_values is None:\n            return\n\n        for i, initial_values in enumerate(initial_values, self._size):\n            self._tree[i] = initial_values\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n\n    def _update(self, k: int) -> None:\n        \"\"\"Update the value of a[k].\"\"\"\n        self._tree[k] = self._op(self._tree[2 * k], self._tree[2 * k + 1])\n\n    def set(self, k: int, x: S) -> None:\n        \"\"\"Assign x to a[k] in O(log n).\"\"\"\n        assert 0 <= k < self._n\n\n        k += self._size\n        self._tree[k] = x\n        while k:\n            k >>= 1\n            self._update(k)\n\n    def get(self, k: int) -> S:\n        \"\"\"Return a[k] in O(1).\"\"\"\n        assert 0 <= k < self._n\n        return self._tree[k + self._size]\n\n    def prod(self, l: int, r: int) -> S:\n        \"\"\"Return op(a[l], ..., a[r - 1]). Return e, if l == r.\n        Complexity: O(log n)\n        \"\"\"\n        assert 0 <= l <= r <= self._n\n\n        sml, smr = self._e, self._e\n        l += self._size\n        r += self._size\n\n        while l < r:\n            if l & 1:\n                sml = self._op(sml, self._tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                smr = self._op(self._tree[r], smr)\n            l >>= 1\n            r >>= 1\n        return self._op(sml, smr)\n\n    def prod_all(self) -> S:\n        \"\"\"Return op(a[0], ..., a[n - 1]. Return e if n == 0.\n        Complexity: O(1)\n        \"\"\"\n        return self._tree[1]\n\n    def max_right(self, l: int, f: Callable[[S], bool]) -> int:\n        \"\"\"\n        Return an index r satisfying both:\n            1. r = l or f(op(a[l], a[l + 1], ..., a[r - 1])) = true\n            2. r = n or f(op(a[l], a[l + 1], ..., a[r])) = false.\n\n        If f is monotone, this is the maximum r satisfying:\n            f(op(a[l], a[l + 1], ..., a[r - 1])) = true.\n\n        Complexity: O(log n)\n        \"\"\"\n        assert 0 <= l <= self._n\n        assert f(self._e)\n\n        if l == self._n:\n            return self._n\n\n        l += self._size\n        sm = self._e\n\n        while True:\n            while not l & 1:\n                l >>= 1\n\n            if not f(self._op(sm, self._tree[l])):\n                while l < self._size:\n                    l *= 2\n                    if f(self._op(sm, self._tree[l])):\n                        sm = self._op(sm, self._tree[l])\n                        l += 1\n                return l - self._size\n\n            sm = self._op(sm, self._tree[l])\n            l += 1\n\n            if (l & -l) == l:\n                break\n\n        return self._n\n\n    def min_left(self, r: int, f: Callable[[S], bool]) -> int:\n        \"\"\"\n        Return an index l satisfying both:\n            1. l = r or f(op(a[l], a[l + 1], ..., a[r - 1])) = true\n            2. l = 0 or f(op(a[l - 1], a[l + 1], ..., a[r - 1])) = false.\n        If f is monotone, this is the minimum l satisfying:\n            f(op(a[l], a[l + 1], ..., a[r - 1])) = true.\n\n        Complexity: O(log n)\n        \"\"\"\n        assert 0 <= r <= self._n\n        assert f(self._e)\n\n        if not r:\n            return 0\n\n        r += self._size\n        sm = self._e\n\n        while True:\n            r -= 1\n            while r > 1 and r & 1:\n                r >>= 1\n\n            if not f(self._op(self._tree[r], sm)):\n                while r < self._size:\n                    r = 2 * r + 1\n                    if f(self._op(self._tree[r], sm)):\n                        sm = self._op(self._tree[r], sm)\n                        r -= 1\n                return r + 1 - self._size\n\n            if (r & -r) == r:\n                break\n\n        return 0\n\n\ndef staticrmq():\n    # https://judge.yosupo.jp/problem/staticrmq\n    import sys\n\n    read = sys.stdin.buffer.read\n    readline = sys.stdin.buffer.readline\n\n    N, _ = list(map(int, readline().split()))\n    A = list(map(int, readline().split()))\n    LR = list(map(int, read().split()))\n    tree = SegmentTree(A, N, (10 ** 10) + 1, min)\n    res = [tree.prod(l, r) for l, r in zip(*[iter(LR)] * 2)]\n    print((\"\\n\".join(map(str, res))))\n\n\ndef practice2_j():\n    # https://atcoder.jp/contests/practice2/tasks/practice2_j\n    import sys\n\n    readline = sys.stdin.readline\n\n    N, Q = list(map(int, readline().split()))\n    A = list(map(int, readline().split()))\n    tree = SegmentTree(A, N, -1, max)\n    res = []\n    for _ in range(Q):\n        t, x, y = list(map(int, readline().split()))\n        if t == 1:\n            tree.set(x - 1, y)\n        elif t == 2:\n            res.append(tree.prod(x - 1, y))\n        else:\n            res.append(tree.max_right(x - 1, lambda n: n < y) + 1)\n    print((\"\\n\".join(map(str, res))))\n\n\ndef dsl_2_a():\n    # https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_A\n    N, Q, *X = list(map(int, open(0).read().split()))\n    tree = SegmentTree(None, N, 2 ** 31 - 1, min)\n    res = []\n    for com, x, y in zip(*[iter(X)] * 3):\n        if com:\n            res.append(tree.prod(x, y + 1))\n        else:\n            tree.set(x, y)\n    print((\"\\n\".join(map(str, res))))\n\n\ndef abc125_c():\n    # https://atcoder.jp/contests/abc125/tasks/abc125_c\n    from math import gcd\n\n    N, *A = list(map(int, open(0).read().split()))\n    tree = SegmentTree(A, N, 0, gcd)\n    res = max(gcd(tree.prod(0, i), tree.prod(i + 1, N)) for i in range(N))\n    print(res)\n\n\ndef __starting_point():\n    # staticrmq()\n    # practice2_j()\n    # dsl_2_a()\n    abc125_c()\n\n__starting_point()", "from math import gcd\nfrom functools import reduce\n \ndef gcd_list(numbers):\n    return reduce(gcd, numbers)\n\nN = int(input())\nA = list(map(int,input().split()))\n\n\nX = [0]*N\nY = [0]*N\nX[0] = A[0]\nY[-1] = A[-1]\nans = [0]*N\nfor i in range(1,N):\n  X[i] = gcd(X[i-1],A[i])\n  Y[N-i-1] = gcd(Y[N-i],A[N-i-1])\nfor i in range(1,N-1):\n  ans[i] = gcd(X[i-1],Y[i+1])\nans[0],ans[-1] = gcd_list(A[1:]),gcd_list(A[:-1])\nprint(max(ans))", "import math\nimport itertools\n\nn = int(input())\na = list(map(int, input().split()))\npf = [0] + list(itertools.accumulate(a, math.gcd))\npb = [0] + list(itertools.accumulate(reversed(a), math.gcd))\npb.reverse()\nans = [0]*n\nfor i in range(n):\n  ans[i] = math.gcd(pf[i], pb[i+1])\nprint(max(ans))", "import sys\nimport math\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n\ngcd = math.gcd\ndef main():\n    N = I()\n    A = TI()\n    past = math.gcd(A[0], A[1])\n    D = {A[0],A[1]}\n    for i in A[2:]:\n        new_D = set()\n        for j in D:\n            new_D = new_D | {gcd(j, i)}\n        new_D = new_D | {past}\n        past = gcd(i, past)\n        D = new_D\n    \n    print(max(D))\n    \ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport math\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n\ndef main():\n    N = I()\n    A = LI()\n    past = math.gcd(A[0], A[1])\n    D = {A[0],A[1]}\n    \n    for i in A[2:]:\n        new_D = set()\n        for j in D:\n            new_D = new_D | {math.gcd(j, i)}\n        new_D = new_D | {past}\n        past = math.gcd(i, past)\n        D = new_D\n    \n    print(max(D))\n    \ndef __starting_point():\n    main()\n__starting_point()", "import math\n\nN = int(input().rstrip())\nA = list(map(int,input().rstrip().split()))\nl = [A[0]]\nr = [A[-1]]\nfor i in range(len(A)-1):\n    l.append(math.gcd(A[i+1],l[i]))\n    r.append(math.gcd(A[-(i+2)],r[i]))\nans = []\nans.append(r[-2])\nfor i in range(len(A)-2):\n    ans.append(math.gcd(l[i],r[-(i+3)]))\nans.append(l[-2])\nprint(max(*ans))", "import math\nn=int(input())\na = list(map(int,input().split()))\na.sort()\nlr=[0]*n\nrl=[0]*n\n\nfor i in range(n):\n  if i==0:\n    g=a[0]\n    lr[0]=g\n  else:\n    g=math.gcd(a[i],g)\n    lr[i]=g\n    \nfor i in range(n-1,0,-1):\n  if n-1==i:\n    g=a[n-1]\n    rl[n-1]=g\n  else:\n    g=math.gcd(a[i],g)\n    rl[i]=g  \nhantei=0\nans=0\n#print(lr)\n#print(rl)\nfor i in range(n):\n  if i==0:\n    hantei=rl[1]\n  elif i==n-1:\n    hantei=lr[n-2]\n  else:\n    hantei=math.gcd(lr[i-1],rl[i+1])\n  if ans<=hantei:\n    ans=hantei\n    \nprint(ans)", "import math\nn = int(input())\na = list(map(int, input().split()))\nif n == 1:\n    print(10 ** 9)\n    return\nl = [0] * n\nr = [0] * n\nl[0] = a[0]\nr[-1] = a[-1]\nfor i in range(n-1):\n    l[i+1] = math.gcd(a[i+1], l[i])\n    r[-i-2] = math.gcd(a[-i-2], r[-i-1])\nans = max(l[-2], r[1])\nfor i in range(n-2):\n    ans = max(ans, math.gcd(l[i], r[i+2]))\nprint(ans)", "import math\n\nn = int(input())\na = list(map(int,input().split()))\nL = [0]*(n+1)\nR = [0]*(n+1)\nfor i in range(n):\n    L[i+1] = math.gcd(L[i], a[i])\n    R[-2-i] = math.gcd(R[-1-i], a[-1-i])\n    \nans = 0\nfor i in range(n):\n    G = math.gcd(L[i], R[i+1])\n    ans = max(ans, G)\nprint(ans)\n", "def gcd(a, b):\n    while b > 0:\n        a, b = b, a % b\n    return a\n\n\nn = int(input())\na = list(map(int, input().strip().split()))\n\nL = [0]\nR = [0]\nfor i in range(n):\n    L.append(gcd(L[i], a[i]))\n    R.append(gcd(R[i], a[n-i-1]))\n\nres = 0\nfor i in range(n):\n    if res < gcd(L[i], R[n - i - 1]):\n        res = gcd(L[i], R[n - i - 1])\n\nprint(res)\n", "from typing import Callable, List, Optional, Union\n\nT = Union[int, str]\n\n\nclass SegmentTree:\n    \"\"\"Segment Tree\"\"\"\n\n    __slots__ = [\"e\", \"op\", \"modifying_op\", \"_n\", \"_size\", \"tree\"]\n\n    def __init__(\n        self,\n        a: List[T],\n        e: T,\n        op: Callable[[T, T], T],\n        modifying_op: Optional[Callable[[T], T]] = None,\n    ) -> None:\n        self.e = e\n        self.op = op\n        self.modifying_op = modifying_op\n        self._n = len(a)\n        self._size = 1 << (self._n - 1).bit_length()\n\n        if modifying_op:\n            a = list(map(modifying_op, a))\n        self.tree = [e] * self._size + a + [e] * (self._size - self._n)\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n\n    def _update(self, k: int) -> None:\n        \"\"\"Update the value of a[k].\"\"\"\n        self.tree[k] = self.op(self.tree[2 * k], self.tree[2 * k + 1])\n\n    def set(self, k: int, x: T) -> None:\n        \"\"\"Assign x to a[k] in O(log n).\"\"\"\n        assert 0 <= k < self._n\n\n        k += self._size\n        if self.modifying_op:\n            x = self.modifying_op(x)\n        self.tree[k] = x\n        while k:\n            k >>= 1\n            self._update(k)\n\n    def get(self, k: int) -> T:\n        \"\"\"Return a[k] in O(1).\"\"\"\n        assert 0 <= k < self._n\n        return self.tree[k + self._size]\n\n    def prod(self, l: int, r: int) -> T:\n        \"\"\"Return op(a[l], ..., a[r - 1]). Return e, if l == r.\n        Complexity: O(log n)\n        \"\"\"\n        assert 0 <= l <= r <= self._n\n\n        sml, smr = self.e, self.e\n        l += self._size\n        r += self._size\n\n        while l < r:\n            if l & 1:\n                sml = self.op(sml, self.tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                smr = self.op(self.tree[r], smr)\n            l >>= 1\n            r >>= 1\n        return self.op(sml, smr)\n\n    def prod_all(self) -> T:\n        \"\"\"Return op(a[0], ..., a[n - 1]. Return e if n == 0.\n        Complexity: O(1)\n        \"\"\"\n        return self.tree[1]\n\n    def max_right(self, l: int, f: Callable[[T], bool]) -> int:\n        \"\"\"\n        Return an index r satisfying both:\n            1. r = l or f(op(a[l], a[l + 1], ..., a[r - 1])) = true\n            2. r = n or f(op(a[l], a[l + 1], ..., a[r])) = false.\n\n        If f is monotone, this is the maximum r satisfying:\n            f(op(a[l], a[l + 1], ..., a[r - 1])) = true.\n\n        Complexity: O(log n)\n        \"\"\"\n        assert 0 <= l <= self._n\n        assert f(self.e)\n\n        if l == self._n:\n            return self._n\n\n        l += self._size\n        sm = self.e\n\n        while True:\n            while not l & 1:\n                l >>= 1\n\n            if not f(self.op(sm, self.tree[l])):\n                while l < self._size:\n                    l *= 2\n                    if f(self.op(sm, self.tree[l])):\n                        sm = self.op(sm, self.tree[l])\n                        l += 1\n                return l - self._size\n\n            sm = self.op(sm, self.tree[l])\n            l += 1\n\n            if (l & -l) == l:\n                break\n\n        return self._n\n\n    def min_left(self, r: int, f: Callable[[T], bool]) -> int:\n        \"\"\"\n        Return an index l satisfying both:\n            1. l = r or f(op(a[l], a[l + 1], ..., a[r - 1])) = true\n            2. l = 0 or f(op(a[l - 1], a[l + 1], ..., a[r - 1])) = false.\n        If f is monotone, this is the minimum l satisfying:\n            f(op(a[l], a[l + 1], ..., a[r - 1])) = true.\n\n        Complexity: O(log n)\n        \"\"\"\n        assert 0 <= r <= self._n\n        assert f(self.e)\n\n        if not r:\n            return 0\n\n        r += self._size\n        sm = self.e\n\n        while True:\n            r -= 1\n            while r > 1 and r % 2:\n                r >>= 1\n\n            if not f(self.op(self.tree[r], sm)):\n                while r < self._size:\n                    r = 2 * r + 1\n                    if f(self.op(self.tree[r], sm)):\n                        sm = self.op(self.tree[r], sm)\n                        r -= 1\n                return r + 1 - self._size\n\n            if (r & -r) == r:\n                break\n\n        return 0\n\n\ndef practice2_j():\n    # https://atcoder.jp/contests/practice2/tasks/practice2_j\n    N, _, *AQ = list(map(int, open(0).read().split()))\n    A, Q = AQ[:N], AQ[N:]\n    tree = SegmentTree(A, -1, max)\n    res = []\n    for t, x, y in zip(*[iter(Q)] * 3):\n        if t == 1:\n            tree.set(x - 1, y)\n        elif t == 2:\n            res.append(tree.prod(x - 1, y))\n        else:\n            res.append(tree.max_right(x - 1, lambda n: n < y) + 1)\n    print((\"\\n\".join(map(str, res))))\n\n\ndef staticrmq():\n    # https://judge.yosupo.jp/problem/staticrmq\n    N, Q, *ALR = list(map(int, open(0).read().split()))\n    A, LR = ALR[:N], ALR[N:]\n    tree = SegmentTree(A, (10 ** 10) + 1, min)\n    res = [tree.prod(l, r) for l, r in zip(*[iter(LR)] * 2)]\n    print((\"\\n\".join(map(str, res))))\n\n\ndef dsl_2_a():\n    # https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_A\n    N, Q, *X = list(map(int, open(0).read().split()))\n    tree = SegmentTree([2 ** 31 - 1] * N, 2 ** 31 - 1, min)\n    res = []\n    for com, x, y in zip(*[iter(X)] * 3):\n        if com:\n            res.append(tree.prod(x, y + 1))\n        else:\n            tree.set(x, y)\n    print((\"\\n\".join(map(str, res))))\n\n\ndef abc125_c():\n    # https://atcoder.jp/contests/abc125/tasks/abc125_c\n    from math import gcd\n\n    N, *A = list(map(int, open(0).read().split()))\n    tree = SegmentTree(A, 0, gcd)\n    res = max(gcd(tree.prod(0, i), tree.prod(i + 1, N)) for i in range(N))\n    print(res)\n\n\ndef __starting_point():\n    # practice2_j()\n    # staticrmq()\n    # dsl_2_a()\n    abc125_c()\n\n__starting_point()", "from math import gcd\nn = int(input())\na = list(map(int,input().split()))\nl,r = [a[0]]*n,[a[n-1]]*n\nfor i in range(1,n-1):\n  l[i] = gcd(l[i-1],a[i])\n  r[n-i-1] = gcd(r[n-i],a[n-i-1])\nans = [0]*n\nans[0] = r[1]\nans[n-1] = l[n-2]\nfor i in range(1,n-1):\n  ans[i] = gcd(l[i-1],r[i+1])\nprint(max(ans))", "import sys\nfrom math import gcd\nfrom itertools import accumulate\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, *A = list(map(int, read().split()))\n\n    vec1 = [0] * (N + 1)\n    vec2 = [0] * (N + 1)\n    for i in range(N):\n        vec1[i + 1] = gcd(vec1[i], A[i])\n    for i in range(N - 1, -1, -1):\n        vec2[i] = gcd(vec2[i + 1], A[i])\n\n    ans = 0\n    for i in range(N):\n        g = gcd(vec1[i], vec2[i + 1])\n        if ans < g:\n            ans = g\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import gcd\n\nN = int(input())\nA = list(map(int,input().split()))\n\nL,R = [0],[0]\n\nfor i in range(N-1):\n    L += [gcd(L[i],A[i])]\n    R += [gcd(R[i],A[-i-1])]\n\nprint((max(gcd(L[i],R[-i-1])for i in range(N))))\n\n", "import math\nn=int(input())\na=list(map(int, input().split()))\nalist=[]\ngcd1=a[0]\nfor i in range(0,n):\n  gcd1=math.gcd(gcd1,a[i])\n  alist.append(gcd1)\nblist=[]\ngcd2=a[n-1]\nfor i in range(n-1,-1,-1):\n  gcd2=math.gcd(gcd2,a[i])\n  blist.append(gcd2)\nclist=[alist[n-2],blist[n-2]]\nfor i in range(n-2):\n  clist.append(math.gcd(alist[i],blist[n-i-3]))\nprint(max(clist))", "def main():\n    def gcd(a, b):\n        if b == 0:\n            return a\n        else:\n            return gcd(b, a%b)\n\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    x = [0] * n\n    y = [0] * n\n    # x []   [0~1][0~2][0~3]...[0~n-1][0~n]\n    # y [0~n][1~n][2~n][3~n]...[n]    []\n    # y\u306erange\u306e\u3068\u308a\u65b9\u3092\u5de5\u592b\u3059\u308b\n    for i in range(1,n):\n        x[i] = gcd(x[i-1], a[i-1])\n    for i in range(n-2, -1, -1):\n        y[i] = gcd(y[i+1], a[i+1])\n    ans = [gcd(x[i], y[i]) for i in range(n)]\n    print(max(ans))\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a%b)\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    left = [A[0]] * (N+2)\n    right = [A[-1]] * (N+2)\n\n    for i in range(N):\n        left[i+1] = gcd(left[i], A[i])\n        right[N-i] = gcd(right[N-i+1], A[N-1-i])\n    # print(left)\n    # print(right)\n    ans = max(left[-3], right[2])\n    for i in range(1, N+1):\n        ans = max(ans, gcd(left[i-1], right[i+1]))\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin/env python3\n\n#import\nimport math\n#import numpy as np\nN = int(input())\nA = list(map(int, input().split()))\n\nclass SegTree:\n    def __init__(self, segfunc, e, v, init_val = None):\n        \"\"\"\n        segfunc: function \u533a\u9593\u306b\u3057\u305f\u3044\u64cd\u4f5c\\n\n        e: Any \u5358\u4f4d\u5143\\n\n        v: int or List \u8981\u7d20\u6570\u304b\u683c\u7d0d\u3059\u308b\u914d\u5217\\n\n        init_val: Any \u521d\u671f\u5024\n        \"\"\"\n        self.segfunc = segfunc\n        self.e = e\n        self.init_val = init_val if init_val != None else e\n        if isinstance(v, int):\n            v = [self.init_val] * v\n        self.n = len(v)\n        self.log = (self.n).bit_length()\n        self.size = 1 << self.log\n        self.tree = [e] * 2 * self.size\n        # 1-indexed\u306a\u306e\u3067tree[1:self.size]\u304cN-1\u8981\u7d20\n        # tree[self.size:self.size + N]\u304c\u914d\u5217\n        for i in range(self.n):\n            self.tree[self.size + i] = v[i]\n        for i in range(self.size - 1, 0, -1):\n            self._update(i)\n\n    def set(self, k, x) -> None:\n        \"\"\"\n        k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0\\n\n        k: index(0-indexed)\\n\n        x: update value\n        \"\"\"\n        k += self.size\n        self.tree[k] = x\n        for i in range(1, self.log + 1):\n            self._update(k >> i)\n\n    def get(self, k):\n        \"\"\"\n        a[k]\u3092\u8fd4\u3059\\n\n        k: index(0-indexed)\n        \"\"\"\n        assert 0 <= k < self.size\n        return self.tree[k + self.size]\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)\u306esegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\\n\n        l: index(0-indexed)\\n\n        r: index(0-indexed)\n        \"\"\"\n        res = self.e\n        l += self.size\n        r += self.size\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n    def all_query(self):\n        \"\"\"\n        \u5168\u7bc4\u56f2\u306bsegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\n        \"\"\"\n        return self.tree[1]\n\n    # \u4e8c\u5206\u63a2\u7d22\u5b9f\u88c5\u3001\u3044\u308b\uff1f\n\n    def _update(self, k):\n        self.tree[k] = self.segfunc(self.tree[k * 2], self.tree[k * 2 + 1])\n\nseg = SegTree(math.gcd, 0, A)\n\nans = 0\n\nfor i in range(N):\n    ans = max(ans, math.gcd(seg.query(0, i), seg.query(i + 1, N)))\n\nprint(ans)\n", "import sys\nimport math\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int, input().split()))\ndef TI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n\ndef main():\n    N = I()\n    A = TI()\n    past = math.gcd(A[0], A[1])\n    D = {A[0],A[1]}\n    for i in A[2:]:\n        new_D = set()\n        for j in D:\n            new_D = new_D | {math.gcd(j, i)}\n        new_D = new_D | {past}\n        past = math.gcd(i, past)\n        D = new_D\n    \n    print(max(D))\n    \ndef __starting_point():\n    main()\n__starting_point()", "from math import*\nN=int(input())\n*A,=map(int,input().split())\nR=[0]*(N+1)\nfor i in range(N):\n    R[-i-2]=gcd(R[-i-1],A[-i-1])\nL=0\nM=1\nfor i in range(N):\n    M=max(M,(gcd(L,R[i+1])))\n    L=gcd(L,A[i])\nprint(M)", "import math\nimport itertools\n\nn = int(input())\na = list(map(int, input().split()))\npf = [0]*(n+1)\npb = [0]*(n+1)\np = a[0]\nfor i in range(n):\n  p = math.gcd(p, a[i])\n  pf[i+1] = p\np = a[-1]\nfor i in range(-1, -n-1, -1):\n  p = math.gcd(p, a[i])\n  pb[i-1] = p\nans = [0]*n\nfor i in range(n):\n  ans[i] = math.gcd(pf[i], pb[i+1])\nprint(max(ans))", "import math\n\ndef main():\n\tN = int(input())\n\tA = [int(a) for a in input().split(\" \")]\n\tgcd1 = []\n\tgcd2 = []\n\tfor i in range(len(A)):\n\t\tif i == 0:\n\t\t\tgcd1.append(A[0])\n\t\t\tgcd2.append(A[-1])\n\t\telse:\n\t\t\tgcd1.append(math.gcd(A[i], gcd1[-1]))\n\t\t\tgcd2.insert(0, math.gcd(A[-i-1], gcd2[0]))\n\n\tgcds = []\n\tfor i in range(N):\n\t\tif i == 0:\n\t\t\tgcds.append(gcd2[1])\n\t\telif i == N - 1:\n\t\t\tgcds.append(gcd1[-2])\n\t\telse:\n\t\t\tgcds.append(math.gcd(gcd1[i-1], gcd2[-N+i+1]))\n\tprint((max(gcds)))\n\nmain()\n", "from math import gcd\nn = int(input())\nalst = list(map(int, input().split()))\nl_gcd = [alst[0]]\nfor num in alst[1:-1]:\n    l_gcd.append(gcd(l_gcd[-1], num))\n\nr_gcd = [alst[-1]]\nfor num in alst[1:-1][::-1]:\n    r_gcd.append(gcd(r_gcd[-1], num))\nr_gcd = r_gcd[::-1]\nans = max(r_gcd[0], l_gcd[-1])\n\n\nfor num1, num2 in zip(r_gcd[1:], l_gcd[:-1]):\n    tmp = gcd(num1, num2)\n    ans = max(ans, tmp)\nprint(ans)", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n\ndef gcd(a, b):\n    \"\"\"\u6700\u5927\u516c\u7d04\u6570\"\"\"\n    a, b = (a, b) if a >= b else (b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(N, A):\n    L = [0] * N\n    L[0] = A[0]\n    for i in range(1, N):\n        L[i] = gcd(A[i], L[i - 1])\n    R = [0] * N\n    R[-1] = A[-1]\n    for i in range(1, N):\n        R[-(i + 1)] = gcd(A[-(i + 1)], R[-i])\n    ans = 0\n    for i in range(N):\n        if i == 0:\n            ans = max(ans, R[i + 1])\n        elif i == N - 1:\n            ans = max(ans, L[i - 1])\n        else:\n            ans = max(ans, gcd(L[i - 1], R[i + 1]))\n    print(ans)\n\n\ndef __starting_point():\n    # S = input()\n    N = int(input())\n    # N, M = map(int, input().split())\n    A = [int(i) for i in input().split()]\n    # B = [int(i) for i in input().split()]\n    # AB = [[int(i) for i in input().split()] for _ in range(N)]\n    solve(N, A)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "from math import gcd\n\n\nN, *A = list(map(int, open(0).read().split()))\n\nacc_l = [0] * (N + 1)\nacc_r = [0] * (N + 1)\nfor i in range(1, N + 1):\n    acc_l[i] = gcd(acc_l[i - 1], A[i - 1])\n    acc_r[i] = gcd(acc_r[i - 1], A[-i])\nans = 0\nfor i in range(N + 1):\n    ans = max(ans, gcd(acc_l[i], acc_r[N - i - 1]))\nprint(ans)\n", "import sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return map(int,input().split())\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print(\"-------\\n{}\\n-------\".format(text))\ndef fde(): print(\"-flag-\")\n\ndef divisors(n):\n    res = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            res.append(i)\n            if i != n // i:\n                res.append(n//i)\n\n    return res\n\n\ndef main():\n    N=ii()\n    A=list(mi())\n    R = divisors(A[0]) + divisors(A[1])\n\n    ans = 0\n    for r in R:\n        miss_count = 0\n        for a in A:\n            if a % r != 0:\n                miss_count += 1\n                if miss_count == 2:\n                    break\n        \n        if miss_count <= 1:\n            ans = max(ans,r)\n            \n\n    print(ans)\n\n\n\n\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import sys\nimport math\nimport itertools\nimport collections\nfrom collections import deque\nfrom collections import defaultdict\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\nMOD2 = 998244353\nINF = float('inf')\ninput = lambda: sys.stdin.readline().strip()\n\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\ndef main():\n    N = NI()\n    A = NLI()\n    \n    L = [0 for _ in range(N)]\n    L_gcd = 0\n    for n in range(0,N-1):\n        L_gcd = math.gcd(A[n],L_gcd)\n        L[n+1] = L_gcd\n\n    \n\n    R = [0 for _ in range(N)]\n    R_gcd = 0\n    for n in range(N-1,-1,-1):\n        R_gcd = math.gcd(A[n],R_gcd)\n        R[n-1] = R_gcd\n    R[-1] = 0\n\n    \n    ans = 0\n    for n in range(N):\n        ans = max(ans,math.gcd(L[n],R[n]))\n    print(ans)\n    \n\n\ndef __starting_point():\n    main()\n__starting_point()", "import math\nn=int(input())\na=list(map(int,input().split()))\n\nra=list(reversed(a))\n\nleft=[]\nright=[]\nright.append(ra[0])\nleft.append(a[0])\n\nif n>2:\n  k=math.gcd(a[0],a[1])\n  left.append(k)\n  for i in range(2,n-1):\n    k=math.gcd(k,a[i])\n    left.append(k)\n\n  k=math.gcd(ra[0],ra[1])\n  right.append(k)\n  for i in range(2,n-1):\n    k=math.gcd(k,ra[i])\n    right.append(k)\n\n  ans=[right[-1]]\n  for i in range(1,n-1):\n    ans.append(math.gcd(left[i-1],right[len(right)-i-1]))\n  ans.append(left[-1])\n  print(max(ans))\nelse:\n  print(max(a[1],a[0]))", "from itertools import accumulate\nfrom math import gcd\n\nN = int(input())\nA = list(map(int, input().split()))\n\nl = list(accumulate(A[:-1], gcd, initial=0))\nr = list(accumulate(A[::-1], gcd, initial=0))\nprint(max(gcd(l[i], r[N-i-1]) for i in range(N)))", "def gcd(x,y):\n    if x==0 or y==0:\n        return max(x,y)\n    if x<y:\n        x,y=y,x\n    if x%y==0:\n        return y\n    return gcd(y,x%y)\nn=int(input())\na=list(map(int,input().split()))\nL=[a[0]]*n\nR=[a[-1]]*n\nfor i in range(n-1):\n    L[i+1]=gcd(L[i],a[i+1])\n    R[-i-2]=gcd(R[-i-1],a[-i-2])\nans=1\nL=[0]+L\nR=R+[0]\nfor i in range(n):\n    ans=max(ans,gcd(L[i],R[i+1]))\nprint(ans)", "import math\nfrom itertools import accumulate\n\nn = int(input())\na = list(map(int, input().split()))\n\nfromleft = list(accumulate(a, math.gcd))\nfromright = list(accumulate(a[::-1], math.gcd))[::-1]\n\ngcd = []\n\ngcd.append(fromright[1])\nfor i in range(1, n-1):\n    gcd.append(math.gcd(fromleft[i-1], fromright[i+1]))\ngcd.append(fromleft[n-2])\n\nprint((max(gcd)))\n", "#a, b, k = map(int, input().split( ))\nimport math\n\n \nn = int(input())\na = list(map(int,input().split()))\n\nleft = [0] * (n + 1)\nright = [0] * (n + 1)\nfor i in range(n):\n    left[i + 1] = (math.gcd(left[i],a[i]))\n    right[n - i - 1] = (math.gcd(right[n - i],a[n - 1 - i]))\n#print(left, right)\n\nans = 0\nfor i in range(n):\n  ans = max(ans, math.gcd(left[i],right[i+1]))\nprint(ans)", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\ndef LIST1() : return list(MAP1())\n\ndef solve():\n    N = INT()\n    a = LIST()\n    l = [0]*N\n    r = [0]*N\n    l[0] = a[0]\n    r[N-1] = a[N-1]\n\n    for i in range(1, N):\n        l[i] = gcd(l[i-1], a[i])\n    for i in range(N-2, -1, -1):\n        r[i] = gcd(r[i+1], a[i])\n\n    ans = max(r[1], l[N-2])\n    for i in range(1, N-1):\n        ans = max(ans, gcd(l[i-1], r[i+1]))\n    print(ans)\n    \ndef __starting_point():\n    solve()\n__starting_point()", "from math import gcd\n\nN = int(input())\nA = list(map(int, input().split()))\n\n\nclass SegmentTree(object):\n    def __init__(self, init_val, segfunc, ide_ele):\n        self.init_val = init_val\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        n = len(init_val)\n\n        self.num = 1 << (n - 1).bit_length()\n\n        self.tree = [ide_ele] * 2 * self.num\n\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def query(self, left, right):\n        res = self.ide_ele\n\n        left += self.num\n        right += self.num\n\n        while left < right:\n            if left & 1:\n                res = self.segfunc(res, self.tree[left])\n                left += 1\n\n            if right & 1:\n                res = self.segfunc(res, self.tree[right - 1])\n\n            left >>= 1\n            right >>= 1\n\n        return res\n\n    def update(self, k, val):\n        k += self.num\n        self.tree[k] = val\n\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n\ndef segfunc(x, y):\n    return gcd(x, y)\n\n\ndef get_lcm(a, b):\n    return (a * b) // gcd(a, b)\n\n\ng = A[0]\nfor a in A[1:]:\n    g = get_lcm(g, a)\n\n\nide_ele = g\nst = SegmentTree(A, segfunc, ide_ele)\n\n\nres = 0\nfor i in range(N):\n    left = st.query(0, i)\n    right = st.query(i + 1, N)\n\n    res = max(res, gcd(left, right))\n\nprint(res)\n", "from math import gcd\nclass SegmentTree:\n    def __init__(self,n,ele=0):\n\n        self.ide_ele = ele\n\n        self.num =2**(n-1).bit_length()\n        self.seg=[self.ide_ele]*2*self.num\n\n\n    #####segfunc######\n    def segfunc(self,x,y):\n        return gcd(x,y)\n\n    def init(self,init_val):\n        #set_val\n        for i in range(n):\n            self.seg[i+self.num-1]=init_val[i]    \n        #built\n        for i in range(self.num-2,-1,-1) :\n            self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n        \n    def update(self,k,x):\n        k += self.num-1\n        self.seg[k] = x\n        while k:\n            k = (k-1)//2\n            self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n        \n    def query(self,p,q):\n        if q<=p:\n            return self.ide_ele\n        p += self.num-1\n        q += self.num-2\n        res=self.ide_ele\n        while q-p>1:\n            if p&1 == 0:\n                res = self.segfunc(res,self.seg[p])\n            if q&1 == 1:\n                res = self.segfunc(res,self.seg[q])\n                q -= 1\n            p = p//2\n            q = (q-1)//2\n        if p == q:\n            res = self.segfunc(res,self.seg[p])\n        else:\n            res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n        return res\nn=int(input())\na=list(map(int,input().split()))\nst=SegmentTree(n)\nst.init(a)\nans=-1\nfor i in range(n):\n    ans=max(ans,gcd(st.query(0,i),st.query(i+1,n)))\nprint(ans)", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\ndef LIST1() : return list(MAP1())\n\n#####segfunc#####\ndef segfunc(x, y):\n    return gcd(x, y)\n#################\n\n#####ide_ele#####\nide_ele = 0\n#################\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): \u914d\u5217init_val\u3067\u521d\u671f\u5316 O(N)\n    update(k, x): k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0 O(logN)\n    query(l, r): \u533a\u9593[l, r)\u3092segfunc\u3057\u305f\u3082\u306e\u3092\u8fd4\u3059 O(logN)\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: \u914d\u5217\u306e\u521d\u671f\u5024\n        segfunc: \u533a\u9593\u306b\u3057\u305f\u3044\u64cd\u4f5c\n        ide_ele: \u5358\u4f4d\u5143\n        n: \u8981\u7d20\u6570\n        num: n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        tree: \u30bb\u30b0\u30e1\u30f3\u30c8\u6728(1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        \"\"\"\n        k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)\u306esegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\ndef solve():\n    N = INT()\n    a = LIST()\n    seg = SegTree(a, segfunc, ide_ele)\n\n    ans = 1\n    for i in range(N):\n        seg.update(i, 0)\n        ans = max(ans, seg.query(0, N))\n        seg.update(i, a[i])\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import math\nfrom itertools import accumulate\n\nn = int(input())\na = list(map(int, input().split()))\n\nfromright = list(accumulate(a, math.gcd))\na.reverse()\nfromleft = list(accumulate(a, math.gcd))\nfromleft.reverse()\n\ngcd = []\n\ngcd.append(fromleft[1])\n\nfor i in range(1, n-1):\n  gcd.append(math.gcd(fromright[i-1], fromleft[i+1]))\n\ngcd.append(fromright[n-2])\n\nif n == 2:\n  print(max(a))\nelse:\n  print(max(gcd))", "import math\n\nN=int(input())\nA=list(map(int,input().split()))\nL=[0]*(N+1)\nR=[0]*(N+1)\nM=[0]*N\nfor i in range(N):\n  L[i+1]=math.gcd(L[i],A[i])\nfor i in range(N-1,0,-1):\n  R[i]=math.gcd(R[i+1],A[i])\nfor i in range(N):\n  M[i]=math.gcd(L[i],R[i+1])\nprint(max(M))", "from math import gcd\n\nN = int(input())\nA = list(map(int, input().split()))\n\nleft = [0]\nright = [0]\n\nfor i in range(1, N + 1):\n    l = gcd(left[-1], A[i - 1])\n    left.append(l)\n\n    r = gcd(right[-1], A[N - i])\n    right.append(r)\n\nres = 0\nfor i in range(N):\n    res = max(res, gcd(left[i], right[N - i - 1]))\n\nprint(res)", "n=int(input())\na=list(map(int,input().split()))\nfrom collections import deque\nfrom math import gcd\na_left=deque()\n\na_left.append(a[0])\n\n\na_right=deque()\n\na_right.append(a[-1])\n\nfor i in range(n-1):\n    a_left.append(gcd(a_left[-1],a[i+1]))\n    a_right.appendleft(gcd(a_right[0],a[n-i-2]))\n\n\na_right=list(a_right)\na_left=list(a_left)\n\ncount=max(a_left[-2],a_right[1])\n\nfor j in range(n-2):\n    count=max(gcd(a_left[j],a_right[j+2]),count)\nprint(count)", "import math\nfrom itertools import accumulate\n\nn = int(input())\na = list(map(int, input().split()))\n\nfromleft = list(accumulate(a, math.gcd))\nfromright = list(accumulate(a[::-1], math.gcd))[::-1]\n\ngcd = []\n\ngcd.append(fromright[1])\nfor i in range(1, n-1):\n    gcd.append(math.gcd(fromleft[i-1], fromright[i+1]))\ngcd.append(fromleft[n-2])\n\nprint(max(gcd))", "import math\n\n# 1\u3064\u81ea\u7531\u306b\u66f8\u304d\u63db\u3048\u308b\u21d2\u3042\u308b\u6570\u3092\u9664\u304fGCD\u306e\u6700\u5927\u5024\n# \u7d2f\u7a4dGCD\u3092\u4e8b\u524d\u306b\u7b97\u51fa\u3059\u308b\u3053\u3068\u3067\u3001\u3042\u308b\u6570\u3092\u9664\u304fGCD\u3092O(N)\u3067\u6c42\u3081\u3089\u308c\u308b\n\nn = int(input())\na = list(map(int, input().split()))\n\ngcd_l = [0] * (n + 1)\ngcd_r = [0] * (n + 1)\n\nfor i in range(n):\n    gcd_l[i+1] = math.gcd(gcd_l[i], a[i])\n    gcd_r[n-i-1] = math.gcd(gcd_r[n-i], a[n-i-1])\n\nans = 1\nfor l,r in zip(gcd_l, gcd_r[1:]):\n    ans = max(ans, math.gcd(l, r))\n\nprint(ans)", "import math\n\nn = int(input())\na = list(map(int,input().split()))\n\nlefGcd = [0]*100100\nrigGcd = [0]*100100\n\nlefGcd[0] = a[0]\nrigGcd[n-1] = a[n-1]\n\n#\u5de6\u5074\u304b\u3089GCD\u3092\u8a08\u7b97\u3057\u305f\u5024\u3092\u4fdd\u6301\u3059\u308b\u3002\nfor i in range(1,n):\n\tlefGcd[i] = math.gcd(lefGcd[i-1],a[i])\n\n#\u53f3\u5074\u304b\u3089GCD\u3092\u8a08\u7b97\u3057\u305f\u5024\u3092\u4fdd\u6301\u3059\u308b\u3002\nfor i in reversed(list(range(0,n-1))):\n\trigGcd[i] = math.gcd(rigGcd[i+1],a[i])\n\n#\u4e00\u756a\u5de6\u304b\u4e00\u756a\u53f3\u306e\u5024\u3092\u9664\u53bb\u3057\u305fGCD\u306e\u5024\u3092\u521d\u671f\u5024\u306b\u3059\u308b\u3002\nans = max(rigGcd[1],lefGcd[n-2])\n\n#\u5de6\u304b\u3089\u306eGCD,1\u500b\u98db\u3070\u3057,\u53f3\u304b\u3089\u306eGCD\u3092\u8a08\u7b97\u3057\u3001\u6bd4\u8f03\u3059\u308b\u3002\nfor i in range(1,n-1):\n\tans = max(ans,math.gcd(lefGcd[i-1],rigGcd[i+1]))\n\nprint(ans)\n", "from math import gcd\n\n\nN, *A = list(map(int, open(0).read().split()))\nacc_l = [0]\nacc_r = [0]\nfor i in range(N):\n    acc_l.append(gcd(acc_l[-1], A[i]))\n    acc_r.append(gcd(acc_r[-1], A[N - i - 1]))\n\nans = 0\nfor i in range(N):\n    ans = max(ans, gcd(acc_l[i], acc_r[N - i - 1]))\nprint(ans)\n", "N=int(input())\n*A,=map(int,input().split())\n\ndef gcd(a,b):\n  if b==0:return a\n  return gcd(b, a%b)\n\ndef cum(array, merge, unit):\n    new=[unit]\n    for i in range(len(array)):\n        new.append(merge(new[-1], array[i]))\n    return new\n  \ncum1 = cum(A,gcd,A[0])\ncum2 = cum(A[::-1],gcd,A[-1])[::-1]\n\nres=[]\nfor i in range(N):\n  if i == 0:\n    tmp = cum2[i+1]\n  elif i == N-1:\n    tmp = cum1[i]\n  else:\n    tmp = gcd(cum1[i],cum2[i+1])\n  res.append(tmp)\n  \nprint(max(res))", "import math\nN = int(input())\nList = list(map(int,input().split()))\nL=[0]*N\nR=[0]*N\nfor i in range(1,N):\n  L[i] = math.gcd(L[i-1],List[i-1])\n  R[-i-1] = math.gcd(R[-i],List[-i])\nans = 0\nfor i in range(N):\n  ans = max(ans,math.gcd(L[i],R[i]))\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\ndef f(A):\n    ret = [A[0]]\n    for a in A:\n        ret.append(gcd(ret[-1], a))\n    ret[0] = reduce(gcd, A[1:])\n    return ret\n\ndef solve(N: int, A: \"List[int]\"):    \n    return  max(gcd(g0, g1) for g0, g1 in zip(f(A), f(A[::-1])[-2::-1]))\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    print((solve(N, A)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "from math import gcd\nN=int(input())\nA=list(map(int,input().split()))\n\nL=[A[0]]\nR=[A[-1]]\n\nfor i in range(1,N):\n    L.append(gcd(L[-1],A[i]))\n    R.append(gcd(R[-1],A[-1-i]))\nR=R[::-1]\n#print(L)\n#print(R)\n\nans=1\nfor j in range(N):\n    if j==0:\n        tmp = R[1]\n    elif j==N-1:\n        tmp = L[N-2]\n    else:\n        tmp = gcd(L[j-1],R[j+1])\n    #print(j,tmp)\n    ans=max(ans,tmp)\n    \nprint(ans)", "from math import gcd\n\nn, *a = list(map(int, open(0).read().split()))\n\nl = [0] * n\nr = [0] * n\nfor i in range(n - 1):\n    l[i + 1] = gcd(l[i], a[i])\nfor i in range(n - 1, 0, -1):\n    r[i - 1] = gcd(r[i], a[i])\nprint((max(gcd(l[i], r[i]) for i in range(n))))\n", "import sys\nfrom math import gcd\nfrom itertools import accumulate\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, *A = list(map(int, read().split()))\n\n    vec1 = list(accumulate(A, func=gcd))\n    vec2 = list(accumulate(reversed(A), func=gcd))\n\n    ans = 0\n    for i in range(N):\n        if i == 0:\n            res = vec2[-2]\n        elif i == N - 1:\n            res = vec1[-2]\n        else:\n            res = gcd(vec1[i - 1], vec2[N - i - 2])\n\n        if ans < res:\n            ans = res\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nn=int(input())\na=list(map(int,input().split()))\nl=[0]*n\nr=[0]*n\nl[0]=a[0]\nr[-1]=a[-1]\nfor i in range(n-1):\n  l[i+1]=math.gcd(l[i],a[i+1])\nfor i in reversed(range(n-1)):\n  r[i] = math.gcd(r[i+1],a[i])\n\nans=max(l[-2],r[1])\nfor i in range(1,n-1):\n  ans = max(ans, math.gcd(l[i-1],r[i+1]))\nprint(ans)", "from math import gcd\n\n\nclass SegmentTree:\n    def __init__(self, size, op, e):\n        self._op = op\n        self._e = e\n        self._size = size\n        t = 1\n        while t < size:\n            t *= 2\n        self._offset = t - 1\n        self._data = [e] * (t * 2 - 1)\n\n    def __getitem__(self, key):\n        return self._data[self._offset + key]\n\n    def __setitem__(self, key, value):\n        op = self._op\n        data = self._data\n        i = self._offset + key\n        data[i] = value\n        while i >= 1:\n            i = (i - 1) // 2\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n\n    def build(self, iterable):\n        op = self._op\n        data = self._data\n        data[self._offset:self._offset + self._size] = iterable\n        for i in range(self._offset - 1, -1, -1):\n            data[i] = op(data[i * 2 + 1], data[i * 2 + 2])\n\n    def query(self, start, stop):\n        def iter_segments(data, l, r):\n            while l < r:\n                if l & 1 == 0:\n                    yield data[l]\n                if r & 1 == 0:\n                    yield data[r - 1]\n                l = l // 2\n                r = (r - 1) // 2\n        op = self._op\n        it = iter_segments(self._data, start + self._offset,\n                           stop + self._offset)\n        result = self._e\n        for v in it:\n            result = op(result, v)\n        return result\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\nst = SegmentTree(N, gcd, 0)\nst.build(A)\n\nresult = st.query(1, N)\nfor i in range(1, N - 1):\n    result = max(result, gcd(st.query(0, i), st.query(i + 1, N)))\nresult = max(result, st.query(0, N - 1))\nprint(result)\n", "N = int(input())\na = list(map(int, input().split()))\n\n\ndef gcd(x, y):\n    if x < y:\n        x, y = y, x\n    while y != 0:\n        tmp = x % y\n        x = y\n        y = tmp\n    return x\n\n\nans = 1\nif N == 2:\n    print(max(a))\n    return\n\nl = [1] * N\nl[0] = a[0]\nr = [1] * N\nr[N-1] = a[N-1]\nfor i in range(1, N):\n    l[i] = gcd(l[i-1], a[i])\n    r[N-1-i] = gcd(r[N-i], a[N-1-i])\n    \nfor i in range(N):\n    if i == 0:\n        n = r[1]\n    elif i == N-1:\n        n = l[N-2]\n    else:\n        n = gcd(l[i-1], r[i+1])\n    ans = max(ans, n)\nprint(ans)", "import math\nfrom collections import deque\nN = int(input())\nA = list(map(int,input().split()))\n\nM = 0\nL = deque([0])\nR = deque([0])\nfor i in range(1,N+1):\n    L.append(math.gcd(L[-1],A[i-1]))\n    R.appendleft(math.gcd(R[0],A[N-i]))\nfor j in range(N):\n    m = math.gcd(L[j],R[j+1])\n    M = max(M,m)\nprint(M)", "N = int(input())\nA = list(map(int, input().split()))\nans = 0\n\ndef gcd(x, y):\n  if x < y:\n    x, y = y, x\n  if y == 0:\n    return x\n  while y > 0:\n    temp = x % y\n    x = y\n    y = temp\n  return x\n\nL = [0]\nR = 0\n\nfor i in range(N-1):\n  L.append(gcd(A[i], L[i]))\nfor i in range(N):\n  temp = gcd(L[N-i-1], R)\n  R = gcd(R, A[N-i-1])\n  if ans < temp:\n    ans = temp\n    \nprint(ans)\n", "import sys\ndef gcd(m, n):\n    if n == 0:\n        n, m = m, n\n    r = m % n\n    return gcd(n, r) if r else n\n\nn = int(input())\na = list(map(int, sys.stdin.readline().split()))\nl, r = [0]*(n+1), [0]*(n+1)\nfor i in range(1, n+1):\n    l[i] = gcd(l[i-1], a[i-1])\n    r[n-i] = gcd(r[n-i+1], a[n-i])\nans = 0\nfor i in range(n):\n    m = gcd(l[i], r[i+1])\n    if ans < m:\n        ans = m\nprint(ans)", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return list(map(int, input().split()))\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n    n = i_input()\n    a = i_list()\n\n    left = [0]\n    right = [0]\n\n    for i in range(n):\n        left.append(gcd(left[i], a[i]))\n        right.append(gcd(right[i], a[-(i+1)]))\n\n    ans = 0\n    for i in range(n):\n        ans = max(ans, gcd(left[i], right[n - i - 1]))\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "class SegmentTree: #1-indexed\n    def __init__(self,list,f=lambda x,y:x+y,inf=0):\n        self.height=(len(list)-1).bit_length()+1 #\u6728\u306e\u9ad8\u3055\n        self.zero=2**(self.height-1) #\u6700\u4e0b\u6bb5\u306b\u6dfb\u5b57\u3092\u5408\u308f\u305b\u308b\u7528\n        self.id=inf #\u5358\u4f4d\u5143\n        self.tree=[self.id]*(2**self.height) #\u6728\u3092\u5358\u4f4d\u5143\u3067\u521d\u671f\u5316\n        self.f=f\n        for i in range(len(list)):\n            self.tree[self.zero+i]=list[i]\n        for i in range(self.zero-1,0,-1):\n            self.tree[i]=self.f(self.tree[2*i],self.tree[2*i+1])\n        \n    def update(self,i,x): #i\u756a\u76ee\u306e\u8981\u7d20\u3092x\u306b\u5909\u66f4\n        i+=self.zero\n        self.tree[i]=x\n        while i>1:\n            i//=2\n            self.tree[i]=self.f(self.tree[2*i],self.tree[2*i+1])\n    \n    def query(self,l,r): #\u533a\u9593[l,r)\n        l+=self.zero\n        r+=self.zero\n        lf,rf=self.id,self.id\n        while l<r:\n            if l&1:\n                lf=self.f(lf,self.tree[l])\n                l+=1\n            if r&1:\n                r-=1\n                rf=self.f(self.tree[r],rf)\n            l//=2\n            r//=2\n        return self.f(lf,rf)\n\n    '''\n    FFFFTTTT\u3068\u3057\u305f\u3068\u304d\u306e\u6700\u5c0f\u306eT\u3092\u6c42\u3081\u308b\n    '''\n    def BinarySearch(self,l,r,f): #f\u306e\u8fd4\u308a\u5024\u306fbool\u306b\u3059\u308b\n        if not f(self.query(l,r)): #\u305d\u3082\u305d\u3082\u533a\u9593\u5185\u306bT\u304c\u306a\u3051\u308c\u3070\u53f3\u7aef\u3092return\n            return r\n        l+=self.zero\n        while True:\n            if f(self.tree[l]):\n                if l>=self.zero:\n                    return l-self.zero+1 #\u6700\u4e0b\u6bb5\u306a\u3089return\n                else:\n                    l*=2 #\u5de6\u306e\u5b50\u4f9b\u3092\u898b\u308b\n            else:\n                if l%2==0:\n                    l+=1 #\u5de6\u306e\u5b50\u306a\u3089\u53f3\u3092\u898b\u308b\n                else:\n                    l=(l//2)+1 #\u53f3\u306e\u5b50\u306a\u3089\u89aa\u306e\u53f3\u3092\u898b\u308b\n\nfrom math import gcd\nn=int(input())\na=list(map(int,input().split()))\nS=SegmentTree(a,gcd)\nans=0\nfor i in range(n):\n    S.update(i,0)\n    ans=max(ans,S.tree[1])\n    S.update(i,a[i])\nprint(ans)", "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\nLeft = [A[0]]\nfor i in range(N-1):\n    Left.append(gcd(Left[i], A[i+1]))\n\nRight = [A[N-1]]\nfor i in range(N-1):\n    Right.append(gcd(Right[i], A[N-2-i]))\nRight.reverse()\n\nans_list = []\nans_list.append(Right[1])\nfor i in range(1, N-1):\n    ans_list.append(gcd(Left[i-1], Right[i+1]))\nans_list.append(Left[N-2])\n\nprint(max(ans_list))", "import sys\nfrom math import gcd\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    if N == 2:\n        ans = max(A)\n        print(ans)\n        return\n\n    L_GCD = [0] * N\n    L_GCD[0] = A[0]\n    for i in range(N - 1):\n        L_GCD[i + 1] = gcd(L_GCD[i], A[i + 1])\n\n    R_GCD = [0] * N\n    R_GCD[-1] = A[-1]\n    for i in reversed(list(range(N - 1))):\n        R_GCD[i] = gcd(R_GCD[i + 1], A[i])\n\n    ans = 1\n    for i in range(N):\n        if i == 0:\n            ans = max(ans, R_GCD[1])\n        elif i == N - 1:\n            ans = max(ans, L_GCD[-2])\n        else:\n            res = gcd(L_GCD[i - 1], R_GCD[i + 1])\n            ans = max(ans, res)\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from math import gcd\nn = int(input())\na = [*map(int,input().split())]\n\nlgcd = [0]*(n+2)\nrgcd = [0]*(n+2)\n\nfor i in range(n):\n    lgcd[i+1] = gcd(lgcd[i],a[i])\n    rgcd[n-i] = gcd(rgcd[n-i+1],a[n-i-1])\nans = 0\nfor i in range(n+1):\n    ans = max(ans,gcd(lgcd[i-1],rgcd[i+1]))\nprint(ans)", "#!/usr/bin/env python3\nimport sys\nfrom math import gcd\n\ndef f(A):\n    ret = [0]\n    for a in A:\n        ret.append(gcd(ret[-1], a))\n    return ret\n\ndef solve(N: int, A: \"List[int]\"):    \n    return  max(gcd(g0, g1) for g0, g1 in zip(f(A), f(A[::-1])[-2::-1]))\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    print((solve(N, A)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "from math import gcd\nfrom itertools import accumulate\n\nn = int(input())\na = list(map(int, input().split()))\n\nl = list(accumulate(a, lambda x, y: gcd(x, y)))\nr = list(accumulate(a[::-1], lambda x, y: gcd(x, y)))[::-1]\nans = max(r[1], l[-2])\nfor i in range(1, n-1):\n    ans = max(ans, gcd(l[i-1], r[i+1]))\nprint(ans)", "def main():\n    import math\n    n = int(input())\n    a = sorted(list(map(int,input().split())))\n    if n==2:\n        print((a[1]))\n        return\n    ans = 0\n    g = math.gcd(a[0],a[1])\n    ans_list = []\n    for i in range(1,int(g**0.5)+1):\n        if g%i==0:\n            ans_list.append(i)\n    ans_list.append(g)\n    for an in ans_list:\n        cnt = 0\n        for i in range(n):\n            if a[i] % an != 0:\n                cnt += 1\n        if cnt < 2:\n            if an>ans:\n                ans = an\n    g = math.gcd(a[1],a[2])\n    ans_list = []\n    for i in range(1,int(g**0.5)+1):\n        if g%i==0:\n            ans_list.append(i)\n    ans_list.append(g)\n    for an in ans_list:\n        cnt = 0\n        for i in range(n):\n            if a[i] % an != 0:\n                cnt += 1\n        if cnt < 2:\n            if an>ans:\n                ans = an\n    g = math.gcd(a[0],a[2])\n    ans_list = []\n    for i in range(1,int(g**0.5)+1):\n        if g%i==0:\n            ans_list.append(i)\n    ans_list.append(g)\n    for an in ans_list:\n        cnt = 0\n        for i in range(n):\n            if a[i] % an != 0:\n                cnt += 1\n        if cnt < 2:\n            if an>ans:\n                ans = an\n    print(ans)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\na = list(map(int,input().split()))\n\ndef make_divisors(n):\n    lower_divisors , upper_divisors = [], []\n    i = 1\n    while i*i <= n:\n        if n % i == 0:\n            lower_divisors.append(i)\n            if i != n // i:\n                upper_divisors.append(n//i)\n        i += 1\n    return lower_divisors + upper_divisors[::-1]\n\n\nadiv = sorted(set(make_divisors(a[0]) + make_divisors(a[1])),reverse=True)\n\n\ndef is_ok(arg):\n    #print(f\"index{arg}\u3067\u30fc\u3059{adiv[arg]}\")\n    cnt = 0\n    for i in range(n):\n        if a[i]%adiv[arg] != 0:\n            cnt += 1\n            #print(str(a[i])+\"\u00d7\")\n\n        if cnt>=2:\n            #print(\"\u3060\u3081\"+str(a[i])+\" i\u306f\"+str(i))\n            return False\n            break    \n    else:\n        #print(\"ok-\")\n        return True\n\nimport sys\nfor i in range(len(adiv)):\n    if is_ok(i):\n        print(adiv[i])\n        return", "import math\n\nn=int(input())\n\na=list(map(int,input().split()))\n\nL=[0]\n\nfor i in range(n):\n  L.append(math.gcd(L[i],a[i]))\n\nR=[0]\nfor i in range(n):\n  R.append(math.gcd(R[i],a[n-1-i]))\n\nans=1\nfor i in range(n):\n  ans=max(ans,math.gcd(L[i],R[n-1-i]))\n\nprint(ans)\n", "# coding: UTF-8\nimport sys\nimport numpy as np\nimport math\n\n\nn = int(input())\naList = list(map(int, input().split()))\ngcdListLeft = [0 for i in range(n)]\ngcdListRight = [0 for i in range(n)]\n\ntmp = aList[0]\nfor i in range(n):\n\ttmp = gcdListLeft[i] = math.gcd(tmp, aList[i])\n\ntmp = aList[n-1]\nfor i in range(n-1, -1, -1):\n\ttmp = gcdListRight[i] = math.gcd(tmp,aList[i])\n\nans = gcdListRight[1]\nfor i in range(1,n-1):\n\tans = max(ans, math.gcd(gcdListLeft[i-1], gcdListRight[i+1]))\nans = max(ans, gcdListLeft[n-2])\nprint(ans)", "from typing import Callable, List, Union\n\nT = Union[int, str]\n\n\nclass SegmentTree:\n    \"\"\"Segment Tree\"\"\"\n\n    __slots__ = [\"e\", \"op\", \"_n\", \"_size\", \"tree\"]\n\n    def __init__(self, a: List[T], e: T, op: Callable[[T, T], T]) -> None:\n        self.e = e\n        self.op = op\n        self._n = len(a)\n        self._size = 1 << (self._n - 1).bit_length()\n\n        self.tree = [e] * self._size + a + [e] * (self._size - self._n)\n        for i in range(self._size - 1, 0, -1):\n            self._update(i)\n\n    def _update(self, k: int) -> None:\n        \"\"\"Update the value of a[k].\"\"\"\n        self.tree[k] = self.op(self.tree[2 * k], self.tree[2 * k + 1])\n\n    def set(self, k: int, x: T) -> None:\n        \"\"\"Assign x to a[k] in O(log n).\"\"\"\n        assert 0 <= k < self._n\n\n        k += self._size\n        self.tree[k] = x\n        while k:\n            k >>= 1\n            self._update(k)\n\n    def get(self, k: int) -> T:\n        \"\"\"Return a[k] in O(1).\"\"\"\n        assert 0 <= k < self._n\n        return self.tree[k + self._size]\n\n    def prod(self, l: int, r: int) -> T:\n        \"\"\"Return op(a[l], ..., a[r - 1]). Return e, if l == r.\n        Complexity: O(log n)\n        \"\"\"\n        assert 0 <= l <= r <= self._n\n\n        sml, smr = self.e, self.e\n        l += self._size\n        r += self._size\n\n        while l < r:\n            if l & 1:\n                sml = self.op(sml, self.tree[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                smr = self.op(self.tree[r], smr)\n            l >>= 1\n            r >>= 1\n        return self.op(sml, smr)\n\n    def prod_all(self) -> T:\n        \"\"\"Return op(a[0], ..., a[n - 1]. Return e if n == 0.\n        Complexity: O(1)\n        \"\"\"\n        return self.tree[1]\n\n    def max_right(self, l: int, f: Callable[[T], bool]) -> int:\n        \"\"\"\n        Return an index r satisfying both:\n            1. r = l or f(op(a[l], a[l + 1], ..., a[r - 1])) = true\n            2. r = n or f(op(a[l], a[l + 1], ..., a[r])) = false.\n\n        If f is monotone, this is the maximum r satisfying:\n            f(op(a[l], a[l + 1], ..., a[r - 1])) = true.\n\n        Complexity: O(log n)\n        \"\"\"\n        assert 0 <= l <= self._n\n        assert f(self.e)\n\n        if l == self._n:\n            return self._n\n\n        l += self._size\n        sm = self.e\n\n        while True:\n            while not l & 1:\n                l >>= 1\n\n            if not f(self.op(sm, self.tree[l])):\n                while l < self._size:\n                    l *= 2\n                    if f(self.op(sm, self.tree[l])):\n                        sm = self.op(sm, self.tree[l])\n                        l += 1\n                return l - self._size\n\n            sm = self.op(sm, self.tree[l])\n            l += 1\n\n            if (l & -l) == l:\n                break\n\n        return self._n\n\n    def min_left(self, r: int, f: Callable[[T], bool]) -> int:\n        \"\"\"\n        Return an index l satisfying both:\n            1. l = r or f(op(a[l], a[l + 1], ..., a[r - 1])) = true\n            2. l = 0 or f(op(a[l - 1], a[l + 1], ..., a[r - 1])) = false.\n        If f is monotone, this is the minimum l satisfying:\n            f(op(a[l], a[l + 1], ..., a[r - 1])) = true.\n\n        Complexity: O(log n)\n        \"\"\"\n        assert 0 <= r <= self._n\n        assert f(self.e)\n\n        if not r:\n            return 0\n\n        r += self._size\n        sm = self.e\n\n        while True:\n            r -= 1\n            while r > 1 and r % 2:\n                r >>= 1\n\n            if not f(self.op(self.tree[r], sm)):\n                while r < self._size:\n                    r = 2 * r + 1\n                    if f(self.op(self.tree[r], sm)):\n                        sm = self.op(self.tree[r], sm)\n                        r -= 1\n                return r + 1 - self._size\n\n            if (r & -r) == r:\n                break\n\n        return 0\n\n\ndef practice2_j():\n    # https://atcoder.jp/contests/practice2/tasks/practice2_j\n    N, _, *AQ = list(map(int, open(0).read().split()))\n    A, Q = AQ[:N], AQ[N:]\n    tree = SegmentTree(A, -1, max)\n    res = []\n    for t, x, y in zip(*[iter(Q)] * 3):\n        if t == 1:\n            tree.set(x - 1, y)\n        elif t == 2:\n            res.append(tree.prod(x - 1, y))\n        else:\n            res.append(tree.max_right(x - 1, lambda n: n < y) + 1)\n    print((\"\\n\".join(map(str, res))))\n\n\ndef staticrmq():\n    # https://judge.yosupo.jp/problem/staticrmq\n    N, Q, *ALR = list(map(int, open(0).read().split()))\n    A, LR = ALR[:N], ALR[N:]\n    tree = SegmentTree(A, (10 ** 10) + 1, min)\n    res = [tree.prod(l, r) for l, r in zip(*[iter(LR)] * 2)]\n    print((\"\\n\".join(map(str, res))))\n\n\ndef dsl_2_a():\n    # https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_A\n    N, Q, *X = list(map(int, open(0).read().split()))\n    tree = SegmentTree([2 ** 31 - 1] * N, 2 ** 31 - 1, min)\n    res = []\n    for com, x, y in zip(*[iter(X)] * 3):\n        if com:\n            res.append(tree.prod(x, y + 1))\n        else:\n            tree.set(x, y)\n    print((\"\\n\".join(map(str, res))))\n\n\ndef abc125_c():\n    # https://atcoder.jp/contests/abc125/tasks/abc125_c\n    from math import gcd\n\n    N, *A = list(map(int, open(0).read().split()))\n    tree = SegmentTree(A, 0, gcd)\n    res = max(gcd(tree.prod(0, i), tree.prod(i + 1, N)) for i in range(N))\n    print(res)\n\n\ndef __starting_point():\n    # practice2_j()\n    # staticrmq()\n    # dsl_2_a()\n    abc125_c()\n\n__starting_point()", "from math import gcd\n\nN = int(input())\nA = list(map(int, input().split()))\n\nA = [0] + A + [0]\n\n#Left side\nL = [A[1]]\ntempL = A[1]\nfor i in range(1, N):\n    tempL = gcd(tempL, A[i+1])\n    L.append(tempL)\nL = [0] + L\n    \n#Right side\nR = [A[-2]]\ntempR = A[-2]\nfor i in range(1, N):\n    tempR = gcd(tempR, A[-i-2])\n    R.append(tempR)\nR = list(reversed(R)) + [0]\n\nans = []\nfor i in range(N):\n    result = gcd(L[i], R[i+1])\n    ans.append(result)\n\nprint((max(ans)))\n", "from math import gcd\nn = int(input())\na = list(map(int,input().split()))\nl = 0\nr = 0\nx = [0] * (n+1)\ny = [0] * (n+1)\nfor i in range(n):\n    x[i+1] = gcd(x[i],a[i])\nfor i in range(n)[::-1]:\n    y[i] = gcd(y[i+1],a[i])\nm = []\nfor i in range(n):\n    m.append(gcd(x[i],y[i+1]))\nprint(max(m))", "N=int(input())\nA=list(map(int,input().split()))\nA=[0]+A\nimport math\n\nL=[0 for i in range(N+2)]\nR=[0 for i in range(N+2)]\nfor i in range(0,N+1):\n  L[i+1]=math.gcd(L[i],A[i])\nfor i in range(N,-1,-1):\n  R[i]=math.gcd(R[i+1],A[i])\n\nM=[0 for i in range(N+1)]\nfor i in range(1,N+1):\n  M[i]=math.gcd(L[i],R[i+1])\nprint(max(M))", "from math import*\nN=int(input())\n*A,=map(int,input().split())\nL=[0]\nl=A[0]\nfor a in A:\n    l=gcd(l,a)\n    L.append(l)\nR=[0]\nr=A[-1]\nfor a in A[::-1]:\n    r=gcd(a,r)\n    R.append(r)\nR=R[::-1]\nM=[]\nfor i in range(N):\n    M.append(gcd(L[i],R[i+1]))\nprint(max(M))", "N = int(input())\nA = list(map(int, input().split()))\n\nimport math\nL = [0] * (N + 1)\nR = [0] * (N + 1)\n\nfor i in range(N):\n    L[i + 1] = math.gcd(L[i], A[i])\n    R[N - i - 1] = math.gcd(R[N - i], A[N - i - 1])\n\nans = 0\nfor i in range(N):\n    ans = max(ans, math.gcd(L[i], R[i+1]))\n\nprint(ans)", "import math\nfrom itertools import accumulate\n\nn = int(input())\na = list(map(int, input().split()))\n\nfromleft = list(accumulate(a, math.gcd))\na.reverse()\nfromright = list(accumulate(a, math.gcd))\nfromright.reverse()\na.reverse()\n\ngcd = []\n\ngcd.append(fromright[1])\nfor i in range(1, n-1):\n    gcd.append(math.gcd(fromleft[i-1], fromright[i+1]))\n\ngcd.append(fromleft[n-2])\n\nif n == 2:\n    print((max(a[1], a[0])))\nelse:\n    print((max(gcd)))\n", "from math import gcd\n\nclass SegTree():\n    def segfunc(self, x, y):\n        return gcd(x, y)\n\n    def __init__(self, ide, init_val):\n        n = len(init_val)\n        self.ide_ele = ide\n        self.num = 2**(n-1).bit_length()\n        self.seg = [self.ide_ele] * 2 * self.num\n        for i in range(n):\n            self.seg[i+self.num-1] = init_val[i]    \n        for i in range(self.num-2,-1,-1):\n            self.seg[i] = self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n    def update(self, idx, val):\n        idx += self.num-1\n        self.seg[idx] = val\n        while idx:\n            idx = (idx-1)//2\n            self.seg[idx] = self.segfunc(self.seg[idx*2+1], self.seg[idx*2+2])\n    def query(self, begin, end):\n        if end <= begin:\n            return self.ide_ele\n        begin += self.num-1\n        end += self.num-2\n        res = self.ide_ele\n        while begin + 1 < end:\n            if begin&1 == 0:\n                res = self.segfunc(res, self.seg[begin])\n            if end&1 == 1:\n                res = self.segfunc(res, self.seg[end])\n                end -= 1\n            begin = begin//2\n            end = (end-1)//2\n        if begin == end:\n            res = self.segfunc(res, self.seg[begin])\n        else:\n            res = self.segfunc(self.segfunc(res, self.seg[begin]), self.seg[end])\n        return res\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    seg = SegTree(0, a)\n    ans = 1\n    for i in range(n):\n        ans = max(ans, gcd(seg.query(0, i), seg.query(i+1, n)))\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "n=int(input())\nA=list(map(int,input().split()))\n\ndef gcd(a,b):\n    if b==0: return a\n    else:\n        return gcd(b,a%b)\ndef lcm(a,b):\n    return a*b//gcd(a,b)\n\nl=[A[0]]* n\nr=[A[-1]]*n\nfor i in range(n-1):\n    l[i+1]=gcd(l[i], A[i+1])\n    r[-i-2]= gcd(r[-i-1], A[-i-2])\n\nans=0\nfor i in range(n):\n    if i==0:\n        ans=max(ans, r[1]);continue\n    if i==n-1:\n        ans=max(ans, l[-2]);continue\n    ans=max(ans, gcd(l[i-1], r[i+1]))\nprint(ans)", "from math import *\n\nn = int(input())\na = list(map(int, input().split()))\n\nl = [a[0]]\nfor i in range(1, n-1):\n  l.append(gcd(a[i], l[i-1]))\n\nans = l[n-2]\nr = a[n-1]\nfor i in range(n-2,0,-1):\n  r = gcd(r, a[i+1])\n  ans = max(ans, gcd(l[i-1], r))\nans = max(ans, gcd(r,a[1]))\nprint(ans)", "import math\n\nn = int(input())\na = list(map(int,input().split()))\n\nlefGcd = [0]*100100\nrigGcd = [0]*100100\n\nlefGcd[0] = a[0]\nrigGcd[n-1] = a[n-1]\n\nfor i in range(1,n):\n\tlefGcd[i] = math.gcd(lefGcd[i-1],a[i])\n\nfor i in reversed(list(range(0,n-1))):\n\trigGcd[i] = math.gcd(rigGcd[i+1],a[i])\n\nans = max(rigGcd[1],lefGcd[n-2])\n\nfor i in range(1,n-1):\n\tans = max(ans,math.gcd(lefGcd[i-1],rigGcd[i+1]))\n\nprint(ans)\n", "from math import gcd\nn=int(input())\na=list(map(int,input().split()))\nl=[0 for i in range(n)]\nr=[0 for i in range(n)]\nl[0]=a[0]\nr[0]=a[-1]\nfor i in range(n-1):\n    l[i+1]=gcd(l[i],a[i+1])\nfor i in range(n-1):\n    r[i+1]=gcd(r[i],a[-2-i])\n\nans=[0 for i in range(n)]\n\nfor i in range(1,n-1):\n    ans[i]=gcd(l[i-1],r[-i+n-2])\nans[0]=r[n-2]\nans[n-1]=l[n-2]\n\nprint((max(ans)))\n\n    \n\n", "from math import gcd\n\nN = int(input())\nA = list(map(int, input().split()))\n\n# L = [0, A_1\u306egcd, A_1~A_2\u306egcd, A_1~A_3\u306egcd, ..., A_1~A_N\u306egcd]\u3001len = N+1\nL = [0]\nfor i in range(N):\n    L.append(gcd(L[-1], A[i]))\n\n\n# R = [A_1~A_N\u306egcd, A_2~A_N\u306egcd, ..., A_N-1~A_N\u306egcd, A_N\u306egcd, 0], len = N+1\nR = [0]\nfor i in range(N):\n    R.append(gcd(R[-1], A[-i - 1]))\nR = R[::-1]\n\nans_list = []\n# A_1\u3092\u6d88\u3059\u5834\u5408, A_2\u3092\u6d88\u3059\u5834\u5408, ..., A_N\u3092\u6d88\u3059\u5834\u5408\nfor i in range(N):\n    ans_list.append(gcd(L[i], R[i + 1]))\n\nprint((max(ans_list)))\n", "import math\n\nN = int(input())\nA = [int(i) for i in input().split()]\n\nleft = [0] * (N+1)\nfor i in range(1, N+1):\n    left[i] = math.gcd(left[i-1], A[i-1])\n    \nright = [0] * (N+1)\nright[N-1] = A[N-1]\nfor i in range(N-2, -1, -1):\n    right[i] = math.gcd(right[i+1], A[i])\n    \noutput = 0\nfor i in range(N):\n    output = max(output, math.gcd(left[i], right[i+1]))\n    \nprint(output)", "from math import*\nN=int(input())\n*A,=map(int,input().split())\nR=[0]\nr=A[-1]\nfor a in A[::-1]:\n    r=gcd(a,r)\n    R.append(r)\nR=R[::-1]\nM=[]\nL=0\nfor i in range(N):\n    M.append(gcd(L,R[i+1]))\n    L=gcd(L,A[i])\nprint(max(M))", "from math import gcd\n\nn = int(input())\na = list(map(int, input().split()))\nl = [a[-1], a[0]]\nr = [a[-1]]\nfor x in a[1:-1]:\n    l.append(gcd(l[-1], x))\nfor x in a[-2:0:-1]:\n    r.append(gcd(r[-1], x))\nr = r[::-1]\nr.append(a[0])\nprint(max(gcd(l[i], r[i]) for i in range(n)))", "from math import gcd\nn = int(input())\na = list(map(int,input().split()))\nl,r = [a[0]]*n,[a[n-1]]*n\nfor i in range(1,n-1):\n  l[i] = gcd(l[i-1],a[i])\n  r[n-i-1] = gcd(r[n-i],a[n-i-1])\nans = [0]*n\nans[0] = r[1]\nans[n-1] = l[n-2]\nfor i in range(1,n-1):\n  ans[i] = gcd(l[i-1],r[i+1])\nprint(max(ans))", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N = I()\n    A = LI()\n\n    # [0, i)\u306e\u7d2f\u7a4dGCD\n    gcd_cum_l = [0] * (N + 1)\n    for i in range(N):\n        gcd_cum_l[i+1] = math.gcd(A[i], gcd_cum_l[i])\n    # [i, N)\u306e\u7d2f\u7a4dGCD\n    gcd_cum_r = [0] * (N + 1)\n    for i in range(N - 1, -1, -1):\n        gcd_cum_r[i] = math.gcd(A[i], gcd_cum_r[i+1])\n    # print(gcd_cum_l)\n    # print(gcd_cum_r)\n\n    ans = 0\n    for i in range(N):\n        ans = max(math.gcd(gcd_cum_l[i], gcd_cum_r[i+1]), ans)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from math import gcd as g\n#####segfunc#####\ndef segfunc(x, y):\n    return g(x,y)\n#################\n\n#####ide_ele#####\nide_ele =0\n#################\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): \u914d\u5217init_val\u3067\u521d\u671f\u5316 O(N)\n    update(k, x): k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0 O(logN)\n    query(l, r): \u533a\u9593[l, r)\u3092segfunc\u3057\u305f\u3082\u306e\u3092\u8fd4\u3059 O(logN)\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: \u914d\u5217\u306e\u521d\u671f\u5024\n        segfunc: \u533a\u9593\u306b\u3057\u305f\u3044\u64cd\u4f5c\n        ide_ele: \u5358\u4f4d\u5143\n        n: \u8981\u7d20\u6570\n        num: n\u4ee5\u4e0a\u306e\u6700\u5c0f\u306e2\u306e\u3079\u304d\u4e57\n        tree: \u30bb\u30b0\u30e1\u30f3\u30c8\u6728(1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # \u914d\u5217\u306e\u5024\u3092\u8449\u306b\u30bb\u30c3\u30c8\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # \u69cb\u7bc9\u3057\u3066\u3044\u304f\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        \"\"\"\n        k\u756a\u76ee\u306e\u5024\u3092x\u306b\u66f4\u65b0\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)\u306esegfunc\u3057\u305f\u3082\u306e\u3092\u5f97\u308b\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\nn=int(input())\na=list(map(int,input().split()))\nseg=SegTree(a,segfunc,ide_ele)\nans=1\nfor i in range(n):\n    p=seg.query(0,i)\n    q=seg.query(i+1,n)\n    ans=max(ans,g(p,q))\nprint(ans)\n\n\n\n\n\n\n", "# author:  Taichicchi\n# created: 11.10.2020 00:03:10\n\nimport sys\nfrom math import gcd\nN = int(input())\nA = list(map(int, input().split()))\n\nL = [0]\nR = [0]\n\nfor i in range(N):\n    L.append(gcd(L[-1], A[i]))\n\nfor i in range(N)[::-1]:\n    R.append(gcd(R[-1], A[i]))\n\nR.reverse()\n\nM = 0\n\nfor i in range(N):\n    M = max(M, gcd(L[i], R[i + 1]))\n\nprint(M)\n", "ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"YES\") if fl else print(\"NO\")\nimport collections\nimport math\nimport itertools\nimport heapq as hq\ngcd = math.gcd\nn = ni()\nA = lma()\ngcd_l = [1]*n\ngcd_l[0]=A[0]\ngcd_r =[1]*n\ngcd_r[-1] = A[-1]\nfor i in range(1,n):\n    gcd_l[i] = gcd(A[i],gcd_l[i-1])\n    gcd_r[-i-1] = gcd(A[-i-1],gcd_r[-i])\nans = max(gcd_l[-2],gcd_r[1])\nfor i in range(1,n-1):\n    ggg = gcd(gcd_l[i-1],gcd_r[i+1])\n    ans = max(ans,ggg)\nprint(ans)\n"]