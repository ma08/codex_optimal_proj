2022-04-22 11:17:47.608222 num operations 1
2022-04-22 11:17:47.608240 size on input set 1
2022-04-22 11:17:47.608402 using api key jaanu
2022-04-22 11:18:02.200764 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][(1 << n) - 1])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\ninput = sys.stdin.readline()\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570(i + 1\u500b\u4ee5\u4e0a)\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    b, a = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\ninput = sys.stdin.readline()\nprint(input)\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * (n + 1)\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1 << 1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\nans = 0\nfor i in range(N):\n    ans += B[A[i] - 1]\n    if i > 0 and A[i] - A[i - 1] == 1:\n        ans += C[A[i - 1] - 1]\nprint(ans)\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1].append(b - 1)\n    edges[b - 1].append(a - 1)\n\n# DP[i][j] = i\u756a\u76ee\u307e\u3067\u306e\u9802\u70b9\u3092\u4f7f\u3063\u3066\u3001j\u3092\u542b\u3080\u5834\u5408\u306e\u30d1\u30bf\u30fc\u30f3\u6570\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n"
    }
  ],
  "created": 1650626267,
  "object": "edit"
}
2022-04-22 11:18:02.201144 fix syntax errors 8 ['\n\nimport sys\n\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (1 << n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(1 << n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][(1 << n) - 1])\n', '\nimport sys\ninput = sys.stdin.readline()\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数(i + 1個以上)\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', '\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', '\n\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * n\nfor _ in range(m):\n    b, a = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', '\nimport sys\ninput = sys.stdin.readline()\nprint(input)\n', '\n\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [0] * (n + 1)\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1] += 1\n    edges[b - 1] += 1\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1 << 1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n', '\nimport sys\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\nans = 0\nfor i in range(N):\n    ans += B[A[i] - 1]\n    if i > 0 and A[i] - A[i - 1] == 1:\n        ans += C[A[i - 1] - 1]\nprint(ans)\n', '\n\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a - 1].append(b - 1)\n    edges[b - 1].append(a - 1)\n\n# DP[i][j] = i番目までの頂点を使って、jを含む場合のパターン数\ndp = [[0] * (2 ** n) for _ in range(n)]\ndp[0][1] = 1\nfor i in range(n - 1):\n    for j in range(2 ** n):\n        if dp[i][j] == 0:\n            continue\n        for k in range(1, n + 1):\n            if j & (1 << k) != 0 or edges[k - 1] == 0:\n                continue\n            dp[i + 1][j | (1 << k)] += dp[i][j]\nprint(dp[n - 1][2 ** n - 1])\n']
2022-04-22 11:18:02.201379 size on output set 8
2022-04-22 11:18:02.201404 num operations 1
2022-04-22 11:18:02.201414 size on input set 1
2022-04-22 11:18:02.201629 using api key sunu
2022-04-22 11:18:23.080599 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\nN = int(input())\n\nans = 0\n\nfor i in range(1, N+1):\n    for j in range(1, N+1):\n        for k in range(1, N+1):\n            ans += gcd(gcd(i, j),k)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport math\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\ndef check(x):\n    for i in range(N):\n        if i == N-1:\n            if A[i] == x:\n                return True\n            else:\n                return False\n        if A[i] >= x:\n            continue\n        if A[i] + K < x:\n            return False\n        if A[i+1] - K > x:\n            return False\n    return True\n\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n\ndef dfs(v, visited, parent):\n    visited[v] = True\n    for child in tree[v]: # v\u304b\u3089\u884c\u3051\u308b\u9802\u70b9\n        if not visited[child]:\n            dfs(child, visited, v)\n        elif child != parent: # \u89aa\u304b\u3089\u3082\u884c\u3051\u308b\u9802\u70b9\u3067\u306a\u3051\u308c\u3070\u3001\u305d\u308c\u306f\u5225\u306e\u30eb\u30fc\u30d7\n            print(0)\n            sys.exit()\n\nvisited = [False for _ in range(N)]\ndfs(0, visited, -1)\n\nans = 1\nfor i in range(1, N):\n    ans *= len(tree[i])\n    if ans > 10**9 + 7:\n        ans %= 10**9 + 7\n\nif not all(visited):\n    print(0)\n    sys.exit()\n\nprint(ans)\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n        ans %= 10**9+7\n\nprint(ans%(10**9+7))\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\nsys.setrecursionlimit(10 ** 6)\nN, M = map(int, input().split())\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a - 1].append(b - 1)\n    tree[b - 1].append(a - 1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n"
    }
  ],
  "created": 1650626282,
  "object": "edit"
}
2022-04-22 11:18:23.080974 fix syntax errors 8 ['\n\nimport sys\n\nN = int(input())\n\nans = 0\n\nfor i in range(1, N+1):\n    for j in range(1, N+1):\n        for k in range(1, N+1):\n            ans += gcd(gcd(i, j),k)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n', '\n\nimport math\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\ndef check(x):\n    for i in range(N):\n        if i == N-1:\n            if A[i] == x:\n                return True\n            else:\n                return False\n        if A[i] >= x:\n            continue\n        if A[i] + K < x:\n            return False\n        if A[i+1] - K > x:\n            return False\n    return True\n\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n', '\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n', '\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n\ndef dfs(v, visited, parent):\n    visited[v] = True\n    for child in tree[v]: # vから行ける頂点\n        if not visited[child]:\n            dfs(child, visited, v)\n        elif child != parent: # 親からも行ける頂点でなければ、それは別のループ\n            print(0)\n            sys.exit()\n\nvisited = [False for _ in range(N)]\ndfs(0, visited, -1)\n\nans = 1\nfor i in range(1, N):\n    ans *= len(tree[i])\n    if ans > 10**9 + 7:\n        ans %= 10**9 + 7\n\nif not all(visited):\n    print(0)\n    sys.exit()\n\nprint(ans)\n', '\n\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n', '\n\nimport sys\nsys.setrecursionlimit(10**6)\n\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n        ans %= 10**9+7\n\nprint(ans%(10**9+7))\n', '\nimport sys\nsys.setrecursionlimit(10 ** 6)\nN, M = map(int, input().split())\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a - 1].append(b - 1)\n    tree[b - 1].append(a - 1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n', '\nimport sys\nsys.setrecursionlimit(10**6)\nN, M = map(int, input().split())\n\ntree = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    tree[a-1].append(b-1)\n    tree[b-1].append(a-1)\n\ndef dfs(v, visited):\n    visited.add(v)\n    for child in tree[v]:\n        if child not in visited:\n            dfs(child, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) != N:\n    print(0)\n    sys.exit()\n\nans = 1\nfor i in range(N):\n    if i == 0:\n        continue\n    if len(tree[i]) > 1:\n        ans *= len(tree[i])\n\nprint(ans)\n']
2022-04-22 11:18:23.081167 size on output set 8
