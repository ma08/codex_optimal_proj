["import sys\nimport heapq, math\nfrom itertools import zip_longest, permutations, combinations, combinations_with_replacement\nfrom itertools import accumulate, dropwhile, takewhile, groupby\nfrom functools import lru_cache\nfrom copy import deepcopy\n\n\n\n\n\nsys.setrecursionlimit(1000000)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\nimport sys\n\nn = int(input())\na = [int(i) for i in sys.stdin.readline().split()]\n\na.sort()\n\ncount = 1\nfor i in range(1,n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n", "\n\nn = int(input())\na = list(map(int, input().split()))\n\n# 1. Find the minimum value of all coins\n# 2. Find the maximum value of all coins\n# 3. If the difference between the minimum and the maximum value is less than the number of coins,\n#    then the minimum number of pockets is 2.\n# 4. Otherwise, the minimum number of pockets is 1.\n\nmin_a = min(a)\nmax_a = max(a)\n\nif max_a - min_a < n:\n    print(2)\nelse:\n    print(1)\n", "\n\n# n = int(input())\n# a = list(map(int, input().split()))\nn = 6\na = [1, 2, 4, 3, 3, 2]\n\n# 1. Find the minimum value of all coins\n# 2. If the difference between the minimum and the maximum value is less than the number of coins,\n#    then the minimum number of pockets is 1.\n# 3. Otherwise, the minimum number of pockets is 2.\n\nmin_a = min(a)\n\nif max(a) - min_a < n:\n    print(1)\nelse:\n    print(2)\n", "\n\n# 1. Find the minimum value of all coins\n# 2. Find the maximum value of all coins\n# 3. If the difference between the minimum and the maximum value is less than the number of coins,\n#    then the minimum number of pockets is 2.\n\nn = int(input())\na = list(map(int, input().split()))\n# 4. Otherwise, the minimum number of pockets is 1.\n\nmin_a = min(a)\nmax_a = max(a)\n\nif max_a - min_a < n:\n    print(2)\nelse:\n    print(1)\n", "\n\nn = int(input())\na = list(map(int, input().split()))\n# n = 6\n# a = [1, 2, 4, 3, 3, 2]\n\n# 1. Find the minimum value of all coins\n# 2. Find the maximum value of all coins\n# 3. If the difference between the minimum and the maximum value is less than the number of coins,\n#    then the minimum number of pockets is 2.\n# 4. Otherwise, the minimum number of pockets is 1.\n\nmin_a = min(a)\nmax_a = max(a)\n\nif max_a - min_a < n:\n    print(2)\nelse:\n    print(1)\n", "\n<<<<<<< HEAD\n\nn = int(input())\na = [int(i) for i in input().split()]\n\na.sort()\n\ncount = 1\nfor i in range(1,n):\n    if a[i] != a[i-1]:\n        count += 1\n\n=======\nprint(\"hello World\")\n>>>>>>> 0a4c7f2e15aab7b6d8edf38b7db8b8894ecf7a41\nprint(count)\n", "\nn = int(input())\na = [int(i) for i in input().split()]\na.sort()\n\ncount = 1\nfor i in range(1,n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n", "\n\nn = int(input())\na = [int(i) for i in input().split()]\n\na.sort()\n\ncount = 1\nfor i in range(1,n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count) \n", "\n\n\nl = int(input())\nx = [int(i) for i in input().split()]\n\nfor i in range(l):\n    if x[i] == 1:\n        print(\"HARD\")\n        exit()\n\nprint(\"EASY\")\n", "\nn = int(input())\na = [int(i) for i in input().split()]\n\na.sort()\n\ncount = 1\nfor i in range(1,n):\n    if a[i] != a[i-1]:\n        count += 1\n\nprint(count)\n", "\n\n# n = int(input())\n# a = list(map(int, input().split()))\nn = 6\na = [1, 2, 4, 3, 3, 2]\n\n# 1. Find the minimum value of all coins\n# 2. Find the maximum value of all coins\n# 3. If the difference between the minimum and the maximum value is less than the number of coins,\n#    then the minimum number of pockets is 2.\n# 4. Otherwise, the minimum number of pockets is 1.\nmin_a = min(a)\nmax_a = max(a)\n\nif max_a - min_a < n:\n    print(2)\nelse:\n    print(1)\n"]