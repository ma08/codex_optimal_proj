["\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print(solve(s))\n", "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique_size\n        if len(p) == 0 and len(x) == 0:\n            max_clique_size = max(max_clique_size, len(r))\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\n\nfrom collections import defaultdict\nfrom sys import stdin, stdout\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(sum(graph[c] for c in max_clique, []))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\n\nfrom collections import defaultdict\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s[:i+1])) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print('YES')\n    print('0' * n)\nelse:\n    print('YES')\n    print(solve(s))\n", "\nimport sys\n\nn = int(sys.stdin.readline())\ns = sys.stdin.readline().strip()\n\ndef solve(s):\n    last = 'a'\n    out = []\n    for c in s:\n        if c < last:\n            out.append('1')\n        else:\n            out.append('0')\n            last = c\n    return ''.join(out)\n\nif s == sorted(s):\n    print 'YES'\n    print '0' * n\nelse:\n    print 'YES'\n    print solve(s)\n", "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set, Iterable, Iterator\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable((graph[c] for c in max_clique)))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print ('YES')\n    print ('0' * n)\nelse:\n    print ('YES')\n    print (solve(s))\n", "\n\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    res = []\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            res.append('1')\n        else:\n            res.append('0')\n            last = s[i]\n    return ''.join(res)\n\nif s == sorted(s):\n    print 'YES'\n    print '0' * n\nelse:\n    print 'YES'\n    print solve(s)\n", "\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\n\n\ndef max_clique_size(s):\n    \"\"\"\n    maximum clique size in a graph of letters, where the letters are the nodes of the graph\n    and there is an edge between two nodes if the letters are adjacent in the given string\n    \"\"\"\n    from collections import defaultdict\n    from itertools import chain\n\n    def get_graph(s):\n        graph = defaultdict(list)\n        for i, c in enumerate(s):\n            graph[c].append(i)\n        return graph\n\n    def get_max_clique(graph):\n        # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n        def bron_kerbosch(r, p, x):\n            nonlocal max_clique\n            if len(p) == 0 and len(x) == 0:\n                max_clique = max(max_clique, r, key=len)\n                return\n            for v in list(p):\n                bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n                p.remove(v)\n                x.add(v)\n\n        max_clique = set()\n        bron_kerbosch(set(), set(graph.keys()), set())\n        return max_clique\n\n    def get_max_clique_size(graph):\n        return len(get_max_clique(graph))\n\n    def get_max_clique_indices(graph):\n        max_clique = get_max_clique(graph)\n        return set(chain.from_iterable(graph[c] for c in max_clique))\n\n    return get_max_clique_size(get_graph(s))\n", "\nimport sys\n\nn = int(sys.stdin.readline())\ns = list(sys.stdin.readline().strip())\n\ndef solve(s):\n    last = 'a'\n    for i in range(len(s)):\n        if s[i] < last:\n            s[i] = '1'\n        else:\n            s[i] = '0'\n            last = s[i]\n    return ''.join(s)\n\nif s == sorted(s):\n    print 'YES'\n    print '0' * n\nelse:\n    print 'YES'\n    print solve(s)\n", "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return list(max_clique)\n\ndef get_max_clique_size(graph):\n    return len(list(get_max_clique(graph)))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    print(\"YES\")\n    print(''.join(colors))\nelse:\n    print(\"NO\")\n", "\n\nfrom collections import defaultdict\nfrom typing import List, Dict, Tuple, Set\nfrom sys import stdin, stdout\nfrom itertools import chain\n\nn = int(stdin.readline())\ns = stdin.readline()\n\nassert 1 <= n <= 200\nassert len(s) == n\nassert all(c.islower() for c in s)\n\ndef get_graph(s):\n    graph = defaultdict(list)\n    for i, c in enumerate(s):\n        graph[c].append(i)\n    return graph\n\ndef get_max_clique(graph):\n    # https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm\n    def bron_kerbosch(r, p, x):\n        nonlocal max_clique\n        if len(p) == 0 and len(x) == 0:\n            max_clique = max(max_clique, r, key=len)\n            return\n        for v in list(p):\n            bron_kerbosch(r | {v}, p & graph[v], x & graph[v])\n            p.remove(v)\n            x.add(v)\n\n    max_clique = set()\n    bron_kerbosch(set(), set(graph.keys()), set())\n    return max_clique\n\ndef get_max_clique_size(graph):\n    return len(get_max_clique(graph))\n\ndef get_max_clique_indices(graph):\n    max_clique = get_max_clique(graph)\n    return set(chain.from_iterable(graph[c] for c in max_clique))\n\ndef get_colors(s):\n    colors = []\n    for i, c in enumerate(s):\n        colors.append('0' if i in get_max_clique_indices(get_graph(s)) else '1')\n    return colors\n\ndef is_sorted(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n\ndef is_sorted_after_swap(s):\n    return is_sorted(s) or is_sorted(s[::-1])\n\ncolors = get_colors(s)\n\nif is_sorted_after_swap(s):\n    stdout.write(\"YES\\n\")\n    stdout.write(''.join(colors) + '\\n')\nelse:\n    stdout.write(\"NO\\n\")\n"]