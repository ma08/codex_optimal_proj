["#\n# import heapq\n#\n# # Input\n# N, M = map(int, input().split())\n# A = list(map(int, input().split()))\n#\n# # Sort A in ascending order\n# A.sort()\n#\n# # If N is smaller than A[-1], Takahashi cannot finish all of the assignments\n# if N < A[-1]:\n#     print(-1)\n#     exit()\n#\n# # Initialize a heap\n# h = []\n#\n# # Put the last element of A into the heap\n# heapq.heappush(h, -A[-1])\n#\n# # Put the second-last element of A into the heap\n# heapq.heappush(h, -A[-2])\n#\n# # Repeat M-2 times\n# for i in range(M-2):\n#     # Pop the largest element in the heap\n#     a = -heapq.heappop(h)\n#\n#     # If a is greater than N, Takahashi cannot finish all of the assignments\n#     if a > N:\n#         print(-1)\n#         exit()\n#\n#     # Push a-1 into the heap\n#     heapq.heappush(h, -(a-1))\n#\n# # Pop the largest element in the heap\n# a = -heapq.heappop(h)\n#\n# # If a is greater than N, Takahashi cannot finish all of the assignments\n# if a > N:\n#     print(-1)\n#     exit()\n#\n# # Print N-(a-1)\n# print(N-(a-1))\n", "\n\nimport sys\nsys.setrecursionlimit(10**7)\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nif a[-1] >= n:\n    print(-1)\n    exit()\n\n\ndef dfs(i, s):\n    if i == m:\n        return n - s\n\n    if s + a[i] >= n:\n        return 0\n\n    return max(dfs(i+1, s), dfs(i+1, s + a[i]))\n\n\nprint(dfs(0, 0))\n", "\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nif a[-1] > n:\n    print(-1)\n    exit()\n\ns = 0\nfor i in range(m):\n    s += a[i]\n\nprint(n - s)\n", "import heapq\n# Input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n# Sort A in ascending order\nA.sort()\n# If N is smaller than A[-1], Takahashi cannot finish all of the assignments\nif N < A[-1]:\n    print(-1)\n    exit()\n# Initialize a heap\nh = []\n# Put the last element of A into the heap\nheapq.heappush(h, -A[-1])\n# Put the second-last element of A into the heap\nheapq.heappush(h, -A[-2])\n# Repeat M-2 times\nfor i in range(M-2):\n    # Pop the largest element in the heap\n    a = -heapq.heappop(h)\n\n    # If a is greater than N, Takahashi cannot finish all of the assignments\n    if a > N:\n        print(-1)\n        exit()\n    # Push a-1 into the heap\n    heapq.heappush(h, -(a-1))\n\n# Pop the largest element in the heap\na = -heapq.heappop(h)\n# If a is greater than N, Takahashi cannot finish all of the assignments\nif a > N:\n    print(-1)\n    exit()\n\n# Print N-(a-1)\nprint(N-(a-1))\n", "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nif a[-1] > n:\n    print(-1); exit()\n\ns = 0\nfor i in range(m):\n    s += a[i]\n\nprint(n - s)\n", "\nn, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\n\nif a[-1] > n:\n    print(-1)\n    exit()\n\ns = 0\nfor i in range(m):\n    s += a[i]\n\nprint(n - s)\n", "import heapq\n\n# Input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Sort A in ascending order\nA.sort()\n\n# If N is smaller than A[-1], Takahashi cannot finish all of the assignments\nif N < A[-1]:\n    print(-1)\n    exit()\n\n# Initialize a heap\nh = []\n\n# Put the last element of A into the heap\nheapq.heappush(h, -A[-1])\n\n# Put the second-last element of A into the heap\nheapq.heappush(h, -A[-2])\n\n# Repeat M-2 times\nfor i in range(M-2):\n    # Pop the largest element in the heap\n    a = -heapq.heappop(h)\n\n    # If a is greater than N, Takahashi cannot finish all of the assignments\n    if a > N:\n        print(-1)\n        exit()\n\n    # Push a-1 into the heap\n    heapq.heappush(h, -(a-1))\n\n# Pop the largest element in the heap\na = -heapq.heappop(h)\n\n# If a is greater than N, Takahashi cannot finish all of the assignments\nif a > N:\n    print(-1)\n    exit()\n\n# Print N-(a-1)\nprint(N-(a-1))\n", "\nn, m = map(int, input().split())\na = list(map(int, input().split()))[:m]\n\na.sort()\n\nif a[-1] > n:\n    print(-1)\n    exit()\n\ns = 0\nfor i in a:\n    s += i\n\nprint(n - s)\n", "from heapq import heappush, heappop\n\n# Input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Sort A in ascending order\nA.sort()\n\n# If N is smaller than A[-1], Takahashi cannot finish all of the assignments\nif N < A[-1]:\n    print(-1)\n    exit()\n\n# Initialize a heap\nh = []\n\n# Put the last element of A into the heap\nheappush(h, -A[-1])\n\n# Put the second-last element of A into the heap\nheapq.heappush(h, -A[-2])\n\n# Repeat M-2 times\nfor i in range(M-2):\n    # Pop the largest element in the heap\n    a = -heapq.heappop(h)\n\n    # If a is greater than N, Takahashi cannot finish all of the assignments\n    if a > N:\n        print(-1)\n        exit()\n\n    # Push a-1 into the heap\n    heapq.heappush(h, -(a-1))\n\n# Pop the largest element in the heap\na = -heapq.heappop(h)\n\n# If a is greater than N, Takahashi cannot finish all of the assignments\nif a > N:\n    print(-1)\n    exit()\n\n# Print N-(a-1)\nprint(N-(a-1))\n", "\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\ns = 0\nfor i in range(m):\n    s += a[i]\n\nprint(n - s)\n", "\nimport heapq\n\n# Input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Sort A in ascending order\nA.sort()\n\n# If N is smaller than A[0], Takahashi cannot finish all of the assignments\nif N < A[0]:\n    print(-1)\n    exit()\n\n# Initialize a heap\nh = []\n\n# Put the first element of A into the heap\nheapq.heappush(h, -A[0])\n\n# Put the second element of A into the heap\nheapq.heappush(h, -A[1])\n\n# Repeat M-2 times\nfor i in range(M-2):\n    # Pop the largest element in the heap\n    a = -heapq.heappop(h)\n\n    # If a is greater than N, Takahashi cannot finish all of the assignments\n    if a > N:\n        print(-1)\n        exit()\n\n    # Push a-1 into the heap\n    heapq.heappush(h, -(a-1))\n\n# Pop the largest element in the heap\na = -heapq.heappop(h)\n\n# If a is greater than N, Takahashi cannot finish all of the assignments\nif a > N:\n    print(-1)\n    exit()\n\n# Print N-(a-1)\nprint(N-(a-1))\n", "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport heapq\n\n# Input\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Sort A in ascending order\nA.sort()\n\n# If N is smaller than A[-1], Takahashi cannot finish all of the assignments\nif N < A[-1]:\n    print(-1)\n    exit()\n\n# Initialize a heap\nh = []\n\n# Put the last element of A into the heap\nheapq.heappush(h, -A[-1])\n\n# Put the second-last element of A into the heap\nheapq.heappush(h, -A[-2])\n\n# Repeat M-2 times from the 2nd element of A\nfor i in range(1, M-1):\n    # Pop the largest element in the heap\n    a = -heapq.heappop(h)\n\n    # If a is greater than N, Takahashi cannot finish all of the assignments\n    if a > N:\n        print(-1)\n        exit()\n\n    # Push a-1 into the heap\n    heapq.heappush(h, -(a-1))\n\n# Pop the largest element in the heap\na = -heapq.heappop(h)\n\n# If a is greater than N, Takahashi cannot finish all of the assignments\nif a > N:\n    print(-1)\n    exit()\n\n# Print N-(a-1)\nprint(N-(a-1))\n", "\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndf = pd.read_csv('data/train.csv')\n\n# print(df.head())\n# print(df.info())\n\n# sns.countplot(x='Survived', data=df)\n\n# sns.countplot(x='Survived', hue='Sex', data=df)\n\n# sns.countplot(x='Survived', hue='Pclass', data=df)\n\n# sns.distplot(df['Age'].dropna(), kde=False, bins=30)\n\n# df['Age'].plot.hist()\n\n# sns.countplot(x='SibSp', data=df)\n\n# df['Fare'].hist(bins=40, figsize=(10, 4))\n\n# plt.show()\n"]