2022-04-22 09:40:24.115388 num operations 1
2022-04-22 09:40:24.115420 size on input set 1
2022-04-22 09:40:24.115587 using api key sunu
2022-04-22 09:40:40.972232 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 1,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n\n\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 2,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 3,
      "text": "\n\n# Solution 1\n\nn = int(raw_input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, raw_input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(raw_input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, raw_input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 4,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 5,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 6,
      "text": "\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n"
    },
    {
      "index": 7,
      "text": "\nn = int(input())\n\nx = [0] * n\ny = [0] * n\n\nfor i in range(n): \n    x[i], y[i] = map(int, input().split())\n    \nprint(max(y) - min(x))\n"
    }
  ],
  "created": 1650620424,
  "object": "edit"
}
2022-04-22 09:40:40.972593 fix syntax errors 8 ['\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n\n\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n\n# Solution 1\n\nn = int(raw_input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, raw_input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(raw_input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, raw_input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\n# Solution 1\n\nn = int(input())\n\nx = []\ny = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nx.sort()\ny.sort()\n\na = 0\nb = 0\n\nfor i in range(n - 1):\n    if x[i] == x[i + 1]:\n        a += 1\n    if y[i] == y[i + 1]:\n        b += 1\n\nif a == n - 1 or b == n - 1:\n    print(0)\nelse:\n    print(y[b] - x[a])\n\n\n# Solution 2\n\nn = int(input())\n\nx = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    x.append((a, b, i))\n\nx.sort()\n\nans = 0\n\nfor i in range(n):\n    a = x[i][0]\n    b = x[i][1]\n    for j in range(i + 1, n):\n        if a > x[j][0]:\n            a = x[j][0]\n        if b < x[j][1]:\n            b = x[j][1]\n        if a == b:\n            break\n    if b - a > ans:\n        ans = b - a\n\nprint(ans)\n', '\nn = int(input())\n\nx = [0] * n\ny = [0] * n\n\nfor i in range(n): \n    x[i], y[i] = map(int, input().split())\n    \nprint(max(y) - min(x))\n']
2022-04-22 09:40:40.972831 size on output set 5
2022-04-22 09:40:40.972851 num operations 1
2022-04-22 09:40:40.972857 size on input set 1
2022-04-22 09:40:40.973007 using api key sunu
2022-04-22 09:40:55.264159 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nprint(\"hello\")\n"
    },
    {
      "index": 1,
      "text": "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If we sort the segments by their left endpoints, we can consider the problem as finding the segment with the least intersection length with the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    },
    {
      "index": 2,
      "text": "\n# SOLUTION\n# The problem is to find the segment with the least intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the least intersection length with\n# the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    },
    {
      "index": 3,
      "text": "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the least intersection length with\n# the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    },
    {
      "index": 4,
      "text": "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the least intersection length with\n# the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n#\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    },
    {
      "index": 5,
      "text": "\n"
    },
    {
      "index": 6,
      "text": "\n# SOLUTION\n# The problem is to find the segment with the least intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the least intersection length with\n# the segment before it.\n"
    },
    {
      "index": 7,
      "text": "\n\n#\n#\n#\n#\n# The problem is to find the segment with the least intersection length. If we sort the segments by their left endpoints, we can consider the problem as finding the segment with the least intersection length with the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous segment.  For the first segment, we just set the right endpoint to -infinity.  For the next segment, we compute the intersection length and update the right endpoint to the right endpoint of the current segment.  We can then keep track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous segment and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"
    }
  ],
  "created": 1650620441,
  "object": "edit"
}
2022-04-22 09:40:55.264508 fix syntax errors 8 ['\nprint("hello")\n', "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.  If we sort the segments by their left endpoints, we can consider the problem as finding the segment with the least intersection length with the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", "\n# SOLUTION\n# The problem is to find the segment with the least intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the least intersection length with\n# the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the least intersection length with\n# the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", "\n\n# SOLUTION\n# The problem is to find the segment with the least intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the least intersection length with\n# the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous\n# segment.  For the first segment, we just set the right endpoint to\n# -infinity.  For the next segment, we compute the intersection length\n# and update the right endpoint to the right endpoint of the current\n# segment.  We can then keep track of the minimum intersection length\n# and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous\n# segment and then just pop the first element, which will be the\n# minimum.\n#\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n", '\n', '\n# SOLUTION\n# The problem is to find the segment with the least intersection length.\n# If we sort the segments by their left endpoints, we can consider the\n# problem as finding the segment with the least intersection length with\n# the segment before it.\n', "\n\n#\n#\n#\n#\n# The problem is to find the segment with the least intersection length. If we sort the segments by their left endpoints, we can consider the problem as finding the segment with the least intersection length with the segment before it.\n\n# To do this, we can keep track of the right endpoint of the previous segment.  For the first segment, we just set the right endpoint to -infinity.  For the next segment, we compute the intersection length and update the right endpoint to the right endpoint of the current segment.  We can then keep track of the minimum intersection length and return at the end.\n\n# We can use a heap to keep track of the right endpoint of the previous segment and then just pop the first element, which will be the minimum.\n\nimport heapq\n\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nheap = [float('-inf')]\nmin_intersection = float('inf')\n\nfor l, r in segments:\n    min_intersection = min(min_intersection, heap[0] - l)\n    heapq.heappush(heap, r)\n\nprint(min_intersection)\n"]
2022-04-22 09:40:55.264670 size on output set 8
