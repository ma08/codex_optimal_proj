["import sys\na,m,n=list(map(int,input().split()))\naux=[0]*(a+1)\ninf=10**15\ndp=[aux.copy() for i in range(n+1)]\nm1=10**12\nm2=10**12\nfor i in range(m):\n    l,r=list(map(int,input().split()))\n    if l<m1:\n        m1=l\n    for j in range(l,r):\n        dp[0][j+1]=inf\ns=[]\nfor i in range(1,n+1):\n    x,w=list(map(int,input().split()))\n    s.append(tuple([x,w]))\n    if x<m2:\n        m2=x\nif m2>m1:\n    print(-1)\n    return\ns.sort()\n\nfor i in range(1,n+1):\n    x=s[i-1][0]\n    w=s[i-1][1]\n    for j in range(x+1):\n        dp[i][j]=dp[i-1][j]\n    for j in range(x+1,a+1):\n        if i!=1:\n            dp[i][j]=min(dp[0][j]+dp[i][j-1],dp[i-1][j],w*(j-x)+dp[i][x])\n        else:\n            dp[i][j]=min(dp[0][j]+dp[i][j-1],w*(j-x)+dp[i][x])\n            \nans=dp[-1][-1]\nif ans>=inf:\n    print(-1)\nelse:\n    print(ans)\n", "import sys\na, n, m = list(map(int, input().split(' ')))\n\nseg = []\nfor i in range(n):\n    rained = tuple(map(int, input().split(' ')))\n    for k in range(rained[0], rained[1]):\n        seg.append(k+1)\n\numbrella = []\nfor j in range(m):\n    u = tuple(map(int, input().split(' ')))\n    umbrella.append(u)\n\nmemo = [0] * (a+1)\n\numbrella = sorted(umbrella, key=lambda x: x[0])\nif umbrella[0][0] > seg[0] - 1:\n    print(-1)\n    return\n\nfor index in range(1, len(memo)):\n\n    if index not in seg:\n        memo[index] = memo[index-1]\n        continue\n\n    for each in umbrella:\n        if index >= each[0]:\n            cur = (index - each[0]) * each[1] + memo[each[0]]\n            if memo[index] > 0:\n                if cur < memo[index]:\n                    memo[index] = cur\n            else:\n                memo[index] = cur\n\n\n\n\n\n\nprint(memo[-1])\n\n\n\n\n\n\n\n\n\n\n", "#     Codeforces Round #486 (Div. 3)\n\nfrom functools import cmp_to_key\n#key=cmp_to_key(lambda x,y: 1 if x not in y else -1 )\n\nimport sys\ndef getIntList():\n    return list(map(int, input().split()))    \n\n\n\na,n,m = getIntList()\nrainend = set()\numbr = {}\nkeyPointSet = set([0,a])\nfor i in range(n):\n    t =tuple(getIntList()) \n    for j in range(t[0] + 1, t[1] + 1):\n        rainend.add(j)\n    keyPointSet.add(t[1])\nfor i in range(m):\n    t =getIntList()\n    if t[0] not in umbr or t[1]< umbr[t[0]]:\n        umbr[t[0]] = t[1]\n    keyPointSet.add(t[0])\n    \nkeyPoint = list(keyPointSet)\nkeyPoint.sort()\n\n\n\ndp = {}\n\ndp[0] =  {}\ndp[0] [0] = 0\nif 0 in umbr:\n    dp[0][umbr[0]] = 0\n\n\nfor i in range(1, len(keyPoint)):\n    x = keyPoint[i]\n    lx = keyPoint[i-1]\n    ifrain =  x in rainend\n    dp[x] = {}\n    nowdp = dp[x]\n    lastdp = dp[lx]\n    \n    for z in lastdp:\n        if z == 0 :\n            if not ifrain:\n                nowdp[0] = lastdp[0]\n        else:\n            nowdp[z]  = lastdp[z] + z * (x-lx)\n    if len(nowdp) >0:\n        nowdp[0] = min(nowdp.values())\n        if x in umbr:\n            if umbr[x] not in nowdp or   nowdp[0] < nowdp[umbr[x]]:\n                nowdp[umbr[x]] = nowdp[0]\n    else:\n        print(-1)\n        return\n\nprint( min(dp[a].values()) )\n            \n    \n", "rd = lambda: list(map(int, input().split()))\na, n, m = rd()\ns = set()\nu = {}\nk = set([0, a])\nfor _ in range(n):\n    l, r = rd()\n    for x in range(l + 1, r + 1):\n        s.add(x)\n    k.add(r)\nfor _ in range(m):\n    x, p = rd()\n    u[x] = min(p, u.get(x, 1e9))\n    k.add(x)\nk = sorted(list(k))\ndp = {}\ndp[0] = {}\ndp[0][0] = 0\nif 0 in u:\n    dp[0][u[0]] = 0\nfor i in range(1, len(k)):\n    x = k[i]\n    y = k[i - 1]\n    dp[x] = {}\n    for z in dp[y]:\n        if z:\n            dp[x][z] = dp[y][z] + z * (x - y)\n        else:\n            if x not in s:\n                dp[x][0] = dp[y][0]\n    if len(dp[x]):\n        dp[x][0] = min(dp[x].values())\n        if x in u:\n            if u[x] not in dp[x] or dp[x][0] < dp[x][u[x]]:\n                dp[x][u[x]] = dp[x][0]\n    else:\n        print(-1)\n        return\nprint(dp[a][0])\n", "import sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef input_l():\n    return map(int, input().split())\n\ndef input_t():\n    return tuple(input_l())\n    \ndef main():\n    a, s, d = input_l()\n    q = []\n    e = []\n    z = [0] * (a + 1)\n    \n    for i in range(s):\n        w = input_t()\n        for k in range(w[0], w[1]):\n            q.append(k + 1)\n\n    for j in range(d):\n        e.append(input_t())\n    \n    e = sorted(e, key = lambda x: x[0])\n    \n    if e[0][0] > q[0] - 1:\n        print(-1)\n        return\n    \n    for i in range(1, len(z)):\n        if i not in q:\n            z[i] = z[i-1]\n            continue\n    \n        for j in e:\n            if i >= j[0]:\n                c = (i - j[0]) * j[1] + z[j[0]]\n                if z[i] > 0:\n                    if c < z[i]:\n                        z[i] = c            \n                else:\n                    z[i] = c\n    \n    print(z[-1])\n    \nmain()", "import math\n\n\ndef main():\n    a, n, m = list(map(int, input().split()))\n    rain = []\n    u = []\n    w = []\n    raining = [False] * (a+1)\n    for i in range(n):\n        l, r = list(map(int, input().split()))\n        rain.append((l, r))\n        for j in range(l, r):\n            raining[j] = True\n\n    for i in range(m):\n        x, y = list(map(int, input().split()))\n        u.append(x)\n        w.append(y)\n\n    rain_int = [0] * a\n    for i in range(n):\n        rain_int[rain[i][0]-1] = 1\n        rain_int[rain[i][1]-1] = -1\n\n    umbrellas = [-1 for _ in range(a+1)]\n    for i, x in enumerate(u):\n        if umbrellas[x] == -1 or w[umbrellas[x]] > w[i]:\n            umbrellas[x] = i\n\n    dp = [[math.inf for _ in range(m+1)] for _ in range(a+1)]\n    dp[0][m] = 0\n    for i in range(a):\n        for j in range(m+1):\n            if dp[i][j] == math.inf:\n                continue\n            if not raining[i]:\n                dp[i+1][m] = min(dp[i+1][m], dp[i][j])\n            if j < m:\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + w[j])\n            if umbrellas[i] != -1:\n                dp[i+1][umbrellas[i]] = min(dp[i+1][umbrellas[i]], dp[i][j]+w[umbrellas[i]])\n\n    ans = math.inf\n    for i in range(m+1):\n        ans = min(ans, dp[a][i])\n    print(-1 if ans == math.inf else ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# Author: S Mahesh Raju\n# Username: maheshraju2020\n# Date: 03/07/2020\n\nfrom sys import stdin,stdout\nfrom math import gcd, ceil, sqrt\nfrom collections import Counter\nii1 = lambda: int(stdin.readline().strip())\nis1 = lambda: stdin.readline().strip()\niia = lambda: list(map(int, stdin.readline().strip().split()))\nisa = lambda: stdin.readline().strip().split()\nmod = 1000000007\n\na, n, m = iia()\nrain = []\nfor _ in range(n):\n    l, r = iia()\n    for i in range(l, r):\n        rain.append(i)\numb = []\nfor _ in range(m):\n    umb.append(iia())\n\nrain.sort()\numb.sort()\n\ndp = [0] * (a + 1)\nfor i in range(a + 1):\n    if i not in rain:\n        if i != 0:\n            dp[i] = dp[i - 1]\n    \n    else:\n        for j in umb:\n            if j[0] <= i:\n                temp = (i + 1 - j[0]) * j[1]\n\n                if j[0] - 1 >= 0:\n                    temp += dp[j[0] - 1]\n\n                if dp[i] > 0:\n                    dp[i] = min(dp[i], temp)\n                \n                else:\n                    dp[i] = temp\n                \n            else:\n                break\n\n# print(dp)\n\nif umb[0][0] > rain[0]:\n    print(-1)\nelse:\n    print(dp[-1])\n\n", "# -*- coding: utf-8 -*-\nimport sys\nfrom collections import deque, defaultdict, namedtuple\nfrom math import sqrt, factorial, gcd, ceil, atan, pi\ndef input(): return sys.stdin.readline()[:-1] # warning not \\n\n# def input(): return sys.stdin.buffer.readline().strip() # warning bytes\n# def input(): return sys.stdin.buffer.readline().decode('utf-8')\nimport string\nimport operator\n# string.ascii_lowercase\nfrom bisect import bisect_left, bisect_right\nfrom functools import lru_cache, reduce\nMOD = int(1e9)+7\nINF = float('inf')\n\n\ndef solve():\n    a, n, m = [int(x) for x in input().split()]\n    rain = [0] * (a + 1)\n    for _ in range(n):\n        l, r = [int(x) for x in input().split()]\n        for i in range(l + 1, r + 1):\n            rain[i] = 1\n    umb = []\n    for _ in range(m):\n        x, p = [int(x) for x in input().split()]\n        umb.append((x, p))\n    umb.sort()\n\n    dp = [INF for _ in range(a + 1)]\n    dp[0] = 0\n    for i in range(1, a + 1):\n        if rain[i]:\n            for x, p in umb:\n                if x >= i: break\n                dp[i] = min(dp[i], dp[x] + p * (i - x))\n        else:\n            dp[i] = dp[i-1]\n\n    if dp[a] == INF:\n        print(-1)\n    else:\n        print(dp[a])\n\n\n\nt = 1\n# t = int(input())\nfor case in range(1,t+1):\n    ans = solve()\n\n\n\"\"\"\n\n1 2\n\ndp[x] = min()\n\n\n\n\n\"\"\"\n", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\nfrom functools import lru_cache\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\nsys.setrecursionlimit(10 ** 6)\n\na, n, m = li()\nl = []\nrain = defaultdict(int)\nfor i in range(n):\n    c, b = li()\n    for j in range(c, b):\n        rain[(j, j + 1)] = 1\n\n\n# print(rain)\numbrellas = [float('inf')] * (a + 5)\nfor i in range(m):\n    c, b = li()\n    umbrellas[c] = min(umbrellas[c], b)\n# print(umbrellas[:a + 1])\n\n@lru_cache(None)\ndef dp(i = 0, umbon = 0):\n    # print(i, umbon)\n    if i == a:\n        if rain[(i - 1, i)]:\n            if umbon:return umbon\n            return float('inf')\n        else:return umbon\n    else:\n        ans = float('inf')\n        last = umbon\n        if rain[(i - 1, i)]:\n            umbon = min(umbon, umbrellas[i]) if umbon else umbrellas[i]\n            if not last:last = float('inf')\n            ans = min(ans, last + dp(i + 1, umbon))\n            ans = min(ans, last + dp(i + 1, 0))\n        else:\n            ans = min(ans, dp(i + 1, 0) + last)\n            umbon = min(umbon, umbrellas[i]) if umbon else umbrellas[i]\n            ans = min(ans, dp(i + 1, umbon) + last)\n    return ans\n\nprint(dp(0, 0) if dp(0, 0) != float('inf') else -1)\n"]