2022-04-22 09:28:52.013025 num operations 1
2022-04-22 09:28:52.013063 size on input set 1
2022-04-22 09:28:52.013238 using api key kouti
2022-04-22 09:29:15.402476 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j], tree[i][k]\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a]\n    visited = [False]*len(tree)\n    visited[a] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    n, k = map(int, input().split())\n    tree = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    if n == k:\n        max_paths = n - 1\n        ans = [i + 1 for i in range(n)]\n    elif n < k:\n        max_paths = n\n        ans = [i + 1 for i in range(n)]\n    else:\n        for i in range(n):\n            for j in range(len(tree[i])):\n                for k in range(j + 1, len(tree[i])):\n                    a, b, c = i + 1, tree[i][j] + 1, tree[i][k] + 1\n                    paths = [0] * 3\n                    for l in range(3):\n                        paths[l] = len(path(tree, a, b, c, l))\n                    max_paths = max(max_paths, sum(paths))\n                    if max_paths == sum(paths):\n                        ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\n\ndef path(tree, a, b, c, i):\n    return find_path(tree, a, b) if i == 0 else (find_path(tree, b, c) if i == 1 else find_path(tree, a, c))\n\n\ndef find_path(tree, a, b):\n    q = [a - 1]\n    visited = [False] * len(tree)\n    visited[a - 1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b - 1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\n\nmain()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a-1, b-1, c-1, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b, visited=None):\n    if visited is None:\n        visited = [False]*len(tree)\n    q = [a]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n = int(input('Number of vertices: '))\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input('Connections: ').split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                ans = [a, b, c] if max_paths == sum(paths) else ans\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n"
    }
  ],
  "created": 1650619732,
  "object": "edit"
}
2022-04-22 09:29:15.403013 fix syntax errors 8 ['\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j], tree[i][k]\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a]\n    visited = [False]*len(tree)\n    visited[a] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\ndef main():\n    n, k = map(int, input().split())\n    tree = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    if n == k:\n        max_paths = n - 1\n        ans = [i + 1 for i in range(n)]\n    elif n < k:\n        max_paths = n\n        ans = [i + 1 for i in range(n)]\n    else:\n        for i in range(n):\n            for j in range(len(tree[i])):\n                for k in range(j + 1, len(tree[i])):\n                    a, b, c = i + 1, tree[i][j] + 1, tree[i][k] + 1\n                    paths = [0] * 3\n                    for l in range(3):\n                        paths[l] = len(path(tree, a, b, c, l))\n                    max_paths = max(max_paths, sum(paths))\n                    if max_paths == sum(paths):\n                        ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\n\ndef path(tree, a, b, c, i):\n    return find_path(tree, a, b) if i == 0 else (find_path(tree, b, c) if i == 1 else find_path(tree, a, c))\n\n\ndef find_path(tree, a, b):\n    q = [a - 1]\n    visited = [False] * len(tree)\n    visited[a - 1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b - 1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a-1, b-1, c-1, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b, visited=None):\n    if visited is None:\n        visited = [False]*len(tree)\n    q = [a]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', "\n\ndef main():\n    n = int(input('Number of vertices: '))\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input('Connections: ').split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n", '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, input().split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                if max_paths == sum(paths):\n                    ans = [a, b, c]\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n', '\n\ndef main():\n    n = int(input())\n    tree = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        tree[a-1].append(b-1)\n        tree[b-1].append(a-1)\n    for i in range(n):\n        tree[i].sort()\n    max_paths = 0\n    for i in range(n):\n        for j in range(len(tree[i])):\n            for k in range(j+1, len(tree[i])):\n                a, b, c = i+1, tree[i][j]+1, tree[i][k]+1\n                paths = [0]*3\n                for l in range(3):\n                    paths[l] = len(path(tree, a, b, c, l))\n                max_paths = max(max_paths, sum(paths))\n                ans = [a, b, c] if max_paths == sum(paths) else ans\n    print(max_paths)\n    print(*ans)\n\ndef path(tree, a, b, c, i):\n    if i == 0:\n        return find_path(tree, a, b)\n    elif i == 1:\n        return find_path(tree, b, c)\n    else:\n        return find_path(tree, a, c)\n\ndef find_path(tree, a, b):\n    q = [a-1]\n    visited = [False]*len(tree)\n    visited[a-1] = True\n    while q:\n        cur = q.pop(0)\n        if cur == b-1:\n            return visited\n        for node in tree[cur]:\n            if not visited[node]:\n                visited[node] = True\n                q.append(node)\n    return []\n\nmain()\n']
2022-04-22 09:29:15.403162 size on output set 7
2022-04-22 09:29:15.403177 num operations 1
2022-04-22 09:29:15.403184 size on input set 1
2022-04-22 09:29:15.403330 using api key sunu
2022-04-22 09:29:49.847126 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\nsys.setrecursionlimit(2 * 10 ** 5)\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex):\n    cnt = 0\n    edges = 1\n    for child in tree[vertex]:\n        child_cnt, child_edges = dfs(child)\n        cnt += child_cnt\n        edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1)\n    cnt2, edges2 = dfs(v2)\n    return edges1 + edges2 + cnt1 * cnt2\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\ndef get_max_edges(v1, v2, parent):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, parent)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2, v3) + get_max_edges(v1, v3, v2) + get_max_edges(v2, v3, v1)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nwith open('data.txt') as f:\n    data = f.read()\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    },
    {
      "index": 7,
      "text": "\n\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n"
    }
  ],
  "created": 1650619755,
  "object": "edit"
}
2022-04-22 09:29:49.847525 fix syntax errors 8 ['import sys\nsys.setrecursionlimit(2 * 10 ** 5)\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex):\n    cnt = 0\n    edges = 1\n    for child in tree[vertex]:\n        child_cnt, child_edges = dfs(child)\n        cnt += child_cnt\n        edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1)\n    cnt2, edges2 = dfs(v2)\n    return edges1 + edges2 + cnt1 * cnt2\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\ndef get_max_edges(v1, v2, parent):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, parent)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2, v3) + get_max_edges(v1, v3, v2) + get_max_edges(v2, v3, v1)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\n\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\ndef dfs(vertex, parent):\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', '\nimport sys\nsys.setrecursionlimit(2 * 10 ** 5)\nn = int(input())\ntree = [[] for _ in range(n)]\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n', "\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nwith open('data.txt') as f:\n    data = f.read()\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n", '\n\n\n\ndef dfs(vertex, parent):\n    # return (count of vertices in subtree, count of edges in subtree)\n    cnt = 1\n    edges = 0\n    for child in tree[vertex]:\n        if child != parent:\n            child_cnt, child_edges = dfs(child, vertex)\n            cnt += child_cnt\n            edges += child_edges + child_cnt\n    return cnt, edges\n\n\ndef get_max_edges(v1, v2):\n    cnt1, edges1 = dfs(v1, -1)\n    cnt2, edges2 = dfs(v2, -1)\n    return edges1 + edges2 + cnt1 * cnt2\n\nimport sys\n\nsys.setrecursionlimit(2 * 10 ** 5)\n\nn = int(input())\ntree = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    v1, v2 = map(int, input().split())\n    tree[v1 - 1].append(v2 - 1)\n    tree[v2 - 1].append(v1 - 1)\n\n\nans = 0\nans1, ans2, ans3 = 0, 0, 0\nfor v1 in range(n):\n    for v2 in tree[v1]:\n        for v3 in tree[v2]:\n            if v1 != v3:\n                cur = get_max_edges(v1, v2) + get_max_edges(v1, v3) + get_max_edges(v2, v3)\n                if cur > ans:\n                    ans = cur\n                    ans1, ans2, ans3 = v1, v2, v3\n\nprint(ans)\nprint(ans1 + 1, ans2 + 1, ans3 + 1)\n']
2022-04-22 09:29:49.847653 size on output set 8
