2022-04-22 10:24:46.599280 num operations 1
2022-04-22 10:24:46.599301 size on input set 1
2022-04-22 10:24:46.599442 using api key soukgp
2022-04-22 10:25:05.375152 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans) \n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P = [int(readline()) for _ in range(D)]\n    C = [int(readline()) for _ in range(D)]\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10 ** 10\n    # for i in range(2 ** D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10 ** 10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n\n\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans) \n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate(P))\n    C_cum = list(accumulate(C))\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    C_cum = list(accumulate([0] + C))\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i + 1] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 2:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650623086,
  "object": "edit"
}
2022-04-22 10:25:05.375639 fix syntax errors 8 ["\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans) \n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P = [int(readline()) for _ in range(D)]\n    C = [int(readline()) for _ in range(D)]\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10 ** 10\n    # for i in range(2 ** D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10 ** 10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n\n\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    P_cum.pop(0)\n    C_cum = list(accumulate([0] + C))\n    C_cum.pop(0)\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans) \n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate(P))\n    C_cum = list(accumulate(C))\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 1:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\n# -*- coding: utf-8 -*-\n\ndef main():\n    from sys import stdin\n    from itertools import accumulate\n    from bisect import bisect_left\n\n    readline = stdin.readline\n\n    D, G = map(int, readline().split())\n    P, C = zip(*[map(int, readline().split()) for _ in range(D)])\n    P = list(P)\n    C = list(C)\n    P_cum = list(accumulate([0] + P))\n    C_cum = list(accumulate([0] + C))\n\n    # O(D^2)\n    # ans = 10**10\n    # for i in range(2**D):\n    #     score = 0\n    #     cnt = 0\n    #     for j in range(D):\n    #         if i >> j & 1:\n    #             score += 100 * (j + 1) * P[j] + C[j]\n    #             cnt += P[j]\n    #     for j in range(D - 1, -1, -1):\n    #         if score >= G:\n    #             ans = min(ans, cnt)\n    #             break\n    #         if i >> j & 1:\n    #             continue\n    #         for k in range(P[j]):\n    #             if score >= G:\n    #                 break\n    #             score += 100 * (j + 1)\n    #             cnt += 1\n    #     else:\n    #         ans = min(ans, cnt)\n    # print(ans)\n\n    # O(D)\n    ans = 10**10\n    for i in range(D):\n        score = C_cum[i + 1] + 100 * (i + 1) * P_cum[i]\n        if score >= G:\n            ans = min(ans, P_cum[i])\n        else:\n            cnt = P_cum[i]\n            score += 100 * (i + 1) * (P_cum[-1] - P_cum[i])\n            cnt += (P_cum[-1] - P_cum[i])\n            if score >= G:\n                ans = min(ans, cnt)\n            else:\n                idx = bisect_left(C_cum[i + 2:], G - score)\n                ans = min(ans, cnt + idx)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-22 10:25:05.375823 size on output set 8
2022-04-22 10:25:05.375835 num operations 1
2022-04-22 10:25:05.375841 size on input set 1
2022-04-22 10:25:05.375992 using api key sunu
2022-04-22 10:25:15.558081 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score\n    # of G or more points\n    ans = float('inf')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n\n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float('inf')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    D, G = map(int, input().split())\n    p, c = list(), list()\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float(\"inf\")\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i >> j) & 1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i >> j) & 1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n\n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float('inf')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float('inf')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0 and score < G:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    D, G = map(int, input().split())\n    P, C = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        P.append(pi)\n        C.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float('inf')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * P[j] + C[j]\n                res += P[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0:\n                for k in range(P[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float('inf')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i >> j) & 1:\n                score += 100 * (j + 1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D - 1, -1, -1):\n            if (i >> j) & 1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j + 1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float('inf')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0 and score < G:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650623105,
  "object": "edit"
}
2022-04-22 10:25:15.558434 fix syntax errors 8 ['\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score\n    # of G or more points\n    ans = float(\'inf\')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n\n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float(\'inf\')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    D, G = map(int, input().split())\n    p, c = list(), list()\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float("inf")\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i >> j) & 1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i >> j) & 1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n\n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float(\'inf\')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float(\'inf\')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0 and score < G:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    D, G = map(int, input().split())\n    P, C = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        P.append(pi)\n        C.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float(\'inf\')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * P[j] + C[j]\n                res += P[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0:\n                for k in range(P[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float(\'inf\')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i >> j) & 1:\n                score += 100 * (j + 1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D - 1, -1, -1):\n            if (i >> j) & 1 == 0:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j + 1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    D, G = map(int, input().split())\n    p, c = [], []\n    for i in range(D):\n        pi, ci = map(int, input().split())\n        p.append(pi)\n        c.append(ci)\n    \n    # calculate the minimum number of problems\n    # that needs to be solved in order to have a total score of G or more points\n    ans = float(\'inf\')\n    for i in range(2**D):\n        score = 0\n        res = 0\n        for j in range(D):\n            if (i>>j)&1:\n                score += 100 * (j+1) * p[j] + c[j]\n                res += p[j]\n        for j in range(D-1, -1, -1):\n            if (i>>j)&1 == 0 and score < G:\n                for k in range(p[j]):\n                    res += 1\n                    score += 100 * (j+1)\n                    if score >= G:\n                        break\n                break\n        if score >= G:\n            ans = min(ans, res)\n    print(ans)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-22 10:25:15.558657 size on output set 6
