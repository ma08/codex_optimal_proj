2022-04-20 11:28:26.947266 num operations 1
2022-04-20 11:28:26.947305 size on input set 1
2022-04-20 11:28:26.947518 using api key derek
2022-04-20 11:28:27.067559 in retry 6 1.5 <class 'Exception'>, Retrying in 1 seconds...
2022-04-20 11:28:28.569447 using api key sunu
2022-04-20 11:28:38.621050 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 1,
      "text": "\n# Read input\nn, m, d = map(int, input().split())  # n is number of nodes, m is number of edges, d is distance from 1 to d\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):  # check if node 1 has an edge\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):  # initialize graph\n    graph[i] = []\nfor edge in edges:  # add edges to graph\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree (breadth first search)\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:  # while queue is not empty\n    node = queue.pop(0)\n    if node is not None:  # if node is not None\n        for neighbor in graph[node]:\n            if not visited[neighbor]:  # if neighbor has not been visited\n                tree.append((node, neighbor))  # add edge to tree\n                visited[neighbor] = True  # mark neighbor as visited\n                queue.append(neighbor)  # add neighbor to queue\n                queue.append(None)  # add None to queue\n                break  # break out of for loop\n\n# Check if tree is valid\nd1 = 0  # number of edges from 1 to d\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:  # if number of edges from 1 to d is not equal to d\n    print(\"NO\")\n    exit()\n\n# Print tree (YES followed by edges)\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    }
  ],
  "created": 1650454108,
  "object": "edit"
}
2022-04-20 11:28:38.621308 fix syntax errors 2 ['\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\n# Read input\nn, m, d = map(int, input().split())  # n is number of nodes, m is number of edges, d is distance from 1 to d\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):  # check if node 1 has an edge\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):  # initialize graph\n    graph[i] = []\nfor edge in edges:  # add edges to graph\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree (breadth first search)\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:  # while queue is not empty\n    node = queue.pop(0)\n    if node is not None:  # if node is not None\n        for neighbor in graph[node]:\n            if not visited[neighbor]:  # if neighbor has not been visited\n                tree.append((node, neighbor))  # add edge to tree\n                visited[neighbor] = True  # mark neighbor as visited\n                queue.append(neighbor)  # add neighbor to queue\n                queue.append(None)  # add None to queue\n                break  # break out of for loop\n\n# Check if tree is valid\nd1 = 0  # number of edges from 1 to d\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:  # if number of edges from 1 to d is not equal to d\n    print("NO")\n    exit()\n\n# Print tree (YES followed by edges)\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n']
2022-04-20 11:28:38.621390 size on output set 2
2022-04-20 11:28:38.621403 num operations 1
2022-04-20 11:28:38.621409 size on input set 1
2022-04-20 11:28:38.621566 using api key gabby
2022-04-20 11:28:40.775358 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 being D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650454118,
  "object": "edit"
}
2022-04-20 11:28:40.775669 fix syntax errors 2 ['\n\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 being D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n']
2022-04-20 11:28:40.775720 size on output set 2
2022-04-20 11:28:40.775731 num operations 1
2022-04-20 11:28:40.775737 size on input set 1
2022-04-20 11:28:40.775895 using api key kouti
2022-04-20 11:28:42.736422 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom collections import deque\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom collections import deque\n\n\nif __name__ == \"__main__\":\n\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    }
  ],
  "created": 1650454120,
  "object": "edit"
}
2022-04-20 11:28:42.736637 fix syntax errors 2 ['\nfrom collections import deque\n\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n', '\n\nfrom collections import deque\n\n\nif __name__ == "__main__":\n\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n']
2022-04-20 11:28:42.736678 size on output set 2
