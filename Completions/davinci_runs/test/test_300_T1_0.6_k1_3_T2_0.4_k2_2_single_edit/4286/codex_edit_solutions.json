["import os\n\ndef get_files(path):\n    pass\n\ndef get_file_content(file_path):\n    pass\n\ndef get_file_stats(file_path):\n    pass\n\ndef get_file_type(file_path):\n    pass\n\ndef get_file_extension(file_path):\n    pass\n\ndef get_file_name(file_path):\n    pass\n\ndef get_file_size(file_path):\n    pass\n\ndef get_file_owner(file_path):\n    pass\n\ndef get_file_group(file_path):\n    pass\n\ndef get_file_permissions(file_path):\n    pass\n\ndef get_file_last_accessed_date(file_path):\n    pass\n\ndef get_file_last_modified_date(file_path):\n    pass\n\ndef get_file_last_status_change_date(file_path):\n    pass\n\ndef get_file_last_accessed_time(file_path):\n    pass\n\ndef get_file_last_modified_time(file_path):\n    pass\n\ndef get_file_last_status_change_time(file_path):\n    pass\n\ndef get_file_last_accessed_datetime(file_path):\n    pass\n\ndef get_file_last_modified_datetime(file_path):\n    pass\n\ndef get_file_last_status_change_datetime(file_path):\n    pass\n\ndef get_file_last_accessed_timestamp(file_path):\n    pass\n\ndef get_file_last_modified_timestamp(file_path):\n    pass\n\ndef get_file_last_status_change_timestamp(file_path):\n    pass\n\ndef get_file_creation_date(file_path):\n    pass\n\ndef get_file_creation_time(file_path):\n    pass\n\ndef get_file_creation_datetime(file_path):\n    pass\n\ndef get_file_creation_timestamp(file_path):\n    pass\n\ndef get_file_is_hidden(file_path):\n    pass\n\ndef get_file_is_readonly(file_path):\n    pass\n\ndef get_file_is_system(file_path):\n    pass\n\ndef get_file_is_executable(file_path):\n    pass\n\ndef get_file_is_writable(file_path):\n    pass\n\ndef get_file_is_readable(file_path):\n    pass\n\ndef get_file_is_empty(file_path):\n    pass\n\ndef get_file_is_symlink(file_path):\n    pass\n\ndef get_file_is_socket(file_path):\n    pass\n\ndef get_file_is_pipe(file_path):\n    pass\n\ndef get_file_is_block_device(file_path):\n    pass\n\ndef get_file_is_character_device(file_path):\n    pass\n\ndef get_file_is_dir(file_path):\n    pass\n\ndef get_file_is_file(file_path):\n    pass\n\ndef get_file_is_regular_file(file_path):\n    pass\n\ndef get_file_is_absolute(file_path):\n    pass\n\ndef get_file_is_relative(file_path):\n    pass\n\ndef get_file_is_file_system(file_path):\n    pass\n\ndef get_file_is_mount_point(file_path):\n    pass\n\ndef get_file_is_block_special_file(file_path):\n    pass\n\ndef get_file_is_character_special_file(file_path):\n    pass\n\ndef get_file_is_fifo(file_path):\n    pass\n\ndef get_file_is_hard_link(file_path):\n    pass\n\ndef get_file_is_soft_link(file_path):\n    pass\n\ndef get_file_is_strict_soft_link(file_path):\n    pass\n\ndef get_file_is_strict_hard_link(file_path):\n    pass\n\ndef get_file_is_strict_link(file_path):\n    pass\n\ndef get_file_is_link(file_path):\n    pass\n\ndef get_file_is_strict_file(file_path):\n    pass\n\ndef get_file_is_strict_dir(file_path):\n    pass\n\ndef get_file_is_strict_regular_file(file_path):\n    pass\n\ndef get_file_is_strict_block_special_file(file_path):\n    pass\n\ndef get_file_is_strict_character_special_file(file_path):\n    pass\n\ndef get_file_is_strict_fifo(file_path):\n    pass\n\ndef get_file_is_strict_socket(file_path):\n    pass\n\ndef get_file_is_strict_pipe(file_path):\n    pass\n\ndef is_file_hidden(file_path):\n    pass\n\ndef is_file_readonly(file_path):\n    pass\n\ndef is_file_system(file_path):\n    pass\n\ndef is_file_executable(file_path):\n    pass\n\ndef is_file_writable(file_path):\n    pass\n\ndef is_file_readable(file_path):\n    pass\n\ndef is_file_empty(file_path):\n    pass\n\ndef is_file_symlink(file_path):\n    pass\n\ndef is_file_socket(file_path):\n    pass\n\ndef is_file_pipe(file_path):\n    pass\n\ndef is_file_block_device(file_path):\n    pass\n\ndef is_file_character_device(file_path):\n    pass\n\ndef is_file_dir(file_path):\n    pass\n\ndef is_file_file(file_path):\n    pass\n\ndef is_file_regular_file(file_path):\n    pass\n\ndef is_file_absolute(file_path):\n    pass\n\ndef is_file_relative(file_path):\n    pass\n\ndef is_file_file_system(file_path):\n    pass\n\ndef is_file_mount_point(file_path):\n    pass\n\ndef is_file_block_special_file(file_path):\n    pass\n\ndef is_file_character_special_file(file_path):\n    pass\n\ndef is_file_fifo(file_path):\n    pass\n\ndef is_file_hard_link(file_path):\n    pass\n\ndef is_file_soft_link(file_path):\n    pass\n\ndef is_file_strict_soft_link(file_path):\n    pass\n\ndef is_file_strict_hard_link(file_path):\n    pass\n\ndef is_file_strict_link(file_path):\n    pass\n\ndef is_file_link(file_path):\n    pass\n\ndef is_file_strict_file(file_path):\n    pass\n\ndef is_file_strict_dir(file_path):\n    pass\n\ndef is_file_strict\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i + 1] for i in range(n)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] += tree[v_idx]\n            tree.pop(v_idx)\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n", "\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\n# This is a comment\nimport heapq\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n        self.cost = [[float('inf') for _ in range(n)] for _ in range(n)]\n        self.costs = []\n        self.is_edge = [[False for _ in range(n)] for _ in range(n)]\n\n    def add_edge(self, u, v, w):\n        self.edges[u].append((v, w))\n        self.cost[u][v] = w\n        self.cost[v][u] = w\n        self.is_edge[u][v] = True\n        self.is_edge[v][u] = True\n        self.costs.append(w)\n\n    def get_minimum_spanning_tree(self):\n        visited = [False] * self.n\n        min_heap = []\n        heapq.heappush(min_heap, (0, 0))\n        total_cost = 0\n        while min_heap:\n            weight, u = heapq.heappop(min_heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            total_cost += weight\n            for v, w in self.edges[u]:\n                if not visited[v]:\n                    heapq.heappush(min_heap, (w, v))\n        return total_cost\n\n    def get_minimum_cost(self):\n        total_cost = self.get_minimum_spanning_tree()\n        min_cost = min(self.costs)\n        return total_cost + (self.n - 1) * min_cost\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    graph = Graph(n)\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        x -= 1\n        y -= 1\n        graph.add_edge(x, y, w)\n    for i in range(n):\n        for j in range(n):\n            if not graph.is_edge[i][j]:\n                graph.add_edge(i, j, a[i] + a[j])\n    print(graph.get_minimum_cost())\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef min_cost(n, m, a, offers):\n    \"\"\"\n    >>> min_cost(3, 2, [1, 3, 3], [(2, 3, 5), (2, 1, 1)])\n    5\n    >>> min_cost(4, 0, [1, 3, 3, 7], [])\n    16\n    >>> min_cost(5, 4, [1, 2, 3, 4, 5], [(1, 2, 8), (1, 3, 10), (1, 4, 7), (1, 5, 15)])\n    18\n    \"\"\"\n    offers = sorted(offers, key=lambda x: x[2])\n    tree = [[i] for i in range(1, n+1)]\n    res = 0\n    for u, v, w in offers:\n        for i in range(n):\n            if u in tree[i]:\n                u_idx = i\n            if v in tree[i]:\n                v_idx = i\n        if u_idx != v_idx:\n            res += w\n            tree[u_idx] = tree[u_idx] + tree[v_idx]\n            tree.remove(tree[v_idx])\n    for i in range(n):\n        if len(tree[i]) == 1:\n            res += a[i]\n    return res\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    offers = []\n    for _ in range(m):\n        offers.append(tuple(map(int, input().split())))\n    print(min_cost(n, m, a, offers))\n", "\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n"]