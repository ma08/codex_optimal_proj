2022-04-20 12:16:33.709794 num operations 1
2022-04-20 12:16:33.709812 size on input set 1
2022-04-20 12:16:33.709993 using api key soukgp
2022-04-20 12:16:35.236224 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    number_of_points = int(input())\n    point_list = []\n    for _ in range(number_of_points):\n        point_list.append(list(map(float, input().split())))\n    max_length = 0\n    for i in range(number_of_points-1):\n        for j in range(i+1, number_of_points):\n            length = ((point_list[i][0]-point_list[j][0])**2 + (point_list[i][1]-point_list[j][1])**2)**0.5\n            if length > max_length:\n                max_length = length\n    print(max_length)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    number_of_points = int(input())\n    point_list = []\n    for _ in range(number_of_points):\n        point_list.append(list(map(float, input().split())))\n    max_length = 0\n    for i in range(number_of_points-1):\n        for j in range(i+1, number_of_points):\n            length = ((point_list[i][0]-point_list[j][0])**2 + (point_list[i][1]-point_list[j][1])**2)**0.5\n            if length > max_length:\n                max_length = length\n    print(max_length)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650456993,
  "object": "edit"
}
2022-04-20 12:16:35.236463 fix syntax errors 2 ['\ndef main():\n    number_of_points = int(input())\n    point_list = []\n    for _ in range(number_of_points):\n        point_list.append(list(map(float, input().split())))\n    max_length = 0\n    for i in range(number_of_points-1):\n        for j in range(i+1, number_of_points):\n            length = ((point_list[i][0]-point_list[j][0])**2 + (point_list[i][1]-point_list[j][1])**2)**0.5\n            if length > max_length:\n                max_length = length\n    print(max_length)\n\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    number_of_points = int(input())\n    point_list = []\n    for _ in range(number_of_points):\n        point_list.append(list(map(float, input().split())))\n    max_length = 0\n    for i in range(number_of_points-1):\n        for j in range(i+1, number_of_points):\n            length = ((point_list[i][0]-point_list[j][0])**2 + (point_list[i][1]-point_list[j][1])**2)**0.5\n            if length > max_length:\n                max_length = length\n    print(max_length)\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-20 12:16:35.236494 size on output set 1
2022-04-20 12:16:35.236519 num operations 1
2022-04-20 12:16:35.236525 size on input set 1
2022-04-20 12:16:35.236679 using api key sunu
2022-04-20 12:16:41.600455 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\n\ndef read_data(file_name):\n\tS = []\n\twith open(file_name, 'r') as file:\n\t\tn = int(file.readline().strip())\n\t\tfor i in range(n):\n\t\t\tx, y = [float(x) for x in file.readline().strip().split()]\n\t\t\tS.append((x,y))\n\treturn S\n\ndef is_left(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef area(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef convex_hull(S):\n\tn = len(S)\n\tS.sort()\n\tP = [S[0],S[1]]\n\tfor i in range(2,n):\n\t\twhile len(P)>1 and is_left(P[-2],P[-1],S[i])<=0:\n\t\t\tP.pop()\n\t\tP.append(S[i])\n\tU = [P[-1],P[0]]\n\tfor i in range(n-2,-1,-1):\n\t\twhile len(U)>1 and is_left(U[-2],U[-1],S[i])<=0:\n\t\t\tU.pop()\n\t\tU.append(S[i])\n\treturn P,U\n\ndef find_angle(S):\n\tn = len(S)\n\tif n<=2:\n\t\treturn 0\n\tP,U = convex_hull(S)\n\tA = 0\n\tfor i in range(len(P)-1):\n\t\tA += area(P[i],P[i+1],U[i])\n\tA += area(P[-1],P[0],U[-1])\n\tA = abs(A)/2\n\tarea_sum = 0\n\tfor i in range(len(P)-1):\n\t\tarea_sum += area(P[i],P[i+1],(0,0))\n\tarea_sum += area(P[-1],P[0],(0,0))\n\tarea_sum = abs(area_sum)/2\n\treturn A/area_sum\n\nS = read_data(sys.argv[1])\nprint(find_angle(S))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\n\ndef read_data(file_name):\n\tS = []\n\twith open(file_name, 'r') as file:\n\t\tn = int(file.readline().strip())\n\t\tfor i in range(n):\n\t\t\tx, y = [float(x) for x in file.readline().strip().split()]\n\t\t\tS.append((x,y))\n\treturn S\n\ndef is_left(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef area(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef convex_hull(S):\n\tn = len(S)\n\tS.sort(key=lambda x: (x[0],x[1]))\n\tP = [S[0],S[1]]\n\tfor i in range(2,n):\n\t\twhile len(P)>1 and is_left(P[-2],P[-1],S[i])>=0:\n\t\t\tP.pop()\n\t\tP.append(S[i])\n\tU = [P[-1],P[0]]\n\tfor i in range(n-2,-1,-1):\n\t\twhile len(U)>1 and is_left(U[-2],U[-1],S[i])>=0:\n\t\t\tU.pop()\n\t\tU.append(S[i])\n\treturn P,U\n\ndef find_angle(S):\n\tn = len(S)\n\tif n<=2:\n\t\treturn 0\n\tP,U = convex_hull(S)\n\tA = 0\n\tfor i in range(len(P)-1):\t\n\t\tA += area(P[i],P[i+1],U[i])\n\tA += area(P[-1],P[0],U[-1])\n\tA = abs(A)/2\t\n\tarea_sum = 0\n\tfor i in range(len(P)-1):\n\t\tarea_sum += area(P[i],P[i+1],(0,0))\n\tarea_sum += area(P[-1],P[0],(0,0))\n\tarea_sum = abs(area_sum)/2\n\treturn A/area_sum\t\n\nS = read_data(sys.argv[1])\nprint(find_angle(S))\n"
    }
  ],
  "created": 1650456995,
  "object": "edit"
}
2022-04-20 12:16:41.600686 fix syntax errors 2 ["\nimport sys\nimport math\n\ndef read_data(file_name):\n\tS = []\n\twith open(file_name, 'r') as file:\n\t\tn = int(file.readline().strip())\n\t\tfor i in range(n):\n\t\t\tx, y = [float(x) for x in file.readline().strip().split()]\n\t\t\tS.append((x,y))\n\treturn S\n\ndef is_left(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef area(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef convex_hull(S):\n\tn = len(S)\n\tS.sort()\n\tP = [S[0],S[1]]\n\tfor i in range(2,n):\n\t\twhile len(P)>1 and is_left(P[-2],P[-1],S[i])<=0:\n\t\t\tP.pop()\n\t\tP.append(S[i])\n\tU = [P[-1],P[0]]\n\tfor i in range(n-2,-1,-1):\n\t\twhile len(U)>1 and is_left(U[-2],U[-1],S[i])<=0:\n\t\t\tU.pop()\n\t\tU.append(S[i])\n\treturn P,U\n\ndef find_angle(S):\n\tn = len(S)\n\tif n<=2:\n\t\treturn 0\n\tP,U = convex_hull(S)\n\tA = 0\n\tfor i in range(len(P)-1):\n\t\tA += area(P[i],P[i+1],U[i])\n\tA += area(P[-1],P[0],U[-1])\n\tA = abs(A)/2\n\tarea_sum = 0\n\tfor i in range(len(P)-1):\n\t\tarea_sum += area(P[i],P[i+1],(0,0))\n\tarea_sum += area(P[-1],P[0],(0,0))\n\tarea_sum = abs(area_sum)/2\n\treturn A/area_sum\n\nS = read_data(sys.argv[1])\nprint(find_angle(S))\n", "\n\nimport sys\nimport math\n\ndef read_data(file_name):\n\tS = []\n\twith open(file_name, 'r') as file:\n\t\tn = int(file.readline().strip())\n\t\tfor i in range(n):\n\t\t\tx, y = [float(x) for x in file.readline().strip().split()]\n\t\t\tS.append((x,y))\n\treturn S\n\ndef is_left(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef area(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef convex_hull(S):\n\tn = len(S)\n\tS.sort(key=lambda x: (x[0],x[1]))\n\tP = [S[0],S[1]]\n\tfor i in range(2,n):\n\t\twhile len(P)>1 and is_left(P[-2],P[-1],S[i])>=0:\n\t\t\tP.pop()\n\t\tP.append(S[i])\n\tU = [P[-1],P[0]]\n\tfor i in range(n-2,-1,-1):\n\t\twhile len(U)>1 and is_left(U[-2],U[-1],S[i])>=0:\n\t\t\tU.pop()\n\t\tU.append(S[i])\n\treturn P,U\n\ndef find_angle(S):\n\tn = len(S)\n\tif n<=2:\n\t\treturn 0\n\tP,U = convex_hull(S)\n\tA = 0\n\tfor i in range(len(P)-1):\t\n\t\tA += area(P[i],P[i+1],U[i])\n\tA += area(P[-1],P[0],U[-1])\n\tA = abs(A)/2\t\n\tarea_sum = 0\n\tfor i in range(len(P)-1):\n\t\tarea_sum += area(P[i],P[i+1],(0,0))\n\tarea_sum += area(P[-1],P[0],(0,0))\n\tarea_sum = abs(area_sum)/2\n\treturn A/area_sum\t\n\nS = read_data(sys.argv[1])\nprint(find_angle(S))\n"]
2022-04-20 12:16:41.600752 size on output set 2
2022-04-20 12:16:41.600767 num operations 1
2022-04-20 12:16:41.600773 size on input set 1
2022-04-20 12:16:41.600928 using api key kouti
2022-04-20 12:16:45.742348 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\nimport sys\nfrom math import atan2, degrees\n\n# This function is taken from https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# Given three colinear points p, q, r, the function checks if\n\n\n# point q lies on line segment 'pr'\ndef onSegment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are colinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p, q, r):\n    # See https://www.geeksforgeeks.org/orientation-3-ordered-points/\n    # for details of below formula.\n    val = (float(q[1]) - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if (val > 0):\n        # Clockwise orientation\n        return 1\n    elif (val < 0):\n        # Counterclockwise orientation\n        return 2\n    else:\n        # Colinear orientation\n        return 0\n\n# The main function that returns true if line segment 'p1q1'\n# and 'p2q2' intersect.\ndef doIntersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general and\n    # special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if (o1 != o2 and o3 != o4):\n        return True\n\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 and onSegment(p1, p2, q1)):\n        return True\n\n    # p1, q1 and q2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 and onSegment(p1, q2, q1)):\n        return True\n\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 and onSegment(p2, p1, q2)):\n        return True\n\n     # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 and onSegment(p2, q1, q2)):\n        return True\n\n    # Doesn't fall in any of the above cases\n    return False\n\ndef get_angle(p, q):\n    x = q[0] - p[0]\n    y = q[1] - p[1]\n    return degrees(atan2(y, x))\n\ndef get_min_angle_diff(points):\n    angles = []\n    for i in range(len(points)):\n        angles.append(get_angle(points[0], points[i]))\n    angles.sort()\n    min_diff = float('inf')\n    for i in range(len(angles) - 1):\n        diff = angles[i+1] - angles[i]\n        if diff < min_diff:\n            min_diff = diff\n    diff = angles[0] - angles[-1] + 360\n    if diff < min_diff:\n        min_diff = diff\n    return min_diff\n\n\ndef main():\n    num_points = int(input())\n    points = []\n    for i in range(num_points):\n        line = sys.stdin.readline()\n        points.append(list(map(float, line.split())))\n\n    min_angle_diff = float('inf')\n    for i in range(num_points):\n        for j in range(num_points):\n            if i == j:\n                continue\n            p1 = points[i]\n            p2 = points[j]\n            q1 = [p1[0] + 1, p1[1]]\n            q2 = [p2[0] + 1, p2[1]]\n            intersects = False\n            for k in range(num_points):\n                if k == i or k == j:\n                    continue\n                for l in range(k+1, num_points):\n                    if l == i or l == j:\n                        continue\n                    if doIntersect(p1, q1, points[k], points[l]):\n                        intersects = True\n                        break\n                    if doIntersect(p2, q2, points[k], points[l]):\n                        intersects = True\n                        break\n                if intersects:\n                    break\n            if not intersects:\n                angle_diff = get_min_angle_diff(points)\n                if angle_diff < min_angle_diff:\n                    min_angle_diff = angle_diff\n    print('{0:.3f}'.format(min_angle_diff))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python3\n\nimport sys\nfrom math import atan2, degrees\n\n# This function is taken from https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# Given three colinear points p, q, r, the function checks if\n# point q lies on line segment 'pr'\ndef onSegment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are colinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p, q, r):\n    # See https://www.geeksforgeeks.org/orientation-3-ordered-points/\n    # for details of below formula.\n    val = (float(q[1]) - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if (val > 0):\n        # Clockwise orientation\n        return 1\n    elif (val < 0):\n        # Counterclockwise orientation\n        return 2\n    else:\n        # Colinear orientation\n        return 0\n\n# The main function that returns true if line segment 'p1q1'\n# and 'p2q2' intersect.\ndef doIntersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general and\n    # special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if (o1 != o2 and o3 != o4):\n        return True\n\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 and onSegment(p1, p2, q1)):\n        return True\n\n    # p1, q1 and q2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 and onSegment(p1, q2, q1)):\n        return True\n\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 and onSegment(p2, p1, q2)):\n        return True\n\n     # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 and onSegment(p2, q1, q2)):\n        return True\n\n    # Doesn't fall in any of the above cases\n    return False\n\ndef get_angle(p, q):\n    x = q[0] - p[0]\n    y = q[1] - p[1]\n    return degrees(atan2(y, x))\n\ndef get_min_angle_diff(points):\n    angles = []\n    for i in range(len(points)):\n        angles.append(get_angle(points[0], points[i]))\n    angles.sort()\n    min_diff = float('inf')\n    for i in range(len(angles) - 1):\n        diff = angles[i+1] - angles[i]\n        if diff < min_diff:\n            min_diff = diff\n    diff = angles[0] - angles[-1] + 360\n    if diff < min_diff:\n        min_diff = diff\n    return min_diff\n\n\ndef main():\n    num_points = int(input())\n    points = []\n    for i in range(num_points):\n        line = sys.stdin.readline().strip()\n        points.append(list(map(float, line.split())))\n\n    min_angle_diff = float('inf')\n    for i in range(num_points):\n        for j in range(num_points):\n            if i == j:\n                continue\n            p1 = points[i]\n            p2 = points[j]\n            q1 = [p1[0] + 1, p1[1]]\n            q2 = [p2[0] + 1, p2[1]]\n            intersects = False\n            for k in range(num_points):\n                if k == i or k == j:\n                    continue\n                for l in range(k+1, num_points):\n                    if l == i or l == j:\n                        continue\n                    if doIntersect(p1, q1, points[k], points[l]):\n                        intersects = True\n                        break\n                    if doIntersect(p2, q2, points[k], points[l]):\n                        intersects = True\n                        break\n                if intersects:\n                    break\n            if not intersects:\n                angle_diff = get_min_angle_diff(points)\n                if angle_diff < min_angle_diff:\n                    min_angle_diff = angle_diff\n    print('{0:.3f}'.format(min_angle_diff))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650457001,
  "object": "edit"
}
2022-04-20 12:16:45.742739 fix syntax errors 2 ["\n\n\nimport sys\nfrom math import atan2, degrees\n\n# This function is taken from https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# Given three colinear points p, q, r, the function checks if\n\n\n# point q lies on line segment 'pr'\ndef onSegment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are colinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p, q, r):\n    # See https://www.geeksforgeeks.org/orientation-3-ordered-points/\n    # for details of below formula.\n    val = (float(q[1]) - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if (val > 0):\n        # Clockwise orientation\n        return 1\n    elif (val < 0):\n        # Counterclockwise orientation\n        return 2\n    else:\n        # Colinear orientation\n        return 0\n\n# The main function that returns true if line segment 'p1q1'\n# and 'p2q2' intersect.\ndef doIntersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general and\n    # special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if (o1 != o2 and o3 != o4):\n        return True\n\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 and onSegment(p1, p2, q1)):\n        return True\n\n    # p1, q1 and q2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 and onSegment(p1, q2, q1)):\n        return True\n\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 and onSegment(p2, p1, q2)):\n        return True\n\n     # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 and onSegment(p2, q1, q2)):\n        return True\n\n    # Doesn't fall in any of the above cases\n    return False\n\ndef get_angle(p, q):\n    x = q[0] - p[0]\n    y = q[1] - p[1]\n    return degrees(atan2(y, x))\n\ndef get_min_angle_diff(points):\n    angles = []\n    for i in range(len(points)):\n        angles.append(get_angle(points[0], points[i]))\n    angles.sort()\n    min_diff = float('inf')\n    for i in range(len(angles) - 1):\n        diff = angles[i+1] - angles[i]\n        if diff < min_diff:\n            min_diff = diff\n    diff = angles[0] - angles[-1] + 360\n    if diff < min_diff:\n        min_diff = diff\n    return min_diff\n\n\ndef main():\n    num_points = int(input())\n    points = []\n    for i in range(num_points):\n        line = sys.stdin.readline()\n        points.append(list(map(float, line.split())))\n\n    min_angle_diff = float('inf')\n    for i in range(num_points):\n        for j in range(num_points):\n            if i == j:\n                continue\n            p1 = points[i]\n            p2 = points[j]\n            q1 = [p1[0] + 1, p1[1]]\n            q2 = [p2[0] + 1, p2[1]]\n            intersects = False\n            for k in range(num_points):\n                if k == i or k == j:\n                    continue\n                for l in range(k+1, num_points):\n                    if l == i or l == j:\n                        continue\n                    if doIntersect(p1, q1, points[k], points[l]):\n                        intersects = True\n                        break\n                    if doIntersect(p2, q2, points[k], points[l]):\n                        intersects = True\n                        break\n                if intersects:\n                    break\n            if not intersects:\n                angle_diff = get_min_angle_diff(points)\n                if angle_diff < min_angle_diff:\n                    min_angle_diff = angle_diff\n    print('{0:.3f}'.format(min_angle_diff))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\nfrom math import atan2, degrees\n\n# This function is taken from https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# Given three colinear points p, q, r, the function checks if\n# point q lies on line segment 'pr'\ndef onSegment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are colinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p, q, r):\n    # See https://www.geeksforgeeks.org/orientation-3-ordered-points/\n    # for details of below formula.\n    val = (float(q[1]) - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if (val > 0):\n        # Clockwise orientation\n        return 1\n    elif (val < 0):\n        # Counterclockwise orientation\n        return 2\n    else:\n        # Colinear orientation\n        return 0\n\n# The main function that returns true if line segment 'p1q1'\n# and 'p2q2' intersect.\ndef doIntersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general and\n    # special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if (o1 != o2 and o3 != o4):\n        return True\n\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 and onSegment(p1, p2, q1)):\n        return True\n\n    # p1, q1 and q2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 and onSegment(p1, q2, q1)):\n        return True\n\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 and onSegment(p2, p1, q2)):\n        return True\n\n     # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 and onSegment(p2, q1, q2)):\n        return True\n\n    # Doesn't fall in any of the above cases\n    return False\n\ndef get_angle(p, q):\n    x = q[0] - p[0]\n    y = q[1] - p[1]\n    return degrees(atan2(y, x))\n\ndef get_min_angle_diff(points):\n    angles = []\n    for i in range(len(points)):\n        angles.append(get_angle(points[0], points[i]))\n    angles.sort()\n    min_diff = float('inf')\n    for i in range(len(angles) - 1):\n        diff = angles[i+1] - angles[i]\n        if diff < min_diff:\n            min_diff = diff\n    diff = angles[0] - angles[-1] + 360\n    if diff < min_diff:\n        min_diff = diff\n    return min_diff\n\n\ndef main():\n    num_points = int(input())\n    points = []\n    for i in range(num_points):\n        line = sys.stdin.readline().strip()\n        points.append(list(map(float, line.split())))\n\n    min_angle_diff = float('inf')\n    for i in range(num_points):\n        for j in range(num_points):\n            if i == j:\n                continue\n            p1 = points[i]\n            p2 = points[j]\n            q1 = [p1[0] + 1, p1[1]]\n            q2 = [p2[0] + 1, p2[1]]\n            intersects = False\n            for k in range(num_points):\n                if k == i or k == j:\n                    continue\n                for l in range(k+1, num_points):\n                    if l == i or l == j:\n                        continue\n                    if doIntersect(p1, q1, points[k], points[l]):\n                        intersects = True\n                        break\n                    if doIntersect(p2, q2, points[k], points[l]):\n                        intersects = True\n                        break\n                if intersects:\n                    break\n            if not intersects:\n                angle_diff = get_min_angle_diff(points)\n                if angle_diff < min_angle_diff:\n                    min_angle_diff = angle_diff\n    print('{0:.3f}'.format(min_angle_diff))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 12:16:45.742840 size on output set 2
