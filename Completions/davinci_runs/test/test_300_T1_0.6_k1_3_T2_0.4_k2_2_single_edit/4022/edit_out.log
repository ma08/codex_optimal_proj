2022-04-20 11:29:41.627432 num operations 1
2022-04-20 11:29:41.627463 size on input set 1
2022-04-20 11:29:41.627657 using api key kouti
2022-04-20 11:29:49.702841 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point.\n    segments = sorted(segments, key=lambda x: x[0])\n\n    # Find the intersection of all segments.\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length.\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one.\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650454181,
  "object": "edit"
}
2022-04-20 11:29:49.703129 fix syntax errors 2 ["\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point.\n    segments = sorted(segments, key=lambda x: x[0])\n\n    # Find the intersection of all segments.\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length.\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one.\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection.\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection.\n            continue\n        else:\n            # The segment intersects the intersection.\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 11:29:49.703287 size on output set 2
2022-04-20 11:29:49.703308 num operations 1
2022-04-20 11:29:49.703315 size on input set 1
2022-04-20 11:29:49.703482 using api key sourya
2022-04-20 11:29:52.256409 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\n\nmain()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n"
    }
  ],
  "created": 1650454189,
  "object": "edit"
}
2022-04-20 11:29:52.256633 fix syntax errors 2 ['\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\n\nmain()\n', '\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n']
2022-04-20 11:29:52.256669 size on output set 2
2022-04-20 11:29:52.256681 num operations 1
2022-04-20 11:29:52.256688 size on input set 1
2022-04-20 11:29:52.256897 using api key sourya
2022-04-20 11:29:55.373569 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    # n = 3\n    n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n = next(reader)\n    segments = list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650454192,
  "object": "edit"
}
2022-04-20 11:29:55.373821 fix syntax errors 2 ['\nfrom random import randint\nimport sys\n\ndef test_data():\n    """ Generates a test case with n segments. """\n\n    # n = 3\n    n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    """ Returns the maximum length of the intersection of n - 1 segments. """\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n = next(reader)\n    segments = list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == "__main__":\n    main()\n', '\nfrom random import randint\nimport sys\n\ndef test_data():\n    """ Generates a test case with n segments. """\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    """ Returns the maximum length of the intersection of n - 1 segments. """\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == "__main__":\n    main()\n']
2022-04-20 11:29:55.376093 size on output set 2
