["n = int(input())\na = list(map(int, input().split()))\na = [0] + a\nfor i in range(1, n):\n  a[i] += a[i - 1]\nmi = min(a)\na = list([x - mi + 1 for x in a])\nprint(-1 if set(a) != set(range(1, n + 1)) else ' '.join(map(str, a)))\n", "n = int(input())\n\nq = list(map(int, input().split()))\n\np = [0]\nfor diff in q:\n\tp.append(p[-1] + diff)\n\nlowest = min(p)\nmod = 1 - lowest\n\na = [x + mod for x in p]\n\nif sorted(a) == list(range(1, n+1)):\n\tprint(*a)\nelse:\n\tprint(-1)", "def main():\n  n=int(input())\n  arr=input().split()\n  store=[1]\n  mini=1\n  for x in range(n-1):\n    arr[x]=int(arr[x])\n    store.append(store[-1]+arr[x])\n    mini=min(mini,store[-1])\n  for x in range(n):\n    store[x]-=mini-1\n  test=store.copy()\n  test.sort()\n  bo=True\n  for x in range(n-1):\n    if test[x+1]-test[x]!=1:\n      bo=False\n      break\n  if bo:\n    for x in range(n):\n      print(store[x],end=\" \")\n  else:\n    print(-1)\nmain()\n", "import sys\ninput = sys.stdin.readline\n\n\nn=int(input())\nQ=list(map(int,input().split()))\n\nP=[0]\nfor q in Q:\n    P.append(P[-1]+q)\nMIN=min(P)\n\nP2=[p+1-MIN for p in P]\n\nP3=sorted(P2)\n\nif P3==list(range(1,n+1)):\n    print(*P2)\nelse:\n    print(-1)\n", "n = int(input())\nq = list(map(int, input().split()))\nr = 0\np = [0] * n\nfor i in range(len(q)):\n    r += (i + 1) * q[i]\nif (r + (n + 1) * n // 2) % n == 0:\n    p[n - 1] = (r + (n + 1) * n // 2) // n\n    s = sum(q)\n    for i in range(n - 1):\n        p[i] = p[n - 1] - s\n        s -= q[i]\n    if sorted(p) == list(range(1, n + 1)):\n        print(*p)\n    else:\n        print(-1)\nelse:\n    print(-1)\n", "def __starting_point():\n    n = input()\n    a = list(map(int, input().split()))\n    b = [0]\n    for ai in a:\n        b.append(b[-1] + ai)\n    b.sort()\n    \n    for i in range(1, len(b)):\n        if b[i - 1] + 1 != b[i]:\n            print(-1)\n            break\n    else:\n        zero_idx = b.index(0)\n        x = zero_idx + 1\n        res = [x]\n        for ai in a:\n            res.append(res[-1] + ai)\n        print(' '.join(map(str, res)))\n\n__starting_point()", "ii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nn = ii()\na = li()\nb = [0]\nfor x in a:\n    b.append(b[-1] + x)\nmn = min(b)\nb = [x - mn + 1 for x in b]\nif sorted(b) == list(range(1, n + 1)):\n    print(*b)\nelse:\n    print(-1)", "n = int(input())\nq = list(map(int, input().split()))\na = [0 for i in range(n)]\nfor i in range(n - 1):\n    a[i + 1] = q[i] + a[i]\nmn = min(a)\nfor i in range(n):\n    a[i] = a[i] - mn + 1\nif len(set(a)) != n or max(a) > n:\n    print(-1)\nelse:\n    print(*a)", "n = int(input())\nA = [int(x) for x in input().split()]\n\nP = [0]\nfor a in A:\n    P.append(P[-1]+a)\n\nmn = min(P)\nP = [p-mn+1 for p in P]\n\nif set(range(1,n+1)) == set(P):\n    print(*P)\nelse:\n    print(-1)\n", "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nn = mint()\nq = list(mints())\na = [0]*n\nfor i in range(0,n-1):\n\ta[i+1] = a[i] + q[i]\nm = min(a)\nfor i in range(n):\n\ta[i] -= m - 1\nif max(a) != n or len(set(a)) != n:\n\tprint(-1)\nelse:\n\tprint(*a)\n", "# # Soru 1\n#\n# nm = list(map(int, input().split()))\n# n = nm[0]\n# m = nm[1]\n#\n# if int(m/n) != m/n:\n#     print(-1)\n# elif m/n == 1:\n#     print(0)\n# else:\n#     x = m//n\n#     count = 0\n#     while x%2 == 0:\n#         x = x//2\n#         count += 1\n#     while x%3 == 0:\n#         x = x//3\n#         count += 1\n#     if x != 1:\n#         print(-1)\n#     else:\n#         print(count)\n# Soru 2\n# n = int(input())\n# lst = list(map(int, input().split()))\n# lst = lst + lst\n# count = 0\n# large = 0\n# for i in lst:\n#     if i == 1:\n#         count += 1\n#     else:\n#         if count > large:\n#             large = count\n#         count = 0\n# print(large)\n# Soru 3\nn = int(input())\nlst = list(map(int, input().split()))\n\nperm = [0]\nx = 0\nfor i in lst:\n    perm.append(perm[x] + i)\n    x += 1\nk = 1- min(perm)\nfor i in range(n):\n    perm[i] += k\ns_perm = sorted(perm)\nk = 1\nfor i in s_perm:\n    if i != k:\n        print(-1)\n        quit()\n    k+= 1\nprint(*perm)\n\n\n", "n = int(input())\nq = list(map(int, input().split()))\np = list(range(n))\np[0] = 0\nminp = 0\nfor i in range(1, n):\n    p[i] = q[i - 1] + p[i - 1]\n    if p[i] < minp:\n        minp = p[i]\nminp = -minp\nfor i in range(n):\n    p[i] += minp + 1\nsp = sorted(p)\nif sp[0] != 1:\n    print(-1)\nelse:\n    fail = 0\n    for i in range(1, n):\n        if sp[i] != sp[i - 1] + 1:\n            fail = 1\n            break\n    if fail:\n        print(-1)\n    else:\n        print(*p)\n\n", "#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\n\nisdebug = False\ntry :\n    #raise ModuleNotFoundError\n    import pylint\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\n    isdebug = True\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\ndef red_inout():\n    inId = 0\n    outId = 0\n    if not isdebug:\n        inId = 0\n        outId = 0\n    if inId>0:\n        dprint('use input', inId)\n        try:\n            f = open('input'+ str(inId) + '.txt', 'r')\n            sys.stdin = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n        except Exception:\n            dprint('invalid input file')\n    if outId>0:\n        dprint('use output', outId)\n        try:\n            f = open('stdout'+ str(outId) + '.txt', 'w')\n            sys.stdout = f #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n        except Exception:\n            dprint('invalid output file')\n            \n        atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n\nif isdebug and len(sys.argv) == 1:\n    red_inout()\n\ndef getIntList():\n    return list(map(int, input().split()))            \n\ndef solve(): \n    pass\n    \nT_ = 1    \n#T_, = getIntList()\n\nfor iii_ in range(T_):\n    #solve()\n    N,  = getIntList()\n    #print(N)\n    zd  = getIntList()\n    tot = 0\n    big = -1\n    for x in zd:\n        tot +=x\n        big = max(big,tot)\n    if big<-1 or big ==0 or big >=N:\n        print(-1)\n        break\n    if big<0:\n        a = N\n    else:\n        a = N-big\n    zr = [a for i in range(N)]\n    vis = [False for i in range(N+1)]\n    vis[a] = True\n    ok = True\n    for i in range(1,N):\n        zr[i] = zr[i-1] + zd[i-1]\n        if zr[i]<1 or zr[i] >N:\n            ok = False\n            break\n        if (vis[zr[i]]) :\n            ok = False\n            break\n        vis[zr[i]] = True\n    if not ok:\n        print(-1)\n        break\n    for i in range(N):    \n        zr[i] = str(zr[i])\n    r = ' '.join(zr)\n    print(r)\n", "n = int(input())\na=list(map(int, input().split()))\np = [0] * n\nfor i in range(n - 2, -1, -1):\n    p[i] = p[i+1]-a[i]\nw = max(p)\nw = n-w\nfor i in range(len(p)):\n    p[i]+=w\nif list(sorted(p))==[i for i in range(1 ,n+1)]:\n    print(*p)\nelse:\n    print(-1)", "n = int(input())\nnums = [int(x) for x in input().split()]\nres = [0]\nfor nu in nums:\n\tres.append(res[-1]+nu)\nmi = min(res)\nresp = [r-mi+1 for r in res]\nse = set(resp)\nif max(resp) == len(resp) and len(resp)==len(se):\n\tprint(*resp)\nelse:\n\tprint(-1)", "from itertools import accumulate\nn = int( input())\nQ = list( map( int, input().split()))\nP = list( accumulate([0] + Q))\nm = min(P) - 1\nANS = list( [x-m for x in P])\nV = [0]*n\nans = 1\nfor i in range(n):\n    if ANS[i] <= n:\n        if V[ANS[i]-1] == 1:\n            ans = 0\n            break\n        V[ANS[i]-1] = 1\n    else:\n        ans = 0\nif ans == 1:\n    print(\" \".join( map( str, ANS)))\nelse:\n    print(-1)\n", "n = int(input())\nq = [int(x) for x in input().split()]\n\na = [0]\nlast = 0\nm = 0\nmx = 0\nallNum = {0}\nfor x in q:\n  last += x\n  a.append(last)\n  m = min(m, last)\n  mx = max(mx, last)\n  allNum.add(last)\n\nif mx-m+1 != n or len(allNum) != n:\n  print(-1)\nelse:\n  a = [str(x-m+1) for x in a]\n  print(\" \".join(a))\n", "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/19 22:45\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : C. Polycarp Restores Permutation.py\n\n\ndef main():\n    n = int(input())\n    q = list(map(int, input().split()))\n\n    c = q.copy()\n    for i in range(1, n - 1):\n        c[i] += c[i - 1]\n\n    q = [0] * n\n    q[0] = max(1, 1 - min(c))\n    for i in range(1, n):\n        q[i] = c[i - 1] + q[0]\n\n    s = set()\n    for x in q:\n        if x < 1 or x > n or x in s:\n            print(-1)\n            return\n        s.add(x)\n    print(*q)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\narr = [int(x) for x in input().split()]\nnew = [0]\nfor i in arr:\n    new.append(i + new[-1])\nk = min(new)\nif max(new) - min(new) + 1 != n or len(set(new)) != n:\n    print(-1)\nelse:\n    for i in new:\n        print(i - k + 1, end=' ')", "\nn = int(input())\na = [int(i) for i in input().split()]\nst = 0\nb = [st]\nmx = st\nfor el in a:\n    st += el\n    mx = max(st, mx)\n    b.append(st)\nx = n - 1 - mx\nused = [1] * n\nfor el in b:\n    if 0 <= el + x <= n - 1:\n        used[el + x] = 0\n    else:\n        print(-1)\n        return\nif sum(used) == 0:\n    for el in b:\n        print(el + x + 1, end = ' ')\nelse:\n    print(-1)", "n = int(input())\nq = list(map(int, input().split()))\n\np = [0] * n\n\nfor i in range(n - 1):\n    p[i + 1] = p[i] + q[i]\nmin_in_p = min(p) - 1\n\np2 = [x - min_in_p for x in p]\n\nif sorted(p2) == [x for x in range(1, n + 1)]:\n    print(' '.join(map(str, p2)))\nelse:\n    print(-1)", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\nfrom math import factorial\n\ndef main():\n    n = get_int()\n    li = get_list()\n    peak,trough = 0,0\n    k = 0\n    for i in li:\n        k+=i\n        if k>0:\n            peak=max(peak,k)\n        else:\n            trough=min(trough,k)\n\n    if peak-trough+1<=n:\n        res = [-trough+1]\n        \n        for i in li:\n            res.append(i+res[-1])\n        display_list(res) if len(set(res))==len(res) else(print(-1))\n    else:\n        print(-1)\n\n\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n = int(input())\nq = list(map(int, input().split()))\nans = [0 for i in range(n)]\nans[0] = 1\nfor i in range(1, n):\n    ans[i] = ans[i - 1] + q[i - 1]\nt = 1 - min(ans)\nb = [i for i in range(1, n + 1)]\nx = set(b)\nann = []\nfor i in ans:\n    ann.append(i + t)\n    x.discard(i + t)\nif len(x):\n    print(-1)\nelse:\n    print(*ann)", "n = int(input())\na = [int(t) for t in input().split(' ')]\nb = [0] * n\nb[1] = a[0]\nfor i in range(0, n-1):\n    b[i+1] = b[i] + a[i]\n\nm = min(b)\nfor i in range(n):\n    b[i] -= m\n    b[i] += 1\n\nif len(set(b)) != n or any(t > n or t < 1 for t in b):\n    print(-1)\nelse:\n    print(*b)\n", "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\n# prime = 998244353 \nINF = 100_000_000\n# from heapq import heappush, heappop\nfrom collections import defaultdict\nt = 1#int(input())\n# from math import sqrt\n\n\nfor test in range(t):\n    n = int(input())\n    # n,m = (map(int, input().split()))\n    # a = []\n    # for i in range(n):\n    q = (list((list(map(int, input().split())))))\n\n    p = [n for i in range(n)]\n\n    for i in range(1, n):\n        p[i] = q[i-1]+p[i-1]\n    \n    t = list(p)\n    t.sort()\n    tmp = t[0]-1\n    ans = 0\n    for i in range(n):\n        p[i] = p[i]-tmp\n        if t[i]-tmp!=i+1:\n            ans=-1\n            break\n    if ans==-1:\n        print(ans)\n    else:\n        print(*p)\n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\n"]