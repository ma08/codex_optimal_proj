["let fs = require('fs');\n\nfs.writeFileSync('test.txt', 'Hello world');\n\nlet fileContents = fs.readFileSync('test.txt');\nconsole.log(fileContents.toString());\n\n// fs.writeFile('test.txt', 'Hello world', (err) => {\n//   if (err) {\n//     console.log(err);\n//   }\n// });\n\n// fs.readFile('test.txt', (err, data) => {\n//   if (err) {\n//     console.log(err);\n//   }\n//   console.log(data.toString());\n// });\n", "from datetime import datetime\nfrom datetime import timedelta\nimport os\n\n\nclass File:\n    def __init__(self, definition):\n        self.definition = definition\n        self.name = definition.get('name')\n        self.path = definition.get('path')\n        self.size = definition.get('size')\n        self.date = definition.get('date')\n        self.time = definition.get('time')\n        self.type = definition.get('type')\n\n    def __repr__(self):\n        return f'<File {self.name}>'\n\n    @property\n    def full_path(self):\n        return os.path.join(self.path, self.name)\n\n    @property\n    def date_time(self):\n        return datetime.strptime(f'{self.date} {self.time}', '%m/%d/%Y %H:%M:%S')\n\n    def is_older_than(self, days=0, hours=0, minutes=0, seconds=0):\n        age = timedelta(days=days, hours=hours, minutes=minutes, seconds=seconds)\n        return datetime.now() - age > self.date_time\n\n    def is_newer_than(self, days=0, hours=0, minutes=0, seconds=0):\n        age = timedelta(days=days, hours=hours, minutes=minutes, seconds=seconds)\n        return datetime.now() - age < self.date_time\n\n    def is_older_than_days(self, days):\n        return self.is_older_than(days=days)\n\n    def is_newer_than_days(self, days):\n        return self.is_newer_than(days=days)\n\n    def is_older_than_hours(self, hours):\n        return self.is_older_than(hours=hours)\n\n    def is_newer_than_hours(self, hours):\n        return self.is_newer_than(hours=hours)\n\n    def is_older_than_minutes(self, minutes):\n        return self.is_older_than(minutes=minutes)\n\n    def is_newer_than_minutes(self, minutes):\n        return self.is_newer_than(minutes=minutes)\n\n    def is_older_than_seconds(self, seconds):\n        return self.is_older_than(seconds=seconds)\n\n    def is_newer_than_seconds(self, seconds):\n        return self.is_newer_than(seconds=seconds)\n\n    def is_of_size(self, size):\n        return size == self.size\n\n    def is_of_type(self, type):\n        return type == self.type\n\n    def is_bigger_than(self, size):\n        return size < self.size\n\n    def is_smaller_than(self, size):\n        return size > self.size\n\n    def is_bigger_than_mb(self, size):\n        return size < self.size\n\n    def is_smaller_than_mb(self, size):\n        return size > self.size\n\n    def is_bigger_than_gb(self, size):\n        return size * 1024 < self.size\n\n    def is_smaller_than_gb(self, size):\n        return size * 1024 > self.size\n\n    def is_bigger_than_kb(self, size):\n        return size / 1024 < self.size\n\n    def is_smaller_than_kb(self, size):\n        return size / 1024 > self.size\n\n    def is_of_size_kb(self, size):\n        return size / 1024 == self.size\n\n    def is_of_size_mb(self, size):\n        return size == self.size\n\n    def is_of_size_gb(self, size):\n        return size * 1024 == self.size\n\n    def is_empty(self):\n        return self.size == 0\n\n    def is_not_empty(self):\n        return self.size != 0\n", "\nimport argparse\nimport os\nimport sys\nimport logging\nfrom collections import defaultdict\nfrom typing import List\n\nlogging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n# logging.disable(logging.CRITICAL)\n\n\ndef main(args):\n    lines = args.input_file.readlines()\n    n, m = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    segments = []\n    for i in range(m):\n        segments.append(tuple(map(int, lines[i + 2].split())))\n\n    max_diff = 0\n    max_indices = []\n    for i in range(m):\n        diff = 0\n        indices = []\n        for j in range(m):\n            if j == i:\n                continue\n\n            l, r = segments[j]\n            diff += sum(a[l - 1:r])\n            indices.append(j + 1)\n        if diff > max_diff:\n            max_diff = diff\n            max_indices = indices\n\n    with open(args.output_file, \"w\") as f:\n        f.write(str(max_diff) + \"\\n\")\n        f.write(str(len(max_indices)) + \"\\n\")\n        f.write(\" \".join(map(str, max_indices)) + \"\\n\")\n\n    return\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-i\", \"--input_file\", type=argparse.FileType(\"r\"), default=sys.stdin)\n    parser.add_argument(\"-o\", \"--output_file\", type=str, default=sys.stdout)\n    args = parser.parse_args()\n\n    main(args)\n"]