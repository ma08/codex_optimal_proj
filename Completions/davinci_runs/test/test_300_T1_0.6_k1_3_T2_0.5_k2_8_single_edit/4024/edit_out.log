2022-04-23 20:56:30.308989 num operations 1
2022-04-23 20:56:30.309013 size on input set 1
2022-04-23 20:56:30.309198 using api key kouti
2022-04-23 20:56:51.614748 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n\ndef minCost(s, k):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\nif __name__ == \"__main__\":\n  k = int(sys.stdin.readline().strip())\n  s = sys.stdin.readline().strip()\n  print(minCost(s, k))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys \nfrom collections import defaultdict \n \ndef minCost(n, k, s): \n  cost = 0 \n  while k > 0: \n    if k > len(s): \n      return -1 \n    if k == 1: \n      return cost + len(s) \n    counts = defaultdict(int) \n    for c in s: \n      counts[c] += 1 \n    maxCount = max(counts.values()) \n    cost += (len(s) - maxCount) \n    s = s[:maxCount] \n    k -= 1 \n  return cost \n \nif __name__ == \"__main__\": \n  n, k = map(int, sys.stdin.readline().strip().split()) \n  s = sys.stdin.readline().strip() \n  print(minCost(n, k, s)) \n"
    },
    {
      "index": 2,
      "text": "\nimport sys\nfrom collections import defaultdict\n\ndef minCost(n, k, s):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\nif __name__ == \"__main__\":\n  n, k = map(int, sys.stdin.readline().strip().split())\n  s = sys.stdin.readline().strip()\n  print(minCost(n, k, s))\n"
    },
    {
      "index": 3,
      "text": "import sys\nfrom collections import defaultdict\n\ndef minCost(n, k, s):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\nif __name__ == \"__main__\":\n  n, k = map(int, sys.stdin.readline().strip().split())\n  s = sys.stdin.readline().strip()\n  print(minCost(n, k, s))\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\nfrom collections import defaultdict\n\ndef minCost(n, k, s):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\nif __name__ == \"__main__\":\n  n, k = map(int, sys.stdin.readline().strip().split())\n  s = sys.stdin.readline().strip()\n  print(minCost(n, k, s))\n"
    },
    {
      "index": 5,
      "text": "\n\nimport sys\nfrom collections import defaultdict\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\nfrom collections import defaultdict\n\ndef minCost(n, k, s):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\n\nif __name__ == \"__main__\":\n  n, k = map(int, sys.stdin.readline().strip().split())\n  s = sys.stdin.readline().strip()\n  print(minCost(n, k, s))\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\nfrom collections import defaultdict\n\n\ndef min_cost(n, k, s):\n    cost = 0\n    while k > 0:\n        if k > len(s):\n            return -1\n        if k == 1:\n            return cost + len(s)\n        counts = defaultdict(int)\n        for c in s:\n            counts[c] += 1\n        max_count = max(counts.values())\n        cost += (len(s) - max_count)\n        s = s[:max_count]\n        k -= 1\n    return cost\n\nif __name__ == \"__main__\":\n    n, k = map(int, sys.stdin.readline().strip().split())\n    s = sys.stdin.readline().strip()\n    print(min_cost(n, k, s))\n"
    }
  ],
  "created": 1650747390,
  "object": "edit"
}
2022-04-23 20:56:51.615079 fix syntax errors 8 ['\n\nimport sys\nfrom collections import defaultdict\n\ndef minCost(s, k):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\nif __name__ == "__main__":\n  k = int(sys.stdin.readline().strip())\n  s = sys.stdin.readline().strip()\n  print(minCost(s, k))\n', '\nimport sys \nfrom collections import defaultdict \n \ndef minCost(n, k, s): \n  cost = 0 \n  while k > 0: \n    if k > len(s): \n      return -1 \n    if k == 1: \n      return cost + len(s) \n    counts = defaultdict(int) \n    for c in s: \n      counts[c] += 1 \n    maxCount = max(counts.values()) \n    cost += (len(s) - maxCount) \n    s = s[:maxCount] \n    k -= 1 \n  return cost \n \nif __name__ == "__main__": \n  n, k = map(int, sys.stdin.readline().strip().split()) \n  s = sys.stdin.readline().strip() \n  print(minCost(n, k, s)) \n', '\nimport sys\nfrom collections import defaultdict\n\ndef minCost(n, k, s):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\nif __name__ == "__main__":\n  n, k = map(int, sys.stdin.readline().strip().split())\n  s = sys.stdin.readline().strip()\n  print(minCost(n, k, s))\n', 'import sys\nfrom collections import defaultdict\n\ndef minCost(n, k, s):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\nif __name__ == "__main__":\n  n, k = map(int, sys.stdin.readline().strip().split())\n  s = sys.stdin.readline().strip()\n  print(minCost(n, k, s))\n', '\nimport sys\nfrom collections import defaultdict\n\ndef minCost(n, k, s):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\nif __name__ == "__main__":\n  n, k = map(int, sys.stdin.readline().strip().split())\n  s = sys.stdin.readline().strip()\n  print(minCost(n, k, s))\n', '\n\nimport sys\nfrom collections import defaultdict\n', '\n\nimport sys\n\nfrom collections import defaultdict\n\ndef minCost(n, k, s):\n  cost = 0\n  while k > 0:\n    if k > len(s):\n      return -1\n    if k == 1:\n      return cost + len(s)\n    counts = defaultdict(int)\n    for c in s:\n      counts[c] += 1\n    maxCount = max(counts.values())\n    cost += (len(s) - maxCount)\n    s = s[:maxCount]\n    k -= 1\n  return cost\n\n\nif __name__ == "__main__":\n  n, k = map(int, sys.stdin.readline().strip().split())\n  s = sys.stdin.readline().strip()\n  print(minCost(n, k, s))\n', '\nimport sys\nfrom collections import defaultdict\n\n\ndef min_cost(n, k, s):\n    cost = 0\n    while k > 0:\n        if k > len(s):\n            return -1\n        if k == 1:\n            return cost + len(s)\n        counts = defaultdict(int)\n        for c in s:\n            counts[c] += 1\n        max_count = max(counts.values())\n        cost += (len(s) - max_count)\n        s = s[:max_count]\n        k -= 1\n    return cost\n\nif __name__ == "__main__":\n    n, k = map(int, sys.stdin.readline().strip().split())\n    s = sys.stdin.readline().strip()\n    print(min_cost(n, k, s))\n']
2022-04-23 20:56:51.615205 size on output set 7
2022-04-23 20:56:51.615219 num operations 1
2022-04-23 20:56:51.615225 size on input set 1
2022-04-23 20:56:51.615351 using api key kouti
2022-04-23 20:57:07.697949 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    s = list(input())\n    count = 0\n    # print(s)\n    while len(s) > 0:\n        print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n,k = map(int,input().split())\n    s = list(input())\n    count = 0\n    while len(s) > 0:\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\ndef main():\n    n,k = map(int, input().split())\n    s = list(input())\n    count = 0\n    # print(s)\n    while len(s) > 0:\n        print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n,k = map(int,input().split())\n    s = list(input())\n    count = 0\n    while len(s) > 0:\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    s = list(input())\n    count = 0\n    # print(s)\n    while len(s) > 0:\n        print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n,k = map(int,input().split())\n    s = list(input())\n    count = 0\n    while len(s) > 0:\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\ndef main():\n    n, k = map(int, input().split())\n    s = list(input())\n    count = 0\n    print(s)\n    while len(s) > 0:\n        # print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    n,k = map(int,input().split())\n    s = list(input())\n    count = 0\n    print(s)\n    while len(s) > 0:\n        print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650747411,
  "object": "edit"
}
2022-04-23 20:57:07.698300 fix syntax errors 8 ['\n\ndef main():\n    n, k = map(int, input().split())\n    s = list(input())\n    count = 0\n    # print(s)\n    while len(s) > 0:\n        print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n,k = map(int,input().split())\n    s = list(input())\n    count = 0\n    while len(s) > 0:\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n,k = map(int, input().split())\n    s = list(input())\n    count = 0\n    # print(s)\n    while len(s) > 0:\n        print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n,k = map(int,input().split())\n    s = list(input())\n    count = 0\n    while len(s) > 0:\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    s = list(input())\n    count = 0\n    # print(s)\n    while len(s) > 0:\n        print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n,k = map(int,input().split())\n    s = list(input())\n    count = 0\n    while len(s) > 0:\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n, k = map(int, input().split())\n    s = list(input())\n    count = 0\n    print(s)\n    while len(s) > 0:\n        # print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n,k = map(int,input().split())\n    s = list(input())\n    count = 0\n    print(s)\n    while len(s) > 0:\n        print(s)\n        if len(s) >= 2:\n            if s[0] == s[1]:\n                # print(s[0])\n                count += 1\n                s = s[1:]\n            else:\n                count += n - 1\n                s = s[1:]\n        else:\n            count += n - 1\n            s = s[1:]\n    print(count)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-23 20:57:07.698441 size on output set 6
2022-04-23 20:57:07.698456 num operations 1
2022-04-23 20:57:07.698462 size on input set 1
2022-04-23 20:57:07.698615 using api key soukgp
2022-04-23 20:57:55.013008 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don't use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "def is_ok(n, k, s):\n    return True\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    if is_ok(n, k, s):\n        print('Yes')\n    else:\n        print('No')\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "from collections import Counter\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nca = Counter(a)\ncb = Counter(b)\n\nfor i in range(max(a), 0, -1):\n    if ca[i] != cb[i]:\n        print(i + 1)\n        break\n\n\n# import sys\n# sys.setrecursionlimit(10**6)\n\n\n# def dfs(i, n, k, s, cost, memo):\n#     if memo[i][k] != -1:\n#         return memo[i][k]\n\n#     if k == 0:\n#         return 0\n\n#     # if we don't use s[i]\n#     res = dfs(i + 1, n, k, s, cost, memo)\n\n#     # if we use s[i]\n#     if i + 1 <= n and s[i] != s[i + 1]:\n#         res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n#     memo[i][k] = res\n#     return res\n\n\n# def solve(n, k, s):\n#     cost = [0] * (n + 1)\n#     for i in range(n - 1, -1, -1):\n#         cost[i] = cost[i + 1] + (n - i)\n\n#     memo = [[-1] * (k + 1) for _ in range(n + 1)]\n#     ans = dfs(0, n, k, s, cost, memo)\n#     if ans >= 10**9:\n#         return -1\n#     return ans\n\n\n# def main():\n#     n, k = map(int, input().split())\n#     s = input()\n#     print(solve(n, k, s))\n\n\n# if __name__ == \"__main__\":\n#     main()\n\n\n# import sys\n# sys.setrecursionlimit(10**6)\n\n\n# def dfs(i, n, k, s, cost, memo):\n#     if memo[i][k] != -1:\n#         return memo[i][k]\n\n#     if k == 0:\n#         return 0\n\n#     # if we don't use s[i]\n#     res = dfs(i + 1, n, k, s, cost, memo)\n\n#     # if we use s[i]\n#     if i + 1 <= n and s[i] != s[i + 1]:\n#         res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n#     memo[i][k] = res\n#     return res\n\n\n# def solve(n, k, s):\n#     cost = [0] * (n + 1)\n#     for i in range(n - 1, -1, -1):\n#         cost[i] = cost[i + 1] + (n - i)\n\n#     memo = [[-1] * (k + 1) for _ in range(n + 1)]\n#     ans = dfs(0, n, k, s, cost, memo)\n#     if ans >= 10**9:\n#         return -1\n#     return ans\n\n\n# def main():\n#     n, k = map(int, input().split())\n#     s = input()\n#     print(solve(n, k, s))\n\n\n# if __name__ == \"__main__\":\n#     main()\n\n\n# import sys\n# sys.setrecursionlimit(10**6)\n\n\n# def dfs(i, n, k, s, cost, memo):\n#     if memo[i][k] != -1:\n#         return memo[i][k]\n\n#     if k == 0:\n#         return 0\n\n#     # if we don't use s[i]\n#     res = dfs(i + 1, n, k, s, cost, memo)\n\n#     # if we use s[i]\n#     if i + 1 <= n and s[i] != s[i + 1]:\n#         res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n#     memo[i][k] = res\n#     return res\n\n\n# def solve(n, k, s):\n#     cost = [0] * (n + 1)\n#     for i in range(n - 1, -1, -1):\n#         cost[i] = cost[i + 1] + (n - i)\n\n#     memo = [[-1] * (k + 1) for _ in range(n + 1)]\n#     ans = dfs(0, n, k, s, cost, memo)\n#     if ans >= 10**9:\n#         return -1\n#     return ans\n\n\n# def main():\n#     n, k = map(int, input().split())\n#     s = input()\n#     print(solve(n, k, s))\n\n\n# if __name__ == \"__main__\":\n#     main()\n\n\n# import sys\n# sys.setrecursionlimit(10**6)\n\n\n# def dfs(i, n, k, s, cost, memo):\n#     if memo[i][k] != -1:\n#         return memo[i][k]\n\n#     if k == 0:\n#         return 0\n\n#     # if we don't use s[i]\n#     res = dfs(i + 1, n, k, s, cost, memo)\n\n#     # if we use s[i]\n#     if i + 1 <= n and s[i] != s[i + 1]:\n#         res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n#     memo[i][k] = res\n#     return res\n\n\n# def solve(n, k, s):\n#     cost = [0] * (n + 1)\n#     for i in range(n - 1, -1, -1):\n#         cost[i] = cost[i + 1] + (n - i)\n\n#     memo = [[-1] * (k + 1) for _ in range(n + 1)]\n#     ans = dfs(0, n, k, s, cost, memo)\n#     if ans >= 10**9:\n#         return -1\n#     return ans\n\n\n# def main():\n#     n, k = map(int, input().split())\n#     s = input()\n#     print(solve(n, k, s))\n\n\n# if __name__ == \"__main__\":\n#     main()\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don't use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don't use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don't use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10 ** 9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "import sys\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don't use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\nsys.setrecursionlimit(10**6)\n#\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don't use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\ndef main():\n    print(10**9)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650747427,
  "object": "edit"
}
2022-04-23 20:57:55.013371 fix syntax errors 8 ['\nimport sys\nsys.setrecursionlimit(10**6)\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don\'t use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\nif __name__ == "__main__":\n    main()\n', 'def is_ok(n, k, s):\n    return True\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    if is_ok(n, k, s):\n        print(\'Yes\')\n    else:\n        print(\'No\')\n\n\nif __name__ == "__main__":\n    main()\n', 'from collections import Counter\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nca = Counter(a)\ncb = Counter(b)\n\nfor i in range(max(a), 0, -1):\n    if ca[i] != cb[i]:\n        print(i + 1)\n        break\n\n\n# import sys\n# sys.setrecursionlimit(10**6)\n\n\n# def dfs(i, n, k, s, cost, memo):\n#     if memo[i][k] != -1:\n#         return memo[i][k]\n\n#     if k == 0:\n#         return 0\n\n#     # if we don\'t use s[i]\n#     res = dfs(i + 1, n, k, s, cost, memo)\n\n#     # if we use s[i]\n#     if i + 1 <= n and s[i] != s[i + 1]:\n#         res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n#     memo[i][k] = res\n#     return res\n\n\n# def solve(n, k, s):\n#     cost = [0] * (n + 1)\n#     for i in range(n - 1, -1, -1):\n#         cost[i] = cost[i + 1] + (n - i)\n\n#     memo = [[-1] * (k + 1) for _ in range(n + 1)]\n#     ans = dfs(0, n, k, s, cost, memo)\n#     if ans >= 10**9:\n#         return -1\n#     return ans\n\n\n# def main():\n#     n, k = map(int, input().split())\n#     s = input()\n#     print(solve(n, k, s))\n\n\n# if __name__ == "__main__":\n#     main()\n\n\n# import sys\n# sys.setrecursionlimit(10**6)\n\n\n# def dfs(i, n, k, s, cost, memo):\n#     if memo[i][k] != -1:\n#         return memo[i][k]\n\n#     if k == 0:\n#         return 0\n\n#     # if we don\'t use s[i]\n#     res = dfs(i + 1, n, k, s, cost, memo)\n\n#     # if we use s[i]\n#     if i + 1 <= n and s[i] != s[i + 1]:\n#         res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n#     memo[i][k] = res\n#     return res\n\n\n# def solve(n, k, s):\n#     cost = [0] * (n + 1)\n#     for i in range(n - 1, -1, -1):\n#         cost[i] = cost[i + 1] + (n - i)\n\n#     memo = [[-1] * (k + 1) for _ in range(n + 1)]\n#     ans = dfs(0, n, k, s, cost, memo)\n#     if ans >= 10**9:\n#         return -1\n#     return ans\n\n\n# def main():\n#     n, k = map(int, input().split())\n#     s = input()\n#     print(solve(n, k, s))\n\n\n# if __name__ == "__main__":\n#     main()\n\n\n# import sys\n# sys.setrecursionlimit(10**6)\n\n\n# def dfs(i, n, k, s, cost, memo):\n#     if memo[i][k] != -1:\n#         return memo[i][k]\n\n#     if k == 0:\n#         return 0\n\n#     # if we don\'t use s[i]\n#     res = dfs(i + 1, n, k, s, cost, memo)\n\n#     # if we use s[i]\n#     if i + 1 <= n and s[i] != s[i + 1]:\n#         res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n#     memo[i][k] = res\n#     return res\n\n\n# def solve(n, k, s):\n#     cost = [0] * (n + 1)\n#     for i in range(n - 1, -1, -1):\n#         cost[i] = cost[i + 1] + (n - i)\n\n#     memo = [[-1] * (k + 1) for _ in range(n + 1)]\n#     ans = dfs(0, n, k, s, cost, memo)\n#     if ans >= 10**9:\n#         return -1\n#     return ans\n\n\n# def main():\n#     n, k = map(int, input().split())\n#     s = input()\n#     print(solve(n, k, s))\n\n\n# if __name__ == "__main__":\n#     main()\n\n\n# import sys\n# sys.setrecursionlimit(10**6)\n\n\n# def dfs(i, n, k, s, cost, memo):\n#     if memo[i][k] != -1:\n#         return memo[i][k]\n\n#     if k == 0:\n#         return 0\n\n#     # if we don\'t use s[i]\n#     res = dfs(i + 1, n, k, s, cost, memo)\n\n#     # if we use s[i]\n#     if i + 1 <= n and s[i] != s[i + 1]:\n#         res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n#     memo[i][k] = res\n#     return res\n\n\n# def solve(n, k, s):\n#     cost = [0] * (n + 1)\n#     for i in range(n - 1, -1, -1):\n#         cost[i] = cost[i + 1] + (n - i)\n\n#     memo = [[-1] * (k + 1) for _ in range(n + 1)]\n#     ans = dfs(0, n, k, s, cost, memo)\n#     if ans >= 10**9:\n#         return -1\n#     return ans\n\n\n# def main():\n#     n, k = map(int, input().split())\n#     s = input()\n#     print(solve(n, k, s))\n\n\n# if __name__ == "__main__":\n#     main()\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don\'t use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\n\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don\'t use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don\'t use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10 ** 9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == "__main__":\n    main()\n', 'import sys\nsys.setrecursionlimit(10**6)\n\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don\'t use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nsys.setrecursionlimit(10**6)\n#\n\ndef dfs(i, n, k, s, cost, memo):\n    if memo[i][k] != -1:\n        return memo[i][k]\n\n    if k == 0:\n        return 0\n\n    # if we don\'t use s[i]\n    res = dfs(i + 1, n, k, s, cost, memo)\n\n    # if we use s[i]\n    if i + 1 <= n and s[i] != s[i + 1]:\n        res = min(res, cost[i + 1] + dfs(i + 1, n, k - 1, s, cost, memo))\n\n    memo[i][k] = res\n    return res\n\n\ndef solve(n, k, s):\n    cost = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        cost[i] = cost[i + 1] + (n - i)\n\n    memo = [[-1] * (k + 1) for _ in range(n + 1)]\n    ans = dfs(0, n, k, s, cost, memo)\n    if ans >= 10**9:\n        return -1\n    return ans\n\n\ndef main():\n    n, k = map(int, input().split())\n    s = input()\n    print(solve(n, k, s))\n\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    print(10**9)\n\n\nif __name__ == "__main__":\n    main()\n']
2022-04-23 20:57:55.013496 size on output set 8
