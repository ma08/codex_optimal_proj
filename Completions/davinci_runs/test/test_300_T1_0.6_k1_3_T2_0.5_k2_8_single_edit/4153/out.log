2022-04-18 02:57:17.548373 """
There are N cubes stacked vertically on a desk.
You are given a string S of length N. The color of the i-th cube from the bottom is red if the i-th character in S is 0, and blue if that character is 1.
You can perform the following operation any number of times: choose a red cube and a blue cube that are adjacent, and remove them. Here, the cubes that were stacked on the removed cubes will fall down onto the object below them.
At most how many cubes can be removed?

-----Constraints-----
 - 1 \leq N \leq 10^5
 - |S| = N
 - Each character in S is 0 or 1.

-----Input-----
Input is given from Standard Input in the following format:
S

-----Output-----
Print the maximum number of cubes that can be removed.

-----Sample Input-----
0011

-----Sample Output-----
4

All four cubes can be removed, by performing the operation as follows:
 - Remove the second and third cubes from the bottom. Then, the fourth cube drops onto the first cube.
 - Remove the first and second cubes from the bottom.
"""
2022-04-18 02:57:17.548391 --------------------------
2022-04-18 02:57:50.216027 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint min(count.values()) * 2"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef find_max_removal(s):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)"
    }
  ],
  "created": 1650250637,
  "id": "cmpl-4yBrhRLazMINCeqw5ugXIhHEyPhxM",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 02:57:50.216255 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nfrom sys import stdin\n\ns = stdin.readline()\n\n# count the number of adjacent 0's and 1's\ncount = {}\nc = s[0]\ncount[c] = 1\nfor i in range(1, len(s)):\n    if s[i] == c:\n        count[c] += 1\n    else:\n        c = s[i]\n        count[c] = 1\n\nprint min(count.values()) * 2"
}
2022-04-18 02:57:50.216304 REASON stop
2022-04-18 02:57:50.355424 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef find_max_removal(s):\n    \"\"\"\n    Counts the maximum number of adjacent red and blue cubes that can be removed\n    :param s: string of 1s and 0s\n    :return: maximum number of adjacent red and blue cubes that can be removed\n    \"\"\"\n    # Initialize variables\n    max_removal = 0\n    prev_digit = None\n    counter = 0\n    for digit in s:\n        # If the digit is the same as the previous digit, increment the counter\n        if digit == prev_digit:\n            counter += 1\n        # If the digit is different from the previous digit, update max_removal\n        else:\n            max_removal = max(max_removal, counter)\n            counter = 1\n        prev_digit = digit\n    # Update max_removal one last time after the loop\n    max_removal = max(max_removal, counter)\n    return max_removal\n\n\nif __name__ == \"__main__\":\n    s = input()\n    max_removal = find_max_removal(s)\n    print(max_removal)"
}
2022-04-18 02:57:50.355527 REASON stop
2022-04-18 02:57:50.378246 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nfrom collections import deque\n\nn = int(input())\ns = deque(input())\n\ncount = 0\nwhile s:\n    if s[0] == '0':\n        count += 1\n        s.popleft()\n    elif s[0] == '1':\n        if len(s) > 1 and s[1] == '0':\n            count += 1\n            s.popleft()\n            s.popleft()\n        else:\n            break\n\nprint(count)"
}
2022-04-18 02:57:50.378308 REASON stop
