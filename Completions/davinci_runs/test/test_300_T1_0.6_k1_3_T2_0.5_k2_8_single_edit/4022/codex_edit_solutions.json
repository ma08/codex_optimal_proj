["\n\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x: x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\n\nmain()\n", "\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\nimport math\n\n    # Check if the segments are empty\n    if len(segments) == 0:\n        return 0\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\n\nif __name__ == '__main__':\n    main()\n", "\nfrom random import randint\n\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [(randint(0, 10 ** 9), randint(0, 10 ** 9)) for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments[1:]:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments[1:]:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\n\n\nfrom random import randint\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n - 1)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)[:n - 1]\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys, math\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    a = [0] * n\n    for i in range(n): a[i] = int(sys.stdin.readline())\n    a.sort()\n    min = a[n - 1] - a[0]\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[j] - a[i] < min: min = a[j] - a[i]\n            if a[j] - a[i] >= m: break\n    print(min)\n\nmain()\n", "\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key=lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\nfrom random import randint\n\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    # n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n = next(reader)\n    segments = list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport sys\n\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    if m == 0:\n        print(0)\n        return\n    edges = [[int(x) for x in sys.stdin.readline().split()] for i in range(m)]\n    edges.sort(key=lambda x: x[2])\n    # print(edges)\n    d = [0] * n\n    for i in range(1, n):\n        d[i] = sys.maxsize\n    for i in range(m):\n        if d[edges[i][1]] > d[edges[i][0]] + edges[i][2]:\n            d[edges[i][1]] = d[edges[i][0]] + edges[i][2]\n    # print(d)\n    for i in range(m):\n        if d[edges[i][1]] > d[edges[i][0]] + edges[i][2]:\n            print('-')\n            return\n    print(d[n - 1])\n\n\nmain()\n", "\nfrom random import randint\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    # n = 3\n    n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments or 0.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] <= segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] >= segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    n, segments = test_data()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n", "\n\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    n = 3\n    segments = [[random.randint(0, 10 ** 9), random.randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n", "import sys\nimport math\n\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef is_inside(x, y, r, x1, y1, x2, y2):\n    if distance(x, y, x1, y1) <= r and distance(x, y, x2, y2) <= r:\n        return True\n    return False\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n", "\nimport math\n\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = segments[0]\n    for segment in segments:\n        if segment[0] > intersection[1] or segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[0] > temp_intersection[1] or segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = []\n    for i in range(n):\n        s = [int(x) for x in sys.stdin.readline().split()]\n        segments.append(s)\n    segments.sort(key=lambda x:x[0])\n    i = 0\n    while i < n - 1:\n        if segments[i][1] < segments[i + 1][0]:\n            del segments[i + 1]\n            n -= 1\n        elif segments[i][1] < segments[i + 1][1]:\n            del segments[i + 1]\n            n -= 1\n        else:\n            i += 1\n    segs = [0] * n\n    for i in range(n):\n        segs[i] = segments[i][1] - segments[i][0]\n    segs.sort()\n    if n > 1:\n        print(segs[n - 2])\n    else:\n        print(0)\n\nmain()\n", "\ndef find_max_intersection_length(n, segments):\n    # Sort segments by starting point\n    segments = sorted(segments, key = lambda x: x[0])\n\n    # Find the intersection of all segments\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    intersection_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        # Find the intersection of all segments except the current one\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            # The segment does not intersect the intersection\n            continue\n        elif segment[0] > temp_intersection[1]:\n            # The segment does not intersect the intersection\n            continue\n        else:\n            # The segment intersects the intersection\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        temp_intersection_length = temp_intersection[1] - temp_intersection[0]\n        if temp_intersection_length > max_length:\n            max_length = temp_intersection_length\n    return max_length\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\nif __name__ == '__main__':\n    main()\n", "\nimport math\n\ndef find_max_intersection_length(n, segments):\n    segments = sorted(segments, key=lambda x: x[0])\n\n    intersection = [segments[0][0], segments[0][1]]\n    for segment in segments:\n        if segment[1] < intersection[0]:\n            continue\n        elif segment[0] > intersection[1]:\n            continue\n        else:\n            intersection[0] = max(intersection[0], segment[0])\n            intersection[1] = min(intersection[1], segment[1])\n    max_length = intersection[1] - intersection[0]\n\n    # Check each segment for the max length\n    max_length = intersection_length\n    for segment in segments:\n        temp_intersection = intersection\n        if segment[1] < temp_intersection[0]:\n            continue\n        elif segment[0] > temp_intersection[1]:\n            continue\n        else:\n            temp_intersection[0] = max(temp_intersection[0], segment[0])\n            temp_intersection[1] = min(temp_intersection[1], segment[1])\n        if temp_intersection[1] - temp_intersection[0] > max_length:\n            max_length = temp_intersection[1] - temp_intersection[0]\n    return max_length\n\n\ndef main():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        l, r = [int(i) for i in input().split()]\n        segments.append([l, r])\n    print(find_max_intersection_length(n, segments))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom random import randint\n\nimport sys\n\ndef test_data():\n    \"\"\" Generates a test case with n segments. \"\"\"\n\n    # n = 3\n    n = randint(2, 3 * 10 ** 5)\n    segments = [[randint(0, 10 ** 9), randint(0, 10 ** 9)] for _ in range(n)]\n    segments.sort()\n    return n, segments\n\ndef solution(n, segments):\n    \"\"\" Returns the maximum length of the intersection of n - 1 segments. \"\"\"\n\n    # If n == 2, return the length of the intersection of the two segments.\n    if n == 2:\n        return max(0, min(segments[1][1], segments[0][1]) - max(segments[0][0], segments[1][0]))\n\n    # If the intersection of the first two segments is empty, return 0.\n    if segments[0][1] < segments[1][0]:\n        return 0\n\n    # If the intersection of the last two segments is empty, return 0.\n    if segments[-1][0] > segments[-2][1]:\n        return 0\n\n    # Find the middle and the highest segment.\n    middle = (n - 1) // 2\n    maximum = max(segments[middle][1], segments[middle + 1][1])\n\n    # Remove the segment with the highest right endpoint.\n    if segments[middle][1] == maximum:\n        return max(\n            solution(n - 1, segments[:middle] + segments[middle + 1:]),\n            min(segments[middle][1], segments[middle - 1][1]) - max(segments[middle][0], segments[middle - 1][0])\n        )\n    else:\n        return max(\n            solution(n - 1, segments[:middle + 1] + segments[middle + 2:]),\n            min(segments[middle][1], segments[middle + 1][1]) - max(segments[middle][0], segments[middle + 1][0])\n        )\n\ndef main():\n    reader = (map(int, line.split()) for line in sys.stdin)\n    n, segments = next(reader), list(reader)\n    segments.sort()\n    print(solution(n, segments))\n\nif __name__ == \"__main__\":\n    main()\n"]