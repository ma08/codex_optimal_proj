2022-04-23 21:12:42.785466 num operations 1
2022-04-23 21:12:42.785486 size on input set 1
2022-04-23 21:12:42.785654 using api key sunu
2022-04-23 21:12:59.335429 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n"
    },
    {
      "index": 1,
      "text": "\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print \"0\" * x + \"1\" * b\nelif (b - x) >= a:\n    print \"1\" * x + \"0\" * a\nelse:\n    zeros = a - (x - b)\n    print \"1\" * (x - zeros) + \"0\" * zeros + \"1\" * b\n"
    },
    {
      "index": 2,
      "text": "\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) <= b:\n    print \"0\" * x + \"1\" * b\nelif (b - x) <= a:\n    print \"1\" * x + \"0\" * a\nelse:\n    zeros = a - (x - b)\n    print \"1\" * (x - zeros) + \"0\" * zeros + \"1\" * b\n"
    },
    {
      "index": 3,
      "text": "\n\na, b, x = map(int, input().split())\n\nif (a - x) >= b:\n    print(\"0\" * x + \"1\" * b)\nelif (b - x) >= a:\n    print(\"1\" * x + \"0\" * a)\nelse:\n    zeros = a - (x - b)\n    print(\"1\" * (x - zeros) + \"0\" * zeros + \"1\" * b)\n"
    },
    {
      "index": 4,
      "text": "\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b or b == 0:\n    print \"0\" * x + \"1\" * b\nelif (b - x) >= a or a == 0:\n    print \"1\" * x + \"0\" * a\nelse:\n    zeros = a - (x - b)\n    print \"1\" * (x - zeros) + \"0\" * zeros + \"1\" * b\n"
    },
    {
      "index": 5,
      "text": "\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print(\"0\" * x + \"1\" * b)\nelif (b - x) >= a:\n    print(\"1\" * x + \"0\" * a)\nelse:\n    zeros = a - (x - b)\n    print(\"1\" * (x - zeros) + \"0\" * zeros + \"1\" * b)\n"
    },
    {
      "index": 6,
      "text": "\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print(\"0\" * x + \"1\" * b)\nelif (b - x) >= a:\n    print(\"1\" * x + \"0\" * a)\nelse:\n    zeros = a - (x - b)\n    print(\"1\" * (x - zeros) + \"0\" * zeros + \"1\" * b)\n"
    },
    {
      "index": 7,
      "text": "\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print \"0\" * x + \"1\" * b \nelif (b - x) >= a:\n    print \"1\" * x + \"0\" * a\nelse:\n    zeros = a - (x - b)\n    print \"1\" * (x - zeros) + \"0\" * zeros + \"1\" * b\n"
    }
  ],
  "created": 1650748362,
  "object": "edit"
}
2022-04-23 21:12:59.335705 fix syntax errors 8 ['\n', '\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print "0" * x + "1" * b\nelif (b - x) >= a:\n    print "1" * x + "0" * a\nelse:\n    zeros = a - (x - b)\n    print "1" * (x - zeros) + "0" * zeros + "1" * b\n', '\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) <= b:\n    print "0" * x + "1" * b\nelif (b - x) <= a:\n    print "1" * x + "0" * a\nelse:\n    zeros = a - (x - b)\n    print "1" * (x - zeros) + "0" * zeros + "1" * b\n', '\n\na, b, x = map(int, input().split())\n\nif (a - x) >= b:\n    print("0" * x + "1" * b)\nelif (b - x) >= a:\n    print("1" * x + "0" * a)\nelse:\n    zeros = a - (x - b)\n    print("1" * (x - zeros) + "0" * zeros + "1" * b)\n', '\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b or b == 0:\n    print "0" * x + "1" * b\nelif (b - x) >= a or a == 0:\n    print "1" * x + "0" * a\nelse:\n    zeros = a - (x - b)\n    print "1" * (x - zeros) + "0" * zeros + "1" * b\n', '\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print("0" * x + "1" * b)\nelif (b - x) >= a:\n    print("1" * x + "0" * a)\nelse:\n    zeros = a - (x - b)\n    print("1" * (x - zeros) + "0" * zeros + "1" * b)\n', '\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print("0" * x + "1" * b)\nelif (b - x) >= a:\n    print("1" * x + "0" * a)\nelse:\n    zeros = a - (x - b)\n    print("1" * (x - zeros) + "0" * zeros + "1" * b)\n', '\n\na, b, x = map(int, raw_input().split())\n\nif (a - x) >= b:\n    print "0" * x + "1" * b \nelif (b - x) >= a:\n    print "1" * x + "0" * a\nelse:\n    zeros = a - (x - b)\n    print "1" * (x - zeros) + "0" * zeros + "1" * b\n']
2022-04-23 21:12:59.335747 size on output set 8
2022-04-23 21:12:59.335759 num operations 1
2022-04-23 21:12:59.335765 size on input set 1
2022-04-23 21:12:59.335916 using api key sunu
2022-04-23 21:13:15.234183 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print(s)\n"
    },
    {
      "index": 1,
      "text": "\n\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print(s)\n"
    },
    {
      "index": 2,
      "text": "\n# Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, raw_input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print s\n"
    },
    {
      "index": 3,
      "text": "\n#!/bin/python\n#!/usr/bin/env python\nif __name__ == '__main__':\n    n = int(raw_input())\n    arr = map(int, raw_input().split())\n    print(arr)\n    arr.sort()\n    print(arr)\n    print(arr[-2])\n"
    },
    {
      "index": 4,
      "text": "\n\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print(s)\n"
    },
    {
      "index": 5,
      "text": "\n\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print(s)\n"
    },
    {
      "index": 6,
      "text": "#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, raw_input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print s\n"
    },
    {
      "index": 7,
      "text": "\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, raw_input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print s\n"
    }
  ],
  "created": 1650748379,
  "object": "edit"
}
2022-04-23 21:13:15.234496 fix syntax errors 8 ["\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print(s)\n", "\n\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print(s)\n", "\n# Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, raw_input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print s\n", "\n#!/bin/python\n#!/usr/bin/env python\nif __name__ == '__main__':\n    n = int(raw_input())\n    arr = map(int, raw_input().split())\n    print(arr)\n    arr.sort()\n    print(arr)\n    print(arr[-2])\n", "\n\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print(s)\n", "\n\n#Solution\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print(s)\n", "#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, raw_input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print s\n", "\n\n#!/usr/bin/env python\n\nif __name__ == '__main__':\n    a, b, x = map(int, raw_input().split())\n    n = a + b\n    s = ''\n    for i in range(n):\n        if (i < x):\n            s += '0'\n        else:\n            s += '1'\n    print s\n"]
2022-04-23 21:13:15.234619 size on output set 6
2022-04-23 21:13:15.234634 num operations 1
2022-04-23 21:13:15.234640 size on input set 1
2022-04-23 21:13:15.234802 using api key jaanu
2022-04-23 21:13:49.667948 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n# Use A[i] to represent the number of 0s required in the first i bits, inclusive\n# Use B[i] to represent the number of 1s required in the first i bits, inclusive\n# Use C[i] to represent the number of transitions required in the first i bits, inclusive\n# Initially, A[0] = a, B[0] = b, C[0] = 0\n# At each step, we have 2 options:\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0\n# At each step, we choose the option that will give us C[i] == x\n# If C[i] > x, then we need to add 0 to the string\n# If C[i] < x, then we need to add 1 to the string\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1\n# If B[i-1] == 0, then we have to add 0\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    if ans[0] == '0':\n        ans.append('1')\n    else:\n        ans.append('0')\n    return \"\".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n"
    },
    {
      "index": 1,
      "text": "\n\n# Use A[i] to represent the number of 0s required in the first i bits\n# Use B[i] to represent the number of 1s required in the first i bits\n# Use C[i] to represent the number of transitions required in the first i bits\n# Initially, A[0] = a, B[0] = b, C[0] = 0\n# At each step, we have 2 options:\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0\n# At each step, we choose the option that will give us C[i] == x\n# If C[i] > x, then we need to add 0 to the string\n# If C[i] < x, then we need to add 1 to the string\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1\n# If B[i-1] == 0, then we have to add 0\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    if ans[0] == '0':\n        ans.append('1')\n    else:\n        ans.append('0')\n    return \"\".join(ans)\n\nT = int(input())\nfor _ in range(T):\n    a, b, x = map(int, input().split())\n    print(solve(a, b, x))\n"
    },
    {
      "index": 2,
      "text": "\n\ndef solve(n):\n    return n\n"
    },
    {
      "index": 3,
      "text": "\n\n# Use A[i] to represent the number of 0s required in the first i bits.\n# Use B[i] to represent the number of 1s required in the first i bits.\n# Use C[i] to represent the number of transitions required in the first i bits.\n# Initially, A[0] = a, B[0] = b, C[0] = 0.\n# At each step, we have 2 options:.\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1.\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1.\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1.\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0.\n# At each step, we choose the option that will give us C[i] == x.\n# If C[i] > x, then we need to add 0 to the string.\n# If C[i] < x, then we need to add 1 to the string.\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1.\n# If B[i-1] == 0, then we have to add 0.\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    if ans[0] == '0':\n        ans.append('1')\n    else:\n        ans.append('0')\n    return \"\".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n"
    },
    {
      "index": 4,
      "text": "\n\n# Use A[i] to represent the number of 0s required in the first i bits.\n# Use B[i] to represent the number of 1s required in the first i bits.\n# Use C[i] to represent the number of transitions required in the first i bits.\n# Initially, A[0] = a, B[0] = b, C[0] = 0.\n# At each step, we have 2 options:.\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1.\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1.\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1.\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0.\n# At each step, we choose the option that will give us C[i] == x.\n# If C[i] > x, then we need to add 0 to the string.\n# If C[i] < x, then we need to add 1 to the string.\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1.\n# If B[i-1] == 0, then we have to add 0.\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    if ans[0] == '0':\n        ans.append('1')\n    else:\n        ans.append('0')\n    return \"\".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n"
    },
    {
      "index": 5,
      "text": "\n\n# Use A[i] to represent the number of 0s required in the last i bits\n# Use B[i] to represent the number of 1s required in the last i bits\n# Use C[i] to represent the number of transitions required in the last i bits\n# Initially, A[0] = a, B[0] = b, C[0] = 0\n# At each step, we have 2 options:\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0\n# At each step, we choose the option that will give us C[i] == x\n# If C[i] > x, then we need to add 0 to the string\n# If C[i] < x, then we need to add 1 to the string\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1, else if B[i-1] == 0, then we have to add 0\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b):\n        if A[i] > 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    if ans[0] == '0':\n        ans.append('1')\n    else:\n        ans.append('0')\n    return \"\".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n"
    },
    {
      "index": 6,
      "text": "\n\n#\n\n\nn = int(input())\n\nfor i in range(n):\n    total = int(input())\n    p = list(map(int, input().split()))\n    for j in range(len(p)):\n        print(j+1, end=\" \")\n    print()\n"
    },
    {
      "index": 7,
      "text": "\n\n#\n# Use A[i] to represent the number of 0s required in the first i bits.\n# Use B[i] to represent the number of 1s required in the first i bits.\n# Use C[i] to represent the number of transitions required in the first i bits.\n# Initially, A[0] = a, B[0] = b, C[0] = 0.\n# At each step, we have 2 options: 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1.\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1.\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1.\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0.\n# At each step, we choose the option that will give us C[i] == x.\n# If C[i] > x, then we need to add 0 to the string.\n# If C[i] < x, then we need to add 1 to the string.\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1.\n# If B[i-1] == 0, then we have to add 0.\n#\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    if ans[0] == '0':\n        ans.append('1')\n    else:\n        ans.append('0')\n    return \"\".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n"
    }
  ],
  "created": 1650748395,
  "object": "edit"
}
2022-04-23 21:13:49.668316 fix syntax errors 8 ['\n\n# Use A[i] to represent the number of 0s required in the first i bits, inclusive\n# Use B[i] to represent the number of 1s required in the first i bits, inclusive\n# Use C[i] to represent the number of transitions required in the first i bits, inclusive\n# Initially, A[0] = a, B[0] = b, C[0] = 0\n# At each step, we have 2 options:\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0\n# At each step, we choose the option that will give us C[i] == x\n# If C[i] > x, then we need to add 0 to the string\n# If C[i] < x, then we need to add 1 to the string\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1\n# If B[i-1] == 0, then we have to add 0\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append(\'0\')\n        else:\n            ans.append(\'1\')\n    if ans[0] == \'0\':\n        ans.append(\'1\')\n    else:\n        ans.append(\'0\')\n    return "".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n', '\n\n# Use A[i] to represent the number of 0s required in the first i bits\n# Use B[i] to represent the number of 1s required in the first i bits\n# Use C[i] to represent the number of transitions required in the first i bits\n# Initially, A[0] = a, B[0] = b, C[0] = 0\n# At each step, we have 2 options:\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0\n# At each step, we choose the option that will give us C[i] == x\n# If C[i] > x, then we need to add 0 to the string\n# If C[i] < x, then we need to add 1 to the string\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1\n# If B[i-1] == 0, then we have to add 0\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append(\'0\')\n        else:\n            ans.append(\'1\')\n    if ans[0] == \'0\':\n        ans.append(\'1\')\n    else:\n        ans.append(\'0\')\n    return "".join(ans)\n\nT = int(input())\nfor _ in range(T):\n    a, b, x = map(int, input().split())\n    print(solve(a, b, x))\n', '\n\ndef solve(n):\n    return n\n', '\n\n# Use A[i] to represent the number of 0s required in the first i bits.\n# Use B[i] to represent the number of 1s required in the first i bits.\n# Use C[i] to represent the number of transitions required in the first i bits.\n# Initially, A[0] = a, B[0] = b, C[0] = 0.\n# At each step, we have 2 options:.\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1.\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1.\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1.\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0.\n# At each step, we choose the option that will give us C[i] == x.\n# If C[i] > x, then we need to add 0 to the string.\n# If C[i] < x, then we need to add 1 to the string.\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1.\n# If B[i-1] == 0, then we have to add 0.\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append(\'0\')\n        else:\n            ans.append(\'1\')\n    if ans[0] == \'0\':\n        ans.append(\'1\')\n    else:\n        ans.append(\'0\')\n    return "".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n', '\n\n# Use A[i] to represent the number of 0s required in the first i bits.\n# Use B[i] to represent the number of 1s required in the first i bits.\n# Use C[i] to represent the number of transitions required in the first i bits.\n# Initially, A[0] = a, B[0] = b, C[0] = 0.\n# At each step, we have 2 options:.\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1.\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1.\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1.\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0.\n# At each step, we choose the option that will give us C[i] == x.\n# If C[i] > x, then we need to add 0 to the string.\n# If C[i] < x, then we need to add 1 to the string.\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1.\n# If B[i-1] == 0, then we have to add 0.\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append(\'0\')\n        else:\n            ans.append(\'1\')\n    if ans[0] == \'0\':\n        ans.append(\'1\')\n    else:\n        ans.append(\'0\')\n    return "".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n', '\n\n# Use A[i] to represent the number of 0s required in the last i bits\n# Use B[i] to represent the number of 1s required in the last i bits\n# Use C[i] to represent the number of transitions required in the last i bits\n# Initially, A[0] = a, B[0] = b, C[0] = 0\n# At each step, we have 2 options:\n# 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0\n# At each step, we choose the option that will give us C[i] == x\n# If C[i] > x, then we need to add 0 to the string\n# If C[i] < x, then we need to add 1 to the string\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1, else if B[i-1] == 0, then we have to add 0\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b):\n        if A[i] > 0:\n            ans.append(\'0\')\n        else:\n            ans.append(\'1\')\n    if ans[0] == \'0\':\n        ans.append(\'1\')\n    else:\n        ans.append(\'0\')\n    return "".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n', '\n\n#\n\n\nn = int(input())\n\nfor i in range(n):\n    total = int(input())\n    p = list(map(int, input().split()))\n    for j in range(len(p)):\n        print(j+1, end=" ")\n    print()\n', '\n\n#\n# Use A[i] to represent the number of 0s required in the first i bits.\n# Use B[i] to represent the number of 1s required in the first i bits.\n# Use C[i] to represent the number of transitions required in the first i bits.\n# Initially, A[0] = a, B[0] = b, C[0] = 0.\n# At each step, we have 2 options: 1) Add 0 to the string: A[i] = A[i-1] - 1, B[i] = B[i-1], C[i] = C[i-1] + 1.\n# 2) Add 1 to the string: A[i] = A[i-1], B[i] = B[i-1] - 1, C[i] = C[i-1] + 1.\n# When adding 0 to the string, if A[i-1] == 0, then there is no more 0s left to add, we have to add 1.\n# When adding 1 to the string, if B[i-1] == 0, then there is no more 1s left to add, we have to add 0.\n# At each step, we choose the option that will give us C[i] == x.\n# If C[i] > x, then we need to add 0 to the string.\n# If C[i] < x, then we need to add 1 to the string.\n# If C[i] == x, then we have 2 options, we can add 0 or 1, but if A[i-1] == 0, then we have to add 1.\n# If B[i-1] == 0, then we have to add 0.\n#\n\ndef solve(a, b, x):\n    A = [a]\n    B = [b]\n    C = [0]\n    for _ in range(a + b - 1):\n        if C[-1] > x:\n            A.append(A[-1] - 1)\n            B.append(B[-1])\n            C.append(C[-1] + 1)\n        elif C[-1] < x:\n            A.append(A[-1])\n            B.append(B[-1] - 1)\n            C.append(C[-1] + 1)\n        else:\n            if A[-1] == 0:\n                A.append(A[-1])\n                B.append(B[-1] - 1)\n                C.append(C[-1] + 1)\n            elif B[-1] == 0:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n            else:\n                A.append(A[-1] - 1)\n                B.append(B[-1])\n                C.append(C[-1] + 1)\n    ans = []\n    for i in range(a + b - 1):\n        if A[i] > 0:\n            ans.append(\'0\')\n        else:\n            ans.append(\'1\')\n    if ans[0] == \'0\':\n        ans.append(\'1\')\n    else:\n        ans.append(\'0\')\n    return "".join(ans)\n\na, b, x = map(int, input().split())\nprint(solve(a, b, x))\n']
2022-04-23 21:13:49.668446 size on output set 7
