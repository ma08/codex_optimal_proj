2022-04-18 03:48:07.964731 """
-----Input-----

The first line contains a single integer n (1 ≤ n ≤ 1000) — the number of points on a plane.

Each of the next n lines contains two real coordinates x_{i} and y_{i} of the $i^{\text{th}}$ point, specified with exactly 2 fractional digits. All coordinates are between  - 1000 and 1000, inclusive.


-----Output-----

Output a single real number θ — the answer to the problem statement. The absolute or relative error of your answer should be at most 10^{ - 2}.


-----Examples-----
Input
8
-2.14 2.06
-1.14 2.04
-2.16 1.46
-2.14 0.70
-1.42 0.40
-0.94 -0.48
-1.42 -1.28
-2.16 -1.62

Output
5.410

Input
5
2.26 1.44
2.28 0.64
2.30 -0.30
1.58 0.66
3.24 0.66

Output
5.620

Input
8
6.98 2.06
6.40 1.12
5.98 0.24
5.54 -0.60
7.16 0.30
7.82 1.24
8.34 0.24
8.74 -0.76

Output
5.480

Input
5
10.44 2.06
10.90 0.80
11.48 -0.48
12.06 0.76
12.54 2.06

Output
6.040

Input
8
16.94 2.42
15.72 2.38
14.82 1.58
14.88 0.50
15.76 -0.16
16.86 -0.20
17.00 0.88
16.40 0.92

Output
6.040

Input
7
20.62 3.00
21.06 2.28
21.56 1.36
21.66 0.56
21.64 -0.52
22.14 2.32
22.62 3.04

Output
6.720
"""
2022-04-18 03:48:07.964746 --------------------------
2022-04-18 03:49:09.154566 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\nimport math\n\ndef read_data(file_name):\n\tS = []\n\twith open(file_name, 'r') as file:\n\t\tn = int(file.readline().strip())\n\t\tfor i in range(n):\n\t\t\tx, y = [float(x) for x in file.readline().strip().split()]\n\t\t\tS.append((x,y))\n\treturn S\n\ndef is_left(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef area(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef convex_hull(S):\n\tn = len(S)\n\tS.sort()\n\tP = [S[0],S[1]]\n\tfor i in range(2,n):\n\t\twhile len(P)>1 and is_left(P[-2],P[-1],S[i])<=0:\n\t\t\tP.pop()\n\t\tP.append(S[i])\n\tU = [P[-1],P[0]]\n\tfor i in range(n-2,-1,-1):\n\t\twhile len(U)>1 and is_left(U[-2],U[-1],S[i])<=0:\n\t\t\tU.pop()\n\t\tU.append(S[i])\n\treturn P,U\n\ndef find_angle(S):\n\tn = len(S)\n\tif n<=2:\n\t\treturn 0\n\tP,U = convex_hull(S)\n\tA = 0\n\tfor i in range(len(P)-1):\n\t\tA += area(P[i],P[i+1],U[i])\n\tA += area(P[-1],P[0],U[-1])\n\tA = abs(A)/2\n\tarea_sum = 0\n\tfor i in range(len(P)-1):\n\t\tarea_sum += area(P[i],P[i+1],(0,0))\n\tarea_sum += area(P[-1],P[0],(0,0))\n\tarea_sum = abs(area_sum)/2\n\treturn A/area_sum\n\nS = read_data(sys.argv[1])\nprint(find_angle(S))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\nfrom math import atan2, degrees\n\n# This function is taken from https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# Given three colinear points p, q, r, the function checks if\n# point q lies on line segment 'pr'\ndef onSegment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are colinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p, q, r):\n    # See https://www.geeksforgeeks.org/orientation-3-ordered-points/\n    # for details of below formula.\n    val = (float(q[1]) - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if (val > 0):\n        # Clockwise orientation\n        return 1\n    elif (val < 0):\n        # Counterclockwise orientation\n        return 2\n    else:\n        # Colinear orientation\n        return 0\n\n# The main function that returns true if line segment 'p1q1'\n# and 'p2q2' intersect.\ndef doIntersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general and\n    # special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if (o1 != o2 and o3 != o4):\n        return True\n\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 and onSegment(p1, p2, q1)):\n        return True\n\n    # p1, q1 and q2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 and onSegment(p1, q2, q1)):\n        return True\n\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 and onSegment(p2, p1, q2)):\n        return True\n\n     # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 and onSegment(p2, q1, q2)):\n        return True\n\n    # Doesn't fall in any of the above cases\n    return False\n\ndef get_angle(p, q):\n    x = q[0] - p[0]\n    y = q[1] - p[1]\n    return degrees(atan2(y, x))\n\ndef get_min_angle_diff(points):\n    angles = []\n    for i in range(len(points)):\n        angles.append(get_angle(points[0], points[i]))\n    angles.sort()\n    min_diff = float('inf')\n    for i in range(len(angles) - 1):\n        diff = angles[i+1] - angles[i]\n        if diff < min_diff:\n            min_diff = diff\n    diff = angles[0] - angles[-1] + 360\n    if diff < min_diff:\n        min_diff = diff\n    return min_diff\n\n\ndef main():\n    num_points = int(input())\n    points = []\n    for i in range(num_points):\n        line = sys.stdin.readline()\n        points.append(list(map(float, line.split())))\n\n    min_angle_diff = float('inf')\n    for i in range(num_points):\n        for j in range(num_points):\n            if i == j:\n                continue\n            p1 = points[i]\n            p2 = points[j]\n            q1 = [p1[0] + 1, p1[1]]\n            q2 = [p2[0] + 1, p2[1]]\n            intersects = False\n            for k in range(num_points):\n                if k == i or k == j:\n                    continue\n                for l in range(k+1, num_points):\n                    if l == i or l == j:\n                        continue\n                    if doIntersect(p1, q1, points[k], points[l]):\n                        intersects = True\n                        break\n                    if doIntersect(p2, q2, points[k], points[l]):\n                        intersects = True\n                        break\n                if intersects:\n                    break\n            if not intersects:\n                angle_diff = get_min_angle_diff(points)\n                if angle_diff < min_angle_diff:\n                    min_angle_diff = angle_diff\n    print('{0:.3f}'.format(min_angle_diff))\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    number_of_points = int(input())\n    point_list = []\n    for _ in range(number_of_points):\n        point_list.append(list(map(float, input().split())))\n    max_length = 0\n    for i in range(number_of_points-1):\n        for j in range(i+1, number_of_points):\n            length = ((point_list[i][0]-point_list[j][0])**2 + (point_list[i][1]-point_list[j][1])**2)**0.5\n            if length > max_length:\n                max_length = length\n    print(max_length)\n\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1650253688,
  "id": "cmpl-4yCeuV6HblirFYhgFTrhAWKJeL7Az",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 03:49:09.154857 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\nimport math\n\ndef read_data(file_name):\n\tS = []\n\twith open(file_name, 'r') as file:\n\t\tn = int(file.readline().strip())\n\t\tfor i in range(n):\n\t\t\tx, y = [float(x) for x in file.readline().strip().split()]\n\t\t\tS.append((x,y))\n\treturn S\n\ndef is_left(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef area(a,b,c):\n\treturn (b[0]-a[0])*(c[1]-a[1])-(c[0]-a[0])*(b[1]-a[1])\n\ndef convex_hull(S):\n\tn = len(S)\n\tS.sort()\n\tP = [S[0],S[1]]\n\tfor i in range(2,n):\n\t\twhile len(P)>1 and is_left(P[-2],P[-1],S[i])<=0:\n\t\t\tP.pop()\n\t\tP.append(S[i])\n\tU = [P[-1],P[0]]\n\tfor i in range(n-2,-1,-1):\n\t\twhile len(U)>1 and is_left(U[-2],U[-1],S[i])<=0:\n\t\t\tU.pop()\n\t\tU.append(S[i])\n\treturn P,U\n\ndef find_angle(S):\n\tn = len(S)\n\tif n<=2:\n\t\treturn 0\n\tP,U = convex_hull(S)\n\tA = 0\n\tfor i in range(len(P)-1):\n\t\tA += area(P[i],P[i+1],U[i])\n\tA += area(P[-1],P[0],U[-1])\n\tA = abs(A)/2\n\tarea_sum = 0\n\tfor i in range(len(P)-1):\n\t\tarea_sum += area(P[i],P[i+1],(0,0))\n\tarea_sum += area(P[-1],P[0],(0,0))\n\tarea_sum = abs(area_sum)/2\n\treturn A/area_sum\n\nS = read_data(sys.argv[1])\nprint(find_angle(S))"
}
2022-04-18 03:49:09.154997 REASON stop
2022-04-18 03:49:09.167503 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\nfrom math import atan2, degrees\n\n# This function is taken from https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n# Given three colinear points p, q, r, the function checks if\n# point q lies on line segment 'pr'\ndef onSegment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\n# To find orientation of ordered triplet (p, q, r).\n# The function returns following values\n# 0 --> p, q and r are colinear\n# 1 --> Clockwise\n# 2 --> Counterclockwise\ndef orientation(p, q, r):\n    # See https://www.geeksforgeeks.org/orientation-3-ordered-points/\n    # for details of below formula.\n    val = (float(q[1]) - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if (val > 0):\n        # Clockwise orientation\n        return 1\n    elif (val < 0):\n        # Counterclockwise orientation\n        return 2\n    else:\n        # Colinear orientation\n        return 0\n\n# The main function that returns true if line segment 'p1q1'\n# and 'p2q2' intersect.\ndef doIntersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general and\n    # special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if (o1 != o2 and o3 != o4):\n        return True\n\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 and onSegment(p1, p2, q1)):\n        return True\n\n    # p1, q1 and q2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 and onSegment(p1, q2, q1)):\n        return True\n\n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 and onSegment(p2, p1, q2)):\n        return True\n\n     # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 and onSegment(p2, q1, q2)):\n        return True\n\n    # Doesn't fall in any of the above cases\n    return False\n\ndef get_angle(p, q):\n    x = q[0] - p[0]\n    y = q[1] - p[1]\n    return degrees(atan2(y, x))\n\ndef get_min_angle_diff(points):\n    angles = []\n    for i in range(len(points)):\n        angles.append(get_angle(points[0], points[i]))\n    angles.sort()\n    min_diff = float('inf')\n    for i in range(len(angles) - 1):\n        diff = angles[i+1] - angles[i]\n        if diff < min_diff:\n            min_diff = diff\n    diff = angles[0] - angles[-1] + 360\n    if diff < min_diff:\n        min_diff = diff\n    return min_diff\n\n\ndef main():\n    num_points = int(input())\n    points = []\n    for i in range(num_points):\n        line = sys.stdin.readline()\n        points.append(list(map(float, line.split())))\n\n    min_angle_diff = float('inf')\n    for i in range(num_points):\n        for j in range(num_points):\n            if i == j:\n                continue\n            p1 = points[i]\n            p2 = points[j]\n            q1 = [p1[0] + 1, p1[1]]\n            q2 = [p2[0] + 1, p2[1]]\n            intersects = False\n            for k in range(num_points):\n                if k == i or k == j:\n                    continue\n                for l in range(k+1, num_points):\n                    if l == i or l == j:\n                        continue\n                    if doIntersect(p1, q1, points[k], points[l]):\n                        intersects = True\n                        break\n                    if doIntersect(p2, q2, points[k], points[l]):\n                        intersects = True\n                        break\n                if intersects:\n                    break\n            if not intersects:\n                angle_diff = get_min_angle_diff(points)\n                if angle_diff < min_angle_diff:\n                    min_angle_diff = angle_diff\n    print('{0:.3f}'.format(min_angle_diff))\n\nif __name__ == '__main__':\n    main()"
}
2022-04-18 03:49:09.167580 REASON stop
2022-04-18 03:49:09.168043 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    number_of_points = int(input())\n    point_list = []\n    for _ in range(number_of_points):\n        point_list.append(list(map(float, input().split())))\n    max_length = 0\n    for i in range(number_of_points-1):\n        for j in range(i+1, number_of_points):\n            length = ((point_list[i][0]-point_list[j][0])**2 + (point_list[i][1]-point_list[j][1])**2)**0.5\n            if length > max_length:\n                max_length = length\n    print(max_length)\n\n\nif __name__ == \"__main__\":\n    main()"
}
2022-04-18 03:49:09.168112 REASON stop
