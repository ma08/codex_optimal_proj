["\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nmin_win = 0\nmax_win = 0\n\nfor i in range(3):\n    for j in range(3):\n        if a[i] == 0 or b[j] == 0:\n            continue\n        else:\n            if (i - j)%3 == 1:\n                min_win += min(a[i],b[j])\n            elif (i - j)%3 == 2:\n                max_win += min(a[i],b[j])\n\nprint(min_win,max_win)\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(3):\n    if a[i] == n or b[i] == n:\n        continue\n    else:\n        if (i - i)%3 == 1:\n            ans += min(a[i],b[i])\n        elif (i - i)%3 == 2:\n            ans += min(a[i],b[i])\n\nprint(ans,n-ans)\n", "\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nmin_win = 0\nmax_win = 0\n\nfor i in range(3):\n    for j in range(3):\n        if a[i] == 0 or b[j] == 0:\n            continue\n        else:\n            if (i - j)%3 == 1:\n                min_win += min(a[i],b[j])\n            elif (i - j)%3 == 2:\n                max_win += min(a[i],b[j])\n\nprint(min_win,max_win)\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(3):\n    if a[i] == n or b[i] == n:\n        continue\n    else:\n        if (i - i)%3 == 1:\n            ans += min(a[i],b[i])\n        elif (i - i)%3 == 2:\n            ans += min(a[i],b[i])\n\nprint(ans,n - ans)\n", "var fs = require('fs');\n\nvar readFile = function (file) {\n    return new Promise(function (resolve, reject) {\n        fs.readFile(file, function(error, data) {\n            if (error) return reject(error);\n            resolve(data);\n        });\n    });\n};\n\nvar asyncReadFile = async function () {\n    var f1 = await readFile('file1.txt');\n    var f2 = await readFile('file2.txt');\n    console.log(f1.toString());\n    console.log(f2.toString());\n};\n\nasyncReadFile();\n", "\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(n):\n    if a[i] == b[i]:\n        continue    \n    elif (a[i] - b[i])%3 == 1:\n        ans += min(a[i],b[i])\n    elif (a[i] - b[i])%3 == 2:\n        ans += min(a[i],b[i])\n\nprint(ans,n-ans)\n", "var fs = require('fs');\n\nvar file = fs.readFileSync(process.argv[2], 'utf8');\nvar lines = file.split('\\n').length - 1;\nconsole.log(lines);\n", "// Array of objects\nvar people = [\n  {\n    name: 'John Doe',\n    age: 30,\n    gender: 'male'\n  },\n  {\n    name: 'Jane Doe',\n    age: 25,\n    gender: 'female'\n  },\n  {\n    name: 'Steven Smith',\n    age: 32,\n    gender: 'male'\n  },\n  {\n    name: 'Stacy Williams',\n    age: 21,\n    gender: 'female'\n  }\n];\n\n// Loop through array\nfor (var i = 0; i < people.length; i++) {\n  // Create new div element\n  var div = document.createElement('div');\n  // Assign class attribute\n  div.setAttribute('class', 'person');\n  // Add text node with person's name\n  div.appendChild(document.createTextNode(people[i].name));\n  // Add div element to DOM\n  document.getElementById('people').appendChild(div);\n}\n", "\n\n# n = int(input())\n# a = list(map(int,input().split()))\n# b = list(map(int,input().split()))\n#\n# min_win = 0\n# max_win = 0\n#\n# for i in range(3):\n#     for j in range(3):\n#         if a[i] == 0 or b[j] == 0:\n#             continue\n#         else:\n#             if (i - j)%3 == 1:\n#                 min_win += min(a[i],b[j])\n#             elif (i - j)%3 == 2:\n#                 max_win += min(a[i],b[j])\n#\n# print(min_win,max_win)\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(3):\n    if a[i] == 0 or b[i] == 0:\n        continue\n    else:\n        if (i - i + 1)%3 == 1:\n            ans += min(a[i],b[i])\n        elif (i - i + 1)%3 == 2:\n            ans += min(a[i],b[i])\n\nprint(ans,n-ans)\n", "\n\nn = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nif a[0] > b[1]:\n    a[0] -= b[1]\n    b[1] = 0\nelse:\n    b[1] -= a[0]\n    a[0] = 0\nif a[2] > b[0]:\n    a[2] -= b[0]\n    b[0] = 0\nelse:\n    b[0] -= a[2]\n    a[2] = 0\nif a[1] > b[2]:\n    a[1] -= b[2]\n    b[2] = 0\nelse:\n    b[2] -= a[1]\n    a[1] = 0\nif a[0] > 0:\n    print(min(a), max(a))\nelse:\n    print(0, 0)\n", "\n\n# n = int(input())\n# a = list(map(int,input().split()))\n# b = list(map(int,input().split()))\n#\n# min_win = 0\n# max_win = 0\n#\n# for i in range(3):\n#     for j in range(3):\n#         if a[i] == 0 or b[j] == 0:\n#             continue\n#         else:\n#             if (i - j)%3 == 1:\n#                 min_win += min(a[i],b[j])\n#             elif (i - j)%3 == 2:\n#                 max_win += min(a[i],b[j])\n#\n# print(min_win,max_win)\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(3):\n    if a[i] == n or b[i] == n:\n        continue\n    else:\n        if (i - i) % 3 == 1:\n            ans += min(a[i],b[i])\n        elif (i - i) % 3 == 2:\n            ans += min(a[i],b[i])\n\nprint(ans,n-ans)\n", "import sys\n\n\ndef main():\n    file_name = sys.argv[1]\n    print(\"File name is: \" + file_name)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\nimport math\n\ndef is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, math.floor(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef main():\n    n = int(input())\n    for i in range(n):\n        if is_prime(i) and is_prime(i + 6):\n            print(i, i + 6)\n\nif __name__ == \"__main__\":\n    main()\n", "\nn = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nif a[0] > b[1]:  # Assume the first player attacks the second player\n    a[0] -= b[1]\n    b[1] = 0\nelse:\n    b[1] -= a[0]\n    a[0] = 0\nif a[2] > b[0]:  # Assume the first player attacks the third player\n    a[2] -= b[0]\n    b[0] = 0\nelse:\n    b[0] -= a[2]\n    a[2] = 0\nif a[1] > b[2]:  # Assume the second player attacks the third player\n    a[1] -= b[2]\n    b[2] = 0\nelse:\n    b[2] -= a[1]\n    a[1] = 0\n\nprint(min(a), max(a))\n", "\n\n# n = int(input())\n# a = list(map(int,input().split()))\n# b = list(map(int,input().split()))\n#\n# min_win = 0\n# max_win = 0\n#\n# for i in range(3):\n#     for j in range(3):\n#         if a[i] == 0 or b[j] == 0:\n#             continue\n#         else:\n#             if (i - j)%3 == 1:\n#                 min_win += min(a[i],b[j])\n#             elif (i - j)%3 == 2:\n#                 max_win += min(a[i],b[j])\n#\n# print(min_win,max_win)\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nans = 0\n\nfor i in range(3):\n    if a[i] == n or b[i] == n:\n        continue\n    else:\n        if (i - i)%3 == 1:\n            ans += min(a[i],b[i])\n        elif (i - i)%3 == 2:\n            ans += min(a[i],b[i])\n\nprint(ans,n-ans)\n\n# a = list(map(int,input().split()))\n# b = list(map(int,input().split()))\n#\n# c = [0,0,0]\n#\n# for i in range(3):\n#     for j in range(3):\n#         if a[i] == 0 or b[j] == 0:\n#             continue\n#         else:\n#             if (i - j)%3 == 1:\n#                 c[0] += min(a[i],b[j])\n#             elif (i - j)%3 == 2:\n#                 c[2] += min(a[i],b[j])\n#             else:\n#                 c[1] += min(a[i],b[j])\n#\n# print(c[0],c[1],c[2])\n", "#!/usr/bin/python\n\nimport os\n\ndef get_dirlist(path):\n    \"\"\"\n      Return a sorted list of all entries in path.\n      This returns just the names, not the full path to the names.\n    \"\"\"\n    dirlist = os.listdir(path)\n    dirlist.sort()\n    return dirlist\n\ndef print_files(path, prefix = \"\"):\n    \"\"\" Print recursive listing of contents of path \"\"\"\n    if prefix == \"\":  # Detect outermost call, print a heading\n        print \"Folder listing for\", path\n        prefix = \"| \"\n\n    dirlist = get_dirlist(path)\n    for f in dirlist:\n        print prefix+f\n        # Compute the prefix and pass to next level\n        if os.path.isdir(path+\"/\"+f):\n            print_files(path+\"/\"+f, prefix + \"| \")\n\ndef duplicate_files(src_dir, dst_dir):\n    \"\"\"\n    Duplicate all files (not directories) in src_dir to dst_dir.\n    Do not overwrite existing files.\n    \"\"\"\n    names = os.listdir(src_dir)\n    for name in names:\n        src_name = os.path.join(src_dir, name)\n        dst_name = os.path.join(dst_dir, name)\n        if os.path.isfile(src_name):\n            if not os.path.exists(dst_name):\n                open(dst_name, \"w\").write(open(src_name).read())\n                print \"Copying\", src_name, \"to\", dst_name\n\ndef compare_files(path1, path2):\n    \"\"\"\n    Compare all files in two directories.\n    Return a list of files that differ.\n    \"\"\"\n    files1 = get_dirlist(path1)\n    files2 = get_dirlist(path2)\n    only1 = []\n    only2 = []\n    both = []\n    for name in files1:\n        if name in files2:\n            both.append(name)\n        else:\n            only1.append(name)\n    for name in files2:\n        if name not in files1:\n            only2.append(name)\n    return only1, only2, both\n\nif __name__ == \"__main__\":\n    print get_dirlist(\".\")\n    print_files(\".\")\n    duplicate_files(\"/tmp/foo\", \"/tmp/bar\")\n    print compare_files(\"/tmp/foo\", \"/tmp/bar\")\n", "\nn = int(input()) \na = list(map(int, input().split())) \nb = list(map(int, input().split())) \n \nans = 0 \nfor i in range(n): \n    if a[i] > b[i]: \n        ans += a[i] - b[i] \n    else: \n        ans += b[i] - a[i] \nprint(ans // 2)\n", "\n\n# n = int(input())\n# a = list(map(int,input().split()))\n# b = list(map(int,input().split()))\n#\n# min_win = 0\n# max_win = 0\n#\n# for i in range(3):\n#     for j in range(3):\n#         if a[i] == 0 or b[j] == 0:\n#             continue\n#         else:\n#             if (i - j)%3 == 1:\n#                 min_win += min(a[i],b[j])\n#             elif (i - j)%3 == 2:\n#                 max_win += min(a[i],b[j])\n#\n# print(min_win,max_win)\n\n# n = int(input())\n# a = list(map(int,input().split()))\n# b = list(map(int,input().split()))\n#\n# ans = 0\n#\n# for i in range(3):\n#     if a[i] == n or b[i] == n:\n#         continue\n#     else:\n#         if (i - i)%3 == 1:\n#             ans += min(a[i],b[i])\n#         elif (i - i)%3 == 2:\n#             ans += min(a[i],b[i])\n#\n# print(ans,n-ans)\n", "\n\nn = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nmin_win = 0\nmax_win = 0\n\nfor i in range(3):\n    for j in range(3):\n        if a[i] == 0 or b[j] == 0:\n            continue\n        else:\n            if (i - j)%3 == 1:\n                min_win += min(a[i],b[j])\n            elif (i - j)%3 == 2:\n                max_win += min(a[i],b[j])\n\nprint(min_win,max_win)\n", "\nn = int(input())\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\n\nif a[0] > b[1]:\n    a[0] -= b[1]\n    b[1] = 0\nelse:\n    b[1] -= a[0]\n    a[0] = 0\nif a[2] > b[0]:\n    a[2] -= b[0]\n    b[0] = 0\nelse:\n    b[0] -= a[2]\n    a[2] = 0\nif a[1] > b[2]:\n    a[1] -= b[2]\n    b[2] = 0\nelse:\n    b[2] -= a[1]\n    a[1] = 0\n\nprint(min(a), max(a))\n", "// FILE\n\n// The fs module provides an API for interacting with the file system in a manner closely modeled around standard POSIX functions.\n\n// All file system operations have synchronous and asynchronous forms.\n\n// The asynchronous form always takes a completion callback as its last argument. The arguments passed to the completion callback depend on the method, but the first argument is always reserved for an exception. If the operation was completed successfully, then the first argument will be null or undefined.\n\n// SYNTAX\n\n// fs.readFile(path[, options], callback)\n// Asynchronous readFile - Asynchronously reads the entire contents of a file.\n\n// fs.readFileSync(path[, options])\n// Synchronous readFile - Synchronously reads the entire contents of a file.\n\n// fs.writeFile(file, data[, options], callback)\n// Asynchronous writeFile - Asynchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer.\n\n// fs.writeFileSync(file, data[, options])\n// Synchronous writeFile - Synchronously writes data to a file, replacing the file if it already exists. data can be a string or a buffer.\n\n// fs.appendFile(file, data[, options], callback)\n// Asynchronous appendFile - Asynchronously appends data to a file, creating the file if it not yet exists. data can be a string or a buffer.\n\n// fs.appendFileSync(file, data[, options])\n// Synchronous appendFile - Synchronously appends data to a file, creating the file if it not yet exists. data can be a string or a buffer.\n\n// fs.open(path, flags[, mode], callback)\n// Asynchronous file open - Asynchronously opens a file for reading or writing.\n\n// fs.openSync(path, flags[, mode])\n// Synchronous file open - Synchronously opens a file for reading or writing.\n\n// fs.close(fd, callback)\n// Asynchronous close - Asynchronously closes a file descriptor.\n\n// fs.closeSync(fd)\n// Synchronous close - Synchronously closes a file descriptor.\n\n// fs.read(fd, buffer, offset, length, position, callback)\n// Asynchronous read - Reads data from the file specified by fd.\n\n// fs.readSync(fd, buffer, offset, length, position)\n// Synchronous read - Reads data from the file specified by fd.\n\n// fs.write(fd, buffer, offset, length[, position], callback)\n// Asynchronous write - Writes buffer to the file specified by fd.\n\n// fs.writeSync(fd, buffer, offset, length[, position])\n// Synchronous write - Writes buffer to the file specified by fd.\n\n// fs.rename(oldPath, newPath, callback)\n// Asynchronous rename - Renames the file specified by oldPath to newPath.\n\n// fs.renameSync(oldPath, newPath)\n// Synchronous rename - Renames the file specified by oldPath to newPath.\n\n// fs.truncate(path, len, callback)\n// Asynchronous truncate - Truncates the file specified by path to a specified length.\n\n// fs.truncateSync(path, len)\n// Synchronous truncate - Truncates the file specified by path to a specified length.\n\n// fs.ftruncate(fd, len, callback)\n// Asynchronous ftruncate - Truncates the file specified by fd to a specified length.\n\n// fs.ftruncateSync(fd, len)\n// Synchronous ftruncate - Truncates the file specified by fd to a specified length.\n\n// fs.rmdir(path, callback)\n// Asynchronous rmdir - Removes the directory specified by path.\n\n// fs.rmdirSync(path)\n// Synchronous rmdir - Removes the directory specified by path.\n\n// fs.mkdir(path[, mode], callback)\n// Asynchronous mkdir - Creates the directory specified by path.\n\n// fs.mkdirSync(path[, mode])\n// Synchronous mkdir - Creates the directory specified by path.\n\n// fs.readdir(path, callback)\n// Asynchronous readdir - Reads the contents of a directory.\n\n// fs.readdirSync(path)\n// Synchronous readdir - Synchronously reads the contents of a directory.\n\n// fs.fstat(fd, callback)\n// Asynchronous fstat - Gets the file status.\n\n// fs.fstatSync(fd)\n// Synchronous fstat - Gets the file status.\n\n// fs.lstat(path, callback)\n// Asynchronous lstat - Gets the file status. Does not dereference symbolic links.\n\n// fs.lstatSync(path)\n// Synchronous lstat - Gets the file status. Does not dereference symbolic links.\n\n// fs.stat(path, callback)\n// Asynchronous stat - Gets the file status.\n\n// fs.statSync(path)\n// Synchronous stat - Gets the file status.\n\n// fs.link(srcpath, dstpath, callback)\n// Asynchronous link - Creates a hard link.\n\n// fs.linkSync(srcpath, dstpath)\n// Synchronous link - Creates a hard link.\n\n// fs.symlink(srcpath, dstpath[, type], callback)\n// Asynchronous symlink - Creates a symbolic link.\n\n// fs.symlinkSync(srcpath, dstpath[, type])\n// Synchronous symlink - Creates a symbolic link.\n\n// fs.readlink(path, callback)\n// Asynchronous readlink - Reads the value of a symbolic link.\n\n// fs.readlinkSync(path)\n// Synchronous readlink - Reads the value of a symbolic link.\n\n// fs.realpath(path[, cache], callback)\n// Asynchronous realpath - Returns the canonicalized absolute pathname.\n\n// fs.realpathSync(path[, cache])\n// Synchronous realpath - Returns the canonicalized absolute pathname.\n\n// fs.unlink(path, callback)\n// Asynchronous unlink - Removes the file specified by path.\n\n// fs.unlinkSync(path)\n// Synchronous unlink - Removes the file specified by path.\n\n// fs.fsync(fd, callback)\n// Asynchronous fsync - Synchronizes a file's in-core state with the underlying storage device.\n\n// fs.fsyncSync(fd)\n// Synchronous fsync - Synchronizes a file's in-core state with the underlying storage device.\n\n// fs.writeSync(fd, data[, position[, encoding]])\n// Synchronous write - Writes buffer to the file specified by fd.\n\n// fs.write(fd, data[, position[, encoding]], callback)\n// Asynchronous write - Writes buffer to the file specified by fd.\n\n// fs.read(fd, buffer, offset, length, position, callback)\n// Asynchronous read - Reads data from the file specified by fd.\n\n// fs.readSync(fd, buffer, offset, length, position)\n// Synchronous read - Reads data from the file specified by fd.\n", "const fs = require('fs');\n\n// fs.readFile('./docs/blog1.txt', (err, data) => {\n//     if (err) {\n//         console.log(err);\n//     }\n//     console.log(data.toString());\n// });\n\n// fs.writeFile('./docs/blog1.txt', 'hello, world', () => {\n//     console.log('file was written');\n// });\n\n// fs.writeFile('./docs/blog3.txt', 'hello, again', () => {\n//     console.log('file was written');\n// });\n\n// fs.writeFile('./docs/blog2.txt', 'hello, again', () => {\n//     console.log('file was written');\n// });\n\n// fs.readdir('./docs', (err, files) => {\n//     if (err) {\n//         console.log(err);\n//     }\n//     console.log(files);\n// });\n\n// fs.rename('./docs/blog1.txt', './docs/blogone.txt', (err) => {\n//     if (err) {\n//         console.log(err);\n//     }\n//     console.log('file renamed');\n// });\n\nfs.unlink('./docs/deleteme.txt', (err) => {\n    if (err) {\n        console.log(err);\n    }\n    console.log('file deleted');\n});\n", "const fs = require(\"fs\");\n\nconst readFile = (path) => {\n    return new Promise((resolve, reject) => {\n        fs.readFile(path, \"utf8\", (err, data) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(data);\n            }\n        });\n    });\n};\n\nconst writeFile = (path, data) => {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(path, data, (err) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve();\n            }\n        });\n    });\n};\n\nmodule.exports = {\n    readFile,\n    writeFile\n};\n"]