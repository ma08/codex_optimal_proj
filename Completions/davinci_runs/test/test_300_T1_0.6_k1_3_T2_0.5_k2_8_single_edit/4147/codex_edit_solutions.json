["\n\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort()\n    bamboos.reverse()\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if A in bamboos:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for b in bamboos:\n        # if b is shorter than A - B\n        if b < A - B:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if b < A - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if b < A:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if B in bamboos:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for b in bamboos:\n        # if b is shorter than B - C\n        if b < B - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if b < B:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if C in bamboos:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for b in bamboos:\n        # if b is shorter than C\n        if b < C:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, [input() for _ in range(N)]))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\nif __name__ == '__main__':\n    main()\n", "\n\n\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort()\n    bamboos.reverse()\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if A in bamboos:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for b in bamboos:\n        # if b is shorter than A - B\n        if b < A - B:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if b < A - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if b < A:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if B in bamboos:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for b in bamboos:\n        # if b is shorter than B - C\n        if b < B - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if b < B:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if C in bamboos:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for b in bamboos:\n        # if b is shorter than C\n        if b < C:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, [input() for i in range(N)]))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list[int]\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort(reverse=True)\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if A in bamboos:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for b in bamboos:\n        # if b is shorter than A - B\n        if b < A - B:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if b < A - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if b < A:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if B in bamboos:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for b in bamboos:\n        # if b is shorter than B - C\n        if b < B - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if b < B:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if C in bamboos:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for b in bamboos:\n        # if b is shorter than C\n        if b < C:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, [input() for i in range(N)]))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list[int]\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort()\n    bamboos.reverse()\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if A in bamboos:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for b in bamboos:\n        # if b is shorter than A - B\n        if b < A - B:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if b < A - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if b < A:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if B in bamboos:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for b in bamboos:\n        # if b is shorter than B - C\n        if b < B - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if b < B:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if C in bamboos:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for b in bamboos:\n        # if b is shorter than C\n        if b < C:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, (input() for i in range(N))))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\nif __name__ == '__main__':\n    main()\n", "\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort()\n    bamboos.reverse()\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if A in bamboos:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for b in bamboos:\n        # if b is shorter than A - B\n        if b < A - B:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if b < A - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if b < A:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if B in bamboos:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for b in bamboos:\n        # if b is shorter than B - C\n        if b < B - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if b < B:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if C in bamboos:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for b in bamboos:\n        # if b is shorter than C\n        if b < C:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, [input() for i in range(N)]))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n# Read the input\nN, A, B, C = map(int, sys.stdin.readline().split())\nl = [int(sys.stdin.readline()) for i in range(N)]\n\n# dp[n][a][b][c] is the minimum amount of MP needed to obtain three bamboos of lengths a, b, c from n bamboos\ndp = [[[[float(\"inf\") for i in range(C+1)] for j in range(B+1)] for k in range(A+1)] for m in range(N+1)]\ndp[0][0][0][0] = 0\n\nfor i in range(N):\n    for a in range(A+1):\n        for b in range(B+1):\n            for c in range(C+1):\n                # Do nothing\n                dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c])\n                # Extend a bamboo\n                if a >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a-l[i]][b][c] + 1)\n                if b >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b-l[i]][c] + 1)\n                if c >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c-l[i]] + 1)\n                # Shorten a bamboo\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 1)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 1)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 1)\n                # Combine two bamboos\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 10)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 10)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 10)\n\n# Print the answer\nprint(dp[N][A][B][C])\n", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\n\n# dp[i][j][k] = min(mp) to obtain bamboos with lengths of a, b, c from l[0:i]\n# dp[i][j][k] = min(dp[i-1][j][k], dp[i-1][j-1][k-1] + 10, dp[i-1][j-1][k] + 1, dp[i-1][j][k-1] + 1)\ndp = [[[float(\"inf\") for _ in range(n+1)] for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(i+1):\n        for k in range(j+1):\n            if l[i] == a and j == 0:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k])\n            if l[i] == b and k == 0:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if l[i] == c and k == j:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if j > 0 and k > 0 and l[i] + a <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + b <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + c <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and l[i] + 1 <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k]+1)\n            if j > 0 and l[i] - 1 >= 1:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k-1]+1)\n\nprint(dp[n][1][1])\n", "\n\nimport sys\n\n# Read the input\nN, A, B, C = map(int, sys.stdin.readline().split())\nl = [int(sys.stdin.readline()) for i in range(N)]\n\n# dp[n][a][b][c] is the minimum amount of MP needed to obtain three bamboos of lengths a, b, c from n bamboos\ndp = [[[[float(\"inf\") for i in range(C+1)] for j in range(B+1)] for k in range(A+1)] for l in range(N)]\ndp[0][0][0][0] = 0\n\nfor i in range(N):\n    for a in range(A+1):\n        for b in range(B+1):\n            for c in range(C+1):\n                # Do nothing\n                dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c])  # this line is wrong\n                # Extend a bamboo\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a-l[i]][b][c] + 1)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b-l[i]][c] + 1)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c-l[i]] + 1)\n                # Shorten a bamboo\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 1)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 1)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 1)\n                # Combine two bamboos\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 10)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 10)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 10)\n\n# Print the answer\nprint(dp[N][A][B][C])\n", "\n\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort(reverse=True)\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if A in bamboos:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for b in bamboos:\n        # if b is shorter than A - B\n        if b < A - B:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if b < A - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if b < A:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if B in bamboos:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for b in bamboos:\n        # if b is shorter than B - C\n        if b < B - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if b < B:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if C in bamboos:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for b in bamboos:\n        # if b is shorter than C\n        if b < C:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, [input() for i in range(N)]))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\nif __name__ == '__main__':\n    main()\n", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\n\n# dp[i][j][k] = min(mp) to obtain bamboos with lengths of a, b, c from l[0:i]\n# dp[i][j][k] = min(dp[i-1][j][k], dp[i-1][j-1][k-1] + 10, dp[i-1][j-1][k] + 1, dp[i-1][j-1][k] + 1)\ndp = [[[float(\"inf\") for _ in range(n+1)] for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(i+1):\n        for k in range(j+1):\n            if l[i] == a and j == 0:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k])\n            if l[i] == b and k == 0:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if l[i] == c and k == j:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if j > 0 and k > 0 and l[i] + a <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + b <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + c <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and l[i] + 1 <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k]+1)\n            if j > 0 and l[i] - 1 >= 1:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k]+1)\n\nprint(dp[n][1][1] if dp[n][1][1] != float(\"inf\") else -1)\n", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\n\n# dp[i][j][k] = min(mp) to obtain bamboos with lengths of a, b, c from l[0:i]\n# dp[i][j][k] = min(dp[i-1][j][k], dp[i-1][j-1][k-1] + 10, dp[i-1][j-1][k] + 1, dp[i-1][j][k-1] + 1)\ndp = [[[float(\"inf\") for _ in range(n+1)] for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(i+1):\n        for k in range(j+1):\n            if l[i] == a and j == 0 and k == 0:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k])\n            if l[i] == b and j == 0 and k == 0:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if l[i] == c and j == 0 and k == 0:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if j > 0 and k > 0 and l[i] + a <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10, dp[i][j-1][k]+10)\n            if j > 0 and k > 0 and l[i] + b <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10, dp[i][j-1][k]+10)\n            if j > 0 and k > 0 and l[i] + c <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10, dp[i][j-1][k]+10)\n            if j > 0 and l[i] + 1 <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k]+1)\n            if j > 0 and l[i] - 1 >= 1:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k-1]+1)\n\nprint(dp[n][1][1])\n", "\n \nimport sys\n\n# Read the input\nN, A, B, C = map(int, sys.stdin.readline().split())\nl = [int(sys.stdin.readline()) for i in range(N)]\n\n# dp[n][a][b][c] is the minimum amount of MP needed to obtain three bamboos of lengths a, b, c from n bamboos\ndp = [[[[float(\"inf\") for i in range(C+1)] for j in range(B+1)] for k in range(A+1)] for l in range(N+1)]\ndp[0][0][0][0] = 0\n\nfor i in range(N):\n    for a in range(A+1):\n        for b in range(B+1):\n            for c in range(C+1):\n                # Do nothing\n                dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c])\n                # Extend a bamboo\n                if a >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a-l[i]][b][c] + 1)\n                if b >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b-l[i]][c] + 1)\n                if c >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c-l[i]] + 1)\n                # Shorten a bamboo\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 1)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 1)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 1)\n                # Combine two bamboos\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 10)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 10)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 10)\n\n# Print the answer\nprint(dp[N][A][B][C])\n", "\n\nimport sys\n\n# Read the input\nN, A, B, C = map(int, sys.stdin.readline().split())\nl = [int(sys.stdin.readline()) for i in range(N)]\n\n# dp[n][a][b][c] is the minimum amount of MP needed to obtain three bamboos of lengths a, b, c from n bamboos.\ndp = [[[[float(\"inf\") for i in range(C+1)] for j in range(B+1)] for k in range(A+1)] for l in range(N+1)]\ndp[0][0][0][0] = 0\n\nfor i in range(N):\n    for a in range(A+1):\n        for b in range(B+1):\n            for c in range(C+1):\n                # Do nothing.\n                dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c])\n                # Extend a bamboo.\n                if a >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a-l[i]][b][c] + 1)\n                if b >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b-l[i]][c] + 1)\n                if c >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c-l[i]] + 1)\n                # Shorten a bamboo.\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 1)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 1)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 1)\n                # Combine two bamboos.\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 10)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 10)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 10)\n\n# Print the answer\nprint(dp[N][A][B][C])\n", "\n\nimport sys\n\n# Read the input\nN, A, B, C = map(int, sys.stdin.readline().split())\nl = [int(sys.stdin.readline()) for i in range(N)]\n\n# dp[n][a][b][c] is the minimum amount of MP needed to obtain three bamboos of lengths a, b, c from n bamboos if the last bamboo is not used\ndp = [[[[float(\"inf\") for i in range(C+1)] for j in range(B+1)] for k in range(A+1)] for l in range(N+1)]\ndp[0][0][0][0] = 0\n\nfor i in range(N):\n    for a in range(A+1):\n        for b in range(B+1):\n            for c in range(C+1):\n                # Extend a bamboo\n                if a >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a-l[i]][b][c] + 1)\n                if b >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b-l[i]][c] + 1)\n                if c >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c-l[i]] + 1)\n                # Shorten a bamboo\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 1)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 1)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 1)\n                # Combine two bamboos\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 10)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 10)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 10)\n\n# Print the answer\nprint(dp[N][A][B][C])\n", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\n\n# dp[i][j][k] = min(mp) to obtain bamboos with lengths of a, b, c from l[0:i]\n# dp[i][j][k] = min(dp[i-1][j][k], dp[i-1][j-1][k-1] + 10, dp[i-1][j-1][k] + 1, dp[i-1][j][k-1] + 1)\ndp = [[[float(\"inf\") for _ in range(n+1)] for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(i+1):\n        for k in range(j+1):\n            if i == 0 and j == 0 and k == 0:\n                continue\n            if l[i] == a:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k])\n            if l[i] == b:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if l[i] == c:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if j > 0 and k > 0 and l[i] + a <= 3000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + b <= 3000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + c <= 3000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and l[i] + 1 <= 3000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k]+1)\n            if k > 0 and l[i] - 1 >= 1:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k]+1)\n\nprint(dp[n][1][1])\n", "\n\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort()\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if A in bamboos:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for b in bamboos:\n        # if b is shorter than A - B\n        if b < A - B:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if b < A - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if b < A:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if B in bamboos:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for b in bamboos:\n        # if b is shorter than B - C\n        if b < B - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if b < B:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if C in bamboos:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for b in bamboos:\n        # if b is shorter than C\n        if b < C:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, [input() for i in range(N)]))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\nif __name__ == '__main__':\n    main()\n", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\n\n# dp[i][j][k] = min(mp) to obtain bamboos with lengths of a, b, c from l[0:i+1]\n# dp[i][j][k] = min(dp[i-1][j][k], dp[i-1][j-1][k-1] + 10, dp[i-1][j-1][k] + 1, dp[i-1][j-1][k] + 1)\ndp = [[[float(\"inf\") for _ in range(n)] for _ in range(n)] for _ in range(n)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(i+1):  # # of bamboos with length of a\n        for k in range(j+1):  # # of bamboos with length of b\n            if l[i] == a and j == 0:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k])\n            if l[i] == b and k == 0:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if l[i] == c and k == j:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if j > 0 and k > 0 and l[i] + a <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + b <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + c <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and l[i] + 1 <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k]+1)\n            if j > 0 and l[i] - 1 >= 1:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k]+1)\n\nprint(dp[n-1][1][1])\n", "\n\nimport sys\n\n# Read the input\nN, A, B, C = map(int, sys.stdin.readline().split())\nl = [int(sys.stdin.readline()) for i in range(N)]\n\n# dp[n][a][b][c] is the minimum amount of MP needed to obtain three bamboos of lengths a, b, c from the first n bamboos\ndp = [[[[float(\"inf\") for i in range(C+1)] for j in range(B+1)] for k in range(A+1)] for l in range(N+1)]\ndp[0][0][0][0] = 0\n\nfor i in range(N):\n    for a in range(A+1):\n        for b in range(B+1):\n            for c in range(C+1):\n                # Do nothing\n                dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c])\n                # Extend a bamboo\n                if a >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a-l[i]][b][c] + 1)\n                # Extend b bamboo\n                if b >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b-l[i]][c] + 1)\n                # Extend c bamboo\n                if c >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c-l[i]] + 1)\n                # Shorten an a bamboo\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 1)\n                # Shorten a b bamboo\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 1)\n                # Shorten a c bamboo\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 1)\n                # Combine a and b bamboos\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 10)\n                # Combine a and c bamboos\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 10)\n                # Combine b and c bamboos\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 10)\n\n# Print the answer\nprint(dp[N][A][B][C])\n", "\n\nimport sys\n\n# Read the input\nN, A, B, C = map(int, sys.stdin.readline().split())\nl = [int(sys.stdin.readline()) for i in range(N)]\n\n# dp[n][a][b][c] is the minimum amount of MP needed to obtain three bamboos of lengths a, b, c from the first n bamboos\ndp = [[[[float(\"inf\") for i in range(C+1)] for j in range(B+1)] for k in range(A+1)] for l in range(N+1)]  # dp[n][a][b][c] = min(dp[n][a][b][c], ...)\ndp[0][0][0][0] = 0\n\nfor i in range(N):\n    for a in range(A+1):  # a > 0\n        for b in range(B+1):  # b > 0\n            for c in range(C+1):  # c > 0\n                # Do nothing\n                dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c])\n                # Extend a bamboo\n                if a >= l[i]:  # a > 0\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a-l[i]][b][c] + 1)\n                if b >= l[i]:  # b > 0\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b-l[i]][c] + 1)\n                if c >= l[i]:  # c > 0\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c-l[i]] + 1)\n                # Shorten a bamboo\n                if a + l[i] <= A:  # a > 0\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 1)\n                if b + l[i] <= B:  # b > 0\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 1)\n                if c + l[i] <= C:  # c > 0\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 1)\n                # Combine two bamboos\n                if a + l[i] <= A:  # a > 0\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 10)\n                if b + l[i] <= B:  # b > 0\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 10)\n                if c + l[i] <= C:  # c > 0\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 10)\n\n# Print the answer\nprint(dp[N][A][B][C])\n", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\n\n# dp[i][j][k] = min(mp) to obtain bamboos with lengths of a, b, c from l[0:i]\n# dp[i][j][k] = min(dp[i-1][j][k], dp[i-1][j-1][k-1] + 10, dp[i-1][j-1][k] + 1, dp[i-1][j-1][k] + 1)\ndp = [[[float(\"inf\") for _ in range(n+1)] for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(i+1):\n        for k in range(j+1):\n            if l[i] == a and j == 0:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k])\n            if l[i] == b and k == 0:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if l[i] == c and k == j:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if j > 0 and k > 0 and l[i] + a <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + b <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + c <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and l[i] + 1 <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k]+1)\n            if j > 0 and l[i] - 1 >= 1:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k]+1)\nprint(dp[n][a][b])\n", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\n\n# dp[i][j][k] = min(mp) to obtain bamboos with lengths of a, b, c from l[0:i+1]\n# dp[i][j][k] = min(dp[i-1][j][k], dp[i-1][j-1][k-1] + 10, dp[i-1][j-1][k] + 1, dp[i-1][j-1][k] + 1)\ndp = [[[float(\"inf\") for _ in range(n+1)] for _ in range(n+1)] for __ in range(n+1)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(i+1):\n        for k in range(j+1):\n            if l[i] == a and j == 0:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k])\n            if l[i] == b and k == 0:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if l[i] == c and k == j:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if j > 0 and k > 0 and l[i] + a <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + b <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + c <= 1000:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and l[i] + 1 <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k]+1)\n            if j > 0 and l[i] - 1 >= 1:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k]+1)\n\nprint(dp[n][1][1])\n", "#!/usr/bin/env python3\n\nimport sys\n\n# Read the input\nN, A, B, C = map(int, sys.stdin.readline().split())\nl = [int(sys.stdin.readline()) for i in range(N)]\n\n# dp[n][a][b][c] is the minimum amount of MP needed to obtain three bamboos of lengths a, b, c from n bamboos\ndp = [[[[float(\"inf\") for i in range(C+1)] for j in range(B+1)] for k in range(A+1)] for l in range(N+1)]\ndp[0][0][0][0] = 0\n\nfor i in range(N):\n    for a in range(A+1):\n        for b in range(B+1):\n            for c in range(C+1):\n                # Do nothing\n                dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c])\n                # Extend a bamboo\n                if a >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a-l[i]][b][c] + 1)\n                if b >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b-l[i]][c] + 1)\n                if c >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c-l[i]] + 1)\n                # Shorten a bamboo\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 1)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 1)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 1)\n                # Combine two bamboos\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 10)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 10)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 10)\n\n# Print the answer\nprint(dp[N][A][B][C])\n", "\n\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort()\n    bamboos.reverse()\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if A in bamboos:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for i in range(len(bamboos)):\n        # if b is shorter than A - B\n        if bamboos[i] < A - B:\n            # decrease its length by 1\n            bamboos[i] -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if bamboos[i] < A - C:\n            # decrease its length by 1\n            bamboos[i] -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if bamboos[i] < A:\n            # increase its length by 1\n            bamboos[i] += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if B in bamboos:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for i in range(len(bamboos)):\n        # if b is shorter than B - C\n        if bamboos[i] < B - C:\n            # decrease its length by 1\n            bamboos[i] -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if bamboos[i] < B:\n            # increase its length by 1\n            bamboos[i] += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if C in bamboos:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for i in range(len(bamboos)):\n        # if b is shorter than C\n        if bamboos[i] < C:\n            # increase its length by 1\n            bamboos[i] += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, [input() for i in range(N)]))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\nif __name__ == '__main__':\n    main()\n"]