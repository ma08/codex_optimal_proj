2022-04-23 20:51:02.985864 num operations 1
2022-04-23 20:51:02.985895 size on input set 1
2022-04-23 20:51:02.986071 using api key jaanu
2022-04-23 20:51:19.745777 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 1,
      "text": "\n\n# Read input\nn, m, k = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nk1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        k1 += 1\nif k1 != k:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 2,
      "text": "\n\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split()) - 1\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(n):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n)]\nqueue = [0, None]\nvisited[0] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 0 or edge[1] == 0:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    sys.exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    sys.exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 4,
      "text": "\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 5,
      "text": "\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    sys.exit(\"NO\")\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    sys.exit(\"NO\")\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 7,
      "text": "\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges.append((a, b))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print(\"NO\")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n + 1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n + 1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print(\"NO\")\n    exit()\n\n# Print tree\nprint(\"YES\")\nfor edge in tree:\n    print(edge[0], edge[1])\n"
    }
  ],
  "created": 1650747063,
  "object": "edit"
}
2022-04-23 20:51:19.746186 fix syntax errors 8 ['\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\n\n# Read input\nn, m, k = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nk1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        k1 += 1\nif k1 != k:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\n\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split()) - 1\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(n):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n)]\nqueue = [0, None]\nvisited[0] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 0 or edge[1] == 0:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\nimport sys\n\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    sys.exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    sys.exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\nimport sys\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    sys.exit("NO")\n\n# Build graph\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n+1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    sys.exit("NO")\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n', '\n# Read input\nn, m, d = map(int, input().split())\nedges = []\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges.append((a, b))\n\n# Check if possible\npossible = False\nfor i in range(m):\n    if edges[i][0] == 1:\n        possible = True\n        break\n\nif not possible:\n    print("NO")\n    exit()\n\n# Build graph\ngraph = {}\nfor i in range(1, n + 1):\n    graph[i] = []\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n# Find spanning tree\ntree = []\nvisited = [False for _ in range(n + 1)]\nqueue = [1, None]\nvisited[1] = True\nwhile len(queue) > 0:\n    node = queue.pop(0)\n    if node is not None:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                tree.append((node, neighbor))\n                visited[neighbor] = True\n                queue.append(neighbor)\n                queue.append(None)\n                break\n\n# Check if tree is valid\nd1 = 0\nfor edge in tree:\n    if edge[0] == 1 or edge[1] == 1:\n        d1 += 1\nif d1 != d:\n    print("NO")\n    exit()\n\n# Print tree\nprint("YES")\nfor edge in tree:\n    print(edge[0], edge[1])\n']
2022-04-23 20:51:19.746287 size on output set 6
2022-04-23 20:51:19.746301 num operations 1
2022-04-23 20:51:19.746306 size on input set 1
2022-04-23 20:51:19.746427 using api key sunu
2022-04-23 20:51:35.780969 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to\n# STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists, otherwise False.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in sys.stdin.readline().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        edges.append((u, v))\n\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "#!/usr/bin/env python\n\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\nimport random\nimport queue\n\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    # return True if a spanning tree with degree of 1 as D exists.\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "\nimport sys\nimport random\nimport queue\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    \"\"\"\n    return True if a spanning tree with degree of 1 as D exists.\n    \"\"\"\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650747079,
  "object": "edit"
}
2022-04-23 20:51:35.781317 fix syntax errors 8 ['\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to\n# STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists, otherwise False.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in sys.stdin.readline().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        edges.append((u, v))\n\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '#!/usr/bin/env python\n\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport random\nimport queue\n\n# Use input() to read input from STDIN and use print to write your output to STDOUT\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport random\nimport queue\n\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    # return True if a spanning tree with degree of 1 as D exists.\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n', '\nimport sys\nimport random\nimport queue\n\ndef read_data():\n    n, m, D = [int(x) for x in input().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in input().split()]\n        edges.append((u, v))\n    return n, m, D, edges\n\ndef check_degree(n, m, D, edges):\n    """\n    return True if a spanning tree with degree of 1 as D exists.\n    """\n    # Construct the graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degree_1 = len(graph[1])\n    if degree_1 == D:\n        return True\n    elif degree_1 > D:\n        return False\n\n    # BFS\n    visited = set()\n    visited.add(1)\n    q = queue.Queue()\n    for v in graph[1]:\n        q.put((1, v))\n        visited.add(v)\n\n    while not q.empty():\n        u, v = q.get()\n        for w in graph[v]:\n            if w not in visited:\n                visited.add(w)\n                q.put((v, w))\n                if len(visited) == n:\n                    return True\n    return False\n\ndef main():\n    n, m, D, edges = read_data()\n    if check_degree(n, m, D, edges):\n        print("YES")\n    else:\n        print("NO")\n\nif __name__ == "__main__":\n    main()\n']
2022-04-23 20:51:35.781466 size on output set 7
2022-04-23 20:51:35.781480 num operations 1
2022-04-23 20:51:35.781485 size on input set 1
2022-04-23 20:51:35.781604 using api key soukgp
2022-04-23 20:51:53.801693 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom collections import deque\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    },
    {
      "index": 1,
      "text": "\n\n\n\ndef dfs(v, g, used, ans):\n    used[v] = True\n    for u in g[v]:\n        if not used[u]:\n            used[u] = True\n            ans.append((v, u))\n            dfs(u, g, used, ans)\n\nfrom collections import deque\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    used = [False] * n\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    },
    {
      "index": 2,
      "text": "import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split()) - 1\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    },
    {
      "index": 3,
      "text": "from collections import deque\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    },
    {
      "index": 4,
      "text": "\nfrom collections import deque\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    },
    {
      "index": 5,
      "text": "\nfrom collections import deque\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    },
    {
      "index": 6,
      "text": "\nfrom collections import deque\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    },
    {
      "index": 7,
      "text": "\nfrom collections import deque\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    g = [[] for i in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n"
    }
  ],
  "created": 1650747095,
  "object": "edit"
}
2022-04-23 20:51:53.802053 fix syntax errors 8 ['\nfrom collections import deque\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n', '\n\n\n\ndef dfs(v, g, used, ans):\n    used[v] = True\n    for u in g[v]:\n        if not used[u]:\n            used[u] = True\n            ans.append((v, u))\n            dfs(u, g, used, ans)\n\nfrom collections import deque\n\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    used = [False] * n\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n', 'import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split()) - 1\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n', 'from collections import deque\n\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n', '\nfrom collections import deque\n\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n', '\nfrom collections import deque\n\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n', '\nfrom collections import deque\n\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n', '\nfrom collections import deque\n\nif __name__ == "__main__":\n    n, m, d = map(int, input().split())\n    g = [[] for i in range(n)]\n    for _ in range(m):\n        v, u = map(int, input().split())\n        g[v - 1].append(u - 1)\n        g[u - 1].append(v - 1)\n\n    q = deque([0])\n    used = [False] * n\n    used[0] = True\n    ans = []\n\n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if not used[u]:\n                used[u] = True\n                ans.append((v, u))\n                q.append(u)\n\n    if len(ans) < n - 1:\n        print("NO")\n    else:\n        print("YES")\n        if d == 0:\n            for v, u in ans:\n                print(v + 1, u + 1)\n        else:\n            for v, u in ans[:-1]:\n                print(v + 1, u + 1)\n            print(ans[-1][0] + 1, ans[-1][1] + 1)\n            print(1, ans[-1][0] + 1)\n            for i in range(d - 2):\n                print(1, ans[i][1] + 1)\n']
2022-04-23 20:51:53.802132 size on output set 6
