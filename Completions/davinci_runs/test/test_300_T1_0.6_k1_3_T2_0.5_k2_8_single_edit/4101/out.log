2022-04-18 02:24:15.749065 """
You are given a binary matrix $a$ of size $n \times m$. A binary matrix is a matrix where each element is either $0$ or $1$.

You may perform some (possibly zero) operations with this matrix. During each operation you can inverse the row of this matrix or a column of this matrix. Formally, inverting a row is changing all values in this row to the opposite ($0$ to $1$, $1$ to $0$). Inverting a column is changing all values in this column to the opposite.

Your task is to sort the initial matrix by some sequence of such operations. The matrix is considered sorted if the array $[a_{1, 1}, a_{1, 2}, \dots, a_{1, m}, a_{2, 1}, a_{2, 2}, \dots, a_{2, m}, \dots, a_{n, m - 1}, a_{n, m}]$ is sorted in non-descending order.


-----Input-----

The first line of the input contains two integers $n$ and $m$ ($1 \le n, m \le 200$) — the number of rows and the number of columns in the matrix.

The next $n$ lines contain $m$ integers each. The $j$-th element in the $i$-th line is $a_{i, j}$ ($0 \le a_{i, j} \le 1$) — the element of $a$ at position $(i, j)$.


-----Output-----

If it is impossible to obtain a sorted matrix, print "NO" in the first line.

Otherwise print "YES" in the first line. In the second line print a string $r$ of length $n$. The $i$-th character $r_i$ of this string should be '1' if the $i$-th row of the matrix is inverted and '0' otherwise. In the third line print a string $c$ of length $m$. The $j$-th character $c_j$ of this string should be '1' if the $j$-th column of the matrix is inverted and '0' otherwise. If there are multiple answers, you can print any.


-----Examples-----
Input
2 2
1 1
0 1

Output
YES
00
10

Input
3 4
0 0 0 1
0 0 0 0
1 1 1 1

Output
YES
010
0000

Input
3 3
0 0 0
1 0 1
1 1 0

Output
NO
"""
2022-04-18 02:24:15.749090 --------------------------
2022-04-18 02:25:07.831448 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nfrom collections import *\n\nn, m = map(int, input().split())\nm = [[int(i) for i in input().split()] for _ in range(n)]\n\n# if a row is sorted, mark it as \"good\"\n# if a row is not sorted, mark it as \"bad\"\n# if a column has 0s, mark it as \"bad\"\n# if a column has 1s, mark it as \"good\"\n# if a column has both 0s and 1s, mark it as \"bad\"\n\n# after finding all the good and bad rows and columns,\n# we can do the following:\n# if there are more than 1 \"good\" row,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"good\" column,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"bad\" row and\n# more than 1 \"bad\" column, we cannot sort the matrix\n# if there are more than 1 \"bad\" row and 0 \"bad\" column,\n# we can invert any of the \"bad\" rows to make it \"good\"\n# if there are more than 1 \"bad\" column and 0 \"bad\" row,\n# we can invert any of the \"bad\" columns to make it \"good\"\n# if there is 1 \"bad\" row and 1 \"bad\" column,\n# we can invert any 1 of them to make it \"good\"\n\ngood_rows = []\ngood_cols = []\nbad_rows = []\nbad_cols = []\n\nfor i in range(n):\n    if all(m[i]):\n        good_rows.append(i)\n    elif not any(m[i]):\n        bad_rows.append(i)\n\nfor j in range(m):\n    if not any(m[i][j] for i in range(n)):\n        bad_cols.append(j)\n    elif all(m[i][j] for i in range(n)):\n        good_cols.append(j)\n\nif len(good_rows) > 1 or len(good_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_rows) > 1 and len(bad_cols) > 1:\n    print(\"NO\")\nelif len(bad_rows) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelse:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n\n    a = []\n    for i in range(n):\n        a.append([int(x) for x in sys.stdin.readline().split()])\n\n    r = [0]*n\n    c = [0]*m\n\n    for i in range(n):\n        zero = 0\n        one = 0\n        for j in range(m):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            r[i] = 1\n\n    for j in range(m):\n        zero = 0\n        one = 0\n        for i in range(n):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            c[j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if r[i] == 1:\n                a[i][j] = 1 - a[i][j]\n            if c[j] == 1:\n                a[i][j] = 1 - a[i][j]\n\n    sorted = True\n    for i in range(n):\n        for j in range(m-1):\n            if a[i][j] > a[i][j+1]:\n                sorted = False\n\n    if sorted:\n        print(\"YES\")\n        print(\"\".join([str(x) for x in r]))\n        print(\"\".join([str(x) for x in c]))\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n#!/usr/bin/env python\n\n# import sys\n# from math import *\n# from string import *\n# from datetime import *\n# from time import *\n# from random import *\n\n# n, m = map(int, input().split())\n# a = []\n# for i in range(n):\n#     a.append(list(map(int, input().split())))\n\n# #print(n, m)\n# #print(a)\n\n# r = []\n# c = []\n# for i in range(n):\n#     r.append(0)\n# for j in range(m):\n#     c.append(0)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 0:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 1:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# a_sort = []\n# for i in range(n):\n#     for j in range(m):\n#         a_sort.append(a[i][j])\n# a_sort = sorted(a_sort)\n# #print(a_sort)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] != a_sort[i * m + j]:\n#             print(\"NO\")\n#             exit()\n\n# print(\"YES\")\n# print(\"\".join(map(str, r)))\n# print(\"\".join(map(str, c)))\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 1:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\na_sort = []\nfor i in range(n):\n    for j in range(m):\n        a_sort.append(a[i][j])\na_sort = sorted(a_sort)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != a_sort[i * m + j]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(\"\".join(map(str, r)))\nprint(\"\".join(map(str, c)))"
    }
  ],
  "created": 1650248655,
  "id": "cmpl-4yBLj2Pqgtk753QdRj2Nb5om3QmVy",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-18 02:25:07.831754 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nfrom collections import *\n\nn, m = map(int, input().split())\nm = [[int(i) for i in input().split()] for _ in range(n)]\n\n# if a row is sorted, mark it as \"good\"\n# if a row is not sorted, mark it as \"bad\"\n# if a column has 0s, mark it as \"bad\"\n# if a column has 1s, mark it as \"good\"\n# if a column has both 0s and 1s, mark it as \"bad\"\n\n# after finding all the good and bad rows and columns,\n# we can do the following:\n# if there are more than 1 \"good\" row,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"good\" column,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"bad\" row and\n# more than 1 \"bad\" column, we cannot sort the matrix\n# if there are more than 1 \"bad\" row and 0 \"bad\" column,\n# we can invert any of the \"bad\" rows to make it \"good\"\n# if there are more than 1 \"bad\" column and 0 \"bad\" row,\n# we can invert any of the \"bad\" columns to make it \"good\"\n# if there is 1 \"bad\" row and 1 \"bad\" column,\n# we can invert any 1 of them to make it \"good\"\n\ngood_rows = []\ngood_cols = []\nbad_rows = []\nbad_cols = []\n\nfor i in range(n):\n    if all(m[i]):\n        good_rows.append(i)\n    elif not any(m[i]):\n        bad_rows.append(i)\n\nfor j in range(m):\n    if not any(m[i][j] for i in range(n)):\n        bad_cols.append(j)\n    elif all(m[i][j] for i in range(n)):\n        good_cols.append(j)\n\nif len(good_rows) > 1 or len(good_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_rows) > 1 and len(bad_cols) > 1:\n    print(\"NO\")\nelif len(bad_rows) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelse:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)"
}
2022-04-18 02:25:07.831901 REASON stop
2022-04-18 02:25:07.894084 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n\n    a = []\n    for i in range(n):\n        a.append([int(x) for x in sys.stdin.readline().split()])\n\n    r = [0]*n\n    c = [0]*m\n\n    for i in range(n):\n        zero = 0\n        one = 0\n        for j in range(m):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            r[i] = 1\n\n    for j in range(m):\n        zero = 0\n        one = 0\n        for i in range(n):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            c[j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if r[i] == 1:\n                a[i][j] = 1 - a[i][j]\n            if c[j] == 1:\n                a[i][j] = 1 - a[i][j]\n\n    sorted = True\n    for i in range(n):\n        for j in range(m-1):\n            if a[i][j] > a[i][j+1]:\n                sorted = False\n\n    if sorted:\n        print(\"YES\")\n        print(\"\".join([str(x) for x in r]))\n        print(\"\".join([str(x) for x in c]))\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()"
}
2022-04-18 02:25:07.894197 REASON stop
2022-04-18 02:25:07.894971 2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n#!/usr/bin/env python\n\n# import sys\n# from math import *\n# from string import *\n# from datetime import *\n# from time import *\n# from random import *\n\n# n, m = map(int, input().split())\n# a = []\n# for i in range(n):\n#     a.append(list(map(int, input().split())))\n\n# #print(n, m)\n# #print(a)\n\n# r = []\n# c = []\n# for i in range(n):\n#     r.append(0)\n# for j in range(m):\n#     c.append(0)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 0:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 1:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# a_sort = []\n# for i in range(n):\n#     for j in range(m):\n#         a_sort.append(a[i][j])\n# a_sort = sorted(a_sort)\n# #print(a_sort)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] != a_sort[i * m + j]:\n#             print(\"NO\")\n#             exit()\n\n# print(\"YES\")\n# print(\"\".join(map(str, r)))\n# print(\"\".join(map(str, c)))\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 1:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\na_sort = []\nfor i in range(n):\n    for j in range(m):\n        a_sort.append(a[i][j])\na_sort = sorted(a_sort)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != a_sort[i * m + j]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(\"\".join(map(str, r)))\nprint(\"\".join(map(str, c)))"
}
2022-04-18 02:25:07.895077 REASON stop
