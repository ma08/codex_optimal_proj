["\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in input().split()]\n\n    a = []\n    for i in range(n):\n        a.append([int(x) for x in input().split()])\n\n    r = [0]*n\n    c = [0]*m\n\n    for i in range(n):\n        zero = 0\n        one = 0\n        for j in range(m):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            r[i] = 1\n\n    for j in range(m):\n        zero = 0\n        one = 0\n        for i in range(n):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            c[j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if r[i] == 1:\n                a[i][j] = 1 - a[i][j]\n            if c[j] == 1:\n                a[i][j] = 1 - a[i][j]\n\n    sorted = True\n    for i in range(n):\n        for j in range(m-1):\n            if a[i][j] > a[i][j+1]:\n                sorted = False\n\n    if sorted:\n        print(\"YES\")\n        print(\"\".join([str(x) for x in r]), flush=True)\n        print(\"\".join([str(x) for x in c]), flush=True)\n    else:\n        print(\"NO\", flush=True)\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import *\n\nn, m = map(int, input().split())\nm = [list(map(int, input().split())) for _ in range(n)]\n\n# if a row is sorted, mark it as \"good\"\n# if a row is not sorted, mark it as \"bad\"\n# if a column has 0s, mark it as \"bad\"\n# if a column has 1s, mark it as \"good\"\n# if a column has both 0s and 1s, mark it as \"bad\"\n\n# after finding all the good and bad rows and columns,\n# we can do the following:\n# if there are more than 1 \"good\" row,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"good\" column,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"bad\" row and\n# more than 1 \"bad\" column, we cannot sort the matrix\n# if there are more than 1 \"bad\" row and 0 \"bad\" column,\n# we can invert any of the \"bad\" rows to make it \"good\"\n# if there are more than 1 \"bad\" column and 0 \"bad\" row,\n# we can invert any of the \"bad\" columns to make it \"good\"\n# if there is 1 \"bad\" row and 1 \"bad\" column,\n# we can invert any 1 of them to make it \"good\"\n\ngood_rows = []\ngood_cols = []\nbad_rows = []\nbad_cols = []\n\nfor i in range(n):\n    if all(m[i]):\n        good_rows.append(i)\n    elif not any(m[i]):\n        bad_rows.append(i)\n\nfor j in range(m):  # fix this\n    if not any(m[i][j] for i in range(n)):\n        bad_cols.append(j)\n    elif all(m[i][j] for i in range(n)):\n        good_cols.append(j)\n\nif len(good_rows) > 1 or len(good_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_rows) > 1 and len(bad_cols) > 1:\n    print(\"NO\")\nelif len(bad_rows) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelse:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\n", "\n\nfrom collections import *\n\nn, m = map(int, input().split())\nmatrix = [[int(i) for i in input().split()] for _ in range(n)]\n\n# if a row is sorted, mark it as \"good\"\n# if a row is not sorted, mark it as \"bad\"\n# if a column has 0s, mark it as \"bad\"\n# if a column has 1s, mark it as \"good\"\n# if a column has both 0s and 1s, mark it as \"bad\"\n\n# after finding all the good and bad rows and columns,\n# we can do the following:\n# if there are more than 1 \"good\" row,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"good\" column,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"bad\" row and\n# more than 1 \"bad\" column, we cannot sort the matrix\n# if there are more than 1 \"bad\" row and 0 \"bad\" column,\n# we can invert any of the \"bad\" rows to make it \"good\"\n# if there are more than 1 \"bad\" column and 0 \"bad\" row,\n# we can invert any of the \"bad\" columns to make it \"good\"\n# if there is 1 \"bad\" row and 1 \"bad\" column,\n# we can invert any 1 of them to make it \"good\"\n\ngood_rows = []\ngood_cols = []\nbad_rows = []\nbad_cols = []\n\nfor i in range(n):\n    if all(matrix[i]):\n        good_rows.append(i)\n    elif not any(matrix[i]):\n        bad_rows.append(i)\n\nfor j in range(n):\n    if not any(matrix[i][j] for i in range(n)):\n        bad_cols.append(j)\n    elif all(m[i][j] for i in range(n)):\n        good_cols.append(j)\n\nif len(good_rows) > 1 or len(good_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_rows) > 1 and len(bad_cols) > 1:\n    print(\"NO\")\nelif len(bad_rows) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelse:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\n", "\n\nfrom collections import *\n\nn, m = map(int, input().split())\nmatrix = [[int(i) for i in input().split()] for _ in range(n)]\n\n# if a row is sorted, mark it as \"good\"\n# if a row is not sorted, mark it as \"bad\"\n# if a column has 0s, mark it as \"bad\"\n# if a column has 1s, mark it as \"good\"\n# if a column has both 0s and 1s, mark it as \"bad\"\n\n# after finding all the good and bad rows and columns,\n# we can do the following:\n# if there are more than 1 \"good\" row,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"good\" column,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"bad\" row and\n# more than 1 \"bad\" column, we cannot sort the matrix\n# if there are more than 1 \"bad\" row and 0 \"bad\" column,\n# we can invert any of the \"bad\" rows to make it \"good\"\n# if there are more than 1 \"bad\" column and 0 \"bad\" row,\n# we can invert any of the \"bad\" columns to make it \"good\"\n# if there is 1 \"bad\" row and 1 \"bad\" column,\n# we can invert any 1 of them to make it \"good\"\n\ngood_rows = []\ngood_cols = []\nbad_rows = []\nbad_cols = []\n\nfor i in range(n):\n    if all(matrix[i]):\n        good_rows.append(i)\n    elif not any(matrix[i]):\n        bad_rows.append(i)\n\nfor j in range(m):  # m is the number of columns\n    if not any(matrix[i][j] for i in range(n)):\n        bad_cols.append(j)\n    elif all(matrix[i][j] for i in range(n)):\n        good_cols.append(j)\n\nif len(good_rows) > 1 or len(good_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * m)  # m is the number of columns\n    print(\"0\" * n)  # n is the number of rows\nelif len(bad_rows) > 1 and len(bad_cols) > 1:\n    print(\"NO\")\nelif len(bad_rows) > 1:\n    print(\"YES\")\n    print(\"0\" * m)  # m is the number of columns\n    print(\"0\" * n)  # n is the number of rows\nelif len(bad_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * m)  # m is the number of columns\n    print(\"0\" * n)  # n is the number of rows\nelse:\n    print(\"YES\")\n    print(\"0\" * m)  # m is the number of columns\n    print(\"0\" * n)  # n is the number of rows\n", "\n#!/usr/bin/env python\n\n# import sys\n# from math import *  # \u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n# from string import *  # \u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u043e \u0441\u0442\u0440\u043e\u043a\u0430\u043c\u0438\n# from datetime import *  # \u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u0434\u0430\u0442\u043e\u0439 \u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c\n# from time import *  # \u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c\n# from random import *  # \u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u043e \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u043c\u0438 \u0447\u0438\u0441\u043b\u0430\u043c\u0438\n\n# n, m = map(int, input().split())\n# a = []\n# for i in range(n):\n#     a.append(list(map(int, input().split())))\n\n# # print(n, m)\n# # print(a)\n\n# r = []\n# c = []\n# for i in range(n):\n#     r.append(0)\n# for j in range(m):\n#     c.append(0)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 0:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# # print(r)\n# # print(c)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 1:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# # print(r)\n# # print(c)\n\n# a_sort = []\n# for i in range(n):\n#     for j in range(m):\n#         a_sort.append(a[i][j])\n# a_sort = sorted(a_sort)\n# # print(a_sort)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] != a_sort[i * m + j]:\n#             print(\"NO\")\n#             exit()\n\n# print(\"YES\")\n# print(\"\".join(map(str, r)))\n# print(\"\".join(map(str, c)))\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 1:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\na_sort = []\nfor i in range(n):\n    for j in range(m):\n        a_sort.append(a[i][j])\na_sort = sorted(a_sort)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != a_sort[i * m + j]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(\"\".join(map(str, r)))\nprint(\"\".join(map(str, c)))\n", "\n\n#!/usr/bin/env python\n\n# import sys\n# from math import *\n# from string import *\n# from datetime import *\n# from time import *\n# from random import *\n\n# n, m = map(int, input().split())\n# a = []\n# for i in range(n):\n#     a.append(list(map(int, input().split())))\n\n# #print(n, m)\n# #print(a)\n\n# r = []\n# c = []\n# for i in range(n):\n#     r.append(0)\n# for j in range(m):\n#     c.append(0)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 0:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 1:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# a_sort = []\n# for i in range(n):\n#     for j in range(m):\n#         a_sort.append(a[i][j])\n# a_sort = sorted(a_sort)\n# #print(a_sort)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] != a_sort[i * m + j]:\n#             print(\"NO\")\n#             exit()\n\n# print(\"YES\")\n# print(\"\".join(map(str, r)))\n# print(\"\".join(map(str, c)))\n\n# n, m = map(int, input().split())\n# a = []\n# for i in range(n):\n#     a.append(list(map(int, input().split())))\n\n# r = []\n# c = []\n# for i in range(n):\n#     r.append(0)\n# for j in range(m):\n#     c.append(0)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 0:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 1:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# a_sort = []\n# for i in range(n):\n#     for j in range(m):\n#         a_sort.append(a[i][j])\n# a_sort = sorted(a_sort)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] != a_sort[i * m + j]:\n#             print(\"NO\")\n#             exit()\n\n# print(\"YES\")\n# print(\"\".join(map(str, r)))\n# print(\"\".join(map(str, c)))\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 1:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\na_sort = []\nfor i in range(n):\n    for j in range(m):\n        a_sort.append(a[i][j])\na_sort = sorted(a_sort)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != a_sort[i * m + j]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(\"\".join(map(str, r)))\nprint(\"\".join(map(str, c)))\n", "\n\nfrom collections import *\n\nn, m = map(int, input().split())\nm = [[int(i) for i in input().split()] for _ in range(n)]\n\n# if a row is sorted, mark it as \"good\"\n# if a row is not sorted, mark it as \"bad\"\n# if a column has 0s, mark it as \"bad\"\n# if a column has 1s, mark it as \"good\"\n# if a column has both 0s and 1s, mark it as \"bad\"\n\n# after finding all the good and bad rows and columns,\n# we can do the following:\n# if there are more than 1 \"good\" row,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"good\" column,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"bad\" row and\n# more than 1 \"bad\" column, we cannot sort the matrix\n# if there are more than 1 \"bad\" row and 0 \"bad\" column,\n# we can invert any of the \"bad\" rows to make it \"good\"\n# if there are more than 1 \"bad\" column and 0 \"bad\" row,\n# we can invert any of the \"bad\" columns to make it \"good\"\n# if there is 1 \"bad\" row and 1 \"bad\" column,\n# we can invert any 1 of them to make it \"good\"\n\ngood_rows = []\ngood_cols = []\nbad_rows = []\nbad_cols = []\n\nfor i in range(n):\n    if all(m[i]):\n        good_rows.append(i)\n    elif not any(m[i]):\n        bad_rows.append(i)\n\nfor j in range(n):\n    if not any(m[i][j] for i in range(n)):\n        bad_cols.append(j)\n    elif all(m[i][j] for i in range(n)):\n        good_cols.append(j)\n\nif len(good_rows) > 1 or len(good_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * n)\nelif len(bad_rows) > 1 and len(bad_cols) > 1:\n    print(\"NO\")\nelif len(bad_rows) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * n)\nelif len(bad_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * n)\nelse:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * n)\n", "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n\n    a = []\n    for i in range(n):\n        a.append([int(x) for x in sys.stdin.readline().split()])\n\n    r = [0]*n\n    c = [0]*m\n\n    for i in range(n):\n        zero = 0\n        one = 0\n        for j in range(m):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            r[i] = 1\n\n    for j in range(m):\n        zero = 0\n        one = 0\n        for i in range(n):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            c[j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if r[i] == 1:\n                a[i][j] = 1 - a[i][j]\n            if c[j] == 1:\n                a[i][j] = 1 - a[i][j]\n\n    sorted_ = True\n    for i in range(n):\n        for j in range(m-1):\n            if a[i][j] > a[i][j+1]:\n                sorted_ = False\n\n    if sorted_:\n        print(\"YES\")\n        print(\"\".join([str(x) for x in r]))\n        print(\"\".join([str(x) for x in c]))\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()\n", "\n\nfrom collections import *\n\nn, m = map(int, input().split())\nm = [[int(i) for i in input().split()] for _ in range(n)]\n\n# if a row is sorted, mark it as \"good\"\n# if a row is not sorted, mark it as \"bad\"\n# if a column has 0s, mark it as \"bad\"\n# if a column has 1s, mark it as \"good\"\n# if a column has both 0s and 1s, mark it as \"bad\"\n\n# after finding all the good and bad rows and columns,\n# we can do the following:\n# if there are more than 1 \"good\" row,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"good\" column,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"bad\" row and\n# more than 1 \"bad\" column, we cannot sort the matrix\n# if there are more than 1 \"bad\" row and 0 \"bad\" column,\n# we can invert any of the \"bad\" rows to make it \"good\"\n# if there are more than 1 \"bad\" column and 0 \"bad\" row,\n# we can invert any of the \"bad\" columns to make it \"good\"\n# if there is 1 \"bad\" row and 1 \"bad\" column,\n# we can invert any 1 of them to make it \"good\"\n\ngood_rows = []\ngood_cols = []\nbad_rows = []\nbad_cols = []\n\nfor i in range(n):\n    if all(m[i]):\n        good_rows.append(i)\n    elif not any(m[i]):\n        bad_rows.append(i)\n\nfor j in range(n):\n    if not any(m[i][j] for i in range(n)):\n        bad_cols.append(j)\n    elif all(m[i][j] for i in range(n)):\n        good_cols.append(j)\n\nif len(good_rows) > 1 or len(good_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * m)\n    print(\"0\" * n)\nelif len(bad_rows) > 1 and len(bad_cols) > 1:\n    print(\"NO\")\nelif len(bad_rows) > 1:\n    print(\"YES\")\n    print(\"0\" * m)\n    print(\"0\" * n)\nelif len(bad_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * m)\n    print(\"0\" * n)\nelse:\n    print(\"YES\")\n    print(\"0\" * m)\n    print(\"0\" * n)\n", "\n\n#!/usr/bin/env python\n\nimport sys\nfrom math import *\nfrom string import *\nfrom datetime import *\nfrom time import *\nfrom random import *\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\n# #print(n, m)\n# #print(a)\n\n# r = []\n# c = []\n# for i in range(n):\n#     r.append(0)\n# for j in range(m):\n#     c.append(0)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 0:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 1:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# a_sort = []\n# for i in range(n):\n#     for j in range(m):\n#         a_sort.append(a[i][j])\n# a_sort = sorted(a_sort)\n# #print(a_sort)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] != a_sort[i * m + j]:\n#             print(\"NO\")\n#             exit()\n\n# print(\"YES\")\n# print(\"\".join(map(str, r)))\n# print(\"\".join(map(str, c)))\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 1:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\na_sort = []\nfor i in range(n):\n    for j in range(m):\n        a_sort.append(a[i][j])\na_sort = sorted(a_sort)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != a_sort[i * m + j]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(\"\".join(map(str, r)))\nprint(\"\".join(map(str, c)))\n", "\n\nfrom collections import *\n\nn, m = map(int, input().split())\nm = [[int(j) for j in input().split()] for _ in range(n)]\n\n# if a row is sorted, mark it as \"good\"\n# if a row is not sorted, mark it as \"bad\"\n# if a column has 0s, mark it as \"bad\"\n# if a column has 1s, mark it as \"good\"\n# if a column has both 0s and 1s, mark it as \"bad\"\n\n# after finding all the good and bad rows and columns,\n# we can do the following:\n# if there are more than 1 \"good\" row,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"good\" column,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"bad\" row and\n# more than 1 \"bad\" column, we cannot sort the matrix\n# if there are more than 1 \"bad\" row and 0 \"bad\" column,\n# we can invert any of the \"bad\" rows to make it \"good\"\n# if there are more than 1 \"bad\" column and 0 \"bad\" row,\n# we can invert any of the \"bad\" columns to make it \"good\"\n# if there is 1 \"bad\" row and 1 \"bad\" column,\n# we can invert any 1 of them to make it \"good\"\n\ngood_rows = []\ngood_cols = []\nbad_rows = []\nbad_cols = []\n\nfor i in range(n):\n    if all(m[i]):\n        good_rows.append(i)\n    elif not any(m[i]):\n        bad_rows.append(i)\n\nfor j in range(n):\n    if not any(m[i][j] for i in range(n)):\n        bad_cols.append(j)\n    elif all(m[i][j] for i in range(n)):\n        good_cols.append(j)\n\nif len(good_rows) > 1 or len(good_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_rows) > 1 and len(bad_cols) > 1:\n    print(\"NO\")\nelif len(bad_rows) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelif len(bad_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\nelse:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * m)\n", "\n\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n\n    a = []\n    for i in range(n):\n        a.append([int(x) for x in sys.stdin.readline().split()])\n\n    r = [0]*n\n    c = [0]*m\n\n    for i in range(n):\n        zero = 0\n        one = 0\n        for j in range(m):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            r[i] = 1\n\n    for j in range(m):\n        zero = 0\n        one = 0\n        for i in range(n):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            c[j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if r[i] == 1:\n                a[i][j] = 1 - a[i][j]\n            if c[j] == 1:\n                a[i][j] = 1 - a[i][j]\n\n    sorted_ = True\n    for i in range(n):\n        for j in range(m-1):\n            if a[i][j] > a[i][j+1]:\n                sorted_ = False\n\n    if sorted_:\n        print(\"YES\")\n        print(\"\".join([str(x) for x in r]))\n        print(\"\".join([str(x) for x in c]))\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()\n", "\n\n#!/usr/bin/python3\n\nimport sys\nfrom math import *\nfrom string import *\nfrom datetime import *\nfrom time import *\nfrom random import *\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\n#print(n, m)\n#print(a)\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 1:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# a_sort = []\n# for i in range(n):\n#     for j in range(m):\n#         a_sort.append(a[i][j])\n# a_sort = sorted(a_sort)\n# #print(a_sort)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] != a_sort[i * m + j]:\n#             print(\"NO\")\n#             exit()\n\n# print(\"YES\")\n# print(\"\".join(map(str, r)))\n# print(\"\".join(map(str, c)))\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 1:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\na_sort = []\nfor i in range(n):\n    for j in range(m):\n        a_sort.append(a[i][j])\na_sort = sorted(a_sort)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != a_sort[i * m + j]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(\"\".join(map(str, r)))\nprint(\"\".join(map(str, c)))\n", "\nimport sys\n\ndef main():\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n\n    a = []\n    for i in range(n):\n        a.append([int(x) for x in sys.stdin.readline().split()])\n\n    r = [0]*n\n    c = [0]*m\n\n    for i in range(n):\n        zero = 0\n        one = 0\n        for j in range(m):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            r[i] = 1\n\n    for j in range(m):\n        zero = 0\n        one = 0\n        for i in range(n):\n            if a[i][j] == 0:\n                zero += 1\n            else:\n                one += 1\n        if zero > one:\n            c[j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if r[i] == 1:\n                a[i][j] = 1 - a[i][j]\n            if c[j] == 1:\n                a[i][j] = 1 - a[i][j]\n\n    sorted = True\n    for i in range(n):\n        for j in range(m-1):\n            if a[i][j] > a[i][j+1]:\n                sorted = False\n\n    if sorted:\n        print(\"YES\")\n        print(\"\".join([str(x) for x in r]))\n        print(\"\".join([str(x) for x in c]))\n    else:\n        print(\"NO\")\n\nif __name__ == '__main__':\n    main()\n", "\n\n#!/usr/bin/env python\n\nimport sys\nfrom math import *\nfrom string import *\nfrom datetime import *\nfrom time import *\nfrom random import *\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\n#print(n, m)\n#print(a)\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\n#print(r)\n#print(c)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 1:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\n#print(r)\n#print(c)\n\na_sort = []\nfor i in range(n):\n    for j in range(m):\n        a_sort.append(a[i][j])\na_sort = sorted(a_sort)\n#print(a_sort)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != a_sort[i * m + j]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(\"\".join(map(str, r)))\nprint(\"\".join(map(str, c)))\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 1:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\na_sort = []\nfor i in range(n):\n    for j in range(m):\n        a_sort.append(a[i][j])\na_sort = sorted(a_sort)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != a_sort[i * m + j]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(\"\".join(map(str, r)))\nprint(\"\".join(map(str, c)))\n", "\n\nfrom collections import *\n\nn, m = map(int, input().split())\nm = [[int(i) for i in input().split()] for _ in range(n)]\n\n# if a row is sorted, mark it as \"good\"\n# if a row is not sorted, mark it as \"bad\"\n# if a column has 0s, mark it as \"bad\"\n# if a column has 1s, mark it as \"good\"\n# if a column has both 0s and 1s, mark it as \"bad\"\n\n# after finding all the good and bad rows and columns,\n# we can do the following:\n# if there are more than 1 \"good\" row,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"good\" column,\n# we can invert any of them to make it \"bad\"\n# if there are more than 1 \"bad\" row and\n# more than 1 \"bad\" column, we cannot sort the matrix\n# if there are more than 1 \"bad\" row and 0 \"bad\" column,\n# we can invert any of the \"bad\" rows to make it \"good\"\n# if there are more than 1 \"bad\" column and 0 \"bad\" row,\n# we can invert any of the \"bad\" columns to make it \"good\"\n# if there is 1 \"bad\" row and 1 \"bad\" column,\n# we can invert any 1 of them to make it \"good\"\n\ngood_rows = []\ngood_cols = []\nbad_rows = []\nbad_cols = []\n\nfor i in range(n):\n    if all(m[i]):\n        good_rows.append(i)\n    elif not any(m[i]):\n        bad_rows.append(i)\n\nfor j in range(n):\n    if not any(m[i][j] for i in range(n)):\n        bad_cols.append(j)\n    elif all(m[i][j] for i in range(n)):\n        good_cols.append(j)\n\nif len(good_rows) > 1 or len(good_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * m)\n    print(\"0\" * n)\nelif len(bad_rows) > 1 and len(bad_cols) > 1:\n    print(\"NO\")\nelif len(bad_rows) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * n)\nelif len(bad_cols) > 1:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * n)\nelse:\n    print(\"YES\")\n    print(\"0\" * n)\n    print(\"0\" * n)\n", "\n\n#!/usr/bin/env python3\n\nimport sys\nfrom math import *\nfrom string import *\nfrom datetime import *\nfrom time import *\nfrom random import *\n\n# n, m = map(int, input().split())\n# a = []\n# for i in range(n):\n#     a.append(list(map(int, input().split())))\n\n# #print(n, m)\n# #print(a)\n\n# r = []\n# c = []\n# for i in range(n):\n#     r.append(0)\n# for j in range(m):\n#     c.append(0)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 0:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] == 1:\n#             r[i] = (r[i] + 1) % 2\n#             c[j] = (c[j] + 1) % 2\n\n# #print(r)\n# #print(c)\n\n# a_sort = []\n# for i in range(n):\n#     for j in range(m):\n#         a_sort.append(a[i][j])\n# a_sort = sorted(a_sort)\n# #print(a_sort)\n\n# for i in range(n):\n#     for j in range(m):\n#         if a[i][j] != a_sort[i * m + j]:\n#             print(\"NO\")\n#             exit()\n\n# print(\"YES\")\n# print(\"\".join(map(str, r)))\n# print(\"\".join(map(str, c)))\n\nn, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nr = []\nc = []\nfor i in range(n):\n    r.append(0)\nfor j in range(m):\n    c.append(0)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 0:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == 1:\n            r[i] = (r[i] + 1) % 2\n            c[j] = (c[j] + 1) % 2\n\na_sort = []\nfor i in range(n):\n    for j in range(m):\n        a_sort.append(a[i][j])\na_sort = sorted(a_sort)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != a_sort[i * m + j]:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")\nprint(\"\".join(map(str, r)))\nprint(\"\".join(map(str, c)))\n"]