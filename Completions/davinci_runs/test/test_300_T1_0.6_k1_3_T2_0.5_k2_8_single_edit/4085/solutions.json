["for q in range(int(input())):\n    n = int(input())\n    D = list(map(int, input().split()))\n    D.sort()\n    z = D[0] * D[-1]\n    if z == -1:\n        print(-1)\n    else:\n        Dz = set()\n        for i in range(2, int(z ** 0.5) + 1):\n            if z % i == 0:\n                Dz.add(i)\n                Dz.add(z // i)\n        if Dz == set(D):\n            print(z)\n        else:\n            print(-1)", "from functools import reduce\nimport operator\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ds = sorted(map(int, input().split()))\n    suspect = ds[0] * ds[-1]\n    pfs = []\n    g = suspect\n    for i in range(2, int(g**0.5) + 1):\n        if g % i == 0:\n            pfs.append([0, i])\n            while g % i == 0:\n                pfs[-1][0] += 1\n                g //= i\n    if 1 < g: pfs.append([1, g])\n    nf = reduce(operator.mul, [u[0] + 1 for u in pfs])\n    ok = nf == len(ds) + 2\n    for d in ds:\n        if suspect % d != 0:\n            ok = False\n    if ok: print(suspect)\n    else: print(-1)\n", "for _ in range(int(input())):\n    n=int(input())\n    a=sorted(list(map(int,input().split())))\n    ans=a[0]*a[-1]\n    b=set(a)\n    r=[]\n    for i in range(2,int(ans**.5+1)):\n        if ans%i==0:\n            r.append(i)\n            r.append(ans//i)\n    if set(r)!=b:\n        print(-1)\n    else:\n        print(ans)\n", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    d = list(map(int, input().split()))\n    d.sort()\n    ans = d[0]*d[-1]\n    flag = 1\n    for i in range((n+1)//2):\n        if d[i]*d[-1-i] != ans:\n            flag = 0\n            break\n    if flag == 1:\n        count = 0\n        for i in range(1, int(ans**(1/2))+1):\n            if ans % i == 0:\n                if i**2 == ans:\n                    count += 1\n                else:\n                    count += 2\n        if count-2 == n:\n            print(ans)\n        else:\n            print(-1)\n    else:\n        print(-1)\n", "import math\nfor test in range(int(input())):\n    n = int(input())\n    a = sorted(list(map(int, input().split())))\n    x, flag = a[0] * a[-1], 0\n    for i in range(len(a)):\n        if a[i] * a[-1 - i] != x:\n            flag = 1\n            break\n    if flag == 1:\n        print(-1)\n        continue\n    b = []\n    for i in range(2, int(math.sqrt(x)) + 1):\n        if x % i == 0:\n            b.append(i)\n            if i != x // i:\n                b.append(x // i)\n    b = sorted(b)\n    if len(a) != len(b):\n        print(-1)\n        continue\n    flag = 0\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            flag = 1\n            break\n    if flag:\n        print(-1)\n    else:\n        print(x)", "def divisors(n):\n    res = set()\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            res.add(i)\n            res.add(n//i)\n    \n    return res\n\ndef solve():\n    for _ in range(int(input())):\n        N = int(input())\n        D = set([int(k) for k in input().split()])\n        \n        ans = max(D) * min(D)\n        \n        if divisors(ans) != D:\n            print(-1)\n            continue\n            \n        print (ans)\n    \ndef __starting_point():  \n    solve() \n\n__starting_point()", "def main():\n    from sys import stdin, stdout\n\n    def read():\n        return stdin.readline().rstrip('\\n')\n\n    def read_array(sep=None, maxsplit=-1):\n        return read().split(sep, maxsplit)\n\n    def read_int():\n        return int(read())\n\n    def read_int_array(sep=None, maxsplit=-1):\n        return [int(a) for a in read_array(sep, maxsplit)]\n\n    def write(*args, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in args) + end)\n\n    def write_array(array, **kwargs):\n        sep = kwargs.get('sep', ' ')\n        end = kwargs.get('end', '\\n')\n        stdout.write(sep.join(str(a) for a in array) + end)\n\n    def prime_sieve(n):\n        \"\"\"returns a sieve of primes >= 5 and < n\"\"\"\n        flag = n % 6 == 2\n        sieve = bytearray((n // 3 + flag >> 3) + 1)\n        for i in range(1, int(n ** 0.5) // 3 + 1):\n            if not (sieve[i >> 3] >> (i & 7)) & 1:\n                k = (3 * i + 1) | 1\n                for j in range(k * k // 3, n // 3 + flag, 2 * k):\n                    sieve[j >> 3] |= 1 << (j & 7)\n                for j in range(k * (k - 2 * (i & 1) + 4) // 3, n // 3 + flag, 2 * k):\n                    sieve[j >> 3] |= 1 << (j & 7)\n        return sieve\n\n    def prime_list(n):\n        \"\"\"returns a list of primes <= n\"\"\"\n        res = []\n        if n > 1:\n            res.append(2)\n        if n > 2:\n            res.append(3)\n        if n > 4:\n            sieve = prime_sieve(n + 1)\n            res.extend(\n                3 * i + 1 | 1 for i in range(1, (n + 1) // 3 + (n % 6 == 1)) if not (sieve[i >> 3] >> (i & 7)) & 1)\n        return res\n\n    primes = prime_list(10**6)\n\n    t = read_int()\n    for _ in range(t):\n        n = read_int()\n        divisors = sorted(read_int_array())\n        x = divisors[0] * divisors[-1]\n        should_have = 1\n        x2 = x\n        for p in primes:\n            if p > x2:\n                break\n            if x2 % p == 0:\n                options = 1\n                while x2 % p == 0:\n                    options += 1\n                    x2 //= p\n                should_have *= options\n\n        if should_have != n + 2:\n            write(-1)\n            continue\n\n        l, r = 0, len(divisors) - 1\n        while l <= r:\n            if divisors[l] * divisors[r] != x:\n                write(-1)\n                break\n            l += 1\n            r -= 1\n        else:\n            write(x)\n\nmain()\n", "from functools import reduce\ndef factors(n):\n\tfrom functools import reduce\n\treturn set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\nfor _ in range(int(input().strip())):\n\tn = int(input().strip())\n\tarr = list(map(int, input().strip().split()))\n\tnum = max(arr)*min(arr)\n\ts1 = set(arr)\n\ts1.add(1)\n\ts1.add(num)\n\ts2 = factors(num)\n\tif s1 == s2:\n\t\tprint(num)\n\telse:\n\t\tprint(-1)\n", "t = int(input())\nfor q in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = min(a)*max(a)\n    deliver = [q for q in range(2, round(ans**(1/2))+1) if ans % q == 0]\n    if deliver+[ans//deliver[q] for q in range(len(deliver)-1-(deliver[-1]**2 == ans), -1, -1)] == sorted(a):\n        print(ans)\n    else:\n        print(-1)\n", "for Valerchiclox in range(int(input())):\n    n = int(input())\n    c = list(map(int,input().split()))\n    c.sort()\n    const = c[0]*c[-1]\n    k = -1\n    for i in c:\n        if i*c[k]!= const:\n            const = -1\n            break\n        k-=1\n    if const == -1:\n        print(const)\n    else:\n        s = 0\n        for i in range(2,int(const**0.5)+1):\n            if const%i==0:\n                s+=1\n        if s*2-n%2==n:\n            print(const)\n        else:\n            print(-1)", "isPrime=[1 for i in range(1000005)]\nprimes=[]\nfor i in range(2,1000005):\n    if(isPrime[i]==1):\n        primes.append(i)\n        j=2*i\n        while(j<1000005):\n            isPrime[j]=0\n            j+=i\n\ndef gcd(a,b):\n    if(b==0):\n        return a\n    else:\n        return gcd(b,a%b)\n\ndef lcm(a,b):\n    return a*b/gcd(a,b)\n\nt=int(input())\nwhile(t>0):\n    n=int(input())\n    d=list(map(int,input().split()))\n    d.sort()\n    ans=1\n    flag=1\n    for i in range(len(d)-1):\n        if(d[i]*d[n-i-1]!=d[i+1]*d[n-i-2]):\n            flag=0\n            break\n    if(flag==0):\n        print(-1)\n    else:\n        ans=d[0]*d[-1]\n        amt=1\n        x=ans\n        for i in primes:\n            if(ans%i==0):\n                cnt=1\n                while(x%i==0):\n                    cnt+=1\n                    x/=i\n                amt*=cnt\n        if(x>1):\n            amt*=2\n        if(amt-2==len(d)):\n            print(int(ans))\n        else:\n            print(-1)\n    \"\"\"    \n    for i in d:\n        ans=lcm(ans,i)\n        if(ans>10**30):\n            print(-1)\n            break\n    if(ans>10**30):\n        t-=1\n        continue \n    if(ans==d[-1]):\n        po=1\n        flag=1\n        for i in d:\n            po*=d[0]\n            if(po!=i):\n                flag=0\n        if(flag==1):\n            print(int(ans*d[0]))\n        else:\n            print(-1)\n    else:\n        amt=1\n        x=ans\n        for i in primes:\n            if(ans%i==0):\n                cnt=1\n                while(x%i==0):\n                    cnt+=1\n                    x/=i\n                amt*=cnt\n        if(x>1):\n            amt*=2\n        if(amt-2==len(d)):\n            print(int(ans))\n        else:\n            print(-1)\n    \"\"\"\n    t-=1\n", "t=int(input())\n\ndef prov1(a):\n    pp=a[0]*a[-1]\n    for i in range(len(a)):\n        if a[i]*a[-1-i]!=pp: return -1\n    return pp\n\ndef kkk(a):\n    i=2\n    d=0\n    while i*i<a:\n       if a%i==0:\n           d+=2\n       i+=1\n    if i*i==a: d+=1\n    return d\n\ndef koka(a,b):\n    ans=0\n    while a%b==0:\n        a=a//b\n        ans+=1\n    return ans\n\n\n\nfor i in range(t):\n    n=int(input())\n    a=sorted(list(map(int,input().split())))\n    y=prov1(a)\n    if y==-1:\n        print(-1)\n    else:\n        yy=kkk(a[0])\n        if yy>0: print(-1)\n        else:\n            u=kkk(a[-1])+2\n            z=koka(a[-1],a[0])\n            if z==0: d=u*2-2\n            else:\n                d=(u//(z+1))*(z+2)-2\n            if d==n:\n                print(y)\n            else:\n                print(-1)\n            \n\n", "t = int(input())\nprime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009]\nfor i in range(t):\n\tn = int(input())\n\tl = list(map(int,input().split()))\n\tmini = min(l)\n\tmaksi = max(l)\n\ta = mini * maksi\n\tc = 0\n\tfor d in l:\n\t\tif a % d != 0:\n\t\t\tc = 1\n\t\t\tbreak\n\t\n\tif c == 1:\n\t\tprint(-1)\n\t\tcontinue\n\t# ile divisors\n\tfac = []\n\ti = 2\n\tfor p in prime:\n\t\tif p > max(maksi, mini):\n\t\t\tbreak\n\t\tif maksi % p != 0 and mini % p != 0:\n\t\t\tcontinue\n\t\tchuj = 0\n\t\twhile True:\n\t\t\tif maksi % p == 0:\n\t\t\t\tmaksi = maksi // p\n\t\t\t\tchuj += 1\n\t\t\telse:\n\t\t\t\tbreak\n\t\twhile True:\n\t\t\tif mini % p == 0:\n\t\t\t\tmini = mini // p\n\t\t\t\tchuj += 1\n\t\t\telse:\n\t\t\t\tbreak\t\n\t\tif chuj > 0:\n\t\t\tfac.append([p, chuj])\n\tczek = 1\n\tdiwi = 1\n\tfor f in fac:\n\t\tdiwi = diwi * (f[1] + 1)\n\tif mini == maksi:\n\t\tif mini > 1:\n\t\t\tdiwi *= 3\n\telse:\n\t\tif mini >1:\n\t\t\tdiwi *= 2\n\t\tif maksi > 1:\n\t\t\tdiwi *= 2\n\tif diwi - 2 == n:\n\t\tprint(a)\n\telse:\n\t\tprint(-1)\n", "from collections import Counter\nR = lambda: map(int, input().split())\n\ndef primefactors(n):\n    f = 2\n    while f * f <= n:\n        while not n % f:\n            yield f\n            n //= f\n        f += 1\n    if n > 1:\n        yield n\n\nfor _ in range(int(input())):\n    n = int(input())\n    dd = list(R())\n    c = Counter()\n    for d in dd:\n        ct = Counter(primefactors(d))\n        for k in ct: c[k] = max(c[k], ct[k])\n    x = 1\n    for k, v in c.items():\n        x *= k**v\n    if x==max(dd):\n        t = min(dd)\n        x *= t\n        c[t] += 1\n    m = 1\n    for v in c.values(): m *= v+1\n    print(x if m==len(dd)+2 else -1)", "Q = int(input())\n\ndef decompose(x):\n  ans = {}\n  cx = x\n  d = 2\n  while d * d <= cx:\n    t = 0\n    while x % d == 0:\n      t += 1\n      x = x // d\n    if t > 0:\n      ans[d] = t\n    d += 1\n  if x > 1:\n    ans[x] = 1\n  return ans\n\ndef fastpow(x, p):\n  if p == 0:\n    return 1\n  ans = fastpow(x, p // 2)\n  ans *= ans\n  if p % 2 == 1:\n    ans *= x\n  return ans\n\ndef makePrimePower(divs):\n  primePowers = {}\n  for d in divs:\n    ppows = decompose(d)\n    for key in ppows:\n      if key not in primePowers:\n        primePowers[key] = ppows[key]\n      else:\n        primePowers[key] = max(primePowers[key], ppows[key])\n  return primePowers\n\ndef solve(divs):\n  primePowers = makePrimePower(divs)\n  x = 1\n  for key in primePowers:\n    x *= fastpow(key, primePowers[key])\n  if x in divs:\n    prim = list(primePowers.keys())[0]\n    x *= prim\n    primePowers[prim] += 1\n  nrdivs = 1\n  for key in primePowers:\n    nrdivs *= primePowers[key] + 1\n  if len(divs) + 2 != nrdivs:\n    return -1\n  return x\n\nfor x in range(Q):\n  N = int(input())\n  divs = list(map(int, input().split()))\n  print(solve(divs))\n", "import math\nn=int(input())\nresult=[]\ndef divisors(n):\n    count=0\n    for i in range(2,int(math.sqrt(n))+1):\n        if n%i==0:\n            if n//i==i:\n                count+=1\n            else:\n                count+=2\n    return count\n\n\nfor i in range(n):\n    n1=int(input())\n    n2=list((list(map(int,input().split()))))\n    n2.sort()\n    a1=n2[0]*n2[-1]\n    final=True\n    for i in range(len(n2)):\n        if n2[i]*n2[len(n2)-1-i]!=a1:\n            final=False\n            break\n    if n1==1 and n2[0]==1:\n        result.append(1)\n    elif final and n1==divisors(a1):\n        result.append(a1)\n    else:\n        result.append(-1)\nfor i in result:\n    print(i)\n\n", "q = int(input())\n\ndef eratosthene(n):\n    if n<2:\n        return []\n    n += 1\n    tableau = [False,False] + [True]*(n-2)\n    tableau[2::2] = [False]*((n-2)//2 + n%2) # sup. des nb pairs\n    premiers = [2] # initialisation de la tableau des nb 1ers (2 est 1er)\n    racine = int(n**0.5)\n    racine = racine + [1,0][racine%2] # pour que racine soit impair\n    for i in range(3, racine+1, 2):\n        if tableau[i]:\n            premiers.append(i)\n            tableau[i::i] = [False]*((n-i)//i + int((n-i)%i>0)) \n    for i in range(racine, n, 2):\n        if tableau[i]:\n            premiers.append(i)\n    return premiers\n\nprimes = eratosthene(10**6+2)\n\ndef divisors(n):\n\n\tans = 1\n\tfor p in primes:\n\t\ttmp = 0\n\t\tif n%p == 0:\n\t\t\twhile True:\n\t\t\t\ttmp +=1\n\t\t\t\tn//=p\n\t\t\t\tif n%p != 0:\n\t\t\t\t\tbreak\n\t\tif tmp > 0:\n\t\t\tans*=(tmp+1)\n\t\t\ttmp = 0\n\t\tif p > n:\n\t\t\tbreak\n\treturn ans - 2\n\nfor _ in range(q):\n\n\tn = int(input())\n\tl = sorted(list(map(int, input().split())))\n\n\tif n == 1:\n\t\tif l[0] in primes:\n\t\t\tprint(l[0]**2)\n\t\telse:\n\t\t\tprint(-1)\n\n\telif n > 1:\n\t\tcandidate = l[0] * l[-1]\n\t\tfor i in range(1, n // 2):\n\t\t\tif l[i]*l[n-1-i] != candidate:\n\t\t\t\tprint(-1)\n\t\t\t\tbreak\n\t\telse:\n\t\t\tif divisors(candidate) == n:\n\t\t\t\tif n%2:\n\t\t\t\t\tif l[n//2]**2 == candidate:\n\t\t\t\t\t\tprint(candidate)\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint(-1)\n\t\t\t\telse:\n\t\t\t\t\tprint(candidate)\n\t\t\telse:\n\t\t\t\tprint(-1)\n"]