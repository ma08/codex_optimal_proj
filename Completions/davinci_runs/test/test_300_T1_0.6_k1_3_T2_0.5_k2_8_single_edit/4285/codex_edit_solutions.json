["\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    s = sys.stdin.readline().strip()\n    a = 0\n    b = 0\n    c = 0\n    count = 1\n    for i in range(n):\n        if s[i] == \"a\":\n            a += 1\n        elif s[i] == \"b\":\n            b += 1\n        elif s[i] == \"c\":\n            c += 1\n        else:\n            count = (count * 3) % 1000000007\n    print((a * b * c * count) % 1000000007)\n\nif __name__ == '__main__':\n    main()\n", "var fs = require('fs');\nvar readline = require('readline');\nvar google = require('googleapis');\nvar googleAuth = require('google-auth-library');\n\n// If modifying these scopes, delete your previously saved credentials\n// at ~/.credentials/drive-nodejs-quickstart.json\nvar SCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly'];\nvar TOKEN_DIR = (process.env.HOME || process.env.HOMEPATH ||\n    process.env.USERPROFILE) + '/.credentials/';\nvar TOKEN_PATH = TOKEN_DIR + 'drive-nodejs-quickstart.json';\n\n// Load client secrets from a local file.\nfs.readFile('client_secret.json', function processClientSecrets(err, content) {\n  if (err) {\n    console.log('Error loading client secret file: ' + err);\n    return;\n  }\n  // Authorize a client with the loaded credentials, then call the\n  // Drive API.\n  authorize(JSON.parse(content), listFiles);\n});\n\n/**\n * Create an OAuth2 client with the given credentials, and then execute the\n * given callback function.\n *\n * @param {Object} credentials The authorization client credentials.\n * @param {function} callback The callback to call with the authorized client.\n */\nfunction authorize(credentials, callback) {\n  var clientSecret = credentials.installed.client_secret;\n  var clientId = credentials.installed.client_id;\n  var redirectUrl = credentials.installed.redirect_uris[0];\n  var auth = new googleAuth();\n  var oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl);\n\n  // Check if we have previously stored a token.\n  fs.readFile(TOKEN_PATH, function(err, token) {\n    if (err) {\n      getNewToken(oauth2Client, callback);\n    } else {\n      oauth2Client.credentials = JSON.parse(token);\n      callback(oauth2Client);\n    }\n  });\n}\n\n/**\n * Get and store new token after prompting for user authorization, and then\n * execute the given callback with the authorized OAuth2 client.\n *\n * @param {google.auth.OAuth2} oauth2Client The OAuth2 client to get token for.\n * @param {getEventsCallback} callback The callback to call with the authorized\n *     client.\n */\nfunction getNewToken(oauth2Client, callback) {\n  var authUrl = oauth2Client.generateAuthUrl({\n    access_type: 'offline',\n    scope: SCOPES\n  });\n  console.log('Authorize this app by visiting this url: ', authUrl);\n  var rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n  });\n  rl.question('Enter the code from that page here: ', function(code) {\n    rl.close();\n    oauth2Client.getToken(code, function(err, token) {\n      if (err) {\n        console.log('Error while trying to retrieve access token', err);\n        return;\n      }\n      oauth2Client.credentials = token;\n      storeToken(token);\n      callback(oauth2Client);\n    });\n  });\n}\n\n/**\n * Store token to disk be used in later program executions.\n *\n * @param {Object} token The token to store to disk.\n */\nfunction storeToken(token) {\n  try {\n    fs.mkdirSync(TOKEN_DIR);\n  } catch (err) {\n    if (err.code != 'EEXIST') {\n      throw err;\n    }\n  }\n  fs.writeFile(TOKEN_PATH, JSON.stringify(token));\n  console.log('Token stored to ' + TOKEN_PATH);\n}\n\n/**\n * Lists the names and IDs of up to 10 files.\n *\n * @param {google.auth.OAuth2} auth An authorized OAuth2 client.\n */\nfunction listFiles(auth) {\n  var service = google.drive('v3');\n  service.files.list({\n    auth: auth,\n    pageSize: 10,\n    fields: \"nextPageToken, files(id, name)\"\n  }, function(err, response) {\n    if (err) {\n      console.log('The API returned an error: ' + err);\n      return;\n    }\n    var files = response.files;\n    if (files.length == 0) {\n      console.log('No files found.');\n    } else {\n      console.log('Files:');\n      for (var i = 0; i < files.length; i++) {\n        var file = files[i];\n        console.log('%s (%s)', file.name, file.id);\n      }\n    }\n  });\n}\n", "\n\nimport sys\n\ndef main():\n    pass\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    s = sys.stdin.readline().strip()\n    a = 0\n    b = 0\n    c = 0\n    count = 1\n    for i in range(n):\n        if s[i] == \"a\":\n            a += 1\n        elif s[i] == \"b\":\n            b += 1\n        elif s[i] == \"c\":\n            c += 1\n        else:\n            count = (count * 3) % 1000000007\n    print ((a * b * c * count) % 1000000007)\n\nif __name__ == '__main__':\n    main()\n", "import os\nprint(os.path.basename(__file__))\n\nprint(os.path.dirname(__file__))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "var fs = require('fs');\n\nvar data = fs.readFileSync('file.txt', 'utf8');\nconsole.log(data);\n\nfs.writeFileSync('file2.txt', 'Hello World');\n", "var fs = require('fs');\n\nvar file = fs.readFileSync(process.argv[2]);\n\nvar str = file.toString();\n\nvar lines = str.split('\\n');\n\nconsole.log(lines.length - 1);\n", "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// WriteFile writes data to a file named by filename.\n// If the file does not exist, WriteFile creates it with permissions perm;\n// otherwise WriteFile truncates it before writing.\nfunc WriteFile(filename string, data []byte, perm os.FileMode) error {\n\tf, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\tn, err := f.Write(data)\n\tif err == nil && n < len(data) {\n\t\terr = io.ErrShortWrite\n\t}\n\tif err1 := f.Close(); err == nil {\n\t\terr = err1\n\t}\n\treturn err\n}\n\n// ReadFile reads the file named by filename and returns the contents.\n// A successful call returns err == nil, not err == EOF. Because ReadFile\n// reads the whole file, it does not treat an EOF from Read as an error\n// to be reported.\nfunc ReadFile(filename string) ([]byte, error) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\t// It's a good but not certain bet that FileInfo will tell us exactly how much to\n\t// read, so let's try it but be prepared for the answer to be wrong.\n\tvar n int64 = bytes.MinRead\n\n\tif fi, err := f.Stat(); err == nil {\n\t\t// As initial capacity for readAll, use Size + a little extra in case Size\n\t\t// is zero, and to avoid another allocation after Read has filled the\n\t\t// buffer. The readAll call will read into its allocated internal buffer\n\t\t// cheaply. If the size was wrong, we'll either waste some space off the end\n\t\t// or reallocate as needed, but in the overwhelmingly common case we'll get\n\t\t// it just right.\n\t\tif size := fi.Size() + bytes.MinRead; size > n {\n\t\t\tn = size\n\t\t}\n\t}\n\treturn readAll(f, n)\n}\n\n// ReadAll reads from r until an error or EOF and returns the data it read\n// from the internal buffer allocated with a specified capacity.\nfunc readAll(r io.Reader, capacity int64) (b []byte, err error) {\n\tvar buf bytes.Buffer\n\t// If the buffer overflows, we will get bytes.ErrTooLarge.\n\t// Return that as an error. Any other panic remains.\n\tdefer func() {\n\t\te := recover()\n\t\tif e == nil {\n\t\t\treturn\n\t\t}\n\t\tif panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {\n\t\t\terr = panicErr\n\t\t} else {\n\t\t\tpanic(e)\n\t\t}\n\t}()\n\tif int64(int(capacity)) == capacity {\n\t\tbuf.Grow(int(capacity))\n\t}\n\t_, err = buf.ReadFrom(r)\n\treturn buf.Bytes(), err\n}\n\n// ReadDir reads the directory named by dirname and returns\n// a list of directory entries sorted by filename.\nfunc ReadDir(dirname string) ([]os.FileInfo, error) {\n\tf, err := os.Open(dirname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlist, err := f.Readdir(-1)\n\tf.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsort.Slice(list, func(i, j int) bool { return list[i].Name() < list[j].Name() })\n\treturn list, nil\n}\n\n// TempDir creates a new temporary directory in the directory dir\n// with a name beginning with prefix and returns the path of the\n// new directory. If dir is the empty string, TempDir uses the\n// default directory for temporary files (see os.TempDir).\n// Multiple programs calling TempDir simultaneously\n// will not choose the same directory. It is the caller's responsibility\n// to remove the directory when no longer needed.\nfunc TempDir(dir, prefix string) (name string, err error) {\n\tif dir == \"\" {\n\t\tdir = os.TempDir()\n\t}\n\n\tnconflict := 0\n\tfor i := 0; i < 10000; i++ {\n\t\ttry := filepath.Join(dir, prefix+nextRandom())\n\t\terr = os.Mkdir(try, 0700)\n\t\tif os.IsExist(err) {\n\t\t\tif nconflict++; nconflict > 10 {\n\t\t\t\trandmu.Lock()\n\t\t\t\trand = reseed()\n\t\t\t\trandmu.Unlock()\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif os.IsNotExist(err) {\n\t\t\tif _, err := os.Stat(dir); os.IsNotExist(err) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t\tif err == nil {\n\t\t\tname = try\n\t\t}\n\t\tbreak\n\t}\n\treturn\n}\n\n// ReadFile reads the file named by filename and returns the contents.\n// A successful call returns err == nil, not err == EOF. Because ReadFile\n// reads the whole file, it does not treat an EOF from Read as an error\n// to be reported.\nfunc ReadFile(filename string) ([]byte, error) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\t// It's a good but not certain bet that FileInfo will tell us exactly how much to\n\t// read, so let's try it but be prepared for the answer to be wrong.\n\tvar n int64 = bytes.MinRead\n\n\tif fi, err := f.Stat(); err == nil {\n\t\t// As initial capacity for readAll, use Size + a little extra in case Size\n\t\t// is zero, and to avoid another allocation after Read has filled the\n\t\t// buffer. The readAll call will read into its allocated internal buffer\n\t\t// cheaply. If the size was wrong, we'll either waste some space off the end\n\t\t// or reallocate as needed, but in the overwhelmingly common case we'll get\n\t\t// it just right.\n\t\tif size := fi.Size() + bytes.MinRead; size > n {\n\t\t\tn = size\n\t\t}\n\t}\n\treturn readAll(f, n)\n}\n\n// ReadAll reads from r until an error or EOF and returns the data it read\n// from the internal buffer allocated with a specified capacity.\nfunc readAll(r io.Reader, capacity int64) (b []byte, err error) {\n\tvar buf bytes.Buffer\n\t// If the buffer overflows, we will get bytes.ErrTooLarge.\n\t// Return that as an error. Any other panic remains.\n\tdefer func() {\n\t\te := recover()\n\t\tif e == nil {\n\t\t\treturn\n\t\t}\n\t\tif panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {\n\t\t\terr = panicErr\n\t\t} else {\n\t\t\tpanic(e)\n\t\t}\n\t}()\n\tif int64(int(capacity)) == capacity {\n\t\tbuf.Grow(int(capacity))\n\t}\n\t_, err = buf.ReadFrom(r)\n\treturn buf.Bytes(), err\n}\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n\tFILE *fp;\n\tint i, j;\n\tchar ch;\n\tchar str[100];\n\tchar *p;\n\tchar *q;\n\tchar *r;\n\tfp = fopen(\"file.c\", \"r\");\n\tif (fp == NULL) {\n\t\tprintf(\"Open file failed\\n\");\n\t\texit(0);\n\t}\n\twhile (fgets(str, 100, fp) != NULL) {\n\t\tp = str;\n\t\twhile (*p != '\\0') {\n\t\t\tif (*p == '\\t') {\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tprintf(\" \");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintf(\"%c\", *p);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t}\n\tfclose(fp);\n\treturn 0;\n}\n", "\n\ndef main():\n    n = int(input())\n    s = input()\n    a = 0\n    b = 0\n    c = 0\n    count = 1\n    for i in range(n):\n        if s[i] == \"a\":\n            a += 1\n        elif s[i] == \"b\":\n            b += 1\n        elif s[i] == \"c\":\n            c += 1\n        else:\n            count = (count * 3) % 1000000007\n    print (a * b * c * count) % 1000000007\n\nmain()\n", "import os\n\ndef read_file(filename):\n\tproducts = []\n\twith open(filename, 'r', encoding='utf-8') as f:\n\t\tfor line in f:\n\t\t\tif '\u5546\u54c1,\u50f9\u683c' in line:\n\t\t\t\tcontinue\n\t\t\tname, price = line.strip().split(',')\n\t\t\tproducts.append([name, price])\n\treturn products\n\n# \u8b93\u4f7f\u7528\u8005\u8f38\u5165\ndef user_input(products):\n\twhile True:\n\t\tname = input('\u8acb\u8f38\u5165\u5546\u54c1\u540d\u7a31: ')\n\t\tif name == 'q':\n\t\t\tbreak\n\t\tprice = input('\u8acb\u8f38\u5165\u5546\u54c1\u50f9\u683c: ')\n\t\tproducts.append([name, price])\n\tprint(products)\n\treturn products\n\n# \u5370\u51fa\u6240\u6709\u8cfc\u8cb7\u7d00\u9304\ndef print_products(products):\n\tfor p in products:\n\t\tprint(p[0], '\u7684\u50f9\u683c\u662f', p[1])\n\n# \u5beb\u5165\u6a94\u6848\ndef write_file(filename, products):\n\twith open(filename, 'w', encoding='utf-8') as f:\n\t\tf.write('\u5546\u54c1,\u50f9\u683c\\n')\n\t\tfor p in products:\n\t\t\tf.write(p[0] + ',' + p[1] + '\\n')\n\ndef main():\n\tfilename = 'products.csv'\n\tif os.path.isfile(filename): # \u6aa2\u67e5\u6a94\u6848\u5728\u4e0d\u5728\n\t\tprint('yeah! \u627e\u5230\u6a94\u6848\u4e86!')\n\t\tproducts = read_file(filename)\n\telse:\n\t\tprint('\u627e\u4e0d\u5230\u6a94\u6848...')\n\n\tproducts = user_input(products)\n\tprint_products(products)\n\twrite_file('products.csv', products)\n\nmain()\n", "import sys\n\ndef main():\n    n = int(sys.stdin.readline().strip())\n    s = sys.stdin.readline().strip()\n    a = 0\n    b = 0\n    c = 0\n    count = 1\n    for i in range(n):\n        if s[i] == \"a\":\n            a += 1\n        elif s[i] == \"b\":\n            b += 1\n        elif s[i] == \"c\":\n            c += 1\n        else:\n            count = (count * 3) % 1000000007\n    print((a * b * c * count) % 1000000007)\n\nif __name__ == '__main__':\n    main()\n", "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n    string line;\n    string word;\n    stringstream ss;\n    ifstream inFile;\n    inFile.open(\"test.txt\");\n    vector<string> vec;\n    \n    if (inFile.is_open()) {\n        while (getline(inFile, line)) {\n            ss << line;\n            while (ss >> word) {\n                vec.push_back(word);\n            }\n            ss.clear();\n        }\n    } else {\n        cout << \"Error opening file.\" << endl;\n    }\n\n    for (auto i : vec) {\n        cout << i << endl;\n    }\n\n    return 0;\n}\n"]