2022-04-23 22:54:24.932134 num operations 1
2022-04-23 22:54:24.932153 size on input set 1
2022-04-23 22:54:24.932299 using api key jaanu
2022-04-23 22:54:45.150715 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone to 0\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - \\\n            len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n - 1)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]) - set(allowed_gates[5]) - set(allowed_gates[6]) - set(allowed_gates[7]) - set(allowed_gates[8]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]): # convert the input to a list of lists that contains the gates allowed by each ID card\n            allowed_gates[j].append(i)\n\n    num_cards = 0\n\n    for allowed in allowed_gates: # iterate through the list of lists of allowed gates for each ID card\n        # find the number of gates which are allowed by only this ID card by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone, so we increment the number of ID cards by 1\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650754465,
  "object": "edit"
}
2022-04-23 22:54:45.151161 fix syntax errors 8 ["\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone to 0\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - \\\n            len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n - 1)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]) - set(allowed_gates[5]) - set(allowed_gates[6]) - set(allowed_gates[7]) - set(allowed_gates[8]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]): # convert the input to a list of lists that contains the gates allowed by each ID card\n            allowed_gates[j].append(i)\n\n    num_cards = 0\n\n    for allowed in allowed_gates: # iterate through the list of lists of allowed gates for each ID card\n        # find the number of gates which are allowed by only this ID card by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone, so we increment the number of ID cards by 1\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\n\n\ndef main():\n    n, m = map(int, input().split())\n    gates = [list(map(int, input().split())) for _ in range(m)]\n\n    # convert the input to a list of lists that contains the gates allowed by each ID card\n    allowed_gates = [[] for _ in range(n)]\n    for i in range(m):\n        for j in range(gates[i][0] - 1, gates[i][1]):\n            allowed_gates[j].append(i)\n\n    # initialize the number of ID cards which allow to pass all the gates alone\n    num_cards = 0\n\n    # iterate through the list of lists of allowed gates for each ID card\n    for allowed in allowed_gates:\n        # find the number of gates which are allowed by only this ID card\n        # by finding the difference between the number of allowed gates and the number of gates allowed by all the other ID cards\n        num_alone = len(allowed) - len(set(allowed) - set(allowed_gates[0]) - set(allowed_gates[1]) - set(allowed_gates[2]) - set(allowed_gates[3]) - set(allowed_gates[4]))\n        # if the number of gates alone is equal to the total number of gates, then this ID card allows to pass all the gates alone\n        if num_alone == m:\n            num_cards += 1\n\n    print(num_cards)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-23 22:54:45.151270 size on output set 6
2022-04-23 22:54:45.151284 num operations 1
2022-04-23 22:54:45.151290 size on input set 1
2022-04-23 22:54:45.151454 using api key soukgp
2022-04-23 22:55:20.242051 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] \u306fi\u756a\u76ee\u306e\u30ab\u30fc\u30c9\u304c\u901a\u308c\u308b\u9580\u306e\u6700\u5927\u5024\ntrange = [0] * n\n\n# \u9580\u304c\u901a\u308c\u308b\u30ab\u30fc\u30c9\u756a\u53f7\u3092\u6c42\u3081\u308b\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l - 1, r):\n        trange[j] = r\n\n# \u901a\u308c\u308b\u9580\u304cm\u4ee5\u4e0a\u3042\u308b\u30ab\u30fc\u30c9\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u6c42\u3081\u308b\nprint(len([i for i in trange if i >= m]))\n"
    },
    {
      "index": 1,
      "text": "\n\nn, m = map(int, input().split())\n\n# trange[i] \u306fi\u756a\u76ee\u306e\u30ab\u30fc\u30c9\u304c\u901a\u308c\u308b\u9580\u306e\u6700\u5927\u5024\ntrange = [0] * n\n\n# \u9580\u304c\u901a\u308c\u308b\u30ab\u30fc\u30c9\u756a\u53f7\u3092\u6c42\u3081\u308b\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# \u901a\u308c\u308b\u9580\u304cm\u4ee5\u4e0a\u3042\u308b\u30ab\u30fc\u30c9\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u6c42\u3081\u308b\nprint(len([i for i in trange if i >= m]))\n"
    },
    {
      "index": 2,
      "text": "\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] \u306fi\u756a\u76ee\u306e\u30ab\u30fc\u30c9\u304c\u901a\u308c\u308b\u9580\u306e\u6700\u5927\u5024\ntrange = [0] * n\n\n# \u9580\u304c\u901a\u308c\u308b\u30ab\u30fc\u30c9\u756a\u53f7\u3092\u6c42\u3081\u308b\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):  # \u9580\u306e\u756a\u53f7\u306f1\u304b\u3089\u59cb\u307e\u308b\u305f\u3081-1\n        trange[j] = r\n\n# \u901a\u308c\u308b\u9580\u304cm\u4ee5\u4e0a\u3042\u308b\u30ab\u30fc\u30c9\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u6c42\u3081\u308b\nprint(sum([1 for i in trange if i >= m]))\n"
    },
    {
      "index": 3,
      "text": "\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] \u306fi\u756a\u76ee\u306e\u30ab\u30fc\u30c9\u304c\u901a\u308c\u308b\u9580\u306e\u6700\u5927\u5024\ntrange = [0] * n\n\n# \u9580\u304c\u901a\u308c\u308b\u30ab\u30fc\u30c9\u756a\u53f7\u3092\u6c42\u3081\u308b\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l - 1, r):\n        trange[j] = r\n\n# \u901a\u308c\u308b\u9580\u304cm\u4ee5\u4e0a\u3042\u308b\u30ab\u30fc\u30c9\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u6c42\u3081\u308b\nprint(len([i for i in trange if i >= m]))\n"
    },
    {
      "index": 4,
      "text": "\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] \u306fi\u756a\u76ee\u306e\u30ab\u30fc\u30c9\u304c\u901a\u308c\u308b\u9580\u306e\u6700\u5927\u5024\ntrange = [0] * n\n\n# \u9580\u304c\u901a\u308c\u308b\u30ab\u30fc\u30c9\u756a\u53f7\u3092\u6c42\u3081\u308b\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# \u901a\u308c\u308b\u9580\u304cm\u4ee5\u4e0a\u3042\u308b\u30ab\u30fc\u30c9\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u6c42\u3081\u308b\nprint(len([i for i in trange if i >= m]))\n"
    },
    {
      "index": 5,
      "text": "import sys\n\nn, m = map(int, input().split())\n\n# trange[i] \u306fi\u756a\u76ee\u306e\u30ab\u30fc\u30c9\u304c\u901a\u308c\u308b\u9580\u306e\u6700\u5927\u5024\ntrange = [0] * n\n\n# \u9580\u304c\u901a\u308c\u308b\u30ab\u30fc\u30c9\u756a\u53f7\u3092\u6c42\u3081\u308b\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# \u901a\u308c\u308b\u9580\u304cm\u4ee5\u4e0a\u3042\u308b\u30ab\u30fc\u30c9\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u6c42\u3081\u308b\nprint(len([i for i in trange if i >= m]))\n"
    },
    {
      "index": 6,
      "text": "\n\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] \u306f i \u756a\u76ee\u306e\u30ab\u30fc\u30c9\u304c\u901a\u308c\u308b\u9580\u306e\u6700\u5927\u5024\ntrange = [0] * n\n\n# \u9580\u304c\u901a\u308c\u308b\u30ab\u30fc\u30c9\u756a\u53f7\u3092\u6c42\u3081\u308b\u305f\u3081\u3001trange \u3092\u66f4\u65b0\u3059\u308b\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# \u901a\u308c\u308b\u9580\u304c m \u4ee5\u4e0a\u3042\u308b\u30ab\u30fc\u30c9\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u6c42\u3081\u308b\nprint(len([i for i in trange if i >= m]))\n"
    },
    {
      "index": 7,
      "text": "\nn, m = map(int, input().split())\n\n# trange[i] \u306fi\u756a\u76ee\u306e\u30ab\u30fc\u30c9\u304c\u901a\u308c\u308b\u9580\u306e\u6700\u5927\u5024\ntrange = [0] * n\n\n# \u9580\u304c\u901a\u308c\u308b\u30ab\u30fc\u30c9\u756a\u53f7\u3092\u6c42\u3081\u308b\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# \u901a\u308c\u308b\u9580\u304cm\u4ee5\u4e0a\u3042\u308b\u30ab\u30fc\u30c9\u304c\u3044\u304f\u3064\u3042\u308b\u304b\u3092\u6c42\u3081\u308b\nprint(len([i for i in trange if i >= m]))\n"
    }
  ],
  "created": 1650754485,
  "object": "edit"
}
2022-04-23 22:55:20.242314 fix syntax errors 8 ['\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] はi番目のカードが通れる門の最大値\ntrange = [0] * n\n\n# 門が通れるカード番号を求める\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l - 1, r):\n        trange[j] = r\n\n# 通れる門がm以上あるカードがいくつあるかを求める\nprint(len([i for i in trange if i >= m]))\n', '\n\nn, m = map(int, input().split())\n\n# trange[i] はi番目のカードが通れる門の最大値\ntrange = [0] * n\n\n# 門が通れるカード番号を求める\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# 通れる門がm以上あるカードがいくつあるかを求める\nprint(len([i for i in trange if i >= m]))\n', '\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] はi番目のカードが通れる門の最大値\ntrange = [0] * n\n\n# 門が通れるカード番号を求める\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):  # 門の番号は1から始まるため-1\n        trange[j] = r\n\n# 通れる門がm以上あるカードがいくつあるかを求める\nprint(sum([1 for i in trange if i >= m]))\n', '\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] はi番目のカードが通れる門の最大値\ntrange = [0] * n\n\n# 門が通れるカード番号を求める\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l - 1, r):\n        trange[j] = r\n\n# 通れる門がm以上あるカードがいくつあるかを求める\nprint(len([i for i in trange if i >= m]))\n', '\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] はi番目のカードが通れる門の最大値\ntrange = [0] * n\n\n# 門が通れるカード番号を求める\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# 通れる門がm以上あるカードがいくつあるかを求める\nprint(len([i for i in trange if i >= m]))\n', 'import sys\n\nn, m = map(int, input().split())\n\n# trange[i] はi番目のカードが通れる門の最大値\ntrange = [0] * n\n\n# 門が通れるカード番号を求める\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# 通れる門がm以上あるカードがいくつあるかを求める\nprint(len([i for i in trange if i >= m]))\n', '\n\nimport sys\n\nn, m = map(int, input().split())\n\n# trange[i] は i 番目のカードが通れる門の最大値\ntrange = [0] * n\n\n# 門が通れるカード番号を求めるため、trange を更新する\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# 通れる門が m 以上あるカードがいくつあるかを求める\nprint(len([i for i in trange if i >= m]))\n', '\nn, m = map(int, input().split())\n\n# trange[i] はi番目のカードが通れる門の最大値\ntrange = [0] * n\n\n# 門が通れるカード番号を求める\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        trange[j] = r\n\n# 通れる門がm以上あるカードがいくつあるかを求める\nprint(len([i for i in trange if i >= m]))\n']
2022-04-23 22:55:20.242445 size on output set 7
2022-04-23 22:55:20.242460 num operations 1
2022-04-23 22:55:20.242466 size on input set 1
2022-04-23 22:55:20.242586 using api key jaanu
2022-04-23 22:55:53.784350 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(max(R_max - L_min + 1, 0))\n"
    },
    {
      "index": 1,
      "text": "\n\nN, A = map(int, input().split())\nX = list(map(int, input().split()))\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n"
    },
    {
      "index": 2,
      "text": "# coding: utf-8\n\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n"
    },
    {
      "index": 3,
      "text": "\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n"
    },
    {
      "index": 4,
      "text": "\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n"
    },
    {
      "index": 5,
      "text": "\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n"
    },
    {
      "index": 6,
      "text": "\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n"
    },
    {
      "index": 7,
      "text": "\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1 if R_max >= L_min else 0)\n"
    }
  ],
  "created": 1650754520,
  "object": "edit"
}
2022-04-23 22:55:53.784680 fix syntax errors 8 ['\n\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(max(R_max - L_min + 1, 0))\n', '\n\nN, A = map(int, input().split())\nX = list(map(int, input().split()))\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n', '# coding: utf-8\n\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n', '\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n', '\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n', '\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n', '\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1)\n', '\nN, M = map(int, input().split())\nL = []\nR = []\nfor _ in range(M):\n    l, r = map(int, input().split())\n    L.append(l)\n    R.append(r)\n\nL_min = min(L)\nR_max = max(R)\nprint(R_max - L_min + 1 if R_max >= L_min else 0)\n']
2022-04-23 22:55:53.784716 size on output set 5
