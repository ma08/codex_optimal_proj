2022-04-23 22:58:54.926709 num operations 1
2022-04-23 22:58:54.926729 size on input set 1
2022-04-23 22:58:54.926847 using api key sunu
2022-04-23 22:59:16.413779 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition for the previous points\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for the current point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 2,
      "text": "\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point]  # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort()  # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 3,
      "text": "\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 5,
      "text": "\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 6,
      "text": "\n\nimport math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point]  # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous\n            # points then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort()  # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 7,
      "text": "import math\n\ndef main():\n    \"\"\"\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    \"\"\"\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        \"\"\"\n        Check that the given number is a power of 2\n        \"\"\"\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1650754735,
  "object": "edit"
}
2022-04-23 22:59:16.414455 fix syntax errors 8 ['\n\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition for the previous points\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for the current point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point]  # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort()  # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', '\n\nimport math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort()  # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point]  # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous\n            # points then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort()  # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n', 'import math\n\ndef main():\n    """\n    We start with the first point and move towards the last point.\n    For each point, we check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n    """\n    n = int(input())\n    points = list(map(int, input().split()))\n\n    def is_pow_of_2(x):\n        """\n        Check that the given number is a power of 2\n        """\n        return int(math.log2(x)) == math.log2(x)\n\n    points.sort() # Sort points to make sure that points are in ascending order\n    max_points = [] # List of points that satisfy the given condition\n    for point_idx in range(n):\n        point = points[point_idx]\n        temp_max_points = [point] # List of points that satisfy the given condition for a particular point\n        for pow_idx in range(1, int(math.log2(10**9))):\n            # We check that there are points at a distance of 2^1, 2^2, 2^3, ..., 2^log2(10^9)\n            if (point + 2**pow_idx in points) and (point - 2**pow_idx in points):\n                temp_max_points.append(point + 2**pow_idx)\n                temp_max_points.append(point - 2**pow_idx)\n            else:\n                break\n        if len(temp_max_points) > len(max_points):\n            # If there are more points that satisfy the given condition for the current point than for the previous points\n            # then we set the current points as the maximum points\n            max_points = temp_max_points\n\n    max_points.sort() # Sort points to make sure that points are in ascending order\n\n    print(len(max_points))\n    print(*max_points)\n\nif __name__ == "__main__":\n    main()\n']
2022-04-23 22:59:16.414610 size on output set 6
2022-04-23 22:59:16.414625 num operations 1
2022-04-23 22:59:16.414632 size on input set 1
2022-04-23 22:59:16.414783 using api key soukgp
2022-04-23 22:59:37.441368 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n        d[cur] = 0\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values()) if d.values() else 0\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums) or nums[i] - nums[i - 1] > 1:\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, max(res, d[cur]))\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 2,
      "text": "\ndef main():\n    n = int(input())\n    nums = [int(i) for i in input().split()]\n\n    d = {}\n    for num in nums:\n        d[num] = d.get(num, 0) + 1\n\n    sorted_nums = sorted(d.keys())\n\n    def helper(sorted_nums, d, i):\n        if i == len(sorted_nums):\n            return\n\n        cur = sorted_nums[i]\n        if cur - 1 in d and cur + 1 in d:\n            d[cur] = d[cur - 1] + d[cur + 1]\n        helper(sorted_nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in sorted_nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 3,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums):\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, max(d[cur], res))\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 4,
      "text": "\n\ndef helper(nums, d, i):\n    if i == len(nums):\n        return d\n\n    cur = nums[i]\n\n    if cur - 1 in d:\n        d[cur] += d[cur - 1]\n    if cur + 1 in d:\n        d[cur] += d[cur + 1]\n\n    return helper(nums, d, i + 1)\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 5,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums) - 1:\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, max(res, d[cur]))\n\n    d = helper(nums, d, 0)\n\n    res = helper(nums, d, 0, 0)\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 6,
      "text": "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    for i in nums:\n        if i - 1 in d:\n            d[i] += d[i - 1]\n        if i + 1 in d:\n            d[i] += d[i + 1]\n\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 7,
      "text": "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d: \n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i): \n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res) \n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650754756,
  "object": "edit"
}
2022-04-23 22:59:37.441705 fix syntax errors 8 ["\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i):\n        if i == len(nums):\n            return d\n        d[cur] = 0\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values()) if d.values() else 0\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums) or nums[i] - nums[i - 1] > 1:\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, max(res, d[cur]))\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    nums = [int(i) for i in input().split()]\n\n    d = {}\n    for num in nums:\n        d[num] = d.get(num, 0) + 1\n\n    sorted_nums = sorted(d.keys())\n\n    def helper(sorted_nums, d, i):\n        if i == len(sorted_nums):\n            return\n\n        cur = sorted_nums[i]\n        if cur - 1 in d and cur + 1 in d:\n            d[cur] = d[cur - 1] + d[cur + 1]\n        helper(sorted_nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in sorted_nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums):\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, max(d[cur], res))\n\n    res = helper(nums, d, 0, 0)\n\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef helper(nums, d, i):\n    if i == len(nums):\n        return d\n\n    cur = nums[i]\n\n    if cur - 1 in d:\n        d[cur] += d[cur - 1]\n    if cur + 1 in d:\n        d[cur] += d[cur + 1]\n\n    return helper(nums, d, i + 1)\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i, res):\n        if i == len(nums) - 1:\n            return res\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1, max(res, d[cur]))\n\n    d = helper(nums, d, 0)\n\n    res = helper(nums, d, 0, 0)\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    for i in nums:\n        if i - 1 in d:\n            d[i] += d[i - 1]\n        if i + 1 in d:\n            d[i] += d[i + 1]\n\n\n    res = max(d.values())\n    print(res)\n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n", "\n\ndef main():\n    n = int(input())\n    x = [int(i) for i in input().split()]\n\n    d = {}\n    for i in x:\n        if i not in d: \n            d[i] = 1\n        else:\n            d[i] += 1\n\n    nums = sorted(d.keys())\n\n    def helper(nums, d, i): \n        if i == len(nums):\n            return d\n\n        cur = nums[i]\n\n        if cur - 1 in d:\n            d[cur] += d[cur - 1]\n        if cur + 1 in d:\n            d[cur] += d[cur + 1]\n\n        return helper(nums, d, i + 1)\n\n    d = helper(nums, d, 0)\n\n    res = max(d.values())\n    print(res) \n    print(' '.join([str(i) for i in nums if d[i] == res]))\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-23 22:59:37.441836 size on output set 8
2022-04-23 22:59:37.441851 num operations 1
2022-04-23 22:59:37.441869 size on input set 1
2022-04-23 22:59:37.442005 using api key jaanu
2022-04-23 22:59:52.386308 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom math import log\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 2,
      "text": "import math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 3,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 4,
      "text": "\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = []\n                if points[i] not in largest_subset:\n                    largest_subset.append(points[j])\n    for i in range(1, n):\n                break\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 5,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 6,
      "text": "\nimport math\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    },
    {
      "index": 7,
      "text": "\n\ndef is_power_of_two(n):\n    \"\"\"\n    :param n: integer\n    :return: True if n is power of 2, False otherwise\n    \"\"\"\n    return (n & (n - 1) == 0) and n != 0\n\n\ndef get_largest_subset(n, points):\n    \"\"\"\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    \"\"\"\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if is_power_of_two(abs(points[i] - points[j])):\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \"\"\"\n    Reads input, parses it.\n    :return: n(int), points(list)\n    \"\"\"\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n"
    }
  ],
  "created": 1650754777,
  "object": "edit"
}
2022-04-23 22:59:52.386590 fix syntax errors 8 ["\nimport math\n\n\ndef get_largest_subset(n, points):\n    \n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    \n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == '__main__':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n", '\n\nfrom math import log\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', 'import math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\n\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = []\n                if points[i] not in largest_subset:\n                    largest_subset.append(points[j])\n    for i in range(1, n):\n                break\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\nimport math\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if math.log(abs(points[i] - points[j]), 2) % 1 == 0:\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n', '\n\ndef is_power_of_two(n):\n    """\n    :param n: integer\n    :return: True if n is power of 2, False otherwise\n    """\n    return (n & (n - 1) == 0) and n != 0\n\n\ndef get_largest_subset(n, points):\n    """\n    :param n: number of points\n    :param points: list of points\n    :return: largest subset of points with integral power of 2 distance between each pair of points in the subset\n    """\n    largest_subset = [points[0]]\n    for i in range(1, n):\n        for j in range(i):\n            if is_power_of_two(abs(points[i] - points[j])):\n                largest_subset.append(points[i])\n    return largest_subset\n\n\ndef read_input():\n    """\n    Reads input, parses it.\n    :return: n(int), points(list)\n    """\n    n = int(input())\n    points = [int(i) for i in input().split()]\n    return n, points\n\n\nif __name__ == \'__main__\':\n    n, points = read_input()\n    largest_subset = get_largest_subset(n, points)\n    print(len(largest_subset))\n    print(*largest_subset)\n']
2022-04-23 22:59:52.386797 size on output set 6
