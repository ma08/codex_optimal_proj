["var file = require('fs');\n\nvar data = file.readFileSync('input.txt');\n\nconsole.log(data.toString());\nconsole.log(\"Program Ended\");\n", "\n\n#---------------------------------------------------------------------------------\n\n\nimport sys\nimport numpy as np\nfrom collections import defaultdict\n\ndef dfs(s, visited, graph):\n    visited[s] = True\n    for i in graph[s]:\n        if not visited[i]:\n            dfs(i, visited, graph)\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n\n    visited = np.zeros(n + 1)\n    dfs(s, visited, graph)\n\n    res = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, graph)\n            res += 1\n    print(res)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import defaultdict\n\nn, m, s = sys.stdin.readline().split()\nn, m, s = int(n), int(m), int(s)\nedges = defaultdict(list)\nfor i in range(m):\n    u, v = sys.stdin.readline().split()\n    u, v = int(u), int(v)\n    edges[u].append(v)\nvisited = set()\nq = [s]\nwhile q:\n    node = q.pop()\n    visited.add(node)\n    for edge in edges[node]:\n        if edge not in visited:\n            q.append(edge)\nprint(n - len(visited))\n\n", "\n\nimport sys\nimport numpy as np\nfrom collections import defaultdict\n\ndef dfs(s, visited, graph, d):\n    visited[s] = True\n    if s in graph:\n        for i in graph[s]:\n            if not visited[i]:\n                dfs(i, visited, graph, d + 1)\n    else:\n        if d > max_d:\n            max_d = d\n    global max_d\n    max_d = 0\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        graph[a].append(b)\n\n    visited = np.zeros(n + 1)\n    dfs(s, visited, graph, 0)\n\n    res = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, graph, 0)\n            res += 1\n    print(res, max_d)\n\nif __name__ == '__main__':\n    main()\n", "<<<<<<< HEAD\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, s = sys.stdin.readline().split()\n    n, m, s = int(n), int(m), int(s)\n    edges = defaultdict(list)\n    for i in range(m):\n        u, v = sys.stdin.readline().split()\n        u, v = int(u), int(v)\n        edges[u].append(v)\n    visited = set()\n    q = [s]\n    while q:\n        node = q.pop()\n        visited.add(node)\n        for edge in edges[node]:\n            if edge not in visited:\n                q.append(edge)\n    print(n - len(visited))\n\nmain()\n=======\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, s = sys.stdin.readline().split()\n    n, m, s = int(n), int(m), int(s)\n    edges = defaultdict(list)\n    for i in range(m):\n        u, v = sys.stdin.readline().split()\n        u, v = int(u), int(v)\n        edges[u].append(v)\n    visited = set()\n    q = [s]\n    while q:\n        node = q.pop()\n        visited.add(node)\n        for edge in edges[node]:\n            if edge not in visited:\n                q.append(edge)\n    print(n - len(visited))\n\nmain()\n>>>>>>> c9e7e9c8d2f1ffa0f2a6c3e3b8e6e7a6b9cd9f0c\n", "<!DOCTYPE html>\n<html>\n<head>\n\t<title>Sorting</title>\n</head>\n<body>\n\t<?php\n\t\t$cars = array(\"Volvo\", \"BMW\", \"Toyota\");\n\t\tsort($cars);\n\t\t$clength = count($cars);\n\t\tfor($x = 0; $x < $clength; $x++) {\n\t\t\techo $cars[$x];\n\t\t\techo \"<br>\";\n\t\t}\n\t?>\n</body>\n</html>\n", "#!/bin/bash\n\n# This script will be used to fix syntax errors in a file\n\nsed -i 's/\\b\\(fi\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(done\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(then\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(else\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(elif\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(esac\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(do\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(done\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(then\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(else\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(elif\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(esac\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(do\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(done\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(then\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(else\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(elif\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(esac\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(do\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(done\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(then\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(else\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(elif\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(esac\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(do\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(done\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(then\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(else\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(elif\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(esac\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(do\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(done\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(then\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(else\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(elif\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(esac\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(do\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(done\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(then\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(else\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(elif\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(esac\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(do\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(done\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(then\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(else\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(elif\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(esac\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(do\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(done\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(then\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(else\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(elif\\)\\b/\\1/g' $1\n\nsed -i 's/\\b\\(esac\\)\\b/\\1/g' $1\n", "\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, s = sys.stdin.readline().split()\n    n, m, s = int(n), int(m), int(s)\n    edges = defaultdict(list)\n    for i in range(m):\n        u, v = sys.stdin.readline().split()\n        u, v = int(u), int(v)\n        edges[u].append(v)\n    visited = set()\n    q = [s]\n    while q:\n        node = q.pop()\n        visited.add(node)\n        for edge in edges[node]:\n            if edge not in visited:\n                q.append(edge)\n    print(n - len(visited))\n\nmain()\n", "\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    edges = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges[u].append(v)\n    visited = set()\n    q = [s]\n    while q:\n        node = q.pop()\n        visited.add(node)\n        for edge in edges[node]:\n            if edge not in visited:\n                q.append(edge)\n    print(n - len(visited))\n\nmain()\n", "\n\n#---------------------------------------------------------------------------------\n\nimport sys\nimport numpy as np\nfrom collections import defaultdict\n\ndef dfs(s, visited, graph):\n    visited[s] = True\n    for i in graph[s]:\n        if not visited[i]:\n            dfs(i, visited, graph)\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n    visited = np.zeros(n + 1)\n    dfs(s, visited, graph)\n\n    res = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, graph)\n            res += 1\n    print(res)\n\nif __name__ == '__main__':\n    main()\n", "# https://www.acmicpc.net/problem/2667\n\n#---------------------------------------------------------------------------------\n\nimport sys\nimport numpy as np\nfrom collections import defaultdict\n\ndef dfs(s, visited, graph):\n    visited[s] = True\n    for i in graph[s]:\n        if not visited[i]:\n            dfs(i, visited, graph)\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n\n    visited = np.zeros(n + 1)\n    dfs(s, visited, graph)\n\n    res = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, graph)\n            res += 1\n    print(res)\n\nif __name__ == '__main__':\n    main()\n", "import sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, s = sys.stdin.readline().split()\n    n, m, s = int(n), int(m), int(s)\n    edges = defaultdict(list)\n    for i in range(m):\n        u, v = sys.stdin.readline().split()\n        u, v = int(u), int(v)\n        edges[u].append(v)\n    visited = set()\n    q = [s]\n    while q:\n        node = q.pop()\n        visited.add(node)\n        for edge in edges[node]:\n            if edge not in visited:\n                q.append(edge)\n    print(n - len(visited))\n\nmain()\n", "#---------------------------------------------------------------------------------\n#  File:        file.py\n#  Description: File description here\n#  Usage:       python file.py\n#  Created:     24-Oct-2019\n#  Author:      Zeyuan Hu\n#---------------------------------------------------------------------------------\n#---------------------------------------------------------------------------------\n\nimport sys\nimport numpy as np\nfrom collections import defaultdict\n\ndef dfs(s, visited, graph):\n    visited[s] = True\n    for i in graph[s]:\n        if not visited[i]:\n            dfs(i, visited, graph)\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n\n    visited = np.zeros(n + 1)\n    dfs(s, visited, graph)\n\n    res = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, graph)\n            res += 1\n    print(res)\n\nif __name__ == '__main__':\n    main()\n", "var fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar colors = require('colors');\nvar mkdirp = require('mkdirp');\n\nvar File = function(filepath) {\n  this.filepath = filepath;\n  this.file = path.basename(filepath);\n  this.dir = path.dirname(filepath);\n  this.ext = path.extname(filepath);\n  this.name = path.basename(filepath, this.ext);\n  this.stat = null;\n  this.contents = null;\n  this.isBinary = null;\n  this.isBuffer = null;\n  this.isStream = null;\n  this.isNull = null;\n};\n\nFile.prototype.isBuffer = function() {\n  return Buffer.isBuffer(this.contents);\n};\n\nFile.prototype.isStream = function() {\n  return util.isStream(this.contents);\n};\n\nFile.prototype.isNull = function() {\n  return this.contents === null;\n};\n\nFile.prototype.isDirectory = function() {\n  return this.stat && this.stat.isDirectory();\n};\n\nFile.prototype.isText = function() {\n  if (this.isBuffer()) {\n    return false;\n  }\n  if (this.isStream()) {\n    return false;\n  }\n  if (this.isNull()) {\n    return false;\n  }\n  return true;\n};\n\nFile.prototype.isNull = function() {\n  return this.contents === null;\n};\n\nFile.prototype.isDirectory = function() {\n  return this.stat && this.stat.isDirectory();\n};\n\nFile.prototype.isText = function() {\n  if (this.isBuffer()) {\n    return false;\n  }\n  if (this.isStream()) {\n    return false;\n  }\n  if (this.isNull()) {\n    return false;\n  }\n  return true;\n};\n\nFile.prototype.isBinary = function() {\n  if (this.isBuffer()) {\n    return true;\n  }\n  if (this.isStream()) {\n    return true;\n  }\n  if (this.isNull()) {\n    return true;\n  }\n  return false;\n};\n\nFile.prototype.inspect = function() {\n  var inspect = [];\n  inspect.push(colors.magenta(this.file));\n  inspect.push(colors.grey('(' + this.contents.length + ')'));\n  return inspect.join(' ');\n};\n\nFile.prototype.read = function(enc, cb) {\n  var self = this;\n  if (!cb && typeof enc === 'function') {\n    cb = enc;\n    enc = null;\n  }\n  if (typeof enc === 'string') {\n    enc = { encoding: enc };\n  }\n  if (cb) {\n    this.readSync(enc);\n    process.nextTick(cb);\n    return;\n  }\n  fs.readFile(this.filepath, enc, function(err, data) {\n    if (err) {\n      self.error = err;\n      self.contents = null;\n      self.stat = null;\n      return cb(err);\n    }\n    self.contents = data;\n    self.stat = fs.statSync(self.filepath);\n    cb(null, self);\n  });\n};\n\nFile.prototype.readSync = function(enc) {\n  this.contents = fs.readFileSync(this.filepath, enc);\n  this.stat = fs.statSync(this.filepath);\n  return this;\n};\n\nFile.prototype.write = function(options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  if (typeof options === 'string') {\n    options = { encoding: options };\n  }\n  if (options.encoding !== null) {\n    options.encoding = options.encoding || 'utf8';\n  }\n  if (!cb) {\n    this.writeSync(options);\n    return;\n  }\n  var self = this;\n  var dir = path.dirname(this.filepath);\n  mkdirp(dir, function(err) {\n    if (err) {\n      self.error = err;\n      return cb(err);\n    }\n    fs.writeFile(self.filepath, self.contents, options, function(err) {\n      if (err) {\n        self.error = err;\n        return cb(err);\n      }\n      self.stat = fs.statSync(self.filepath);\n      cb(null, self);\n    });\n  });\n};\n\nFile.prototype.writeSync = function(options) {\n  if (options.encoding !== null) {\n    options.encoding = options.encoding || 'utf8';\n  }\n  var dir = path.dirname(this.filepath);\n  mkdirp.sync(dir);\n  fs.writeFileSync(this.filepath, this.contents, options);\n  this.stat = fs.statSync(this.filepath);\n  return this;\n};\n\nFile.prototype.clone = function(options) {\n  if (typeof options === 'string') {\n    options = {cwd: options};\n  }\n  options = options || {};\n  var file = new File({\n    cwd: options.cwd || this.cwd,\n    base: options.base || this.base,\n    path: options.path || this.path,\n    stat: this.stat,\n    contents: this.contents\n  });\n  return file;\n};\n\nFile.prototype.pipe = function(stream, opt) {\n  if (!opt) opt = {};\n  if (typeof opt.end === 'undefined') opt.end = true;\n\n  if (this.isStream()) {\n    return this.contents.pipe(stream, opt);\n  }\n\n  if (this.isBuffer()) {\n    if (opt.end) {\n      stream.end(this.contents);\n    } else {\n      stream.write(this.contents);\n    }\n    return stream;\n  }\n\n  if (this.isNull()) {\n    if (opt.end) stream.end();\n    return stream;\n  }\n\n  stream.end(this.contents, opt.encoding);\n  return stream;\n};\n\nFile.prototype.contents = function(buf) {\n  if (typeof buf === 'undefined') {\n    if (!this.isBuffer()) {\n      return this.contents;\n    }\n    if (this.isStream()) {\n      throw new Error('Contents is a stream');\n    }\n    return this.contents;\n  }\n  if (typeof buf === 'string') {\n    buf = new Buffer(buf);\n  }\n  this.contents = buf;\n  return this;\n};\n\nFile.prototype.relative = function(filepath) {\n  if (filepath) {\n    this.path = path.join(this.base, filepath);\n  }\n  return path.relative(this.cwd, this.path);\n};\n\nFile.prototype.basename = function(ext) {\n  if (ext) {\n    this.path = path.join(this.dirname\n", "function readFile(file){\n\tvar fs = require('fs');\n\tvar array = fs.readFileSync(file).toString().split(\"\\n\");\n\tfor(i in array) {\n\t    console.log(array[i]);\n\t}\n}\n\nreadFile(process.argv[2]);\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, m, s = sys.stdin.readline().split()\n    n, m, s = int(n), int(m), int(s)\n    edges = defaultdict(list)\n    for i in range(m):\n        u, v = sys.stdin.readline().split()\n        u, v = int(u), int(v)\n        edges[u].append(v)\n    visited = set()\n    q = [s]\n    while q:\n        node = q.pop()\n        visited.add(node)\n        for edge in edges[node]:\n            if edge not in visited:\n                q.append(edge)\n    print(n - len(visited))\n\nmain()\n", "function readFile(fileName) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(fileName, (error, data) => {\n            if (error) {\n                reject(error);\n            }\n            resolve(data);\n        });\n    });\n}\n\nfunction writeFile(fileName, data) {\n    return new Promise((resolve, reject) => {\n        fs.writeFile(fileName, data, (error) => {\n            if (error) {\n                reject(error);\n            }\n            resolve();\n        });\n    });\n}\n\nfunction appendFile(fileName, data) {\n    return new Promise((resolve, reject) => {\n        fs.appendFile(fileName, data, (error) => {\n            if (error) {\n                reject(error);\n            }\n            resolve();\n        });\n    });\n}\n\nfunction deleteFile(fileName) {\n    return new Promise((resolve, reject) => {\n        fs.unlink(fileName, (error) => {\n            if (error) {\n                reject(error);\n            }\n            resolve();\n        });\n    });\n}\n\nfunction readDir(path) {\n    return new Promise((resolve, reject) => {\n        fs.readdir(path, (error, files) => {\n            if (error) {\n                reject(error);\n            }\n            resolve(files);\n        });\n    });\n}\n\nfunction createDir(path) {\n    return new Promise((resolve, reject) => {\n        fs.mkdir(path, (error) => {\n            if (error) {\n                reject(error);\n            }\n            resolve();\n        });\n    });\n}\n\nfunction deleteDir(path) {\n    return new Promise((resolve, reject) => {\n        fs.rmdir(path, (error) => {\n            if (error) {\n                reject(error);\n            }\n            resolve();\n        });\n    });\n}\n\nmodule.exports = {\n    readFile,\n    writeFile,\n    appendFile,\n    deleteFile,\n    readDir,\n    createDir,\n    deleteDir\n};\n", "\n\n#---------------------------------------------------------------------------------\n\nimport sys\nimport numpy as np\nfrom collections import defaultdict\n\ndef dfs(s, visited, graph):\n    visited[s] = True\n    for i in graph[s]:\n        if not visited[i]:\n            dfs(i, visited, graph)\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n    a = 1\n    visited = np.zeros(n + 1)\n    dfs(s, visited, graph)\n\n    res = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, graph)\n            res += 1\n    print(res)\n\nif __name__ == '__main__':\n    main()\n", "\n#---------------------------------------------------------------------------------\n\nimport sys\nimport numpy as np\nfrom collections import defaultdict\n\ndef dfs(s, visited, graph):\n    visited[s] = True\n    for i in graph[s]:\n        if not visited[i]:\n            dfs(i, visited, graph)\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v) \n        \n    visited = np.zeros(n + 1)\n    dfs(s, visited, graph)\n\n    res = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, graph)\n            res += 1\n    print(res)\n    \nif __name__ == '__main__':\n    main()\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LENGTH 1024\n\nint main(int argc, char *argv[]){\n\n\tint i;\n\tchar *s;\n\tFILE *fp;\n\tchar buf[MAX_LENGTH];\n\n\tif(argc <2){\n\t\tfprintf(stderr, \"Usage: %s <filename>\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tfor(i=1; i<argc; i++) {\n\t\tfp = fopen(argv[i], \"r\");\n\t\tif(fp == NULL){\n\t\t\tperror(\"fopen failed\");\n\t\t\texit(1);\n\t\t}\n\n\t\twhile(fgets(buf, MAX_LENGTH, fp)){\n\t\t\ts = strtok(buf, \" \\t\\n\");\n\t\t\twhile(s != NULL){\n\t\t\t\tprintf(\"%s\\n\", s);\n\t\t\t\ts = strtok(NULL, \" \\t\\n\");\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t}\n\treturn 0;\n}\n", "\n\n#---------------------------------------------------------------------------------\n\nimport sys\nimport numpy as np\nfrom collections import defaultdict\n\ndef dfs(s, visited, graph):\n    visited[s] = True\n    for i in graph[s]:\n        if not visited[i]:\n            dfs(i, visited, graph)\n\ndef main():\n    n, m, s = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for i in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n    graph[v].append(u)\n    visited = np.zeros(n + 1)\n    dfs(s, visited, graph)\n\n    res = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, graph)\n            res += 1\n    print(res)\n\nif __name__ == '__main__':\n    main()\n", "require 'fileutils'\n\nclass File\n  def self.write(file, content)\n    FileUtils.mkdir_p File.dirname(file)\n    File.open(file, 'w') { |f| f.write content }\n  end\nend\n"]