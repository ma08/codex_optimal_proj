["\n\ndef main():\n    # read data for n sequences\n    n = int(input())\n    s = input()\n    t = input()\n\n    # solve\n    if s == t:\n        print(0)\n    else:\n        # create a dictionary to store the number of occurences of each character\n        d = {}\n        for i in range(n):\n            if s[i] in d:\n                d[s[i]] += 1\n            else:\n                d[s[i]] = 1\n            if t[i] in d:\n                d[t[i]] -= 1\n            else:\n                d[t[i]] = -1\n        flag = True\n        for key in d:\n            if d[key] != 0:\n                flag = False\n                break\n        if flag:\n            i = 0\n            j = 0\n            count = 0\n            while i < n and j < n:\n                if s[i] == t[j]:\n                    i += 1\n                    j += 1\n                else:\n                    i += 1\n                    count += 1\n            if count > 10000:\n                print(-1)\n            else:\n                print(count)\n            i = 0\n            j = 0\n            while i < n and j < n:\n                if s[i] == t[j]:\n                    i += 1\n                    j += 1\n                else:\n                    print(i, end=' ')\n                    i += 1\n                    count += 1\n        else:\n            print(-1)\n\nmain()\n", "var fs = require('fs');\n\nfs.readFile('file.js', 'utf8', function (err,data) {\n  if (err) {\n    return console.log(err);\n  }\n  console.log(data);\n});\n", "\n\ndef main():\n    # read data for n sequences\n    n = int(input())\n    s = input()\n    t = input()\n\n    # solve\n    if s == t:\n        print(0)\n    else:\n        # create a dictionary to store the number of occurences of each character\n        d = {}\n        for i in range(n):\n            if s[i] in d:\n                d[s[i]] += 1\n            else:\n                d[s[i]] = 1\n            if t[i] in d:\n                d[t[i]] -= 1\n            else:\n                d[t[i]] = -1\n        flag = True\n        for key in d:\n            if d[key] != 0:\n                flag = False\n                break\n        if flag:\n            i = 0\n            j = 0\n            count = 0\n            while i < n and j < n:\n                if s[i] == t[j]:\n                    i += 1\n                    j += 1\n                else:\n                    i += 1\n                    count += 1\n            print(count)\n            i = 0\n            j = 0\n            while i < n and j < n:\n                if s[i] == t[j]:\n                    i += 1\n                    j += 1\n                else:\n                    print(i, end=' ')\n                    i += 1\n                    count += 1\n        else:\n            print(-1)\n\nmain()\n", "\n\ndef main():\n    # read data for n sequences\n    n = 3\n    s = \"abc\"\n    t = \"abc\"\n\n    # solve\n    if s == t:\n        print(0)\n    else:\n        # create a dictionary to store the number of occurences of each character\n        d = {}\n        for i in range(n):\n            if s[i] in d:\n                d[s[i]] = 1\n            else:\n                d[s[i]] = 1\n            if t[i] in d:\n                d[t[i]] -= 1\n            else:\n                d[t[i]] = -1\n        flag = True\n        for key in d:\n            if d[key] != 0:\n                flag = False\n                break\n        if flag:\n            i = 0\n            j = 0\n            count = 0\n            while i < n and j < n:\n                if s[i] == t[j]:\n                    i += 1\n                    j += 1\n                else:\n                    i += 1\n                    count += 1\n            if count > 10000:\n                print(-1)\n            else:\n                print(count)\n                i = 0\n                j = 0\n                while i < n and j < n:\n                    if s[i] == t[j]:\n                        i += 1\n                        j += 1\n                    else:\n                        print(i, end=' ')\n                        i += 1\n                        count += 1\n        else:\n            print(-1)\n\nmain()\n", "//write a function that takes a filename as a parameter\n//The file contains an ended Tic-Tac-Toe match\n//We have provided you some example files (draw.txt, win-x.txt, win-o.txt)\n//Return \"X\", \"O\" or \"Draw\" based on the input file\n//example:\n//console.log(ticTacResult('win-o.txt'))\n//console.log(ticTacResult('win-x.txt'))\n//console.log(ticTacResult('draw.txt'))\n\nconst fs = require('fs');\n\nfunction ticTacResult(fileName) {\n  let result = fs.readFileSync(fileName, 'utf-8');\n  if (result.indexOf('OOO') > -1) {\n    return 'O';\n  } else if (result.indexOf('XXX') > -1) {\n    return 'X';\n  } else {\n    return 'Draw';\n  }\n}\n\nconsole.log(ticTacResult('win-o.txt'));\nconsole.log(ticTacResult('win-x.txt'));\nconsole.log(ticTacResult('draw.txt'));\n", "var fs = require('fs');\nvar Promise = require('bluebird');\n\nfunction readFileAsync(fileName) {\n  return new Promise(function(resolve, reject) {\n    fs.readFile(fileName, function(err, data) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\nfunction* gen() {\n  try {\n    var f1 = yield readFileAsync('a.txt');\n    var f2 = yield readFileAsync('b.txt');\n    console.log(f1.toString());\n    console.log(f2.toString());\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nvar g = gen();\n\nvar r1 = g.next();\nr1.value.then(function(data) {\n  var r2 = g.next(data);\n  r2.value.then(function(data) {\n    var r3 = g.next(data);\n  });\n});\n", "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport time\nimport shutil\nimport logging\nimport argparse\nimport tempfile\nfrom contextlib import contextmanager\n\nimport pyinotify\nfrom watchdog.observers import Observer\nfrom watchdog.events import (FileCreatedEvent,\n                             FileDeletedEvent,\n                             FileModifiedEvent,\n                             FileMovedEvent,\n                             DirCreatedEvent,\n                             DirDeletedEvent,\n                             DirModifiedEvent,\n                             DirMovedEvent,\n                             PatternMatchingEventHandler)\n\nlogger = logging.getLogger(__name__)\n\n\nclass FileWatcher(PatternMatchingEventHandler):\n    def __init__(self, patterns=None, ignore_patterns=None,\n                 ignore_directories=False, case_sensitive=False):\n        super(FileWatcher, self).__init__(\n            patterns=patterns, ignore_patterns=ignore_patterns,\n            ignore_directories=ignore_directories, case_sensitive=case_sensitive)\n\n    def on_created(self, event):\n        if isinstance(event, FileCreatedEvent):\n            logger.info(\"File created: %s\", event.src_path)\n        elif isinstance(event, DirCreatedEvent):\n            logger.info(\"Dir created: %s\", event.src_path)\n\n    def on_deleted(self, event):\n        if isinstance(event, FileDeletedEvent):\n            logger.info(\"File deleted: %s\", event.src_path)\n        elif isinstance(event, DirDeletedEvent):\n            logger.info(\"Dir deleted: %s\", event.src_path)\n\n    def on_modified(self, event):\n        if isinstance(event, FileModifiedEvent):\n            logger.info(\"File modified: %s\", event.src_path)\n        elif isinstance(event, DirModifiedEvent):\n            logger.info(\"Dir modified: %s\", event.src_path)\n\n    def on_moved(self, event):\n        if isinstance(event, FileMovedEvent):\n            logger.info(\"File moved: %s -> %s\", event.src_path, event.dest_path)\n        elif isinstance(event, DirMovedEvent):\n            logger.info(\"Dir moved: %s -> %s\", event.src_path, event.dest_path)\n\n\nclass InotifyWatcher(pyinotify.ProcessEvent):\n    def __init__(self, mask, output_dir):\n        super(InotifyWatcher, self).__init__()\n        self.mask = mask\n        self.output_dir = output_dir\n\n    def process_IN_CREATE(self, event):\n        logger.info(\"File created: %s\", event.pathname)\n\n    def process_IN_DELETE(self, event):\n        logger.info(\"File deleted: %s\", event.pathname)\n\n    def process_IN_MODIFY(self, event):\n        logger.info(\"File modified: %s\", event.pathname)\n\n    def process_IN_MOVED_FROM(self, event):\n        logger.info(\"File moved from: %s\", event.pathname)\n\n    def process_IN_MOVED_TO(self, event):\n        logger.info(\"File moved to: %s\", event.pathname)\n\n\n@contextmanager\ndef temp_dir():\n    temp_dir = tempfile.mkdtemp()\n    yield temp_dir\n    shutil.rmtree(temp_dir)\n\n\ndef main(args):\n    logger.info(\"Started: %s\", args)\n\n    watch_dir = args.watch_dir\n    patterns = args.patterns\n    ignore_patterns = args.ignore_patterns\n    ignore_directories = args.ignore_directories\n    case_sensitive = args.case_sensitive\n    recursive = args.recursive\n    inotify = args.inotify\n    polling_interval = args.polling_interval\n\n    if inotify:\n        wm = pyinotify.WatchManager()\n        notifier = pyinotify.Notifier(wm, InotifyWatcher(\n            pyinotify.ALL_EVENTS, args.output_dir))\n        wm.add_watch(watch_dir, pyinotify.ALL_EVENTS, rec=True, auto_add=True)\n    else:\n        event_handler = FileWatcher(\n            patterns=patterns,\n            ignore_patterns=ignore_patterns,\n            ignore_directories=ignore_directories,\n            case_sensitive=case_sensitive)\n        observer = Observer()\n        observer.schedule(event_handler, watch_dir, recursive=recursive)\n        observer.start()\n\n    try:\n        while True:\n            if inotify:\n                notifier.process_events()\n                if notifier.check_events():\n                    notifier.read_events()\n            else:\n                time.sleep(polling_interval)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        if inotify:\n            notifier.stop()\n        else:\n            observer.stop()\n            observer.join()\n\n    logger.info(\"Finished: %s\", args)\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('watch_dir', help='Directory to be watched')\n    parser.add_argument('-p', '--patterns', nargs='+', default=['*'],\n                        help='List of filename patterns to watch')\n    parser.add_argument('-i', '--ignore-patterns', nargs='+', default=[],\n                        help='List of filename patterns to ignore')\n    parser.add_argument('-d', '--ignore-directories', action='store_true',\n                        help='Ignores all directories')\n    parser.add_argument('-c', '--case-sensitive', action='store_true',\n                        help='Case sensitive pattern matching')\n    parser.add_argument('-r', '--recursive', action='store_true',\n                        help='Watch directories recursively')\n    parser.add_argument('--inotify', action='store_true',\n                        help='Use inotify')\n    parser.add_argument('--polling-interval', type=float, default=1.0,\n                        help='Polling interval (sec)')\n    parser.add_argument('--output-dir', default='.',\n                        help='Output directory')\n    args = parser.parse_args()\n\n    main(args)\n"]