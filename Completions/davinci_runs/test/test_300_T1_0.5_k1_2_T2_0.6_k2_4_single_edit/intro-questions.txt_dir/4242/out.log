2022-04-09 19:20:29.849566 """
You are given positive integers A and B.
Find the K-th largest positive integer that divides both A and B.
The input guarantees that there exists such a number.

-----Constraints-----
 - All values in input are integers.
 - 1 \leq A, B \leq 100
 - The K-th largest positive integer that divides both A and B exists.
 - K \geq 1

-----Input-----
Input is given from Standard Input in the following format:
A B K

-----Output-----
Print the K-th largest positive integer that divides both A and B.

-----Sample Input-----
8 12 2

-----Sample Output-----
2

Three positive integers divides both 8 and 12: 1, 2 and 4.
Among them, the second largest is 2.
"""
2022-04-09 19:20:29.849586 --------------------------
2022-04-09 19:20:43.010669 {
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport math\n\ndef gcd(a, b):\n    if a < b:\n        a, b = b, a\n    while b != 0:\n        a, b = b, a % b\n    return a\n\na, b, k = map(int, input().split())\n\ng = gcd(a, b)\n\ndivisors = []\nfor i in range(1, int(math.sqrt(g)) + 1):\n    if g % i == 0:\n        divisors.append(i)\n        if i != g // i:\n            divisors.append(g // i)\n\ndivisors.sort(reverse=True)\n\nprint(divisors[k - 1])"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\nimport math\n\nA, B, K = map(int, input().split())\n\ndef prime_factorization(n):\n    factors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        while n % i == 0:\n            n //= i\n            factors.append(i)\n    return factors\n\ndef find_num(A, B, K):\n    A_factors = prime_factorization(A)\n    B_factors = prime_factorization(B)\n    common_factors = list(set(A_factors) & set(B_factors))\n    return common_factors[-K]\n\nprint(find_num(A, B, K))"
    }
  ],
  "created": 1649546430,
  "id": "cmpl-4vEfWDSiZBswIsaVGe7pmJm6uyzH3",
  "model": "code-davinci:002",
  "object": "text_completion"
}
2022-04-09 19:20:43.010863 0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport math\n\ndef gcd(a, b):\n    if a < b:\n        a, b = b, a\n    while b != 0:\n        a, b = b, a % b\n    return a\n\na, b, k = map(int, input().split())\n\ng = gcd(a, b)\n\ndivisors = []\nfor i in range(1, int(math.sqrt(g)) + 1):\n    if g % i == 0:\n        divisors.append(i)\n        if i != g // i:\n            divisors.append(g // i)\n\ndivisors.sort(reverse=True)\n\nprint(divisors[k - 1])"
}
2022-04-09 19:20:43.010905 REASON stop
2022-04-09 19:20:43.022533 1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\nimport math\n\nA, B, K = map(int, input().split())\n\ndef prime_factorization(n):\n    factors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        while n % i == 0:\n            n //= i\n            factors.append(i)\n    return factors\n\ndef find_num(A, B, K):\n    A_factors = prime_factorization(A)\n    B_factors = prime_factorization(B)\n    common_factors = list(set(A_factors) & set(B_factors))\n    return common_factors[-K]\n\nprint(find_num(A, B, K))"
}
2022-04-09 19:20:43.022639 REASON stop
