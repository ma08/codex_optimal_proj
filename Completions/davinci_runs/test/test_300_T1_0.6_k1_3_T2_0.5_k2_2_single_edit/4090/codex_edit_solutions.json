["from collections import defaultdict\n\n\ndef main():\n    n = int(input())\n    words = input().split()\n    d = defaultdict(int)\n    for i in range(n):\n        d[words[i]] += 1\n\n    d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    prev = -1\n    res = 0\n    for i in range(len(d)):\n        if d[i][1] != prev:\n            res += len(d[i][0])\n            prev = d[i][1]\n        else:\n            res += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "\nn = int(input())\nwords = input().split()\nwords = input().split()\nwords = input().split()\nwords = input().split()\nwords = input().split()\nwords = input().split()\n\n# Find all the words that are repeated in the list\nrepeats = set()\nfor word in words:\n    if words.count(word) > 1:\n        repeats.add(word)\n\n# Find the length of the text before abbreviation\nlength_before = len(\" \".join(words))\n\n# Find the length of the text after abbreviating the list\nlength_after = length_before\nfor repeat in repeats:\n    # Find all the indices of a word\n    indices = [i for i, word in enumerate(words) if word == repeat]\n    # Find the length of the text after abbreviating the first occurrence of the word\n    length_after = min(length_after, length_before - (len(repeat) - 1) * len(indices) + len(indices) - 1)\n    # Find the length of the text after abbreviating the second occurrence of the word\n    if len(indices) > 1:\n        length_after = min(length_after, length_before - (len(repeat) - 1) * (len(indices) - 1) + len(indices) - 2)\n\nprint(length_after)\n", "\ndef main():\n    n = int(input())\n    words = input().split()\n    d = {}\n    for i in range(n):\n        if words[i] in d:\n            d[words[i]] += 1\n        else:\n            d[words[i]] = 1\n\n    d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    prev = -1\n    res = 0\n    for i in range(len(d)):\n        if d[i][1] != prev:\n            res += len(d[i][0])\n            prev = d[i][1]\n        else:\n            res += 1\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\n# ======== SOLUTION =========\n\n# The task is to find the minimum length of the text after at most one abbreviation.\n# The first idea is to find the maximum number of words that we can abbreviate.\n# We do it in a greedy way.\n# We start from the beginning of the text.\n# The current word is the first word in the first segment that we want to abbreviate.\n# We go through the text and find all occurrences of the current word.\n# We take the maximum number of occurrences of the current word that do not intersect with each other.\n# We mark them and find the next word that is not marked, and again, we find the maximum number of occurrences of this word that do not intersect with each other.\n# We do this until we have no more unmarked words.\n# We abbreviate the marked words.\n# The length of the abbreviated text is equal to the length of the initial text minus the number of unmarked words.\n\n\ndef find_max_abbrev(words):\n    \"\"\"\n    Find the maximum number of words that we can abbreviate.\n    :param words: list of words\n    :return: list of positions of words that we should abbreviate\n    \"\"\"\n    positions = []\n    n = len(words)\n    marked = [False] * n\n\n    i = 0\n    while i < n:\n        while i < n and marked[i]:\n            i += 1\n        if i >= n:\n            break\n        word = words[i]\n        positions.append(i)\n\n        i += 1\n        while i < n:\n            while i < n and marked[i]:\n                i += 1\n            if i >= n:\n                break\n            if word != words[i]:\n                break\n            positions.append(i)\n            i += 1\n\n    return positions\n\n\ndef abbrev(words):\n    \"\"\"\n    Abbreviate the text.\n    :param words: list of words\n    :return: abbreviated text\n    \"\"\"\n    positions = find_max_abbrev(words)\n    len_words = len(words)\n\n    if len(positions) * 2 > len_words:\n        new_words = []\n        for i in range(len_words):\n            if i not in positions:\n                new_words.append(words[i])\n            elif i == positions[0]:\n                word = words[positions[0]]\n                new_words.append(word[0].upper() + word[1:])\n                del positions[0]\n        return new_words\n    else:\n        return words\n\n\nn = int(input())\nwords = input().split()\n\nprint(len(' '.join(abbrev(words))))\n", "\n\n# ======== SOLUTION ========\n\n# The task is to find the minimum length of the text after at most one abbreviation.\n# The first idea is to find the maximum number of words that we can abbreviate.\n# We do it in a greedy way.\n# We start from the beginning of the text.\n# The current word is the first word in the first segment that we want to abbreviate.\n# We go through the text and find all occurrences of the current word.\n# We take the maximum number of occurrences of the current word that do not intersect with each other.\n# We mark them and find the next word that is not marked,\n# and again, we find the maximum number of occurrences of this word that do not intersect with each other.\n# We do this until we have no more unmarked words.\n# We abbreviate the marked words.\n# The length of the abbreviated text is equal to the length of the initial text minus the number of unmarked words.\n\n\ndef find_max_abbrev(words):\n    \"\"\"\n    Find the maximum number of words that we can abbreviate.\n    :param words: list of words\n    :return: list of positions of words that we should abbreviate\n    \"\"\"\n    positions = []\n    n = len(words)\n    marked = [False] * n\n\n    i = 0\n    while i < n:\n        while i < n and marked[i]:\n            i += 1\n        if i >= n:\n            break\n        word = words[i]\n        positions.append(i)\n\n        i += 1\n        while i < n:\n            while i < n and marked[i]:\n                i += 1\n            if i >= n:\n                break\n            if word != words[i]:\n                break\n            positions.append(i)\n            i += 1\n\n    return positions\n\n\ndef abbrev(words):\n    \"\"\"\n    Abbreviate the text.\n    :param words: list of words\n    :return: abbreviated text\n    \"\"\"\n    positions = find_max_abbrev(words)\n    len_words = len(words)\n\n    if len(positions) * 2 > len_words:\n        new_words = []\n        for i in range(len_words):\n            if i not in positions:\n                new_words.append(words[i])\n            elif i == positions[0]:\n                word = words[positions[0]]\n                new_words.append(word[0].upper() + word[1:])\n                del positions[0]\n        return new_words\n    else:\n        return words\n\n\nn = int(input())\nwords = input().split()\n\nprint(len(' '.join(abbrev(words))))\n", "\nn = int(input())\nwords = input().split()\n\n# Find all the words that are repeated in the list\nrepeats = set()\nfor word in words:\n    if words.count(word) > 1:\n        repeats.add(word)\n\n# Find the length of the text before abbreviation\nlength_before = len(\" \".join(words))\n\n# Find the length of the text after abbreviating the list\nlength_after = length_before\nfor repeat in repeats:\n    # Find all the indices of a word\n    indices = [i for i, word in enumerate(words) if word == repeat]\n    # Find the length of the text after abbreviating the first occurrence of the word\n    length_after = min(length_after, length_before - (len(repeat) - 1) * len(indices) + len(indices) - 1)\n    # Find the length of the text after abbreviating the second occurrence of the word\n    if len(indices) > 1:\n        length_after = min(length_after, length_before - (len(repeat) - 1) * (len(indices) - 1) + len(indices) - 2)\n\nprint(length_after)\n"]