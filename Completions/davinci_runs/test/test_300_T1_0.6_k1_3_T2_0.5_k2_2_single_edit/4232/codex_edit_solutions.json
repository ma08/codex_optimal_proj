["\nfrom sys import stdin\n\n\ndef solve():\n    n, k = map(int, stdin.readline().split())\n    a = sorted(map(int, stdin.readline().split()))\n\n    print(a[k - 1] if k else -1)\n\n\nif __name__ == \"__main__\":\n    solve()\n", "from sys import stdin\nfrom bisect import bisect_left\nn, k = map(int, stdin.readline().split())\na = sorted(map(int, stdin.readline().split()))\n\nprint(a[k - 1] if k else -1)\n", "\n\ndef main():\n    n, k = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    if k == 0:\n        print(1)\n        return\n    if k == n:\n        print(l[-1])\n        return\n    if k-1 >= 0 and l[k-1] == l[k]:\n        print(-1)\n        return\n    print(l[k-1])\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python\n\nimport sys\nimport os\nimport re\nimport tempfile\nimport shutil\nimport subprocess\n\nimport argparse\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', '-f', type=str, help='file to be fixed')\n    parser.add_argument('--out', '-o', type=str, help='output file')\n    parser.add_argument('--replace', '-r', action='store_true', default=False, help='replace the file')\n    parser.add_argument('--no-backup', '-b', action='store_false', default=True, help='do not backup the file')\n    args = parser.parse_args()\n\n    if not os.path.isfile(args.file):\n        print('file does not exist')\n        return\n\n    if args.replace and not args.out:\n        args.out = args.file\n\n    tempdir = tempfile.mkdtemp()\n    tempfile = os.path.join(tempdir, os.path.basename(args.file))\n\n    subprocess.call(['vim', '-c', 'set fileformat=unix', '-c', 'wq', args.file])\n    subprocess.call(['vim', '-c', 'set fileformat=unix', '-c', 'wq', args.file])\n\n    subprocess.call(['vim', '-c', 'set fileformat=unix', '-c', 'wq', args.file])\n    subprocess.call(['vim', '-c', 'set fileformat=unix', '-c', 'wq', args.file])\n\n    subprocess.call(['vim', '-c', 'set fileformat=unix', '-c', 'wq', args.file])\n    subprocess.call(['vim', '-c', 'set fileformat=unix', '-c', 'wq', args.file])\n\n    if args.replace:\n        if args.no_backup:\n            shutil.copy(args.file, args.file + '.bak')\n        shutil.move(tempfile, args.out)\n    else:\n        print('new file: {}'.format(tempfile))\n\n    shutil.rmtree(tempdir)\n\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python\n\ndef main():\n    n, k = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    if k == 0:\n        print(1)\n        return\n    if k == n:\n        print(l[-1])\n        return\n    if l[k-1] == l[k]:\n        print(-1)\n        return\n    print(l[k-1])\n\nif __name__ == '__main__':\n    main()\n", "var fs = require('fs');\n\nfunction readFile(filename, callback) {\n    fs.readFile(filename, function(err, data) {\n        if (err) throw err;\n        callback(data.toString());\n    });\n}\n\nfunction writeFile(filename, data, callback) {\n    fs.writeFile(filename, data, function(err) {\n        if (err) throw err;\n        callback();\n    });\n}\n\nfunction readJSON(filename, callback) {\n    readFile(filename, function(data) {\n        callback(JSON.parse(data));\n    });\n}\n\nfunction writeJSON(filename, data, callback) {\n    writeFile(filename, JSON.stringify(data), callback);\n}\n\nmodule.exports = {\n    readFile: readFile,\n    writeFile: writeFile,\n    readJSON: readJSON,\n    writeJSON: writeJSON\n};\n"]