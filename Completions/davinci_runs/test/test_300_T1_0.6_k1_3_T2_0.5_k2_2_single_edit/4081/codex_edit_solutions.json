["\n\ndef main():\n    n = int(input())\n    nums = list(map(int, input().split(' ')))\n    ans = [0] * n\n    stack = []\n    for i in range(n):\n        while stack and nums[stack[-1]] < nums[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    for i in range(n - 1, -1, -1):\n        while stack and nums[stack[-1]] < nums[i]:\n            ans[stack.pop()] = i\n        stack.append(i)\n    max_ans = 0\n    for i in range(n):\n        max_ans = max(max_ans, ans[i] - i + 1)\n    print(max_ans)\n    for i in range(n):\n        if i == n - 1 or ans[i] < ans[i + 1]:\n            print('L', end='')\n        else:\n            print('R', end='')\n    print()\n\nmain()\n", "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # Get the reverse sorted indices for the array.\n    r_sorted_idx = sorted(range(len(a)), key=lambda k: a[k])\n    r_sorted_idx.reverse()\n\n    # For each index, find the longest increasing subsequence starting at that index.\n    # Keep track of the best subsequence and the corresponding indexes.\n    longest_sequence = 0\n    best_idx = 0\n\n    for i in range(n):\n        # Keep track of the last index visited in the sequence.\n        last_visited_idx = 0\n        # Keep track of the current length of the subsequence.\n        curr_len = 0\n        # keep track of the current index\n        curr_idx = i\n\n        while curr_idx < n:\n            # If the current index is greater than the last visited index, then\n            # this index can be added to the increasing subsequence\n            if r_sorted_idx[curr_idx] > last_visited_idx:\n                last_visited_idx = r_sorted_idx[curr_idx]\n                curr_len += 1\n            curr_idx += 1\n\n        # If the current subsequence is longer than the previous best, then\n        # update the best subsequence and the corresponding indexes\n        if curr_len > longest_sequence:\n            longest_sequence = curr_len\n            best_idx = i\n\n    # Print out the length of the longest subsequence\n    print(longest_sequence)\n\n    curr_idx = best_idx\n    while curr_idx < n:\n        # If the current index is greater than the last visited index, then\n        # this index can be added to the increasing subsequence\n        if r_sorted_idx[curr_idx] > last_visited_idx:\n            last_visited_idx = r_sorted_idx[curr_idx]\n            # if the index is the leftmost element, print L, else print R\n            if last_visited_idx == 0:\n                print('L', end='')\n            else:\n                print('R', end='')\n        curr_idx += 1\n\n\nmain()\n", "\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    # Get the reverse sorted indices for the array\n    r_sorted_idx = sorted(range(len(a)), key=lambda k: a[k])\n    r_sorted_idx.reverse()\n\n    # For each index, find the longest increasing subsequence starting at that index\n    # Keep track of the best subsequence and the corresponding indexes\n    longest_sequence = 0\n    best_idx = 0\n\n    for i in range(n):\n        # keep track of the last index visited in the sequence\n        last_visited_idx = 0\n        # keep track of the current length of the subsequence\n        curr_len = 0\n        # keep track of the current index\n        curr_idx = i\n\n        while curr_idx < n:\n            # If the current index is greater than the last visited index, then\n            # this index can be added to the increasing subsequence\n            if r_sorted_idx[curr_idx] > last_visited_idx:\n                last_visited_idx = r_sorted_idx[curr_idx]\n                curr_len += 1\n            curr_idx += 1\n\n        # If the current subsequence is longer than the previous best, then\n        # update the best subsequence and the corresponding indexes\n        if curr_len > longest_sequence:\n            longest_sequence = curr_len\n            best_idx = i\n\n    # Print out the length of the longest subsequence\n    print(longest_sequence)\n\n    curr_idx = best_idx\n    while curr_idx < n:\n        # If the current index is greater than the last visited index, then\n        # this index can be added to the increasing subsequence\n\n    last_visited_idx = 0\n        if r_sorted_idx[curr_idx] > last_visited_idx:\n            last_visited_idx = r_sorted_idx[curr_idx]\n            # if the index is the leftmost element, print L, else print R\n            if last_visited_idx == 0:\n                print('L', end='')\n            else:\n                print('R', end='')\n        curr_idx += 1\n\n\nmain()\n", "\n\ndef main():\n    print(1)\n\nmain()\n", "\nn = int(input())\na = [int(x) for x in input().split()]\n\n# In the optimal solution the sequence must be strictly increasing.\n# We can find the longest strictly increasing subsequence in linear time.\n# (See https://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms)\n#\n# The optimal solution then consists of the longest strictly increasing subsequence\n# followed by the remaining elements from the original sequence.\n\n# Find the longest increasing subsequence.\n# We use a list to store the indices of the sequence.\n# The indices are sorted according to the corresponding elements in the sequence.\n# The last element of the list is the smallest element of the longest increasing subsequence.\n# If a new element is larger than the last element in the list, we append it to the list.\n# Otherwise, we replace the smallest element that is larger than the new element with the new element.\n# This way the list always represents the longest increasing subsequence.\nlis = []\nfor i in range(n):\n    if lis == []:\n        lis.append(i)\n    elif a[i] > a[lis[-1]]:\n        lis.append(i)\n    else:\n        for j in range(len(lis)):\n            if a[lis[j]] > a[i]:\n                lis[j] = i\n                break\n\n# Construct the solution from the longest increasing subsequence.\ns = ['L' for _ in range(len(lis))]\nleft = [0] * n\nfor i in range(len(lis)):\n    left[lis[i]] = 1\n    if i > 0:\n        left[lis[i]] += left[lis[i-1]]\n\nfor i in range(len(lis)):\n    if i == len(lis) - 1 or left[lis[i]] < left[lis[i+1]]:\n        s[i] = 'R'\n\n# Print the answer.\nprint(len(lis))\nprint(''.join(s))\n"]