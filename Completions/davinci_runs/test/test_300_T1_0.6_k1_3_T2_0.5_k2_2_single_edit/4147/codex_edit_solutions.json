["\n\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort()\n    bamboos.reverse()\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if A in bamboos:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for b in bamboos:\n        # if b is shorter than A - B\n        if b < A - B:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if b < A - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if b < A:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if B in bamboos:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for b in bamboos:\n        # if b is shorter than B - C\n        if b < B - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if b < B:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if C in bamboos:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for b in bamboos:\n        # if b is shorter than C\n        if b < C:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, [input() for i in range(N)]))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\nif __name__ == '__main__':\n    main()\n", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\n\n# dp[i][j][k] = min(mp) to obtain bamboos with lengths of a, b, c from l[0:i]\n# dp[i][j][k] = min(dp[i-1][j][k], dp[i-1][j-1][k-1] + 10, dp[i-1][j-1][k] + 1, dp[i-1][j-1][k] + 1)\ndp = [[[float(\"inf\") for _ in range(n+1)] for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0][0] = 0 \nfor i in range(n):\n    for j in range(i+1):\n        for k in range(j+1):\n            if l[i] == a and j == 0: \n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k])\n            if l[i] == b and k == 0: \n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if l[i] == c and k == j: \n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if j > 0 and k > 0 and l[i] + a <= 1000: \n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + b <= 1000: \n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + c <= 1000: \n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j-1][k-1]+10)\n            if j > 0 and l[i] + 1 <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k]+1)\n            if j > 0 and l[i] - 1 >= 1:\n                dp[i+1][j][k] = min(dp[i+1][j][k], dp[i][j][k]+1)\n\nprint(dp[n][1][1])\n", "\n\nn, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\n\n# dp[i][j][k] = min(mp) to obtain bamboos with lengths of a, b, c from l[0:i]\n# dp[i][j][k] = min(dp[i-1][j][k], dp[i-1][j-1][k-1] + 10, dp[i-1][j-1][k] + 1, dp[i-1][j][k-1] + 1)\ndp = [[[float(\"inf\") for _ in range(n+1)] for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0][0] = 0\nfor i in range(n):\n    for j in range(i+1):\n        for k in range(j+1):\n            if l[i] == a and j == 0:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k])\n            if l[i] == b and k == 0:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if l[i] == c and k == j:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k])\n            if j > 0 and k > 0 and l[i] + a <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + b <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j-1][k-1]+10)\n            if j > 0 and k > 0 and l[i] + c <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j-1][k-1]+10)\n            if j > 0 and l[i] + 1 <= 1000:\n                dp[i+1][j+1][k] = min(dp[i+1][j+1][k], dp[i][j][k]+1)\n            if j > 0 and l[i] - 1 >= 1:\n                dp[i+1][j][k+1] = min(dp[i+1][j][k+1], dp[i][j][k]+1)\n\nprint(dp[n][1][1])\n", "\nimport sys\n\n# Read the input\nN, A, B, C = map(int, sys.stdin.readline().split())\nl = [int(sys.stdin.readline()) for i in range(N)]\n\n# dp[n][a][b][c] is the minimum amount of MP needed to obtain three bamboos of lengths a, b, c from n bamboos\ndp = [[[[float(\"inf\") for i in range(C+1)] for j in range(B+1)] for k in range(A+1)] for l in range(N+1)]\ndp[0][0][0][0] = 0\n\nfor i in range(N):\n    for a in range(A+1):\n        for b in range(B+1):\n            for c in range(C+1):\n                # Do nothing\n                dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c])\n                # Extend a bamboo\n                if a >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a-l[i]][b][c] + 1)\n                if b >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b-l[i]][c] + 1)\n                if c >= l[i]:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c-l[i]] + 1)\n                # Shorten a bamboo\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 1)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 1)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 1)\n                # Combine two bamboos\n                if a + l[i] <= A:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a+l[i]][b][c] + 10)\n                if b + l[i] <= B:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b+l[i]][c] + 10)\n                if c + l[i] <= C:\n                    dp[i+1][a][b][c] = min(dp[i+1][a][b][c], dp[i][a][b][c+l[i]] + 10)\n\n# Print the answer\nprint(dp[N][A][B][C])\n", "\n\ndef bamboo_magic(A, B, C, bamboos):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type bamboos: list\n    :rtype: int\n    \"\"\"\n    # initialization\n    bamboos.sort()\n    bamboos.reverse()\n    magic_points = 0\n    # check if there is a bamboo of length A\n    if bamboos.count(A) > 0:\n        # remove it to get the bamboos that are shorter than A\n        bamboos.remove(A) # O(N)\n    # for each bamboo of length b in bamboos that's shorter than A\n    for b in bamboos:\n        # if b is shorter than A - B\n        if b < A - B:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A - C\n        if b < A - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than A\n        if b < A:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length B\n    if bamboos.count(B) > 0:\n        # remove it to get the bamboos that are shorter than B\n        bamboos.remove(B)\n    # for each bamboo of length b in bamboos that's shorter than B\n    for b in bamboos:\n        # if b is shorter than B - C\n        if b < B - C:\n            # decrease its length by 1\n            b -= 1\n            # increase the magic point\n            magic_points += 1\n        # if b is shorter than B\n        if b < B:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # check if there is a bamboo of length C\n    if bamboos.count(C) > 0:\n        # remove it to get the bamboos that are shorter than C\n        bamboos.remove(C)\n    # for each bamboo of length b in bamboos that's shorter than C\n    for b in bamboos:\n        # if b is shorter than C\n        if b < C:\n            # increase its length by 1\n            b += 1\n            # increase the magic point\n            magic_points += 1\n    # return the magic point\n    return magic_points\n\ndef main():\n    \"\"\"\n    :rtype: None\n    \"\"\"\n    # read the inputs\n    N, A, B, C = map(int, input().split())\n    bamboos = list(map(int, [input() for i in range(N)]))\n    # print the minimum amount of MP needed\n    print(bamboo_magic(A, B, C, bamboos))\n\nif __name__ == '__main__':\n    main()\n"]