["N,A,B,C = map(int,input().split())\nl = [int(input()) for _ in range(N)]\nans = float(\"inf\")\nfor i in range(4**N):\n    a,b,c = [],[],[]\n    cost = 0\n    for j in range(N):\n        r = (i//(4**j)) % 4\n        if r == 1:\n            a.append(l[j])\n        elif r == 2:\n            b.append(l[j])\n        elif r == 3:\n            c.append(l[j])\n    if a and b and c:\n        cost += sum(max((len(x)-1), 0)*10 for x in [a,b,c])\n        a = sum(a)\n        b = sum(b)\n        c = sum(c)\n        cost += sum(abs(x-y) for x,y in [(a,A),(b,B),(c,C)])\n        ans = min(ans, cost)\nprint(ans)", "from itertools import product\n\nN,A,B,C=map(int,input().split())\nl = [int(input()) for _ in range(N)]\n\nminscore=10**9\nfor p in product(range(-1,3),repeat=N):\n  flag=0\n  score = 0\n  n_abc=[0,0,0]\n  sumlen = [0,0,0]\n  for i in range(N):\n    if p[i] != -1:\n      n_abc[p[i]] += 1\n      sumlen[p[i]] += l[i]\n  for j in range(3):\n    if n_abc[j] == 0:\n      flag=1\n      break\n    score += (n_abc[j]-1)*10 + abs(sumlen[j]-[A,B,C][j])\n    \n  if flag:\n    continue\n    \n  if score < minscore:\n    minscore = score\n    \nprint(minscore)", "n,a,b,c = map(int, input().split())\n\nl = [int(input()) for i in range(n)]\n\nimport itertools\n\nbumboo=[\"A\",\"B\",\"C\",\"D\"]\n\nprod = list(itertools.product(bumboo,repeat=n))\n\ntemp = []\n\nfor i in prod:\n    tempa = 0\n    tempb = 0\n    tempc = 0\n    for j in range(n):\n        if i[j] ==\"A\":\n            tempa += l[j]\n        elif i[j] ==\"B\":\n            tempb += l[j]\n        elif i[j] ==\"C\":\n            tempc += l[j]\n    if tempa*tempb*tempc == 0:\n        pass\n    else:\n        temp.append(abs(tempa-a)+abs(tempb-b)+abs(tempc-c)+10*(n-3-i.count(\"D\")))\nprint(min(temp))", "N, A, B, C = map(int, input().split())\nL_list = [int(input()) for i in range(N)]\n\nINF = 10 ** 9\n\ndef dfs(a, b, c, n):\n    if n == N:\n        return abs(A - a) + abs(B - b) + abs(C - c) - 30 if min(a, b, c) > 0 else INF\n\n    ret1 = dfs(a, b, c, n + 1)\n    ret2 = dfs(a + L_list[n], b, c, n + 1) + 10\n    ret3 = dfs(a, b + L_list[n], c, n + 1) + 10\n    ret4 = dfs(a, b, c + L_list[n], n + 1) + 10\n    return min(ret1, ret2, ret3, ret4)\n\n\nans = dfs(0, 0, 0, 0)\nprint(ans)\n'''\n8 100 90 80\n100\n100\n90\n90\n90\n80\n80\n80\n\n0\n\n\n8 1000 800 100\n300\n333\n400\n444\n500\n555\n600\n666\n\n243\n\n'''", "def main():\n    n, *target = list(map(int, input().split()))\n    l = [int(input()) for _ in range(n)]\n    ans = float(\"inf\")\n    base = 4\n    for i in range(pow(base, n)):\n        now_l = [0] * base\n        add = [0] * base\n        now = i\n        for j in range(n):\n            now_l[now % base] += l[j]\n            add[now % base] += 1\n            now //= base\n        if 0 in now_l[:base - 1]:\n            continue\n        now_ans = sum([abs(target[i] - now_l[i]) for i in range(3)]) + (sum(add[:3]) - 3) * 10\n        ans = min(ans, now_ans)\n    print((0 if all(t in l for t in target) else ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from itertools import product\n\nN, A, B, C = list(map(int, input().split(' ')))\nL = [int(input()) for _ in range(N)]\n\nans = 10 ** 9\nfor groups in product(list(range(4)), repeat=N):\n    length_a = 0\n    length_b = 0\n    length_c = 0\n    cost_a = -10\n    cost_b = -10\n    cost_c = -10\n\n    for group, length in zip(groups, L):\n        if group == 1:\n            length_a += length\n            cost_a += 10\n        elif group == 2:\n            length_b += length\n            cost_b += 10\n        elif group == 3:\n            length_c += length\n            cost_c += 10\n\n    if 0 in {length_a, length_b, length_c}:\n        continue\n\n    ans = min(ans, sum([\n        abs(A - length_a),\n        abs(B - length_b),\n        abs(C - length_c),\n        cost_a,\n        cost_b,\n        cost_c,\n    ]))\n\nprint(ans)\n", "import sys\nfrom itertools import product\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, *A = list(map(int, readline().split()))\n    (*L,) = list(map(int, read().split()))\n\n    ans = INF\n    for p in product(list(range(4)), repeat=N):\n        num = [0] * 3\n        length = [0] * 3\n        for i, j in enumerate(p):\n            if j < 3:\n                num[j] += 1\n                length[j] += L[i]\n        res = 0\n        for j in range(3):\n            if num[j] == 0:\n                res = INF\n                break\n            else:\n                res += (num[j] - 1) * 10 + abs(length[j] - A[j])\n        if ans > res:\n            ans = res\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nN, A, B, C = map(int, input().split())\nL = [int(input()) for i in range(N)]\nINF = float('inf')\n\ndef dfs(i, a, b, c):\n    if i == N:\n        if a == 0 or b == 0 or c == 0:\n            return INF\n        else:\n            return abs(a-A) + abs(b-B) + abs(c-C)\n    ans0 = dfs(i+1, a, b, c)\n\n    ans1 = dfs(i+1, a+L[i], b, c) + (10 if a != 0 else 0)\n    ans2 = dfs(i+1, a, b+L[i], c) + (10 if b != 0 else 0)\n    ans3 = dfs(i+1, a, b, c+L[i]) + (10 if c != 0 else 0)\n\n    return min(ans0, ans1, ans2, ans3)\n\ndef main():\n    print(dfs(0, 0, 0, 0))\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import product\n\n\ndef solve():\n    N, A, B, C, *L = list(map(int, open(0).read().split()))\n\n    ans = float(\"inf\")\n    for X in product([0, 1, 2, 3], repeat=N):\n        tmp = [[] for _ in range(3)]\n        [tmp[x - 1].append(L[i]) for i, x in enumerate(X) if x]\n        if any(not t for t in tmp):\n            continue\n        join_cost = sum((len(li) - 1) * 10 for li in tmp)\n        expand_cost = sum(abs(sum(t) - a) for t, a in zip(tmp, [A, B, C]))\n        ans = min(ans, join_cost + expand_cost)\n    return ans\n\n\nprint((solve()))\n", "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return list(map(int, sys.stdin.readline().split()))\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from collections import Counter # a = Counter(A).most_common()\n#from itertools import accumulate #list(accumulate(A))\nimport itertools\n\nN, *A = mi()\nL = [ii() for _ in range(N)]\n\n#A = sorted(A)\nsum_a = sum(A)\n\ndef dfs(i, a, b, c, use):\n    if (0 not in [a, b, c]) and use > 2:\n        nonlocal ans\n        #abc = sorted([a, b, c])\n        #ans = min(ans, (use-3)*10 + sum([abs(abc[i]-A[i]) for i in range(3)]))\n        ans = min(ans, (use-3)*10 + abs(a-A[0]) + abs(b-A[1]) + abs(c-A[2]))\n\n    if i > N-1:\n        return\n\n    dfs(i+1, a+L[i], b, c, use+1)\n    dfs(i+1, a, b+L[i], c, use+1)\n    dfs(i+1, a, b, c+L[i], use+1)\n    dfs(i+1, a, b, c, use)\n\nans = float('inf')\ndfs(0, 0, 0, 0, 0)\n\nprint(ans)\n\n", "import sys\ninput = lambda: sys.stdin.readline().rstrip()\ninput_nums = lambda: list(map(int, input().split()))\nINF = 10**9\n\ndef main():\n    N, A, B, C = input_nums()\n    ll = [int(input()) for _ in range(N)]\n\n    def dfs(idx, a, b, c):\n        if idx == N:\n            # a,b,c\u305d\u308c\u305e\u308c\u6700\u4f4e1\u672c\u306f\u5fc5\u8981\u3067\u5408\u6210\u3092\u3057\u3066\u3044\u308b\u305f\u3081\u3001-30\u304c\u5fc5\u8981\n            return abs(a-A)+abs(b-B)+abs(c-C) - 30 if min(a, b, c) > 0 else INF\n        ret0 = dfs(idx+1, a, b, c)\n        ret1 = dfs(idx+1, a+ll[idx], b, c) + 10\n        ret2 = dfs(idx+1, a, b+ll[idx], c) + 10\n        ret3 = dfs(idx+1, a, b, c+ll[idx]) + 10\n        return min(ret0, ret1, ret2, ret3)\n\n    print(dfs(0,0,0,0))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,a,b,c=list(map(int,input().split()))\nl=[]\nfor i in range(n):\n    l.append(int(input()))\nans=100000\nfor i in range(4**n):\n    mp=0\n    f=0\n    x=[]\n    y=[]\n    z=[]\n    w=[]\n    for j in range(n):\n        if i%4==0:\n            x.append(l[j])\n        elif i%4==1:\n            y.append(l[j])\n        elif i%4==2:\n            z.append(l[j])\n        else:\n            w.append(l[j])\n        i=i//4\n    if sum(x)==0 or sum(y)==0 or sum(z)==0:\n        f=1\n    \n    X=sum(x)\n    Y=sum(y)\n    Z=sum(z)\n    mp+=(len(x)+len(y)+len(z)-3)*10\n    p=[X,Y,Z]\n    q=[a,b,c]\n    p=sorted(p)\n    q=sorted(q)\n    mp+=abs(p[0]-q[0])+abs(p[1]-q[1])+abs(p[2]-q[2])\n    if f!=1:     \n        ans=(min(mp,ans))\nprint(ans)\n    \n        \n\n    \n        \n        \n    \n", "import itertools\n\nn, *abc = map(int, input().split())\nllst = [int(input()) for _ in range(n)]\n\nans = 10 ** 10\nfor abc_lst in itertools.product(range(4), repeat = n):\n    tmp = 0\n    labc = [[0, 0] for _ in range(3)]\n    for i in range(n):\n        pos = abc_lst[i]\n        if pos == 3:\n            continue\n        labc[pos][0] += llst[i]\n        labc[pos][1] += 1\n    if [0, 0] in labc:\n        continue\n    for i in range(3):\n        tmp += abs(abc[i] - labc[i][0])\n        tmp += 10 * (labc[i][1] - 1)\n    ans = min(ans, tmp)\nprint(ans)", "n,a,b,c = map(int, input().split())\nl = [int(input()) for i in range(n)]\n\ndef check(t):\n  ca = t.count('a')\n  cb = t.count('b')\n  cc = t.count('c')\n  if ca == 0 or cb == 0 or cc == 0:\n    return False\n  return True\n\ndef calc(t):\n  A,B,C=0,0,0\n  d = (t.count('a')-1+ t.count('b')-1+t.count('c')-1)*10\n  for i,j in enumerate(t):\n    if j == 'a':\n      A+=l[i]\n    elif j == 'b':\n      B+=l[i]\n    elif j == 'c':\n      C+=l[i]\n  d += abs(A-a)+abs(B-b)+abs(C-c)\n  return d\n\nary=['a','b','c','d']\ntake = []\ndef dfs(s):\n  if len(s) == n:\n    if check(s):\n      take.append(calc(s))\n    return\n  for i in range(4):\n    dfs(s+ary[i])\n\n\ndfs('')\n\nprint (min(take))", "import sys\nfrom functools import lru_cache\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, A, B, C = list(map(int, readline().split()))\n    (*L,) = list(map(int, read().split()))\n\n    @lru_cache(maxsize=None)\n    def rec(i, a, b, c):\n        if i == N:\n            return abs(a - A) + abs(b - B) + abs(c - C) - 30 if min(a, b, c) > 0 else INF\n\n        res0 = rec(i + 1, a, b, c)\n        res1 = rec(i + 1, a + L[i], b, c) + 10\n        res2 = rec(i + 1, a, b + L[i], c) + 10\n        res3 = rec(i + 1, a, b, c + L[i]) + 10\n\n        return min(res0, res1, res2, res3)\n\n    print((rec(0, 0, 0, 0)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,A,B,C=map(int,input().split())\nQ=[int(input()) for ii in range(n)]\ninf=10**15\ndef dfs(now,a,b,c):\n    if now==n:\n        return abs(a-A)+abs(b-B)+abs(c-C) if 0 not in [a,b,c] else inf\n    q1= dfs(now+1,a,b,c)\n    q2= dfs(now+1, a+Q[now],b,c)+10\n    q3= dfs(now+1, a, b+Q[now], c)+10\n    q4 = dfs(now+1,a,b,c+Q[now])+10\n    return min(q1,q2,q3,q4)\n\nprint(dfs(0,0,0,0)-30)", "N,A,B,C = list(map(int,input().split()))\nl = []\nfor i in range(N):\n    l.append(int(input()))\n\nchoiceList = []\nfor i in range(4 ** N):\n    choice = [-1 for i in range(N)]\n    for j in range (N):\n        choice[j] = i // (4 ** j) % 4\n    choiceList.append(choice)\n\nminCost = 10 ** 9\nfor choice in choiceList:\n    cost = 10 ** 9\n    aList = []\n    bList = []\n    cList = []\n    for i in range(N):\n        if choice[i] == 1:\n            aList.append(l[i])\n        elif choice[i] == 2:\n            bList.append(l[i])\n        elif choice[i] == 3:\n            cList.append(l[i])\n    if len(aList) == 0 or len(bList) == 0 or len(cList) == 0:\n        cost = 10 ** 9\n    else:\n        aCost = (len(aList) - 1) * 10 + abs(sum(aList) - A)\n        bCost = (len(bList) - 1) * 10 + abs(sum(bList) - B)\n        cCost = (len(cList) - 1) * 10 + abs(sum(cList) - C)\n        cost = aCost + bCost + cCost\n    if minCost > cost:\n        minCost = cost\n\nprint(minCost)", "N,A,B,C = map(int,input().split())\nL = [int(input()) for i in range(N)]\n\nans = float('inf')\nfor a in range(1<<N):\n    at = []\n    for i in range(N):\n        if a&(1<<i):\n            at.append(L[i])\n    if not at: continue\n    ap = 10*(len(at)-1) + abs(A - sum(at))\n    for b in range(1<<N):\n        if a&b: continue\n        bt = []\n        for i in range(N):\n            if b&(1<<i):\n                bt.append(L[i])\n        if not bt: continue\n        bp = 10*(len(bt)-1) + abs(B - sum(bt))\n        for c in range(1<<N):\n            if (a&c) or (b&c): continue\n            ct = []\n            for i in range(N):\n                if c&(1<<i):\n                    ct.append(L[i])\n            if not ct: continue\n            cp = 10*(len(ct)-1) + abs(C - sum(ct))\n            ans = min(ans, ap+bp+cp)\nprint(ans)", "import sys\nfrom itertools import product\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, A, B, C = list(map(int, input().split()))\n    L = [0] * N\n    for i in range(N):\n        L[i] = int(input())\n\n    ans = float(\"inf\")\n    for comb in product(list(range(4)), repeat=N):\n        mp = -30\n        a = b = c = 0\n        for i, j in enumerate(comb):\n            if j == 0:\n                continue\n            elif j == 1:\n                a += L[i]\n            elif j == 2:\n                b += L[i]\n            elif j == 3:\n                c += L[i]\n            mp += 10\n\n        if min(a, b, c) == 0:\n            continue\n\n        mp += abs(A - a) + abs(B - b) + abs(C - c)\n        if mp < ans:\n            ans = mp\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N, A, B, C = map(int, input().split())\nl = [int(input()) for _ in range(N)]\n\nINF = float('inf')\n\ndef dfs(cur, a, b, c):\n    if cur == N:\n        if min(a, b, c) > 0:\n            return abs(a -A) + abs(b - B) + abs(c - C) - 30\n        else:\n            return INF\n\n    ret0 = dfs(cur + 1, a, b, c)\n    ret1 = dfs(cur + 1, a + l[cur], b, c) + 10\n    ret2 = dfs(cur + 1, a, b + l[cur], c) + 10\n    ret3 = dfs(cur + 1, a, b, c + l[cur]) + 10\n    return min(ret0, ret1, ret2, ret3)\n\nprint(dfs(0, 0, 0, 0))", "import sys\nsys.setrecursionlimit(10**6)\nn, A, B, C =map(int,input().split())\nl=[]\nfor i in range(n):\n    l.append(int(input()))\ninf=10**9\n\"\"\"\n\u89e3\u6cd5\n\u305d\u308c\u305e\u308c\u306e\u7af9\u306b\u3064\u3044\u3066\u300cA\u306e\u6750\u6599\u300d\u3001\u300cB\u306e\u6750\u6599\u300d\u3001\u300cC\u306e\u6750\u6599\u300d\u3001\u300c\u4f7f\u308f\u306a\u3044\u300d\u306e4\u629e\u3092\u6c7a\u3081\u308b(4**n\u901a\u308a)\n\"\"\"\ndef dfs(cur, a, b, c):\n    if cur==n:\n        return abs(a-A)+abs(b-B)+abs(c-C)-30 if min(a,b,c)>0 else inf\n    \n    ret0=dfs(cur+1,a,b,c)\n    ret1=dfs(cur+1,a+l[cur],b,c)+10\n    ret2=dfs(cur+1,a,b+l[cur],c)+10\n    ret3=dfs(cur+1,a,b,c+l[cur])+10\n    return min(ret0, ret1, ret2, ret3)\n\nprint(dfs(0,0,0,0))", "n,a,b,c=map(int,input().split())\nl=[int(input())for _ in range(n)]\ndef dfs(i,x,y,z):\n if i==n:return abs(a-x)+abs(b-y)+abs(c-z)-30if min(x,y,z)>0else 10**9\n return min(dfs(i+1,x,y,z),dfs(i+1,x+l[i],y,z)+10,dfs(i+1,x,y+l[i],z)+10,dfs(i+1,x,y,z+l[i])+10)\nprint(dfs(0,0,0,0))", "N, A, B, C = map(int, input().split())\nL = []\nfor _ in range(N):\n  L.append(int(input()))\n\ndef rec(i, a, b, c):\n  if i == N:\n    if not a or not b or not c: return float('inf')\n    return abs(a-A) + abs(b-B) + abs(c-C)\n  \n  ret = rec(i+1, a, b, c)\n  \n  ret = min(ret, rec(i+1, a+L[i], b, c) + (10 if a else 0))\n  ret = min(ret, rec(i+1, a, b+L[i], c) + (10 if b else 0))\n  ret = min(ret, rec(i+1, a, b, c+L[i]) + (10 if c else 0))\n  \n  return ret\n\nprint(rec(0, 0, 0, 0))", "from itertools import product\n\n\ndef solve():\n    N, A, B, C, *L = list(map(int, open(0).read().split()))\n\n    ans = float(\"inf\")\n    for X in product([0, 1], repeat=N):\n        tmp = [L[i] for i in range(N) if X[i]]\n        if len(tmp) < 3:\n            continue\n        for Y in product([0, 1, 2], repeat=len(tmp)):\n            tmp_inner = [[] for _ in range(3)]\n            for j, y in enumerate(Y):\n                tmp_inner[y].append(tmp[j])\n            if all(t for t in tmp_inner):\n                join_cost = sum((len(li) - 1) * 10 for li in tmp_inner)\n                expand_cost = sum(abs(sum(t) - a) for t, a in zip(tmp_inner, [A, B, C]))\n                ans = min(ans, join_cost + expand_cost)\n    return ans\n\n\nprint((solve()))\n", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\n# def main():\n  \n\n# # main()\n# print(main())\n\nn,a,b,c=LI()\nl=[I() for _ in range(n)]\nanswer=inf\n\ndef f(lst,ind):\n  nonlocal answer\n  if ind==n:\n    ac=lst.count(1)\n    bc=lst.count(2)\n    cc=lst.count(3)\n\n    if ac==0 or bc==0 or cc==0:\n      return min(answer,inf)\n\n    _a=_b=_c=0\n    for i,x in enumerate(lst):\n      if x==1:\n        _a+=l[i]\n      elif x==2:\n        _b+=l[i]\n      elif x==3:\n        _c+=l[i]\n    # \u5408\u308f\u306a\u304b\u3063\u305f\u539f\u56e0\u3002\u77ed\u7e2e\u3067\u304d\u308b\u3053\u3068\u3092\u5fd8\u308c\u3066\u305f\n    # if _a>a or _b>b or _c>c:\n    #   return min(answer,inf)\n\n    sm=0\n    sm+=max(0,ac-1)*10\n    sm+=max(0,bc-1)*10\n    sm+=max(0,cc-1)*10\n    sm+=abs(a-_a)\n    sm+=abs(b-_b)\n    sm+=abs(c-_c)\n\n    return min(answer,sm)\n\n  else:\n    for i in range(4):\n      lst[ind]=i\n      answer=min(answer,f(lst,ind+1))\n\n  return answer\n\nlst=[-1]*n\nprint((f(lst,0)))\n", "from itertools import product\nn, a, b, c = list(map(int, input().split()))\nL = [int(input())for _ in range(n)]\n\nINF = 10**18\nans = INF\nfor subset in product(list(range(4)), repeat=n):\n    cost = 0\n    ABC = [[]for _ in range(3)]\n    for i, s in enumerate(subset):\n        if not s:\n            continue\n        ABC[s-1].append(L[i])\n    if any(not X for X in ABC):\n        continue\n    for x, X in zip((a, b, c), ABC):\n        cost += (len(X)-1)*10\n        cost += abs(x-sum(X))\n    if cost < ans:\n        ans = cost\n\nprint(ans)\n", "def dfs(ka, kb, kc, cnta, cntb, cntc, phase):\n    nonlocal ans\n    if phase == n:\n        if 0 < cnta and 0 < cntb and 0 < cntc:\n            ans = min(ans, abs(a-ka) + abs(b-kb) + abs(c-kc) + 10*(cnta+cntb+cntc-3))\n        return\n    dfs(ka+l[phase], kb, kc, cnta+1, cntb, cntc, phase+1)\n    dfs(ka, kb+l[phase], kc, cnta, cntb+1, cntc, phase+1)\n    dfs(ka, kb, kc+l[phase], cnta, cntb, cntc+1, phase+1)\n    dfs(ka, kb, kc, cnta, cntb, cntc, phase+1)\n\n\nn,a,b,c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\nans = 10**9\ndfs(0,0,0,0,0,0,0)\nprint(ans)", "N,A,B,C = map(int,input().split())\n\nL = [int(input()) for i in range(N)]\n\n# L\u672c\u306e\u7af9\u3092\u3001A,B,C,0(\u4f7f\u308f\u306a\u3044)\u306b\u632f\u308a\u5206\u3051\u308b\u5168\u63a2\u7d22 4^N = \u7d0460000\u901a\u308a\n\nans = 10 ** 10\nimport itertools\nfor prod in itertools.product(range(4), repeat = N):\n  bamboo = [0] * 4\n  mp = 0\n  for i in range(len(prod)):\n    if prod[i] == 0:\n      continue\n    if bamboo[prod[i]] != 0:\n      mp += 10\n    bamboo[prod[i]] += L[i]\n  if 0 in bamboo[1:]:\n    continue\n  mp += abs(A - bamboo[1]) + abs(B - bamboo[2]) + abs(C - bamboo[3])\n  if ans > mp:\n    ans = mp\n    \nprint(ans)", "import sys\nfrom itertools import product\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    n, A, B, C = list(map(int, input().split()))\n    goal = [A, B, C]\n    L = list(int(input()) for _ in range(n))\n\n    res = f_inf\n    for pattern in product([0, 1, 2, 3], repeat=n):\n        cnt = [0] * 3\n        length = [0] * 3\n        for idx, p in enumerate(pattern):\n            if p != 0:\n                length[p - 1] += L[idx]\n                cnt[p - 1] += 1\n        mp = 0\n        for i in range(3):\n            if cnt[i] == 0:\n                break\n            mp += abs(goal[i] - length[i]) + (cnt[i] - 1) * 10\n        else:\n            res = min(res, mp)\n    print(res)\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "from itertools import product\nN,A,B,C=map(int,input().split())\nl=[]\nfor _ in range(N):\n    l.append(int(input()))\nans=10**18\nfor i in product(range(4),repeat=N):\n    mp=0\n    bamboo=[0,0,0]\n    for j in range(N):\n        s=i[j]\n        if s==3:\n            continue\n        else:\n            if bamboo[s]!=0:\n                mp+=10\n            bamboo[s]+=l[j]\n    if bamboo[0]==0 or bamboo[1]==0 or bamboo[2]==0:\n        continue\n    mp+=abs(A-bamboo[0])\n    mp+=abs(B-bamboo[1])\n    mp+=abs(C-bamboo[2])\n    ans=min(ans,mp)\nprint(ans)", "import sys\nfrom itertools import product\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N, A, B, C = list(map(int, readline().split()))\n    (*L,) = list(map(int, read().split()))\n\n    def rec(i, a, b, c):\n        if i == N:\n            return abs(a - A) + abs(b - B) + abs(c - C) - 30 if min(a, b, c) > 0 else INF\n\n        res0 = rec(i + 1, a, b, c)\n        res1 = rec(i + 1, a + L[i], b, c) + 10\n        res2 = rec(i + 1, a, b + L[i], c) + 10\n        res3 = rec(i + 1, a, b, c + L[i]) + 10\n\n        return min(res0, res1, res2, res3)\n\n    print((rec(0, 0, 0, 0)))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\nN, A, B, C = map(int, input().split())\nL = [int(input()) for i in range(N)]\nINF = float('inf')\ndef dfs(i,a,b,c):\n    # \u3055\u3044\u3054\u307e\u3067\u5230\u9054\u3057\u305f\u3068\u304d\u306e\u64cd\u4f5c  \n    if i == N:\n        if a==0 or b==0 or c==0:\n            return INF\n        else:\n            return abs(a-A) + abs(b-B) + abs(c-C)\n    # \u3059\u3079\u3066\u306e\u624b\u9806\n    ans0 = dfs(i+1, a, b, c)\n    ans1 = dfs(i+1, a+L[i], b, c) + (10 if a != 0 else 0)\n    ans2 = dfs(i+1, a, b+L[i], c) + (10 if b != 0 else 0)\n    ans3 = dfs(i+1, a, b, c+L[i]) + (10 if c != 0 else 0)\n    \n    ans = min(ans0, ans1, ans2, ans3)\n    return ans\n\ndef main():\n    print(dfs(0,0,0,0))\n\ndef __starting_point():\n    main()\n__starting_point()", "from itertools import product\nN, A, B, C = map(int, input().split())\nabc = [C, B, A]\nlst = [int(input()) for _ in range(N)]\n\nans = []\nfor l in product([0, 1, 2, 3], repeat=N):\n    cnt = [[], [], [], []]\n    for i, ll in enumerate(l):\n        cnt[ll].append(lst[i])\n    mp = 0\n    p = []\n    for i in cnt[:3]:\n        if len(i) != 0: mp += (len(i) - 1) * 10\n        p.append(sum(i))\n    p.sort()\n    if p[0]!=0:\n        for i in range(3):\n            mp += abs(p[i] - abc[i])\n        ans.append(mp)\nprint(min(ans))", "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return list(map(int, sys.stdin.readline().split()))\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from collections import Counter # a = Counter(A).most_common()\n#from itertools import accumulate #list(accumulate(A))\nimport itertools\n\nN, *A = mi()\nL = [ii() for _ in range(N)]\nL_ = [L[i] for i in range(N)]\nN_ = N\n\nA = sorted(A)\n#sum_l = sum(L)\ntmp = [0] * 3\nans = float('inf')\n\nfor k in itertools.product([0,1], repeat=N_):\n    N = sum(k)\n    if N < 3:\n        continue\n    L = []\n    for x in range(N_):\n        if k[x]:\n            L.append(L_[x]*k[x])\n    #L = [L_[x]*k[x] for x in range(N_)]\n    sum_l = sum(L)\n\n    for i in range(1, N+1):\n        for koho_i in range(1, 2**i):\n            for koho_j in range(1, 2**i):\n                j = i\n                #print(koho_i, koho_j)\n                if koho_i & koho_j:\n                    continue\n                #tmp[0] = [L[x]*koho_i[x] for x in range(i)]\n                tmp[0] = sum([L[x]*min((koho_i & 1<<x), 1) for x in range(i)])\n                #tmp[1] = [L[x]*koho_j[x] for x in range(j)]\n                tmp[1] = sum([L[x]*min((koho_j & 1<<x), 1) for x in range(j)])\n                tmp[2] = sum_l - tmp[0] - tmp[1]\n                #print(tmp)\n\n                if 0 in tmp:\n                    continue\n\n                tmp = sorted(tmp)\n                cost = (N-3) * 10 + sum([abs(tmp[x]-A[x]) for x in range(3)])\n                #if cost < ans:\n                    #print(tmp, cost, N)\n                #if tmp[0] == 80 and tmp[1] == 91 and tmp[2] == 98:\n                    #print(cost)\n                ans = min(ans, cost)\n\nprint(ans)\n", "def main():\n    n, a, b, c = list(map(int, input().split()))\n    L = [int(input()) for _ in range(n)]\n    INF = 1000000\n    def dfs(i, la, lb, lc):\n        if i == n:\n            return abs(la - a) + abs(lb - b) + abs(lc - c) if min(la, lb, lc) > 0 else INF\n        res = []\n        res.append(dfs(i + 1, la, lb, lc))\n        res.append(dfs(i + 1, la + L[i], lb, lc) + 10 if la != 0 else dfs(i + 1, la + L[i], lb, lc))\n        res.append(dfs(i + 1, la, lb + L[i], lc) + 10 if lb != 0 else dfs(i + 1, la, lb + L[i], lc))\n        res.append(dfs(i + 1, la, lb, lc + L[i]) + 10 if lc != 0 else dfs(i + 1, la, lb, lc + L[i]))\n        return min(res)\n    print(dfs(0, 0, 0, 0))\n\ndef __starting_point():\n    main()\n__starting_point()", "N, A, B, C = list(map(int, input().split()))\nL_list = [int(input()) for i in range(N)]\n\nimport itertools\n\nTarget = itertools.product([0, 1, 2, 3], repeat=N)\n\nINF = 10 ** 9\n#Target = [(1,2,2,2,3)]\nans = INF\nfor T in Target:\n    A_sum = 0\n    B_sum = 0\n    C_sum = 0\n    A_cost = 0\n    B_cost = 0\n    C_cost = 0\n    for i in range(N):\n        if T[i] == 0: continue\n        if T[i] == 1:\n            if A_sum == 0:\n                A_sum += L_list[i]\n            else:\n                A_sum += L_list[i]\n                A_cost += 10\n        if T[i] == 2:\n            if B_sum == 0:\n                B_sum += L_list[i]\n            else:\n                B_sum += L_list[i]\n                B_cost += 10\n        if T[i] == 3:\n            if C_sum == 0:\n                C_sum += L_list[i]\n            else:\n                C_sum += L_list[i]\n                C_cost += 10\n\n    if min(A_sum, B_sum, C_sum) == 0: continue\n\n    ans = min(ans, abs(A - A_sum)+A_cost + abs(B - B_sum)+B_cost + abs(C - C_sum)+C_cost)\nprint(ans)\n", "N, A, B, C = list(map(int, input().split()))\nl = [int(input()) for i in range(N)]\n \nINF = float('inf')\nans = INF\n \ndef dfs(a, b, c, n, cost):\n    nonlocal ans\n    if n == N:\n        cost += abs(A - a) + abs(B - b) + abs(C - c) - 30 if min(a, b, c) > 0 else INF\n        ans = min(ans, cost)\n        return\n    dfs(a, b, c, n+1, cost)\n    dfs(a+l[n], b, c, n+1, cost+10)\n    dfs(a, b+l[n], c, n+1, cost+10)\n    dfs(a, b, c+l[n], n+1, cost+10)\n \ndfs(0, 0, 0, 0, 0)\nprint(ans)\n", "n,a,b,c = map(int,input().split())\nl = [int(input()) for _ in range(n)]\n\ndef kadomatsu(li,x):\n    cost = 0\n    cost += 10*(len(li)-1)\n    cost += abs(sum(li)-x)\n    return cost\n\nansli = []\n\nfor i in range(4**n):\n    #print(i,end = \" \")\n    #memo = i\n    amari = []\n    while True:\n        if i >= 4:\n            amari.append(i%4)\n            i = i//4\n        else:\n            amari.append(i)\n            break\n    gyaku = amari[::-1]\n    #print(gyaku,end=\" \")\n    gya = [0]*(n - len(gyaku)) + gyaku\n    #print(gya,end = \" \")\n    al = []\n    bl = []\n    cl = []\n    for j in range(n):\n        if gya[j] == 1:\n            al += [l[j]]\n        elif gya[j] == 2:\n            bl += [l[j]]\n        elif gya[j] == 3:\n            cl += [l[j]]\n    if al and bl and cl:\n        ans = kadomatsu(al,a) + kadomatsu(bl,b) + kadomatsu(cl,c)\n        ansli += [ans]\n        #print(memo,gya,al,bl,cl)\nprint(min(ansli))", "# n=int(input())\nn, A, B, C = map(int, input().split())\n# l=list(map(int,input().split()))\n#l=[list(map(int,input().split())) for i in range(n)]\nl = [int(input()) for i in range(n)]\n\nINF = 10**9\n\n\ndef dfs(cur, a, b, c):\n    if cur == n:\n        return abs(a-A)+abs(b-B)+abs(c-C)-30 if min(a, b, c) > 0 else INF\n    ret0 = dfs(cur+1, a, b, c)\n    ret1 = dfs(cur+1, a+l[cur], b, c)+10\n    ret2 = dfs(cur+1, a, b+l[cur], c)+10\n    ret3 = dfs(cur+1, a, b, c+l[cur])+10\n\n    return min(ret0, ret1, ret2, ret3)\n\n\nans = dfs(0, 0, 0, 0)\nprint(ans)", "# coding: utf-8\n\n# https://atcoder.jp/contests/abc119\n\n\ndef main():\n    N, A, B, C = list(map(int, input().split()))\n    ls = [None] * N\n    for i in range(N):\n        ls[i] = int(input())\n\n    abc_mp = []\n\n    def rec(i, a, b, c, mp, ls):\n        if i == len(ls):\n            if a > 0 and b > 0 and c > 0:\n                abc_mp.append([a, b, c, mp-30])\n        else:\n            rec(i+1, a+ls[i], b, c, mp+10, ls)\n            rec(i+1, a, b+ls[i], c, mp+10, ls)\n            rec(i+1, a, b, c+ls[i], mp+10, ls)\n            rec(i+1, a, b, c, mp, ls)\n\n    rec(0, 0, 0, 0, 0, ls)\n    a0, b0, c0, mp0 = abc_mp[0]\n    ans = mp0 + abs(A-a0) + abs(B-b0) + abs(C-c0)\n    for a, b, c, mp in abc_mp:\n        cand = mp + abs(A-a) + abs(B-b) + abs(C-c)\n        if cand < ans:\n            ans = cand\n\n    return ans\n\n\nprint((main()))\n", "N, A, B, C = list(map(int, input().split()))\nL = []\nfor _ in range(N):\n    L.append(int(input()))\n\n\ndef test(n, a, b, c, na, nb, nc):\n    \"\"\"\n    :param n: \u4f7f\u7528\u3057\u3066\u3044\u308b\u7af9\u306e\u672c\u6570\n    :param a: \u7af9a\u306e\u9577\u3055\n    :param b: \u7af9b\u306e\u9577\u3055\n    :param c: \u7af9c\u306e\u9577\u3055\n    :param na: \u7af9a\u306b\u4f7f\u7528\u3057\u305f\u672c\u6570\n    :param nb: \u7af9b\u306b\u4f7f\u7528\u3057\u305f\u672c\u6570\n    :param nc: \u7af9c\u306b\u4f7f\u7528\u3057\u305f\u672c\u6570\n    :return: \u6d88\u8cbbMP\n    \"\"\"\n    if n == N:\n        # \u6700\u7d42MP\u306e\u78ba\u5b9a\n        if min(na, nb, nc) == 0:\n            return 10**9\n        else:\n            mp = 0\n            mp += (na-1) * 10 if na else 0\n            mp += (nb-1) * 10 if nb else 0\n            mp += (nc-1) * 10 if nc else 0\n            mp += abs(A-a) + abs(B-b) + abs(C-c)\n            return mp\n    else:\n        mp1 = test(n+1, a, b, c, na, nb, nc)  # \u4f7f\u7528\u3057\u306a\u3044\n        mp2 = test(n+1, a+L[n], b, c, na+1, nb, nc)  # \u7af9a\u306b\u9069\u7528\n        mp3 = test(n+1, a, b+L[n], c, na, nb+1, nc)  # \u7af9b\u306b\u9069\u7528\n        mp4 = test(n+1, a, b, c+L[n], na, nb, nc+1)  # \u7af9c\u306b\u9069\u7528\n        return min(mp1, mp2, mp3, mp4)\n\n\nprint((test(0, 0, 0, 0, 0, 0, 0)))\n", "n,a,b,c=map(int,input().split())\nl=[]\nfor _ in range(n):\n    lt=int(input())\n    l.append(lt)\nfrom itertools import product\ncount=10**10\nfor i in product([0,1,2,3],repeat=n):\n    if i.count(0)>=1 and i.count(2)>=1 and i.count(1)>=1:\n    \n        temp=0\n        at=0\n        bt=0\n        ct=0\n        for j in range(n):\n            if i[j]==0:\n                at+=l[j]\n                temp+=1\n\n            elif i[j]==1:\n                bt+=l[j]\n                temp+=1\n            \n            elif i[j]==2:\n                ct+=l[j]\n                temp+=1\n        count=min(count,abs(a-at)+abs(b-bt)+abs(c-ct)+10*(temp-3))\n        \nprint(count)", "N, A, B, C = list(map(int, input().split()))\nabc = [C, B, A]\n\nl = [0] * N\nfor i in range(N):\n    l[i] = int(input())\n\nimport numpy\nmpp = 10**10\nL = [0] * 3\nt = [-10] * 3\n\nfor i in range(1, 4**N):\n    b = numpy.base_repr(i, 4, N)[-N:]\n    L = [A, B, C]\n    t = [-10] * 3\n    if \"1\" not in b or \"2\" not in b or \"3\" not in b:\n        continue\n    #print(b)\n    for j in range(N):\n        for k in range(3):\n            if b[j] == str(k + 1):\n                L[k] -= l[j]\n                t[k] += 10\n    mpp = min(mpp, sum(t) + sum([abs(x) for x in L]))\n\nprint(mpp)\n\n", "n,a,b,c,*l=map(int,open(0).read().split())\ndef dfs(x,y,z,r):\n  if r==n:\n    return abs(a-x)+abs(b-y)+abs(c-z)-30 if min(x,y,z)>0 else 10**9\n  return min(\n    dfs(x+l[r],y,z,r+1)+10,\n    dfs(x,y+l[r],z,r+1)+10,\n    dfs(x,y,z+l[r],r+1)+10,\n    dfs(x,y,z,r+1)\n  )\nprint(dfs(0,0,0,0))", "n, a, b, c = map(int,input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nans = 10**9    \nfor ci in range(4**n):\n    ci_ = [-1] * n\n    cnt = [0] * 3\n    ca, cb, cc = 0, 0, 0\n    for cj in range(n):\n        cx = ci & 3\n        if cx == 0:\n            ca += l[cj]\n            cnt[0] += 1 \n        elif cx == 1:\n            cb += l[cj]\n            cnt[1] += 1 \n        elif cx == 2:\n            cc += l[cj]\n            cnt[2] += 1 \n        ci >>= 2\n    if ca == 0 or cb == 0 or cc == 0:\n        continue\n    \n    cost = 0\n    for i in range(3):\n        if cnt[i] > 1:\n            cost += 10 * (cnt[i]-1)\n    cost += abs(a-ca) + abs(b-cb) + abs(c-cc)\n    ans = min(ans, cost)\nprint(ans)", "n,A,B,C=map(int,input().split())\nQ=[int(input()) for ii in range(n)]\ninf=10**15\ndef dfs(now,a,b,c):\n    if now==n:\n        return abs(a-A)+abs(b-B)+abs(c-C) if 0 not in [a,b,c] else inf\n    q1= dfs(now+1,a,b,c)\n    q2= dfs(now+1, a+Q[now],b,c)+10\n    q3= dfs(now+1, a, b+Q[now], c)+10\n    q4 = dfs(now+1,a,b,c+Q[now])+10\n    return min(q1,q2,q3,q4)\n \nprint(dfs(0,0,0,0)-30)", "from itertools import *\nN,A,B,C = map(int, input().split())\nL = [int(input()) for n in range(N)]\nans = []\n\nfor i in product(range(4),repeat=N):\n  a = 0\n  b = 0\n  c = 0\n  d = 0\n  for j in range(N):\n    if i[j]:\n      d+=1\n      if i[j]==1:\n        a+=L[j]\n      elif i[j]==2:\n        b+=L[j]\n      else:\n        c+=L[j]\n  if a*b*c:\n    ans+=[abs(A-a)+abs(B-b)+abs(C-c)+10*(d-3)]\n\nprint(min(ans))", "import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\n# def LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\nn,a,b,c=LI()\nl=[I() for _ in range(n)]\n\ndef dfs(cnt,aa,bb,cc):\n  if cnt==n:\n    if aa==0 or bb==0 or cc==0:\n      return inf\n    return abs(aa-a)+abs(bb-b)+abs(cc-c)-30\n\n  aaa=dfs(cnt+1,aa+l[cnt],bb,cc)+10\n  bbb=dfs(cnt+1,aa,bb+l[cnt],cc)+10\n  ccc=dfs(cnt+1,aa,bb,cc+l[cnt])+10\n  ddd=dfs(cnt+1,aa,bb,cc)\n  return min(aaa,bbb,ccc,ddd)\n\nprint((dfs(0,0,0,0)))\n", "# \u3068\u308a\u3042\u3048\u305a\u89e3\u8aac\u3092\u898b\u305a\u306b\u7121\u7406\u77e2\u7406\u89e3\u304f\u3002\n# \u5168\u3066\u306e\u7af9\u3092\u300cA\u306b\u4f7f\u3046\u30fbB\u306b\u4f7f\u3046\u30fbC\u306b\u4f7f\u3046\u30fb\u4f7f\u308f\u306a\u3044\u300d\u306e\u3069\u308c\u304b\u306b\u632f\u308a\u5206\u3051\u308b\u65b9\u6cd5\u306f\n# 4**8 = 2**16 \u2252 64000\u306a\u306e\u3067\u5168\u901a\u308a\u63a2\u7d22\u3067\u304d\u308b\u3002\n# C < B < A\u306a\u306e\u3067\u3001\u5408\u6210\u3057\u305f\u5f8c\u306b\u9577\u3044\u9806\u306b\u3059\u308c\u30706\u5206\u306e1\u3060\u3051\u8abf\u3079\u308c\u3070\u826f\u3044\u304c\u3001\u8a72\u5f53\u306e6\u5206\u306e1\u3060\u3051\u3092\u629c\u304d\u51fa\u3059\u306e\u306f\u96e3\u3057\u3044\n# \u3069\u308c\u304b\u306b\u4f7f\u3046\u304c\u7a7a\u96c6\u5408\u306b\u306a\u3063\u3066\u308b\u306e\u306f\u9664\u5916\u3002\n\nimport itertools\nn, a, b, c = list(map(int, input().split()))\nnums = [int(input()) for _ in range(n)]\n\nans = 10**10\n\nfor usage_info in itertools.product(list(range(4)), repeat=n):\n\n    mp = 0\n    length = [0, 0, 0]\n    for idx, usage in enumerate(usage_info):\n        if usage == 3:\n            continue\n        if length[usage] > 0:\n            mp += 10  # \u5408\u6210\u9b54\u6cd5\n        length[usage] += nums[idx]\n    if min(length) == 0:\n        continue\n\n    mp += abs(length[0] - a) + abs(length[1] - b) + abs(length[2] - c)  # \u5ef6\u9577\u3001\u77ed\u7e2e\u9b54\u6cd5\n    ans = min(ans, mp)\n\nprint(ans)\n", "N,A,B,C=list(map(int,input().split()))\nl=[]\nfor i in range(N):\n    l.append(int(input()))\n\nfrom itertools import product\n\nP=product(list(range(4)),repeat=N)\n\nans=1000000000\nfor p in P:\n    A_len=0\n    B_len=0\n    C_len=0\n    temp=0\n    for i in range(N):\n        n=int(p[i])\n        if n==3:\n            if A_len!=0:\n                temp+=10\n            A_len+=l[i]\n        elif n==2:\n            if B_len!=0:\n                temp+=10\n            B_len+=l[i]\n        elif n==1:\n            if C_len!=0:\n                temp+=10\n            C_len+=l[i]\n\n    if A_len!=0 and B_len!=0 and C_len!=0:\n        temp+=abs(A-A_len)\n        temp+=abs(B-B_len)\n        temp+=abs(C-C_len)\n\n        ans=min(ans,temp)\n\nprint(ans)\n\n", "from functools import lru_cache\nN, A, B, C, *L = list(map(int, open(0).read().split()))\n\n\n@lru_cache(None)\ndef popcnt(n):\n    return bin(n).count('1')\n\n\n@lru_cache(None)\ndef synth(bit):\n    length = 0\n    for i in range(N):\n        if bit >> i & 1:\n            length += L[i]\n    return length\n\n\nans = 1 << 60\nfor bit1 in range(1, 1 << N):\n    if popcnt(bit1) >= N-1:\n        continue\n    length1 = synth(bit1)\n\n    for bit2 in range(1, 1 << N):\n        if bit1 & bit2:\n            continue\n        if popcnt(bit1 | bit2) == N:\n            continue\n        length2 = synth(bit2)\n\n        for bit3 in range(1, 1 << N):\n            if bit1 & bit3 or bit2 & bit3:\n                continue\n\n            length3 = synth(bit3)\n            c, b, a = sorted([length1, length2, length3])\n\n            cost = 10*(popcnt(bit1 | bit2 | bit3)-3) + abs(C-c) + abs(B-b) + abs(A-a)\n            if cost < ans:\n                ans = cost\n\nprint(ans)\n", "n,a,b,c,*L = map(int,open(0).read().split())\nL.sort(reverse = True)\n\nfrom itertools import product\nfrom copy import deepcopy\nli1 = [4,1,2,3]\nans = 10**10\nfor v in product(li1,repeat = n):\n    #print(v)\n    num = 0\n    A,B,C,NO = [],[],[],[]\n    for i in range(n):\n        if v[i] == 1:\n            #if L[i] not in (a,b,c):\n            A.append(L[i])\n        elif v[i] == 2:\n            #if L[i] not in (a,b,c):\n            B.append(L[i])\n        elif v[i] == 3:\n            #if L[i] not in (a,b,c):\n            C.append(L[i])\n        elif v[i] == 4:\n            NO.append(L[i])\n    if A and B and C:\n        num +=abs(sum(A)-a) + max(0,(len(A)-1)*10) + abs(sum(B)-b) + max(0,(len(B)-1)*10)+ abs(sum(C)-c) + max(0,(len(C)-1)*10)\n        ans = min(ans,num)\n    #print(num,ans,A,B,C,max(0,(len(A)-1)*10),max(0,(len(B)-1)*10))\nprint(ans)", "import itertools\n\nN, A, B, C = list(map(int, input().split()))\n\nl = [int(input()) for _ in range(N)]\n\nans = 10**10\n# [\u7af91\u306e\u9078\u629e, \u7af92\u306e\u9078\u629e, ..., \u7af9N\u306e\u9078\u629e]\n# 4**8==65536\nfor x in itertools.product([0, 1, 2, 3], repeat=N):\n    # [\u4e0d\u4f7f\u7528\u306e\u7af9\u306e\u5408\u8a08\u9577\u3055\u3001A\u306b\u4f7f\u7528\u3059\u308b\u7af9\u306e\u5408\u8a08\u9577\u3055\u3001B\u306b...\u3001C\u306b...]\n    bamboo = [0] * 4\n    tmp = 0\n    for i in range(N):\n        # \u59cb\u3081\u3066\u9078\u3076\u5834\u5408\u306f\u30b3\u30b9\u30c8\u304c\u304b\u304b\u3089\u306a\u3044\n        if x[i] in [1, 2, 3] and bamboo[x[i]] > 0:\n            tmp += 10\n        bamboo[x[i]] += l[i]\n\n    # A,B,C\u305d\u308c\u305e\u308c\u306b\u3064\u3044\u3066\u30011\u672c\u4ee5\u4e0a\u4f7f\u3046\u5fc5\u8981\u304c\u3042\u308b\n    if 0 in bamboo[1:]:\n        continue\n    # \u5ef6\u9577\u9b54\u6cd5 or \u77ed\u7e2e\u9b54\u6cd5\u3067\u8abf\u6574\n    tmp += abs(bamboo[1] - A) + abs(bamboo[2] - B) + abs(bamboo[3] - C)\n\n    ans = min(ans, tmp)\n\nprint(ans)\n", "N, A, B, C = list(map(int, input().split()))\nL = []\nfor _ in range(N):\n  L.append(int(input()))\n\ndef rec(i, a, b, c):\n  if i == N:\n    if not a or not b or not c: return float('inf')\n    return abs(a-A) + abs(b-B) + abs(c-C)\n  \n  ret = rec(i+1, a, b, c)\n  \n  ret = min(ret, rec(i+1, a+L[i], b, c) + (10 if a else 0))\n  ret = min(ret, rec(i+1, a, b+L[i], c) + (10 if b else 0))\n  ret = min(ret, rec(i+1, a, b, c+L[i]) + (10 if c else 0))\n  \n  return ret\n\nprint((rec(0, 0, 0, 0)))\n", "N, A, B, C = list(map(int, input().split()))\nL = [int(input()) for _ in range(N)]\ndef rec(itr, a, b, c, mp):\n    if itr == N:\n        if a == 0 or b == 0 or c == 0:\n            return 10 ** 9\n        return abs(a - A) + abs(b - B) + abs(c - C) + mp - 30\n    res = rec(itr + 1, a, b, c, mp)\n    res = min(res, rec(itr + 1, a + L[itr], b, c, mp) + 10)\n    res = min(res, rec(itr + 1, a, b + L[itr], c, mp) + 10)\n    res = min(res, rec(itr + 1, a, b, c + L[itr], mp) + 10)\n    return res\nprint((rec(0, 0, 0, 0, 0)))\n", "from itertools import product\nn, a, b, c = list(map(int, input().split()))\nl = [int(input()) for _ in range(n)]\nans = 1001001001\nfor x in product(list(range(4)), repeat=n):\n    s = [0] * 4\n    t = -3\n    for i in range(n):\n        t += x[i] < 3\n        s[x[i]] += l[i]\n    s.pop()\n    if 0 in s:\n        continue\n    ans = min(ans, t * 10 + abs(s[0] - a) + abs(s[1] - b) + abs(s[2] - c))\nprint(ans)\n", "# N\u756a\u76ee\u306e\u7af9\u3092A,B,C\u306e\u3044\u305a\u308c\u304b\u306b\u4f7f\u3046or\u3069\u308c\u306b\u3082\u4f7f\u308f\u306a\u3044\u306e\u5168\u63a2\u7d22\n# 4 ^ 8 = 60000\u5f37\n\nimport sys\nreadline = sys.stdin.readline\n\nN,A,B,C = map(int,readline().split())\nL = [int(readline()) for i in range(N)]\n\nans = 10 ** 10\nimport itertools\nfor prod in itertools.product(range(4),repeat = N):\n  if len(set(prod) & set(range(3))) != 3:\n    continue\n  take = [0] * 3\n  cost = 0\n  for i in range(len(prod)):\n    if prod[i] == 3:\n      continue\n    if take[prod[i]] != 0:\n      cost += 10\n    take[prod[i]] += L[i]\n  cost += abs(A - take[0]) + abs(B - take[1]) + abs(C - take[2])\n  if ans > cost:\n    ans = cost\n\nprint(ans)", "import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return map(int, sys.stdin.readline().split())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from collections import Counter # a = Counter(A).most_common()\n#from itertools import accumulate #list(accumulate(A))\nimport itertools\n\nN, *A = mi()\nL = [ii() for _ in range(N)]\n\nA = sorted(A)\nsum_a = sum(A)\n\ndef dfs(i, a, b, c, use):\n    if (0 not in [a, b, c]) and use > 2:\n        nonlocal ans\n        abc = sorted([a, b, c])\n        ans = min(ans, (use-3)*10 + sum([abs(abc[i]-A[i]) for i in range(3)]))\n\n    if i > N-1:\n        return\n\n    dfs(i+1, a+L[i], b, c, use+1)\n    dfs(i+1, a, b+L[i], c, use+1)\n    dfs(i+1, a, b, c+L[i], use+1)\n    dfs(i+1, a, b, c, use)\n\nans = float('inf')\ndfs(0, 0, 0, 0, 0)\n\nprint(ans)", "N,A,B,C = map(int,input().split())\nl = [int(input()) for n in range(N)]\ninf = 10 ** 18\n\ndef dfs(cur,a,b,c):\n    if cur == N:\n        if min(a,b,c) > 0:\n            return abs(A-a)+abs(B-b)+abs(C-c)-30\n        else:\n            return inf\n\n    res0 = dfs(cur+1,a,b,c)\n    res1 = dfs(cur+1,a+l[cur],b,c)+10\n    res2 = dfs(cur+1,a,b+l[cur],c)+10\n    res3 = dfs(cur+1,a,b,c+l[cur])+10\n    return min(res0,res1,res2,res3)\nprint(dfs(0,0,0,0))", "N,A,B,C=map(int,input().split())\nl=[int(input()) for _ in range(N)]\ninf=10**18\ndef dfs(cur,a,b,c):\n  if cur==N:\n    if min(a,b,c)>0:\n      return abs(A-a)+abs(B-b)+abs(C-c)-30\n    else:\n      return inf\n  res0 = dfs(cur+1,a,b,c)\n  res1 = dfs(cur+1,a+l[cur],b,c)+10\n  res2 = dfs(cur+1,a,b+l[cur],c)+10\n  res3 = dfs(cur+1,a,b,c+l[cur])+10\n  return min(res0,res1,res2,res3)\nprint(dfs(0,0,0,0))", "N, A, B, C = list(map(int, input().split()))\nl = [int(input()) for i in range(N)]\ndef dfs(cur,a,b,c):\n    if cur ==N:\n        return abs(a-A) + abs(b-B) + abs(c-C) -30 if min(a,b,c) > 0 else float('inf')\n    r1 = dfs(cur+1,a,b,c)\n    r2 = dfs(cur+1,a+l[cur],b,c) +10\n    r3 = dfs(cur+1,a,b+l[cur],c) + 10\n    r4 = dfs(cur+1,a,b,c+l[cur]) + 10\n    return min(r1,r2,r3,r4)\nprint((dfs(0,0,0,0)))\n#\u5168\u3066\u306e\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u8a66\u3059\u3001dfs\n", "# C MP\u6d88\u8cbb\u3092\u6291\u3048\u308b\u306b\u306fABC\u3068\u306e\u5dee\u304c\u5c0f\u3055\u3051\u308c\u306f\u826f\u3044\nn, A, B, C = list(map(int, input().split()))\nl = [int(input()) for _ in range(n)]\nINF = 10**9\n\n\ndef dfs(now, a, b, c):\n    if now == n:\n        return abs(a - A) + abs(b - B) + abs(c - C) - 30 if min(a, b, c) > 0 else INF\n    # \u65b9\u6cd5\uff11\u3000\uff11\u3064\u98db\u3070\u3059\n    way1 = dfs(now + 1, a, b, c)\n    # \u65b9\u6cd5\uff12\u3000\u5408\u6210\u9b54\u6cd5(MP10)\n    way2 = dfs(now + 1, a + l[now], b, c)+10\n    way3 = dfs(now + 1, a, b + l[now], c)+10\n    way4 = dfs(now + 1, a, b, c + l[now])+10\n    return min(way1, way2, way3, way4)\n\n\nprint((dfs(0, 0, 0, 0)))\n", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return list(map(int, input().split()))\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\ndef main():\n    n, A,B,C = i_map()\n\n    l = [i_input() for i in range(n)]\n\n    def dfs(cur, a,b,c):\n        if cur==n:\n            return abs(a-A) + abs(b-B) + abs(c-C) - 30 if min(a,b,c) > 0 else INF\n        ret0 = dfs(cur+1, a,b,c)\n        ret1 = dfs(cur+1, a+l[cur],b,c) + 10\n        ret2 = dfs(cur+1, a,b+l[cur],c) + 10\n        ret3 = dfs(cur+1, a,b,c+l[cur]) + 10\n        return min(ret0, ret1,ret2, ret3)\n    print((dfs(0,0,0,0)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10**7)\nn,A,B,C = map(int,input().split())\nL_ls = [int(input()) for _ in range(n)]\n\n# dfs(i,a,b,c) := i\u756a\u76ee\u306e\u7af9\u306e\u307e\u3048\u306e\u6642\u70b9\u3067\u3001A\u7528\u306e\u9577\u3055\u304ca, B\u7528\u306e\u9577\u3055\u304cb, C\u7528\u306e\u9577\u3055\u304cc\u3060\u3063\u305f\u6642\u306e\u3001\u305d\u308c\u4ee5\u964d\u306e\u5206\u5c90\u3067\u306e\u6700\u521d\u30b3\u30b9\u30c8\ndef dfs(i,a,b,c):\n    if i == n:\n        if a==0 or b == 0 or c == 0:\n            return float('inf')\n        else:\n            return abs(a-A) + abs(b-B) + abs(c-C)\n    \n    Min = dfs(i+1,a,b,c)\n\n    if a == 0:\n        Min = min(Min,dfs(i+1,a+L_ls[i],b,c))\n    else:\n        Min = min(Min,dfs(i+1,a+L_ls[i],b,c)+10)\n    \n    if b == 0:\n        Min = min(Min,dfs(i+1,a,b+L_ls[i],c))\n    else:\n        Min = min(Min,dfs(i+1,a,b+L_ls[i],c)+10)\n    \n    if c == 0:\n        Min = min(Min,dfs(i+1,a,b,c+L_ls[i]))\n    else:\n        Min = min(Min,dfs(i+1,a,b,c+L_ls[i])+10)\n    \n    return Min\nprint(dfs(0,0,0,0))", "from itertools import product\nn, a, b, c = map(int, input().split())\nl = [int(input()) for i in range(n)]\n\nans = float('inf')\nfor choice in product([0, 1, 2, 3], repeat=n):\n    items = [0] * 3\n    totals = [0] * 3\n    temp = 0\n    if min([choice.count(i) for i in range(3)]) == 0: continue\n    for i, ch in enumerate(choice):\n        if ch == 3: continue\n        totals[ch] += l[i]\n        items[ch] += 1\n        if items[ch] > 1:\n            temp += 10\n    temp+=abs(a-totals[0])\n    temp+=abs(b-totals[1])\n    temp+=abs(c-totals[2])\n    ans = min(ans, temp)\nprint(ans)", "N, A, B, C = map(int, input().split())\nfrom itertools import product\nl = [int(input()) for i in range(N)]\nans = []\nfor i in product(range(4), repeat=N):\n  a = 0\n  b = 0\n  c = 0\n  d = 0\n  for j in range(N):\n    if i[j]:\n      d += 1\n      if i[j] == 1:\n        a += l[j]\n      elif i[j] == 2:\n        b += l[j]\n      else:\n        c += l[j]\n  if a * b * c:\n    ans += [abs(A - a) + abs(B - b) + abs(C - c) + (d - 3) * 10]\nprint(min(ans))", "import sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\ndef s(): return input()\ndef i(): return int(input())\ndef S(): return input().split()\ndef I(): return map(int,input().split())\ndef L(): return list(map(int,input().split()))\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b//math.gcd(a,b)\nsys.setrecursionlimit(10 ** 9)\nINF = 10**9\nmod = 10**9+7\n\nN,A,B,C = I()\nl = [i() for _ in range(N)]\ndef dfs(cur,a,b,c):\n    if cur == N:\n        return abs(a-A)+abs(b-B)+abs(c-C)-30 if min(a,b,c) > 0 else INF\n    ret0 = dfs(cur+1,a,b,c)\n    ret1 = dfs(cur+1,a+l[cur],b,c)+10\n    ret2 = dfs(cur+1,a,b+l[cur],c)+10\n    ret3 = dfs(cur+1,a,b,c+l[cur])+10\n    return min(ret0,ret1,ret2,ret3)\nprint(dfs(0,0,0,0))", "N,A,B,C= list(map(int,input().split()))\nl=[]\nInf=float(\"Inf\")\nfor i in range(N):l.append(int(input()))\ndef Answer(cnt,a,b,c):\n   if cnt==N:\n      return abs(A-a)+abs(B-b)+abs(C-c)-30 if min(a,b,c)>0 else Inf\n   pt1=Answer(cnt+1,a,b,c)\n   pt2=Answer(cnt+1,a+l[cnt],b,c)+10\n   pt3=Answer(cnt+1,a,b+l[cnt],c)+10\n   pt4=Answer(cnt+1,a,b,c+l[cnt])+10\n   return(min(pt1,pt2,pt3,pt4))\nprint(Answer(0,0,0,0))", "from itertools import product\n\nN, *ABC = map(int, input().split())\n\nL = []\nfor _ in range(N):\n  L.append(int(input()))\n\nans = 10**9\nfor X in product((0, 1, 2, 3), repeat=N):\n  cnt, K, temp = [0]*4, [0]*4, 0\n  for i in range(N):\n    cnt[X[i]] += 1\n    K[X[i]] += L[i]\n  if min(cnt[1:]) == 0:\n    continue\n  for i in range(3):\n    temp += abs(ABC[i] - K[i+1])\n    temp += 10 * max(cnt[i+1]-1, 0)\n  ans = min(ans, temp)\n\nprint(ans)", "N, A, B, C = map(int, input().split())\nl = [int(input()) for _ in range(N)]\n\ndef dfs(cur, a, b, c):\n\tif cur == N:\n\t\treturn abs(a - A) + abs(b- B) + abs(c - C) - 30 if min(a, b, c) > 0 else float(\"inf\")\n\n\tret0 = dfs(cur + 1, a, b, c)\n\tret1 = dfs(cur + 1, a + l[cur], b, c) + 10\n\tret2 = dfs(cur + 1, a, b + l[cur], c) + 10\n\tret3 = dfs(cur + 1, a, b, c + l[cur]) + 10\n\n\treturn min(ret0, ret1, ret2, ret3)\n\nprint(dfs(0, 0, 0, 0))", "import itertools\nN,A,B,C=map(int, input().split())\nl=[int(input()) for _ in range(N)]\npattern=[\"a\",\"b\",\"c\",\"N\"]\n\nlcombi=itertools.product(pattern,repeat=N)\n\nans=(1000)**3\nfor lc in list(lcombi):\n\tAlen=0\n\tBlen=0\n\tClen=0\n\tAcost=0\n\tBcost=0\n\tCcost=0\n\t\n\tif (\"a\" not in lc) or(\"b\" not in lc) or(\"c\" not in lc):\n\t\tcontinue\n\telse:\n\t\tfor i in range(N):\n\t\t\tif lc[i]==\"a\":\n\t\t\t\tif Alen==0:Alen+=l[i]\n\t\t\t\telse:\n\t\t\t\t\tAlen+=l[i]\n\t\t\t\t\tAcost+=10\n\t\t\telif lc[i]==\"b\":\n\t\t\t\tif Blen==0:Blen+=l[i]\n\t\t\t\telse:\n\t\t\t\t\tBlen+=l[i]\n\t\t\t\t\tBcost+=10\n\t\t\telif lc[i]==\"c\":\n\t\t\t\tif Clen==0:Clen+=l[i]\n\t\t\t\telse:\n\t\t\t\t\tClen+=l[i]\n\t\t\t\t\tCcost+=10\n\t\tAcost+=abs(Alen-A)\n\t\tBcost+=abs(Blen-B)\n\t\tCcost+=abs(Clen-C)\n\t\tans=min(ans,Acost+Bcost+Ccost)\n\nprint(ans)", "N,A,B,C=map(int,input().split())\nL=[int(input()) for i in range(N)]\nR=[0]*N\nans=10**9\ndef myadd(i):\n    if R[i]==3:\n        R[i]=0\n        myadd(i+1)\n    else:\n        R[i]+=1\nfor i in range(4**N-1):\n    myadd(0)\n    if 1 in R and 2 in R and 3 in R:\n        tmp=-30\n        t1,t2,t3=0,0,0\n        for j in range(N):\n            if R[j]==0:\n                continue\n            if R[j]==1:\n                t1+=L[j]\n            elif R[j]==2:\n                t2+=L[j]\n            elif R[j]==3:\n                t3+=L[j]\n            tmp+=10\n        tmp+=abs(A-t1)+abs(B-t2)+abs(C-t3)\n        ans=min(tmp,ans)\nprint(ans)", "n, a, b, c = map(int, input().split())\nl = [int(input()) for _ in range(n)]\nans = 100000000000\nfor i in range(4**n):\n    A = []\n    B = []\n    C = []\n    D = []\n    current = 0\n    for j in range(n):\n        if i>>(2*j)&3 == 0:\n            A.append(l[j])\n        elif i>>(2*j)&3 == 1:\n            B.append(l[j])\n        elif i>>(2*j)&3 == 2:\n            C.append(l[j])\n        elif i>>(2*j)&3 == 3:\n            D.append(l[j])\n    if A and B and C:\n        current += (len(A)-1)*10 + abs(sum(A)-a)\n        current += (len(B)-1)*10 + abs(sum(B)-b)\n        current += (len(C)-1)*10 + abs(sum(C)-c)\n        ans = min(ans, current)\nprint(ans)", "from itertools import product\n\nINF = 10 ** 9\n\nN, *A = list(map(int, input().split()))\nL = [int(input()) for _ in range(N)]\n\n\ndef estimate(lst):\n    if any(not p for p in lst):\n        return INF\n\n    ret = 0\n    for p, g in zip(lst, A):\n        ret += abs(g - sum(p)) + (len(p) - 1) * 10\n    return ret\n\n\nans = INF\nfor prd in product(list(range(4)), repeat=N):\n    pieces = [[] for _ in range(3)]\n    for bamboo_ind, target_kadomatsu in enumerate(prd):\n        if target_kadomatsu == 3: continue\n        pieces[target_kadomatsu].append(L[bamboo_ind])\n    if ans > (res := estimate(pieces)):\n        ans = res\nprint(ans)\n", "from itertools import product, permutations\n\nN, A, B, C = list(map(int, input().split(' ')))\nL = [int(input()) for _ in range(N)]\n\nans = 10 ** 9\nfor groups in product(list(range(4)), repeat=N):\n    items = []\n    group_a = []\n    group_b = []\n    group_c = []\n\n    for group, length in zip(groups, L):\n        if group == 0:\n            items.append((length, 0))\n        elif group == 1:\n            group_a.append(length)\n        elif group == 2:\n            group_b.append(length)\n        elif group == 3:\n            group_c.append(length)\n\n    if group_a:\n        items.append((sum(group_a), (len(group_a) - 1) * 10))\n    if group_b:\n        items.append((sum(group_b), (len(group_b) - 1) * 10))\n    if group_c:\n        items.append((sum(group_c), (len(group_c) - 1) * 10))\n\n    if len(items) < 3:\n        continue\n\n    for one, two, three in permutations((A, B, C), r=3):\n        cost = 0\n        _items = list(items)\n\n        _items = sorted(_items, key=lambda x: (abs(x[0] - one), x[1]))\n        cost += abs(_items[0][0] - one) + _items[0][1]\n        _items.pop(0)\n\n        _items = sorted(_items, key=lambda x: (abs(x[0] - two), x[1]))\n        cost += abs(_items[0][0] - two) + _items[0][1]\n        _items.pop(0)\n\n        _items = sorted(_items, key=lambda x: (abs(x[0] - three), x[1]))\n        cost += abs(_items[0][0] - three) + _items[0][1]\n\n        ans = min(ans, cost)\n\nprint(ans)\n", "N, A, B, C = map(int, input().split())\nl = []\nfor i in range(N):\n    l.append(int(input()))\n    \ndef dfs(bamboo, a, b, c):\n    if bamboo == N:\n        if min(a, b, c) > 0:\n            return abs(A-a) + abs(B-b) + abs(C-c) - 30\n        else:\n            return 10**10\n    else:\n        ans1 = dfs(bamboo+1, a, b, c)\n        ans2 = dfs(bamboo+1, a+l[bamboo], b, c) + 10\n        ans3 = dfs(bamboo+1, a, b+l[bamboo], c) + 10\n        ans4 = dfs(bamboo+1, a, b, c+l[bamboo]) + 10\n        return min(ans1, ans2, ans3, ans4)\n        \nprint(dfs(0, 0, 0, 0))", "N,A,B,C = map(int,input().split())\n\nL = [int(input()) for _ in range(N)]\n    \nINF = 10**9\n\ndef dfs(i, a, b, c):\n    if i == N:\n        if min(a,b,c) > 0:\n            return abs(a-A) + abs(b-B) + abs(c-C) - 30\n        else:\n            return INF\n            \n    ret1 = dfs(i+1, a, b, c)\n    ret2 = dfs(i+1, a+L[i], b, c) + 10\n    ret3 = dfs(i+1, a, b+L[i], c) + 10\n    ret4 = dfs(i+1, a, b, c+L[i]) + 10\n    return min(ret1,ret2,ret3,ret4)\n    \nprint(dfs(0,0,0,0))", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N, A, B, C = LI()\n    ABC = (A, B, C)\n    l = [I() for _ in range(N)]\n\n    # A, B, C\u306b\u4f7f\u3046\u3001\u6368\u3066\u308b\u3001\u306e4\u901a\u308a\n    ans = INF\n    for i in itertools.product(list(range(4)), repeat=N):\n        a_cnt = i.count(0)\n        b_cnt = i.count(1)\n        c_cnt = i.count(2)\n        if a_cnt > 0 and b_cnt > 0 and c_cnt > 0:\n            # \u5408\u6210\u9b54\u6cd5\n            mp = 10 * (a_cnt + b_cnt + c_cnt - 3)\n            # \u5ef6\u9577\u77ed\u7e2e\u9b54\u6cd5\n            len = [0] * 3\n            for j in range(N):\n                if 0 <= i[j] < 3:\n                    len[i[j]] += l[j]\n            mp += sum([abs(j - k) for j, k in zip(ABC, len)])\n            ans = min(mp, ans)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "n,a,b,c=list(map(int,input().split()))\nL=[int(input()) for _ in range(n)]\nans=10**9\nfor x in range(4**n):\n    A,B,C=0,0,0\n    cost=0\n    for i in range(n):\n        r=x%4\n        x//=4\n        if r==1:\n            A+=L[i]\n        elif r==2:\n            B+=L[i]\n        elif r==3:\n            C+=L[i]\n        if r>0:\n            cost+=10\n    if A==0 or B==0 or C==0:\n        continue\n    cost+=-30+abs(A-a)+abs(B-b)+abs(C-c)\n    ans=min(ans,cost)\nprint(ans)\n", "from itertools import product\np=4\nn,a,b,c=map(int,input().split())\nbanboo=[0]*n\nfor i in range(n):\n    banboo[i]=int(input())\n\nBit_4=list(product(range(p),repeat=n))\nans=10**6\nfor Bi in Bit_4:\n    tmp=[0]*4\n    magic=0\n    if 1 in Bi and 2 in Bi and 3 in Bi:\n        for i in range(n):\n            tmp[Bi[i]]+=banboo[i]\n            if tmp[Bi[i]]!=banboo[i] and Bi[i]!=0:\n                magic+=10\n        magic+=abs(tmp[1]-a)\n        magic+=abs(tmp[2]-b)\n        magic+=abs(tmp[3]-c)\n        ans=min(magic,ans)\nprint(ans)", "n, a, b, c = map(int, input().split())\nbamboos = []\nfor i in range(n):\n    bamboo = int(input())\n    bamboos.append(bamboo)\n\ndef Base_10_to_n(X, n):\n    X_dumy = X\n    out = ''\n    while X_dumy>0:\n        out = str(X_dumy%n)+out\n        X_dumy = int(X_dumy/n)\n    return out\n\ndef calc_score(group, target):\n    score = 0\n    if len(group) > 1:\n        score += 10 * (len(group) - 1)\n    length = sum(group)\n    score += abs(length - target)\n    return score\n\nmin_score = 10**12\nfor i in range(4**n):\n    num = Base_10_to_n(i, 4).zfill(n)\n    score = 0\n    group_A = []\n    group_B = []\n    group_C = []\n    for j in range(n):\n        if num[j] == '1':\n            group_A.append(bamboos[j])\n        elif num[j] == '2':\n            group_B.append(bamboos[j])\n        elif num[j] == '3':\n            group_C.append(bamboos[j])\n    if len(group_A) == 0 or len(group_B) == 0 or len(group_C) == 0:\n        continue\n    else:\n        score += calc_score(group_A, a)\n        score += calc_score(group_B, b)\n        score += calc_score(group_C, c)\n\n    if score < min_score:\n        min_score = score\n\nprint(min_score)", "N, A, B, C = map(int,input().split())\nl = [int(input()) for i in range(N)]\nINF = 10 ** 9\n\ndef dfs(cnt,a,b,c):\n    if cnt == N:\n        return abs(a-A) + abs(b-B) + abs(c-C) - 30 if min(a,b,c) > 0 else INF\n        #\u6700\u521d\u306f0\u304b\u3089\u59cb\u3081\u3066\u3044\u3066\u4e0d\u8981\u306a\u51e6\u7406\u304c\u4e00\u56de\u3042\u308b\u305f\u3081-30\u3059\u308b\u3002\n    res0 = dfs(cnt + 1,a,b,c)\n    res1 = dfs(cnt + 1,a + l[cnt],b,c) + 10\n    res2 = dfs(cnt + 1,a,b + l[cnt],c) + 10\n    res3 = dfs(cnt + 1,a,b,c + l[cnt]) + 10\n    return min(res0,res1,res2,res3)\n\nprint(dfs(0,0,0,0))", "def to4(num):\n    if num//4 < 1:\n        return str(num)\n    else:\n        return to4(num//4)+str(num%4)\n    \ndef SyntheticKadomatsu():\n    idata = list(map(int, input().split()))\n    l = [int(input()) for _ in range(idata[0])]\n    ans = float('inf')\n    # bit\u5168\u63a2\u7d22\n    for i in range(4**idata[0]):\n        bits = [0]*4\n        tmp = 0\n        num = to4(i).zfill(idata[0])\n        for j in range(idata[0]):\n            v = int(num[-j-1])\n            if bits[v] != 0 and v != 3:\n                tmp += 10\n            bits[v] += l[j]\n        if 0 in set(bits[:-1]):\n            continue\n        for j in range(3):\n            tmp += abs(bits[j]-idata[j+1])\n        ans = min(ans, tmp)\n    print(ans)\n\ndef __starting_point():\n    SyntheticKadomatsu()\n    \n\n__starting_point()", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n\tN, A, B, C = NMI()\n\tL = [NI() for _ in range(N)]\n\n\tdef dfs(bamboo, a, b, c):\n\t\tif bamboo == N:\n\t\t\tif a*b*c == 0:\n\t\t\t\treturn 10**100\n\t\t\ta, b, c = sorted([a, b, c], reverse=True)\n\t\t\tres = abs(A-a) + abs(B-b) + abs(C-c)\n\t\t\treturn res\n\n\t\tres = 10**100\n\n\t\tres = min(res, dfs(bamboo + 1, a + L[bamboo], b, c) + 10) if a > 0 else min(res, dfs(bamboo + 1, a + L[bamboo], b, c))\n\t\tres = min(res, dfs(bamboo + 1, a, b + L[bamboo], c) + 10) if b > 0 else min(res, dfs(bamboo + 1, a, b + L[bamboo], c))\n\t\tres = min(res, dfs(bamboo + 1, a, b, c + L[bamboo]) + 10) if c > 0 else min(res, dfs(bamboo + 1, a, b, c + L[bamboo]))\n\t\tres = min(res, dfs(bamboo + 1, a, b, c))\n\t\treturn res\n\n\tprint(dfs(0, 0, 0, 0))\n\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "import sys,math,collections,itertools\ninput = sys.stdin.readline\n\nN,A,B,C=list(map(int,input().split()))\nl = [ int(input()) for _ in range(N)]\n\nuse_list = list(itertools.product(list(range(4)),repeat = N))\npoint = float('inf')\n\nfor i in range(len(use_list)):\n    ABC = [0]*3\n    count = [0]*3\n    if (0 not in use_list[i]) or(1 not in use_list[i]) or (2 not in use_list[i]):\n        continue\n    for j in range(len(use_list[i])):\n        if use_list[i][j] != 3:\n            ABC[use_list[i][j]] += l[j]\n            count[use_list[i][j]] += 1\n    p = (sum(count)-len(count))*10+abs(ABC[0]-A)+abs(ABC[1]-B)+abs(ABC[2]-C)\n    point = min(point,p)   \nprint(point)\n", "n,a,b,c=map(int,input().split())\nl = []\nfor i in range(n):\n  l.append(int(input()))\nm = [a,b,c]\nans = 4000\nfor i in range(4**n):\n  p = [0]*n\n  k = i\n  for j in range(n):\n    p[j] = k % 4\n    k //= 4\n  cost = [-1,-1,-1]\n  q = [[] for _ in range(4)]\n  for j in range(n):\n    q[p[j]].append(l[j])\n  for j in range(3):\n    if len(q[j+1]) != 0:\n      cost[j] = 10 * (len(q[j+1]) - 1) + abs(sum(q[j+1])-m[j])\n  if cost[0] != -1 and cost[1] != -1 and cost[2] != -1:\n    ans = min(ans, cost[0] + cost[1] + cost[2])\nprint(ans)", "import itertools\n\nn, a, b, c = map(int, input().split())\nl = []\nfor i in range(n):\n    l.append(int(input()))\nmp = float(\"inf\")\nfor i in itertools.product([0,1,2,3], repeat = n):\n    if 0 not in i or 1 not in i or 2 not in i:\n        continue\n    la, lb, lc = 0, 0, 0\n    temp = 0\n    for j in range(3):\n        temp += (i.count(j) - 1) * 10\n    for j in range(n):\n        if i[j] == 0:\n            la += l[j]\n        elif i[j] == 1:\n            lb += l[j]\n        elif i[j] == 2:\n            lc += l[j]\n    for j, k in [[la, a], [lb, b], [lc, c]]:\n        temp += abs(j - k)\n    mp = min(mp, temp)\nprint(mp)", "N, A, B, C = list(map(int, input().split()))\n\nl = []\nfor i in range(N):\n    l.append(int(input()))\n\ndef dfs(i, a, b, c):\n    if i == N:\n        if min(a,b,c) == 0:\n            return float(\"INF\")\n        else:\n            return abs(a-A) + abs(b-B) + abs(c-C)\n    else:\n        ans0 = dfs(i+1, a, b, c) #\u68d2i\u3092\u4f7f\u308f\u306a\u3044\u30d1\u30bf\u30fc\u30f3\n        ans1 = dfs(i+1, a+l[i], b, c) + (10 if a!=0 else 0)\n        ans2 = dfs(i+1, a, b+l[i], c) + (10 if b!=0 else 0)\n        ans3 = dfs(i+1, a, b, c+l[i]) + (10 if c!=0 else 0)\n    return min(ans0, ans1, ans2, ans3)\n\nprint((dfs(0, 0, 0, 0)))\n", "N, A, B, C = map(int, input().split())\nL = [0]*N\nfor i in range(N):\n    L[i] = int(input())\nINF = 10 ** 9\n\n\ndef dfs(times, a, b, c):  \n    if times == N:\n        return abs(a - A) + abs(b - B) + abs(c - C) - 30 if min(a, b, c) > 0 else INF\n    no_pattern = dfs(times + 1, a, b, c)\n    a_pattern = dfs(times + 1, a + L[times], b, c) + 10\n    b_pattern = dfs(times + 1, a, b + L[times], c) + 10\n    c_pattern = dfs(times + 1, a, b, c + L[times]) + 10\n\n    return min(no_pattern, a_pattern, b_pattern, c_pattern)\n\n\nprint(dfs(0,0,0,0))", "n,a,b,c, = map(int,input().split())\nl = list(int(input()) for i in range(n))\nans = 10 ** 6\nfor i in range(4 ** n):\n    m = i\n    j = 0\n    x,xp,y,yp,z,zp = 0,0,0,0,0,0\n    while m > 0:\n        p = m % 4\n        if p == 1:\n            x += l[j]\n            xp += 1\n        elif p == 2:\n            y += l[j]\n            yp += 1\n        elif p == 3:\n            z += l[j]\n            zp += 1\n        else:\n            pass\n        m = m // 4\n        j += 1\n    if xp != 0 and yp != 0 and zp != 0:\n        t = abs(a-x) + abs(b-y) + abs(c-z) + ((xp-1)*10) + ((yp-1)*10) + ((zp-1)*10)\n        ans = min(ans,t)\nprint(ans)", "#\u5168\u63a2\u7d22\u3092A,B,C\u4e00\u5ea6\u3067\u5206\u3051\u305f\n# RE 1   ac 19\n\n# \u521d\u671f\u5165\u529b\nimport copy\nfrom itertools import combinations\nimport sys\ninput = sys.stdin.readline  #\u6587\u5b57\u5217\u3067\u306f\u4f7f\u308f\u306a\u3044\nN,A,B,C = (int(i) for i in input().split())\nl =[0]*N\nfor i in range(N):\n    l[i] = int(input())\n\n# A,B,C\u3069\u306e\u7af9\u3092\u9078\u3076\u304bcombination\nmp=[]\nfor na in range(1,N-1):\n    for ja in combinations(l,na):\n\n        l_b =copy.copy(l)\n        for i2 in ja:\n            if i2 in l_b:\n                l_b.remove(i2)\n        for nb in range(1,N):\n            for jb in combinations(l_b ,nb):\n\n                l_c =copy.copy(l_b)\n                for i3 in jb:\n                    if i3 in l_c:\n                        l_c.remove(i3)\n                for nc in range(1,N+1):\n                    for jc in combinations(l_c ,nc):\n                        \n                        # MP\u306e\u6d88\u8cbb\u91cf\uff1d\uff08\u6c42\u3081\u308b\u9577\u3055\u30fc\u4eca\u56de\u9078\u3093\u3060\u7af9\u306e\u9577\u3055\u5408\u8a08\uff09+10*\uff08\u5408\u6210\u9b54\u6cd5\u306e\u56de\u6570)\n                        AA =abs(A-sum(ja)) +10*(na-1)\n                        BB =abs(B-sum(jb)) +10*(nb-1)\n                        CC =abs(C-sum(jc)) +10*(nc-1)\n                        mp.append(AA +BB +CC)\n\n\nprint(min(mp))", "def B10N(X,B):\n    if X//B!=0: return B10N(X//B,B)+str(X%B)\n    return str(X%B)\n\nN,A,B,C = (int(X) for X in input().split())\nLi = [int(input()) for X in range(0,N)]\nCostM = pow(10,9)\nfor T in range(0,pow(4,N)):\n    Cho = list(B10N(T,4).zfill(N))\n    if Cho.count('1')>0 and Cho.count('2')>0 and Cho.count('3')>0:\n        Cost = 0\n        ALi = [Li[X] for X,Y in enumerate(Cho) if Y=='1']\n        BLi = [Li[X] for X,Y in enumerate(Cho) if Y=='2']\n        CLi = [Li[X] for X,Y in enumerate(Cho) if Y=='3']\n        SyC = (len(ALi)+len(BLi)+len(CLi)-3)*10\n        LeC = abs(sum(ALi)-A)+abs(sum(BLi)-B)+abs(sum(CLi)-C)\n        if SyC+LeC<CostM: CostM = SyC+LeC\nprint(CostM)"]