2022-04-20 20:10:02.886185 num operations 1
2022-04-20 20:10:02.886209 size on input set 1
2022-04-20 20:10:02.886449 using api key soukgp
2022-04-20 20:10:07.018420 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#! /bin/bash\n\n# This script is for creating a new file and appending some text to it\n\ntouch testfile\necho \"This is a test file\" >> testfile\n"
    },
    {
      "index": 1,
      "text": "var fs = require('fs');\n\nfs.readFile('./input.txt', function(err, data) {\n    if (err) {\n        console.error(err);\n    }\n    console.log(data.toString());\n});\n\nconsole.log('End of program');\n"
    }
  ],
  "created": 1650485403,
  "object": "edit"
}
2022-04-20 20:10:07.018683 fix syntax errors 2 ['#! /bin/bash\n\n# This script is for creating a new file and appending some text to it\n\ntouch testfile\necho "This is a test file" >> testfile\n', "var fs = require('fs');\n\nfs.readFile('./input.txt', function(err, data) {\n    if (err) {\n        console.error(err);\n    }\n    console.log(data.toString());\n});\n\nconsole.log('End of program');\n"]
2022-04-20 20:10:07.018708 size on output set 2
2022-04-20 20:10:07.018720 num operations 1
2022-04-20 20:10:07.018725 size on input set 1
2022-04-20 20:10:07.018883 using api key sourya
2022-04-20 20:10:07.056084 in retry 6 1.5 <class 'Exception'>, Retrying in 1 seconds...
2022-04-20 20:10:08.557980 using api key soukgp
2022-04-20 20:10:15.205669 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import sys\n\n\ndef dfs(graph, v, parent, used, color):\n    color[v] = 1 - color[parent]\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    color = [-1] * n\n    if dfs(graph, 0, -1, used, color):\n        print('NO')\n        return\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [tuple(next(reader) for _ in range(2)) for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1650485408,
  "object": "edit"
}
2022-04-20 20:10:15.205894 fix syntax errors 2 ["import sys\n\n\ndef dfs(graph, v, parent, used, color):\n    color[v] = 1 - color[parent]\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    color = [-1] * n\n    if dfs(graph, 0, -1, used, color):\n        print('NO')\n        return\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [[next(reader), next(reader)] for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\n\ndef dfs(graph, v, parent, used, color):\n    used[v] = True\n    for u in graph[v]:\n        if u == parent:\n            continue\n        if used[u]:\n            continue\n        if dfs(graph, u, v, used, 1 - color):\n            return True\n    return False\n\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    used = [False] * n\n    if dfs(graph, 0, -1, used, 0):\n        print('NO')\n        return\n    color = [None] * n\n    for i in range(n):\n        if color[i] is None:\n            color[i] = 0\n            stack = [i]\n            while stack:\n                v = stack.pop()\n                for u in graph[v]:\n                    if color[u] is None:\n                        color[u] = 1 - color[v]\n                        stack.append(u)\n    for u, v in edges:\n        if color[u - 1] == color[v - 1]:\n            print('NO')\n            return\n    print('YES')\n    for u, v in edges:\n        if color[u - 1] < color[v - 1]:\n            print(0, end='')\n        else:\n            print(1, end='')\n\n\ndef main():\n    reader = (int(x) for x in sys.stdin.readline().split())\n    n, m = next(reader), next(reader)\n    edges = [tuple(next(reader) for _ in range(2)) for _ in range(m)]\n    solve(n, m, edges)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-04-20 20:10:15.205942 size on output set 2
2022-04-20 20:10:15.205954 num operations 1
2022-04-20 20:10:15.205960 size on input set 1
2022-04-20 20:10:15.206115 using api key sunu
2022-04-20 20:10:35.763490 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n        dfs(graph, 1)\n\n        if not all(seen):\n            return False\n\n    # find a cycle\n        cycle = [False for _ in range(m)]\n        seen = [False for _ in range(n + 1)]\n        seen[1] = True\n        for i in range(m):\n            u, v = edges[i]\n            if seen[u] and seen[v]:\n                cycle[i] = True\n            seen[u] = True\n            seen[v] = True\n\n        # print(cycle)\n\n    # find a cycle that has at least one even degree node\n        def dfs2(graph, source, cycle, even_degree_count):\n            seen[source] = True\n            if len(graph[source]) % 2 == 0:\n                even_degree_count += 1\n            if len(graph[source]) > 1 and even_degree_count > 1:\n                return True\n            if len(graph[source]) == 1 and even_degree_count > 0:\n                return True\n            if len(graph[source]) == 0:\n                return even_degree_count > 0\n            for v in graph[source]:\n                if not seen[v]:\n                    if dfs2(graph, v, cycle, even_degree_count):\n                        for u, v in edges:\n                            if u == source:\n                                cycle[u - 1] = False\n                        return True\n            return False\n\n        # print(cycle)\n        for i in range(m):\n            if cycle[i]:\n                u, v = edges[i]\n                graph[u].remove(v)\n                graph[v].remove(u)\n                seen = [False for _ in range(n + 1)]\n                if dfs2(graph, u, cycle, 0):\n                    cycle[i] = False\n                graph[u].append(v)\n                graph[v].append(u)\n\n        # print(cycle)\n        return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    # print(cycle)\n    for i in range(m): \n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # print(cycle)\n    return cycle\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"\".join(map(str, map(int, cycle))))\n"
    }
  ],
  "created": 1650485415,
  "object": "edit"
}
2022-04-20 20:10:35.763825 fix syntax errors 2 ['\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n        dfs(graph, 1)\n\n        if not all(seen):\n            return False\n\n    # find a cycle\n        cycle = [False for _ in range(m)]\n        seen = [False for _ in range(n + 1)]\n        seen[1] = True\n        for i in range(m):\n            u, v = edges[i]\n            if seen[u] and seen[v]:\n                cycle[i] = True\n            seen[u] = True\n            seen[v] = True\n\n        # print(cycle)\n\n    # find a cycle that has at least one even degree node\n        def dfs2(graph, source, cycle, even_degree_count):\n            seen[source] = True\n            if len(graph[source]) % 2 == 0:\n                even_degree_count += 1\n            if len(graph[source]) > 1 and even_degree_count > 1:\n                return True\n            if len(graph[source]) == 1 and even_degree_count > 0:\n                return True\n            if len(graph[source]) == 0:\n                return even_degree_count > 0\n            for v in graph[source]:\n                if not seen[v]:\n                    if dfs2(graph, v, cycle, even_degree_count):\n                        for u, v in edges:\n                            if u == source:\n                                cycle[u - 1] = False\n                        return True\n            return False\n\n        # print(cycle)\n        for i in range(m):\n            if cycle[i]:\n                u, v = edges[i]\n                graph[u].remove(v)\n                graph[v].remove(u)\n                seen = [False for _ in range(n + 1)]\n                if dfs2(graph, u, cycle, 0):\n                    cycle[i] = False\n                graph[u].append(v)\n                graph[v].append(u)\n\n        # print(cycle)\n        return cycle\n\n\nif __name__ == "__main__":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print("NO")\n    else:\n        print("YES")\n        print("".join(map(str, map(int, cycle))))\n', '\n\nimport sys\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n\n    # DFS\n    seen = [False for _ in range(n + 1)]\n    def dfs(graph, source):\n        seen[source] = True\n        for v in graph[source]:\n            if not seen[v]:\n                dfs(graph, v)\n\n    dfs(graph, 1)\n\n    if not all(seen):\n        return False\n\n    # find a cycle\n    cycle = [False for _ in range(m)]\n    seen = [False for _ in range(n + 1)]\n    seen[1] = True\n    for i in range(m):\n        u, v = edges[i]\n        if seen[u] and seen[v]:\n            cycle[i] = True\n        seen[u] = True\n        seen[v] = True\n\n    # print(cycle)\n\n    # find a cycle that has at least one even degree node\n    def dfs2(graph, source, cycle, even_degree_count):\n        seen[source] = True\n        if len(graph[source]) % 2 == 0:\n            even_degree_count += 1\n        if len(graph[source]) > 1 and even_degree_count > 1:\n            return True\n        if len(graph[source]) == 1 and even_degree_count > 0:\n            return True\n        if len(graph[source]) == 0:\n            return even_degree_count > 0\n        for v in graph[source]:\n            if not seen[v]:\n                if dfs2(graph, v, cycle, even_degree_count):\n                    for u, v in edges:\n                        if u == source:\n                            cycle[u - 1] = False\n                    return True\n        return False\n\n    # print(cycle)\n    for i in range(m): \n        if cycle[i]:\n            u, v = edges[i]\n            graph[u].remove(v)\n            graph[v].remove(u)\n            seen = [False for _ in range(n + 1)]\n            if dfs2(graph, u, cycle, 0):\n                cycle[i] = False\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # print(cycle)\n    return cycle\n\n\nif __name__ == "__main__":\n    n, m = map(int, sys.stdin.readline().strip().split())\n    edges = [None for _ in range(m)]\n    for i in range(m):\n        edges[i] = tuple(map(int, sys.stdin.readline().strip().split()))\n    cycle = solve(n, m, edges)\n    if cycle is False:\n        print("NO")\n    else:\n        print("YES")\n        print("".join(map(str, map(int, cycle))))\n']
2022-04-20 20:10:35.763897 size on output set 2
