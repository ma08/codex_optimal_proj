["from collections import Counter\n\nr = lambda: list(map(int, input().split()))\n\ndef main():\n\tn, = r()\n\ts = input()\n\tcost = list(r())\n\n\tans = 0\n\n\tcnt = Counter()\n\n\tfor i in range(n // 2):\n\t\tif s[i] == s[n - 1 - i]:\n\t\t\tans += min(cost[i], cost[n - 1 - i])\n\t\t\tcnt[s[i]] += 1\n\ttotal = sum(cnt.values())\n\tif total > 0:\n\t\tch, occ = cnt.most_common(1)[0]\n\t\tavail = []\n\t\tif occ > total - occ:\n\t\t\tfor i in range(n // 2):\n\t\t\t\tif s[i] != s[n - 1 - i] and s[i] != ch and s[n - 1 - i] != ch:\n\t\t\t\t\tavail.append(min(cost[i], cost[n - 1 - i]))\n\t\t\tavail.sort()\n\t\t\tans += sum(avail[:2 * occ - total])\n\n\tprint(sum(cost) - ans)\n\nmain()\n", "from collections import *\nn = int(input())\ns = input()\nb = [int (i) for i in input().split(' ')]\nn = n\ncnt = defaultdict(int)\nmultiples = []\nbiggest = 'a'\nans = 0\nfor i in range(n//2):\n    if(s[i] == s[n-i-1]):\n        multiples.append(i)\n        cnt[s[i]] += 1\n        ans += max(b[i],b[n-i-1])\n    else:\n        ans += b[i] + b[n-i-1]\n\nfor i in range(26):\n    if(cnt[chr(ord('a')+i)] > cnt[biggest]):\n        biggest = chr(ord('a')+i)\nmore = max(max(cnt.values())*2-sum(cnt.values()),0)\n# print(more)\ntakes = []\nfor i in range(n//2):\n    if(s[i] != s[n-i-1] and s[i] != biggest and s[n-i-1] != biggest):\n        takes.append(min(b[i],b[n-i-1]))\n\ntakes = sorted(takes)[:more]\npen = sum(takes)\n# print(pen)\n# print(takes)\nprint(ans-pen)\n", "#https://pymotw.com/2/collections/counter.html\n#same code as mmaxio\nfrom collections import Counter\n\nr = lambda: list(map(int, input().split()))\n\ndef main():\n\tn, = r()\n\ts = input()\n\tcost = list(r())\n\n\tans = 0\n\n\tcnt = Counter()\n\n\tfor i in range(n // 2):\n\t\tif s[i] == s[n - 1 - i]:\n\t\t\tans += min(cost[i], cost[n - 1 - i])\n\t\t\tcnt[s[i]] += 1\n\ttotal = sum(cnt.values())\n\tif total > 0:\n\t\tch, occ = cnt.most_common(1)[0]\n\t\tavail = []\n\t\tif occ > total - occ:# if highest occurence is more than the 50% of total then we will look for the letters which does not have pairs and are not equal to the letter with the highest ocuurence\n\t\t\tfor i in range(n // 2):\n\t\t\t\tif s[i] != s[n - 1 - i] and s[i] != ch and s[n - 1 - i] != ch:\n\t\t\t\t\tavail.append(min(cost[i], cost[n - 1 - i]))\n\t\t\tavail.sort()\n\t\t\tans += sum(avail[:2 * occ - total])\n\n\tprint(sum(cost)-ans)\n\nmain()\n#suppose total is 100 and highest occ is 51...difference between highest occ and remaining can be found using this form 2*occ-total as it is a simplified form of two steps 1.total-occ=remaining and 2.occ-remaining which is this case is 2 if highest occ is <= 50 % of total then it can be satisfied by remaining 50% but if it is greater than 50% then we have to use the letters of of the total\n", "class letter(object):\n    def __init__(self,let,val):\n        self.let=let\n        self.val=val\n\n    def __lt__(self,other):\n        return self.val<other.val\n\nn=int(input())\ns=input()\ncandi=[[] for i in range(n//2)]\nans=0\nfor i,vl in enumerate(map(int,input().split())):\n    candi[min(i,n-i-1)].append((letter)(s[i],vl))\n    ans+=vl\nfor i in range(n//2):\n    candi[i].sort()\nti=[0 for i in range(26)]\nsum=0\nfor i in range(n//2):\n    if candi[i][0].let==candi[i][1].let:\n        ans-=candi[i][0].val\n        ti[ord(candi[i][0].let)-ord('a')]+=1\n        sum+=1\n\nmx=0\np=0\nfor i in range(26):\n    if ti[i]>mx:\n        mx=ti[i]\n        p=i\nb=[]\nfor i in range(n//2):\n    if ord(candi[i][0].let)-ord('a')!=p and ord(candi[i][1].let)-ord('a')!=p and candi[i][0].let!=candi[i][1].let:\n        b.append(candi[i][0])\nb.sort()\ni=0\nwhile mx*2>sum:\n    sum+=1\n    ans-=b[i].val\n    i+=1\nprint(ans)"]