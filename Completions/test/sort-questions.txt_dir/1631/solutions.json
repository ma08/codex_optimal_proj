["#return if sa contains a real prefix: sb\ndef isPrefix( sa , sb ):\n    if len(sa) <= len(sb):\n        return False\n    return sa[0:len(sb)] == sb\n\ndef getOrder( sa , sb ):\n    for i in range( 0 , min( len(sa) , len(sb) ) ):\n        if sa[i] != sb[i]:\n            return sa[i],sb[i]\n\ntest = False\nif test:\n    fp = open(\"C-4.in\",\"r\")\n    n = int(fp.readline().strip())\n    names = [ fp.readline().strip() for i in range(0,n)]\n    fp.close()\nelse:\n    n = int(input().strip())\n    names = [ input().strip() for i in range(0,n)]\n\ng = [[False]*26 for i in range(0,26)]\n\nres = True\nfor i in range(1,n):\n    if names[i-1] == names[i] or isPrefix( names[i] , names[i-1] ):\n        continue\n    elif isPrefix( names[i-1] , names[i] ):\n        res = False\n        break\n    else:\n        ca,cb = getOrder( names[i-1] , names[i] )\n        #print(ca,\"<\",cb)\n        if g[ord(cb)-ord('a')][ord(ca)-ord('a')]:\n            res = False\n            break\n        else:\n            g[ord(ca)-ord('a')][ord(cb)-ord('a')] = True\n\ndef printG():\n    print(\"  abcdefghijklmnopqrstuvwxyz\")\n    for i in range(0,26):\n        print( chr( ord(\"a\") + i ) , \"\".join( [ \"1\" if x else \"0\" for x in g[i]] ) , sep = \"\")\n#printG()\n\nif not res:\n    print(\"Impossible\")\nelse:\n\n    def getZeroIndegreeNode():\n        for i in range(0,26):\n            if not used[i] and indegree[i] == 0:\n                return i\n        return -1\n    #topo sort\n    theOrder = []\n    indegree = [0] * 26\n    used = [False] * 26\n\n    #calc indegree\n    for i in range(0,26):\n        ithIndegree = 0\n        for j in range(0,26):\n            if g[j][i]: ithIndegree += 1\n        indegree[i] = ithIndegree\n        \n    for i in range(0,26):\n        zeroIndegreeNode = getZeroIndegreeNode()\n        if zeroIndegreeNode == -1:\n            res = False\n            break\n        else:\n            used[zeroIndegreeNode] = True\n            theOrder.append( chr( ord('a') + zeroIndegreeNode ) )\n            for j in range(0,26):\n                if g[zeroIndegreeNode][j]:\n                    indegree[j] -= 1\n\n    if not res:\n        print(\"Impossible\")\n    else:\n        print( \"\".join( theOrder ) )\n", "#import sys\n#sys.stdin = open('in.txt')\n#sys.setrecursionlimit(10000)\ndef isPrefix(sa, sb):\n    if len(sa) <= len(sb):\n        return False\n    return sa[0:len(sb)] == sb\n\ndef getOrder(sa, sb):\n    for i in range(0, min(len(sa), len(sb))):\n        if sa[i] != sb[i]: \n            return sa[i], sb[i]\n\ntest = False\nif test:\n    fp = open(\"in.txt\", 'r')\n    n = int(fp.readline().strip())\n    names = [fp.readline().strip() for i in range(0, n)]\n    fp.close()\nelse:\n    n = int(input().strip())\n    names = [input().strip() for i in range(0, n)]\n \ng = [[False] * 26 for i in range(0, 26)]\n\nres = True\nfor i in range(1, n):\n    if names[i - 1] == names[i] or isPrefix(names[i], names[i - 1]):\n        continue\n    elif isPrefix(names[i - 1], names[i]):\n        res = False\n        break\n    else:\n        ca, cb = getOrder(names[i - 1], names[i])\n        #print(ca, '<', cb)\n        if g[ord(cb) - ord('a')][ord(ca) - ord('a')]:\n            res = False\n            break\n        else:\n            g[ord(ca) - ord('a')][ord(cb) - ord('a')] = True\n\ndef printG():\n    print(\"   abcdefghijklmnopqrstuvwxyz\")\n    for i in range(0, 26):\n        print(chr(ord('a') + i), \"\".join([\"1\" if x else \"0\" for x in g[i]]), sep = \n\n\"\")\n#printG()\n\nif not res:\n    print(\"Impossible\")\nelse:\n    \n    def getZeroIndegreeNode():\n        for i in range(0, 26):\n            if not used[i] and indegree[i] == 0:\n                return i\n        return -1\n    #topo sort\n    theOrder = []\n    indegree = [0] * 26\n    used = [False] * 26\n    \n    #calc indegree\n    for i in range(0, 26):\n        ithIndegree = 0\n        for j in range(0, 26):\n           if g[j][i]: ithIndegree += 1\n        indegree[i] = ithIndegree\n    for i in range(0, 26):\n        zeroIndegreeNode = getZeroIndegreeNode()\n        if zeroIndegreeNode == -1:\n            res = False\n            break\n        else:\n            used[zeroIndegreeNode] = True\n            theOrder.append(chr(ord('a') + zeroIndegreeNode))\n            for j in range(0, 26):\n                if g[zeroIndegreeNode][j]:\n                    indegree[j] -= 1\n    if not res:\n        print(\"Impossible\")\n    else:\n        print(\"\".join(theOrder))", "#import sys\n#sys.stdin = open('in.txt')\n#sys.setrecursionlimit(10000)\ndef isPrefix(sa, sb):\n    if len(sa) >= len(sb):\n        return False\n    return sa == sb[0:len(sa)]\n\ndef getOrder(sa, sb):\n    for i in range(min(len(sa), len(sb))):\n        if sa[i] != sb[i]:\n            return sa[i], sb[i]\n\ntest = False\nif test:\n    fp = open('in.txt', 'r')\n    n = int(fp.readline().strip())\n    names = [fp.readline().strip() for _ in range(n)]\n    fp.close()\nelse:\n    n = int(input().strip())\n    names = [input().strip() for _ in range(n)]\n\nres = True\ng = [[False] * 26 for _ in range(26)]\n\"\"\"\nfor i in range(26):\n    for j in range(26):\n        g[i][j] = False\n\"\"\"\ndef printG():\n    print(\" abcdefghijklmnopqrstuvwxyz\")\n    for i in range(0, 26):\n        print(chr(ord('a') + i), \"\".join([\"1\" if x else \"0\" for x in g[i]]), sep = \n\n\"\")\n#get a table\nfor i in range(n - 1):\n    if names[i] == names[i + 1] or isPrefix(names[i], names[i + 1]):\n        continue\n    elif isPrefix(names[i + 1], names[i]):\n        res = False\n        break\n    else:\n        ca, cb = getOrder(names[i], names[i + 1])\n        #print(ca, '<', cb)\n        if g[ord(cb) - ord('a')][ord(ca) - ord('a')]:\n            res = False\n            break\n        else:\n            #pass\n            #printG()\n            a = ord(ca) - ord('a')\n            b = ord(cb) - ord('a')\n            g[a][b] = True\n            #printG()\n\nif not res:\n    print(\"Impossible\")\nelse:\n    def getZeroIndegreeNode():\n       for i in range(26):\n          if not vis[i] and Indegree[i] == 0:\n              return i\n       return -1\n    \n    #cacl Indegree\n    strOrder = []\n    vis = [False] * 26\n    Indegree = [0] * 26\n    for i in range(26):\n        ithIndegree = 0\n        for j in range(26):\n            if g[j][i]: ithIndegree += 1\n        Indegree[i] = ithIndegree\n    \n    #get the order string\n    for i in range(26):\n        ZeroIndegreeNode = getZeroIndegreeNode()\n        if ZeroIndegreeNode == -1:\n            res = False\n            break\n        else:\n            strOrder.append(chr(ord('a') + ZeroIndegreeNode))\n            vis[ZeroIndegreeNode] = True\n            for i in range(26):\n                if g[ZeroIndegreeNode][i]:\n                    Indegree[i] -= 1\n    if not res:\n        print(\"Impossible\")\n    else:\n        print(\"\".join(strOrder))\n", "import string\n\ndef make_link(G, char1, char2):\n    if char1 in G:\n        if char2 in G[char1]:\n            return\n        else:\n            G[char1].append(char2)\n    else:\n        G[char1] = [char2]\n\ndef make_order(G, str1, str2):\n    for i in range(min(len(str1), len(str2))):\n        if str1[i] != str2[i]:\n            make_link(G, str1[i], str2[i])\n            return True\n\n    if len(str2) > len(str1):\n        return True\n    else:\n        return False\n\ndef topological_sort(G, ans, k = '', visited = {}):\n    if visited.get(k, True) == False:\n        return True\n    if k not in visited:\n        visited[k] = False\n        for next in G.get(k, []):\n            if topological_sort(G, ans, next, visited):\n                return True\n        visited[k] = True\n        ans.insert(0, k)\n    return False\n\ndef main():\n    N = int(input())\n\n    strs = [input() for i in range(N)]\n\n    G = {}\n\n    for i in range(N-1):\n        if not make_order(G, strs[i], strs[i + 1]):\n            print(\"Impossible\")\n            return\n\n    G[''] = reversed(string.ascii_lowercase)\n\n    ans = []\n    if topological_sort(G, ans):\n        print(\"Impossible\")\n    else:\n        print(''.join(ans))\n\nmain()", "n=int(input())\nx=input()\na=len(x)\nlex=dict()\nALPHA=list('abcdefghijklmnopqrstuvwxyz')\n\nfor i in ALPHA:\n    for j in ALPHA:\n        lex[(i,j)]=0\n    \nfor i in range(n-1):\n    y=input()\n    b=len(y)\n    for j in range(min([a,b])):\n        if x[j]!=y[j]:\n            if lex[(x[j],y[j])]==-1:\n                print('Impossible')\n                raise SystemExit\n            else:\n                lex[(x[j],y[j])]=1\n                lex[(y[j],x[j])]=-1\n                x=y\n                a=b\n            break\n        if j==(min([a,b])-1):\n            if a>b:\n                print('Impossible')\n                raise SystemExit\n            x=y\n            a=b\n    \ndef biggest(alphabet):\n    for i in alphabet:\n        t=0\n        for j in alphabet:\n            if lex[(i,j)]<0:\n                t=1\n                break\n        if t==0:\n            return i\n    return -1\nnewalpha=['']*26 \ni=0\nwhile ALPHA!=[]:\n    BIG=biggest(ALPHA)\n    if biggest(ALPHA)==-1:\n        print('Impossible')\n        raise SystemExit\n    newalpha[i]=BIG\n    i=i+1\n    ALPHA.remove(BIG)\n\nprint(''.join(newalpha))\n    \n\n        \n"]