["from collections import defaultdict\nn, flower, bee = list(map(int, input().split()))\nroads = {}\nfor _ in range(n-1):\n    x, y = list(map(int, input().split()))\n    if x not in roads:\n        roads[x] = [y]\n    else:\n        roads[x].append(y)\n    if y not in roads:\n        roads[y] = [x]\n    else:\n        roads[y].append(x)\nflowers = defaultdict(int)\n\ndef dfs(bee, flower):\n    q = []\n    visited = set()\n    visited.add(flower)\n    last = -1\n    for y in roads[flower]:\n        if y == bee:\n            last = y\n            continue\n        q.append([y, y])\n    while q:\n        now = q.pop()\n        visited.add(now[0])\n        flowers[now[1]] += 1\n        for y in roads[now[0]]:\n            if y not in visited:\n                if y == bee:\n                    last = now[1]\n                    continue\n                q.append([y, now[1]])\n    return last\nrem = dfs(bee, flower)\nflower_total = sum(flowers.values())+1\nprint(n*(n-1)-(flower_total - flowers[rem])*(n-(flower_total)))", "from collections import defaultdict\n\nn, x, y = list(map(int, input().split()))\nsub_checks = [False] * (n + 1)\nsub_count = [1] * (n + 1)\n\n\ndef dfs(y, x, graph):\n    visited = set()\n    s = [y]\n    stack_order = []\n    while len(s) != 0:\n        curr = s.pop()\n        visited.add(curr)\n        if curr == x:\n            sub_checks[curr] = True\n        order = []\n        for child in graph[curr]:\n            if child not in visited:\n                s.append(child)\n                order.append(child)\n        if len(order) != 0:\n            stack_order.append((curr, order))\n\n  \n    while len(stack_order) != 0:\n        curr = stack_order.pop()\n        for child in curr[1]:\n            sub_count[curr[0]] += sub_count[child]\n            sub_checks[curr[0]] |= sub_checks[child]\n\ngraph = defaultdict(list)\nfor _ in range(n - 1):\n    edge = list(map(int, input().split()))\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\ndfs(y, x, graph)\n\n# Note that branch that contains x has a exception, all nodes from y to x should also count as possible paths so we exclude them\n# In order to do that we keep track of which nodes belong the branch with x with sub_checks array\nexclude = 0\nfor child in graph[y]:\n    if sub_checks[child]:\n        exclude = sub_count[y] - sub_count[child]\n        break\n\nprint(n * (n - 1) - (exclude * sub_count[x]))\n", "from itertools import combinations,permutations\nfrom collections import defaultdict\nimport math\nimport sys\nimport os\n\ngraph=defaultdict(list)\n\ndef solution(n,flo,bee):\n\n    cleverBrute=[0]*(n+1)\n    visited=[0]*(n+1)\n    q=[]\n    cutNode=0\n    for elem in graph[flo]:\n        if elem != bee:\n            q.append([elem, elem])\n        else:\n            cutNode=elem\n\n    visited[flo]=1\n    while q:\n        temp=q.pop()\n        currentFrom,currentTo=temp[0],temp[1]\n        visited[currentFrom]=1\n        cleverBrute[currentTo]+=1\n        for elem in graph[currentFrom]:\n            if not visited[elem]:\n                if elem != bee:\n                    q.append([elem, currentTo])\n                else:\n                    cutNode=currentTo\n\n    \"print(cleverBrute)\"\n    \"print(sum(cleverBrute),cleverBrute[cutNode])\"\n    return (sum(cleverBrute)+1-cleverBrute[cutNode])*(n-(sum(cleverBrute)+1))\n\n\ndef main():\n\n    n,x,y=map(int,input().strip().split())\n    for _ in range(n-1):\n        u,v=map(int,input().strip().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    print(n*(n-1)-(solution(n,x,y)))\n\n\ndef __starting_point():\n    main()\n\n\n\"\"\"\n\n3 1 3\n1 2\n2 3\n\n3 1 3\n1 2\n1 3\n\n\"\"\"\n__starting_point()", "from collections import defaultdict\n \nn, x, y = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n-1)]\nchk = [False] * (n+1)\ncnt = [1] * (n+1)\nadj = defaultdict(list)\n \nfor u, v in edges:\n    adj[u].append(v)\n    adj[v].append(u)\n \ndef dfs(y, x, adj):\n    vis = set()\n    stk = [y]\n    stack_order = []\n    while stk:\n        u = stk.pop()\n        vis.add(u)\n        if u == x:\n            chk[u] = True\n        order = []\n        for v in adj[u]:\n            if v not in vis:\n                stk.append(v)\n                order.append(v)\n        if order:\n            stack_order.append((u, order))\n \n    while stack_order:\n        u = stack_order.pop()\n        for v in u[1]:\n            cnt[u[0]] += cnt[v]\n            chk[u[0]] |= chk[v]\n \ndfs(y, x, adj)\nres = 0\nfor i in adj[y]:\n    if chk[i]:\n        res = cnt[y] - cnt[i]\n        break\n \nprint(n*(n-1) - (res*cnt[x]))", "from collections import defaultdict\n\nn,x,y = list(map(int,input().split()))\ngraph = defaultdict(list)\nvis = [False for i in range(n+1)]\nmat = [False for i in range(n+1)]\nsubtree = [0 for i in range(n+1)]\n\nfor i in range(n-1):\n\tu,v = list(map(int,input().split()))\n\tgraph[u].append(v)\n\tgraph[v].append(u)\nq = []\ncur = 0\nfor v in graph[x]:\n\tif v!=y:\n\t\tq.append([v,v])\n\telse:\n\t\tcur = v\nvis[x] = 1\nwhile q!=[]:\n\ttemp = q.pop()\n\tu,v = temp\n\tvis[u] = True\n\tsubtree[v]+=1\n\tfor node in graph[u]:\n\t\tif vis[node]==False:\n\t\t\tif node!=y:\n\t\t\t\tq.append([node,v])\n\t\t\telse:\n\t\t\t\tcur = v\nval = sum(subtree)\nval1 = (val+1-subtree[cur])\nval2 = n-(sum(subtree)+1)\nval = val1*val2\nprint(n*(n-1)-val)", "from collections import defaultdict\n \nn,x,y = list(map(int,input().split()))\ngraph = defaultdict(list)\nvis = [False for i in range(n+1)]\nmat = [False for i in range(n+1)]\nsubtree = [0 for i in range(n+1)]\n \nfor i in range(n-1):\n\tu,v = list(map(int,input().split()))\n\tgraph[u].append(v)\n\tgraph[v].append(u)\nq = []\ncur = 0\nfor v in graph[x]:\n\tif v!=y:\n\t\tq.append([v,v])\n\telse:\n\t\tcur = v\nvis[x] = 1\nwhile q!=[]:\n\ttemp = q.pop()\n\tu,v = temp\n\tvis[u] = True\n\tsubtree[v]+=1\n\tfor node in graph[u]:\n\t\tif vis[node]==False:\n\t\t\tif node!=y:\n\t\t\t\tq.append([node,v])\n\t\t\telse:\n\t\t\t\tcur = v\nval = sum(subtree)\nval1 = (val+1-subtree[cur])\nval2 = n-(sum(subtree)+1)\nval = val1*val2\nprint(n*(n-1)-val)", "import sys\nfrom collections import deque \ndef get_roots_direct_children(q,roots_direct_children,visited,edges):\n\twhile q:\n\t\troot = q.popleft()\n\n\t\tvisited[root] = True \n\n\t\troot_direct_children = list()\n\n\t\tfor vertice in edges[root]:\n\t\t\tif not visited[vertice]:\n\t\t\t\tq.appendleft(vertice)\n\t\t\t\tvisited[vertice] = True \n\t\t\t\troot_direct_children.append(vertice)\n\n\t\troots_direct_children.append((root,root_direct_children))\n\n\ndef get_cnt(cnt,roots_direct_children):\n\twhile roots_direct_children:\n\t\tcur_tuple = roots_direct_children.pop()\n\t\troot = cur_tuple[0]\n\t\tdirect_children = cur_tuple[1]\n\t\tfor direct_child in direct_children:\n\t\t\tcnt[root] += cnt[direct_child]\n\n\ndef solve():\n\tinput = sys.stdin.readline\n\tn,x,y = map(int,input().split())\n\n\tedges = {vertice:list() for vertice in range(1,n+1)}\n\tfor i in range(n-1):\n\t\tuv = input().split()\n\t\tu = int(uv[0])\n\t\tv = int(uv[1])\n\t\tedges[u].append(v)\n\t\tedges[v].append(u)\n\n\tcnt = [1 for _ in range(n+1)]\n\tvisited = [False for _ in range(n+1)]\n\n\tq = deque()\n\tq.append(x)\n\troots_direct_children = list()\n\n\tget_roots_direct_children(q,roots_direct_children,visited,edges)\n\tget_cnt(cnt,roots_direct_children)\n\n\tcnt_y = cnt[y]\n\n\tq = deque()\n\tq.append(y)\n\troots_direct_children = list()\n\tcnt = [1 for _ in range(n+1)]\n\tvisited = [False for _ in range(n+1)]\n\n\tget_roots_direct_children(q,roots_direct_children,visited,edges)\n\tget_cnt(cnt,roots_direct_children)\n\n\tcnt_x = cnt[x]\n\n\ttotal = n*(n-1)\n\tnot_ok_routes = cnt_x * cnt_y\t\n\tresult = total - not_ok_routes \n\n\tprint(result)\n\nsolve()", "\nimport sys\nimport threading\nfrom collections import defaultdict\n\nn,x,y=list(map(int,input().split()))\nadj=defaultdict(list)\nfor _ in range(n-1):\n    a,b=list(map(int,input().split()))\n    adj[a].append(b)\n    adj[b].append(a)\n    \n    \n    \ndef fun(node,par,dest,ans):\n    cnt=1\n    for ch in adj[node]:\n        if ch != par:\n              cnt+=fun(ch,node,dest,ans)\n    if node==dest:\n        ans[0]=cnt*ans[0]\n    return cnt\n \n \n\n\n\ndef main():\n    ans=[1]\n    t=fun(x,0,y,ans)\n    fun(y,0,x,ans)\n    print(t*(t-1)-ans[0])\ndef __starting_point():\n    sys.setrecursionlimit(10**6)\n    threading.stack_size(10**8)\n    t = threading.Thread(target=main)\n    t.start()\n    t.join() \n__starting_point()", "# from debug import debug\nimport sys; input = sys.stdin.readline\nfrom collections import deque\n\nn, x, y = list(map(int, input().split()))\nx-=1; y-=1\ngraph = [[] for i in range(n)]\nfor i in range(n-1):\n\ta, b = list(map(int, input().split()))\n\tgraph[a-1].append(b-1)\n\tgraph[b-1].append(a-1)\nparent = [-1]*n\nq = deque([x])\nwhile q:\n\tnode = q.popleft()\n\tif node == y: break\n\tfor i in graph[node]:\n\t\tif i == parent[node]: continue\n\t\tparent[i] = node\n\t\tq.append(i)\nnode = y\ny_ = parent[y]\nwhile parent[node] != x: node = parent[node]\nparent = [-1]*n\nparent[x] = node\nparent[y] = y_\na, b = 0, 0\nq = deque([x])\nwhile q:\n\tnode = q.popleft()\n\ta+=1\n\tfor i in graph[node]:\n\t\tif i == parent[node]: continue\n\t\tparent[i] = node\n\t\tq.append(i)\nq = deque([y])\nwhile q:\n\tnode = q.popleft()\n\tb+=1\n\tfor i in graph[node]:\n\t\tif i == parent[node]: continue\n\t\tparent[i] = node\n\t\tq.append(i)\n\nans = n*(n-1) - a*b\nprint(ans)\n"]