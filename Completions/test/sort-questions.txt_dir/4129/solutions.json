["\nfrom queue import Queue\nfrom random import shuffle\nimport sys\nimport math\nimport os.path\n\n\nsys.setrecursionlimit(100000)\n\n# LOG\n\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\n\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef toMapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\n\n# SORT\ndef sortId(arr):\n    return sorted(range(len(arr)), key=lambda k: arr[k])\n\n\n# MAIN\n\nn,m,s = ni()\n\ns -= 1\n\nadj = [[] for _ in range(n)]\n\nfor i in range(m):\n    u,v = nio(-1)\n    if (v != s):\n        adj[u].append(v)\n\nstack = []\n\nvisited= [False]*n\n\ndef dfs(x):\n    nonlocal visited\n    nonlocal stack\n    visited[x] = True\n    for y in adj[x]:\n        if not visited[y]:\n            dfs(y)\n\n    stack.append(x)\n\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i)\n\n# log(adj)\n# log(visited)\n# log(stack)\n\ncount = -1\n\ndef loang(x):\n    nonlocal visited\n    visited[x] = False\n    for y in adj[x]:\n        if visited[y]:\n            loang(y)\n\n\nfor x in stack[::-1]:\n    if visited[x]:\n        count += 1\n        loang(x)\n\nprint(count)", "\nfrom queue import Queue\nfrom random import shuffle\nimport sys\nimport math\nimport os.path\n\n\nsys.setrecursionlimit(10**9)\n\n# LOG\n\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\n\ndef ni():\n    return map(int, input().split())\n\n\ndef nio(offset):\n    return map(lambda x: int(x) + offset, input().split())\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef toMapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\n\n# SORT\ndef sortId(arr):\n    return sorted(range(len(arr)), key=lambda k: arr[k])\n\n\n# MAIN\n\nn,m,s = ni()\n\ns -= 1\n\nadj = [[] for _ in range(n)]\n\nfor i in range(m):\n    u,v = nio(-1)\n    if (v != s):\n        adj[u].append(v)\n\nstack = []\n\nvisited= [False]*n\n\ndef dfs(x):\n    nonlocal visited\n    nonlocal stack\n    visited[x] = True\n    for y in adj[x]:\n        if not visited[y]:\n            dfs(y)\n\n    stack.append(x)\n\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i)\n\n# log(adj)\n# log(visited)\n# log(stack)\n\ncount = -1\n\ndef loang(x):\n    nonlocal visited\n    visited[x] = False\n    for y in adj[x]:\n        if visited[y]:\n            loang(y)\n\n\nfor x in stack[::-1]:\n    if visited[x]:\n        count += 1\n        loang(x)\n\nprint(count)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(1000000)\n\nn, m, s = list(map(int, input().split()))\ns = s - 1\n\n\ndef read_graph():\n    g = defaultdict(list)\n    for _ in range(m):\n        (u, v) = [int(x) - 1 for x in input().split()]\n        if v != s:\n            g[u].append(v)\n    return g\n\n\nG = read_graph()\nvis = defaultdict(lambda: False)\ntopo = []\n\n\ndef dfs(u):\n    # print(u)\n    for v in G[u]:\n        if not vis[v]:\n            vis[v] = True\n            dfs(v)\n    topo.append(u)\n\n\nfor i in range(n):\n    if not vis[i]:\n        vis[i] = True\n        dfs(i)\n\nvis.clear()\nvis[s] = True\ndfs(s)\nans = 0\nfor i in topo[::-1]:\n    if not vis[i]:\n        vis[i] = True\n        ans += 1\n        dfs(i)\n\nprint(ans)\n", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(1000000)\n\nn, m, s = list(map(int, input().split()))\ns = s - 1\n\n\ndef read_graph():\n    g = defaultdict(list)\n    for _ in range(m):\n        (u, v) = [int(x) - 1 for x in input().split()]\n        # if v != s:\n        g[u].append(v)\n    return g\n\n\nG = read_graph()\nvis = defaultdict(lambda: False)\ntopo = []\n\n\ndef dfs(u):\n    # print(u)\n    for v in G[u]:\n        if not vis[v]:\n            vis[v] = True\n            dfs(v)\n    topo.append(u)\n\n\nfor i in range(n):\n    if not vis[i]:\n        vis[i] = True\n        dfs(i)\n\nvis.clear()\nvis[s] = True\ndfs(s)\nans = 0\nfor i in topo[::-1]:\n    if not vis[i]:\n        vis[i] = True\n        ans += 1\n        dfs(i)\n\nprint(ans)\n", "import sys\n\n\ndef dfs(u):\n    avail[u] = False\n    for v in g[u]:\n        if avail[v]:\n            dfs(v)\n    topo.append(u)\n\n\nsys.setrecursionlimit(6000)\nn, m, s = map(int, input().split())\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    g[u - 1].append(v - 1)\navail, topo = [True] * n, []\nfor i,a in enumerate(avail):\n    if a:\n        dfs(i)\navail, res = [True] * n, 0\ndfs(s - 1)\nfor i in reversed(topo):\n    if avail[i]:\n        res += 1\n        dfs(i)\nprint(res)", "import sys\n\nN = 5000 + 5\nadj = [[] for i in range(N)]\nmark = [0 for i in range(N)]\ntopo = []\nsys.setrecursionlimit(6000)\n#fin = open(\"999E.inp\", \"r\")\n#fou = open(\"999E.out\", \"w\")\n#n, m, s = map(int, fin.readline().split())\nn, m, s = list(map(int, input().split()))\nfor i in range(m):\n\t#u, v = map(int, fin.readline().split())\n\tu, v = list(map(int, input().split()))\n\tadj[u].append(v)\n\ndef topoSort(u):\n\tmark[u] = 1\n\tfor j in range(len(adj[u])):\n\t\tv = adj[u][j]\n\t\tif (mark[v] == 0): topoSort(v)\n\ttopo.append(u)\n\ndef dfs(u):\n\tmark[u] = 1\n\tfor j in range(len(adj[u])):\n\t\tv = adj[u][j]\n\t\tif (mark[v] == 0): dfs(v)\n\nfor i in range(1, n+1):\n\tif (mark[i] == 0):\n\t\ttopoSort(i)\ntopo.reverse()\nfor i in range(1, n+1):\n\tmark[i] = 0\ndfs(s)\nres = 0\nfor i in range(n):\n\tv = topo[i]\n\tif (mark[v] == 0):\n\t\tres += 1\n\t\tdfs(v)\n#fou.write(str(res))\nprint(res)\n\n", "from collections import defaultdict\nimport sys\ndef dfs(u):\n    avail[u] = False\n    for v in g[u]:\n        if avail[v]:\n            dfs(v)\n    topo.append(u)\n\n\nsys.setrecursionlimit(6000)\nn, m, s = map(int, input().split())\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    g[u - 1].append(v - 1)\n\navail, topo = [True] * n, []\nfor i,a in enumerate(avail):\n    if a:\n        dfs(i)\navail, res = [True] * n, 0\ndfs(s - 1)\nfor i in reversed(topo):\n    if avail[i]:\n        res += 1\n        dfs(i)\nprint(res)", "import sys\n\nn, m, s = list(map(int, input().split()))\n\nadj = [[] for i in range(500005)]\nar = []\nvis = [0 for i in range(500005)]\nsys.setrecursionlimit(6000)\n\ndef dfs(s):\n    vis[s] = 1\n    for i in range(len(adj[s])):\n        if(vis[adj[s][i]] == 0):\n            dfs(adj[s][i])\n    ar.append(s)\n\n\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    adj[u].append(v)\n\ndfs(s)\n\nfor i in range(n):\n    if(vis[i + 1] == 0):\n        dfs(i + 1)\nres = 0\nvis = [0 for i in range(500005)]\nfor i in range(n - 1, -1, -1):\n    if(vis[ar[i]] == 0):\n        if(s != ar[i]):\n            res += 1\n        dfs(ar[i])\n\nprint(res)\n", "import sys\n\nn, m, s = list(map(int, input().split()))\n\nadj = [[] for _ in range(500005)]\nar = []\nvis = [0] * 500005\nsys.setrecursionlimit(6000)\n\ndef dfs(s):\n    vis[s] = 1\n    for i in range(len(adj[s])):\n        if(vis[adj[s][i]] == 0):\n            dfs(adj[s][i])\n    ar.append(s)\n\n\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    adj[u].append(v)\n\ndfs(s)\n\nfor i in range(n):\n    if(vis[i + 1] == 0):\n        dfs(i + 1)\nres = 0\nvis = [0] * 500005\nfor i in range(n - 1, -1, -1):\n    if(vis[ar[i]] == 0):\n        if(s != ar[i]):\n            res += 1\n        dfs(ar[i])\n\nprint(res)\n", "import sys\n\nBigNum = 10 ** 10\n\nclass DSU:\n    def __init__(self, count, stateInitializer, stateMerger):\n        self.vs = list(range(count))\n        self.states = [stateInitializer(i) for i in range(count)]\n        self.sizes = [1] * count\n        self.merger = stateMerger\n    \n    def get(self, i):\n        if self.vs[i] == i:\n            return i\n        else:\n            res = self.get(self.vs[i])\n            self.vs[i] = res\n            return res\n\n    def getState(self, i):\n        return self.states[self.get(i)]\n    \n    def setState(self, i, newState):\n        i = self.get(i)\n        self.states[i] = newState\n    \n    def unite(self, a, b):\n        a = self.get(a)\n        b = self.get(b)\n        if a == b:\n            return a\n\n        mergedState = self.merger(self.states[a], self.states[b])\n        if self.sizes[a] >= self.sizes[b]:\n            self.vs[b] = a\n            self.sizes[a] += self.sizes[b]\n            self.states[a] = mergedState\n            return a\n        else:\n            self.vs[a] = b\n            self.sizes[b] += self.sizes[a]\n            self.states[b] = mergedState\n            return b\n    \n    def flatten(self):\n        for i in range(len(self.vs)):\n            self.get(i)\n    \n    def setNames(self):\n        self.flatten()\n        return set(self.vs)\n\nn, m, s = list(map(int, input().split(' ')))\nps = [[] for _ in range(n+1)]\nedges = []\nfor i in range(m):\n    u, v = list(map(int, input().split(' ')))\n    ps[v] += [u]\n    edges += [(u, v)]\n\ndsu = DSU(\n    n+1,\n    lambda i: (0, BigNum),\n    lambda a, b: (min(a[0], b[0]), min(a[1], b[1]))\n)\n\ndef dfs(v, depth):\n    vSt = dsu.getState(v)\n    vState, vMinDepth = vSt\n\n    if vState >= 1:\n        raise 'Not supposed to dfs processed node!'\n\n    vState = 1\n    vMinDepth = depth\n    dsu.setState(v, (vState, vMinDepth))\n\n    for nv in ps[v]:\n        #print(':', v, nv)\n        nvSt = dsu.getState(nv)\n        nvState, nvMinDepth = nvSt\n\n        if nvState == 2:\n            continue\n        if nvState == 1:\n            if nvMinDepth < vMinDepth:\n                vMinDepth = nvMinDepth\n                dsu.setState(v, (vState, vMinDepth))\n        else:\n            nvMinDepth = dfs(nv, depth + 1)\n            if nvMinDepth <= depth:\n                dsu.unite(v, nv)\n\n            if nvMinDepth < vMinDepth:\n                vMinDepth = nvMinDepth\n                dsu.setState(v, (vState, vMinDepth))\n\n    if depth <= vMinDepth:\n        vState = 2\n        dsu.setState(v, (vState, vMinDepth))\n\n    return vMinDepth\n\n\nsys.setrecursionlimit(12000)\n\nfor i in range(1, n+1):\n    st = dsu.getState(i)\n    if st[0] == 0:\n        dfs(i, 0)\n\ncomponents = dsu.setNames().difference({0})\n#print(dsu.vs)\n#print(components)\n\ncomponents = components.difference({ dsu.get(s) })\nfor (u, v) in edges:\n    u, v = dsu.get(u), dsu.get(v)\n    if u == v:\n        continue\n    components = components.difference({ v })\n\n#print(components)\nprint(len(components))\n", "import sys\n\nBigNum = 10 ** 10\n\nclass DSU:\n    def __init__(self, count, stateInitializer, stateMerger):\n        self.vs = list(range(count))\n        self.states = [stateInitializer(i) for i in range(count)]\n        self.sizes = [1] * count\n        self.merger = stateMerger\n    \n    def get(self, i):\n        if self.vs[i] == i:\n            return i\n        else:\n            res = self.get(self.vs[i])\n            self.vs[i] = res\n            return res\n\n    def getState(self, i):\n        return self.states[self.get(i)]\n    \n    def setState(self, i, newState):\n        i = self.get(i)\n        self.states[i] = newState\n    \n    def unite(self, a, b):\n        a = self.get(a)\n        b = self.get(b)\n        if a == b:\n            return a\n\n        mergedState = self.merger(self.states[a], self.states[b])\n        if self.sizes[a] >= self.sizes[b]:\n            self.vs[b] = a\n            self.sizes[a] += self.sizes[b]\n            self.states[a] = mergedState\n            return a\n        else:\n            self.vs[a] = b\n            self.sizes[b] += self.sizes[a]\n            self.states[b] = mergedState\n            return b\n    \n    def flatten(self):\n        for i in range(len(self.vs)):\n            self.get(i)\n    \n    def setNames(self):\n        self.flatten()\n        return set(self.vs)\n\nn, m, s = list(map(int, input().split(' ')))\nps = [[] for _ in range(n+1)]\nedges = []\nfor i in range(m):\n    u, v = list(map(int, input().split(' ')))\n    ps[v] += [u]\n    edges += [(u, v)]\n\ndsu = DSU(\n    n+1,\n    lambda i: (0, BigNum),\n    lambda a, b: (min(a[0], b[0]), min(a[1], b[1]))\n)\n\ndef dfs(v, depth):\n    vSt = dsu.getState(v)\n    vState, vMinDepth = vSt\n\n    if vState >= 1:\n        raise 'Not supposed to dfs processed node!'\n\n    vState = 1\n    vMinDepth = depth\n    dsu.setState(v, (vState, vMinDepth))\n\n    for nv in ps[v]:\n        #print(':', v, nv)\n        nvSt = dsu.getState(nv)\n        nvState, nvMinDepth = nvSt\n\n        if nvState == 2:\n            continue\n        if nvState == 1:\n            if nvMinDepth < vMinDepth:\n                vMinDepth = nvMinDepth\n                dsu.setState(v, (vState, vMinDepth))\n        else:\n            nvMinDepth = dfs(nv, depth + 1)\n            if nvMinDepth <= depth:\n                dsu.unite(v, nv)\n\n            if nvMinDepth < vMinDepth:\n                vMinDepth = nvMinDepth\n                dsu.setState(v, (vState, vMinDepth))\n\n    if depth <= vMinDepth:\n        vState = 2\n        dsu.setState(v, (vState, vMinDepth))\n\n    return vMinDepth\n\n\nsys.setrecursionlimit(6000)\n\nfor i in range(1, n+1):\n    st = dsu.getState(i)\n    if st[0] == 0:\n        dfs(i, 0)\n\ncomponents = dsu.setNames().difference({0})\n#print(dsu.vs)\n#print(components)\n\ncomponents = components.difference({ dsu.get(s) })\nfor (u, v) in edges:\n    u, v = dsu.get(u), dsu.get(v)\n    if u == v:\n        continue\n    components = components.difference({ v })\n\n#print(components)\nprint(len(components))\n", "import sys\n\n\ndef d(u):\n    rt[u] = False\n    for v in q[u]:\n        if rt[v]:\n            d(v)\n    topo.append(u)\n\n\nsys.setrecursionlimit(6000)\nn, m, s = map(int, input().split())\nq = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    q[u - 1].append(v - 1)\nrt, topo = [True] * n, []\nfor i,a in enumerate(rt):\n    if a:\n        d(i)\nrt, res = [True] * n, 0\nd(s - 1)\nfor i in reversed(topo):\n    if rt[i]:\n        res += 1\n        d(i)\nprint(res)", "import sys\nsys.setrecursionlimit(6000)\n\nn, m, s = map(int, input().split())\ns -= 1\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    g[a-1].append(b-1)\n\nused = [False] * 5010\ntopo = []\n\ndef topo_sort(node):\n    used[node] = True\n    for c in g[node]:\n        if not used[c]:\n            topo_sort(c)\n    topo.append(node)\n\ndef dfs(node):\n    used[node] = True\n    for c in g[node]:\n        if not used[c]:\n            dfs(c)\n\nfor i in range(n):\n    if not used[i]:\n        topo_sort(i)\n\ntopo.reverse()\nfor i in range(n):\n    used[i] = False\n\ndfs(s)\nres = 0\nfor v in topo:\n    if not used[v]:\n        res += 1\n        dfs(v)\n\nprint(res)", "from collections import deque\nimport sys\nsys.setrecursionlimit(1000000)\n \n\nn, m, s = [int(x) for x in input().split()]\nadj = [[] for u in range(n + 1)]\nvis = [False for u in range(n + 1)]\nfor i in range(m):\n    u, v = [int(x) for x in input().split()]\n    adj[u].append(v)\n\ndef tarjan():\n    low = [-1 for u in range(n + 1)]\n    disc = [-1 for v in range(n + 1)]\n    in_stack = [False for v in range(n + 1)]\n    st = deque()\n    comp = []\n\n    def dfs(u):\n        dfs.dfs_time = dfs.dfs_time + 1\n        low[u] = dfs.dfs_time\n        disc[u] = dfs.dfs_time\n        in_stack[u] = True\n        st.append(u)\n\n        for v in adj[u]:\n            if disc[v] == -1:\n                dfs(v)\n                low[u] = min(low[u], low[v])\n            elif in_stack[v]:\n                low[u] = min(low[u], disc[v])\n\n        if low[u] == disc[u]:\n            comp.append([])\n            while u != st[-1]:\n                x = st.pop()\n                in_stack[x] = False\n                comp[-1].append(x)\n            x = st.pop()\n            in_stack[x] = False\n            comp[-1].append(x)\n\n    dfs.dfs_time = 0\n    for i in range(1, n + 1):\n        if disc[i] == -1:\n            dfs(i)\n\n    return comp[::-1]\n\ndef visit(adj, vis, src):\n    q = deque()\n    q.append(src)\n    vis[src] = True\n    while len(q) > 0: \n        u = q.popleft()\n        for v in adj[u]:\n            if vis[v] == False:\n                vis[v] = True\n                q.append(v)\n    \nans = 0\nvisit(adj, vis, s)\ntarOrd = tarjan()\nfor lis in tarOrd:\n    x = lis[0]\n    if vis[lis[0]] == False:\n        visit(adj, vis, x)\n        ans += 1\n\nprint(ans)\n\n\n\n", "from bisect import bisect\nfrom collections import defaultdict\n# l = list(map(int,input().split()))\n# map(int,input().split()))\nfrom math import gcd,sqrt,ceil\nfrom collections import Counter\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef dfs(n):\n    b[n] =True\n\n    for i in hash[n]:\n        if b[i] == False:\n            dfs(i)\n\n    top.append(n)\nn,m,s = list(map(int,input().split()))\n\nhash = defaultdict(list)\n\nfor i in range(m):\n    a,b = list(map(int,input().split()))\n    hash[a].append(b)\n\nb = [False]*(n+1)\ntop = []\nfor i in range(1,n+1):\n    if not b[i]:\n        dfs(i)\nb = [False]*(n+1)\ndfs(s)\ntop.reverse()\ncount = 0\nfor i in top:\n    if not b[i]:\n        count+=1\n        dfs(i)\n\nprint(count)\n\n", "import sys\ninput = sys.stdin.readline\n\nn, m, s = list(map(int, input().split()))\ns -= 1\nadj = [[] for _ in range(n)]\nrev = [[] for _ in range(n)]\n\nfor u, v in (list(map(int, input().split())) for _ in range(m)):\n    adj[u-1].append(v-1)\n    rev[v-1].append(u-1)\n\ngroup = [-1]*n\ngroup[s] = 0\nstack = [s]\n\nwhile stack:\n    v = stack.pop()\n    for dest in adj[v]:\n        if group[dest] != -1:\n            continue\n        group[dest] = 0\n        stack.append(dest)\n\ng = 0\nfor i in range(n):\n    if group[i] != -1 or rev[i]:\n        continue\n    g += 1\n    group[i] = g\n    stack = [i]\n\n    while stack:\n        v = stack.pop()\n        for dest in adj[v]:\n            if group[dest] != -1:\n                continue\n            group[dest] = g\n            stack.append(dest)\n\nfor i in range(n):\n    if group[i] != -1:\n        continue\n    g += 1\n    group[i] = g\n    stack = [i]\n\n    while stack:\n        v = stack.pop()\n        for dest in adj[v]:\n            if group[dest] == 0 or group[dest] == g:\n                continue\n            group[dest] = g\n            stack.append(dest)\n\nprint(len(set(group)) - 1)\n", "import sys\ninput = sys.stdin.readline\n\nn, m, s = list(map(int, input().split()))\ns -= 1\nadj = [[] for _ in range(n)]\nrev = [[] for _ in range(n)]\n\nfor u, v in (list(map(int, input().split())) for _ in range(m)):\n    adj[u-1].append(v-1)\n    rev[v-1].append(u-1)\n\ngroup = [-1]*n\ng = 0\ngroup[s] = g\nstack = [s]\n\nwhile stack:\n    v = stack.pop()\n    for dest in adj[v]:\n        if group[dest] != -1:\n            continue\n        group[dest] = g\n        stack.append(dest)\n\n\nfor i in range(n):\n    if group[i] != -1:\n        continue\n    g += 1\n    group[i] = g\n    stack = [i]\n\n    while stack:\n        v = stack.pop()\n        for dest in adj[v]:\n            if group[dest] == 0 or group[dest] == g:\n                continue\n            group[dest] = g\n            stack.append(dest)\n\nprint(len(set(group)) - 1)\n", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import Counter\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef bfs(nodes, src):\n    from collections import deque\n\n    que = deque([(src, 0)])\n    dist[src][src] = 1\n    while que:\n        u, c = que.popleft()\n        for v in nodes[u]:\n            if dist[src][v]:\n                continue\n            dist[src][v] = 1\n            que.append((v, c+1))\n\nN, M, s = MAP()\ns -= 1\n\nnodes = [[] for i in range(N)]\nfor _ in range(M):\n    a, b = MAP()\n    a -= 1; b -= 1\n    nodes[a].append(b)\n\ndist = list2d(N, N, 0)\nfor i in range(N):\n    bfs(nodes, i)\n\nneed = []\nfor v in range(N):\n    if not dist[s][v]:\n        need.append((dist[v].count(1), v))\nneed.sort(reverse=1)\n\ndone = [False] * N\nans = 0\nfor _, u in need:\n    if not done[u]:\n        for v, can in enumerate(dist[u]):\n            if can:\n                done[v] = True\n        ans += 1\nprint(ans)\n", "from collections import defaultdict\n\ndef topo_sort_variant(graph, n):\n    result = []\n    visited = [False] * (n+1)\n\n    for i in range(1, n+1):\n        if not visited[i]:\n            stack = [i]\n            while stack:\n                node = stack[-1]\n                if not visited[node]:\n                    visited[node] = True\n                    for child in graph[node]:\n                        if not visited[child]:\n                            stack.append(child)\n                else:\n                    result.append(stack.pop())\n    return result\n\n\n\ndef __starting_point():\n    min_roads_required = 0\n    ncities, nroads, capital = map(int, input().split())\n\n    g = defaultdict(list)\n\n    for i in range(nroads):\n        u, v = map(int, input().split())\n        g[u].append(v)\n\n    #print(\"The graph is:\", g)\n    op = topo_sort_variant(g, ncities)\n    #print(\"The topo sort output is\", op)\n\n    visited = [False] * (ncities + 1)\n\n    def topo_dfs(i):\n        stack = [i]\n        while stack:\n            node = stack[-1]\n            if not visited[node]:\n                visited[node] = True\n                for child in g[node]:\n                    if not visited[child]:\n                        stack.append(child)\n            else:\n                stack.pop()\n\n\n    topo_dfs(capital)\n    for i in reversed(topo_sort_variant(g, ncities)):\n        if not visited[i]:\n            topo_dfs(i)\n            min_roads_required += 1\n\n    print(min_roads_required)\n__starting_point()", "import sys\ninput=lambda:sys.stdin.readline().rstrip()\nsys.setrecursionlimit(50000)\n\n# \u5f37\u9023\u7d50\u6210\u5206\u5206\u89e3(SCC): \u30b0\u30e9\u30d5G\u306b\u5bfe\u3059\u308bSCC\u3092\u884c\u3046\n# \u5165\u529b: <N>: \u9802\u70b9\u30b5\u30a4\u30ba, <G>: \u9806\u65b9\u5411\u306e\u6709\u5411\u30b0\u30e9\u30d5, <RG>: \u9006\u65b9\u5411\u306e\u6709\u5411\u30b0\u30e9\u30d5\n# \u51fa\u529b: (<\u30e9\u30d9\u30eb\u6570>, <\u5404\u9802\u70b9\u306e\u30e9\u30d9\u30eb\u756a\u53f7>)\ndef scc(N, G, RG):\n  order = []\n  used = [0]*N\n  group = [None]*N\n  def dfs(s):\n    used[s] = 1\n    for t in G[s]:\n      if not used[t]:\n        dfs(t)\n    order.append(s)\n  def rdfs(s, col):\n    group[s] = col\n    used[s] = 1\n    for t in RG[s]:\n      if not used[t]:\n        rdfs(t, col)\n  for i in range(N):\n    if not used[i]:\n      dfs(i)\n  used = [0]*N\n  label = 0\n  for s in reversed(order):\n    if not used[s]:\n      rdfs(s, label)\n      label += 1\n  return label, group\n\n# \u7e2e\u7d04\u5f8c\u306e\u30b0\u30e9\u30d5\u3092\u69cb\u7bc9\ndef construct(N, G, label, group):\n  G0 = [[] for i in range(label)]\n  GP = [[] for i in range(label)]\n  for v in range(N):\n    lbs = group[v]\n    for w in G[v]:\n      lbt = group[w]\n      if lbs == lbt:\n        continue\n      G0[lbs].append(lbt)\n    GP[lbs].append(v)\n  return G0, GP\n\nn,m,s=map(int,input().split())\ns-=1\nedge=[[]for _ in range(n)]\nredge=[[]for _ in range(n)]\nfor _ in range(m):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  edge[a].append(b)\n  redge[b].append(a)\nlabel,group=scc(n,edge,redge)\na,b=construct(n,redge,label,group)\nans=0\nfor i in range(label):\n  if len(a[i])==0:\n    ans+=(i!=group[s])\nprint(ans)", "def main():\n    import sys\n    sys.setrecursionlimit(10**5)\n    from collections import deque\n    n, m, s = map(int, input().split())\n    s -= 1\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n\n    seen = [False]*n\n    li = deque()\n\n    def visit(node):\n        if not seen[node]:\n            seen[node] = True\n            for c_node in graph[node]:\n                visit(c_node)\n            li.appendleft(node)\n\n    def visit2(node):\n        if not seen[node]:\n            seen[node] = True\n            for c_node in graph[node]:\n                visit2(c_node)\n\n    for i in range(n):\n        visit(i)\n    seen = [False]*n\n    cnt = 0\n    visit2(s)\n    for i in li:\n        if seen[i]:\n            continue\n        visit2(i)\n        cnt += 1\n    print(cnt)\n\ndef __starting_point():\n    try:\n        main()\n    except:\n        print('error!')\n        return\n__starting_point()", "import sys\nsys.setrecursionlimit(10**5)\nfrom collections import deque\nn, m, s = map(int, input().split())\ns -= 1\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u-1].append(v-1)\n\nseen = [False]*n\nli = deque()\ndef visit(node):\n    if not seen[node]:\n        seen[node] = True\n        for c_node in graph[node]:\n            visit(c_node)\n        li.appendleft(node)\nfor i in range(n):\n    visit(i)\nseen = [False]*n\ncnt = 0\nli2 = list(li)\nvisit(s)\nfor i in li2:\n    if seen[i]:\n        continue\n    visit(i)\n    cnt += 1\nprint(cnt)"]