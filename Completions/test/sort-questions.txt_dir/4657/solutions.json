["from sys import stdin\nc=int(stdin.readline().strip())\nfor cas in range(c):\n    n,m=list(map(int,stdin.readline().strip().split()))\n    s=list(map(int,stdin.readline().strip().split()))\n    sm=0\n    ans=[]\n    ind=-1\n    for i in range(n):\n        if m==1:\n            ind=i\n            break\n        sm+=s[i]\n        if sm%2!=0:\n            ans.append(i+1)\n            sm=0\n            m-=1\n    if ind==-1:\n        print(\"NO\")\n        continue\n    sm=sum(s[ind::])\n    if sm%2!=0:\n        ans.append(n)\n        print(\"YES\")\n        print(*ans)\n    else:\n        print(\"NO\")\n\n    \n\n", "def main():\n    import sys\n    input = sys.stdin.readline\n    \n    def solve():\n        n, k = map(int, input().split())\n        arr = list(map(int, input().split()))\n        curr = 0\n        ans = []\n        for i in range(n):\n            curr += arr[i]\n            if curr & 1:\n                curr = 0\n                ans.append(i + 1)\n        if len(ans) < k or ((len(ans) - k) & 1):\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(*(ans[:k-1]+[n]))\n        \n    \n    for _ in range(int(input())):\n        solve()\n    \n    return 0\n\nmain()", "import sys\ninput = sys.stdin.readline\n\nq=int(input())\n\nfor testcases in range(q):\n    n,k=list(map(int,input().split()))\n    A=list(map(int,input().split()))\n\n    if sum(A)%2!=k%2:\n        print(\"NO\")\n        continue\n\n    ANS=[]\n    SUM=0\n    for i in range(n):\n        SUM+=A[i]\n        if SUM%2==1:\n            ANS.append(i+1)\n            SUM=0\n\n    if len(ANS)>=k-1:\n        print(\"YES\")\n        ANS0=ANS[:k-1]+[n]\n        print(*ANS0)\n\n    else:\n        print(\"NO\")\n\n        \n        \n", "'''input\n3\n5 3\n7 18 3 14 1\n5 4\n1 2 3 4 5\n6 2\n1 2 8 4 10 2\n\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nfrom  heapq import heappush as hpush\nfrom heapq import heappop as hpop\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\nfor _ in range(int(input())):\n\tn,k = ri()\n\ta= ri()\n\tsu =[0]\n\tfor i in a:\n\t\tsu.append(su[-1]+i)\n\tans =[]\n\tpre=0\n\tfor i in range(len(a)):\n\t\tpre+=a[i]\n\t\tif len(ans) != k-1 and pre%2 ==1:\n\t\t\tans.append(i+1)\n\t\t\tpre=0\n\tif pre %2 ==1:\n\t\tans.append(n)\n\t\tpre=0\n\n\tif pre !=0 or len(ans)!=k:\n\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"YES\")\n\t\tprint(*ans)\n", "import sys\ninput = lambda: sys.stdin.readline().strip()\n\nT = int(input())\nfor i in range(T):\n    n, k = map(int, input().split())\n    ls = list(map(int, input().split()))\n    odd = 0\n    for i in ls:\n        if i%2: odd+=1\n    if (odd-k)<0 or (odd-k)%2: print(\"NO\")\n    else:\n        print(\"YES\")\n        cnt = 0\n        for i in range(n):\n            if cnt==k-1: break\n            if ls[i]%2: print(i+1, end=\" \"); cnt+=1\n        print(n)\n", "for _ in range(int(input())):\n    n,k=list(map(int,input().split()))\n    arr=list(map(int,input().split()))\n    if k==1 and sum(arr)%2:\n        print(\"YES\")\n        print(n)\n        continue\n    elif k==1:\n        print(\"NO\")\n        continue\n    ans=[]\n    tot=0\n    for ind,i in enumerate(arr):\n        tot+=i\n        if tot%2:\n            k-=1\n            ans.append(ind+1)\n            tot=0\n            if not k:\n                break\n    if tot!=0 and tot%2==0 or k!=0:\n        print(\"NO\")\n        continue\n    temp=sum(arr[ans[-2]:])\n    if temp%2:\n        print(\"YES\")\n        ans.pop()\n        for j in ans:\n            print(j,end=\" \")\n        print(n)\n    else:\n        print(\"NO\")", "from sys import stdin\n\nq=int(stdin.readline())\nfor i in range(q):\n    n,k=map(int,stdin.readline().split())\n    arr=list(map(int,stdin.readline().split()))\n    count=0\n    ans=[]\n    s=0\n    for i in range(n):\n        if count!=k-1:    \n            if arr[i]%2!=0:\n                ans.append(i+1)\n                count+=1\n                s=0\n            else:\n                s+=arr[i]\n        else:\n            if sum(arr[i:])%2!=0:\n                ans.append(n)\n            else:\n                pass\n            break\n    if len(ans)!=k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for i in range(k-1):\n            print(ans[i],end=\" \")\n        print(ans[-1])    \n        \n", "q = int(input())\nB = []\nOTVET = []\nfor m in range(q):\n    n, k = list(map(int, input().split()))\n    sttr = list(map(int, input().split()))\n    a = list(sttr)\n    kolvo = 0\n    nechet = []\n    for i in range(n):\n        if a[i] % 2 == 1:\n            kolvo += 1\n            nechet.append(i + 1)\n    #print(kolvo, k)\n    if (kolvo >= k) and ((kolvo - k) % 2 == 0):\n        otsh = []\n        for i in range(k - 1):\n            otsh.append(nechet[i])\n        otsh.append(n)\n        B.append(1)\n        OTVET.append(otsh)\n    else:\n        B.append(0)\nj = 0\nfor i in range(q):\n    if B[i] == 1:\n        print(\"YES\")\n        print(*OTVET[j])\n        j += 1\n    else:\n        print(\"NO\")\n", "import sys\nfor _ in range(int(input())):\n    n,k=list(map(int,sys.stdin.readline().split()))\n    a=list(map(int,sys.stdin.readline().split()))\n    s=sum(a)\n    if (s%2==0 and k%2) or (s%2 and k%2==0):\n        print(\"NO\")\n    else:\n        s=0\n        b=[]\n        i=0\n        j=0\n        while i<k-1 and j<n:\n        # for i in range(k-1):\n            if s%2==0:\n                s+=a[j]\n                j+=1\n            else:\n                b.append(j)\n                s=0\n                i+=1\n        b.append(n)\n        \n        if len(set(b))==k:\n            \n            print(\"YES\")\n            print(*b)\n        else:\n            print(\"NO\")\n                \n                \n        \n", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nimport collections\n \nQ = int(input())\n \n#s = input()\n#N = len(s)\n#arr = [int(x) for x in stdin.readline().split()]\nfor i in range(Q):\n    N,K = [int(x) for x in stdin.readline().split()]\n    arr = [int(x) for x in stdin.readline().split()]\n    \n    odds = 0\n    \n    for i in range(N):\n        if arr[i]%2==1:\n            odds += 1\n            \n    if odds<K:\n        print('NO')\n        continue\n    \n    elif (odds-K)%2==1:\n        print('NO')\n        continue\n    \n    three = (odds-K)//2\n    \n    print('YES')\n    odds = 0\n    if K==1:\n        print(N)\n        continue\n    \n    for i in range(N):\n        if arr[i]%2==1:\n            odds += 1\n        if three>0 and odds!=3:\n            continue\n        elif three>0 and odds==3:\n            K -= 1\n            print(i+1,end=' ')\n            three -= 1\n            odds = 0\n        elif three==0 and odds==1:\n            K -= 1\n            print(i+1,end=' ')\n            odds = 0\n        if K==1:\n            break\n    print(N,end='\\n')\n\n\n\n\n", "t = int(input().strip())\nfor i in range(t):\n    n, k = list(map(int, input().strip().split()))\n    nums = [int(i) for i in input().strip().split()]\n    cur_k = 0\n    ans = []\n    has = True\n    if k == 1:\n        if sum(nums) %2 ==0:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(n)\n    else:\n        for i in range(n):\n            if cur_k == k - 1:\n                if ans[-1] != n:\n                    if sum(nums[ans[-1]:]) % 2 ==0:\n                        has = False\n                        break\n                    else:\n                        cur_k += 1\n                        ans.append(n)\n                        break\n            if nums[i] % 2 == 1:\n                ans.append(i + 1)\n                cur_k += 1\n        #print(\"ans \", ans)\n        if cur_k < k or not has:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(' '.join(str(i) for i in ans))\n        \n", "from sys import stdin\nq = int(stdin.readline())\nfor query in range(q):\n    n, k = list(map(int, stdin.readline().split()))\n    a = list(map(int, stdin.readline().split()))\n    ans = [0]\n    for i in range(n):\n        if k == 1:\n            break\n        if a[i] % 2 == 0:\n            continue\n        ans.append(i + 1)\n        k -= 1\n    if k != 1 or sum(a[ans[-1]:]) % 2 == 0:\n        print(\"NO\")\n        continue\n    print(\"YES\")\n    ans.append(n)\n    print(' '.join(map(str, ans[1:])))\n", "import sys\ninput = sys.stdin.readline\n\nQ = int(input())\n\ndef calc(n, k, X):\n    if (sum(X)-k) % 2:\n        print(\"NO\")\n        return 0\n    ANS = []\n    if k == 1:\n        print(\"YES\")\n        print(n)\n        return 0\n    for i in range(N-1):\n        if X[i] % 2:\n            ANS.append(i+1)\n            if len(ANS) == k-1:\n                print(\"YES\")\n                print(*ANS, n)\n                return 0\n    else:\n        print(\"NO\")\n\nfor _ in range(Q):\n    N, K = list(map(int, input().split()))\n    calc(N, K, [int(a) for a in input().split()])\n", "from bisect import *\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nfrom decimal import *\nfrom copy import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b):\n    return abs(a[0]-b[0])+abs(b[1]-a[1])\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN(x = ' '):\n    return list(map(int,sys.stdin.readline().strip().split(x)))\n\ndef eld(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    meh = 0\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\ndef ncr(n,r):\n    num=den=1\n    for i in range(r):\n        num = (num*(n-i))%MOD\n        den = (den*(i+1))%MOD\n\n    return (num*(pow(den,MOD-2,MOD)))%MOD\n\n\n\ndef flush():\n    return sys.stdout.flush()\n\n'''*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*'''\nfor _ in range(int(input())):\n    n,k = arrIN()\n    a = arrIN()\n    pre = list(accumulate(a))\n    ans = []\n    for i in range(n):\n        if ans:\n            if (pre[i]-pre[ans[-1]])%2:\n                ans.append(i)\n        else:\n            if pre[i]%2:\n                ans.append(i)\n    #print(ans)\n    if len(ans)<k:\n        print('NO')\n    else:\n        if len(ans)==k:\n            print('YES')\n            print(*[i+1 for i in ans[:len(ans)-1]],n)\n        else:\n            ext = len(ans)-k\n            if ext%2:\n                print('NO')\n            else:\n                print('YES')\n                print(*[i+1 for i in ans[:k-1]],n)\n\n\n    \n", "import sys\ninput = sys.stdin.readline\nq = int(input())\nfor i in range(q):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    odd = 0\n    for j in range(n):\n        if a[j] % 2 != 0:\n            odd += 1\n    if odd < k:\n        print('NO')\n    elif odd > k and (odd - k) % 2 != 0:\n        print('NO')\n    else:\n        print('YES')\n        ans = []\n        for j in range(n):\n            if len(ans) == k - 1:\n                ans.append(n)\n                break\n            if a[j] % 2 != 0:\n                ans.append(j + 1)\n        print(*ans)", "from sys import stdin\ninput=stdin.readline\nfor _ in range(int(input())):\n    n,k=list(map(int,input().split()))\n    a=list(map(int,input().split()))\n    ans=[]\n    for i in range(n):\n        if a[i]&1:\n            ans.append(i+1)\n    if len(ans)<k:\n        print(\"NO\")\n    elif (k-len(ans))&1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        ans[-1]=n\n        print(*ans[len(ans)-k:])\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict,deque\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef all_factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(digits-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef generate_primes(n):\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * 2, n+1, p): \n                prime[i] = False\n        p += 1\n    return prime\n\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = True\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = False #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\nfrom math import factorial\n\ndef main():\n    n, k = get_tuple()\n    li = get_list()\n    odd_indexes = [i+1 for i,ele in enumerate(li) if ele%2!=0]\n    if len(odd_indexes)<k:\n        print(\"NO\")\n    elif len(odd_indexes)%2==k%2:\n        ln = odd_indexes[:k-1] + [n]\n        print(\"YES\")\n        display_list(ln)\n    else:\n        print(\"NO\")\n\n\n\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for i in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n = int( input() )\nresult = []\nfor _ in range(n):\n    (n,k) = list( map( int, input().split() ))\n    a = list( map( int, input().split() ))\n    nbOdds = 0\n    for i in a:\n        if i % 2 == 1:\n            nbOdds += 1\n    if nbOdds < k:\n        result.append(\"NO\")\n    elif (nbOdds - k) % 2 == 0:\n        result.append(\"YES\")\n        current = []\n        for j in range(n):\n            if a[j] % 2 == 1 and len(current) < k - 1:\n                current.append(j+1)\n        current.append(n)\n        result.append( \" \".join( list( map(str, current) ) ) )\n\n    else:\n        result.append(\"NO\")\nprint( \"\\n\".join(result) )\n\n\n", "import sys\n \nt = int(input())\nfor i in range(t):\n    n, k = list(map(int, sys.stdin.readline().split()))\n    a = list(map(int, sys.stdin.readline().split()))\n    p = []\n    for i in range(n):\n        if a[i] % 2 == 1:\n            p.append(i+1)\n    if len(p) >= k and (len(p) - k)%2 == 0:\n        p = p[:k]\n        p[len(p)-1] = n\n        print('YES')\n        print(*p)\n    else:\n        print('NO')\n", "from sys import *\nfor _ in range(int(stdin.readline())):\n    a,b=list(map(int,stdin.readline().rstrip().split()))\n    l=list(map(int,stdin.readline().split()))\n    k=[]\n    c=0\n    for x in range(a):\n        if l[x]&1!=0:\n            k.append(x+1)\n            c+=1\n    j=c\n    if j<b:\n        print(\"NO\")\n    else:\n        t=j-b\n        if t&1==0:\n            print(\"YES\")\n            for x in range(b-1):\n                print(k[x],end=\" \")\n            print(a)\n        else:\n            print(\"NO\")", "'''input\n3\n2 1\n1 1\n5 4\n1 2 3 4 5\n6 2\n1 2 8 4 10 2\n'''\nfrom copy import deepcopy\nfrom bisect import bisect_right\nfrom itertools import combinations\nfrom sys import stdin\n\n\n\ndef dis(first, second, remain):\n\tif second[0] > first[0]:\n\t\tfirst[0], second[0] = second[0], first[0]\n\n\tif remain > first[0] - second[0]:\n\t\tremain -= first[0] - second[0]\n\t\tsecond[0] = first[0]\n\t\tfirst[0] += remain // 2\n\t\treturn first[0]\n\telse:\n\t\treturn second[0] + remain\n\n\n# main starts\nq = int(stdin.readline().strip())\nfor _ in range(q):\n\tn, k = list(map(int, stdin.readline().split()))\n\tarr = list(map(int, stdin.readline().split()))\n\ttemp  = 0\n\tcount = 0\n\ti = 0\n\tans = []\n\twhile i < len(arr) and count < k - 1:\n\t\ttemp += arr[i]\n\t\tif temp% 2 == 1:\n\t\t\tans.append(i + 1)\n\t\t\ttemp = 0\n\t\t\tcount += 1\n\t\ti += 1\n\tif len(ans) == 0:\n\t\tif sum(arr) % 2 == 1 and k == 1:\n\t\t\tprint(\"YES\")\n\t\t\tprint(n)\n\t\telse:\n\t\t\tprint(\"NO\")\n\n\telif sum(arr[ans[-1]:]) % 2 == 1:\n\t\tans.append(n)\n\t\tcount += 1\n\t\tif count == k:\n\t\t\tprint(\"YES\")\n\t\t\tprint(*ans)\n\t\telse:\n\t\t\tprint(\"NO\")\n\telse:\n\t\tprint(\"NO\")", "#575_B\n\nimport time\nimport sys\n\nstart = time.time()\n\nq = int(sys.stdin.readline().rstrip())\n\nfor i in range(0, q):\n    ns = [int(j) for j in sys.stdin.readline().rstrip().split(\" \")]\n    n = ns[0]\n    k = ns[1]\n    ln = [int(j) for j in sys.stdin.readline().rstrip().split(\" \")]\n    if len(ln) == 1:\n        if ln[0] % 2 == 1:\n            print(\"YES\")\n            print(1)\n        else:\n            print(\"NO\")\n        continue\n    cc = 1\n    inc = 0\n    inds = []\n    for j in range(0, len(ln)):\n        if ln[j] % 2 == 1:\n            if inc < k - 1:\n                inc += 1\n                inds.append(j + 1)\n            elif inc < k:\n                inc += 1\n            else:\n                cc += 1\n    if inc < k or cc % 2 == 0:\n        print(\"NO\")\n    else:\n        inds.append(n)\n        print(\"YES\")\n        print(\" \".join([str(j) for j in inds]))\n", "import sys\n\ninf = sys.stdin\n#inf = open(\"input_data.in\", \"r\")\n\nlines = inf.readlines()\n\n\nq = int(lines[0])\n\nfor tests in range(q):\n    n, k = (int(val) for val in lines[2*tests+1].split())\n    candy = [int(val) for val in lines[2*tests+2].split()]\n    \n    odds = 0\n    \n    for i in candy:\n        if i % 2 == 1:\n            odds += 1\n    \n    if(odds < k or sum(candy) % 2 != k % 2):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        \n        count = 1\n        \n        for i in range(len(candy)):\n            if count >= k:\n                print(n)\n                break\n            if candy[i] % 2 == 1:\n                print(i + 1, end = ' ')\n                count += 1"]