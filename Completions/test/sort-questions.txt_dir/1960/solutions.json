["N = int( input() )\nA = list( map( int, input().split() ) )\n\nmaxa = max( A )\n\ndef upd( ftree, x, v ):\n  while x <= maxa:\n    ftree[ x ] = max( ftree[ x ], v )\n    x += x & -x\n\ndef qry( ftree, x ):\n  res = 0\n  while x:\n    res = max( res, ftree[ x ] )\n    x -= x & -x\n  return res\n\nst_len = [ 0 for i in range( N ) ]\nftree = [ 0 for i in range( maxa + 1 ) ]\nfor i in range( N - 1, -1, -1 ):\n  st_len[ i ] = qry( ftree, maxa + 1 - A[ i ] - 1 ) + 1\n  upd( ftree, maxa + 1 - A[ i ], st_len[ i ] )\n\ned_len = [ 0 for i in range( N ) ]\nftree = [ 0 for i in range( maxa + 1 ) ]\nfor i in range( N ):\n  ed_len[ i ] = qry( ftree, A[ i ] - 1 ) + 1\n  upd( ftree, A[ i ], ed_len[ i ] )\n\nmax_len = max( st_len )\nst_cnt_len = [ 0 for i in range( N + 1 ) ]\nfor i in range( N ):\n  if ed_len[ i ] + st_len[ i ] - 1 == max_len:\n    st_cnt_len[ st_len[ i ] ] += 1\n\nfor i in range( N ):\n  if ed_len[ i ] + st_len[ i ] - 1 != max_len:\n    print( 1, end = \"\" )\n  elif st_cnt_len[ st_len[ i ] ] > 1:\n    print( 2, end = \"\" )\n  else:\n    print( 3, end = \"\" )\nprint()\n", "n = int(input())\nsecuencia = [None] * n\nma = 0\nfor num, e in enumerate(input().strip().split()):\n    en = int(e)\n    secuencia[num] = [en, 0, num]\n    ma = max(ma, en)\nescritura = [\"1\"] * len(secuencia)\n# ma = max((x[0] for x in secuencia))\nbit = [0] * (ma + 1)\n\ndef max_x(x, l):\n    suma = 0\n    while x != 0:\n        suma = max(suma, l[x])\n        x -= (x & -x)\n    return suma\n\ndef update_x(x, l, max_n, val):\n    while x <= max_n:\n        if val > l[x]:\n            l[x] = val\n        else:\n            return\n        x += (x & -x)\n\n# def index_list(item, alist, first=0, last=-1):\n#     pos = first\n#     while first <= last:\n#         midpoint = (first + last) // 2\n#         pos = midpoint\n#         if alist[midpoint][1] == item:\n#             return midpoint\n#         else:\n#             if item > alist[midpoint][1]:\n#                 last = midpoint - 1\n#             else:\n#                 first = midpoint + 1\n#                 pos += 1\n#     return pos\n\ndef new_get_secuence(e):\n    num = secuencia[e][0]\n    maximo = max_x(num - 1, bit) + 1\n    update_x(num, bit, ma, maximo)\n    return maximo\n\nfor e in range(n):\n    secuencia[e][1] = new_get_secuence(e)\n\nsecuencia.sort(key=lambda x: (-x[1], -x[2]))\nultimos = [(ma + 1, 0, n)]\npartir = 0\nmoment_max = secuencia[0][1]\n# while moment_max > 0:\n#     terminar = n\n#     usados = []\n#     for e in range(partir, n):\n#         if secuencia[e][1] < moment_max:\n#             terminar = e\n#             break\n#         for element in ultimos:\n#             if secuencia[e][2] < element[2]:\n#                 if secuencia[e][0] < element[0]:\n#                     usados.append(secuencia[e])\n#                     break\n#     if len(usados) == 1:\n#         escritura[usados[0][2]] = \"3\"\n#     else:\n#         for e in usados:\n#             escritura[e[2]] = \"2\"\n#     ultimos = usados\n#     partir = terminar\n#     moment_max -= 1\nusados = []\nfor e in secuencia:\n    if e[1] < moment_max:\n        if len(usados) == 1:\n            escritura[usados[0][2]] = \"3\"\n        else:\n            for y in usados:\n                escritura[y[2]] = \"2\"\n        ultimos = usados\n        usados = []\n        moment_max -= 1\n    for element in ultimos:\n        if e[2] < element[2]:\n            if e[0] < element[0]:\n                usados.append(e)\n                break\n        else:\n            break\nif len(usados) == 1:\n    escritura[usados[0][2]] = \"3\"\nelse:\n    for y in usados:\n        escritura[y[2]] = \"2\"\nprint(\"\".join(escritura))\n\n\n\n\n", "n = int(input())\nsecuencia = [None] * n\nma = 0\nfor num, e in enumerate(input().strip().split()):\n    en = int(e)\n    secuencia[num] = [en, 0, num]\n    ma = max(ma, en)\nescritura = [\"1\"] * len(secuencia)\n# ma = max((x[0] for x in secuencia))\nbit = [0] * (ma + 1)\n\ndef max_x(x, l):\n    suma = 0\n    while x != 0:\n        suma = max(suma, l[x])\n        x -= (x & -x)\n    return suma\n\ndef update_x(x, l, max_n, val):\n    while x <= max_n:\n        if val > l[x]:\n            l[x] = val\n        else:\n            return\n        x += (x & -x)\n\n# def index_list(item, alist, first=0, last=-1):\n#     pos = first\n#     while first <= last:\n#         midpoint = (first + last) // 2\n#         pos = midpoint\n#         if alist[midpoint][1] == item:\n#             return midpoint\n#         else:\n#             if item > alist[midpoint][1]:\n#                 last = midpoint - 1\n#             else:\n#                 first = midpoint + 1\n#                 pos += 1\n#     return pos\n\ndef new_get_secuence(e):\n    num = secuencia[e][0]\n    maximo = max_x(num - 1, bit) + 1\n    update_x(num, bit, ma, maximo)\n    return maximo\n\nfor e in range(n):\n    secuencia[e][1] = new_get_secuence(e)\n\nsecuencia.sort(key=lambda x: (-x[1], -x[2]))\nultimos = [(ma + 1, 0, n)]\npartir = 0\nmoment_max = secuencia[0][1]\n# while moment_max > 0:\n#     terminar = n\n#     usados = []\n#     for e in range(partir, n):\n#         if secuencia[e][1] < moment_max:\n#             terminar = e\n#             break\n#         for element in ultimos:\n#             if secuencia[e][2] < element[2]:\n#                 if secuencia[e][0] < element[0]:\n#                     usados.append(secuencia[e])\n#                     break\n#     if len(usados) == 1:\n#         escritura[usados[0][2]] = \"3\"\n#     else:\n#         for e in usados:\n#             escritura[e[2]] = \"2\"\n#     ultimos = usados\n#     partir = terminar\n#     moment_max -= 1\nusados = []\nfor e in secuencia:\n    if e[1] < moment_max:\n        if len(usados) == 1:\n            escritura[usados[0][2]] = \"3\"\n        else:\n            for y in usados:\n                escritura[y[2]] = \"2\"\n        ultimos = usados\n        usados = []\n        moment_max -= 1\n    for element in ultimos:\n        if e[2] < element[2]:\n            if e[0] < element[0]:\n                usados.append(e)\n                break\n        else:\n            break\nif len(usados) == 1:\n    escritura[usados[0][2]] = \"3\"\nelse:\n    for y in usados:\n        escritura[y[2]] = \"2\"\nprint(\"\".join(escritura))\n\n\n\n\n", "# a simple parser for python. use get_number() and get_word() to read\ndef main():\n    def parser():\n        while 1:\n            data = list(input().split(' '))\n            for number in data:\n                if len(number) > 0:\n                    yield(number)\n\n    input_parser = parser()\n    gets = lambda: next(input_parser)\n\n    def getNum():\n        data = gets()\n        try:\n            return int(data)\n        except ValueError:\n            return float(data)\n    # ---------program---------\n    from bisect import bisect_left\n    binslb = bisect_left\n    MAXA = int(9e9)\n    n = getNum()\n    RANGN = range(n)\n    a = [ getNum() for _ in RANGN ]\n\n    revlis = []\n    g = [MAXA]*n\n    for i in reversed(RANGN):\n        x = -a[i]\n        pt = binslb( g, x )\n        revlis.append(pt+1)\n        if( x < g[pt] ):\n            g[pt] = x\n    hlis = max( revlis )\n\n    lis, inlis = [], []\n    d = [0]*n\n    for i in RANGN: g[i] = MAXA\n    for i in RANGN:\n        pt = binslb( g, a[i] )\n        lis.append( pt+1 )\n        inlis.append( lis[i] + revlis[n-i-1] > hlis )\n        d[pt] += inlis[-1]\n        if( a[i] < g[pt] ):\n            g[pt] = a[i]\n    \n    print( ''.join(\n        [ '32'[d[lis[i]-1] > 1] if inlis[i] else '1'  \n        for i in RANGN ]\n    ) )\n        \ndef __starting_point():\n    main()\n__starting_point()", "# a simple parser for python. use get_number() and get_word() to read\ndef main():\n    def parser():\n        while 1:\n            data = list(input().split(' '))\n            for number in data:\n                if len(number) > 0:\n                    yield(number)\n\n    input_parser = parser()\n    gets = lambda: next(input_parser)\n\n    def getNum():\n        data = gets()\n        try:\n            return int(data)\n        except ValueError:\n            return float(data)\n    # ---------program---------\n    from bisect import bisect_left as binsleft\n    # bisect_left = bisect_left\n    MAXA = int(9e9)\n    n = getNum()\n    RANGN = range(n)\n    a = [ getNum() for _ in RANGN ]\n\n    revlis = []\n    g = [MAXA]*n\n    for i in reversed(RANGN):\n        x = -a[i]\n        pt = binsleft( g, x )\n        revlis.append(pt+1)\n        if( x < g[pt] ):\n            g[pt] = x\n    hlis = max( revlis )\n\n    lis, inlis = [], []\n    d = [0]*n\n    for i in RANGN: g[i] = MAXA\n    for i in RANGN:\n        pt = binsleft( g, a[i] )\n        lis.append( pt+1 )\n        inlis.append( lis[i] + revlis[n-i-1] > hlis )\n        d[pt] += inlis[-1]\n        if( a[i] < g[pt] ):\n            g[pt] = a[i]\n    \n    print( ''.join(\n        [ '32'[d[lis[i]-1] > 1] if inlis[i] else '1'  \n        for i in RANGN ]\n    ) )\n        \ndef __starting_point():\n    main()\n__starting_point()", "# a simple parser for python. use get_number() and get_word() to read\ndef main():\n    def parser():\n        while 1:\n            data = list(input().split(' '))\n            for number in data:\n                if len(number) > 0:\n                    yield(number)\n\n    input_parser = parser()\n    gets = lambda: next(input_parser)\n\n    def getNum():\n        data = gets()\n        try:\n            return int(data)\n        except ValueError:\n            return float(data)\n    # ---------program---------\n    from bisect import bisect_left as binsleft\n    # bisect_left = bisect_left\n    MAXA = int(9e9)\n    n = getNum()\n    RANGN = range(n)\n    a = [ getNum() for _ in RANGN ]\n\n    revlis = []\n    g = [MAXA]*n\n    for i in reversed(RANGN):\n        x = -a[i]\n        pt = binsleft( g, x )\n        revlis.append(pt+1)\n        if( x < g[pt] ):\n            g[pt] = x\n    hlis = max( revlis )\n\n    lis, inlis = [], []\n    d = [0]*n\n    for i in RANGN: g[i] = MAXA\n    for i in RANGN:\n        pt = binsleft( g, a[i] )\n        lis.append( pt+1 )\n        inlis.append( lis[i] + revlis[n-i-1] > hlis )\n        d[pt] += inlis[-1]\n        if( a[i] < g[pt] ):\n            g[pt] = a[i]\n    \n    print( ''.join(\n        [ '32'[d[lis[i]-1] > 1] if inlis[i] else '1'  \n        for i in RANGN ]\n    ) )\n        \ndef __starting_point():\n    main()\n__starting_point()", "# a simple parser for python. use get_number() and get_word() to read\ndef main():\n    def parser():\n        while 1:\n            data = list(input().split(' '))\n            for number in data:\n                if len(number) > 0:\n                    yield(number)\n\n    input_parser = parser()\n    gets = lambda: next(input_parser)\n\n    def getNum():\n        data = gets()\n        try:\n            return int(data)\n        except ValueError:\n            return float(data)\n    # ---------program---------\n    from bisect import bisect_left # as bisect_left\n    MAXA = int(9e9)\n    n = getNum()\n    RANGN = range(n)\n    a = [ getNum() for _ in RANGN ]\n\n    revlis = []\n    g = [MAXA]*n\n    for i in reversed(RANGN):\n        x = -a[i]\n        pt = bisect_left( g, x )\n        revlis.append(pt+1)\n        if( x < g[pt] ):\n            g[pt] = x\n    hlis = max( revlis )\n\n    lis, inlis = [], []\n    d = [0]*n\n    for i in RANGN: g[i] = MAXA\n    for i in RANGN:\n        pt = bisect_left( g, a[i] )\n        lis.append( pt+1 )\n        inlis.append( lis[i] + revlis[n-i-1] > hlis )\n        d[pt] += inlis[-1]\n        if( a[i] < g[pt] ):\n            g[pt] = a[i]\n    \n    print( ''.join(\n        [ '32'[d[lis[i]-1] > 1] if inlis[i] else '1'  \n        for i in RANGN ]\n    ) )\n        \ndef __starting_point():\n    main()\n__starting_point()", "# http://codeforces.com/problemset/problem/486/E\nimport sys\nimport re\nimport collections\nimport threading\nimport bisect # bisect.bisect(list, value)\n\nN = 0\n\nLast = []\nAA = [0 for _ in range(100005)]\nLL = [0 for _ in range(100005)]\nBB = [0 for _ in range(100005)] # reverse\nSS = [0 for _ in range(100005)] # reverse\nTT = [0 for _ in range(100005)] # reverse\nANS = [1 for _ in range(100005)]\n\n\ndef LIS(A, L):\n    nonlocal N\n\n    Last.append(-1) # dummy\n\n    for i in range(N):\n        if Last[-1] < A[i]:\n            Last.append(A[i])\n\n        it = bisect.bisect_left(Last, A[i]) # lower_bound() in C++\n\n        Last[it] = A[i]\n        L[i] = it\n\nN = int(sys.stdin.readline())\nAA = list(map(int, sys.stdin.readline().strip().split()))\n\nLIS(AA, LL)\n\nlength = max(LL)\n\nfor i in range(N):\n    BB[N-i-1] = 1000000 - AA[i]\n\nLast = []\n\nLIS(BB, SS)\n\nfor i in range(N):\n    TT[N-i-1] = SS[i]\n\nfor i in range(N):\n    if LL[i] + TT[i] == length + 1 :\n        ANS[i] = 3\n\nmaxi = 0;\nmini = 1000000;\n\nfor i in range(N):\n    if ANS[i] != 1:\n        if AA[i] <= maxi: ANS[i] = 2\n        maxi = max(maxi, AA[i])\n\nfor i in range(N-1, -1, -1):\n    if ANS[i] != 1:\n        if AA[i] >= mini: ANS[i] = 2\n        mini = min(mini, AA[i])\n\nfor i in range(N):\n    print(ANS[i], end=\"\", flush=True)\n\nprint()"]