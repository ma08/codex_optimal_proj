["import  sys\ninput=sys.stdin.readline\nn,m=list(map(int,input().split()))\na=[int(x) for x in input().split()]\ns=[set() for i in range(m+1)]\n\nfor i in range(n):\n    s[a[i]].add(i+1)\n\nf=[0]*(m+2)\nfor i in range(m+1):\n    f[i]=i\n\ndef fin(x):\n    if f[x]==x:\n        return x\n    f[x]=fin(f[x])\n    return f[x]\nans=0\nfor i in range(1,m+1):\n    for j in s[i]:\n        if j in s[i] and j-1 in s[i]:\n            ans+=1\n\nout=[n-ans-1]\n\nfor i in range(m-1):\n    x,y=list(map(int,input().split()))\n    x=fin(x)\n    y=fin(y)\n\n    if len(s[x])<len(s[y]):\n        x,y=y,x\n    for i in s[y]:\n        if i in s[y] and i-1 in s[x]:\n            ans+=1\n        if i in s[y]  and i+1 in s[x]:\n            ans+=1\n\n    out.append(n-ans-1)\n    s[x]|=s[y]\n    f[y]=x\n\nprint('\\n'.join(str(x) for x in out))\n\n\n", "import  sys\ninput=sys.stdin.readline\nn,m=list(map(int,input().split()))\na=[int(x) for x in input().split()]\ns=[set() for i in range(m+1)]\n\nfor i in range(n):\n    s[a[i]].add(i+1)\n\nf=[0]*(m+2)\nfor i in range(m+1):\n    f[i]=i\n\ndef fin(x):\n    if f[x]==x:\n        return x\n    f[x]=fin(f[x])\n    return f[x]\nans=0\nfor i in range(1,m+1):\n    for j in s[i]:\n        if j in s[i] and j-1 in s[i]:\n            ans+=1\n\nout=[n-ans-1]\n\nfor i in range(m-1):\n    x,y=list(map(int,input().split()))\n    x=fin(x)\n    y=fin(y)\n\n    if len(s[x])<len(s[y]):\n        x,y=y,x\n    for i in s[y]:\n        if i in s[y] and i-1 in s[x]:\n            ans+=1\n        if i in s[y]  and i+1 in s[x]:\n            ans+=1\n\n    out.append(n-ans-1)\n    s[x]|=s[y]\n    f[y]=x\n\nprint('\\n'.join(str(x) for x in out))\n\n\n", "import sys\ninput = sys.stdin.readline\n\nclass Dsu:\n    def __init__(self, _n):\n        self.n = _n\n        self.p = [-1] * _n\n\n    def get(self, v):\n        u = v\n        while self.p[u] != -1:\n            u = self.p[u]\n        while self.p[v] != -1:\n            nxt = self.p[v]\n            self.p[v] = u\n            v = nxt\n        return u\n\n    def unite(self, v, u):\n        v = self.get(v)\n        u = self.get(u)\n        if v == u:\n            return\n        self.p[v] = u\n\nn, m = map(int, input().split())\nreal = Dsu(m)\na = list(map(lambda x: int(x) - 1, input().split()))\n\nidxs = [[] for i in range(n)]\nfor i in range(n):\n    idxs[a[i]].append(i)\n\nans = 0\nfor i in range(1, n):\n    if a[i] != a[i - 1]:\n        ans += 1\nprint(ans)\n\nfor _ in range(1, m):\n    v, u = map(lambda x: int(x) - 1, input().split())\n    v = real.get(v)\n    u = real.get(u)\n    if len(idxs[v]) > len(idxs[u]):\n        v, u = u, v\n    real.unite(v, u)\n    if v != u:\n        for i in idxs[v]:\n            if i >= 1 and a[i] == v and a[i - 1] == u:\n                ans -= 1\n            if i + 1 < n and a[i] == v and a[i + 1] == u:\n                ans -= 1\n        for i in idxs[v]:\n            idxs[u].append(i)\n            a[i] = u;\n    print(ans) ", "import sys\ninput = sys.stdin.readline\n\nclass Dsu:\n    def __init__(self, _n):\n        self.n = _n\n        self.p = [-1] * _n\n\n    def get(self, v):\n        if self.p[v] == -1:\n            return v\n        self.p[v] = self.get(self.p[v])\n        return self.p[v]\n\n    def unite(self, v, u):\n        v = self.get(v)\n        u = self.get(u)\n        if v == u:\n            return\n        self.p[v] = u\n\nn, m = map(int, input().split())\nreal = Dsu(m)\na = list(map(lambda x: int(x) - 1, input().split()))\n\nidxs = [[] for i in range(n)]\nfor i in range(n):\n    idxs[a[i]].append(i)\n\nans = 0\nfor i in range(1, n):\n    if a[i] != a[i - 1]:\n        ans += 1\nprint(ans)\n\nfor _ in range(1, m):\n    v, u = map(lambda x: int(x) - 1, input().split())\n    v = real.get(v)\n    u = real.get(u)\n    if len(idxs[v]) > len(idxs[u]):\n        v, u = u, v\n    real.unite(v, u)\n    if v != u:\n        for i in idxs[v]:\n            if i >= 1 and a[i] == v and a[i - 1] == u:\n                ans -= 1\n            if i + 1 < n and a[i] == v and a[i + 1] == u:\n                ans -= 1\n        for i in idxs[v]:\n            idxs[u].append(i)\n            a[i] = u;\n    print(ans) ", "import sys\ninput = sys.stdin.readline\nn,m = map(int,input().split())\na = list(map(int,input().split()))\ns = [set() for i in range(m+1)]\nu = [-1]*(m+1)\n\nfor i in range(n):\n    s[a[i]].add(i+1)\n\ndef find(x):\n    if u[x] <= 0:\n        return x\n    else:\n        u[x] = find(u[x])\n        return u[x]\n\ncount = 0\nfor i in range(n-1):\n    if a[i] != a[i+1]:\n        count += 1\nans = [count]\n\nfor i in range(1,m):\n    x,y = map(int,input().split())\n    x = find(x)\n    y = find(y)\n    if len(s[x]) < len(s[y]):\n        x,y = y,x\n    for j in s[y]:\n        if j-1 in s[x]:\n            count -= 1\n        if j+1 in s[x]:\n            count -= 1\n    ans.append(count)\n    s[x] |= s[y]\n    u[y] = x\n\nfor i in ans:\n    print(i)", "class UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy: return\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def calc_group_num(self):\n        N = len(self._parent)\n        ans = 0\n        for i in range(N):\n            if self.find_root(i) == i:\n                ans += 1\n        return ans\n\nimport sys\n\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nt=list(map(int,input().split()))\nt=[t[i]-1 for i in range(n)]\nquery=[]\nfor i in range(m-1):\n    a,b=list(map(int,input().split()))\n    query.append((a-1,b-1))\n\ntower=[[] for i in range(m)]\nfor i in range(n):\n    id=t[i]\n    if not tower[id]:\n        tower[id].append((i+1,i+1))\n    else:\n        start,end=tower[id].pop()\n        if end+1==i+1:\n            tower[id].append((start,i+1))\n        else:\n            tower[id].append((start,end))\n            tower[id].append((i+1,i+1))\n\n#print(tower)\ntest=[]\nfor i in range(m):\n    for start,end in tower[i]:\n        if end!=n:\n            test.append((t[start-1],t[end]))\n\n#print(test)\nstart=[-1]*len(test)\nend=[m-1]*len(test)\ntemp=[[] for i in range(m)]\nfor i in range(len(test)):\n    T=(end[i]+start[i])//2\n    temp[T].append(i)\n\n\ndef parabisect():\n    uf=UnionFindVerSize(m)\n    for i in range(m-1):\n        a,b=query[i]\n        uf.unite(a,b)\n        while temp[i]:\n            j=temp[i].pop()\n            id1,id2=test[j]\n            if uf.is_same_group(id1,id2):\n                end[j]=i\n            else:\n                start[j]=i\n            if end[j]-start[j]>1:\n                T=(end[j]+start[j])//2\n                temp[T].append(j)\n\nfor i in range(20):\n    parabisect()\n\nres=[0]*m\nfor i in range(len(test)):\n    res[end[i]+1]-=1\n\nfor i in range(1,m):\n    res[i]+=res[i-1]\n\nfor i in range(m):\n    print(len(test)+res[i])\n"]