["\nn = int(input())\n\nitems = []\nmax_time = 0\n\nfor i in range(1,n+1):\n    t,d,p = list(map(int,input().split()))\n    max_time = max(max_time, d)\n    items.append((t,d,p,i))\n\nitems.sort(key=lambda x: x[1])\n\ndp = [[(0,[]) for _ in range(n+1)] for _ in range(max_time+1)]\n\nfor time in range(1, max_time+1):\n    for it in range(1, n+1):\n        \n        if time < items[it-1][0] or time >= items[it-1][1]:\n            dp[time][it] = max(dp[time][it-1], dp[time-1][it])\n        else:\n            \n            pick = dp[time-items[it-1][0]][it-1][0] + items[it-1][2]\n            if dp[time][it-1][0] > pick : \n                dp[time][it] = max(dp[time][it-1], dp[time-1][it])\n            else:\n                \n                dp[time][it] = (dp[time-items[it-1][0]][it-1][0] + items[it-1][2], list(dp[time-items[it-1][0]][it-1][1]))\n                dp[time][it][1].append(items[it-1][3])\n\n#print(dp)\n\nres = max(dp[max_time])\n\nprint(res[0])\nprint(len(res[1]))\nprint(*res[1])             \n", "P = [0] * 2001\nS = [[] for i in range(2001)]\n\nq = [list(map(int, input().split())) + [str(i + 1)] for i in range(int(input()))]\nq.sort(key=lambda q: q[1])\n\nfor t, d, p, i in q:\n    for x in range(t, d)[::-1]:\n        if P[x] < P[x - t] + p:\n            P[x] = P[x - t] + p\n            S[x] = S[x - t] + [i]\n\nk = P.index(max(P))\nprint('\\n'.join([str(P[k]), str(len(S[k])), ' '.join(S[k])]))", "from functools import lru_cache\n\n\ndef readints():\n    return [int(obj) for obj in input().strip().split()]\n\n\nclass Solver:\n    def main(self):\n        n = readints()[0]\n        self.t, self.d, self.p = [], [], []\n        for i in range(n):\n            t1, d1, p1 = readints()\n            self.t.append(t1)\n            self.d.append(d1)\n            self.p.append(p1)\n\n        self.backtrack = []\n        sd = max(self.d) + 1\n        for i in range(n+1):\n            self.backtrack.append([])\n            for j in range(sd):\n                self.backtrack[i].append(0)\n\n        triples = list(zip(self.t, self.d, self.p, list(range(1, n+1))))\n        triples = sorted(triples, key=lambda x: x[1])\n        self.t, self.d, self.p, self.indexes = [0], [0], [0], []\n        for i in range(n):\n            self.t.append(triples[i][0])\n            self.d.append(triples[i][1])\n            self.p.append(triples[i][2])\n            self.indexes.append(triples[i][3])\n\n        self.f = []\n        for i in range(n+1):\n            self.f.append([])\n            for j in range(sd):\n                self.f[i].append(0)\n\n        for i in range(1, n+1):\n            for d in range(sd):\n                if d - self.t[i] >= 0 and d < self.d[i] and self.t[i] < self.d[i]:\n                    data = self.f[i - 1][d - self.t[i]]\n                    if data + self.p[i] > self.f[i][d]:\n                        self.f[i][d] = data + self.p[i]\n                        self.backtrack[i][d] = i\n\n                data = self.f[i - 1][d]\n                if data > self.f[i][d]:\n                    self.f[i][d] = data\n                    self.backtrack[i][d] = 0\n\n        ans = 0\n        res = []\n        best = None\n        for i in range(sd):\n            data = self.f[n][i]\n            if data > ans:\n                ans = data\n                best = (n, i)\n\n        if best is None:\n            print('0\\n0\\n')\n            return\n\n        i = best[0]\n        s = best[1]\n        while i > 0:\n            if self.backtrack[i][s] != 0:\n                res.append(self.backtrack[i][s])\n                s -= self.t[self.backtrack[i][s]]\n            i -= 1\n\n        print(ans)\n        print(len(res))\n        print(' '.join(str(self.indexes[item - 1]) for item in reversed(res)))\n\n\nSolver().main()\n", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\n\n\"\"\"\ncreated by shhuan at 2017/10/4 21:10\n\n\"\"\"\n\nN = int(input())\nM = []\nfor i in range(N):\n    M.append([int(x) for x in input().split()])\n\n# N = 9\n# M = [[13, 18, 14],\n#      [8, 59, 20],\n#      [9, 51, 2],\n#      [18, 32, 15],\n#      [1, 70, 18],\n#      [14, 81, 14],\n#      [10, 88, 16],\n#      [18, 52, 3],\n#      [1, 50, 6]]\n\nMA = []\nfor i, row in enumerate(M):\n    t, d, p = row\n    MA.append((d, p, t, i+1))\nM = sorted(MA)\n\n# for row in M:\n#     print(row)\n\nT = [0] + [x[2] for x in M]\nD = [0] + [x[0] for x in M]\nP = [0] + [x[1] for x in M]\nI = [0] + [x[3] for x in M]\n\ndmax = max(D)\n\n# dp[t][i]\u5373\u65f6\u95f4t\u5185\u80fd\u591f\u62ef\u6551\u7684\u524di\u4e2a\u7269\u54c1\u7684\u6700\u5927\u7269\u54c1\u4ef7\u503c\ndp = [[0 for _ in range(N+1)] for _ in range(dmax)]\ntrack = [[0 for _ in range(N+1)] for _ in range(dmax)]\nfor t in range(dmax):\n    for i in range(1, N+1):\n        ti = t-T[i]\n        if T[i] <= t < D[i] and ti >= 0:\n            dp[t][i] = max(dp[t][i-1], dp[ti][i-1] + P[i])\n            if dp[t][i-1] > dp[ti][i-1]+P[i]:\n                track[t][i] = (t, i-1, -1)\n            else:\n                track[t][i] = (ti, i-1, i)\n        else:\n            dp[t][i] = dp[t][i-1]\n            track[t][i] = (t, i-1, -1)\n\n# for row in dp:\n#     print(row)\n\nsaved = 0\nt, i, j = 0, N, -1\nfor j in range(dmax):\n    if dp[j][N] > saved:\n        saved = dp[j][N]\n        t = j\n\nprint(saved)\n# print(I)\nres = []\nwhile t > 0 and i > 0:\n    t, i, j = track[t][i]\n    if j > 0:\n        res.append(I[j])\n\nprint(len(res))\nprint(' '.join([str(x) for x in reversed(res)]))\n\n\n\n\n", "import os\nimport sys\nimport re\nfrom collections import OrderedDict\n\nif 'PYCHARM' in os.environ:\n    sys.stdin = open('in', 'r')\n\nn = int(input())\nthings = []\nfor i in range(n):\n    t, d, p = list(map(int, input().split()))\n    things.append((d, t, p, i + 1))\n\nthings.sort()\nD = 2001\nf = [[0] * D]\nw = [[False] * D]\n\nfor i in range(n):\n    thing = things[i]\n    w.append([False] * D)\n    f.append(list(f[i]))\n    for j in range(D):\n        ni = j + thing[1]\n        nv = f[i][j] + thing[2]\n        if ni < thing[0]:\n            if f[i + 1][ni] < nv:\n                f[i + 1][ni] = nv\n                w[i + 1][ni] = True\n\nind = 0\nfor i in range(D):\n    if f[n][i] > f[n][ind]:\n        ind = i\n\nprint(f[n][ind])\nans = []\nfor i in range(n, 0, -1):\n    if w[i][ind]:\n        ind -= things[i - 1][1]\n        ans.append(things[i - 1][3])\n\nprint(len(ans))\nprint(*reversed(ans))\n\n\n\n", "n = int(input())\na = []\nfor i in range(n):\n    t,d,p = list(map(int,input().split()))\n    a.append([t,d,p,i+1])\na.sort(key = lambda x: x[1])\nd = {0: [0,[]]}\nfor i in a:\n    e = {}\n    for j in d:\n        if d[j][0] + i[0] < i[1]:\n            if j + i[2] in d:\n                if d[j][0]+i[0] < d[j+i[2]][0]:\n                    e[j+i[2]] = [d[j][0]+i[0],d[j][1]+[i[3]]]\n            else:\n                e[j+i[2]] = [d[j][0]+i[0],d[j][1]+[i[3]]]\n    d.update(e)\nt = max(d)                \nprint(t)\nk = d[t][1]\nprint(len(k))\nk = list(map(str,k))\nprint(' '.join(k))\n", "from sys import stdin\ninput = stdin.readline\nn = int(input())\nT = 2001\nt, d, p, idx = [], [], [], []\nans = []\narr = []\nfor i in range(n):\n    a, b, c = map(int, input().split())\n    arr.append([a, b, c, i])\narr.sort(key=lambda x: x[1])\nfor i in arr:\n    t.append(i[0]); d.append(i[1]); p.append(i[2]); idx.append(i[3])\ndp = [[0 for j in range(n)] for i in range(T)]\nfor time in range(1, T):\n    for i in range(n):\n        #dp[time][i] = max(dp[time - 1][i], dp[time][i - 1])\n        dp[time][i] = dp[time][i - 1]\n        if d[i] > time >= t[i]:\n            if i:\n                dp[time][i] = max(dp[time][i], p[i] + dp[time - t[i]][i - 1])\n            else:\n                dp[time][i] = p[i]\nb = [0, [0 ,0]]\nfor i in range(T):\n    for j in range(n):\n        if b[0] < dp[i][j]:\n            b = [dp[i][j], [i, j]]\nprint(b[0])\nb = b[1]\nwhile dp[b[0]][b[1]] and b[0] > -1:\n    if b[1] and dp[b[0]][b[1]] != dp[b[0]][b[1] - 1]:\n        ans.append(b[1])\n        b[0] -= t[b[1]]\n    elif b[1] == 0:\n        if dp[b[0]][b[1]]:\n            ans.append(b[1])\n        break\n    b[1] -= 1\nprint(len(ans))\nfor i in ans[::-1]:\n    print(idx[i] + 1, end=' ')", "import copy\nn = int(input()) \narr = []\nm = 0\nfor er in range(n):\n    temp = list(map(int,input().split(\" \")))\n    temp.append(er+1)\n    if(temp[0]<temp[1]):\n        arr.append(temp)\n        if(temp[1]>m):\n            m = temp[1]\n    else:\n        n-=1\narr.sort(key = lambda x:x[1])\n#print(arr)\ntemp=[]\nfor i in range(n):\n    temp.append([0])\ncom = []\ncom.append(temp)\ntotal = [0,0]\nfor i in range(1,m+1):\n    temp = []\n    for j in range(n+1):\n        if(j==0):\n            temp.append([0])\n        else:\n            p=arr[j-1]\n            if(p[0]>i or p[1]<=i):\n                temp.append(temp[j-1])\n            else:\n                te = i - p[0]\n                ty = copy.deepcopy(com[te][j-1])\n                ty[0]+=p[2]\n                ty.append(j)\n                if(total[0]<ty[0]):\n                    total = ty\n                if(temp[j-1][0]<ty[0]):\n                    temp.append(ty)\n                else:\n                    temp.append(temp[j-1])\n    #print(temp , \" temp\")\n    com.append(temp)\n#print(com)\nprint(total[0])\nif(total[0]>0):\n    print(len(total)-1)\n    for i in range(1,len(total)):\n        print(arr[total[i]-1][3] , end = \" \")\nelse:\n    print(\"0\")", "from sys import stdin\n\nn = int(stdin.readline())\n\nitems = []\n\nfor i in range(n):\n  t,d,p = [int(x) for x in stdin.readline().split()]\n  items.append((d,t,p,i))\n\nitems.sort()\n\nmem = [{} for x in range(n)]\nmem2 = [{} for x in range(n)]\n\ndef best(time,x):\n  time += items[x][1]\n  if time in mem[x]:\n    return mem[x][time]\n\n  if time >= items[x][0]:\n    mem[x][time] = 0\n    mem2[x][time] = -1\n    return 0\n  \n  top = 0\n  top2 = -1\n\n  for i in range(x+1,n):\n    temp = best(time,i)\n    if temp > top:\n      top = temp\n      top2 = i\n\n  mem[x][time] = top+items[x][2]\n  mem2[x][time] = top2\n  return mem[x][time]\n\ntop = -1\nl = []\n\nfor x in range(n):\n  b = best(0,x)\n  if b > top:\n    top = b\n    #print('new',x,top)\n    l = []\n    c = x\n    time = 0\n    while c != -1:\n      time += items[c][1]\n      l.append(items[c][3])\n      if time in mem2[c]:\n        c = mem2[c][time]\n      else:\n        c = -1\n\nprint(top)\nif top != 0:\n  print(len(l))\n  print(' '.join([str(x+1) for x in l]))\nelse:\n  print(0)\n  print()\n    \n"]