["def lis(a):\n    b = []\n    for c in a:\n        # if len(b) == 0 or c > b[-1]\n        if len(b) == 0 or c > b[-1]:\n            b.append(c)\n        else:\n            l = 0\n            r = len(b)\n            while l < r-1:\n                m = l+r>>1\n                # if b[m] <= c: l = m\n                if b[m] < c: l = m\n                else: r = m\n            # if b[l] <= c: l += 1\n            if b[l] < c: l += 1\n            b[l] = c\n        \n    return len(b)\n                    \n\nn = int(input())\n\na = list(map(int, input().split()))\n\nprint(lis(a))\n", "from bisect import bisect_right\ns, n = [0], input()\nfor i in map(int, input().split()):\n    if i > s[-1]: s.append(i)\n    else: s[bisect_right(s, i)] = i\nprint(len(s) - 1)", "import sys; sys.setrecursionlimit(1000000)\n\ndef solve():\n    # 3 1 2 4\n    # 1 2 3 4\n\n    # 2 1 3 5 4\n    # 1 2 3 4 5\n\n    n, = rv()\n    a, = rl(1)\n\n\n\n    # 3 1 2 7 4 6 5\n    # [ , 1 ,  , , , ]\n    # [ , 1 , 2 , , , ]\n    # [ , 1 , 2 , 4, 5, ]\n\n    mem = [10000000] * (n + 1)\n    mem[0] = a[0]\n    for i in range(1, n):\n        left, right = 0, n - 1\n        while left < right:\n            mid = (left + right) // 2\n            if a[i] < mem[mid]: right = mid\n            else: left = mid + 1\n        mem[left] = a[i]\n        # for j in range(n):\n        #     if a[i] < mem[j]:\n        #         mem[j] = a[i]\n        #         break\n    res = 0\n    # print(mem)\n    for i in range(1, n):\n        if mem[i] != 10000000: res = i\n    print(res + 1)\n\n\n\n\ndef rv(): return list(map(int, input().split()))\ndef rl(n): return [list(map(int, input().split())) for _ in range(n)]\nif sys.hexversion == 50594544 : sys.stdin = open(\"test.txt\")\nsolve()\n\n\n", "from bisect import bisect_left, bisect_right, insort\nR = lambda: map(int, input().split())\nn, arr = int(input()), list(R())\ndp = []\nfor i in range(n):\n    idx = bisect_left(dp, arr[i])\n    if idx >= len(dp):\n        dp.append(arr[i])\n    else:\n        dp[idx] = arr[i]\nprint(len(dp))", "n = int(input())\nnum_list = list(map(int, input().split()))\n# def lower_bound(min_lis, x): \n#     #goal return the position of the first element >= x\n#     left = 0 \n#     right = len(min_lis) - 1\n#     res = -1\n#     while left <= right:\n#         mid = (left + right) // 2 \n#         if min_lis[mid] < x: \n#             left = mid + 1\n#         else:\n#             res = mid\n#             right = mid - 1\n#     return res\nimport bisect\n\ndef LongestIncreasingSubsequence(a, n):\n    min_lis = []\n    #lis = [0 for i in range(n)]\n    for i in range(n): \n        pos = bisect.bisect_left(min_lis, a[i])\n        if pos == len(min_lis):\n            #lis[i] = len(min_lis) + 1\n            min_lis.append(a[i])\n        else:\n            #lis[i] = pos + 1\n            min_lis[pos] = a[i]\n        #print(*min_lis)\n    return (len(min_lis))\n\nprint(LongestIncreasingSubsequence(num_list, n))\n", "import math\nimport sys\nfrom bisect import bisect_right, bisect_left, insort_right\nfrom collections import Counter, defaultdict\nfrom heapq import heappop, heappush\nfrom itertools import accumulate, permutations, combinations\nfrom sys import stdout\n\nR = lambda: map(int, input().split())\nn = int(input())\narr = list(R())\ntps = [(0, 0)]\nfor x in arr:\n    i = bisect_left(tps, (x, -1)) - 1\n    tps.insert(i + 1, (x, tps[i][1] + 1))\n    if i + 2 < len(tps) and tps[i + 1][1] >= tps[i + 2][1]:\n        del tps[i + 2]\nprint(max(x[1] for x in tps))", "\"\"\"\nhttp://codeforces.com/problemset/problem/341/B\n\"\"\"\n\nfrom typing import List\nfrom bisect import bisect_right\n\n\nclass Solution:\n    def patienceSort(self, a: List[int]) -> int:\n        # patience sort can find longest increasing subsequence in O(NlogN)\n        # https://en.wikipedia.org/wiki/Patience_sorting\n        n = len(a)\n        piles = [n + 1 for i in range(n)]  # To find length of LIS, we're only interested in the top card of each pile\n        nextPileIdx = 0\n        for i in a:\n            idx = bisect_right(piles, i, 0, nextPileIdx)\n            piles[idx] = i\n            if idx >= nextPileIdx:\n                nextPileIdx += 1\n\n        return nextPileIdx\n\n    def maxIndependentSetSize(self, a: List[int]) -> int:\n        return self.patienceSort(a)\n\n\ndef __starting_point():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    s = Solution()\n    print(s.maxIndependentSetSize(a))\n\n__starting_point()", "MXusl = int\nMXuso = input\nMXusL = map\nMXusr = min\nMXusI = print\nn = MXusl(MXuso())\na = [1e6] * (n + 1)\ns = 1\nfor x in MXusL(MXusl, MXuso().split()):\n    l = 0\n    r = s\n    while r-l > 1:\n        m = (l + r) >> 1\n        if a[m] < x:\n            l = m\n        else:\n            r = m\n    s += r == s\n    a[r] = MXusr(a[r], x)\nMXusI(s - 1)\n", "def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LIS(A, size): \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\n\ndef main():\n    n = int(input())\n    arr = list(map(int,input().split()))\n\n    print(LIS(arr,n))\n    \n\nmain()\n", "from bisect import *\ns, n = [0], input()\nfor i in map(int, input().split()):\n    if i > s[-1]: s.append(i)\n    else: s[bisect_right(s, i)] = i\n    \nprint(len(s) - 1)", "# Python program to find \n# length of longest \n# increasing subsequence \n# in O(n Log n) time \n\n# Binary search (note \n# boundaries in the caller) \n# A[] is ceilIndex \n# in the caller \ndef CeilIndex(A, l, r, key): \n\n\twhile (r - l > 1): \n\t\n\t\tm = l + (r - l)//2\n\t\tif (A[m] >= key): \n\t\t\tr = m \n\t\telse: \n\t\t\tl = m \n\treturn r \n\ndef Lis(A, size): \n\n\t# Add boundary case, \n\t# when array size is one \n\n\ttailTable = [0 for i in range(size + 1)] \n\tlen = 0 # always points empty slot \n\n\ttailTable[0] = A[0] \n\tlen = 1\n\tfor i in range(1, size): \n\t\n\t\tif (A[i] < tailTable[0]): \n\n\t\t\t# new smallest value \n\t\t\ttailTable[0] = A[i] \n\n\t\telif (A[i] > tailTable[len-1]): \n\n\t\t\t# A[i] wants to extend \n\t\t\t# largest subsequence \n\t\t\ttailTable[len] = A[i] \n\t\t\tlen+= 1\n\n\t\telse: \n\t\t\t# A[i] wants to be current \n\t\t\t# end candidate of an existing \n\t\t\t# subsequence. It will replace \n\t\t\t# ceil value in tailTable \n\t\t\ttailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n\t\t\n\n\treturn len\n\n\n# Driver program to \n# test above function \n\na=int(input())\nz=list(map(int,input().split()))\nprint(Lis(z,a))\n", "def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LongestIncreasingSubsequenceLength(A, size): \n  \n    # Add boundary case, \n    # when array size is one \n   \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n  \n            # new smallest value \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n  \n            # A[i] wants to extend \n            # largest subsequence \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            # A[i] wants to be current \n            # end candidate of an existing \n            # subsequence. It will replace \n            # ceil value in tailTable \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\nn=int(input())\nl=list(map(int,input().split()))\nprint(LongestIncreasingSubsequenceLength(l, n))\n", "n = int(input())\na= list(map(int,input().split()))\nbit = [0]*(n+1)\ndef update(idx,val):\n    while idx<=n:\n        bit[idx] = max(bit[idx],val)\n        idx+=idx&(-idx)\ndef query(idx):\n    res =0\n    while idx>0:\n        res = max(res,bit[idx])\n        idx-=idx&(-idx)\n    return res\nb = []\nfor i in range(n):\n    b.append([a[i],-(i+1)])\nb.sort()\nfor i in range(n):\n    qe = query(-b[i][1])\n    update(-b[i][1],qe+1)\nprint(query(n))", "n=int(input())\na=list(map(lambda x: int(x), input().split()))\n\n\ndef CeilIndex(A, l, r, key):\n    while (r - l > 1):\n\n        m = l + (r - l) // 2\n        if (A[m] >= key):\n            r = m\n        else:\n            l = m\n    return r\n\n\ndef LongestIncreasingSubsequenceLength(A, size):\n    # Add boundary case,\n    # when array size is one\n\n    tailTable = [0 for i in range(size + 1)]\n    len = 0  # always points empty slot\n\n    tailTable[0] = A[0]\n    len = 1\n    for i in range(1, size):\n\n        if (A[i] < tailTable[0]):\n\n            # new smallest value\n            tailTable[0] = A[i]\n\n        elif (A[i] > tailTable[len - 1]):\n\n            # A[i] wants to extend\n            # largest subsequence\n            tailTable[len] = A[i]\n            len += 1\n\n        else:\n            # A[i] wants to be current\n            # end candidate of an existing\n            # subsequence. It will replace\n            # ceil value in tailTable\n            tailTable[CeilIndex(tailTable, -1, len - 1, A[i])] = A[i]\n\n    return len\nprint(LongestIncreasingSubsequenceLength(a,len(a)))", "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\ndef CeilIndex(A, l, r, key): \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef lis(A, size): \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n    return len\n\n\nn,=I()\np=I()\nan=1\nprint(lis(p,n))\n", "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\ndef CeilIndex(A, l, r, key): \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef lis(A, size): \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n    return len\nn,=I()\np=I()\nan=1\nprint(lis(p,n))\n", "import sys,math as mt\nimport heapq as hp\nimport collections as cc\nimport math as mt\nimport itertools as it\ninput=sys.stdin.readline\nI=lambda:list(map(int,input().split()))\ndef CeilIndex(A, l, r, key): \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef lis(A, size): \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n    return len\nn,=I()\nl=I()\nprint(lis(l,n))", "def CeilIndex(A, l, r, key): \n  \n    while (r - l > 1): \n      \n        m = l + (r - l)//2\n        if (A[m] >= key): \n            r = m \n        else: \n            l = m \n    return r \n   \ndef LongestIncreasingSubsequenceLength(A, size): \n  \n    # Add boundary case, \n    # when array size is one \n   \n    tailTable = [0 for i in range(size + 1)] \n    len = 0 # always points empty slot \n   \n    tailTable[0] = A[0] \n    len = 1\n    for i in range(1, size): \n      \n        if (A[i] < tailTable[0]): \n  \n            # new smallest value \n            tailTable[0] = A[i] \n   \n        elif (A[i] > tailTable[len-1]): \n  \n            # A[i] wants to extend \n            # largest subsequence \n            tailTable[len] = A[i] \n            len+= 1\n   \n        else: \n            # A[i] wants to be current \n            # end candidate of an existing \n            # subsequence. It will replace \n            # ceil value in tailTable \n            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i] \n          \n   \n    return len\nN = int(input())\nList = [int(x) for x in input().split()]\n\nprint(LongestIncreasingSubsequenceLength(List,N))\n", "from bisect import bisect_right\ndef answer(n,A):\n    ans=[A[0]]\n    for i in range(1,n):\n        if ans[-1]<A[i]:\n            ans.append(A[i])\n        else:\n            index=bisect_right(ans,A[i])\n            ans[index]=A[i]\n            \n    return len(ans)\n\n\nn=int(input())\narr=list(map(int,input().split()))\nprint(answer(n,arr))"]