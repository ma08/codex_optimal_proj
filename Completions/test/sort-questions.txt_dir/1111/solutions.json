["n, k = list(map(int, input().split()))\n\nMOD = 10**9+7\n\n\ndef fast_modinv(up_to, M):\n    ''' Fast modular inverses of 1..up_to   modulo M. '''\n    modinv = [-1 for _ in range(up_to + 1)]\n    modinv[1] = 1\n    for x in range(2, up_to + 1):\n        modinv[x] = (-(M//x) * modinv[M%x])%M\n    return modinv\n\nmaxn = 2*10**5 + 10\nmodinv = fast_modinv(maxn, MOD)\nfact, factinv = [1], [1]\nfor i in range(1, maxn):\n    fact.append(fact[-1]*i % MOD)\n    factinv.append(factinv[-1]*modinv[i] % MOD)\n\n\ndef Stirling(n, k):\n    '''The Stirling number of second kind (number of nonempty partitions). '''\n    if k > n:\n        return 0\n    result = 0\n    for j in range(k+1):\n        result += (-1 if (k-j)&1 else 1) * fact[k] * factinv[j] * factinv[k - j] * pow(j, n, MOD) % MOD\n        result %= MOD\n    result *= factinv[k]\n    return result % MOD\n\nW = sum(map(int, input().split())) % MOD\nprint((Stirling(n, k) + (n - 1) * Stirling(n - 1, k))* W % MOD)\n", "M = 0x3b9aca07\nrd = lambda: list(map(int, input().split()))\ninv = lambda x: (M - M // x) * inv(M % x) % M if x - 1 else 1\nn, k = rd()\nw = sum(rd()) % M\nmodinv = [0, 1]\nfor i in range(2, 200005):\n    modinv.append((M - M // i) * modinv[M % i] % M)\nf = [1, -1] \nfa_inv = [1]\nfor i in range(1, 200005):\n    fa_inv.append(fa_inv[-1] * modinv[i] % M)\ndef sti(n, m):\n    r = 0\n    if n >= m:\n        for i in range(m + 1):\n            r = (r + f[i & 1] * fa_inv[m - i] * fa_inv[i] * pow(m - i, n, M)) % M\n    return r\nprint(w * (sti(n, k) + (n - 1) * sti(n - 1, k)) % M)\n", "def read_data():\n    n, m = map(int, list(input().strip().split()))\n    a = list(map(int, list(input().strip().split())))\n    return n, m, a\n\ndef get_modinv(m):\n    modinv = [-1 for _ in range(m+1)]\n    modinv[1] = 1\n    for i in range(2,m+1):\n        modinv[i] = (-(div//i) * modinv[div%i]) % div\n    return modinv\n\ndef partitions(n,k):\n    if k >n :\n        return 0\n    val = 0\n    sign = 1\n    if k%2 == 1:\n        sign = -1\n    for i in range(k+1):\n        v = (fact[k] * factinv[i] * factinv[k-i] * pow(i,n,div)) % div\n        val += v * sign\n        val %= div\n        sign *= -1\n    val *= factinv[k]\n    return val % div\n\ndef solve():\n    modinv = get_modinv(n+1)\n    for i in range(1,n+2):\n        fact.append(fact[-1]*i%div)\n        factinv.append(factinv[-1] * modinv[i] % div)\n    return ((partitions(n,k) + (n-1)*partitions(n-1,k))*sum(a)) % div\n\ndiv = 10**9 + 7\nn, k, a = read_data()\nfact, factinv = [1], [1]\nprint(solve())", "def read_data():\n    n, m = map(int, list(input().strip().split()))\n    a = list(map(int, list(input().strip().split())))\n    return n, m, a\n \ndef get_modinv(m):\n    modinv = [-1 for _ in range(m+1)]\n    modinv[1] = 1\n    for i in range(2,m+1):\n        modinv[i] = (-(div//i) * modinv[div%i]) % div\n    return modinv\n \ndef partitions(n,k):\n    if k >n :\n        return 0\n    val = 0\n    sign = 1\n    if k%2 == 1:\n        sign = -1\n    for i in range(k+1):\n        v = (fact[k] * factinv[i] * factinv[k-i] * pow(i,n,div)) % div\n        val += v * sign\n        val %= div\n        sign *= -1\n    val *= factinv[k]\n    return val % div\n \ndef solve():\n    modinv = get_modinv(n+1)\n    for i in range(1,n+2):\n        fact.append(fact[-1]*i%div)\n        factinv.append(factinv[-1] * modinv[i] % div)\n    return ((partitions(n,k) + (n-1)*partitions(n-1,k))*sum(a)) % div\n \ndiv = 10**9 + 7\nn, k, a = read_data()\nfact, factinv = [1], [1]\nprint(solve())"]