["n, m  = (int(x) for x in input().strip().split())\n\ncoproc = [int(x) for x in input().strip().split()]\nedges = []\nfor _ in range(m):\n  edges.append((int(x) for x in input().strip().split()))\n\ninorder = [0] * n \nadj = [[] for _ in range(n)]\nfor u, v in edges:\n  adj[v].append(u)\n  inorder[u] += 1\n  \nqueue0 = [u for u in range(n) if inorder[u]==0 and not coproc[u]]\nqueue1 = [u for u in range(n) if inorder[u]==0 and coproc[u]]\n\nres = 0 \n\nwhile len(queue0)>0 or len(queue1)>0:\n  \n  while queue0:\n    next0 = []\n    for u in queue0:\n      for v in adj[u]:\n        inorder[v] -= 1 \n        if inorder[v] == 0:\n          if coproc[v]:\n            queue1.append(v)\n          else:\n            next0.append(v)\n    queue0 = next0\n    \n  if queue1:\n    res += 1   # coproc call\n  \n  \n  while queue1:\n    next1 = []\n    for u in queue1:\n      for v in adj[u]:\n        inorder[v] -= 1 \n        if inorder[v] == 0:\n          if coproc[v]:\n            next1.append(v)\n          else:\n            queue0.append(v)\n    queue1 = next1\n  \nprint(res)", "n, m = [int(x) for x in input().split()]\ntps = {i:int(t) for i, t in enumerate(input().split())}\ndeps = {i:0 for i in range(n)}\nparents = {i:[] for i in range(n)}\nleafs = {i for i in range(n)}\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    deps[x] += 1\n    parents[y].append(x)\n    if x in leafs:\n        leafs.remove(x)\n\ndeep = {i:tps[i] for i in range(n)}\nres = 0\nwhile len(leafs) > 0:\n    leaf = leafs.pop()\n    if len(parents[leaf])==0:\n        res = max(res, deep[leaf])\n        continue\n##    print(leaf, leafs)\n    for parent in parents[leaf]:\n        l = deep[leaf]\n        if tps[parent] == 1 and tps[leaf] == 0:\n            l += 1\n        if deep[parent] < l:\n            deep[parent] = l\n            \n        deps[parent] -= 1\n        if deps[parent] == 0:\n            leafs.add(parent)\n##        print(leaf, parent, l, deps[parent], leafs, deep)\n    \n    \nprint(res)\n", "from collections import deque\nimport sys\ninput = sys.stdin.readline\ndef put():\n    return list(map(int, input().split()))\n\ndef bfs_(main, co, flag):\n    curr = main if flag else co\n    while curr:\n        x = curr.popleft()\n        for y in graph[x]:\n            inedge[y]-=1\n            if inedge[y]==0:\n                if is_co[y]:co.append(y)\n                else:main.append(y)\n    return main,co\n\ndef bfs():\n    main, co, ans = deque(), deque(), 0\n    for i in range(n):\n        if inedge[i]==0:\n            if is_co[i]: co.append(i)\n            else:       main.append(i)\n\n    while main or co:\n        main, co = bfs_(main, co, True)\n        if co: ans+=1\n        main, co = bfs_(main, co, False)\n    return ans\n\nn,m   = put()\nis_co     = list(put())\ngraph = [[] for i in range(n)]\ninedge, vis= [0]*n, [0]*n\nfor _ in range(m):\n    x,y = put()\n    graph[y].append(x)\n    inedge[x]+=1\nprint(bfs())\n", "from sys import stdin\nfrom collections import deque\n\nn,m = [int(x) for x in stdin.readline().split()]\n\ne = [int(x) for x in stdin.readline().split()]\ngraph = [set() for x in range(n)]\nreverse = [set() for x in range(n)]\nroot = set([x for x in range(n)])\n\nfor edge in range(m):\n  a,b = [int(x) for x in stdin.readline().split()]\n  graph[b].add(a)\n  reverse[a].add(b)\n  if a in root:\n    root.remove(a)\n\ndone = set()\n\nqMain = deque(list(root))\nqCo = deque()\n\ntotal = -1\n\nwhile len(done) < n:\n  total += 1\n  while qCo:\n    nxt = qCo.popleft()\n    #print('co', nxt)\n    if e[nxt] == 0:\n      qMain.append(nxt)\n    else:\n      done.add(nxt)\n      for x in graph[nxt]:\n        reverse[x].remove(nxt)\n        if not reverse[x]:\n          qCo.append(x)\n    \n  while qMain:\n    nxt = qMain.popleft()\n    #print('main', nxt)\n    if e[nxt] == 1:\n      qCo.append(nxt)\n    else:\n      done.add(nxt)\n      for x in graph[nxt]:\n        reverse[x].remove(nxt)\n        if not reverse[x]:\n          qMain.append(x)\n\nprint(total)\n"]