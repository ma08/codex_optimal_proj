["n, m = map(int, input().split())\nl = list(map(int, input().split()))\nindex = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n\tmini = 10000000000000\n\tfor j in range(i, n):\n\t\tif l[j] < mini:\n\t\t\tinde = j\n\t\t\tmini = l[j]\n\t\tindex[i][j] = inde\nprime = 998244353\nd = {}\nval = [[1 for i in range(n + 1)] for j in range(n + 1)]\nfor i in range(n):\n\tfor j in range(n - i):\n\t\tif i == 0:\n\t\t\tval[j][j + i] = 1\n\t\telif i == 1:\n\t\t\tval[j][j + i] = 2\n\t\telse:\n\t\t\tind = index[j][j + i]\n\t\t\tsumap = 0\n\t\t\tsumak = 0\n\t\t\tfor p in range(j, ind +1):\n\t\t\t\tsumap += (val[j][p - 1] * val[p][ind - 1]) % prime\n\t\t\tfor k in range(ind, j + i + 1):\n\t\t\t\tsumak += (val[ind + 1][k] * val[k + 1][j + i]) % prime\n\t\t\tval[j][j + i] = (sumap * sumak) % prime\nprint(val[0][n-1])", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nA=[a-1 for a in A]\n\nMININDLIST=[[i]*m for i in range(m)]\n\nfor i in range(m):\n    MIN=A[i]\n    MININDNOW=i\n    for j in range(i,m):\n        if A[j]<MIN:\n            MIN=A[j]\n            MININDNOW=j\n\n        MININDLIST[i][j]=MININDNOW\n\nmod=998244353\n\nSCORE=[0]*((m+1)**2)\n\ndef calc(i,j,m):\n    if SCORE[i*(m+1)+j]!=0:\n        return SCORE[i*(m+1)+j]\n    \n    #print(i,j)\n    if j==i+1 or i==j:\n        return 1\n    \n    MININD=MININDLIST[i][j-1]\n\n    #print(MININD)\n\n    ANS1=ANS2=0\n \n    for mi in range(i,MININD+1):\n        ANS1=(ANS1+calc(i,mi,m)*calc(mi,MININD,m))%mod\n        \n    for Mi in range(MININD+1,j+1):\n        ANS2=(ANS2+calc(MININD+1,Mi,m)*calc(Mi,j,m))%mod\n \n    SCORE[i*(m+1)+j]=ANS1*ANS2%mod\n \n    return SCORE[i*(m+1)+j]\n \nprint(calc(0,m,m))\n            \n\n    \n", "def main():\n\n    line = input().split()\n    n = int(line[0])\n\n    line = input().split()\n\n    v = [int(x) for x in line]\n\n    mod = 998244353\n\n    dp = [[1] * (n + 5) for i in range(n + 5)]\n\n    for sz in range(2, n + 1):\n        for lo in range(1, n - sz + 2):\n            hi = lo + sz - 1\n\n            pos, num = -1, n + 5\n            \n            for k in range(lo, hi + 1):\n                if v[k - 1] < num:\n                    num = v[k - 1]\n                    pos = k\n            \n            s1, s2 = 0, 0\n\n            for k in range(lo, pos + 1):\n                cnt = dp[lo][k - 1] * dp[k][pos - 1] % mod\n                s1 = (s1 + cnt) % mod\n            \n            for k in range(pos, hi + 1):\n                cnt = dp[pos + 1][k] * dp[k + 1][hi] % mod\n                s2 = (s2 + cnt) % mod\n\n            dp[lo][hi] = s1 * s2 % mod\n\n    print(dp[1][n])\n\n\nmain()", "class SparseTable():\n    \"\"\"\u533a\u9593\u53d6\u5f97\u30af\u30a8\u30ea\u3092O(1)\u3067\u7b54\u3048\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u3092O(NlogN)\u3067\u69cb\u7bc9\u3059\u308b\n    query(l, r): \u533a\u9593[l, r)\u306b\u5bfe\u3059\u308b\u30af\u30a8\u30ea\u306b\u7b54\u3048\u308b\n    \"\"\"\n    def __init__(self, array, n):\n        n = len(array)\n        self.row_size = n.bit_length()\n\n        # log_table\u3092\u69cb\u7bc9\u3059\u308b\n        # log_table = [0, 0, 1, 1, 2, 2, 2, 2, ...]\n        self.log_table = [0] * (n + 1)\n        for i in range(2, n + 1):\n            self.log_table[i] = self.log_table[i//2] + 1\n\n        # sparse_table\u3092\u69cb\u7bc9\u3059\u308b\n        self.sparse_table = [[0] * n for _ in range(self.row_size)]\n        for i in range(n):\n            self.sparse_table[0][i] = array[i]\n        for row in range(1, self.row_size):\n            for i in range(n - (1 << row) + 1):\n                self.sparse_table[row][i] = self._merge(self.sparse_table[row - 1][i], \\\n                                            self.sparse_table[row - 1][i + (1 << row - 1)])\n\n    def _merge(self, num1, num2):\n        \"\"\"\u30af\u30a8\u30ea\u306e\u5185\u5bb9\"\"\"\n        return min(num1, num2)\n\n    def query(self, l, r):\n        \"\"\"\u533a\u9593[l, r)\u306b\u5bfe\u3059\u308b\u30af\u30a8\u30ea\u306b\u7b54\u3048\u308b\"\"\"\n        row = self.log_table[r - l]\n        return self._merge(self.sparse_table[row][l], self.sparse_table[row][r - (1 << row)])\n\n\nn, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nMOD = 998244353\n\nsp = SparseTable(a, n)\nto_ind = {}\nfor i in range(n):\n    to_ind[a[i]] = i\n\ndp = [[-1]*(n+1) for i in range(n+1)]\n\n\ndef solve(l, r):\n    if dp[l][r] != -1:\n        return dp[l][r]\n    if l == r:\n        dp[l][r] = 1\n        return 1\n    if r - l == 1:\n        dp[l][r] = 1\n        return 1\n    ind = to_ind[sp.query(l, r)]\n    res1 = 0\n    res2 = 0\n    for i in range(ind+1, r+1):\n        res1 += solve(ind+1, i) * solve(i, r)\n        res1 %= MOD\n    for i in range(l, ind+1):\n        res2 += solve(l, i) * solve(i, ind)\n        res2 %= MOD\n    dp[l][r] = max(res1, 1)*max(res2, 1)\n    dp[l][r] %= MOD\n    return dp[l][r]\n\nprint(solve(0, n) % MOD)\n", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n \nM = mod = 998244353 \ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\nn,m = li()\nl = li()\n\nl = [i - 1 for i in l]\nmintill = [[0]*m for i in range(m)]\nfor i in range(n):\n    curr = l[i]\n    an = i\n    for j in range(i + 1,m):\n        if l[j] < curr:\n            curr = l[j]\n            an = j\n        mintill[i][j] = an\n\nscore = [[-1]*(m + 1) for i in range(m + 1)]\n\ndef recursive(i,j):\n    if score[i][j] != -1:return score[i][j]\n    if i == j or i + 1== j:return 1\n    mincurr = mintill[i][j - 1]\n    left = right = 0\n\n    for k in range(i,mincurr + 1):\n        left = (left + recursive(i,k)*recursive(k,mincurr))%mod\n    for k in range(mincurr + 1,j + 1):\n        right = (right + recursive(mincurr + 1,k)*recursive(k,j))%mod\n    score[i][j] = left*right%mod\n    return score[i][j]\nprint(recursive(0,m))\n\n"]