["x = int(input())\ny = list(map(int, input().split(' ')))\nbad = x//2\ns = 0\nt=0\ny = y + y\nfor i in range(bad):\n    s += y[2*i]\n    # print(\"adding {} to s\".format(2*i))\n    t += y[2*i+1]\n    # print(\"adding {} to t\".format(2*i+1))\n\nmini = min(s, t)\nfor i in range(bad):\n    s -= y[2*i]\n    # print(\"subing {} to s\".format(2*i))\n\n    s += y[2*(bad+i)]\n    # print(\"adding {} to s\".format(2*(bad+i)))\n\n    t -= y[2*i+1]\n    # print(\"sub {} to t\".format(2*i+1))\n\n    t += y[2*(bad+i)+1]\n    # print(\"adding {} to t\".format(2*(bad+i)+1))\n\n    mini = min(mini, min(s, t))\nprint(sum(y)//2-mini)", "from collections import defaultdict as dd\nfrom collections import deque\nimport bisect\nimport heapq\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(map(int, input().split()))\n\n\ndef solve():\n    n = ri()\n    A = rl()\n    odd_total = 0\n    even_total = 0\n    for i in range(n):\n        if i % 2 == 0:\n            even_total += A[i]\n        else:\n            odd_total += A[i]\n\n    best = 0\n    even_before = 0\n    odd_before = 0\n    even_after = even_total\n    odd_after = odd_total\n    for i in range(n):\n        if i % 2 == 0:\n            even_after -= A[i]\n            even_before += A[i]\n            candidate = even_before + odd_after\n        else:\n            odd_after -= A[i]\n            odd_before += A[i]\n            candidate = odd_before + even_after\n        best = max(best, candidate)\n\n    print (best)\n\n\n\n\n\nmode = 's'\n\nif mode == 'T':\n    t = ri()\n    for i in range(t):\n        solve()\nelse:\n    solve()\n", "\nn = int(input())\na = list(map(int,input().split()))\n\nl1 = [0]\nl2 = [0]\nr1 = [0]\nr2 = [0]\n\nfor i in range(n):\n\n    if i % 2 == 0:\n        l1.append(l1[-1] + a[i])\n        l2.append(l2[-1])\n        r1.append(r1[-1])\n        r2.append(r2[-1] + a[n-1-i])\n\n    else:\n        l1.append(l1[-1])\n        l2.append(l2[-1] + a[i])\n        r1.append(r1[-1] + a[n-1-i])\n        r2.append(r2[-1])\n\nans = 0\nfor i in range(n+1):\n    ans = max(ans , l1[i]+r1[n-i] , l2[i]+r2[n-i])\nprint (ans)\n", "n = int(input())\nl = list(map(int, input().split()))\n\npref_odd = [0]\ncurr = 0\nfor i in range(n):\n    if i % 2 == 1:\n        curr += l[i]\n    pref_odd.append(curr)\n\npref_even = [0]\ncurr = 0\nfor i in range(n):\n    if i % 2 == 0:\n        curr += l[i]\n    pref_even.append(curr)\n\nbest = 0\nfor i in range(n):\n    o1 = pref_even[i] + (pref_odd[-1] - pref_odd[i+1])\n    o2 = pref_odd[i] + (pref_even[-1] - pref_even[i+1])\n    best = max(best,max(o1,o2)+l[i])\nprint(best)\n", "def getsum(a, b, pref):\n    if b < a:\n        b += n\n    return pref[b] - pref[a]\n\n\nfor _ in range(1):\n    # for _ in range(int(input())):\n    # a, b = map(int, input().split())\n    n = int(input())\n    arr = list(map(int, input().split()))\n    # s = input()\n    pref0 = [0] * (len(arr) + 1)\n    pref1 = [0] * (len(arr) + 1)\n    for i in range(1, len(pref0)):\n        pref0[i] = pref0[i - 1]\n        pref1[i] = pref1[i - 1]\n        if i % 2 == 1:\n            pref0[i] += arr[i - 1]\n        else:\n            pref1[i] += arr[i - 1]\n    mx = pref0[-1]\n    s = sum(arr)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            x = pref0[i + 1] + (s - pref0[-1] - pref1[i + 1])\n        else:\n            x = pref1[i + 1] + (s - pref1[-1] - pref0[i + 1])\n        mx = max(mx, x)\n    print(mx)", "n=int(input())\na=list(map(int,input().split()))\nans=0\nfor i in range(n//2):\n  ans+=a[2*i]\nans+=a[n-1]\npointer=n-1\npointer2=0\nmaxans=ans\nfor i in range(n):\n  ans-=a[pointer2]\n  pointer2=(pointer2+2)%n\n  ans+=a[(pointer+2)%n]\n  pointer=(pointer+2)%n\n  maxans=max(ans,maxans)\nprint(maxans)", "import sys\nimport heapq, functools, collections\nimport math, random\nfrom collections import Counter, defaultdict\n\n# available on Google, not available on Codeforces\n# import numpy as np\n# import scipy\n\n\ndef solve(lst):  # fix inputs here\n    console(\"----- solving ------\")\n\n    arr = []\n    arr.extend(lst[::2])\n    arr.extend(lst[1::2])\n    arr.extend(lst[::2])\n    arr.extend(lst[1::2])\n\n    psum = []\n    ps = 0\n    for i in arr:\n        ps += i\n        psum.append(ps)\n    \n    res = 0\n    sub_length = (len(lst)+1)//2\n    # console(psum, sub_length)\n    for i in range(len(lst)):\n        res = max(res, psum[i+sub_length] - psum[i])\n\n    # return a string (i.e. not a list or matrix)\n    return res\n\n\ndef console(*args):  # the judge will not read these print statement\n    print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\n    return\n\n# fast read all\n# sys.stdin.readlines()\n\n# for case_num in range(int(input())):\n    # read line as a string\n    # strr = input()\n\n    # read line as an integer\n_ = int(input())\n    \n    # read one line and parse each word as a string\n    # lst = input().split()\n\n    # read one line and parse each word as an integer\nlst = list(map(int,input().split()))\n\n    # read matrix and parse as integers (after reading read nrows)\n    # lst = list(map(int,input().split()))\n    # nrows = lst[0]  # index containing information, please change\n    # grid = []\n    # for _ in range(nrows):\n    #     grid.append(list(map(int,input().split())))\n\nres = solve(lst)  # please change\n    \n    # Google - case number required\n    # print(\"Case #{}: {}\".format(case_num+1, res))\n\n    # Codeforces - no case number required\nprint(res)\n", "y=lambda x:print(x)or quit()\nn=int(input())\np=list(map(int,input().split()))\nif n<2:y(p[0])\nif n<4:y(sum(p)-min(p))\ns=[p[-1],p[-2]]\nr=[p[0],p[1]]\nfor i in range(2,n):\n    r.append(r[-2]+p[i])\n    s.append(s[-2]+p[-i-1])\ns=s[::-1]\nm=r[-1]+r[-2]\nfor i in range(n-3):m=min(m,r[i]+s[i+3])\nm=min([m,r[n-3],s[1],s[2]])\ny(r[-1]+r[-2]-m)", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nn = int(input())\na = [int(item) for item in input().split()]\ntotal = sum(a)\nif n == 1:\n    print(total)\n    return\nval = sum(a[::2])\na.append(a[0])\n\nans = 0\nfor a0, a1 in zip(a, a[1:]):\n    val = total - val + a0\n    ans = max(ans, val)\nprint(ans)", "n = int(input())\na = list(map(int, input().rstrip().split()))\nif n == 1:\n    print(a[0])\nelse:\n    b = a + a\n    k = (n+1)//2\n    s = 0\n    for j in range(0, 2*k, 2):\n        s += b[j]\n    M = s\n    left = 0\n    while left + 2*k < 2*n:\n        s -= b[left]\n        s += b[left + 2*k]\n        M = max(s, M)\n        left += 2\n    s = 0\n    for j in range(1, 2*k+1, 2):\n        s += b[j]\n    M = max(s, M)\n    left = 1\n    while left + 2*k < 2*n:\n        s -= b[left]\n        s += b[left + 2*k]\n        M = max(s, M)\n        left += 2\n    print(M)", "N = int(input())\nA = list(map(int,input().split()))\ncumev = [0]\ncumod = [0]\nfor i,a in enumerate(A):\n    cumev.append(cumev[-1] + (a if i%2==0 else 0))\n    cumod.append(cumod[-1] + (a if i%2 else 0))\n\nans = cumev[-1]\nfor i,(e,o) in enumerate(zip(cumev,cumod)):\n    if i%2:\n        tmp = e + cumod[-1] - o\n    else:\n        tmp = o + cumev[-1] - e\n    ans = max(ans,tmp)\nprint(ans)\n", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\ndef solve1(a):\n\tn = len(a)\n\t\ndef solve():\n\tn = mint()\n\ta = list(mints())\n\tif n == 1:\n\t\tprint(a[0])\n\t\treturn\n\ta += a\n\t#print(a)\n\tb = [0]*(2*n)\n\tb[0] = a[0]\n\tb[1] = a[1]\n\tfor i in range(2,len(b)):\n\t\tb[i] = b[i-2]+a[i]\n\tr = min(b[n-3],b[n-3+1])\n\t#print(n-3)\n\t#print(b)\n\tfor j in range(n-3+2,len(b)):\n\t\t#print(j,j-(n-3)-2,b[j]-b[j-(n-3)-2])\n\t\tr = min(r, b[j]-b[j-(n-3)-2])\n\tprint(sum(a)//2-r)\n#for i in range(mint()):\nsolve()", "n=int(input())\na=list(map(int,input().split()))\na=[a[i%n] for i in range(0,2*n,2)]\ns1=sum(a[:(n+1)//2])\nsx=s1\nfor i in range(1,n):\n\ts1+=a[(i+(n-1)//2)%n]-a[i-1]\n\tsx=max(sx,s1)\nprint(sx)", "n = int(input())\na = list(map(int, input().split()))\nans = 0\ncnt = 0\nfor i in range(0, n, 2):\n    cnt += a[i]\nans = cnt\nj = 0\nfor i in range(n):\n    cnt -= a[j % n]\n    cnt += a[(j + 1) % n]\n    ans = max(cnt, ans)\n    j += 2\nprint(ans)", "n = int(input())\nl = list(map(int,input().split()))\ns = sum(l)\nx = 0\nk = n//2\nfor i in range(k):x+=l[i*2]\nminx = x\nfor i in range(n-1):\n    x-=l[(i*2)%n]\n    x+=l[((k+i)*2)%n]\n    minx = min(minx,x)\nprint(s-minx)", "import sys\nINF = 10**20\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\n\n\n\"\"\"\nFacts and Data representation\nConstructive? Top bottom up down\n\"\"\"\ndef find(x):\n  ans = []\n  for i in range(1, int(x ** 0.5) + 1):\n    if x % i:\n      continue\n    ans.append(i)\n    ans.append(x // i)\n  return ans\n\ndef solve():\n  n, = I()\n  a = I() * 2\n  ans = sum(a) // 2\n  mn = INF\n  odd = even = 0\n  for i in range(n - 1):\n    if i % 2:\n      odd += a[i]\n    else:\n      even += a[i]\n  mn = min(odd, even)\n  back = n - 1\n  for i in range(n - 1, 2 * n):\n    if i % 2:\n      odd += a[i]\n      odd -= a[i - back]\n    else:\n      even += a[i]\n      even -= a[i - back]\n    mn = min(mn, odd, even)\n  print(ans - mn)\n\n\nsolve()", "import math\nimport sys\ninput = sys.stdin.readline\nt = 1\nfor cs in range(t):\n    n = int(input())\n    a = [int(_) for _ in input().split()]\n    if n == 1:\n        print(a[0])\n        continue\n    pre = [0] * n\n    suf = [0] * n\n    for i in range(n):\n        if i >= 2:\n            pre[i] = pre[i - 2] + a[i]\n        else:\n            pre[i] = a[i]\n    for i in range(n - 1, -1, -1):\n        if i + 2 < n:\n            suf[i] = suf[i + 2] + a[i]\n        else:\n            suf[i] = a[i]\n    ans = max(pre[0], pre[1])\n    for i in range(n):\n        if i > 0:\n            ans = max(ans, pre[i - 1] + suf[i])\n        if i >= 3:\n            ans = max(ans, pre[i - 3] + suf[i])\n    print(ans)\n"]