["n, k = list(map(int,input().split()))\nL = list(map(int,input().split()))\ni = 0\np = 0\nz = 1\nR = [0 for _ in range(k)]\nwhile i<n:\n    R[p] += L[n-1-i]\n    p = p + z\n    i+=1\n    if p == k or p == -1:\n        z = z*(-1)\n        if p == k:\n            p = p - 1\n        else:\n            p = p + 1\nprint(max(R))\n\n", "n, k = map(int, input().split(\" \"))\ns = list(map(int, input().split(\" \")))\ns.sort()\nresult = s[len(s) - 1]\nwhile k*2 > n:\n\tn -= 1\n\tk -= 1\nif n > 0:\n\tfor i in range(int(n/2)):\n\t\tresult = max( result, s[i] + s[n-1-i])\nprint(result)", "n,k = list(map(int, input().strip().split()))\na = list(map(int, input().strip().split()))\nl = max(a)-1\nr = 100000000001\n\ndef check(s):\n\tcount = 0\n\tl = 0\n\tr = n-1\n\twhile l<=r:\n\t\tif l!=r and a[l]+a[r]<=s:\n\t\t\tcount +=1\n\t\t\tl+=1\n\t\t\tr-=1\n\t\telse:\n\t\t\tr-=1\n\t\t\tcount +=1\n\tif count <= k:\n\t\treturn True\n\telse:\n\t\treturn False\n\nwhile (r-l>1):\n\tm = (r+l+1)//2\n\t#print(l,m,r)\n\tif check(m):\n\t\tr = m\n\telse:\n\t\tl = m\n\t\nprint(r)\n", "\nn, k = list(map(int, input().split(\" \")))\nl = list(map(int, input().split(\" \")))\n\nli = []\n\nfor i in range((n-k-1)+1):\n    li.append(l[i] + l[2*(n-k-1)+1 - i])\n\nif(len(li) == 0):\n    print(l[n-1])\nelse:        \n    print(max(max(li), l[n-1]))\n", "n,k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nt = k - (2*k - n)\nres = 0\nfor i in range(t):\n\tres = max ( res, a[i] + a[2*t-1-i])\nres = max(res, a[n-1])\nprint (res) \n\n", "import sys\n\nline1 = sys.stdin.readline().split()\nn = int(line1[0])\nk = int(line1[1])\n\ns = sys.stdin.readline().split()\ns = [int(x) for x in s]\n\nif n == 1:\n    print(s[0])\nelse:\n    pairs = s[:(2*n-2*k)]\n\n    pair_sums = []\n    for i in range(int(len(pairs)/2)):\n        pair_sums.append(pairs[i]+pairs[-i-1])\n\n    #print(pairs)\n    #print(pair_sums)\n    if len(pair_sums)>0:\n        pmax = max(pair_sums)\n    else:\n        pmax = 0\n    singles = s[-(2*k-n):]\n    #print(singles)\n    if len(singles)>0:\n        smax = max(singles)\n    else:\n        smax = 0\n    print(max(pmax,smax))\n\n", "n,k = map(int,input().split())\nS = list(map(int,input().split()))\n\nt = n - k\nm = 0\nfor i in range(n):\n    if i < t:\n        s = S[i] + S[2*t - 1 - i]\n    elif i < 2*t:\n        continue\n    else:\n        s = S[i]\n    if s > m:\n        m = s\nprint(m)", "import math\nn, k = map(int, input().split())\ndata = list(map(int, input().split()))\ncolvo_1_cor = k * 2 - n\ncolvo_2_cor = k - colvo_1_cor\nanswer = []\nif colvo_1_cor > n:\n    colvo_1_cor = n\nfor i in range(colvo_1_cor):\n    answer.append(data[-1])\n    data.pop()\nif len(data) > 0:\n    index1 = 0\n    index2 = len(data) - 1    \n    while index1 != len(data) // 2 + 1:\n        answer.append(data[index1] + data[index2])\n        index1 += 1\n        index2 -= 1\nprint(max(answer))", "n, k = list(map(int, input().split()))\ns = list(map(int, input().split()))\nmaxi = 0\npos = n - 1\nif n == 1:\n    print(s[0])\nelse:\n if k >= n:\n     print(s[-1])\n else:\n  while 2 * (k - 1) >= (n - 1):\n      maxi = max(maxi, s[pos])\n      pos -= 1\n      k -= 1\n      n -= 1\n  posq = 0\n  while pos - posq >= 1:\n      maxi = max(maxi, s[posq] + s[pos])\n      pos -= 1\n      posq += 1\n  if pos == posq:\n      maxi = max(maxi, s[pos])\n  print(maxi)\n", "import math\n\ndef can_pack(m, b):\n    nonlocal n, k\n    cnt = 0\n    if b[-1] > m:\n        return False\n    p1 = 0\n    p2 = n - 1\n    while p1 < p2:\n        if b[p2] + b[p1] <= m:\n            p1 += 1\n            p2 -= 1\n        else:\n            p2 -= 1\n        cnt += 1\n    if p1 == p2:\n        cnt += 1\n    return cnt <= k\n\n\nn, k = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nl = 0\nr = 10 ** 9\nwhile l != r - 1:\n    m = (l + r) // 2\n    if not can_pack(m, b):\n        l = m\n    else:\n        r = m\nprint(r)", "n, k = list(map(int, input().split()))\nsizes = list(map(int, input().split()))\n\ndef solve(n, k, sizes):\n    if k >= n:\n        return max(sizes)\n    head = sizes[:n - k]\n    tail = sizes[n - k:]\n    for i, h in enumerate(head[::-1]):\n        tail[i] += h\n    return max(tail)\n\nprint(solve(n, k, sizes))\n", "n,k = input().split()\nn=int(n)\nk=int(k)\ns=input().split()\nfor i in range(n):\n    s[i]=int(s[i])\n    #print(i,\"\",end=\"\")\nr=(n-k)*2\nm=s[-1]\ni=0\nif(k>=n):\n    print(m)\nelse:\n    while(i<r):\n        x=s[i]+s[r-i-1]\n        #print(i,r-i)\n        if(m<x):\n            m=x\n        i+=1\n    print(m)\n", "n, k = map(int, input().split())\ns = list(map(int, input().split()))\n\np1 = []\np2 = []\n\nif n <= k:\n    print(max(s))\nelse:\n    for i in range(n - k):\n        p1.append(s[i] + s[2 * (n - k) - i - 1])\n        p2.append(s[2 * i] + s[2 * i + 1])\n    \n    for i in range(n - k + 1, n):\n        p1.append(s[i])\n        p2.append(s[i])\n    \n    print(min(max(p1), max(p2)))", "\"\"\"\nCodeforces Round #334 (Div. 2)\n\nProblem 604 B. More Cowbell\n\n@author yamaton\n@date 2015-12-01\n\"\"\"\n\nimport itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\n\ndef solve(xs, n, k):\n    if k >= n:\n        return max(xs)\n    ys1 = xs[:(n - k)]\n    ys2 = xs[(n - k) : 2*(n - k)]\n    maxval = max(a + b for (a, b) in zip(ys1, ys2[::-1]))\n    return max(maxval, xs[-1])\n\n# def pp(*args, **kwargs):\n#     return print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    xs = [int(c) for c in input().split()]\n    assert len(xs) == n\n    result = solve(xs, n, k)\n    print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "\"\"\"\nCodeforces Round #334 (Div. 2)\n\nProblem 604 B. More Cowbell\n\n@author yamaton\n@date 2015-12-01\n\"\"\"\n\nimport itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\n\ndef solve(xs, n, k):\n    # assert xs is sorted\n    if k >= n:\n        return xs[-1]\n    ys1 = it.islice(xs, n - k)\n    ys2 = it.islice(xs, n - k, 2*(n - k))\n    ys2rev = reversed(list(ys2))\n    maxval = max(a + b for (a, b) in zip(ys1, ys2rev))\n    return max(maxval, xs[-1])\n\n\n# def pp(*args, **kwargs):\n#     return print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    xs = [int(c) for c in input().split()]\n    assert len(xs) == n\n    result = solve(xs, n, k)\n    print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def main():\n\tn, k = (map(int, input().split()))\n\ts = list(map(int, input().split()))\n\n\tminSize = s[n - 1]\n\t\n\tif n <= k:\n\t\tprint(minSize)\n\t\treturn\n\n\t\n\ti = 0\n\ttotal = n - 1\n\twhile 2 * k > n :\n\t\tn, k = n - 1, k - 1\n\tfor i in range(k):\n\t\tminSize = max(minSize, s[i] + s[n - i - 1])\n\n\tprint(minSize)\n\n\n\ndef __starting_point():\n\tmain()\n__starting_point()", "a, b = list(map(int, input().split(' ')))\nx = list(map(int, input().split(' ')))\n\ndef f(num):\n    lo = 0\n    hi = a-1\n    ct = 0\n    while lo <= hi:\n        if lo == hi:\n            ct += 1\n            break\n        if x[lo] + x[hi] <= num:\n            lo+=1\n            hi-=1\n        else:\n            hi-=1\n        ct+=1\n    return ct\n\nlo = max(x)\nhi = 100000000\nwhile lo < hi:\n    mid = (lo + hi) // 2\n    if f(mid) > b:\n        lo = mid + 1\n    else:\n        hi = mid\n\nprint(lo)\n", "__author__ = 'heckboy'\n#!/usr/bin/env python\nn, k = map(int,input().split())\nL = list(map(int,input().split()))\ni = 0\np = 0\nz = 1\nR = [0 for _ in range(k)]\nwhile i<n:\n    R[p] += L[n-1-i]\n    p = p + z\n    i+=1\n    if p == k or p == -1:\n        z = z*(-1)\n        if p == k:\n            p = p - 1\n        else:\n            p = p + 1\nprint(max(R))", "n,k=map(int,input().split())\na=list(map(int,input().split()))\nd=n-k\nm=0\nfor i in range(d):\n    m=max(m,a[i]+a[2*d-i-1])\nprint(max(m,a[-1]))", "n, k = list(map(int, input().split(\" \")))\nthing = input()\nthing = thing.split(\" \")\nballs = []\nfor t in thing:\n    balls += [int(t)]\n\nif n<=k:\n    m = max(balls)\nelse:\n    squeeze = n-k\n\n    m=0\n\n    for i in range (squeeze):\n        current = balls[i] + balls[2*squeeze-1-i]\n        m = max(current, m)\n\n    m = max(balls[n-1], m)\n\nprint (m)\n", "#!/usr/bin/env python3\n# 604B_cowbell.py - Codeforces.com/problemset/problem/604/B by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Cowbell Class (Main Program)\n###############################################################################\n\n\nclass Cowbell:\n    \"\"\" Cowbell representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n, self.k] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.nums = list(map(int, uinput().split()))\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        b = self.nums[self.n-self.k:]\n        for i in range(self.n-self.k):\n            b[i] += self.nums[self.n-self.k-1-i]\n        result = max(b)\n\n        return str(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Cowbell class testing \"\"\"\n\n        # Constructor test\n        test = \"2 1\\n2 5\"\n        d = Cowbell(test)\n        self.assertEqual(d.n, 2)\n        self.assertEqual(d.k, 1)\n        self.assertEqual(d.nums, [2, 5])\n\n        # Sample test\n        self.assertEqual(Cowbell(test).calculate(), \"7\")\n\n        # Sample test\n        test = \"4 3\\n2 3 5 9\"\n        self.assertEqual(Cowbell(test).calculate(), \"9\")\n\n        # Sample test\n        test = \"3 2\\n3 5 7\"\n        self.assertEqual(Cowbell(test).calculate(), \"8\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Cowbell(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Cowbell(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Cowbell().calculate())\n\n__starting_point()", "n, k = map(int, input().split(\" \"))\ns = list(map(int, input().split(\" \")))\nresult = s[-1]\nwhile k*2 > n:\n    n -= 1\n    k -= 1\nif n > 0:\n    for i in range(int(n/2)):\n        result = max( result, s[i] + s[n-1-i])\nprint(result)", "num_cows, num_boxes = list(map(int, input().split()))\ncows = list(map(int, input().split()))\nneed = cows[-1]\nlimit = 2 * (num_cows - num_boxes)\nfor left in range(limit):\n    right = limit - 1 - left\n    if right < left:\n        break\n    need = max(need, cows[left] + cows[right])\nprint(need)\n", "n, k = map(int, input().split())\nsize = list(map(int, input().split()))\nl = size[-1] - 1\nr = size[-1] * 2\nwhile r - l > 1:\n    m = (r + l) // 2\n    x1, x2 = 0, len(size) - 1\n    cnt = 0\n    while x1 <= x2:\n        if size[x1] + size[x2] <= m:\n            x1 += 1\n            x2 -= 1\n        else:\n            x2 -= 1\n        cnt += 1\n    if cnt <= k:\n        r = m\n    else:\n        l = m\nprint(r)", "def __starting_point():\n    n, k = list(map(int, input().split()))\n    s_list = list(map(int, input().split()))\n\n    a_list = s_list[:n - min(n, 2 * k - n)]\n    b_list = reversed(a_list)\n    c_list = [a + b for a, b in zip(a_list, b_list)]\n    print(max(max(c_list or [0]), max(s_list)))\n\n__starting_point()"]