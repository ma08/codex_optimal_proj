["import sys\nfrom collections import deque\n\ninput=sys.stdin.readline\n\nfor _ in range(int(input())):\n    n=int(input())\n    edge=[[] for i in range(n)]\n    for i in range(n-1):\n        u,v=list(map(int,input().split()))\n        edge[u-1].append(v-1)\n        edge[v-1].append(u-1)\n    m=int(input())\n    p=list(map(int,input().split()))\n\n    size=[1 for i in range(n)]\n    parent=[-1 for i in range(n)]\n    res=[]\n    deq=deque([(0,-1)])\n    while deq:\n        v,pv=deq.popleft()\n        res.append(v)\n        for nv in edge[v]:\n            if nv!=pv:\n                parent[nv]=v\n                deq.append((nv,v))\n\n    res=res[::-1]\n    for v in res:\n        for nv in edge[v]:\n            if nv!=parent[v]:\n                size[v]+=size[nv]\n\n    coef=[]\n    for v in res:\n        for nv in edge[v]:\n            if nv!=parent[v]:\n                c=size[nv]*(n-size[nv])\n                coef.append(c)\n    mod=10**9+7\n    #print(coef)\n    #print(p)\n    #print(size)\n    if m<n-1:\n        res=0\n        coef.sort(reverse=True)\n        p.sort(reverse=True)\n        for i in range(m):\n            res+=coef[i]*p[i]\n            res%=mod\n        for i in range(m,n-1):\n            res+=coef[i]\n            res%=mod\n        print(res)\n    else:\n        res=0\n        coef.sort()\n        p.sort()\n        for i in range(n-2):\n            res+=coef[i]*p[i]\n            res%=mod\n        tmp=coef[-1]\n        for i in range(n-2,m):\n            tmp*=p[i]\n            tmp%=mod\n        res=(res+tmp)%mod\n        print(res)\n", "mod = 10**9+7\nimport sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nclass Graph(object):\n\t\"\"\"docstring for Graph\"\"\"\n\tdef __init__(self,n,d): # Number of nodes and d is True if directed\n\t\tself.n = n\n\t\tself.graph = [[] for i in range(n)]\n\t\tself.parent = [-1 for i in range(n)]\n\t\tself.directed = d\n\t\t\n\tdef addEdge(self,x,y):\n\t\tself.graph[x].append(y)\n\t\tif not self.directed:\n\t\t\tself.graph[y].append(x)\n\n\tdef bfs(self, root): # NORMAL BFS\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tvis[i] = 1\n\n\tdef dfs(self, root, ans): # Iterative DFS\n\t\tstack=[root]\n\t\tvis=[0]*self.n\n\t\tstack2=[]\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tstack.append(i)\n\n\t\twhile len(stack2)!=0: # BACKTRACING. Modify the loop according to the question\n\t\t\telement = stack2.pop()\n\t\t\tm = 0\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif i!=self.parent[element]:\n\t\t\t\t\tm += ans[i]\n\t\t\tans[element] = m+1\n\t\treturn ans\n\n\tdef shortestpath(self, source, dest): # Calculate Shortest Path between two nodes\n\t\tself.bfs(source)\n\t\tpath = [dest]\n\t\twhile self.parent[path[-1]]!=-1:\n\t\t\tpath.append(parent[path[-1]])\n\t\treturn path[::-1]\n\n\tdef detect_cycle(self):\n\t\tindeg = [0]*self.n\n\t\tfor i in range(self.n):\n\t\t\tfor j in self.graph[i]:\n\t\t\t\tindeg[j] += 1\n\t\tq = deque()\n\t\tvis = 0\n\t\tfor i in range(self.n):\n\t\t\tif indeg[i]==0:\n\t\t\t\tq.append(i)\n\t\twhile len(q)!=0:\n\t\t\te = q.popleft()\n\t\t\tvis += 1\n\t\t\tfor i in self.graph[e]:\n\t\t\t\tindeg[i] -= 1\n\t\t\t\tif indeg[i]==0:\n\t\t\t\t\tq.append(i)\n\t\tif vis!=self.n:\n\t\t\treturn True\n\t\treturn False\n\n\tdef reroot(self, root, ans):\n\t\tstack = [root]\n\t\tvis = [0]*n\n\t\twhile len(stack)!=0:\n\t\t\te = stack[-1]\n\t\t\tif vis[e]:\n\t\t\t\tstack.pop()\n\t\t\t\t# Reverse_The_Change()\n\t\t\t\tcontinue\n\t\t\tvis[e] = 1\n\t\t\tfor i in graph[e]:\n\t\t\t\tif not vis[e]:\n\t\t\t\t\tstack.append(i)\n\t\t\tif self.parent[e]==-1:\n\t\t\t\tcontinue\n\t\t\t# Change_The_Answers()\n\n\tdef maximizeSum(self):\n\t\tedges = []\n\t\tfor i in range(1,n):\n\t\t\tedges.append(count[i]*(n-count[i]))\n\t\tedges.sort()\n\t\t# print (edges)\n\n\t\tans = 0\n\t\tfor i in range(n-1):\n\t\t\tans += (edges[i]*a[i])%mod\n\t\t\tans = ans%mod\n\n\t\treturn (ans)\n\n\n\nfor nt in range(int(input())):\n\tn = int(input())\n\tg = Graph(n,False)\n\tfor i in range(n-1):\n\t\tx,y = list(map(int,input().split()))\n\t\tg.addEdge(x-1,y-1)\n\n\n\tm = int(input())\n\ta = list(map(int,input().split()))\n\tif m<=n-1:\n\t\ta.extend([1]*(n-1-m))\n\t\ta.sort()\n\telse:\n\t\ta.sort()\n\t\tx = 1\n\t\tfor i in range(n-2,m):\n\t\t\tx = (x*a[i])%mod\n\t\t\tx = x%mod\n\t\ta = a[0:n-2]+[x]\n\t# print (a)\n\tcount = [0]*n\n\tcount = g.dfs(0,count)\n\t# print (count)\n\tprint(g.maximizeSum()) \n", "import sys\ninput = sys.stdin.readline\nmod=1000000007\nfor f in range(int(input())):\n    n=int(input())\n    \n    neig=[0]*n\n    for i in range(n):\n        neig[i]=[0]\n    edges=[]\n    for i in range(n-1):\n        vertexa,vertexb=map(int,input().split())\n        vertexa-=1\n        vertexb-=1\n        neig[vertexa][0]+=1\n        neig[vertexb][0]+=1\n        neig[vertexa].append(vertexb)\n        neig[vertexb].append(vertexa)\n        edges.append([vertexa,vertexb])\n    tod=[]\n    upn=[-1]*n\n    dn=[1]*n\n    for i in range(n):\n        if neig[i][0]==1:\n            tod.append(i)\n    while len(tod)>0:\n        x=tod.pop()\n        neig[x][0]=0\n        for foo in range(1,len(neig[x])):\n            v=neig[x][foo]\n            if neig[v][0]>0:\n                neig[v][0]-=1\n                upn[x]=v\n                dn[v]+=dn[x]\n                if neig[v][0]==1:\n                    tod.append(v)\n    m=int(input())\n    p=list(map(int,input().split()))\n    p.sort(reverse=True)\n    facs=[1]*(n-1)\n    if m<n:\n        for i in range(m):\n            facs[i]=p[i]\n    else:\n        diff=m-(n-1)\n        for j in range(diff):\n            facs[0]*=p[j]\n            facs[0]%=mod\n        for j in range(diff,m):\n            facs[j-diff]*=p[j]\n    wedgies=[0]*(n-1)\n    for i in range(n-1):\n        a,b=edges[i][0],edges[i][1]\n        if upn[a]==b:\n            wedgies[i]=dn[a]*(n-dn[a])\n        else:\n            wedgies[i]=dn[b]*(n-dn[b])\n    wedgies.sort(reverse=True)\n    sol=0\n    for i in range(n-1):\n        sol+=wedgies[i]*facs[i]\n        sol%=mod\n    print(sol)"]