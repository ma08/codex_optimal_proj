["import sys\nsys.stdin = open('input.txt')\nsys.stdout = open('output.txt','w')\n\nn = int(input())\na = list(map(int, input().split()))\n\nr1, c1, r2, c2 = (i - 1 for i in map(int, input().split()))\nx, y = (r1, r2) if r1 < r2 else (r2, r1)\n\nif r1 < r2: c1 = min(c1, min(a[i] for i in range(r1 + 1, r2 + 1)))\nelif r2 < r1: c1 = min(c1, min(a[i] for i in range(r2, r1)))\n\nd = abs(c1 - c2)\nc = c1\nfor i in range(x - 1, -1, -1):\n    if c > a[i]:\n        c = a[i]\n        q = abs(c2 - c) + 2 * abs(x - i)\n        if q < d: d = q\nc = c1\nfor i in range(y + 1, n):\n    if c > a[i]:\n        c = a[i]\n        q = abs(c2 - c) + 2 * abs(i - y)\n        if q < d: d = q\nprint(d + abs(r2 - r1))", "import sys\n\nsys.stdin = open('input.txt')\nsys.stdout = open('output.txt', 'w')\n\nn = int(input())\na = [int(x) for x in input().split()]\n[r1, c1, r2, c2] = [int(x) for x in input().split()]\n\nr1 -= 1\nr2 -= 1\nc1 -= 1\nc2 -= 1\n\ndr = r2 - r1\nddr = dr // abs(dr) if dr != 0 else 1\n\nc = c1\n\nfor i in range(abs(dr)+1):\n    r = r1 + ddr*i\n    c = min(c, a[r])\n\npen1 = 0\nfor i in range(min(r1, r2)):\n    pen = (min(r1, r2) - i) * 2\n    if c > c2 and a[i] < c and a[i] <= min(a[i:min(r1, r2)]):\n        pen -= c - c2 - abs(a[i] - c2)\n    pen1 = min(pen1, pen)\n\npen2 = 0\nfor i in range(max(r1, r2)+1, n):\n    pen = (i - max(r1, r2)) * 2\n    if c > c2 and a[i] < c and a[i] <= min(a[max(r1, r2):i]):\n        pen -= c - c2 - abs(a[i] - c2)\n    pen2 = min(pen2, pen)\n    # print(i+1, pen2)\n\npen = abs(dr) + abs(c - c2)\n# print(dr, c, c2)\n# print(pen, pen1, pen2)\nprint(min(pen + pen1, pen+ pen2))", "import sys\nsys.stdin = open('input.txt')\nsys.stdout = open('output.txt','w')\n\nn = int(input())\na = list(map(int, input().split()))\nr1, c1, r2, c2 = list(map(int, input().split()))\nr1 -= 1 ; r2 -= 1 ; c1 -= 1 ; c2 -= 1\nsign = 1 if r2 - r1 >= 0 else -1\nfor i in range(abs(r2 - r1) + 1):\n    c1 = min(c1, a[r1 + sign * i]) \nres1 = 0\nfor i in range(min(r1, r2)):\n    tmp = (min(r1, r2) - i) * 2\n    if c1 > max(c2, a[i]) and a[i] <= min(a[i:min(r1, r2)]):\n        tmp -= c1 - c2 - abs(a[i] - c2)\n    res1 = min(res1, tmp) \nres2 = 0\nfor i in range(max(r1, r2)+1, n):\n    tmp = (i - max(r1, r2)) * 2\n    if c1 > max(c2, a[i]) and a[i] <= min(a[max(r1, r2):i]):\n        tmp -= c1 - c2 - abs(a[i] - c2)\n    res2 = min(res2, tmp)\nprint(min(res1, res2) + abs(r2 - r1) + abs(c1 - c2))\n", "import sys\nfrom collections import *\n\n\ndef arr_inp(n):\n    return [int(x) for x in sys.stdin.readline().split()]\n\n\ndef up():\n    nonlocal ans\n    mi, c = pos[1], 0\n    for i in range(pos[0], n + 1):\n        mi = min(mi, cols[i - 1] + 1)\n\n        if i == pos[2]:\n            ans = min(ans, pos[2] - pos[0] + abs(mi - pos[3]))\n        elif i > pos[2]:\n            if pos[2] < pos[0]:\n                ans = min(ans, (pos[0] - pos[2]) + (2 * c) + abs(min(min(cols[pos[2] - 1:pos[0]]) + 1, mi) - pos[3]))\n            else:\n                ans = min(ans, (i - pos[2]) + c + abs(min(min(cols[pos[0]:i]) + 1, mi) - pos[3]))\n\n        c += 1\n\n\ndef down():\n    nonlocal ans\n    mi, c = pos[1], 1\n    for i in range(pos[0] - 1, 0, -1):\n        mi = min(mi, cols[i - 1] + 1)\n\n        if i == pos[2]:\n            ans = min(ans, pos[0] - pos[2] + abs(mi - pos[3]))\n        elif i < pos[2]:\n            if pos[2] >= pos[0]:\n                ans = min(ans, (pos[2] - pos[0]) + (2 * c) + abs(min(min(cols[pos[0] - 1:pos[2]]) + 1, mi) - pos[3]))\n            else:\n                ans = min(ans, (pos[2] - i) + c + abs(min(min(cols[i:pos[0]]) + 1, mi) - pos[3]))\n\n        c += 1\n\n\nsys.stdin = open('input.txt')\nsys.stdout = open('output.txt', 'w')\nn, cols, pos = int(sys.stdin.readline()), arr_inp(1), arr_inp(1)\nans = float('inf')\nup()\ndown()\nprint(ans)\n", "from collections import deque\n\n\ndef read(line):\n    return [int(c) for c in line.split()]\n\n\ndef solve(n, lines, r1, c1, r2, c2):\n    queue = deque([(r1, c1, 0)])\n    visited = {}\n    while queue:\n        r, c, cost = queue.pop()\n\n        if (r, c) not in visited:\n            visited[(r, c)] = cost\n        else:\n            if cost < visited[(r, c)]:\n                visited[(r, c)] = cost\n            else:\n                continue\n\n        # left or right to the target column\n        if c2 <= lines[r - 1] + 1:\n            queue.appendleft((r, c2, cost + abs(c - c2)))\n\n        # right to last column\n        last_pos = lines[r - 1] + 1\n        if c < last_pos:\n            queue.appendleft((r, last_pos, cost + abs(c - last_pos)))\n\n        # up\n        if r - 1 >= 1:\n            last_pos_prev = lines[r - 2] + 1\n            if last_pos_prev >= c:\n                queue.appendleft((r - 1, c, cost + 1))\n            else:\n                queue.appendleft((r - 1, last_pos_prev, cost + 1))\n\n        # down\n        if r + 1 <= n:\n            last_pos_next = lines[r] + 1\n            if last_pos_next >= c:\n                queue.appendleft((r + 1, c, cost + 1))\n            else:\n                queue.appendleft((r + 1, last_pos_next, cost + 1))\n\n    return visited[(r2, c2)]\n\n\ndef main():\n    with open('input.txt') as f:\n        test = f.readlines()\n\n    n, = read(test[0])\n    lines = read(test[1])\n    r1, c1, r2, c2 = read(test[2])\n    ans = solve(n, lines, r1, c1, r2, c2)\n    with open('output.txt', 'w') as f:\n        f.write(str(ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]