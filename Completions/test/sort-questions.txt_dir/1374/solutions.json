["def main():\n    N, *A = list(map(int, open(0).read().split()))\n\n    B = sorted(A)\n    l, r = 0, N\n    m, c = N // 2, N * (N + 1) // 2\n\n    def check(x):\n        b, r, y = N, 0, 0\n        D = [0] * (2 * N + 1)\n        for a in A:\n            D[b] += 1\n            if a < x:\n                r += D[b]\n                b += 1\n            else:\n                b -= 1\n                r -= D[b]\n            y += r\n        return y\n\n    while True:\n        if check(B[m]) <= c // 2:\n            if m == N - 1 or check(B[m + 1]) > c // 2:\n                break\n            l, m = m, (m + r) // 2\n        else:\n            m, r = (m + l) // 2, m + 1\n\n    print((B[m]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\na = list(map(int, input().split()))\nx = list(sorted(set(a)))\nn_sub = n * (n + 1) // 2\nLi = 0\nRi = len(x)\nwhile Ri > Li + 1:\n    i = (Li + Ri) // 2\n    xi = x[i]\n    UorD = [1 if ak >= xi else -1 for ak in a]\n    cnt_sum = [0] * (2 * n + 1)\n    cumsum = 0\n    cnt_sum[cumsum + n] = 1\n    judge = 0\n    s = 0\n    for uk in UorD:\n        cumsum += uk\n        if uk == 1:\n            s += cnt_sum[cumsum + n] + 1\n        else:\n            s -= cnt_sum[cumsum + n + 1] - 1\n        cnt_sum[cumsum + n] += 1\n        judge += s\n        if judge >= n_sub // 2:\n            Li = i\n            break\n    else:\n        Ri = i\nprint((x[Li]))\n", "N = int(input())\nA = list(map(int, input().split()))\nNN = ((N + 1) * N // 2 + 1) // 2\n\ndef ok(x):\n    B = [0] * (2 * N + 1)\n    res, cum, cur = 0, 0, 0\n    B[0] += 1\n    for a in A:\n        if a >= x:\n            cum += 1\n            cur += B[cum]+1\n        else:\n            cur -= B[cum]-1\n            cum -= 1\n        B[cum] += 1\n        res += cur\n    return res >= NN\n\nB = sorted(set(A))\nl = 0\nr = len(B)\nwhile r - l > 1:\n    m = (l + r) // 2\n    if ok(B[m]):\n        l = m\n    else:\n        r = m\nprint(B[l])", "\ndef median_of_medians(N: int, A: list)->int:\n    def search(c):\n        bar = N\n        r = 0\n        res_nega = 0\n        dp_arr = [0]*(2*N+1)\n        for i in range(N):\n            dp_arr[bar] += 1\n            if A[i] < c:\n                r += dp_arr[bar]\n                bar += 1\n            else:\n                r -= (dp_arr[bar-1])\n                bar -= 1\n            res_nega += r\n        return res_nega\n\n    # binary search\n    a_sorted = sorted(A)\n    left = 0\n    right = N\n    mid = N // 2\n    C = N*(N+1) // 2\n    while True:\n        if search(a_sorted[mid]) <= C // 2:\n            if mid == N-1:\n                break\n            elif search(a_sorted[mid+1]) > C // 2:\n                break\n            else:\n                left = mid\n                mid = (mid + right) // 2\n        else:\n            right = mid + 1\n            mid = (mid + left) // 2\n\n    return a_sorted[mid]\n\n\ndef __starting_point():\n    N = int(input())\n    A = [int(s) for s in input().split()]\n    ans = median_of_medians(N, A)\n    print(ans)\n\n__starting_point()", "n=int(input())\na=list(map(int,input().split()))\na2=sorted(set(a))\nL=len(a2)\nif n==1:print(a[0]);return\nelif n==2:print(a[1]);return\nng=L\nok=0\nwhile ng-ok>1:\n    check=a2[(ok+ng)//2]\n    cnt=0 #check\u4ee5\u4e0a\u306e\u8981\u7d20\u306e\u6570\n    idx=n\n    cl=[0]*(2*n+1)\n    cl[n]=1\n    Ru=0\n    for i in range(n):\n        if a[i]<check:\n            Ru-=cl[idx]-1\n            idx-=1\n        else:\n            idx+=1\n            Ru+=cl[idx]+1\n        cnt += Ru\n        cl[idx]+=1\n    if cnt >= ((n+1)*n//2)//2:\n        ok = (ok+ng)//2\n    else:\n        ng = (ok+ng)//2\nprint(a2[ok])", "def f(n, a):\n    x = list(sorted(set(a)))\n    n_sub_half = n * (n + 1) // 2 // 2\n    n_plus_minus = n * 2 + 1\n    Li = 0\n    Ri = len(x)\n    while Ri > Li + 1:\n        i = (Li + Ri) // 2\n        xi = x[i]\n        cnt_sum = [0] * n_plus_minus\n        cumsum = 0\n        cnt_sum[cumsum] = 1\n        judge = 0\n        s = 0\n        for ak in a:\n            if ak >= xi:\n                cumsum += 1\n                s += cnt_sum[cumsum] + 1\n            else:\n                cumsum -= 1\n                s -= cnt_sum[cumsum + 1] - 1\n            cnt_sum[cumsum] += 1\n            judge += s\n            if judge >= n_sub_half:\n                Li = i\n                break\n        else:\n            Ri = i\n    print(x[Li])\n\nn = int(input())\na = list(map(int, input().split()))\nf(n, a)", "def f(n, a):\n    x = list(sorted(set(a)))\n    n_sub_half = n * (n + 1) // 2 // 2\n    n_plus_minus = n * 2 + 1\n    Li = 0\n    Ri = len(x)\n    while Ri > Li + 1:\n        i = (Li + Ri) // 2\n        xi = x[i]\n        cnt_sum = [0] * n_plus_minus\n        cumsum = 0\n        cnt_sum[cumsum] = 1\n        judge = 0\n        s = 0\n        for ak in a:\n            if ak >= xi:\n                cumsum += 1\n                s += cnt_sum[cumsum] + 1\n            else:\n                cumsum -= 1\n                s -= cnt_sum[cumsum + 1] - 1\n            cnt_sum[cumsum] += 1\n            judge += s\n            if judge >= n_sub_half:\n                Li = i\n                break\n        else:\n            Ri = i\n    print((x[Li]))\n\n\nn = int(input())\na = list(map(int, input().split()))\nf(n, a)\n", "n = int(input())\nA = list(map(int, input().split()))\n\ndef search(x):\n    b = n\n    r = 0\n    y = 0\n    D = [0]*(2*n+1)\n    for i in range(n):\n        D[b] += 1\n        if A[i] < x:\n            r += D[b]\n            b += 1\n        else:\n            b -= 1\n            r -= D[b]   \n        y += r\n    return y\n\nS = sorted(A)\nl = 0\nr = n\nm = n // 2\nc = n * (n + 1) // 2\n\nwhile True:\n    if search(S[m]) <= c // 2:\n        if m == n - 1:\n            break\n        elif search(S[m + 1]) > c // 2:\n            break\n        else:\n            l = m\n            m = (m + r) // 2\n    else:\n        r = m + 1\n        m = (m + l) // 2\n        \nprint((S[m]))\n", "n=int(input())\na=list(map(int,input().split()))\na2=sorted(set(a))\nL=len(a2)\nif n==1:print(a[0]);return\nelif n==2:print(a[1]);return\nng=L\nok=0\nwhile ng-ok>1:\n    check=a2[(ok+ng)//2]\n    cnt=0 #check\u4ee5\u4e0a\u306e\u8981\u7d20\u306e\u6570\n    idx=n\n    cl=[0]*(2*n+1)\n    cl[n]=1\n    Ru=0\n    for i in range(n):\n        if a[i]<check:\n            Ru-=cl[idx]-1\n            idx-=1\n        else:\n            idx+=1\n            Ru+=cl[idx]+1\n        cnt += Ru\n        cl[idx]+=1\n    if cnt >= ((n+1)*n//2)//2:\n        ok = (ok+ng)//2\n    else:\n        ng = (ok+ng)//2\n\nprint(a2[ok])", "N = int(input())\nA = list(map(int, input().split()))\n \nsortA = sorted(set(A)) + [float('inf')]\n \ndef isOk(n):\n    x = sortA[n]\n    count = [0 for _ in range(2 * N + 1)]\n    count[N + 1] = 1\n \n    i = N + 1\n    s = 1\n    result = 0\n \n    for a in A:\n        if a >= x:\n            i += 1\n            s += count[i]\n        else:\n            s -= count[i]\n            i -= 1\n        result += s\n        count[i] += 1\n        s += 1\n \n    if result >= N * (N + 1) // 4:\n        return False\n    else:\n        return True\n \n \nleft = 0\nright = len(sortA) - 1\n \nwhile right - left > 1:\n    mid = (left + right ) // 2\n \n    if isOk(mid):\n        right = mid\n    else:\n        left = mid\n \nprint(sortA[left])", "def main():\n    n,*a=map(int,open(0).read().split())\n    m=n*-~n//2+1>>1\n    ng=max(a)+1\n    ok=0\n    while ng-ok>1:\n        mid=ok+ng>>1\n        b=[1]+[0]*n*2\n        c=d=s=0\n        for t in a:\n            if t>=mid:\n                c+=1\n                d+=b[c]+1\n            else:\n                d-=b[c]-1\n                c-=1\n            b[c]+=1\n            s+=d\n        if s>=m:ok=mid\n        else:ng=mid\n    print(ok)\nmain()", "import numpy as np\nfrom collections import defaultdict\n\nN = int(input())\nA = np.array(input().split(), dtype=np.int32)\ntotal_medians = N*(N+1)//2\n# n\u4ef6\u306e\u30c7\u30fc\u30bf\n# (\u4e0a\u5074\u4e2d\u592e\u5024 >= x) iff (a > x \u3068\u306a\u308b a \u304c(n-1)//2\u4ee5\u4e0b)\n\ndef test(x):\n  # \u300c\u7b54\u306fx\u4ee5\u4e0b\u3067\u3042\u308b\u300d\n  # \u300cx\u3088\u308a\u771f\u306b\u5927\u304d\u306a\u533a\u9593\u4e2d\u592e\u5024\u304c(total_medians-1)//2\u500b\u4ee5\u4e0b\u300d\n  # x\u3088\u308a\u771f\u306b\u5927\u304d\u306a\u5024\u30921\u3001\u4ed6\u3092-1\u3068\u3059\u308b\u3002\n  # 1\u306e\u500b\u6570\u304c-1\u306e\u500b\u6570\u4ee5\u4e0a\u306b\u306a\u3063\u3066\u3044\u308b\u533a\u9593\n  current = 0 # \u7d2f\u7a4d\u548c\n  memo = defaultdict(int) # \u904e\u53bb\u306e\u7d2f\u7a4d\u548c\u306e\u5206\u5e03, incl empty\n  memo[0] = 1\n  cnt_below = 1 # sum memo[y] for y <= x\n  result = 0\n  for a in A:\n    if a > x:\n      current += 1\n      cnt_below += memo[current]\n    else:\n      cnt_below -= memo[current]\n      current -= 1\n    result += cnt_below\n    memo[current] += 1\n    cnt_below += 1\n  return result <= (total_medians-1)//2\n\nAA = sorted(A)\nleft = -1 # \u7b54\u306fAA[left]\u3088\u308a\u5927\u304d\u3044\nright = len(AA)-1 # \u7b54\u306fAA[right]\u4ee5\u4e0b\u3067\u3042\u308b\nwhile right - left > 1:\n  mid = (left+right)//2\n  if test(AA[mid]):\n    right = mid\n  else:\n    left = mid\n    \nanswer = AA[right]\nprint(answer)\n", "def bisect_right_callable(fn, x, lo, hi):\n    \"\"\"\n    lo \u304b\u3089 hi-1 \u306e\u3046\u3061\u3001fn \u306e\u7d50\u679c\u304c x \u4ee5\u4e0b\u3068\u306a\u308b\u3001\u6700\u3082\u53f3\u306e\u5024 + 1\n    bisect.bisect_right \u3068\u540c\u3058\n    https://docs.python.org/ja/3/library/bisect.html\n    :param callable fn:\n    :param x:\n    :param int lo: \u6700\u5c0f\u5024\n    :param int hi: \u6700\u5927\u5024 + 1\n    :return: lo <= ret <= hi\n    \"\"\"\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if x < fn(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\n\nN = int(input())\nseries = list(map(int, input().split()))\nseries_sorted = sorted(series)\n\n# L \u3068 r \u306e\u9078\u3073\u65b9\u306e\u7d44\u307f\u5408\u308f\u305b\u6570\u30021 \u304b\u3089 N \u307e\u3067\u306e\u548c\u306b\u7b49\u3057\u3044\nlr_size = (N + 1) * N / 2\n\n\ndef count_lr(x):\n    \"\"\"\n    x \u4ee5\u4e0a\u306e\u6570\u3092\u534a\u5206\u4ee5\u4e0a\u542b\u3080 == \u4e2d\u592e\u5024\u304c x \u4ee5\u4e0a\u3067\u3042\u308b\u3001L \u3068 r \u306e\u9078\u3073\u65b9\u306e\u6570\n    :param x:\n    :return:\n    \"\"\"\n    ret = 0\n    # series[i] \u304c x \u672a\u6e80\u306a\u3089 1\u3001x \u4ee5\u4e0a\u306a\u3089 -1 \u3092 i\u756a\u76ee\u306b\u6301\u3064\u914d\u5217\u306e\u3001i=0 \u304b\u3089 i \u307e\u3067\u306e\u7d2f\u7a4d\u548c\u3002\n    cumsum = 0\n    # counts[i]: cumsum \u304c i \u306b\u4f55\u56de\u306a\u3063\u305f\u304b\n    counts = {i: 0 for i in range(-N, N + 1)}\n    counts[cumsum] = 1\n    diff = 0\n    for i in range(N):\n        if series[i] >= x:\n            cumsum += 1\n            counts[cumsum] += 1\n            diff += counts[cumsum]\n        else:\n            cumsum -= 1\n            counts[cumsum] += 1\n            diff -= counts[cumsum + 1] - 1\n        ret += diff\n    return ret\n\n\n# count_lr(x) \u306e\u7d50\u679c\u304c\u534a\u5206\u4ee5\u4e0a\u3067\u3042\u308c\u3070\u3001\u4e2d\u592e\u5024\u306f x \u4ee5\u4e0a\u3002\n# count_lr(x) \u304c\u534a\u5206\u4ee5\u4e0a\u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044 x \u3092\u63a2\u3059\u3002\ndef solve(i):\n    if count_lr(series_sorted[i]) >= (lr_size + 1) // 2:\n        return 0\n    else:\n        return float('inf')\n\n\nans_i = bisect_right_callable(solve, 0, lo=0, hi=N)\nprint((series_sorted[max(0, min(N - 1, ans_i - 1))]))\n", "n = int(input())\na = list(map(int, input().split()))\nx = list(sorted(set(a)))\nn_sub = n * (n + 1) // 2\nLi = 0\nRi = len(x)\nwhile Ri > Li + 1:\n    i = (Li + Ri) // 2\n    xi = x[i]\n    UorD = [1 if ak >= xi else -1 for ak in a]\n    cnt_sum = [0] * (2 * n + 1)\n    cumsum = 0\n    cnt_sum[cumsum + n] = 1\n    judge = 0\n    s = 0\n    for uk in UorD:\n        cumsum += uk\n        if uk == 1:\n            s += cnt_sum[cumsum + n] + 1\n        else:\n            s -= cnt_sum[cumsum + n + 1] - 1\n        cnt_sum[cumsum + n] += 1\n        judge += s\n        if judge >= n_sub // 2:\n            Li = i\n            break\n    else:\n        Ri = i\nprint((x[Li]))\n", "def main():\n    N, *A = list(map(int, open(0).read().split()))\n\n    B = sorted(A)\n    l, r = 0, N\n    m, c = N // 2, N * (N + 1) // 2\n\n    def check(x):\n        b, r, y = N, 0, 0\n        D = [0] * (2 * N + 1)\n        for a in A:\n            D[b] += 1\n            if a < x:\n                r += D[b]\n                b += 1\n            else:\n                b -= 1\n                r -= D[b]\n            y += r\n        return y\n\n    while True:\n        if check(B[m]) <= c // 2:\n            if m == N - 1 or check(B[m + 1]) > c // 2:\n                break\n            else:\n                l, m = m, (m + r) // 2\n        else:\n            m, r = (m + l) // 2, m + 1\n\n    print((B[m]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\na_list = list(map(int, input().split()))\ndef search(c):\n    bar = N\n    r = 0\n    res_nega = 0\n    dp_arr = [0]*(2*N+1)\n    for i in range(N):\n        dp_arr[bar] += 1\n        if a_list[i] < c:\n            r += dp_arr[bar]\n            bar += 1\n        else:\n            r -= (dp_arr[bar-1])\n            bar -= 1\n        res_nega += r\n    return res_nega\n# binary search\na_sorted = sorted(a_list)\nleft = 0\nright = N\nmid = N // 2\nC = N*(N+1) // 2\nwhile True:\n    if search(a_sorted[mid]) <= C // 2:\n        if mid == N-1:\n            break\n        elif search(a_sorted[mid+1]) > C // 2:\n            break\n        else:\n            left = mid\n            mid = (mid + right) // 2\n    else:\n        right = mid + 1\n        mid = (mid + left) // 2\nprint((a_sorted[mid]))\n", "def main():\n    N, *A = map(int, open(0).read().split())\n \n    B = sorted(A)\n    l, r = 0, N\n    m, c = N // 2, N * (N + 1) // 2\n \n    def check(x):\n        b, r, y = N, 0, 0\n        D = [0] * (2 * N + 1)\n        for a in A:\n            D[b] += 1\n            if a < x:\n                r += D[b]\n                b += 1\n            else:\n                b -= 1\n                r -= D[b]\n            y += r\n        return y\n \n    while True:\n        if check(B[m]) <= c // 2:\n            if m == N - 1 or check(B[m + 1]) > c // 2:\n                break\n            else:\n                l, m = m, (m + r) // 2\n        else:\n            m, r = (m + l) // 2, m + 1\n \n    print(B[m])\n \n \ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\na = list(map(int, input().split()))\n\ndef check(x):\n    b = n\n    r = 0\n    y = 0\n    D = [0]*(2*n+1)\n    for i in range(n):\n        D[b] += 1\n        if a[i] < x:\n            r += D[b]\n            b += 1\n        else:\n            b -= 1\n            r -= D[b]\n        y += r\n    return y\n\nalpha = sorted(a)\nl, r = 0, n\nm, c = n//2, n*(n+1)//2\nwhile True:\n    if check(alpha[m]) <= c//2:\n        if m == n-1:\n            break\n        elif check(alpha[m+1]) > c//2:\n            break\n        else:\n            l, m = m, (m+r)//2\n    else:\n        m, r = (m+l)//2, m+1\n        \nprint(alpha[m])", "n = int(input())\na = list(map(int, input().split()))\nx = list(sorted(set(a)))\nn_sub = n * (n + 1) // 2\nLi = 0\nRi = len(x)\nwhile Ri > Li + 1:\n    i = (Li + Ri) // 2\n    xi = x[i]\n    UorD = [1 if ak >= xi else -1 for ak in a]\n    cnt_sum = [0] * (2 * n + 1)\n    cumsum = 0\n    cnt_sum[cumsum + n] = 1\n    judge = 0\n    s = 0\n    for uk in UorD:\n        cumsum += uk\n        if uk == 1:\n            s += cnt_sum[cumsum + n] + 1\n        else:\n            s -= cnt_sum[cumsum + n + 1] - 1\n        cnt_sum[cumsum + n] += 1\n        judge += s\n        if judge >= n_sub // 2:\n            Li = i\n            break\n    else:\n        Ri = i\nprint((x[Li]))\n"]