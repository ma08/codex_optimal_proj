["n = int(input())\ns = input()\nt = input()\n\ndef ff(ch):\n    return ord(ch) - ord('a')\n\ndef answer(a, b, sc):\n    print(cans + sc)\n    print(a+1, b+1)\n    return\n\ncans = 0\nmatrix = [[None] * 26 for i in range(26)]\nfor i in range(n):\n    matrix[ff(s[i])][ff(t[i])] = i\n    if s[i] != t[i]:\n        cans += 1\n\nfor i in range(26):\n    for j in range(i):\n        if matrix[i][j] is not None and matrix[j][i] is not None:\n            answer(matrix[i][j], matrix[j][i], -2)\n\nfor i in range(26):\n    for h in range(26):\n        if h == i:\n            continue\n        for v in range(26):\n            if v == i:\n                continue\n            if matrix[h][i] is not None and matrix[i][v] is not None:\n                answer(matrix[h][i], matrix[i][v], -1)\n\nanswer(-2, -2, 0)\n", "import sys\nn = int(input())\na = input()\nb = input()\nl = 0\nc = [[0 for j in range(26)] for i in range(26)]\nfor i in range(n):\n    if a[i] != b[i]:\n        l += 1\n        c[ord(a[i]) - ord('a')][ord(b[i]) - ord('a')] = i+1\n\nfor i in range(26):\n    for j in range(26):\n        if i == j or c[i][j] == 0 or c[j][i] == 0:\n            continue\n        print(l-2)\n        print(c[i][j], c[j][i])\n        return\nfor i in range(26):\n    for j in range(26):\n        if i == j or c[i][j] == 0 or max(c[j]) == 0:\n            continue\n        print(l-1)\n        print(c[i][j], end=' ')\n        for k in range(26):\n            if c[j][k] > 0:\n                print(c[j][k])\n        return\nprint(l)\nprint(-1, -1)\n", "import unittest\n\n\ndef solve(S, T):\n    pos_s = {}\n    pos_t = {}\n    wrongs = []\n    distance = 0\n\n    for i, (s, t) in enumerate(zip(S,T)):\n        if s != t:\n            pos_t[(s,t)] = i\n            pos_s[s] = i\n            wrongs.append((s,t,i))\n            distance += 1\n\n    for wrong, need, i in wrongs:\n        j = pos_t.get((need, wrong))\n        if j is not None:\n            return (distance-2, i + 1, j + 1)\n\n    for wrong, need, i in wrongs:\n        if need in pos_s:\n            return (distance-1, i + 1, pos_s[need] + 1)\n\n    return distance, -1, -1\n\n\n\nclass Test_solution(unittest.TestCase):\n    def test_case(self):\n        self.assertEqual(solve(\"pergament\", \"permanent\"), (1, 4, 6))\n        self.assertEqual(solve(\"wookie\", \"cookie\"), (1, -1, -1))\n        self.assertEqual(solve(\"petr\", \"egor\"), (2,1,2))\n        self.assertEqual(solve(\"double\", \"bundle\"), (2,1,4))\n        self.assertEqual(solve(\"\", \"\"), (0,-1,-1))\n\n\ndef __starting_point():\n    #unittest.main()\n    input()\n    S = input()\n    T = input()\n    distance, i, j = solve(S, T)\n    print(distance)\n    print(i,j)\n\n__starting_point()", "alth = \"abcdefghijklmnopqrstuvwxyz\"\nn = int(input())\nS = input()\nT = input()\nheming = 0\nfirst = [-1] * 26\nsecond = [-1] * 26\nfirst_second = [-1] * 676\nfor i in range(n):\n    if S[i] != T[i]:\n        heming += 1\n        temp = alth.find(S[i])\n        temp2 = alth.find(T[i])\n        first[temp] = i\n        second[temp2] = i\n        first_second[temp*26+temp2] = i\nerror_1 = 0\nerror_2 = 0\nfor i in range(676):\n    temp = i % 26\n    temp2 = i // 26\n    if first_second[i] != -1 and first_second[temp * 26 + temp2]!= -1:\n        error_1 = 1\n        print(heming - 2)\n        print(first_second[i]+1,first_second[temp * 26 + temp2]+1)\n        break\nif error_1 == 0:\n    for i in range(26):\n        if first[i] != -1 and second[i] != -1:\n            error_2 = 2\n            print(heming - 1)\n            print(first[i]+1,second[i]+1)\n            break\n    if error_2 == 0:\n        print(heming)\n        print(-1,-1)\n", "from pprint import pprint\nfrom operator import itemgetter\n\ndef main():\n    _ = int(input().strip())\n    w1 = input().strip()\n    w2 = input().strip()\n    \n    if len(w1) != len(w2):\n        return -1\n    \n    hdis, fpos, lpos = one_replace_hamming(w1, w2)\n    print(hdis)\n    print(min(fpos + 1, lpos + 1), max(fpos + 1, lpos + 1))\n\ndef ham_wt(w1, w2):\n    diff_pairs1 = []\n    rev_assoc = dict()\n    pos_indicator = dict()\n    for i in range(len(w1)):\n        if w2[i] != w1[i]:\n            diff_pairs1.append((w1[i], w2[i]))\n            rev_assoc[w2[i]] = w1[i]\n            pos_indicator[w1[i], w2[i]] = i\n    return (diff_pairs1, rev_assoc, pos_indicator)\n\ndef one_replace_hamming(w1, w2):\n    diff_pairs, rev_assoc, pos_indicator = ham_wt(w1, w2)\n\n    for fst, snd in diff_pairs:\n        if fst in rev_assoc and rev_assoc[fst] == snd:\n            return (len(diff_pairs) - 2, pos_indicator[fst, snd], pos_indicator[snd, fst])\n    \n    for fst, snd in diff_pairs:\n        if fst in rev_assoc:\n            return (len(diff_pairs) - 1, pos_indicator[fst, snd], pos_indicator[rev_assoc[fst], fst])\n    \n    \n    return (len(diff_pairs), -2, -2)\n        \n    \n\ndef __starting_point():\n    main()\n__starting_point()", "#!/usr/bin/env python\n# coding=utf-8\n\nimport sys\nn = int(input())\na, b = input(), input()\nl = 0\nc = [[0 for j in range(26)] for i in range(26)]\nfor i in range(n):\n    if a[i] != b[i]:\n        l += 1\n        c[ord(a[i]) - ord('a')][ord(b[i]) - ord('a')] = i + 1\nfor i in range(26):\n    for j in range(26):\n        if i == j or c[i][j] == 0 or c[j][i] == 0:\n            continue\n        print(l - 2)\n        print(c[i][j], c[j][i])\n        return\nfor i in range(26):\n    for j in range(26):\n        if i == j or c[i][j] == 0 or max(c[j]) == 0:\n            continue\n        print(l - 1)\n        print(c[i][j], end = ' ')\n        for k in range(26):\n            if c[j][k] > 0:\n                print(c[j][k])\n        return\nprint(l)\nprint(-1, -1)\n", "#!/c/Python34/python\n# coding: utf-8\n#Anser\n\n\ndef main():\n    n = int(input())\n    s, t = str(input()), str(input())\n    p = [[0] * 26 for _ in range(26)]\n    dist = 0\n\n    for i in range(n):\n        if s[i] != t[i]:\n            j = ord(s[i]) - ord('a')\n            k = ord(t[i]) - ord('a')\n            p[j][k] = i + 1\n            dist += 1\n\n    for i in range(26):\n        for j in range(26):\n            if i != j and p[i][j] > 0 and p[j][i] > 0:\n                print(dist-2)\n                print(p[i][j], p[j][i])\n                return\n\n    for i in range(26):\n        for j in range(26):\n            if i != j and p[i][j] > 0 and max(p[j]) > 0:\n                print(dist-1)\n\n                for k in range(26):\n                    if p[j][k] > 0:\n                        print(p[i][j], p[j][k])\n                        return\n\n    print(dist)\n    print(-1, -1)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, s, t = int(input()), input(), input()\n\nt_dict = dict()\ndiffs = list()\nres_i, res_j = -1, -1\nres_d = 0\n\nfor i in range(n):\n    if s[i] == t[i]:\n        continue\n    res_d += 1\n    diffs.append(i)\n    t_dict[t[i]] = i\n\nperfect_swapped = False\nswapped = False\nfor i in diffs:\n    if s[i] not in t_dict:\n        continue\n    swapped = True\n    res_i = i + 1\n    j = t_dict[s[i]]\n    res_j = j + 1\n    if s[j] == t[i]:\n        perfect_swapped = True\n        break\n\nprint(res_d - (2 if perfect_swapped else 1 if swapped else 0))\nprint(res_i, res_j)\n", "n, s, t = int(input()), input(), input()\n\nt_dict = dict()\ndiffs = list()\nres_i, res_j = -1, -1\nres_d = 0\n\nfor i in range(n):\n    if s[i] == t[i]:\n        continue\n    res_d += 1\n    diffs.append(i)\n    t_dict[t[i]] = i\n\nperfect_swapped = False\nswapped = False\nfor i in diffs:\n    if s[i] not in t_dict:\n        continue\n    swapped = True\n    res_i = i + 1\n    j = t_dict[s[i]]\n    res_j = j + 1\n    if s[j] == t[i]:\n        perfect_swapped = True\n        break\n\nprint(res_d - (2 if perfect_swapped else 1 if swapped else 0))\nprint(res_i, res_j)\n", "n,s,t = int(input()),input(),input()\n\nd = {}\nwrongs = []\nansD,ansI,ansJ = 0,-1,-1\nfor i in range(n) :\n    if s[i]!=t[i] :\n        ansD+=1\n        wrongs.append(i)\n        d[t[i]] = i\n\nperfectSwapped = False\nswapped = False\nfor i in wrongs :\n    if s[i] in d :\n        swapped = True\n        ansI = i+1\n        j = d[s[i]]\n        ansJ = j+1\n        if s[j]==t[i] :\n            perfectSwapped = True\n            break\n\nprint(ansD-(2 if perfectSwapped else 1 if swapped else 0))\nprint(ansI, ansJ)\n        \n", "import sys\nn = int(input())\ns = input()\nt = input()\n\ndef ff(ch):\n    return ord(ch) - ord('a')\n\ndef answer(a, b, sc):\n    print(res + sc)\n    print(a + 1, b + 1)\n    return\n    \nmatrix = [[None] * 26 for _ in range(26)]\nres = 0\n\nfor i in range(len(s)):\n    matrix[ff(s[i])][ff(t[i])] = i\n    if s[i] != t[i]:\n        res += 1\n\nfor i in range(26):\n    for j in range(i):\n        if matrix[i][j] is not None and matrix[j][i] is not None:\n            answer(matrix[i][j], matrix[j][i], -2)\n\nfor i in range(26):\n    for h in range(26):\n        if h == i:\n            continue\n        for v in range(26):\n            if v == i:\n                continue\n            if matrix[h][i] is not None and matrix[i][v] is not None:\n                answer(matrix[h][i], matrix[i][v], -1)\n                \nanswer(-2, -2, 0)", "n=int(input())\ns=input()\nt=input()\nq={}\nosh=[]\nrez1=0\nrez2=-1\nrez3=-1\nfor i in range(n):\n    if s[i]!=t[i]:\n        rez1+=1\n        osh.append(i)\n        q[t[i]]=i\np=False\nsq=False\nfor i in osh:\n    if s[i] in q:\n        p=True\n        rez2=i+1\n        f=q[s[i]]\n        rez3=f+1\n        if s[f]==t[i]:\n            sq=True\n            break\nprint(rez1-(2 if sq else 1 if p else 0))\nprint(rez2,rez3)", "n = int(input())\ns = input()\nt = input()\np = 0           #used as a pointer\ndist = 0        #used as hamming distance\nm = [[] for i in range(0,26)]\nsr = []\nwhile p < len(s):\n    #print('...1')\n    if s[p] != t[p]:\n        m[ord(s[p])-ord('a')].append((t[p], p))\n        dist += 1\n    p += 1\n\n#print(m)\np = 0\nwhile p < len(s):\n    #print('...2')\n    if s[p] != t[p]:\n        flag = False\n        for i in sr:\n            if i[0] == s[p] and i[1] == t[p]:\n                flag = True\n                break\n        if flag == True:\n            p += 1\n            continue\n        sr.append((s[p], t[p]))\n        for i in m[ord(t[p]) - ord('a')]:\n            if i[0] == s[p]:\n                dist -= 2\n                print(dist)\n                print(p+1, i[1]+1)\n                quit()\n    p += 1\n\np = 0\nwhile p < len(s):\n    #print('...3')\n    if s[p] != t[p]:\n        if len(m[ord(t[p]) - ord('a')]) > 0:\n            dist -= 1\n            print(dist)\n            print(p+1, m[ord(t[p]) - ord('a')][0][1]+1)\n            quit()\n    p += 1\nprint(dist)\nprint(-1, -1)", "import sys\nn = int(input())\na = input()\nb = input()\nl = 0\nc = [[0 for j in range(26)] for i in range(26)]\nfor i in range(n):\n    if a[i] != b[i]:\n        l += 1\n        c[ord(a[i]) - ord('a')][ord(b[i]) - ord('a')] = i+1\n\nfor i in range(26):\n    for j in range(26):\n        if i == j or c[i][j] == 0 or c[j][i] == 0:\n            continue\n        print(l-2)\n        print(c[i][j], c[j][i])\n        return\nfor i in range(26):\n    for j in range(26):\n        if i == j or c[i][j] == 0 or max(c[j]) == 0:\n            continue\n        print(l-1)\n        print(c[i][j], end=' ')\n        for k in range(26):\n            if c[j][k] > 0:\n                print(c[j][k])\n        return\nprint(l)\nprint(-1, -1)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Mar 21 00:34:22 2015\n\n@author: NEC-PCuser\n\"\"\"\n\ndef solve(n, S, T):\n    st = dict()\n    ts = dict()\n    s = dict()\n    t = dict()\n    dist = 0\n    for i, (si, ti) in enumerate(zip(S, T), 1):\n        if si != ti:\n            st[si, ti] = i\n            ts[ti, si] = i\n            s[si] = i\n            t[ti] = i\n            dist += 1\n    for key, i in st.items():\n        if key in ts:\n            j = ts[key]\n            return dist - 2, min(i, j), max(i, j)\n    for si, i in s.items():\n        if si in t:\n            j = t[si]\n            return dist - 1, min(i, j), max(i, j)\n    return dist, -1, -1\n\nn = int(input())\nS = input()\nT = input()\ndist, i, j = solve(n, S, T)\nprint(dist)\nprint(i, j)", "import string\n\nn, s, t = int(input()), input(), input()\nx, i, j = 0, -1, -1\nsc_dict = {c: set() for c in string.ascii_lowercase}\ntc_dict = {c: set() for c in string.ascii_lowercase}\nsti_dict, tsi_dict = dict(), dict()\n\nfor ci, sc, tc in zip(list(range(n)), s, t):\n    if sc == tc:\n        continue\n    sc_dict[sc].add(tc)\n    tc_dict[tc].add(sc)\n    sti_dict[sc + tc] = ci\n    tsi_dict[tc + sc] = ci\n    x += 1\n\nfor c in string.ascii_lowercase:\n    cs = sc_dict[c] & tc_dict[c]\n    if not cs:\n        continue\n    c2 = cs.pop()\n    x -= 2\n    i = sti_dict[c + c2] + 1\n    j = tsi_dict[c + c2] + 1\n    break\nelse:\n    for c in string.ascii_lowercase:\n        if not sc_dict[c] or not tc_dict[c]:\n            continue\n        x -= 1\n        i = sti_dict[c + sc_dict[c].pop()] + 1\n        j = tsi_dict[c + tc_dict[c].pop()] + 1\n        break\n\nprint(x)\nprint(i, j)\n", "import string\n\nn, s, t = int(input()), input(), input()\nx, i, j = 0, -1, -1\nsc_dict = {c: set() for c in string.ascii_lowercase}\ntc_dict = {c: set() for c in string.ascii_lowercase}\nsti_dict, tsi_dict = dict(), dict()\n\nfor ci, sc, tc in zip(list(range(n)), s, t):\n    if sc == tc:\n        continue\n    sc_dict[sc].add(tc)\n    tc_dict[tc].add(sc)\n    sti_dict[sc + tc] = ci\n    tsi_dict[tc + sc] = ci\n    x += 1\n\nfor c in string.ascii_lowercase:\n    cs = sc_dict[c] & tc_dict[c]\n    if not cs:\n        continue\n    c2 = cs.pop()\n    x -= 2\n    i = sti_dict[c + c2] + 1\n    j = tsi_dict[c + c2] + 1\n    break\nelse:\n    for c in string.ascii_lowercase:\n        if not sc_dict[c] or not tc_dict[c]:\n            continue\n        x -= 1\n        i = sti_dict[c + sc_dict[c].pop()] + 1\n        j = tsi_dict[c + tc_dict[c].pop()] + 1\n        break\n\nprint(x)\nprint(i, j)\n", "#compute hamming distance\n# mark indexes that differ\n#m_benefit=0,s_i,s_j\n#for each i in index\n#   for each j in i+1\n#       swap i & j and see what is the benefit\n#       if benefit > m_benefit:\n#           m_ben=ben\n#           record m_i and m_j\n#if m_ben = 0 then -1 -1 \n#else distance-benefit and print s_i+1&s_j+1\ndiff = []\nwrong_t = {}\n\ndef distance(n,s,t):\n    count = 0\n    for i in range(n):\n        if s[i] != t[i]:\n            diff.append(i)\n            wrong_t[t[i]] = i\n            count+=1\n    return count\n\ndef minDistance():\n    m_ben = 0\n    m_i = -2\n    m_j = -2\n    for i in diff:\n        v = wrong_t[s[i]] if (s[i] in wrong_t) else None\n        if v != None:\n            m_ben = 1\n            m_i = i\n            m_j = v\n            if s[v] == t[i]:\n                return (2,i,v)\n    return (m_ben,m_i,m_j)\n\nn = int(input())\ns = input()\nt = input()\nd = distance(n,s,t)\nm_ben,m_i,m_j = minDistance()\nprint(d - m_ben)\nprint(\"{0} {1}\".format(m_i + 1,m_j + 1))\n\n", "import time\n\nclass Profiler(object):\n    def __enter__(self):\n        self._startTime = time.time()\n\n    def __exit__(self, type, value, traceback):\n        print(\"Elapsed time: {:.3f} sec\".format(time.time() - self._startTime))\n\n\nn = int(input())\na = input()\nb = input()\n#a= 'x'*200000 +'ab'\n#b= 'b'*200000 +'xx'\nindexes = list()\nd = {}\nf1 = False\nf2 = False\ndf = 0\ni1 = 0\ni2 = 0\n#with Profiler() as p:\nfor i in range(n):\n    if a[i] != b[i]:\n        df += 1\n        indexes.append(i)\n        d[b[i]] = i\nfor i in indexes:\n    if a[i] in d:\n        f1 = True\n        j = d[a[i]]\n        i1 = i+1\n        i2 = j+1\n        if a[j] == b[i]:\n            f2 = True\n            break\nif f2:\n    print(str(df-2))\n    print(i1.__str__() + ' ' + i2.__str__())\nelif f1:\n    print(str(df-1))\n    print(i1.__str__() + ' ' + i2.__str__())\nelse:\n    print(str(df))\n    print('-1 -1')", "def gao():\n\tn = int(input())\n\ta = input()\n\tb = input()\n\tmp = {}\n\tcnt = 0\n\tfor i in range(n):\n\t\tif a[i] != b[i]:\n\t\t\tcnt += 1\n\t\t\tmp[(a[i], b[i])] = i + 1\n\tl = [chr(ord('a') + i) for i in range(26)]\n\tfor i in l:\n\t\tfor j in l:\n\t\t\tif (i, j) in mp and (j, i) in mp:\n\t\t\t\tprint(cnt - 2)\n\t\t\t\tprint(mp[(i, j)], mp[(j, i)])\n\t\t\t\treturn\n\tfor i in l:\n\t\tfor j in l:\n\t\t\tfor k in l:\n\t\t\t\tif (i, j) in mp and (j, k) in mp:\n\t\t\t\t\tprint(cnt - 1)\n\t\t\t\t\tprint(mp[(i, j)], mp[(j, k)])\n\t\t\t\t\treturn\n\tprint(cnt)\n\tprint(-1, -1)\n\n\ngao()\n", "n=int(input())\ns=input()\nt=input()\ndis=0\nd=[[False for i in range(30)] for i in range(30)]\nx=[[0 for i in range(30)] for i in range(30)]\nfor i in range(n):\n\tif s[i]!=t[i]:\n\t\tdis+=1\n\t\td[ord(s[i])-ord('a')][ord(t[i])-ord('a')]=True\n\t\tx[ord(s[i])-ord('a')][ord(t[i])-ord('a')]=i+1\ndef progress():\n\tfor i in range(26):\n\t\tfor j in range(26):\n\t\t\tif (d[i][j]) and (d[j][i]):\n\t\t\t\tprint(\"{}\\n{} {}\".format(dis-2,x[i][j],x[j][i]))\n\t\t\t\treturn 0\n\tfor i in range(26):\n\t\tfor j in range(26):\n\t\t\tif d[i][j]:\n\t\t\t\tfor t in range(26):\n\t\t\t\t\tif d[j][t]:\n\t\t\t\t\t\tprint(\"{}\\n{} {}\".format(dis-1,x[i][j],x[j][t]))\n\t\t\t\t\t\treturn 0\n\tprint(\"{}\\n{} {}\".format(dis,-1,-1))\nprogress()\n\n\n", "n = input()\ns1,s2 = input(),input()\nl1 = [[x,[s1[x],s2[x]]] for x in range(len(s1)) if s1[x] != s2[x]]\nd1,d2 = dict([(y[1][0] + y[1][1],y[0]) for y in l1]),dict([(y[1][1] + y[1][0],y[0]) for y in l1])\nins = set(d1.keys()) & set(d2.keys())\nif ins:\n    e = ins.pop()\n    print (len(l1) - 2)\n    print (d1[e] + 1,d2[e] + 1)\n    return\ns1,s2 = dict([(y[1][0],y[0]) for y in l1]),dict([(y[1][1],y[0]) for y in l1])\nins = set(s1.keys()) & set(s2.keys())\nif ins:\n    e = ins.pop()\n    print (len(l1) - 1)\n    print (s1[e] + 1,s2[e] + 1)\n    return\nprint (len(l1))\nprint (-1,-1)", "n = input()\ns1,s2 = input(),input()\nl2,l3 = [],[]\nl1 = [[l2.append((s1[x] + s2[x],x)),l3.append((s2[x] + s1[x],x))] for x in range(len(s1)) if s1[x] != s2[x]]\nd1,d2 = dict(l2),dict(l3)\nins = set(d1.keys()) & set(d2.keys())\nif ins:\n    e = ins.pop()\n    print (len(l1) - 2)\n    print (d1[e] + 1,d2[e] + 1)\n    return\ns1,s2 = {y[0][0]:y[1] for y in l2},{y[0][1]:y[1] for y in l2}\nins = set(s1.keys()) & set(s2.keys())\nif ins:\n    e = ins.pop()\n    print (len(l1) - 1)\n    print (s1[e] + 1,s2[e] + 1)\n    return\nprint (len(l1))\nprint (-1,-1)"]