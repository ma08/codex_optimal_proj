["import sys\n\nn, m = list(map(int,input().split()))\ng = [list(map(int,input().split())) for _ in range(n)]\nfor c1 in range(m):\n    for c2 in range(c1, m):\n        ok = True\n        for row in g:\n            row[c1], row[c2] = row[c2], row[c1]\n            cnt = 0\n            for i in range(m):\n                if row[i] != i + 1:\n                    cnt += 1\n                if cnt > 2:\n                    break\n            row[c1], row[c2] = row[c2], row[c1]\n            if cnt > 2:\n                ok = False\n                break\n        if ok:\n            print('YES')\n            return\nprint('NO')\n", "import sys\n\ndef swapC(c1, c2):\n    for r in range(n):\n        swap(r, c1, c2)\n\ndef swap(r, c1, c2):\n    nums[r][c1], nums[r][c2] = nums[r][c2], nums[r][c1]\n\ndef checkRow(r):\n    bad = []\n    for i in range(m):\n        if nums[r][i] != i:\n            bad.append(i)\n    if len(bad) == 0:\n        return True\n    if len(bad) != 2:\n        return False\n    x0, x1 = nums[r][bad[0]], nums[r][bad[1]]\n    return bad[0] == x1 and bad[1] == x0\n\ndef checkAll():\n    for r in range(n):\n        if not checkRow(r):\n            return False\n    return True\n\nn, m = map(int, input().split())\nnums = [list(map(lambda x: int(x) - 1, input().split())) for i in range(n)]\n\n\nflag = False\nfor c1 in range(m):\n    for c2 in range(c1, m):\n        swapC(c1, c2)\n        if checkAll():\n            print(\"YES\")\n            flag = True\n            break\n        swapC(c1, c2)\n    if flag:\n        break\nelse:\n    print(\"NO\")", "read = lambda: list(map(int, input().split()))\nn, m = read()\na = [list(read()) for i in range(n)]\nb = [a[i][:] for i in range(n)]\nflag = True\nfor i in range(n):\n            c = sorted(b[i])\n            d = b[i][:]\n            dif = sum(c[j] != d[j] for j in range(m))\n            if dif > 2: flag = False\nif flag:\n            print('YES')\n            return\nfor k1 in range(m):\n    for k2 in range(k1 + 1, m):\n        b = [a[i][:] for i in range(n)]\n        for i in range(n):\n                b[i][k1], b[i][k2] = b[i][k2], b[i][k1]\n        flag = True\n        for i in range(n):\n            c = sorted(b[i])\n            d = b[i][:]\n            dif = sum(c[j] != d[j] for j in range(m))\n            if dif > 2: flag = False\n        if flag:\n            print('YES')\n            return\nprint('NO')\n", "def check(table):\n    n = len(table)\n    m = len(table[0])\n    bits = [[table[i][j] == j+1 for j in range(m)] for i in range(n)]\n    for row in bits:\n        if row.count(False) > 2:\n            return False\n    return True\n\nn,m =list(map(int, input().split()))\ntable = [list(map(int, input().split())) for i in range(n)]\nfor i in range(m-1):\n    for j in range(i,m):\n        _table = [table[i][:] for i in range(n)]\n        for k in range(n):\n            _table[k][i], _table[k][j] = _table[k][j],_table[k][i]\n        if check(_table):\n            print('YES')\n            return\nif check(table):\n    print('YES')\n    return\n\nprint('NO')\n\n", "\nn, m = list(map(int, input().split()))\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\ndef check(x, y):\n    for i in range(n):\n        k = 0\n        for j in range(m):\n            if (j == x):\n                if (a[i][y] != j + 1):\n                    k += 1\n            elif (j == y):\n                if (a[i][x] != j + 1):\n                    k += 1\n            elif (a[i][j] != j + 1):\n                    k += 1\n        if k > 2:\n            return False\n    return True\nfor e in range(m):\n    for r in range(m):\n        if check(e, r):\n            print('YES')\n            return\nprint('NO')\n", "from collections import defaultdict\n\ndef getdiff(l):\n    diff = []\n    for i in range(m):\n        if l[i] != i + 1:\n            diff.append(l[i])\n    return diff\n\nn, m = list(map(int, input().split()))\nt = [list(map(int, input().split())) for i in range(n)]\n\ndiffs = [defaultdict(bool) for i in range(n)]\nfor j in range(m):\n    for j2 in range(j, m):\n        for i in range(n):\n            t[i][j], t[i][j2] = t[i][j2], t[i][j]\n            df = getdiff(t[i])\n            t[i][j], t[i][j2] = t[i][j2], t[i][j]\n            if len(df) == 2:\n                diffs[i][tuple(sorted(df))] = True\n\nfor j in range(m):\n    for j2 in range(j, m):\n        for i in range(n):\n            if j != j2 and not diffs[i][(j + 1, j2 + 1)]:\n                break\n            t[i][j], t[i][j2] = t[i][j2], t[i][j]\n            df = getdiff(t[i])\n            t[i][j], t[i][j2] = t[i][j2], t[i][j]\n            if len(df) > 2:\n                break\n        else:\n            print('YES')\n            return\nprint('NO')\n", "from copy import deepcopy\n\nn, m = list(map(int, input().split()))\narr = []\n\nfor i in range(n):\n    arr.append(list(map(int, input().split())))\n\ndef solve(arr):\n    # print(arr)\n    for row in arr:\n        count = 0\n        for i, num in enumerate(row):\n            if i + 1 != num:\n                count += 1\n                if count > 2:\n                    return False\n    return True\n\ndef permute(arr, i, j):\n    arr_ = deepcopy(arr)\n    for k in range(n):\n        arr_[k][i], arr_[k][j] = arr_[k][j], arr_[k][i]\n    # print(arr_)\n    return arr_\n\ndef main():\n    if solve(arr):\n        print(\"YES\")\n        return\n\n    for row in arr:\n        wrong_cols = []\n        for i, num in enumerate(row):\n            if i + 1 != num:\n                wrong_cols.append(i)\n        if wrong_cols:\n            # print(row, wrong_cols)\n            if len(wrong_cols) > 4:\n                print(\"NO\")\n                return\n            for col in wrong_cols:\n                if solve(permute(arr, col, row[col] - 1)):\n                    print(\"YES\")\n                    return\n            print(\"NO\")\n            return\n\n    print(\"NO\")\n    return\n\nmain()", "n, m = map(int, input().split())\niden = list(range(1, m + 1))\nb = [[int(x) for x in input().split()] for _ in range(n)]\ndef run(board):\n    okay = True\n    for row in board:\n        s = 0\n        for x, y in zip(row, iden):\n            s += x != y\n        okay = okay and s in {0, 2}\n    return okay\nokay = run(b)\nfor i in range(m):\n    for j in range(m):\n        if i == j: continue\n        B = [row[:] for row in b]\n        for k in range(n):\n            B[k][i], B[k][j] = B[k][j], B[k][i]\n        okay = okay or run(B)\nprint('YES' if okay else 'NO')", "n,m = list(map(int,input().split()))\ninp = [input() for _ in range(n) ]\nmat = [[] for _ in range(m) ]\nfor row in inp:\n\tr = row.split()\n\tfor idx,val in enumerate(r):\n\t\tmat[idx].append(int(val))\ndef valid(row):\n\tcount = 0\n\tfor idx,col in enumerate(mat):\n\t\tif (idx + 1) != col[row]:\n\t\t\tcount += 1\n\t\t\tif count > 2:\n\t\t\t\treturn False\n\treturn count <= 2\n\ndef try_swap(col1,col2):\n\ttemp = mat[col1]\n\tmat[col1] = mat[col2]\n\tmat[col2] = temp\n\tfor row in range(n):\n\t\tif not valid(row):\n\t\t\ttemp = mat[col2]\n\t\t\tmat[col2] = mat[col1]\n\t\t\tmat[col1] = temp\n\t\t\treturn False\n\ttemp = mat[col2]\n\tmat[col2] = mat[col1]\n\tmat[col1] = temp\n\treturn True\n\nfor col in range(m):\n\tfor col2 in range(col + 1,m):\n\t\tif try_swap(col,col2):\n\t\t\tprint('YES')\n\t\t\timport sys\n\t\t\treturn\nif try_swap(0,0):\n\tprint('YES')\nelse:\n\tprint('NO')\n", "\n\ndef judge():\n    n,m = list(map(int, input().split()))\n    num = [list(map(int, input().split())) for x in range(n)]\n    for i in range(m):\n        for j in range(m):\n            tmp = num[:]\n            for k in range(n):\n                tmp[k][i],tmp[k][j] = tmp[k][j],tmp[k][i]\n            cur = True\n            for k in range(n):\n                cnt = len([l for l in range(m) if tmp[k][l]!=l+1])\n                if cnt>2:\n                    cur = False\n            for k in range(n):\n                tmp[k][i],tmp[k][j] = tmp[k][j],tmp[k][i]\n            if cur:\n                return True\n    return False\n    \nif judge():\n    print('YES')\nelse:\n    print('NO')\n", "n, m = list(map(int, input().split()))\n\ndef f(a):\n    nonlocal c, k\n    c = []\n    k = 0\n    for i in range(m):\n        if a[i] - 1 != i:\n            k += 1\n            c.append(i)\n    \n            \n\nc = []\nbb = []\ncc = []\nk = 0\nflag1 = True\nflag = True\nfor i in range(n):\n    b = list(map(int, input().split()))\n    f(b)\n    if k > 2:\n        flag1 = False\n    if k > 2:\n        if k > 4:\n            print('NO')\n            flag = False\n            break\n        elif cc == []:\n            for j in range(len(c)):\n                cc.append(c[j])\n        elif k == 3:\n            cc = []\n            for j in range(len(c)):\n                cc.append(c[j])\n    bb.append(b)\nif flag1:\n    print('YES')\nelse:\n    if flag:\n        for i in range(n):\n            bb[i][cc[0]], bb[i][cc[1]] = bb[i][cc[1]], bb[i][cc[0]]\n            f(bb[i])\n            if k > 2:\n                flag = False\n            bb[i][cc[0]], bb[i][cc[1]] = bb[i][cc[1]], bb[i][cc[0]]\n        if flag:\n            print('YES')\n        else:\n            flag = True\n            for i in range(n):\n                bb[i][cc[0]], bb[i][cc[2]] = bb[i][cc[2]], bb[i][cc[0]]\n                f(bb[i])\n                if k > 2:\n                    flag = False\n                bb[i][cc[0]], bb[i][cc[2]] = bb[i][cc[2]], bb[i][cc[0]]\n            if flag:\n                print('YES')\n            else:\n                flag = True\n                for i in range(n):\n                    bb[i][cc[1]], bb[i][cc[2]] = bb[i][cc[2]], bb[i][cc[1]]\n                    f(bb[i])\n                    if k > 2:\n                        flag = False\n                    bb[i][cc[1]], bb[i][cc[2]] = bb[i][cc[2]], bb[i][cc[1]]\n                if flag:\n                    print('YES')\n                else:\n                    if len(cc) == 3:\n                        print('NO')\n                    else:\n                        flag = True\n                        for i in range(n):\n                            bb[i][cc[0]], bb[i][cc[3]] = bb[i][cc[3]], bb[i][cc[0]]\n                            f(bb[i])\n                            if k > 2:\n                                flag = False\n                            bb[i][cc[0]], bb[i][cc[3]] = bb[i][cc[3]], bb[i][cc[0]]\n                        if flag:\n                            print('YES')\n                        else:\n                            flag = True\n                            for i in range(n):\n                                bb[i][cc[1]], bb[i][cc[3]] = bb[i][cc[3]], bb[i][cc[1]]\n                                f(bb[i])\n                                if k > 2:\n                                    flag = False\n                                bb[i][cc[1]], bb[i][cc[3]] = bb[i][cc[3]], bb[i][cc[1]]\n                            if flag:\n                                print('YES')\n                            else:\n                                flag = True\n                                for i in range(n):\n                                    bb[i][cc[2]], bb[i][cc[3]] = bb[i][cc[3]], bb[i][cc[2]]\n                                    f(bb[i])\n                                    if k > 2:\n                                        flag = False\n                                    bb[i][cc[2]], bb[i][cc[3]] = bb[i][cc[3]], bb[i][cc[2]]\n                                if flag:\n                                    print('YES')\n                                else:\n                                    print('NO')\n\n                              \n", "import sys, re, itertools\nrai=lambda x:list(map(int, x.split()))\ndef pm(a):\n    for l in a:\n        print(l)\n    print()\n_use_stdin = True\nif _use_stdin:\n    inp = sys.stdin\nelse:\n    inp = open(\"input.txt\", \"r\")\nls = inp.read().splitlines()\nn, m = rai(ls[0])\na = [rai(l) for l in ls[1:]]\nb = list(range(1,m+1))\nc = []\ndef f(x):\n    t = 0\n    for i, x in enumerate(a[x]):\n        if x != b[i]:\n            t += 1\n    return t\nflag = False\nfor i in range(m):\n    for j in range(i, m):\n        for k in range(n):\n            a[k][i], a[k][j] = a[k][j], a[k][i]\n        flag2 = True\n        for k in range(n):\n            if f(k) > 2:\n                flag2 = False\n                break\n#         for k in range(n):\n#             print(a[k], f(k))\n#         print()\n        if not flag:\n            flag = flag2\n        for k in range(n):\n            a[k][i], a[k][j] = a[k][j], a[k][i]\nprint(\"YES\" if flag else \"NO\")", "def difference(ln, k, l):\n    count = 0\n\n    line2 = ln[:]\n    line2[k], line2[l] = ln[l], ln[k]\n    for i in range(len(ln)):\n        if line2[i] != i + 1:\n            count += 1\n\n    return count\n\ndef difference2(ln):\n    count = 0\n    for i in range(len(ln)):\n        if ln[i] != i + 1:\n            count += 1\n\n    return count\n\ndef __starting_point():\n\n    n, m = input().split(' ')\n    n = int(n)\n    m = int(m)\n\n    matrix = []\n    for i in range(n):\n        line = [int(i) for i in input().split(' ')]\n        matrix.append(line)\n        \n    res = False\n\n    ans = True\n    for line in matrix:\n        if difference2(line) > 2:\n            ans = False\n    if ans:\n        res = True\n\n    for i in range(m):\n        for j in range(m):\n            if i == j:\n                continue\n\n            answer = True\n            for line in matrix:\n                if difference(line, i, j) > 2:\n                    answer = False\n\n            if answer == True:\n                res = True\n\n    if res:\n        print('YES')\n    else:\n        print('NO')\n__starting_point()", "from sys import stdin\n\nn, m = (int(x) for x in stdin.readline().split())\n\ntable = []\nfor _ in range(n):\n    table.append([int(x) for x in stdin.readline().split()])\n\n\ndef tr(l):\n    return list(map(list, list(zip(*l))))\n\n\ndef need_one_or_zero_swap(l):\n    swap = 2\n    for i, item in enumerate(l):\n        if item != i + 1:\n            if swap:\n                if l[item-1] == i + 1:\n                    swap -= 1\n                else:\n                    return False\n            else:\n                return False\n    return True\n\n\ndef check_after_global_swap(t):\n    for row in t:\n        if not need_one_or_zero_swap(row):\n            return False\n    return True\n\n\ndef try_global_swap_first():\n    if check_after_global_swap(table):\n        return True\n    transp = tr(table)\n    for i in range(len(transp)):\n        for j in range(i + 1, len(transp)):\n            transp[i], transp[j] = transp[j], transp[i]\n            t2 = tr(transp)\n            if check_after_global_swap(t2):\n                return True\n            transp[i], transp[j] = transp[j], transp[i]\n    return False\n\nif try_global_swap_first():\n    print('YES')\nelse:\n    print('NO')\n# print(need_one_or_zero_swap([1, 4, 3, 2]))\n", "def solve():\n\tn, m = map(int, input().split())\n\ttab = [list(map(int, input().split())) for _ in range(n)]\n\n\tdef ordered(l):\n\t\tfor i in range(len(l) - 1):\n\t\t\tif l[i] > l[i + 1]: return False\n\t\treturn True\n\n\tdef canswap(l):\n\t\tif ordered(l): return True\n\t\tfor i in range(len(l)):\n\t\t\tfor j in range(i + 1, len(l)):\n\t\t\t\tlc = list(l)\n\t\t\t\tlc[i], lc[j] = lc[j], lc[i]\n\t\t\t\tif ordered(lc):\n\t\t\t\t\treturn True\n\t\treturn False\n\n\tworks = True\n\tfor row in tab:\n\t\tif not canswap(row):\n\t\t\tworks = False\n\tif works: return True\n\n\tfor coli in range(m):\n\t\tfor colj in range(coli, m):\n\t\t\tworks = True\n\n\t\t\tfor rowref in tab:\n\t\t\t\trow = list(rowref)\n\t\t\t\trow[coli], row[colj] = row[colj], row[coli]\n\t\t\t\tif ordered(row):\n\t\t\t\t\tcontinue\n\t\t\t\tgood = False\n\t\t\t\tfor i in range(m):\n\t\t\t\t\tif good: break\n\t\t\t\t\tfor j in range(m):\n\t\t\t\t\t\trow = list(rowref)\n\t\t\t\t\t\trow[i], row[j] = row[j], row[i]\n\t\t\t\t\t\trow[coli], row[colj] = row[colj], row[coli]\n\t\t\t\t\t\tif ordered(row):\n\t\t\t\t\t\t\tgood = True\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\trow = list(rowref)\n\t\t\t\t\t\trow[coli], row[colj] = row[colj], row[coli]\n\t\t\t\t\t\trow[i], row[j] = row[j], row[i]\n\t\t\t\t\t\tif ordered(row):\n\t\t\t\t\t\t\tgood = True\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\tif not good:\n\t\t\t\t\tworks = False\n\t\t\t\t\tbreak\n\t\t\tif works:\n\t\t\t\treturn True\n\treturn False\n\nres = solve()\nprint(\"YES\" if res else \"NO\")", "__author__ = 'Think'\ndef parse(row):\n\tcount=0\n\tproblems=[]\n\tfor i in range(1, m+1):\n\t\tif i!=row[i-1]:\n\t\t\tcount+=1\n\t\t\tproblems.append((i, row[i-1]))\n\tif count==0:\n\t\treturn [0]\n\telif count==2:\n\t\treturn [2, sorted((problems[0][0], problems[0][1]))]\n\telif count==3:\n\t\treturn [3, sorted((problems[0][0], problems[1][0])), sorted((problems[2][0], problems[1][0])), sorted((problems[0][0], problems[2][0]))]\n\telif count==4 and row[problems[0][1]-1]==problems[0][0]:\n\t\tif problems[0][1]!=problems[1][0]:\n\t\t\treturn [3, sorted((problems[0][0], problems[0][1])), sorted((problems[1][0], problems[1][1]))]\n\t\telse:\n\t\t\treturn [3, sorted((problems[0][0], problems[0][1])), sorted((problems[2][0], problems[2][1]))]\n\telse:\n\t\treturn [4]\n\ndef merge(l1, l2):\n\tif l1[0]==4 or l2==[4]:\n\t\treturn \"Fail\"\n\telif l1[0]==0:\n\t\treturn l2\n\telif l2[0]==0:\n\t\treturn l1\n\telif l1[0]==3 and l2[0]==3:\n\t\tnew=[3]\n\t\tfor i in l1[1:]:\n\t\t\tif i in l2[1:]:\n\t\t\t\tnew.append(i)\n\t\tif len(new)>1:\n\t\t\treturn new\n\t\telse:\n\t\t\treturn \"Fail\"\n\telif (l1[0]==2) != (l2[0]==2):\n\t\tif l1[0]==2:\n\t\t\tnewl2=l1\n\t\t\tnewl3=l2\n\t\telse:\n\t\t\tnewl2=l2\n\t\t\tnewl3=l1\n\t\tif len(newl2)==1:\n\t\t\treturn \"Fail\"\n\t\tif newl2[1] in newl3[1:]:\n\t\t\treturn newl2\n\t\telse:\n\t\t\treturn \"Fail\"\n\telif l1[0]==2 and l2[0]==2:\n\t\tif l1==l2:\n\t\t\treturn l1\n\t\telse:\n\t\t\treturn [2]\n\n\tprint(\"Missed a case!\", l1, l2)\n\ncurrent=[0]\nbroken=False\nn, m=[int(i) for i in input().split()]\nfor j in range(n):\n\tnewrow=[int(i) for i in input().split()]\n\tnew=parse(newrow)\n\tcurrent=merge(new, current)\n\tif current==\"Fail\":\n\t\tprint(\"NO\")\n\t\tbroken=True\n\t\tbreak\nif not broken:\n\tprint(\"YES\")\n", "n, m = [int(x) for x in input().split()]\nL = [[int(x) for x in input().split()] for i in range(n)]\ndef solve(L):\n    D = {i:set() for i in range(n)}\n    for i in range(n):\n        for j in range(m):\n            if L[i][j] != j+1:\n                D[i].add((min(j+1, L[i][j]), max(j+1, L[i][j])))\n                if len(D[i]) > 3 or len(D[i]) == 3 and L[i][L[i][j]-1] == j+1:\n                    return False\n    if all((len(D[i]) < 2) for i in range(n)):\n        return True\n    for x in range(m):\n        for y in range(x,m):\n            for i in range(n):\n                if not ((x+1,y+1) in D[i] or len(D[i]) == 0):\n                    break\n            else:\n                return True\n    return False\n\nprint('YES') if solve(L) else print('NO')\n", "def gene(l):\n    d = {}\n    for i in range(len(l)):\n        if l[i] != i + 1:\n            d[i + 1] = l[i]\n    return d\n\ndef paired(d):\n    return tuple(sorted(zip(list(d.keys()), list(d.values()))))\n\ndef exchange(d):\n    if len(d) in (0, 2):\n        yield paired(d)\n    for i in d:\n        if d[i] in d:\n            if d[d[i]] == i:\n                dp = {j: d[j] for j in d if j != i and j != d[i]}\n                if len(dp) in (0, 2):\n                    yield paired(dp)\n            else:\n                dp = {j: d[j] for j in d}\n                dp[i], dp[d[i]] = dp[d[i]], dp[i]\n                dp = {j: dp[j] for j in dp if j != dp[j]}\n                if len(dp) in (0, 2):\n                    yield paired(dp)\n        else:\n            assert(False)\n\nn, m = list(map(int, input().split()))\nds = {((i, j), (j, i)) for i in range(1, m + 1) for j in range(i, m + 1)}\nds.add(tuple())\nl = [ds for _ in range(n)]\nfor i in range(n):\n    il = list(map(int, input().split()))\n    if il == sorted(il):\n        continue\n    d = gene(il)\n    # print(d)\n    if len(d) > 4:\n        print('NO')\n        return\n    l[i] = set(exchange(d))\n    if not l[i]:\n        print('NO')\n        return\n#print(l)\n\ns = l[0]\nfor i in range(1, n):\n    s = s.intersection(l[i])\n# print(s)\nif s:\n    print('YES')\nelse:\n    print('NO')\n", "read = lambda: list(map(int, input().split()))\nn, m = read()\na = [list(read()) for i in range(n)]\nb = [a[i][:] for i in range(n)]\nflag = True\nfor i in range(n):\n    c = sorted(b[i])\n    d = b[i][:]\n    dif = sum(c[j] != d[j] for j in range(m))\n    if dif > 2: flag = False\nif flag:\n    print('YES')\n    return\nfor k1 in range(m):\n    for k2 in range(k1 + 1, m):\n        b = [a[i][:] for i in range(n)]\n        for i in range(n):\n            b[i][k1], b[i][k2] = b[i][k2], b[i][k1]\n        flag = True\n        for i in range(n):\n            c = sorted(b[i])\n            d = b[i][:]\n            dif = sum(c[j] != d[j] for j in range(m))\n            if dif > 2: flag = False\n        if flag:\n            print('YES')\n            return\nprint('NO')\n", "n, m = map(int, input().split(' '))\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split(' '))))\n\np = []\npossible = True\ncol_swap = False\n#print('swaps:')\nfor r in a:\n    x = []\n    j = 0\n    swaps = []\n    while j < len(r) and len(swaps) < 3:\n        if r[j] != j + 1:\n            tmp = r[j]\n            r[j] = r[tmp - 1]\n            r[tmp - 1] = tmp\n            swaps.append((j, tmp - 1))\n        else:\n            j += 1\n    #print(swaps)\n    if len(swaps) > 2:\n        possible = False\n        break\n    if len(swaps) == 2:\n        col_swap = True\n    if len(swaps) > 0:\n        x = swaps\n        if len(swaps) == 2 and swaps[0][0] == swaps[1][0]:\n            x.append((\n                min(swaps[0][1], swaps[1][1]),\n                max(swaps[0][1], swaps[1][1])\n            ))\n        p.append(x)\n\n#print('possible:', possible, 'p:', p, 'col_swap:', col_swap)\nif possible and col_swap and p:\n    c = set(p[0])\n    for x in p:\n        c = c.intersection(x)\n    possible = bool(c)\n    #print('c:', c)\n\nif possible:\n    print('YES')\nelse:\n    print('NO')", "I=lambda:map(int,input().split())\nR=range\nn,m=I()\nt=[[]for _ in R(m)]\ne=list(R(1,m+1))\nr='NO'\nfor _ in R(n):\n\tfor i,v in zip(R(m),I()):t[i]+=[v]\nfor i in R(m):\n\tfor j in R(i,m):\n\t\tt[i],t[j]=t[j],t[i]\n\t\tif all(3>sum(t[i][j]!=e[i]for i in R(m))for j in R(n)):r='YES'\n\t\tt[i],t[j]=t[j],t[i]\nprint(r)", "n, m = map(int,input().split())\ng = [list(map(int,input().split())) for _ in range(n)]\nfor c1 in range(m):\n    for c2 in range(c1, m):\n        ok = True\n        for row in g:\n            row[c1], row[c2] = row[c2], row[c1]\n            cnt = 0\n            for i in range(m):\n                if row[i] != i + 1:\n                    cnt += 1\n                if cnt > 2:\n                    break\n            row[c1], row[c2] = row[c2], row[c1]\n            if cnt > 2:\n                ok = False\n                break\n        if ok:\n            print('YES')\n            return\nprint('NO')", "def get_perms(perm):\n\tperms = {tuple(perm)}\n\tfor i in range(len(perm)):\n\t\tfor j in range(i+1, len(perm)):\n\t\t\tperm_copy = list(perm)\n\t\t\tperm_copy[i], perm_copy[j] = perm_copy[j], perm_copy[i]\n\t\t\tperms.add(tuple(perm_copy))\n\treturn perms\n\nn, m = list(map(int, input().split(' ')))\ngood_perms = get_perms([i for i in range(1, m+1)])\nfor i in range(n):\n\tperm = list(map(int, input().split(' ')))\n\tgood_perms &= get_perms(perm)\nif good_perms:\n\tprint('YES')\nelse:\n\tprint('NO')\n"]