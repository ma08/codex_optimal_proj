["n, m = list(map(int, input().split()))\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = int(input())\nk = []\nfor i in range(d):\n    k.append(int(input()))\n\nvis = [False for i in range(m+1)]\nmatch = [-1 for i in range(m+1)]\n\n\ndef dfs(u: int) -> bool:\n    for v in e[u]:\n        if not vis[v]:\n            vis[v] = True\n            if match[v] == -1 or dfs(match[v]):\n                match[v] = u\n                return True\n    return False\n\n\ne = [[] for i in range(5005)]\nfor i in range(n):\n    if i + 1 not in k:\n        e[p[i]].append(c[i])\n\nmex = 0\nans = []\nfor i in range(d - 1, -1, -1):\n    while True:\n        vis = [False for j in range(m+1)]\n        if not dfs(mex):\n            break\n        mex += 1\n    ans.append(mex)\n    e[p[k[i]-1]].append(c[k[i]-1])\n\nfor i in reversed(ans):\n    print(i)\n", "n, m = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = int(input())\nk = []\nfor i in range(d):\n    k.append(int(input()))\n\nvis = [False for i in range(m+1)]\nmatch = [-1 for i in range(m+1)]\n\n\ndef dfs(u: int) -> bool:\n    for v in e[u]:\n        if not vis[v]:\n            vis[v] = True\n            if match[v] == -1 or dfs(match[v]):\n                match[v] = u\n                return True\n    return False\n\n\ne = [[] for i in range(5005)]\nfor i in range(n):\n    if i + 1 not in k:\n        e[p[i]].append(c[i])\n\nmex = 0\nans = []\nfor i in range(d - 1, -1, -1):\n    while True:\n        vis = [False for j in range(m+1)]\n        if not dfs(mex):\n            break\n        mex += 1\n    ans.append(mex)\n    e[p[k[i]-1]].append(c[k[i]-1])\n\nfor i in reversed(ans):\n    print(i)", "import sys\ninput = sys.stdin.readline \n\nn, m = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = int(input())\ndisable = [False] * n\nbase = 5001\nds = [int(input())-1 for _ in range(d)]\nfor ele in ds:\n    disable[ele] = True\n\n# Create Graph\n\nchilds = [[] for i in range(base+m+1)]\n\nfor idx, (i, j) in enumerate(zip(p, c)):\n    if not disable[idx]:\n        childs[i].append(base+j)\n\n\n# dfs\n# alternative path for finding maximum cardinality\n\nvis = [False]*(base+m+1)\nmatching = [-1]*(base+m+1)\n\ndef dfs(num):\n    for child in childs[num]:\n        if not vis[child]:\n            vis[child] = True\n            if matching[child] == -1 or dfs(matching[child]):\n                matching[child] = num\n                return True\n    return False\n\nans = []\nmex = 0\nfor idx in range(d-1, -1, -1):\n    while True:\n        vis = [False]*(base+m+1)\n        if not dfs(mex):\n            break\n        mex += 1\n    # Add edge\n    ans.append(mex)\n    childs[p[ds[idx]]].append(base+c[ds[idx]])\n\nprint(\"\\n\".join([str(a) for a in reversed(ans)]))"]