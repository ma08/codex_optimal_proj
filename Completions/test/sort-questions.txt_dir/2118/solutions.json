["def create_list(n, num_of_calls):\n    if n == 1:\n        return [1], 0\n    if n == 2:\n        return [2, 1], 2\n    if num_of_calls == 2:\n        return list(range(2, n // 2 + 2)) + [1] +\\\n               list(range(n // 2 + 2, n + 1)), 2\n\n    list1, num_of_calls1 = create_list(n // 2, num_of_calls - 2)\n    if num_of_calls1 == num_of_calls - 2:\n        return list1 + list(range(n // 2 + 1, n + 1)), num_of_calls\n\n    list2, num_of_calls2 = create_list((n + 1) // 2,\n                                       num_of_calls - num_of_calls1 - 2)\n    return list1 + [x + n // 2 for x in list2], \\\n        num_of_calls1 + num_of_calls2 + 2\n\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    if k % 2 != 1:\n        print(-1)\n        return\n\n    if k == 1:\n        print(' '.join([str(x) for x in range(1, n + 1)]))\n        return\n\n    num_list, num_of_calls = create_list(n, k - 1)\n    if num_of_calls != k - 1:\n        print(-1)\n        return\n    print(' '.join([str(x) for x in num_list]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\n\n\"\"\"\ncreated by shhuan at 2017/10/14 15:30\n\n\"\"\"\n\nn, k = map(int, input().split())\n\nif k & 1 == 0 or k > 2*n-1:\n    print(-1)\nelse:\n    a = [0] * n\n    gs = (k-1)//2\n\n    def unsort(l, r, v):\n        if l == r-1:\n            a[l] = v\n        else:\n            nonlocal gs\n            if gs > 0:\n                gs -= 1\n                mid = (l+r)//2\n                unsort(l, mid, v+r-mid)\n                unsort(mid, r, v)\n            else:\n                for i in range(r-l):\n                    a[l+i] = v+i\n\n    unsort(0, n, 1)\n\n    print(' '.join([str(x) for x in a]))", "'''\nBased on solution from Firepaw which is awesome\n'''\n\nk1 = 0\n\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    if k & 1 == 0 or k > 2*n-1:\n        print(\"-1\")\n    else:\n        lst = [0]*n\n\n        # k1 count how many recursions left, drain one for the initial  call\n        nonlocal k1\n        k1 = k - 1\n\n        # solve the task for [l, r)\n        # Filling array with values val, val+1, ...\n        def fill_arr(l, r, val):\n            nonlocal k1\n            # list size 1, nothing to do just set the value\n            if r <= l+1:\n                lst[l] = val\n            elif k1 == 0:\n                # just fill in a sorted array - no more calls here\n                for i in range(l, r):\n                    lst[i] = val + i - l\n            else:\n                # drain 2 recursion calls (for left and right path)\n                k1 -= 2\n                # call subproblems\n                m = (l+r) // 2\n                # set initial vals for left path as [val + r-m, ... , val + r)\n                fill_arr(l, m, val+r-m)\n\n                # set initial vals for right path as [val, val+1, ... , val + r-m)\n                fill_arr(m, r, val)\n\n                # after filling subproblems we are sure list is not sorted\n                # this justifies the draining k1\n\n        fill_arr(0, n, 1)\n        #assert(k1 == 0)\n        print(\" \".join(map(str, lst)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "'''\nBased on solution from Firepaw which is awesome\n'''\n\nk1 = 0\n\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    if k & 1 == 0 or k > 2*n-1:\n        print(\"-1\")\n    else:\n        lst = [0]*n\n\n        # k1 count how many recursions left, drain one for the initial  call\n        nonlocal k1\n        k1 = k - 1\n\n        # solve the task for [l, r)\n        # Filling array with values val, val+1, ...\n        def fill_arr(l, r, val):\n            nonlocal k1\n            # list size 1, nothing to do just set the value\n            if r <= l+1:\n                lst[l] = val\n            elif k1 == 0:\n                # just fill in a sorted array - no more calls here\n                for i in range(l, r):\n                    lst[i] = val + i - l\n            else:\n                # drain 2 recursion calls (for left and right path)\n                k1 -= 2\n                # call subproblems\n                m = (l+r) // 2\n                # set initial vals for left path as [val + r-m, ... , val + r)\n                fill_arr(l, m, val+r-m)\n\n                # set initial vals for right path as [val, val+1, ... , val + r-m)\n                fill_arr(m, r, val)\n\n                # after filling subproblems we are sure list is not sorted\n                # this justifies the draining k1\n\n        fill_arr(0, n, 1)\n        print(' '.join([str(x) for x in lst]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = [int(i) for i in input().split()]\nif k % 2 == 0 or k >= 2 * n:\n    print(-1)\n    return\nlast = n\na = [0] * n\ndef ans(c, l, r):\n    nonlocal last\n    if c == 1:\n        i = r - 1\n        while i >= l:\n            a[i] = last\n            last -= 1\n            i -= 1\n        return\n    m = (l + r) // 2\n    ans(c // 2 - int((c // 2) % 2 == 0), l, m)\n    ans(c // 2 + int((c // 2) % 2 == 0), m, r)\nans(k, 0, n)\nprint(*a)\n", "n, k = [int(i) for i in input().split()]\nif k % 2 == 0 or k >= 2 * n:\n    print(-1)\n    return\nlast = n\na = [0] * n\ndef ans(c, l, r):\n    nonlocal last\n    if c == 1:\n        i = r - 1\n        while i >= l:\n            a[i] = last\n            last -= 1\n            i -= 1\n        return\n    m = (l + r) // 2\n    ans(c // 2 - int((c // 2) % 2 == 0), l, m)\n    ans(c // 2 + int((c // 2) % 2 == 0), m, r)\nans(k, 0, n)\nprint(*a)\n", "n,m = list(map(int, input().split()))\n\nres = []\n\ndef solve(begin, end, rem):\n\t#print('Solve:', begin, end, rem)\n\tif rem<2:\n\t\tres.extend(list(range(begin,end)))\n\t\treturn rem\n\tif end-begin==1:\n\t\tres.append(begin)\n\t\treturn rem\n\trem -= 2\n\tmid = (begin+end+1)//2\n\trem = solve(mid, end, rem)\n\trem = solve(begin, mid, rem)\n\treturn rem\n\nrem = solve(1, n+1, m-1)\nif rem == 0:\n\tprint(' '.join(map(str, res)))\nelse:\n\tprint(-1)\n\t#print(rem)\n\t#print(res)\n", "n,k=map(int,input().split())\nif not k&1:print(-1);return()\nk-=1\na=[int(i+1) for i in range(n)]\ndef f(l,r):\n    nonlocal k\n    if k<2or r-l<2:return\n    k-=2\n    m=(l+r)//2\n    a[m],a[m-1]=a[m-1],a[m]\n    f(l,m)\n    f(m,r)\nf(0,n)\nif k:print(-1);return()\nfor i in a:\n    print(int(i),end=' ')\n\n", "n,k=map(int,input().split())\na=[i+1 for i in range(n)]\nif not k&1:print(-1);return()\nk-=1\ndef f(l,r):\n    nonlocal k\n    if(k<2 or r-l<2): return\n    k-=2\n    m=(l+r)//2\n    a[m-1],a[m]=a[m],a[m-1]\n    f(l,m)\n    f(m,r)\nf(0,n)\nif not k==0:print(-1);return()\nfor i in a:\n    print(int(i),end=\" \")\n\n", "\ndef arr(n,k,l):\n    nonlocal flag\n    #print(n,k,l)    \n\n    if k == 0:\n        return(list(range(l,l+n)))\n\n    if n == 1:\n        flag = True\n        return([0])\n    \n\n    if (k%4 == 2): k1 = k2 = k//2 - 1 \n    else:\n        k1 = (k-4)//2\n        k2 = k1+2\n\n    n1 = n//2\n    n2 = n-n1\n     \n    a1 = arr(n1,k1,l+n2)\n    a2 = arr(n2,k2,l)\n\n    a1.extend(a2)\n    return( a1 )\n\nn,k = [int(i) for i in input().split()]\n        \nflag = False\n\nans = arr(n,k-1,1)\n\nif (k%2 == 0): flag = True\n\nif flag: print(-1)\nelse:\n    for i in ans: print(i,end = \" \")\n", "import os\nimport sys\nimport copy\nnum = 0\na = None\n# sys.stdin = open(os.path.join(os.path.dirname(__file__),'35.in'))\nk = None\ndef solve():\n    nonlocal k,a\n    n, k = map(lambda x:int(x), input().split())\n    savek = copy.deepcopy(k)\n    # print(a)\n    a = [_+1 for _ in range(n)]\n\n    def mgsort(l, r):\n        nonlocal num,a,k\n        mid = (l+r) >> 1\n        if r - l == 1 or k == 1:\n            return\n        k -= 2\n        a[l:mid] , a[mid:r] = a[mid:r] , a[l:mid]\n        mgsort(l, mid)\n        mgsort(mid, r)\n    if k % 2 != 0:  \n        mgsort(0, n)\n        \n    if k == 1:\n        for i in a:\n            print(i,sep=' ',end=' ')\n    else:\n        print(-1)\nsolve()", "n, k = map(int,input().split())\nif k % 2 == 0:\n    print(-1);return()\nk -= 1\na = [int(i+1) for i in range(n)] \ndef f(l,r):\n    nonlocal k\n    if k < 2 or r-l < 2:\n        return\n    k-=2\n    m=(l+r)//2\n    a[m], a[m-1] = a[m-1], a[m]\n    f(l,m)\n    f(m,r)\nf(0,n)\nif k:print(-1);return()\nfor i in a:\n    print(int(i),end=' ')", "n, k = map(int,input().split())\nif k % 2 == 0:\n    print(-1);return()\nk -= 1\na = [i+1 for i in range(n)]\ndef sl(l,r):\n    nonlocal k\n    if r-l < 2 or k == 0:\n        return\n    k -= 2\n    m = (l+r)//2\n    a[m], a[m-1] = a[m-1], a[m]\n    sl(l,m)\n    sl(m, r)\nsl(0, n)\nif k != 0:\n    print(-1);return()\nprint(' '.join([str(i) for i in a]))", "def unsort(d, left, right, k):\n    if k[0] <= 0 or left >= right - 1:\n        return\n    k[0] -= 2\n    mid = (left + right) // 2\n    tmp = d[mid-1]\n    d[mid-1] = d[mid]\n    d[mid] = tmp\n    unsort(d, left, mid, k)\n    unsort(d, mid, right, k)\n\n\ndef main():\n    k = [0]  # K needs to be a mutable integer\n    n, k[0] = (int(i) for i in input().split())\n    if k[0] % 2 == 0:\n        print('-1')\n        return\n    d = [i for i in range(n+1)]\n    k[0] -= 1\n    unsort(d, 1, n+1, k)\n    if k[0] == 0:\n        print(*d[1:])\n    else:\n        print('-1')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "def unsort(d, left, right, k):\n    if k[0] <= 0 or left >= right - 1:\n        return\n    k[0] -= 2\n    mid = (left + right) // 2\n    tmp = d[mid-1]\n    d[mid-1] = d[mid]\n    d[mid] = tmp\n    unsort(d, left, mid, k)\n    unsort(d, mid, right, k)\n\n\ndef main():\n    k = [0]  # K needs to be a mutable integer\n    n, k[0] = (int(i) for i in input().split())\n    if k[0] % 2 == 0:\n        print('-1')\n        return\n    d = [i for i in range(1, n+1)]\n    k[0] -= 1\n    unsort(d, 0, n, k)\n    if k[0] == 0:\n        print(*d)\n    else:\n        print('-1')\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n, k = list(map(int, input().split()))\n\nlst = [i for i in range(1, n + 1)]\n\n\ndef rearrange(l, r):\n    nonlocal k\n    if k < 1 or l + 1 == r:\n        return\n    k -= 2\n    mid = (l + r) // 2\n    lst[mid - 1], lst[mid] = lst[mid], lst[mid - 1]\n    rearrange(l, mid)\n    rearrange(mid, r)\n\n\nif k % 2 == 0 or n * 2 < k:\n    print(-1)\nelse:\n    k -= 1\n    rearrange(0, n)\n    print(' '.join(str(i) for i in lst))\n", "n,k=map(int,input().split())\na=[i+1 for i in range(n)]\nif not k&1:print(-1);return()\nk-=1\ndef f(l,r):\n    nonlocal k\n    if(k<2 or r-l<2): return \n    k-=2\n    m=(l+r)//2\n    a[m-1],a[m]=a[m],a[m-1]\n    f(l,m)\n    f(m,r)\nf(0,n)    \nif not k==0:print(-1);return()\nfor i in a:\n    print(int(i),end=\" \")", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue, bisect\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\nn, k = list(map(int, input().split()))\nk -= 1\na = [-1 for i in range(n)]\nc = 1\n\ndef merge(l, r, k):\n    nonlocal a, c\n    if l >= r or k%2 != 0:\n        return False\n    if k == 0:\n        for i in range(l, r):\n            a[i] = c\n            c += 1\n        return True\n    k -= 2\n    m = (l+r)//2\n    if (k//2)%2 == 0:\n        if merge(m, r, k//2):\n            return merge(l, m, k//2)\n        else:\n            return False\n    else:\n        if merge(m, r, k//2+1):\n            return merge(l, m, k//2-1)\n        else:\n            return False\nif not merge(0, n, k):\n    print(-1)\n    return\nprint(*a)\n", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue, bisect\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\nsys.setrecursionlimit(1000000)\n\nn, k = map(int, input().split())\na = [-1 for i in range(n)]\nc = 1\n\ndef merge(l, r, k):\n    nonlocal c, a\n    if l >= r:\n        return False\n    k -= 1\n    if k == 0:\n        for i in range(l, r):\n            a[i] = c\n            c += 1\n        return True\n    if k%2 == 1:\n        return False\n    m = l+(r-l)//2\n    if (k//2)%2 == 1:\n        if merge(m, r, k//2):\n            return merge(l, m, k//2)\n    else:\n        if merge(m, r, k//2+1):\n            return merge(l, m, k//2-1)\n    return False\n    \nif not merge(0, n, k):\n    print(-1)\n    return\nprint(*a)", "\"\"\"\n\u041e\u0447\u0435\u0432\u0438\u0434\u043d\u043e, \u0447\u0442\u043e \u0435\u0441\u043b\u0438 k \u0447\u0451\u0442\u043d\u043e, \u0442\u043e \u0440\u0435\u0448\u0435\u043d\u0438\u044f \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442, \u0442\u0430\u043a \u043a\u0430\u043a \u043a\u043e\u043b-\u0432\u043e \u0432\u044b\u0437\u043e\u0432\u043e\u0432 \n\u0432\u0441\u0435\u0433\u0434\u0430 \u043d\u0435\u0447\u0451\u0442\u043d\u043e (\u043e\u0434\u0438\u043d \u0432\u044b\u0437\u043e\u0432 \u0434\u0435\u043b\u0430\u0435\u0442\u0441\u044f \u0432 \u0441\u0430\u043c\u043e\u043c \u043d\u0430\u0447\u0430\u043b\u0435, \u0438 \u043a\u0430\u0436\u0434\u044b\u0439 \u0432\u044b\u0437\u043e\u0432 \u0434\u0435\u043b\u0430\u0435\u0442 0 \n\u0438\u043b\u0438 2 \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u044b\u0445 \u0432\u044b\u0437\u043e\u0432\u0430).\n\n\u0417\u0430\u0442\u0435\u043c, \u0435\u0441\u043b\u0438 k \u0447\u0451\u0442\u043d\u043e, \u043d\u0430\u0447\u043d\u0451\u043c \u0441 \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0439 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u0438 \u043f\u043e\u043f\u0440\u043e\u0431\u0443\u0435\u043c \n\u00ab\u043f\u0435\u0440\u0435\u043c\u0435\u0448\u0430\u0442\u044c\u00bb \u0435\u0451. \u0412\u0432\u0435\u0434\u0451\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044e unsort(l,\u2009r), \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0431\u0443\u0434\u0435\u0442 \u00ab\u043f\u0435\u0440\u0435\u043c\u0435\u0448\u0438\u0432\u0430\u0442\u044c\u00bb \n\u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043e\u043a. \u041f\u0440\u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u0448\u0438\u0432\u0430\u043d\u0438\u0438 \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043a\u0430 \u043c\u044b \u043b\u0438\u0431\u043e \u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0435\u0433\u043e \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c \n(\u0435\u0441\u043b\u0438 \u0431\u044b\u043b\u043e \u0443\u0436\u0435 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u0432\u044b\u0437\u043e\u0432\u043e\u0432), \u0438\u043b\u0438 \u043c\u0435\u043d\u044f\u0435\u043c \u0435\u0433\u043e \u0438 \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u043c unsort(l,\u2009mid) \u0438 \nunsort(mid,\u2009r), \u0435\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e \u0431\u043e\u043b\u044c\u0448\u0435 \u0432\u044b\u0437\u043e\u0432\u043e\u0432. \u041a\u043e\u0433\u0434\u0430 \u043c\u044b \u043c\u0435\u043d\u044f\u0435\u043c \u043f\u0440\u043e\u043c\u0435\u0436\u0443\u0442\u043e\u043a, \u043b\u0443\u0447\u0448\u0435 \u0435\u0433\u043e\n\u043f\u043e\u043b\u043e\u0432\u0438\u043d\u044b \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u043c\u0438; \u043f\u0440\u043e\u0441\u0442\u043e\u0439 \u0441\u043f\u043e\u0441\u043e\u0431 \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u044d\u0442\u043e \u2014 \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c \n\u043c\u0435\u0441\u0442\u0430\u043c\u0438 \u0434\u0432\u0430 \u0441\u043e\u0441\u0435\u0434\u043d\u0438\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430.\n\n\u041c\u043e\u0436\u043d\u043e \u043b\u0435\u0433\u043a\u043e \u0443\u0432\u0438\u0434\u0435\u0442\u044c, \u0447\u0442\u043e \u043a\u043e\u043b-\u0432\u043e \u0432\u044b\u0437\u043e\u0432\u043e\u0432 unsort \u0440\u0430\u0432\u043d\u043e \u043a\u043e\u043b-\u0432\u0443 \u0432\u044b\u0437\u043e\u0432\u043e\u0432 mergesort, \n\u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u043c\u0443 \u0434\u043b\u044f \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0439 \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0442\u0430\u043a\u043e\u0435 \u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u043c\u043e\u0436\u043d\u043e\n\u043f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c, \u0447\u0442\u043e\u0431\u044b \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0440\u043e\u0432\u043d\u043e k \u0432\u044b\u0437\u043e\u0432\u043e\u0432.\n\"\"\"\n\ndef unsort(arr, left, right, k):\n    if k[0] <= 0 or left >= right - 1:\n        return\n    \n    k[0] -= 2\n    mid = (left + right) // 2\n\n    arr[mid], arr[mid - 1] = arr[mid - 1], arr[mid]\n\n    unsort(arr, left, mid, k)\n    unsort(arr, mid, right, k)\n\n\nn, k = list(map(int, input().split()))\n \nif k % 2 == 0:\n    print(-1)\nelse:\n    k = [k - 1]\n    arr = [i for i in range(1, n + 1)]\n \n    unsort(arr, 0, n, k)\n\n    if not k[0]:\n        print(*arr)\n    else:\n        print(-1)\n", "from sys import setrecursionlimit as c\nc(10000)\n \ndef s(a, le, ri):\n    nonlocal k\n    if k <= 0 or le >= ri-1:\n        return\n    k -= 2\n    mid = (le+ri)//2\n    a[mid], a[mid-1] = a[mid-1], a[mid]\n    s(a, le, mid)\n    s(a, mid, ri)\n \nn, k = list(map(int, input().split()))\n \nif not(k%2):\n    print(\"-1\")\nelse:\n    k -= 1\n    l = list(range(1, n+1))\n    s(l, 0, n)\n    if not(k):\n        print(*l)\n    else:\n        print(\"-1\")\n", "import sys\ndef cal(l,r):\n    nonlocal k\n    if r-l < 2 or k == 0:\n        return\n    k -= 2\n    m = (l+r)//2\n    a[m], a[m-1] = a[m-1], a[m]\n    cal(l,m)\n    cal(m, r)\nn, k = list(map(int,sys.stdin.readline().split()))\nif k % 2 == 0:\n    sys.stdout.write(\"-1\")\nelse:\n    k -= 1\n    a = [i+1 for i in range(n)]\n    cal(0, n)\n    if k != 0:\n        sys.stdout.write(\"-1\")\n    else:\n        sys.stdout.write(' '.join([str(i) for i in a]))\n\n\n", "import random, math\nfrom copy import deepcopy as dc\n\ncalls = 1\n\n# Function to call the actual solution\ndef solution(n, k):\n\tif k % 2 == 0 or k > (2 * n) - 1:\n\t\treturn -1 \n\tli = [i for i in range(1, n+1)]\n\tdef mergeCount(li, s, e, k):\n\t\tnonlocal calls\n\t\tif calls >= k or s >= e-1:\n\t\t\treturn\n\t\tmid = (s + e)//2\n\t\tcalls += 2\n\t\tif mid-1 >= s:\n\t\t\tli[mid], li[mid-1] = li[mid-1], li[mid]\n\t\t\tmergeCount(li, s, mid, k)\n\t\t\tmergeCount(li, mid, e, k)\n\tmergeCount(li, 0, n, k)\n\treturn li\n\n\n# Function to take input\ndef input_test():\n\tn, k = list(map(int, input().strip().split(\" \")))\n\tout = solution(n, k)\n\tif out != -1:\n\t\tprint(' '.join(list(map(str, out))))\n\telse:\n\t\tprint(out)\n\ninput_test()\n# test()s\n", "import random, math\nfrom copy import deepcopy as dc\n\ncalls = 1\n\n# Function to call the actual solution\ndef solution(n, k):\n\tif k % 2 == 0 or k > (2 * n) - 1:\n\t\treturn -1 \n\tli = [i for i in range(1, n+1)]\n\tdef mergeCount(li, s, e, k):\n\t\tnonlocal calls\n\t\tif calls >= k or s >= e-1:\n\t\t\treturn\n\t\tmid = (s + e)//2\n\t\tcalls += 2\n\t\tif mid-1 >= s:\n\t\t\tli[mid], li[mid-1] = li[mid-1], li[mid]\n\t\t\tmergeCount(li, s, mid, k)\n\t\t\tmergeCount(li, mid, e, k)\n\tmergeCount(li, 0, n, k)\n\treturn li\n\n\n# Function to take input\ndef input_test():\n\tn, k = list(map(int, input().strip().split(\" \")))\n\tout = solution(n, k)\n\tif out != -1:\n\t\tprint(' '.join(list(map(str, out))))\n\telse:\n\t\tprint(out)\n\ninput_test()\n# test()s\n"]