["import sys\n\n# sys.stind.readline lee datos el doble de\n# r\u00e1pido que la funcion por defecto input\ninput = sys.stdin.readline\nlength = len\n\n\ndef get_input():\n    n, m, h = [int(x) for x in input().split(' ')]\n\n    digraph = [[] for _ in range(n + 1)]\n    transpose = [[] for _ in range(n + 1)]\n    mantainence = [0] + [int(x) for x in input().split(' ')]\n\n    for _ in range(m):\n        c1, c2 = [int(x) for x in input().split(' ')]\n\n        if (mantainence[c1] + 1) % h == mantainence[c2]:\n            digraph[c1].append(c2)\n            transpose[c2].append(c1)\n        if (mantainence[c2] + 1) % h == mantainence[c1]:\n            digraph[c2].append(c1)\n            transpose[c1].append(c2)\n\n    return digraph, transpose\n\n\ndef dfs_cc_1_visit(graph, node, color, finalization_stack):\n    stack = [node]\n\n    while stack:\n        current_node = stack[-1]\n\n        if color[current_node] != 'white':\n            stack.pop()\n            if color[current_node] == 'grey':\n                finalization_stack.append(current_node)\n                color[current_node] = 'black'\n            continue\n\n        color[current_node] = 'grey'\n        for adj in graph[current_node]:\n            if color[adj] == 'white':\n                stack.append(adj)\n\n\ndef dfs_cc_1(graph):\n    n = length(graph)\n    finalization_stack = []\n    color = ['white'] * n\n    for i in range(1, n):\n        if color[i] == 'white':\n            dfs_cc_1_visit(graph, i, color, finalization_stack)    \n    return finalization_stack\n\n\ndef dfs_cc_2_visit(graph, node, color, scc, component):\n    stack = [node]\n\n    while stack:\n        current_node = stack[-1]\n\n        if color[current_node] != 'white':\n            stack.pop()\n            color[current_node] = 'black'\n            scc[current_node] = component\n            continue\n\n        color[current_node] = 'grey'\n        for adj in graph[current_node]:\n            if color[adj] == 'white':\n                stack.append(adj)\n\n\ndef dfs_cc_2(graph, stack_time):\n    n = length(graph)\n    color = ['white'] * n\n    scc = [0] * n\n    component = 0\n    while stack_time:\n        current_node = stack_time.pop()\n        if color[current_node] == 'white':\n            dfs_cc_2_visit(graph, current_node, color, scc, component)\n            component += 1\n\n    return scc, component\n\n\ndef strongly_connected_components(digraph, transpose):\n    stack_time = dfs_cc_1(digraph)\n    scc, max_component = dfs_cc_2(transpose, stack_time)\n\n    # create the components\n    out_deg = [0] * max_component\n    scc_nodes = [[] for _ in range(max_component)]\n    for node in range(1, length(digraph)):\n        scc_nodes[scc[node]].append(node)\n        for adj in digraph[node]:\n            if scc[node] != scc[adj]:\n                out_deg[scc[node]] += 1\n    \n    # searching minimum strongly connectected component with out degree 0\n    minimum_component = None\n    for i, value in enumerate(out_deg):\n        if value == 0 and (minimum_component is None or length(scc_nodes[i]) < length(scc_nodes[minimum_component])):\n            minimum_component = i\n    \n    # return the size of the component and the nodes\n    return length(scc_nodes[minimum_component]), scc_nodes[minimum_component]\n\n\ndef __starting_point():\n    digraph, transpose = get_input()\n    count, nodes = strongly_connected_components(digraph, transpose)\n    \n    print(count)\n    print(' '.join([str(x) for x in nodes]))\n\n__starting_point()", "import sys\n\n# sys.stind.readline lee datos el doble de\n# r\u00e1pido que la funcion por defecto input\ninput = sys.stdin.readline\n\n\n\ndef get_input():\n    n, m, h = [int(x) for x in input().split(' ')]\n\n    digraph = [[] for _ in range(n + 1)]\n    transpose = [[] for _ in range(n + 1)]\n    mantainence = [0] + [int(x) for x in input().split(' ')]\n\n    for _ in range(m):\n        c1, c2 = [int(x) for x in input().split(' ')]\n\n        if (mantainence[c1] + 1) % h == mantainence[c2]:\n            digraph[c1].append(c2)\n            transpose[c2].append(c1)\n        if (mantainence[c2] + 1) % h == mantainence[c1]:\n            digraph[c2].append(c1)\n            transpose[c1].append(c2)\n\n    return digraph, transpose\n\n\ndef dfs_cc_1_visit(graph, node, color, finalization_stack):\n    stack = [node]\n\n    while stack:\n        current_node = stack[-1]\n\n        if color[current_node] != 'white':\n            stack.pop()\n            if color[current_node] == 'grey':\n                finalization_stack.append(current_node)\n                color[current_node] = 'black'\n            continue\n\n        color[current_node] = 'grey'\n        for adj in graph[current_node]:\n            if color[adj] == 'white':\n                stack.append(adj)\n\n\ndef dfs_cc_1(graph):\n    n = len(graph)\n    finalization_stack = []\n    color = ['white'] * n\n    for i in range(1, n):\n        if color[i] == 'white':\n            dfs_cc_1_visit(graph, i, color, finalization_stack)    \n    return finalization_stack\n\n\ndef dfs_cc_2_visit(graph, node, color, scc, component):\n    stack = [node]\n\n    while stack:\n        current_node = stack[-1]\n\n        if color[current_node] != 'white':\n            stack.pop()\n            color[current_node] = 'black'\n            scc[current_node] = component\n            continue\n\n        color[current_node] = 'grey'\n        for adj in graph[current_node]:\n            if color[adj] == 'white':\n                stack.append(adj)\n\n\ndef dfs_cc_2(graph, stack_time):\n    n = len(graph)\n    color = ['white'] * n\n    scc = [0] * n\n    component = 0\n    while stack_time:\n        current_node = stack_time.pop()\n        if color[current_node] == 'white':\n            dfs_cc_2_visit(graph, current_node, color, scc, component)\n            component += 1\n\n    return scc, component\n\n\ndef strongly_connected_components(digraph, transpose):\n    stack_time = dfs_cc_1(digraph)\n    scc, max_component = dfs_cc_2(transpose, stack_time)\n\n    # create the components\n    out_deg = [0] * max_component\n    scc_nodes = [[] for _ in range(max_component)]\n    for node in range(1, len(digraph)):\n        scc_nodes[scc[node]].append(node)\n        for adj in digraph[node]:\n            if scc[node] != scc[adj]:\n                out_deg[scc[node]] += 1\n    \n    # searching minimum strongly connectected component with out degree 0\n    minimum_component = None\n    for i, value in enumerate(out_deg):\n        if value == 0 and (minimum_component is None or len(scc_nodes[i]) < len(scc_nodes[minimum_component])):\n            minimum_component = i\n    \n    # return the size of the component and the nodes\n    return len(scc_nodes[minimum_component]), scc_nodes[minimum_component]\n\n\ndef __starting_point():\n    digraph, transpose = get_input()\n    count, nodes = strongly_connected_components(digraph, transpose)\n    \n    print(count)\n    print(' '.join([str(x) for x in nodes]))\n\n__starting_point()"]