["from math import *\n\nn, q = list(map(int, input().split()))\nafter = min(15, n)\nbefore = n - after\n\n\ndef calc(left, right):\n    return right * (right + 1) // 2 - left * (left - 1) // 2\n\n\ndef perm(i):\n    unused = [i + 1 for i in range(after)]\n    arr = []\n    for j in reversed(list(range(after))):\n        cur = i // factorial(j)\n        arr.append(unused[cur])\n        del unused[cur]\n        i -= cur * factorial(j)\n    return arr\n\n\np = perm(0)\nx = 0\n\nfor _ in range(q):\n    line = list(map(int, input().split()))\n\n    if len(line) == 3:\n        # type 1\n        l = line[1]\n        r = line[2]\n        res = 0\n        if l <= before:\n            if r <= before:\n                res += r * (r + 1) // 2\n            else:\n                res += before * (before + 1) // 2\n            res -= l * (l - 1) // 2\n            l = before + 1\n        if r > before:\n            res += sum(p[l-1-before:r-before]) + (r-l+1) * before\n\n        print(res)\n    else:\n        # type 2\n        x += line[1]\n        p = perm(x)\n", "import sys\ninput = sys.stdin.readline\n\nn,q=list(map(int,input().split()))\nX=list(range(1,n+1))\n\nS=[0]\nfor x in X:\n    S.append(S[-1]+x)\n\nFACT=[1,1]\nfor i in range(2,16):\n    FACT.append(FACT[-1]*i)\n\nA=X[-15:]\nLEN=len(A)\ndef calc(x):\n    AA=[a for a in A]\n    ANS=[]\n\n    for i in range(LEN,0,-1):\n        q=x//FACT[i-1]\n        x-=q*FACT[i-1]\n\n        ANS.append(AA.pop(q))\n\n        #print(q,x,AA,ANS)\n    \n    return ANS\n\nNOW=0\nfor queries in range(q):\n    Q=list(map(int,input().split()))\n\n    if Q[0]==2:\n        NOW+=Q[1]\n        continue\n    \n    l,r=Q[1],Q[2]\n\n    if r<=n-LEN:\n        print(S[r]-S[l-1])\n        continue\n\n    elif l<=n-LEN:\n        ANS=S[-LEN-1]-S[l-1]\n        l=0\n        r-=n-LEN+1\n    else:\n        ANS=0\n        l-=n-LEN+1\n        r-=n-LEN+1\n\n    NOWA=calc(NOW)\n\n    print(ANS+sum(NOWA[l:r+1]))\n", "n, Q = list(map(int, input().split()))\ncnt = 1\nF = [1]\nfor i in range(1, 17):\n    F.append(F[-1] * i)\nst = max(0, n - 15)\na = [0] * (n + 1)\nvs = [0] * (n + 1)\nfor i in range(1, n + 1):\n    a[i] = a[i - 1] + i\nfor _ in range(Q):\n    q = list(map(int, input().split()))\n    if q[0] == 1:\n        l, r = q[1], q[2]\n        print(a[r] - a[l - 1])\n        continue\n    x = q[1]\n    cnt += x\n    hav = cnt\n    for i in range(st, n + 1):\n        vs[i] = 0\n    for i in range(st, n):\n        tmp = 0\n        for j in range(st, n + 1):\n            if not vs[j]:\n                tmp += F[n - i]\n                if tmp >= hav:\n                    hav -= tmp - F[n - i]\n                    a[i] = a[i - 1] + j\n                    vs[j] = 1\n                    break\n    for i in range(st, n + 1):\n        if not vs[i]:\n            a[n] = a[n - 1] + i\n    \n\n", "import sys\ninput=sys.stdin.readline\n\nfact=[1]\nfor i in range(1,15+1):\n    fact.append(fact[-1]*i)\n\ndef generate_perm(n,m):\n    ret=[]\n    if n<=15:\n        cand=[i+1 for i in range(n)]\n    else:\n        cand=[i+1 for i in range(n-15,n)]\n    for i in range(1,min(15+1,n+1)):\n        pos=m//fact[min(15,n)-i]\n        m%=fact[min(15,n)-i]\n        ret.append(cand[pos])\n        del cand[pos]\n    return ret\n\nn,q=map(int,input().split())\nids=0\nif n<=15:\n    perm=[i+1 for i in range(n)]\nelse:\n    perm=[i+1 for i in range(n-15,n)]\nfor _ in range(q):\n    query=list(map(int,input().split()))\n    if query[0]==1:\n        l,r=query[1],query[2]\n        if n<=15:\n            print(sum(perm[l-1:r]))\n        else:\n            if l<=n-15:\n                if r<=n-15:\n                    print((r*(r+1))//2-(l*(l-1))//2)\n                else:\n                    print((n-15)*(n-14))//2-(l*(l-1))//2+sum(perm[0:r-(n-15)])\n            else:\n                print(sum(perm[l-1-(n-15):r-(n-15)]))\n    elif query[0]==2:\n        ids+=query[1]\n        perm=generate_perm(n,ids)", "# No need to use segment Tree because apart from the last 14 numbers, nothing will change since 14! > 2*pow(10, 10)\n\ndef modify(rest):\n\tfor i in range(len(rest)):\n\t\tprefix[-len(rest)+i] = prefix[-len(rest)+(i-1)] + rest[i]\n\t# print(\"prefix\", prefix)\n\n\ndef next_perm_direct(permc):\t# Gets the next permc lexographically bigger permutation\n\trest = [x for x in range(max(1, n-14), n+1)]\n\n\ttemp = 1\n\tfor i in range(1, len(rest)):\n\t\ttemp = temp*i\n\n\tfor i in range(len(rest)-1):\n\t\tif permc >= temp:\n\t\t\tchange = permc//temp\n\t\t\trest[i], rest[i+change] = rest[i+change], rest[i]\n\t\t\trest = rest[:i+1] + list(sorted(rest[i+1:]))\n\t\t\tpermc = permc%temp\n\t\ttemp = temp//(len(rest)-1-i)\n\t# print(\"rest\", rest)\n\tmodify(rest)\n\n\nn, q = list(map(int, input().split()))\nprefix = [0 for i in range(n+1)]\nfor i in range(1, n+1):\n\tprefix[i] = prefix[i-1]+i\n# print(prefix)\n\npermc = 0\nfor _ in range(q):\n\tquer = list(map(int, input().split()))\n\tif len(quer) == 2:\n\t\tpermc += quer[1]\n\t\tnext_perm_direct(permc)\n\telse:\n\t\tl, r = quer[1], quer[2]\n\t\tprint(prefix[r]-prefix[l-1])\n\n\t\n\n"]