["import sys\ninput = sys.stdin.readline\n\nn,x=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nMIN_R=[A[-1]]\nfor a in A[:-1][::-1]:\n    MIN_R.append(min(a,MIN_R[-1]))\n\nMIN_R=MIN_R[::-1]\n\nMAX=x\n\nfor i in range(n-1):\n    if A[i]>MIN_R[i+1]:\n        MAX=min(MAX,A[i])\n\nMAX_L=[A[0]]\nfor a in A[1:]:\n    MAX_L.append(max(a,MAX_L[-1]))\n\nMIN=0\nfor i in range(1,n):\n    if MAX_L[i-1]>A[i]:\n        MIN=max(MIN,A[i])\n\nNEED=[i for i in range(x+3)]\n\nfor i in range(n-1):\n    if A[i]>MIN_R[i+1]:\n        NEED[1]=max(NEED[1],MIN_R[i+1])\n        NEED[MIN_R[i+1]+1]=max(NEED[MIN_R[i+1]+1],A[i])\n\nfor i in range(1,x+2):\n    NEED[i]=max(NEED[i],NEED[i-1])\n\nANS=0\n\nfor i in range(1,MAX+1):\n    ANS+=x-max(MIN,NEED[i])+1\n\n    #print(i,ANS)\n\nprint(ANS)\n", "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\nmi = [x + 1] * (x + 1)\nma = [0] * (x + 1)\ntrie = [0] * (1 << 23)\nm = 4\ntrie[0] = x + 1\nfor i in a:\n  at = 0\n  mii = x + 1\n  maa = 0\n  for j in range(19, -1, -1):\n    if (i & (1 << j)):\n      if not trie[at + 3]:\n        trie[at + 3] = m\n        at = m\n        trie[m] = i\n        trie[m + 1] = i\n        m += 4\n      else:\n        at = trie[at + 3]\n        trie[at] = min(trie[at + 0], i)\n        trie[at + 1] = max(trie[at + 1], i)\n    else:\n      if trie[at + 3]:\n        mii = trie[trie[at + 3]]\n        if not maa:\n          maa = trie[trie[at + 3] + 1]\n      if not trie[at + 2]:\n        trie[at + 2] = m\n        at = m\n        trie[m] = i\n        trie[m + 1] = i\n        m += 4\n      else:\n        at = trie[at + 2]\n        trie[at] = min(trie[at + 0], i)\n        trie[at + 1] = max(trie[at + 1], i)\n  mi[i] = min(mi[i], mii)\n  ma[i] = max(ma[i], maa)\n\nfi = 0\nfor i in range(x, 0, -1):\n  if mi[i] != x + 1:\n    fi = i\n    break\n\nans = 0\ng = x + 1\nfor i in range(1, x + 1):\n  ans += x - max(i, fi) + 1\n  if i == g:\n    break\n  fi = max(fi, ma[i])\n  g = min(g, mi[i])\nprint(ans)", "n, x = map(int, input().split())\na = list(map(int, input().split()))\nfst, last, sm = [], [], []\nfor i in range(1000005):\n    fst.append(0)\n    last.append(0)\n    sm.append(0)\nfor i in range(n):\n    if fst[a[i]] == 0:\n        fst[a[i]] = i + 1\n    last[a[i]] = i + 1\nfor i in range(x + 2):\n    if fst[i] == 0:\n        fst[i] = n + 1\nl, ans = 0, 0\nfor i in range(1, x + 1):\n    if fst[i] > l:\n        l = max(l, last[i])\n        sm[l] += 1\n    else:\n        break\nfor i in range(1, n + 1):\n    sm[i] += sm[i - 1]\nl, i = n + 1, x + 1\nwhile i > 1:\n    if last[i] < l:\n        l = min(fst[i], l)\n        ans += min(sm[l - 1] + 1, i - 1)\n    else:\n        break\n    i -= 1\nprint(ans)", "N, X = map(int, input().split(' '))\n\n\nclass Next():\n\tdef __init__(self, arr):\n\t\t# array of length X\n\t\tnext_ = [None for _ in arr]\n\t\tfor i in range(len(arr)-2, -1, -1):\n\t\t\tnext_[i] = next_[i+1]\n\n\t\t\tif arr[i+1] != None:\n\t\t\t\tnext_[i] = i+1 \n\t\tself.next_ = next_\n\n\t\t\t\n\n\tdef get_next(self, value):\n\t\treturn self.next_[value]\n\ndef fast_solution():\n\tpref = 0\n\tmost_right = last[0]\n\tif most_right is None:\n\t\tmost_right = -1\n\n\t# Find longest non-decreasing prefix\n\twhile True:\n\t\tif pref == X - 1:\n\t\t\tbreak\n\t\tif first[pref+1] is not None and first[pref+1] < most_right:\n\t\t\tbreak\n\t\tpref += 1\n\t\tif pref + 1 < X and last[pref] is not None:\n\t\t\tmost_right = max(most_right, last[pref])\n\n\t# Find longest non-decreasing suffix\n\tsuf = X - 1\n\tmost_left = first[X-1]\n\tif most_left is None:\n\t\tmost_left = N\n\twhile True:\n\t\tif suf == 0:\n\t\t\tbreak\n\t\tif last[suf-1] is not None and last[suf-1] > most_left:\n\t\t\tbreak\n\t\tsuf -= 1\n\t\tif suf > 0 and first[suf] is not None:\n\t\t\tmost_left = min(most_left, first[suf])\n\n\tcount = 0\n\tj = max(suf-1, 0)\n\tfor i in range(min(pref+2, X)):\n\t\tj = max(i, j)\n\t\twhile i>0 and j<X-1 and last[i-1] is not None and next_first.get_next(j) is not None  and last[i-1] > first[next_first.get_next(j)]:\n\t\t\tj += 1\n\t\tcount += X - j\n\treturn count\n\ndef transform(x):\n\treturn int(x) - 1\n\nA = list(map(transform, input().split(' ')))\nfirst = [None for _ in range(X)]\nlast = [None for _ in range(X)]\n\nfor i in range(N):\n\tx = A[i]\n\tif first[x] is None:\n\t\tfirst[x] = i\n\n\tlast[x] = i\n\nnext_first = Next(first)\n\nprint(fast_solution())", "import os\nfrom io import BytesIO, StringIO\n#input = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef input_as_list():\n    return list(map(int, input().split()))\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\ndef main():\n    n, x = input_as_list()\n    a = input_as_list()\n\n    fo = array_of(lambda:-1, x+1)\n    lo = array_of(lambda:-1, x+1)\n\n    ans = 0\n\n    for i, e in enumerate(a):\n        if fo[e] == -1:\n            fo[e] = i\n        lo[e] = i\n\n    lastidx = -1\n    for i in range(1, x+1):\n        if fo[i] != -1:\n            if lastidx < fo[i]:\n                lastidx = lo[i]\n            else:\n                i -= 1\n                break\n    L = i\n\n\n    firstidx = n+1\n    for i in range(x, 0, -1):\n        if fo[i] != -1:\n            if lo[i] < firstidx:\n                firstidx = fo[i]\n            else:\n                i += 1\n                break\n    R = i\n\n    ans += min(x - R + 2, x)\n\n    c = n\n    for i in range(x, R-1, -1):\n        if fo[i] == -1:\n            fo[i] = c\n        else:\n            c = fo[i]\n\n    r = R\n    l = 1\n\n    while l <= L:\n        if l + 1 < r and (lo[l] == -1 or x < r or lo[l] < fo[r]):\n            ans += x - r + 2\n            #print(l+1, r-1)\n            l += 1\n        else:\n            r += 1\n    #print(L, R, ans)\n    print(ans)\n\nmain()"]