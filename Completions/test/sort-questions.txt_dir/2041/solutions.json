["import sys\n\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\n\ndef __starting_point():\n    lines = sys.stdin.readlines()\n    n = int(lines[0])\n    aa = [(a, i) for i, a in enumerate(map(int, lines[1].split()))]\n    m = int(lines[2])\n    qs = [None]*m\n    ans = [None]*m\n    for i in range(m):\n        k, pos = list(map(int, lines[i+3].split()))\n        qs[i] = (pos, k, i)\n    qs.sort(key=lambda x: x[1])\n    aa.sort(key=lambda x: x[1])\n    aa.sort(key=lambda x: x[0], reverse=True)\n    avl = AvlTree()\n    s = 0\n    for pos, k, i in qs:\n        for a, j in aa[s: k]:\n            avl.add(j, a)\n        ans[i] = str(avl.get_at(pos - 1)[1])\n        s = k\n    print(\"\\n\".join(ans))\n\n\n__starting_point()", "WIDTH = 10\n\ndef index_tree(n):\n    levels = [ [1]*n ]\n\n    size = WIDTH\n    while size < n:\n        m, r = n // size, n % size\n        levels.append( [size]*m + ([r] if r > 0 else []) )\n        size *= WIDTH\n\n    return levels\n\ndef dec_index(levels, i):\n    for level in levels:\n        level[i] -= 1\n        i //= WIDTH\n\ndef find_pos(levels, pos):\n    i, l = 0, len(levels) - 1\n    \n    total = 0\n    while True:\n        level = levels[l]\n        while total + level[i] < pos:\n            total += level[i]\n            i += 1\n        \n        if l == 0: return i\n        i *= WIDTH\n        l -= 1\n\n\nimport sys\n\ndef main():\n    ## INPUT\n    numbers = [int(x) for x in sys.stdin.read().split()]\n    n = numbers[0]\n    sequence = numbers[1:n+1]\n    m = numbers[n+1]\n\n    queries = {}\n    for i in range(n+2, n+2 + 2*m, 2):\n        k, pos = numbers[i], numbers[i+1]\n        if k in queries: queries[k][pos] = None\n        else: queries[k] = { pos: None }\n    \n    ## WORK\n    sequence1 = sorted([ (s,-i) for i,s in enumerate(sequence) ])\n    tree = index_tree(n)\n    size = n\n\n    for _, neg_i in sequence1: \n        if size in queries:\n            for pos in queries[size]:\n                queries[size][pos] = find_pos(tree, pos)\n\n        dec_index(tree, -neg_i)\n        size -= 1\n\n    ## PRINT \n    for i in range(n+2, n+2 + 2*m, 2):\n        k, pos = numbers[i], numbers[i+1]\n        print(sequence[ queries[k][pos] ])\n\n\nmain()\n\n", "from collections import defaultdict\nimport sys as _sys\n\n\ndef main():\n    n, = _read_ints()\n    a = tuple(_read_ints())\n    m, = _read_ints()\n    queries = (tuple(_read_ints()) for i_query in range(m))\n    result = process_queries(a, queries)\n    print(*result, sep='\\n')\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return map(int, _read_line().split())\n\n\ndef process_queries(sequence, queries):\n    sequence = tuple(sequence)\n    \n    indices_by_values = defaultdict(list)\n    for i, x in enumerate(sequence):\n        indices_by_values[x].append(i)\n    \n    enumerated_queries = sorted(enumerate(queries), key=lambda iv: iv[1][0])[::-1]\n    queries_responses = [None] * len(enumerated_queries)\n    \n    selections_tree = [0] * (len(sequence) + 1)\n    \n    k = 0\n    for value, indices in sorted(indices_by_values.items(), reverse=True):\n        for index_to_select in indices:\n            _fenwick_tree_add(selections_tree, index_to_select, 1)\n            k += 1\n            while enumerated_queries and enumerated_queries[-1][1][0] == k:\n                query_index, (_k, subseq_index) = enumerated_queries.pop()\n                seq_index = _find_seq_index_by_subseq_index(selections_tree, subseq_index)\n                queries_responses[query_index] = sequence[seq_index]\n\n    return queries_responses\n\n\ndef _find_seq_index_by_subseq_index(tree, subseq_i):\n    min_i = 0\n    max_i = len(tree) - 1\n    while min_i != max_i:\n        mid_i = (min_i + max_i) // 2\n        if _fenwick_tree_prefix_sum(tree, mid_i) < subseq_i:\n            min_i = mid_i + 1\n        else:\n            max_i = mid_i\n    return min_i\n\n\ndef _fenwick_tree_prefix_sum(tree, i):\n    i += 1\n    result = 0\n    while i != 0:\n        result += tree[i]\n        i -= i & (-i)\n    return result\n\n\ndef _fenwick_tree_add(tree, i, x):\n    i += 1\n    while i < len(tree):\n        tree[i] += x\n        i += i & (-i)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys as _sys\n\n\ndef main():\n    n, = _read_ints()\n    a = tuple(_read_ints())\n    m, = _read_ints()\n    queries = (tuple(_read_ints()) for i_query in range(m))\n    result = process_queries(a, queries)\n    print(*result, sep='\\n')\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return map(int, _read_line().split())\n\n\ndef process_queries(sequence, queries):\n    sequence = tuple(sequence)\n    \n    indices_to_select = sorted(\n        range(len(sequence)),\n        key=lambda index: (-sequence[index], index)\n    )\n    \n    enumerated_queries = sorted(enumerate(queries), key=lambda iv: iv[1][0])[::-1]\n    queries_responses = [None] * len(enumerated_queries)\n    \n    selections_tree = [0] * (len(sequence) + 1)\n    \n    selected_n = 0\n    for index_to_select in indices_to_select:\n        _fenwick_tree_add(selections_tree, index_to_select, 1)\n        selected_n += 1\n        while enumerated_queries and enumerated_queries[-1][1][0] == selected_n:\n            query_index, (_k, subseq_index) = enumerated_queries.pop()\n            seq_index = _find_seq_index_by_subseq_index(selections_tree, subseq_index)\n            queries_responses[query_index] = sequence[seq_index]\n    \n    return queries_responses\n\n\ndef _find_seq_index_by_subseq_index(tree, subseq_i):\n    seq_length = len(tree) - 1\n    min_i = 0\n    max_i = seq_length - 1\n    while min_i != max_i:\n        mid_i = (min_i + max_i) // 2\n        if _fenwick_tree_prefix_sum(tree, mid_i) < subseq_i:\n            min_i = mid_i + 1\n        else:\n            max_i = mid_i\n    return min_i\n\n\ndef _fenwick_tree_prefix_sum(tree, i):\n    i += 1\n    result = 0\n    while i != 0:\n        result += tree[i]\n        i -= i & (-i)\n    return result\n\n\ndef _fenwick_tree_add(tree, i, x):\n    i += 1\n    while i < len(tree):\n        tree[i] += x\n        i += i & (-i)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]