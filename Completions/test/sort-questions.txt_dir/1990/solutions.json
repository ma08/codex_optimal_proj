["# reproduction of solution \u2116 66039386 by @windhunterSB\nimport sys\n\n\n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (s.rstrip() for s in sys.stdin)\n\nn = int(next(reader))\noperations = next(reader)\n\n# inf.close()\n\nleft_sum = [0] * (n + 2)   # for s[:i+1]\nright_sum = [0] * (n + 2)  # for s[i:][::-1]\nleft_min = [0] * (n + 2)   # min - validation of bracket sequence\nright_min = [0] * (n + 2)  \nleft_max = [0] * (n + 2)   # max - depth of bracket sequence\nright_max = [0] * (n + 2)\ntext = [0] * (n + 2)       # entered text, letters marked as 0\n\nop_map = {'(': 1,\n          ')': -1}\nans = []\ni = 1  # cursor loc i >= 1\nfor op in operations:\n    if op == 'L':\n        i = max(1, i - 1)\n    elif op == 'R':\n        i += 1\n    else:\n        text[i] = op_map.get(op, 0)\n        \n    left_sum[i] = left_sum[i - 1] + text[i]\n    left_min[i] = min(left_min[i - 1], left_sum[i])\n    left_max[i] = max(left_max[i - 1], left_sum[i])\n    \n    right_sum[i] = right_sum[i + 1] - text[i]  # -text[i] cause of symmetry\n    right_min[i] = min(right_min[i + 1], right_sum[i])\n    right_max[i] = max(right_max[i + 1], right_sum[i])\n    \n    correct = left_min[i] >= 0 and right_min[i + 1] >= 0 and left_sum[i] == right_sum[i + 1]\n    status = max(left_max[i], right_max[i + 1]) if correct else -1\n    ans.append(status)\n    \nprint(*ans)\n", "# reproduction of solution 66039386 by @windhunterSB\nimport sys\n \n \n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (s.rstrip() for s in sys.stdin)\n \nn = int(next(reader))\noperations = next(reader)\n \n# inf.close()\n \nleft_sum  = [0 for i in range(n + 2)]\nright_sum = [0 for i in range(n + 2)]\nleft_min = [0 for i in range(n + 2)]\nright_min = [0 for i in range(n + 2)]\nleft_max = [0 for i in range(n + 2)]\nright_max = [0 for i in range(n + 2)]\n# left_sum = [0] * (n + 2)   # for s[:i+1]\n# right_sum = [0] * (n + 2)  # for s[i:][::-1]\n# left_min = [0] * (n + 2)   # min - validation of bracket sequence\n# right_min = [0] * (n + 2)  \n# left_max = [0] * (n + 2)   # max - depth of bracket sequence\n# right_max = [0] * (n + 2)\n\ntext = [0] * (n + 2)       # entered text, letters marked as 0\n \nop_map = {'(': 1,\n          ')': -1}\nans = []\ni = 1  # cursor loc i >= 1\nfor op in operations:\n    if op == 'L':\n        i = max(1, i - 1)\n    elif op == 'R':\n        i += 1\n    else:\n        text[i] = op_map.get(op, 0)\n        \n    left_sum[i] = left_sum[i - 1] + text[i]\n    left_min[i] = min(left_min[i - 1], left_sum[i])\n    left_max[i] = max(left_max[i - 1], left_sum[i])\n    \n    right_sum[i] = right_sum[i + 1] - text[i]  # -text[i] cause of symmetry\n    right_min[i] = min(right_min[i + 1], right_sum[i])\n    right_max[i] = max(right_max[i + 1], right_sum[i])\n    \n    correct = left_min[i] >= 0 and right_min[i + 1] >= 0 and left_sum[i] == right_sum[i + 1]\n    status = max(left_max[i], right_max[i + 1]) if correct else -1\n    ans.append(status)\n    \nprint(*ans)", "# reproduction of solution \u2116 66039386 by @windhunterSB\nimport sys\n \n \n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (s.rstrip() for s in sys.stdin)\n \nn = int(next(reader))\noperations = next(reader)\n \n# inf.close()\n \nleft_sum = [0] * (n + 2)   # for s[:i+1]\nright_sum = [0] * (n + 2)  # for s[i:][::-1]\nleft_min = [0] * (n + 2)   # min - validation of bracket sequence\nright_min = [0] * (n + 2)  \nleft_max = [0] * (n + 2)   # max - depth of bracket sequence\nright_max = [0] * (n + 2)\ntext = [0] * (n + 2)       # entered text, letters marked as 0\n \nop_map = {'(': 1,\n          ')': -1}\nans = []\ni = 1  # cursor loc i >= 1\nfor op in operations:\n    if op == 'L':\n        i = max(1, i - 1)\n    elif op == 'R':\n        i += 1\n    else:\n        text[i] = op_map.get(op, 0)\n        \n    left_sum[i] = left_sum[i - 1] + text[i]\n    left_min[i] = min(left_min[i - 1], left_sum[i])\n    left_max[i] = max(left_max[i - 1], left_sum[i])\n    \n    right_sum[i] = right_sum[i + 1] - text[i]  # -text[i] cause of symmetry\n    right_min[i] = min(right_min[i + 1], right_sum[i])\n    right_max[i] = max(right_max[i + 1], right_sum[i])\n    \n    correct = left_min[i] >= 0 and right_min[i + 1] >= 0 and left_sum[i] == right_sum[i + 1]\n    status = max(left_max[i], right_max[i + 1]) if correct else -1\n    ans.append(status)\n    \nprint(' '.join(map(str, ans)))", "# Thanks for mitribunskiy\n# efficient input style\n# https://codeforces.com/contest/1263/submission/66081769\n\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\nn = int(next(reader))\noperations = next(reader)\nfrom collections import deque\n\nleft = deque()\nright = deque()\ncur = 0\nmax_n = n+1\nleft.append((0,0,0,0))\nfor i in range(max_n-1):\n    right.append((0,0,0,0))\n\nans = [-1]*n\nfor i, c in enumerate(operations):\n    if c == \"R\":\n        cur += 1\n        ci, _, _, _ = right.popleft()\n        _, su, mi, ma = left[-1]\n        left.append((-ci, su-ci, min(mi, su-ci), max(ma, su-ci)))\n    elif c == \"L\":\n        if cur:\n            cur -= 1\n            ci, _,_,_ = left.pop()\n            _, su, mi, ma = right[0]\n            right.appendleft((-ci, su-ci, min(mi, su-ci), max(ma, su-ci)))\n    else:\n        left.pop()\n        q = 0\n        if c == \"(\":\n            q = 1\n        elif c == \")\":\n            q = -1\n        if left:\n            ci, su, mi, ma = left[-1]\n            left.append((q, su+q, min(mi, su+q), max(ma, su+q)))\n        else:\n            left.append((q, q, q, q))\n    # check\n    _, sl, mil, mal = left[-1]\n    _, sr, mir, mar = right[0]\n    if sl == sr and mil >= 0 and mir >= 0:\n        ans[i] = max(mal, mar)\nprint(*ans)", "'''input\n11\n(R)R(R)Ra)c\n'''\n\n# MODIFIED SEGMENT TREE (MIN = MINIMUM PREFIX SUM instead of MINIMUM ELEMENT IN PREFIX)\n\nclass SegmentTree:\n    def __init__(self, n, arr=[]):\n        self.n = n\n        self.tsum = [0] * (2 * n)\n        self.tmin = [0] * (2 * n)\n        self.tmax = [0] * (2 * n)\n        if arr:\n            for i in range(len(arr)):\n                self.tsum[n + i] = arr[i];\n            for i in range(len(arr) - 1, 0, -1) :\n                self.tsum[i] = self.tsum[i << 1] + self.tsum[i << 1 | 1];\n\n    def update(self, p, val):\n        p += self.n;\n        self.tsum[p] = val;\n        self.tmin[p] = val;\n        self.tmax[p] = val;\n\n        i = p;\n        while i > 1:\n            self.tsum[i >> 1] = self.tsum[i] + self.tsum[i ^ 1];\n            self.tmin[i >> 1] = min(self.tmin[i], self.tmin[i ^ 1] + self.tsum[i]) if i%2==0 else min(self.tmin[i^1], self.tmin[i] + self.tsum[i^1])\n            self.tmax[i >> 1] = max(self.tmax[i], self.tmax[i ^ 1] + self.tsum[i]) if i%2==0 else max(self.tmax[i^1], self.tmax[i] + self.tsum[i^1])\n            i >>= 1;\n\n'''\nimport math\narray = [1,3,5,7,9,11]\nn = 2 ** math.ceil(math.log(len(array), 2))\nst = SegmentTree(n, array)\nst.update(0, 2)\n'''\n\nfrom sys import stdin\nimport math\ndef input():\n    return stdin.readline()[:-1]\n\nn = int(input())\ns = input()\n\n#n = 2 ** math.ceil(math.log(n, 2))\nn = 1048576\nst = SegmentTree(n)\n\nmaxit = -1\ncurrentit = 0\noutput = []\nfor c in s:\n    if c == 'L':\n        currentit = max(0, currentit - 1)\n    elif c == 'R':\n        currentit += 1\n    else:\n        maxit = max(maxit, currentit)\n        if c == '(':\n            st.update(currentit, 1)\n        elif c == ')':\n            st.update(currentit, -1)\n        else:\n            st.update(currentit, 0)\n\n    vmax = st.tmax[1]\n    vmin = st.tmin[1]\n    vsum = st.tsum[1]\n    if vmin >= 0 and vsum == 0:\n        output.append(vmax)\n    else:\n        output.append(-1)\n\nprint(' '.join(map(str, output)))\n\n", "'''input\n11\n(R)R(R)Ra)c\n'''\n\n# https://codeforces.com/blog/entry/18051\n# Min = minimum prefix sum instead of minimum value\n\nclass SegmentTree:\n    def __init__(self, n, arr=[]):\n        self.n = n\n        self.tsum = [0] * (2 * n)\n        self.tmin = [0] * (2 * n)\n        self.tmax = [0] * (2 * n)\n        if arr:\n            for i in range(len(arr)):\n                self.tsum[n + i] = arr[i];\n            for i in range(len(arr) - 1, 0, -1) :\n                self.tsum[i] = self.tsum[i<<1] + self.tsum[i<<1|1];\n\n    def update(self, p, val):\n        p += self.n;\n        self.tsum[p] = val;\n        self.tmin[p] = val;\n        self.tmax[p] = val;\n\n        i = p;\n        while i > 1:\n            par = i>>1 # parent\n            if i & 1: # i is a right child (odd index)\n                self.tsum[par] = self.tsum[i] + self.tsum[i^1];\n                self.tmin[par] = min(self.tmin[i^1], self.tmin[i] + self.tsum[i^1]) # i^1 = other child of i's parent\n                self.tmax[par] = max(self.tmax[i^1], self.tmax[i] + self.tsum[i^1])\n            else: # i is a left child\n                self.tsum[par] = self.tsum[i] + self.tsum[i^1];\n                self.tmin[par] = min(self.tmin[i], self.tmin[i^1] + self.tsum[i])\n                self.tmax[par] = max(self.tmax[i], self.tmax[i^1] + self.tsum[i])\n            i >>= 1;\n\n'''\nint query(int l, int r) {  // sum on interval [l, r)\n  int res = 0;\n  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n    if (l&1) res += t[l++];\n    if (r&1) res += t[--r];\n  }\n  return res;\n}\n\n'''\n\n'''\nimport math\narray = [1,3,5,7,9,11]\nn = 2 ** math.ceil(math.log(len(array), 2))\nst = SegmentTree(n, array)\nst.update(0, 2)\n'''\n\nfrom sys import stdin\nimport math\ndef input():\n    return stdin.readline()[:-1]\n\nn = int(input())\ns = input()\n\n#n = 2 ** math.ceil(math.log(n, 2))\nn = 1048576\nst = SegmentTree(n)\n\nmaxit = -1\ncurrentit = 0\noutput = []\nfor c in s:\n    if c == 'L':\n        currentit = max(0, currentit - 1)\n    elif c == 'R':\n        currentit += 1\n    else:\n        maxit = max(maxit, currentit)\n        if c == '(':\n            st.update(currentit, 1)\n        elif c == ')':\n            st.update(currentit, -1)\n        else:\n            st.update(currentit, 0)\n\n    vmax = st.tmax[1]\n    vmin = st.tmin[1]\n    vsum = st.tsum[1]\n    if vmin >= 0 and vsum == 0:\n        output.append(vmax)\n    else:\n        output.append(-1)\n\nprint(' '.join(map(str, output)))\n\n", "import traceback\n\ndef push(stack, delta):\n    if stack:\n        _, d, mn, mx = stack[-1]\n    else:\n        d, mn, mx = 0, 0, 0\n    stack.append((delta, d + delta, min(d + delta, mn), max(d + delta, mx)))\n\ndef main():\n    n = int(input())\n    ss = input()\n    left = [(0, 0,0,0)]\n    right = [(0, 0,0,0)] * n\n    res = []\n    try:\n        for s in ss:\n            if s == 'R':\n                delta = right.pop()[0]\n                push(left, -delta)\n            elif s == 'L':\n                if len(left) > 1:\n                    delta = left.pop()[0]\n                    push(right, -delta)\n            else:\n                if left:\n                    left.pop()\n                if s == '(':\n                    delta = 1\n                elif s == ')':\n                    delta = -1\n                else:\n                    delta = 0\n                push(left, delta)\n            _, ld, lmn, lmx = left[-1]\n            _, rd, rmn, rmx = right[-1]\n            if ld == rd and lmn >= 0 and rmn >= 0:\n                res.append(max(ld, lmx, rmx))\n            else:\n                res.append(-1)\n    except Exception as e:\n        print(e)\n        traceback.print_exc()\n        print(\"size left %d size right %d\"%(len(left), len(right)))\n    print(' '.join(map(str, res)))\n\n\n\n\ndef __starting_point():\n    main()\n__starting_point()", "'''input\n11\n(R)R(R)Ra)c\n'''\n\n# https://codeforces.com/blog/entry/18051\n# Min = minimum prefix sum instead of minimum value\n\nclass SegmentTree:\n    def __init__(self, n, arr=[]):\n        self.n = n\n        self.tsum = [0] * (2 * n)\n        self.tmin = [0] * (2 * n)\n        self.tmax = [0] * (2 * n)\n        if arr:\n            for i in range(len(arr)):\n                self.tsum[n + i] = arr[i];\n            for i in range(len(arr) - 1, 0, -1) :\n                self.tsum[i] = self.tsum[i<<1] + self.tsum[i<<1|1];\n\n    def update(self, p, val):\n        p += self.n;\n        self.tsum[p] = val;\n        self.tmin[p] = val;\n        self.tmax[p] = val;\n\n        i = p;\n        while i > 1:\n            par = i>>1 # parent\n            if i & 1: # i is a right child (odd index)\n                self.tsum[par] = self.tsum[i] + self.tsum[i^1];\n                self.tmin[par] = min(self.tmin[i^1], self.tmin[i] + self.tsum[i^1]) # i^1 = other child of i's parent\n                self.tmax[par] = max(self.tmax[i^1], self.tmax[i] + self.tsum[i^1])\n            else: # i is a left child\n                self.tsum[par] = self.tsum[i] + self.tsum[i^1];\n                self.tmin[par] = min(self.tmin[i], self.tmin[i^1] + self.tsum[i])\n                self.tmax[par] = max(self.tmax[i], self.tmax[i^1] + self.tsum[i])\n            i >>= 1;\n\n'''\nint query(int l, int r) {  // sum on interval [l, r)\n  int res = 0;\n  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n    if (l&1) res += t[l++];\n    if (r&1) res += t[--r];\n  }\n  return res;\n}\n\n'''\n\n'''\nimport math\narray = [1,3,5,7,9,11]\nn = 2 ** math.ceil(math.log(len(array), 2))\nst = SegmentTree(n, array)\nst.update(0, 2)\n'''\n\nfrom sys import stdin\nimport math\ndef input():\n    return stdin.readline()[:-1]\n\nn = int(input())\ns = input()\n\n#n = 2 ** math.ceil(math.log(n, 2))\nn = 1048576\nst = SegmentTree(n)\n\nmaxit = -1\ncurrentit = 0\noutput = []\nfor c in s:\n    if c == 'L':\n        currentit = max(0, currentit - 1)\n    elif c == 'R':\n        currentit += 1\n    else:\n        maxit = max(maxit, currentit)\n        if c == '(':\n            st.update(currentit, 1)\n        elif c == ')':\n            st.update(currentit, -1)\n        else:\n            st.update(currentit, 0)\n\n    vmax = st.tmax[1]\n    vmin = st.tmin[1]\n    vsum = st.tsum[1]\n    if vmin >= 0 and vsum == 0:\n        output.append(vmax)\n    else:\n        output.append(-1)\n\nprint(' '.join(map(str, output)))\n", "'''input\n11\n(R)R(R)Ra)c\n'''\n\n# https://codeforces.com/blog/entry/18051\n# Min = minimum prefix sum instead of minimum value\n\nclass SegmentTree:\n    def __init__(self, n, arr=[]):\n        self.n = n\n        self.tsum = [0] * (2 * n)\n        self.tmin = [0] * (2 * n)\n        self.tmax = [0] * (2 * n)\n        if arr:\n            for i in range(len(arr)):\n                self.tsum[n + i] = arr[i];\n            for i in range(len(arr) - 1, 0, -1) :\n                self.tsum[i] = self.tsum[i<<1] + self.tsum[i<<1|1];\n\n    def update(self, p, val):\n        p += self.n;\n        self.tsum[p] = val;\n        self.tmin[p] = val;\n        self.tmax[p] = val;\n\n        i = p;\n        while i > 1:\n            par = i>>1 # parent\n            if i & 1: # i is a right child (odd index)\n                self.tsum[par] = self.tsum[i] + self.tsum[i^1];\n                self.tmin[par] = min(self.tmin[i^1], self.tmin[i] + self.tsum[i^1]) # i^1 = other child of i's parent\n                self.tmax[par] = max(self.tmax[i^1], self.tmax[i] + self.tsum[i^1])\n            else: # i is a left child\n                self.tsum[par] = self.tsum[i] + self.tsum[i^1];\n                self.tmin[par] = min(self.tmin[i], self.tmin[i^1] + self.tsum[i])\n                self.tmax[par] = max(self.tmax[i], self.tmax[i^1] + self.tsum[i])\n            i >>= 1;\n\n'''\nint query(int l, int r) {  // sum on interval [l, r)\n  int res = 0;\n  for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n    if (l&1) res += t[l++];\n    if (r&1) res += t[--r];\n  }\n  return res;\n}\n\n'''\n\n'''\nimport math\narray = [1,3,5,7,9,11]\nn = 2 ** math.ceil(math.log(len(array), 2))\nst = SegmentTree(n, array)\nst.update(0, 2)\n'''\n\nfrom sys import stdin\nimport math\ndef input():\n    return stdin.readline()[:-1]\n\ndef main():\n    n = int(input())\n    s = input()\n\n    #n = 2 ** math.ceil(math.log(n, 2))\n    n = 1048576\n    st = SegmentTree(n)\n\n    maxit = -1\n    currentit = 0\n    output = []\n    for c in s:\n        if c == 'L':\n            currentit = max(0, currentit - 1)\n        elif c == 'R':\n            currentit += 1\n        else:\n            maxit = max(maxit, currentit)\n            if c == '(':\n                st.update(currentit, 1)\n            elif c == ')':\n                st.update(currentit, -1)\n            else:\n                st.update(currentit, 0)\n\n        vmax = st.tmax[1]\n        vmin = st.tmin[1]\n        vsum = st.tsum[1]\n        if vmin >= 0 and vsum == 0:\n            output.append(vmax)\n        else:\n            output.append(-1)\n\n    print(' '.join(map(str, output)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nS = list(input().rstrip())\n\nL = [0]\nLm = [0]\nLM = [0]\nR = [0]\nRm = [0]\nRM = [0]\nans = []\nfor s in S:\n    if s == \"R\":\n        if len(R) == 1:\n            d = 0\n        else:\n            d = R[-2] - R[-1]\n            R.pop()\n            Rm.pop()\n            RM.pop()\n        L.append(L[-1]+d)\n        Lm.append(min(Lm[-1], L[-1]))\n        LM.append(max(LM[-1], L[-1]))\n    elif s == \"L\":\n        if len(L) != 1: \n            d = L[-2] - L[-1]\n            L.pop()\n            Lm.pop()\n            LM.pop()\n            R.append(R[-1]+d)\n            Rm.append(min(Rm[-1], R[-1]))\n            RM.append(max(RM[-1], R[-1]))\n    else:\n        if s == \"(\":\n            num = -1\n        elif s == \")\":\n            num = +1\n        else:\n            num = 0\n        if len(R) != 1:\n            R.pop()\n            Rm.pop()\n            RM.pop()\n        R.append(R[-1]+num)\n        Rm.append(min(Rm[-1], R[-1]))\n        RM.append(max(RM[-1], R[-1]))\n\n    if L[-1] == R[-1] and Lm[-1] >= 0 and Rm[-1] >= 0:\n        ans.append(str(max(LM[-1], RM[-1])))\n    else:\n        ans.append(str(-1))\n\nprint(\" \".join(ans))"]