["from sys import stdin, stdout\nimport os,sys,__pypy__\n\ndef main():\n    #t = int(stdin.readline())\n    n,m = list(map(int, stdin.readline().split()))\n    tree = [list() for _ in range(n+1)]\n    mn = [0] * (n+1)\n    for _ in range(m):\n        a,b = list(map(int, stdin.readline().split()))\n        tree[a].append(b)\n        tree[b].append(a)\n    stacks = [list() for _ in range(n+1)]\n    arr = list(map(int, stdin.readline().split()))\n    for i,x in enumerate(arr):\n        stacks[x].append(i+1)\n        \n    is_can = True\n    ans = __pypy__.builders.StringBuilder()\n    cnt = 0\n    for i,stack in enumerate(stacks):\n        for x in stack:\n            if mn[x] + 1 == i:\n                ans.append(\"%d \"%(x))\n                cnt += 1\n                for near in tree[x]:\n                    if mn[near] +1 == i:\n                        mn[near] += 1\n            else:\n                is_can = False\n                break\n        if not is_can:\n            break\n    if not is_can  or cnt != n:\n        stdout.write(\"-1\\n\")\n    else:\n        os.write(1,ans.build().encode())\n        \nmain()", "import io\nimport os\n\nfrom collections import Counter, defaultdict, deque\n\n\n\ndef solve(N, M, edges, topics):\n    g = [[] for i in range(N)]\n    for u, v in edges:\n        g[u].append(v)\n        g[v].append(u)\n\n    assert len(topics) == N\n    vertices = sorted(list(range(N)), key=lambda k: topics[k])\n\n    seen = set()\n    for v in vertices:\n        best = -1\n        uniq = set()\n        for nbr in g[v]:\n            if nbr in seen:\n                best = max(best, topics[nbr])\n                uniq.add(topics[nbr])\n        if best + 1 != topics[v] or len(uniq) != topics[v]:\n            return -1\n        seen.add(v)\n\n    return \" \".join(str(x + 1) for x in vertices)\n\n\ndef __starting_point():\n    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n    N, M = [int(x) for x in input().split()]\n    edges = [[int(x) - 1 for x in input().split()] for i in range(M)]  # 0 indexed\n    topics = [int(x) - 1 for x in input().split()]  # 0 indexed\n    ans = solve(N, M, edges, topics)\n    print(ans)\n\n__starting_point()", "import sys\ninput = sys.stdin.buffer.readline\nn,m=list(map(int,input().split()))\ncon=[[] for _ in range(n)]\nfor _ in range(m):\n\ta,b=list(map(int,input().split()))\n\tcon[a-1].append(b-1)\n\tcon[b-1].append(a-1)\nt=[int(x) for x in input().split()]\nod=sorted(list(range(n)),key=lambda f:t[f])\ncn=[1]*n\nans=[]\nfor ii in od:\n\ttt=t[ii]\n\tif cn[ii]!=tt:\n\t\tprint(-1)\n\t\treturn\n\tfor jj in con[ii]:\n\t\tif cn[jj]==tt:\n\t\t\tcn[jj]+=1\n\tans.append(ii+1)\nprint(\" \".join(map(str,ans)))\n\n\n", "import io,os\ninput=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nimport sys\nfrom collections import deque\n\ndef solve(n,m,Edges,T):\n    if n==1:\n        if T[0]==1:\n            return [1]\n        return [-1]\n    L=[]\n    for i,t in enumerate(T):\n        L.append((t,i))\n    L.sort()\n    Visited=[False]*n\n    Ans=[]\n    for num,fr in L:\n        Visited[fr]=True\n        s=set()\n        for to in Edges[fr]:\n            if Visited[to]:\n                if T[to]==num:\n                    return [-1]\n                s.add(T[to])\n        if len(s)!=num-1:\n            return [-1]\n        Ans.append(fr+1)\n    return Ans\n\ndef main():\n    n,m=map(int,input().split())\n    Edges=[[] for _ in range(n)]\n    for _ in range(m):\n        a,b=map(lambda x: int(x)-1,input().split())\n        Edges[a].append(b)\n        Edges[b].append(a)\n    T=list(map(int,input().split()))\n    Ans=solve(n,m,Edges,T)\n    sys.stdout.write(' '.join(map(str,Ans))+'\\n')\n    \ndef __starting_point():\n    main()\n__starting_point()"]