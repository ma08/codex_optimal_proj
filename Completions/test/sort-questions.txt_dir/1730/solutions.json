["def f():\n    n, m, k = map(int, input().split())\n    p = [[] for i in range(n + 1)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        p[a].append(b)\n        p[b].append(a)\n    t, r = [0] * (n + 1), [1]\n    x = t[1] = 1\n    i = 0 - k\n    while True:\n        for y in p[x]:\n            if t[y] == 2: return r[r.index(y): ]\n            if t[y]: continue\n            t[y], x = 1, y\n            r.append(x)\n            i += 1\n            if i >= 0: t[r[i]] = 2\n            break\nt = f()\nprint(len(t))\nprint(' '.join(map(str, t)))", "n,l,k=map(int,input().split())\nc=list([] for i in range(n+1))\nfor i in range(l):\n    x,y=map(int,input().split())\n    c[x].append(y)\n    c[y].append(x)\nd=list(0 for i in range(n+1))\nd[1]=1\nnow=1\ntime=1\nf=True\nwhile f:\n    time+=1\n    v=0\n    while v>=0:\n        if d[c[now][v]]==0:\n            now=c[now][v]\n            d[now]=time\n            v=-1\n        elif d[c[now][v]]+k<time:\n            f=False\n            mintime=d[c[now][v]]\n            v=-1\n        else:\n            v+=1\ng=list(0 for i in range(time-mintime))\nfor i in range(n+1):\n    if d[i]>=mintime:\n        g[d[i]-mintime]=i \nprint(time-mintime)\nprint(*g)", "import sys\nimport threading\n\ndef put():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef dfs(i, h):\n    vis[i] =h \n    done[i]=1\n    element.append(i)\n    for j in graph[i]:\n        if vis[j]!=0 and h-vis[j]>=k:\n                ind = element.index(j)\n                ans.extend(element[ind:])\n                raise ValueError\n        elif done[j]==0:\n            dfs(j,h+1)\n    vis[i]=0\n    element.pop()\n\ndef solve():\n    try:\n        for i in range(1, n+1):\n            if done[i]==0:\n                dfs(i,1)\n    except:\n        print(len(ans))\n        print(*ans)\n           \n\n\nn,m,k = put()\ngraph = [[] for _ in range(n+1)]\nfor i in range(m):\n    x,y = put()\n    graph[x].append(y)\n    graph[y].append(x)\n    \ndone,vis = [0]*(n+1),[0]*(n+1)\nelement,ans = [],[]\n\n\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()\n", "def find_cycle_optimum(n,m,k,adj):\n    path = [1]\n    visited = [-1 for _ in range(n+1)]\n    visited[1] = 1\n    while True:\n        v = path[-1]\n        visited[v] = len(path) - 1\n        for w in adj[v]:\n            if visited[w] == -1:\n                path.append(w)\n                break\n            elif len(path) - visited[w] > k:\n                return path[visited[w]::]\n\ndef main ():\n    n,m,k =[int(i) for i in input().split()]\n    adj = [[] for i in range(n+1)]\n    for _ in range(m):\n        u,v = [int(i) for i in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    c = find_cycle_optimum(n,m,k,adj)\n    l = len(c)\n    print(l)\n    print(' '.join(str(v) for v in c))\n\nmain()"]