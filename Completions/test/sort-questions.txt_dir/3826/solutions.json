["def main():\n    import sys\n    input = sys.stdin.readline\n    \n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    dct = {}\n    for x in arr:\n        dct[x] = 0\n    \n    i = 0\n    while i != n and dct[arr[i]] == 0:\n        dct[arr[i]] = 1\n        i += 1\n    \n    if i == n:\n        print(0)\n        return 0\n    \n    j = n - 1\n    while dct[arr[j]] == 0:\n        dct[arr[j]] = 1\n        j -= 1\n    \n    ans = j - i + 1\n    \n    for k in range(i - 1, -1, -1):\n        dct[arr[k]] -= 1\n        while dct[arr[j]] == 0:\n            dct[arr[j]] = 1\n            j -= 1\n        ans = min(ans, j - (k - 1))\n    \n    print(ans)\n    \n    return 0\n\nmain()", "n = int(input())\na = list(map(int, input().split()))\ns, d = {}, {}\nfor q in range(n):\n    s[a[q]] = q\n    d[a[q]] = d.get(a[q], 0)+1\nq2, ans = 0, n-1\nfor q1 in d:\n    while d[q1] > 1:\n        d[a[q2]] -= 1\n        q2 += 1\nf = set()\nfor q in range(n):\n    ans = min(ans, q2-q)\n    if a[q] in f:\n        break\n    f.add(a[q])\n    q2 = max(q2, s[a[q]]+1, q+1)\nprint(ans)\n", "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nd = dict()\n\nfor elem in a:\n    d[elem] = d.get(elem, 0) + 1\n\nnot_uniq = 0\nfor elem in d:\n    if d[elem] > 1:\n        not_uniq += 1\n\nif not_uniq == 0:\n    print(0)\n    return\n\nans = 10 ** 9\nleft = 0\nright = -1\n\nwhile True:\n    if not_uniq == 0:\n        ans = min(ans, right - left + 1)\n    if not_uniq > 0:\n        right += 1\n        if right >= n:\n            break\n        elem = a[right]\n        d[elem] -= 1\n        if d[elem] == 1:\n            not_uniq -= 1\n    else:\n        elem = a[left]\n        d[elem] += 1\n        if d[elem] == 2:\n            not_uniq += 1\n        left += 1\n\nprint(ans)\n\n\n        \n    \n", "n = int(input())\na = [int(x) for x in input().split()]\n\nfrom collections import defaultdict as dd\nd = dd(int)\n\nfor i in a:\n    d[i] += 1\n\ncnt, ans = 0, 10000000\nfor i in d:\n    if d[i] >= 2:\n        cnt += 1\n\nif cnt == 0:\n    print(0)\nelse:\n    for i in range(n):\n        d2 = dd(int)\n        ct = 0\n        for j in range(i, n):\n            d2[a[j]] += 1\n\n            if d2[a[j]] == d[a[j]] - 1 and d[a[j]]  >= 2:\n                ct += 1\n                \n            #print(j, i, ct, d2[3])\n            if ct == cnt:\n                ans = min(ans, abs(j - i + 1))\n                \n    print(ans)\n", "import sys\nimport copy\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nfrom collections import Counter\n\nC=Counter(A)\nfor a in A:\n    if C[a]<=1:\n        del C[a]\n\n\n\nif not(C):\n    print(0)\n    return\n\nANS=n-1\n\nfor i in range(n):\n    D=copy.deepcopy(C)\n\n    for j in range(i,n):\n        if D[A[j]]>=1:\n            D[A[j]]-=1\n\n        if D[A[j]]==1:\n            del D[A[j]]\n\n        if not(D):\n            ANS=min(ANS,j-i+1)\n            break\n\n    #print(i,j,D,ANS)\n\nprint(ANS)\n            \n", "import math\nfrom collections import defaultdict\n\n\ndef try_solve(x, d):\n    occ = defaultdict(lambda: 0)\n    for i in range(d, len(x)):\n        occ[x[i]] += 1\n    multi = 0\n    for k, v in list(occ.items()):\n        if v > 1:\n            multi += 1\n\n    if multi == 0:\n        return True\n\n    if d == 0:\n        return False\n\n    for i in range(len(x) - d):\n        occ[x[i]] += 1\n        if occ[x[i]] == 2: multi += 1\n        occ[x[i + d]] -= 1\n        if occ[x[i + d]] == 1: multi -= 1\n        if multi == 0:\n            return True\n\n    return False\n\n\ndef main():\n    n = int(input())\n    x = [int(x) for x in input().split()]\n\n    for i in range(n - 1):\n        if try_solve(x, i):\n            print(i)\n            return\n\n    print(n - 1)\n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "'''input\n4\n1 1 2 2\n'''\nfrom sys import stdin\nfrom copy import deepcopy\n\n\ndef get_dict(arr, n):\n\tmydict = dict()\n\tfor i in range(n):\n\t\tif arr[i] in mydict:\n\t\t\tmydict[arr[i]] += 1\n\t\telse:\n\t\t\tmydict[arr[i]] = 1\n\n\tmore = 0\n\tfor i in mydict:\n\t\tif mydict[i] > 1:\n\t\t\tmore += 1\n\treturn more, mydict\n\n\n# main starts\nn = int(stdin.readline().strip())\narr = list(map(int, stdin.readline().split()))\nans = float('inf')\nmore, mydict = get_dict(arr, n)\nif more == 0:\n\tans = 0\n\tprint(ans)\n\treturn\n\nfor i in range(n):\n\tt = more\n\ttdict = deepcopy(mydict)\n\tfor j in range(i, n):\n\t\ttdict[arr[j]] -= 1\n\t\tif tdict[arr[j]] == 1:\n\t\t\tt -= 1\n\t\tif t == 0:\n\t\t\tans = min(ans,  abs(i - j) + 1)\n\n\nprint(ans)", "n = int(input())\n\na = list(map(int,input().split()))\nmin1 = n + 1\nmyset = set()\nfor i in range(n):\n    temp = myset.copy()\n    min1 = min(min1, n - i)\n    for j in range(n-1, i-1, -1):\n    \tif(a[j] in temp):\n    \t\tbreak\n    \ttemp.add(a[j])\n    \tmin1 = min(min1, j - i)\n    if(a[i] in myset):\n        break\n    myset.add(a[i])\n    # print(myset, min1)\n\t\nprint(min1)", "'''n=int(input())\na=[int(i) for i in input().split()]\nst = set()\npre=[]\nfor i in range(len(a)):\n    st.add(a[i])\n    pre.append(len(st))\n\nstn=set()\nsuf=[]\nfor i in range(len(a)-1,-1,-1):\n    stn.add(a[i])\n    suf.append(len(stn))\nsuf = suf[::-1]\nsuf = suf + [0]\npre = [0]+pre\nfuf = suf+[0]\n\nans=10**9\nfor i in range(len(a)):\n    for j in range(i,len(a)):\n        left=i\n        right=j\n        tot = (i) + (n-j-1)\n        if(pre[i]+suf[j+1]==tot):\n            print(i,j,left,right,tot,pre[i],suf[j])\n            ans = min(ans,j-i+1)\nif(ans==10**9):\n    print(0)\nelse:\n    print(ans)'''\nfrom collections import defaultdict as dd\n\ndef main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    d = dd(int)\n\n    for i in a:\n        d[i] += 1\n\n    cnt=0\n    ans=10**9\n    for i in d:\n        if d[i] >= 2:\n            cnt += 1\n\n    if cnt == 0:\n        print(0)\n    else:\n        for i in range(n):\n            d2 = dd(int)\n            ct = 0\n            for j in range(i, n):\n                d2[a[j]] += 1\n\n                if d2[a[j]] == d[a[j]] - 1 and d[a[j]]  >= 2:\n                    ct += 1\n\n                if ct == cnt:\n                    ans = min(ans, abs(j - i + 1))\n                    \n        print(ans)\n\n\nmain()\n", "n = int(input())\nA = [int(x) for x in input().split()]\n\nfrom collections import defaultdict as dd\n\n\nhsh = dd(int)\nfor i in range(n):\n    hsh[A[i]] += 1\n\ncnt = 0\nans = 10000000\n\nfor i in hsh:\n    if hsh[i] >= 2:\n        cnt += 1\nif len(set(A)) == n:\n    print(0)\nelse:\n    for i in range(n):\n        hsh2 = dd(int)\n        ct = 0\n        for j in range(i, n):\n            hsh2[A[j]] += 1\n            if hsh2[A[j]] == hsh[A[j]] - 1 and hsh[A[j]]  >= 2:\n                ct += 1\n            if ct == cnt:\n                ans = min(ans, abs(j - i + 1))\n                \n    print(ans)\n", "from collections import defaultdict\n\n\ndef can_remove(a, n):\n    nums = defaultdict(lambda: 0)\n\n    for i in range(n, len(a)):\n        nums[a[i]] += 1\n\n    if all([x<=1 for x in  list(nums.values())]):\n        return True\n\n    for remove_num in range(n, len(a)):\n        nums[a[remove_num]] -= 1\n        nums[a[remove_num - n]] += 1\n        if all([x <= 1 for x in list(nums.values())]):\n            return True\n\n    return False\n\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nimpossible = -1\npossible = len(a) - 1\n\nwhile possible - impossible > 1:\n    m = (possible + impossible) // 2\n    if can_remove(a, m):\n        possible = m\n    else:\n        impossible = m\n\nprint(possible)\n\n\n\n", "import collections\ndef __starting_point():\n    N = int(input())\n    A = [int(a) for a in input().split(\" \")]\n    C = collections.Counter(A)\n    n_duplicate = 0\n    for k, v in list(C.items()):\n        if v > 1:\n            n_duplicate += v - 1\n    if n_duplicate == 0:\n        print(\"0\")\n    else:\n        ans = N\n        for i in range(0, N - 1):\n            T = collections.Counter(A)\n            t_duplicate = n_duplicate\n            for j in range(i, min(N, i + ans)):\n                T[A[j]] -= 1\n                if T[A[j]] >= 1:\n                    t_duplicate -= 1\n                if t_duplicate == 0:\n                    ans = j + 1 - i\n                    break\n        print(str(ans))\n\n\n\n__starting_point()", "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    ans = n\n    for l in range(0, n + 1):\n        s = set(a[:l])\n        if len(s) < l:\n            break\n\n        # print(l, s)\n\n        r = n - 1\n        while r >= l and a[r] not in s:\n            s.add(a[r])\n            r -= 1\n\n        # print(r, s)\n        ans = min(ans, r - l + 1)\n        # print()\n\n    print(ans)\n\n\nmain()\n", "def f(m):\n    b = {}\n    for i in a[m:]:\n        if i in b:\n            b[i] += 1\n        else:\n            b[i] = 1\n    #print(m,b)\n    k = 0\n    for i in b:\n        if b[i] > 1:\n            k += 1\n    if k == 0:\n        return True\n    for i in range(n-m):\n        b[a[i+m]] -= 1\n        if b[a[i+m]] == 1:\n            k -= 1\n        if a[i] in b:\n            b[a[i]] += 1\n            if b[a[i]] == 2:\n                k += 1\n        else:\n            b[a[i]] = 1\n        if k == 0:\n            return True\n    return False\n\nn = int(input())\na = list(map(int,input().split()))\n\nl = 0\nr = n\nwhile r-l > 1:\n    m = (r+l)//2\n    if f(m):\n        r = m\n    else:\n        l = m\nif f(l):\n    r = l\nprint(r)\n", "import sys\n\n\ndef get_sn():\n    return int(input())\n\ndef get_n():\n    return list(map(int, input().split()))\n\ndef get_ln():\n    return list(get_n())\n\ndef cond(x, a, n):\n    for i in range(n - x + 1):\n        if len(set(a[:i] + a[i + x:])) == n - x:\n            return True\n    return False\n\ndef solve(a, n):\n    l, r = -1, n + 1\n    while r - l > 1:\n        m = (r + l) // 2\n        if cond(m, a, n):\n            r = m\n        else:\n            l = m\n    return r\n\ndef main():\n    n = get_sn()\n    arr = get_ln()\n    print(solve(arr, n))\n\nmain()\n", "import sys\ninput = lambda: sys.stdin.readline().strip()\n\nn = int(input())\nls = list(map(int, input().split()))\nd = [{}]\nworks = {}\nfor i in range(n):\n    works[i] = True\nfor i in range(n):\n    d.append(dict(d[-1]))\n    try: d[-1][ls[i]]+=1; works[i] = False\n    except: d[-1][ls[i]] = 1\nm = n\nfor l in range(n):\n    for r in range(n-1, l-1, -1):\n        try:\n            d[l][ls[r]]+=0\n            break\n        except:\n            d[l][ls[r]] = 1\n            pass\n    if works[l]:\n        m = min(m, r-l+1)\n    else:\n        m = min(m, r-l+1)\n        break\nif len(set(ls))==n: print(0)\nelse: print(m)\n", "n=int(input())\na=list(map(int,input().split()))\nk=set(a)\nm=len(k)\nif n == m:\n    print(0)\nelse:\n    ans=9999999999999999999999999999999999999999999999999999999999999999\n    for i in range(n):\n        mp={}\n        for j in range(n):\n            if a[j] in mp:\n                mp[a[j]] += 1\n            else:\n                mp[a[j]]=1\n        for j in range(i,n):\n            mp[a[j]] -= 1\n            if mp[a[j]]==0:\n                    mp.pop(a[j])\n            p=len(mp)\n            if p == n-j+i-1:\n                ans=min(ans,j-i+1);     \n                break\n            \n    print(ans)\n", "from collections import defaultdict\ndef KKK():\n    n = int(input())\n    d = defaultdict(int)\n    a = list(map(int, input().split()))\n    se = set()\n    for i in range(len(a)):\n        d[a[i]] += 1\n        se.add(a[i])\n\n    s = 0\n    while se:\n        s += d[se.pop()] - 1\n\n\n    minLen = 3000\n    for i in range(len(a)):\n        r = s\n        newd = d.copy()\n        for j in range(i, len(a)):\n            if r == 0:\n                minLen = min(j - i, minLen)\n            if newd[a[j]] > 1:\n                newd[a[j]] -= 1\n                r -= 1\n        if r == 0:\n            minLen = min(len(a) - i, minLen)\n    print(minLen)\nKKK()", "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\n# prime = 998244353 \n# INF = 1000000000000000000000\n\n# from sys import stdout\n# from heapq import heappush, heappop\nfrom collections import defaultdict\n# from collections import deque  \n\n# from math import sqrt    \n# from math import gcd\n# from math import log2\n\nt = 1#int(input())\n\nfor test in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    D = defaultdict(int)\n    ind1 = 0\n    ind2 = -1\n    for i in a:\n        D[i]+=1\n    count = 0\n    seta = list(set(a))\n    for i in seta:\n        if D[i]>1:\n            count+=1\n    if count == 0:\n        print(0)\n        return\n    tmp_count = 0\n    ans = n\n    while True:\n        # print(\"check\", tmp_count, count, ind2)\n        if tmp_count<count:\n            ind2+=1\n            if ind2==n:\n                break\n            D[a[ind2]]-=1\n            if D[a[ind2]]==1:\n                tmp_count+=1\n        elif tmp_count==count:\n            ans = min(ind2-ind1+1, ans)\n            D[a[ind1]]+=1\n            if D[a[ind1]]==2:\n                tmp_count-=1\n            ind1+=1\n    print(ans)\n\n\n\n\n", "from sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n\n\nn = int(input())\na = list(map(int, input().split()))\n\n\ndef solve(n, a):\n    l = -1\n    s = set()\n    while l + 1 < n and a[l + 1] not in s:\n        s.add(a[l + 1])\n        l += 1\n\n    r = n\n    while r - 1 >= 0 and a[r - 1] not in s:\n        s.add(a[r - 1])\n        r -= 1\n\n    res = l + 1 + (n - r)\n    while l >= 0:\n        s.remove(a[l])\n        l -= 1\n        while r - 1 >= 0 and a[r - 1] not in s:\n            s.add(a[r-1])\n            r -= 1\n        res = max(res, l + 1 + n - r)\n    return n - res\n\nprint(str(solve(n, a)))\n", "n = int(input())\na = [int(x) for x in input().split()]\nmp = {}\nrep = 0\n\nfor i in range(n):\n  if a[i] in mp:\n    mp[a[i]] += 1\n    rep+=1\n  else:\n    mp[a[i]] = 1\n\nans = 1000000\nif rep == 0:\n  print(0)\nelse:\n  for i in range(n):\n    z = []\n    flag = 0\n    for j in range(i,n):\n      if mp[a[j]]>1:\n        z.append(a[j])\n        mp[a[j]]-=1\n        rep-=1\n      if rep == 0:\n        ans = min(ans,j - i + 1)\n        break\n    rep+=len(z)\n    for i in z:\n      mp[i]+=1\n  print(ans)\n\n\n\n", "n = int(input())\nai = list(map(int,input().split()))\nar = {}\nnum = 1\nfor i in range(n):\n    try:\n        ar[ai[i]] += 1\n        num = i\n        break\n    except:\n        ar[ai[i]] = 1\nans = num\nif ans == n :\n    print(0)\nelse:\n    for i in range(num-1,-2,-1):\n        ar3 = {}\n        for j in range(i+1):\n            ar3[ai[j]] = 1\n        for j in range(n-1,-1,-1):\n            try:\n                ar3[ai[j]] += 1\n                ans = max(ans, i+1 + n-1-j )\n                break\n            except:\n                ar3[ai[j]] = 1\n    print(n - ans)\n", "''' \u0628\u0650\u0633\u0652\u0645\u0650 \u0627\u0644\u0644\u064e\u0651\u0647\u0650 \u0627\u0644\u0631\u064e\u0651\u062d\u0652\u0645\u064e\u0670\u0646\u0650 \u0627\u0644\u0631\u064e\u0651\u062d\u0650\u064a\u0645\u0650 '''\n#codeforces1208B_live\nfrom collections import Counter\ngi = lambda : list(map(int,input().split()))\nn, = gi()\nl = gi()\nocc = Counter(l)\nmid = 0\nans = n\nrep = n - len(occ)\ndef f(x):\n\toc = Counter(l)\n\tfor k in range(x):\n\t\toc[l[k]] -= 1\n\ts = set(oc.values())\n\tif s == {1} or s == {1, 0}:\n\t\treturn 1\n\tfor k in range(x, n):\n\t\toc[l[k]] -= 1\n\t\toc[l[k - x]] += 1\n\t\ts = set(oc.values())\n\t\tif s == {1} or s == {1, 0}:\n\t\t\treturn 1\n\treturn 0\nlo, hi = 0, n\nwhile lo <= hi:\n\tmid = (lo + hi) // 2\n\tif f(mid):\n\t\tans = min(ans, mid)\n\t\thi = mid - 1\n\telse:\n\t\tlo = mid + 1\nprint(ans)", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n                (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return list(map(int, stdin.readline().split()))\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = False\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    li = get_list()\n    l,r = 0, -1\n    cnt = Counter(li)\n    for i in range(n):\n        st = set()\n        if cnt[li[i]]==1: continue\n        brk = False\n        for j in range(0,i):\n            if li[j] in st:\n                brk = True\n                break\n            st.add(li[j])\n        if brk: continue\n        for j in range(n-1, i-1, -1):\n            if li[j] in st:\n                break\n            st.add(li[j])\n        if r-l<0 or r-l>=j-i:\n            l,r = i, j\n            #print(l,r )\n    print(r-l+1)\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()\n", "def check(repeat):\n    for key in repeat:\n        if(repeat[key]>0):\n            return False\n    return True\n\n\n\n\nn=int(input())\narray=list(map(int,input().split()))\noccur=dict()\nrepeat=dict()\nfor i in array:\n    if(i not in occur):\n        occur[i]=1\n    else:\n        if(i not in repeat):\n            repeat[i]=1\n        else:\n            repeat[i]+=1\nif(len(repeat)==0):\n    print(0)\nelse:\n    minm=2**31-1\n    i=0\n    boolean=False\n    j=0\n    while(i<len(array) and j<len(array)):\n        while(boolean==False and j<len(array)):\n            if(array[j] in repeat):\n                repeat[array[j]]-=1\n            j+=1\n            if(check(repeat)):\n                minm=min(minm,j-i)\n                #print(\"a\",i,j)\n                boolean=True\n            else:\n                boolean=False\n        while(boolean==True and i<j):\n            if(array[i] in repeat):\n                repeat[array[i]]+=1\n            i+=1\n            if(check(repeat)):\n                boolean=True\n                #print(\"b\",i,j)\n                minm=min(minm,j-i)\n            else:\n                boolean=False\n    boolean=check(repeat)\n    while(boolean and i<len(array)):\n        if(array[i] in repeat):\n            repeat[array[i]]+=1\n        i+=1\n        if(check(repeat)):\n            boolean=True\n            #print(i,j)\n            minm=min(\"c\",minm,j-i)\n        else:\n            boolean=False\n    print(minm)\n            \n"]