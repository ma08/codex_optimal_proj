["import math\nn = int(input())\na = list(map(int, input().split()))\nd = {0: 1}\nm = 1\nans = 0\nfor i in a:\n\t#print(\"i=\", i)\n\tdivisors = []\n\tfor j in range(1, min(m, int(math.sqrt(i))) + 1):\n\t\tif i % j == 0:\n\t\t\tk = int(i / j)\n\t\t\tdivisors.append(j)\n\t\t\tif j != k and k <= m:\n\t\t\t\tdivisors.append(k)\n\t#print(\"divisors=\", divisors)\n\tnew_d = {0: 1}\n\tfor j in divisors:\n\t\tans = (ans + d[j - 1]) % 1000000007\n\t\t#print(\"j=\", j, \"ans=\", ans)\n\t\tnew_d[j] = d.get(j, 0) + d[j - 1]\n\t\tif j == m:\n\t\t\tm = m + 1\n\t#print(\"new_d=\", new_d)\n\tfor j in new_d:\n\t\td[j] = new_d[j]\nprint(ans)", "import math\n\ndef nextDiv(a):\n    ret = []\n    i = 1;\n    while (i*i <= a):\n        if (a%i == 0):\n            ret.append(i)\n            j = a//i\n            if (i != j):\n                ret.append(j)\n        i += 1\n    return ret[::-1]\n\ndef solve(n, lis):\n    dp = [0] * (max(lis)+1)\n    dp[0] = 1\n\n    for i in range(n):\n        for j in nextDiv(lis[i]):\n            dp[j] += dp[j-1]\n\n    # print(dp)\n    return (sum(dp)-1) % int(1e9+7)\n\n###########################\n###########################\n\nfrom sys import stdin\ndef intRead():\n    while True:\n        ln = stdin.readline().strip()\n        if not ln:\n            return\n        for i in map(int, ln.split()):\n            yield i\n\ndef __starting_point():\n    ipt = intRead()\n    n = next(ipt)\n    lis = [next(ipt) for _ in range(n)]\n    print(solve(n, lis))\n\n__starting_point()", "import math\n\ndef nextDiv(a):\n    tmp = []\n    sq = int(math.sqrt(a))\n    for i in range(1, sq+1):\n        if (a%i == 0):\n            j = a//i\n            yield j\n            if (i != j):\n                tmp.append(i)\n\n    while tmp:\n        yield tmp.pop()\n\nMOD = int(1e9+7)\n\ndef solve(n, lis):\n    dp = [0] * (max(lis)+1)\n    dp[0] = 1\n\n    for i in lis:\n        for j in nextDiv(i):\n            dp[j] += dp[j-1]\n            # dp[j] = dp[j] % MOD\n\n    return (sum(dp)-1) % MOD\n\n###########################\n###########################\n\nfrom sys import stdin\ndef intRead():\n    while True:\n        ln = stdin.readline().strip()\n        if not ln:\n            return\n        for i in map(int, ln.split()):\n            yield i\n\ndef __starting_point():\n    ipt = intRead()\n    n = next(ipt)\n    lis = [next(ipt) for _ in range(n)]\n    print(solve(n, lis))\n\n__starting_point()", "import math\n\ndef nextDiv(a):\n    tmp = []\n    sq = int(math.sqrt(a))\n    for i in range(1, sq+1):\n        if (a%i == 0):\n            j = a//i\n            yield j\n            if (i != j):\n                tmp.append(i)\n\n    while tmp:\n        yield tmp.pop()\n\nMOD = int(1e9+7)\n\ndef solve(n, lis):\n    dp = [0] * (max(lis)+1)\n    dp[0] = 1\n\n    for i in lis:\n        for j in nextDiv(i):\n            dp[j] += dp[j-1]\n            dp[j] %= MOD\n\n    return (sum(dp)-1) % MOD\n\n###########################\n###########################\n\nfrom sys import stdin\ndef intRead():\n    while True:\n        ln = stdin.readline().strip()\n        if not ln:\n            return\n        for i in map(int, ln.split()):\n            yield i\n\ndef __starting_point():\n    ipt = intRead()\n    n = next(ipt)\n    lis = [next(ipt) for _ in range(n)]\n    print(solve(n, lis))\n\n__starting_point()", "import math\n\ndef nextDiv(a):\n    tmp = set()\n    sq = int(math.sqrt(a))\n    for i in range(1, sq+1):\n        if (a%i == 0):\n            tmp.add(i)\n            tmp.add(a//i)\n\n    return reversed(sorted(tmp))\n\nMOD = int(1e9+7)\n\ndef solve(n, lis):\n    dp = [0] * (max(lis)+1)\n    dp[0] = 1\n\n    for i in lis:\n        for j in nextDiv(i):\n            dp[j] += dp[j-1]\n            dp[j] %= MOD\n\n    return (sum(dp)-1) % MOD\n\n###########################\n###########################\n\nfrom sys import stdin\ndef intRead():\n    while True:\n        ln = stdin.readline().strip()\n        if not ln:\n            return\n        for i in map(int, ln.split()):\n            yield i\n\ndef __starting_point():\n    ipt = intRead()\n    n = next(ipt)\n    lis = [next(ipt) for _ in range(n)]\n    print(solve(n, lis))\n\n__starting_point()", "import math\n\ndef nextDiv(a):\n    ret = []\n    i = 1;\n    while (i*i <= a):\n        if (a%i == 0):\n            ret.append(i)\n            j = a//i\n            if (i != j):\n                ret.append(j)\n        i += 1\n    return ret[::-1]\n\nMOD = int(1e9+7)\n\ndef solve(n, lis):\n    dp = [0] * (max(lis)+1)\n    dp[0] = 1\n\n    for i in lis:\n        for j in nextDiv(i):\n            dp[j] += dp[j-1]\n            dp[j] %= MOD\n\n    return (sum(dp)-1) % MOD\n\n###########################\n###########################\n\nfrom sys import stdin\ndef intRead():\n    while True:\n        ln = stdin.readline().strip()\n        if not ln:\n            return\n        for i in map(int, ln.split()):\n            yield i\n\ndef __starting_point():\n    ipt = intRead()\n    n = next(ipt)\n    lis = [next(ipt) for _ in range(n)]\n    print(solve(n, lis))\n\n__starting_point()", "import math\n\ndef nextDiv(a):\n    ret = []\n    i = 1;\n    while (i*i <= a):\n        if (a%i == 0):\n            ret.append(i)\n            j = a//i\n            if (i != j):\n                ret.append(j)\n        i += 1\n    return reversed(ret)\n\nMOD = int(1e9+7)\n\ndef solve(n, lis):\n    dp = [0] * (max(lis)+1)\n    dp[0] = 1\n\n    for i in lis:\n        for j in nextDiv(i):\n            dp[j] += dp[j-1]\n            dp[j] %= MOD\n\n    return (sum(dp)-1) % MOD\n\n###########################\n###########################\n\nfrom sys import stdin\ndef intRead():\n    while True:\n        ln = stdin.readline().strip()\n        if not ln:\n            return\n        for i in map(int, ln.split()):\n            yield i\n\ndef __starting_point():\n    ipt = intRead()\n    n = next(ipt)\n    lis = [next(ipt) for _ in range(n)]\n    print(solve(n, lis))\n\n__starting_point()", "import math\n\ndef nextDiv(a):\n    ret = []\n    i = 1;\n    while (i*i <= a):\n        if (a%i == 0):\n            ret.append(i)\n            j = a//i\n            if (i != j):\n                ret.append(j)\n        i += 1\n    return ret[::-1]\n\nMOD = int(1e9+7)\nfrom functools import reduce\ndef solve(n, lis):\n    dp = [0] * (max(lis)+1)\n    dp[0] = 1\n\n    for i in lis:\n        for j in nextDiv(i):\n            dp[j] += dp[j-1]\n            dp[j] %= MOD\n\n\n    dp[0]=0\n    return reduce(lambda a,b: (a+b)%MOD, dp)\n\n###########################\n###########################\n\nfrom sys import stdin\ndef intRead():\n    while True:\n        ln = stdin.readline().strip()\n        if not ln:\n            return\n        for i in map(int, ln.split()):\n            yield i\n\ndef __starting_point():\n    ipt = intRead()\n    n = next(ipt)\n    lis = [next(ipt) for _ in range(n)]\n    print(solve(n, lis))\n\n__starting_point()", "import math\n\ndef nextDiv(a):\n    ret = []\n    i = 1;\n    while (i*i <= a):\n        if (a%i == 0):\n            ret.append(i)\n            j = a//i\n            if (i != j):\n                ret.append(j)\n        i += 1\n    return reversed(ret)\n\nMOD = int(1e9+7)\nfrom functools import reduce\ndef solve(n, lis):\n    dp = [0] * (max(lis)+1)\n    dp[0] = 1\n\n    for i in lis:\n        for j in nextDiv(i):\n            dp[j] += dp[j-1]\n            dp[j] %= MOD\n\n\n    dp[0]=0\n    return reduce(lambda a,b: (a+b)%MOD, dp)\n\n###########################\n###########################\n\nfrom sys import stdin\ndef intRead():\n    while True:\n        ln = stdin.readline().strip()\n        if not ln:\n            return\n        for i in map(int, ln.split()):\n            yield i\n\ndef __starting_point():\n    ipt = intRead()\n    n = next(ipt)\n    lis = [next(ipt) for _ in range(n)]\n    print(solve(n, lis))\n\n__starting_point()", "#multiplicity\nn=int(input())\na=[int(x) for x in input().split()]\n\nhell=10**9+7\ndp=[0]*(n+5)\ndp[0]=1\nimport math\nfor i,x in enumerate(a):\n\t\n\tj=1\n\tt_dp={}\n\twhile j<=min(i+1,int(math.sqrt(x))):\n\t\t\n\t\tif(x%j == 0):\n\t\t\tt_dp[j]=(dp[j]+dp[j-1])%hell\n\t\t\tif(x//j != j and x//j <=(i+1)):\n\t\t\t\tt_dp[x//j]=(dp[x//j] + dp[ (x//j) -1])%hell\n\t\t\t\n\t\tj+=1\n\t\n\tfor e in list(t_dp.keys()):\n\t\tdp[e]=t_dp[e]\n\t\n\nans=0\nfor i in dp[1:]:\n    ans =(ans+ i)%hell\nprint(ans%hell)\n\n\n\n", "import math\nn = int(input())\na = list(map(int,input().split()))\ndp = [0]*(n+1)\ndp[0]=1\nmod = int(1e9 +7)\nfor el in a:\n\tsqrt = int(math.sqrt(el))\n\tfor d in range(min(n,sqrt),0,-1):\n\t\tif el%d==0:\n\t\t\tif el/d > sqrt and el/d<=n:\n\t\t\t\tdp[el//d]= (dp[el//d] + dp[el//d-1])%mod\n\t\t\tdp[d]= (dp[d]+dp[d-1])%mod\nres=0\nfor i in range(1,n+1):\n\tres = (res+dp[i])%mod\nprint(res)", "#import numpy as np\nimport bisect\n\ndef main(n,s,mod):\n    ls = len(s)\n    L = [[] for i in range(n+1)]\n    for i,x in enumerate(s):\n        L[x].append(i)\n    for i in range(1,ls+1):\n        for j in range(2*i,n+1,i):\n            L[i] += L[j]\n        L[i].sort()\n    L = L[:ls+1]\n\n    counts = [list(range(ls)),[1 for i in range(ls)]]\n    S = ls\n    for d in range(2,ls+1):\n        if not L[d]: break\n        lcounts = len(counts[0])\n        sumcounts = [0]\n        for i in range(1,lcounts+1):\n            sumcounts.append((sumcounts[i-1] + counts[1][i-1]) % mod)\n        newcounts = [[],[]]\n        for x in L[d]:\n            y = sumcounts[bisect.bisect_left(counts[0],x)]\n            S = (S + y) % mod\n            newcounts[0].append(x), newcounts[1].append(y)\n        counts = newcounts\n    return S\n\nuseless = str(input()).split(' ')\ns = [int(i) for i in input().split(' ')]\nn = 10**6\nmod = 10**9 + 7\n#k = 10**5\n#s = [0]*(2*k)\n#s[0:2*k:2] = list(range(1,k+1))\n#s[1:2*k:2] = list(range(1,k+1))\nprint(main(n,s,mod))\n", "n=int(input())\na=list(map(int,input().split()))\ndp=[0]*(1000001)\ndp[0]=1\nfor i in range(n):\n    x=int(a[i]**.5)\n    for j in range(min(i+1,x),0,-1):\n        if a[i]%j==0:\n            if a[i]/j>x and a[i]/j<=n:\n                dp[a[i]//j]+=dp[a[i]//j-1]\n            dp[j]+=dp[j-1]\nans=0\nfor i in range(1,n+1):\n    ans+=dp[i]\n    ans%=1000000007\nprint(ans)", "#\t!/bin/env python3\n#\tcoding: UTF-8\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology and Management,Gwalior\n\n#\tQuestion Link\n#\thttps://codeforces.com/problemset/problem/1061/C\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef factors(n):\n    curr = []\n    j = 1\n    while j*j <= n:\n        if n % j == 0:\n            curr.append(j)\n            if j != n//j:\n                curr.append(n//j)\n        j += 1\n    curr.sort(reverse=True)\n    return curr\n\n\ndef main():\n    n = int(input())\n    dp = [0 for _ in range(1000005)]\n    arr = get_array()\n    for i in range(n):\n        x = factors(arr[i])\n        for j in range(len(x)):\n            if x[j] == 1:\n                continue\n            dp[x[j]] += dp[x[j]-1]\n            dp[x[j]] %= mod\n        dp[1] += 1\n    ans = 0\n    for i in range(1000005):\n        ans += dp[i]\n    ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#\t!/bin/env python3\n#\tcoding: UTF-8\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology and Management,Gwalior\n\n#\tQuestion Link\n#\thttps://codeforces.com/problemset/problem/1061/C\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef factors(n):\n    curr = []\n    j = 1\n    while j*j <= n:\n        if n % j == 0:\n            curr.append(j)\n            if j != n//j:\n                curr.append(n//j)\n        j += 1\n    curr.sort(reverse=True)\n    return curr\n\n\ndef main():\n    n = int(input())\n    dp = [0 for _ in range(1000005)]\n    dp[0] = 1\n    arr = get_array()\n    for i in range(n):\n        x = factors(arr[i])\n        for j in range(len(x)):\n            dp[x[j]] += dp[x[j]-1]\n            dp[x[j]] %= mod\n\n    ans = 0\n    for i in range(1, n+1):\n        ans += dp[i]\n    ans %= mod\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\na = list(map(int, input().split()))\nN = 1000005\nMOD = 10 ** 9 + 7\ndp =[0] * N\ndp[0] = 0\nfor i in range(n):\n    cur = []\n    A = int(a[i] ** 0.5) + 1\n    for j in range(1, A):\n        if a[i] % j == 0:\n            cur.append(j)\n            if a[i] // j != j:\n                cur.append(a[i] // j)\n\n    cur = sorted(cur, reverse=True)\n    for j in cur:\n        if j == 1:\n            dp[j] += 1\n        else:\n            dp[j] += dp[j - 1]\n\nans = 0\nfor i in dp:\n    ans += i\n    ans %= MOD\nprint(ans)\n", "n=int(input())\na=list(map(int,input().split()))\nseen=[0]*(n+3)\nlong=1\nfor guy in a:\n    if guy**0.5>long-50:\n        for i in range(long+1,1,-1):\n            if guy%i==0:\n                seen[i]+=seen[i-1]\n                if i==long+1:\n                    long+=1\n    else:\n        facs=[]\n        bigfacs=[]\n        for i in range(1,int(guy**0.5)+1):\n            if guy%i==0:\n                facs.append(i)\n                bigfacs.append(guy//i)\n        if facs[-1]==bigfacs[-1]:\n            bigfacs.pop()\n        facs+=bigfacs[::-1]\n        for guy1 in facs[::-1]:\n            if guy1<=long+1:\n                seen[guy1]+=seen[guy1-1]\n                if guy1==long+1:\n                    long+=1          \n    seen[1]+=1\nprint(sum(seen)%1000000007)", "MOD = int(1e9 + 7)\n\nN = int(input())\nA = list(map(int, input().split()))\nways = [0] * (N + 1)\nways[0] = 1\n\nfor a in A:\n    factors = []\n    big_factors = []\n    x = 1\n\n    while x * x <= a:\n        if a % x == 0:\n            factors.append(x)\n\n            if x * x < a:\n                big_factors.append(a // x)\n\n        x += 1\n\n    factors.reverse()\n\n    for x in big_factors:\n        if x <= N:\n            ways[x] += ways[x - 1]\n\n            if ways[x] >= MOD:\n                ways[x] -= MOD\n\n    for x in factors:\n        if x <= N:\n            ways[x] += ways[x - 1]\n\n            if ways[x] >= MOD:\n                ways[x] -= MOD\n\nprint((sum(ways) - 1) % MOD)\n", "import math\nfrom collections import defaultdict\n\nn = int(input())\narr = list(map(int,input().strip().split()))\n\nMOD = 1000000007\n\npre = defaultdict(int)\n\ndef get_divisors(k, upper):\n  div = []\n  for i in range(2, min(upper, int(math.floor(math.sqrt(k)))) + 1):\n    if k % i == 0:\n      div.append(i)\n      if k // i <= upper:\n        div.append(k // i)\n  if k <= upper:\n    div.append(k)\n  return div\n\nfor i in range(n):\n  div = get_divisors(arr[i], i+1)\n  update = {}\n  for d in div:\n    if pre[d-1] == 0:\n      continue\n    update[d] = (pre[d] + pre[d-1]) % MOD\n  pre.update(update)\n  pre[1] += 1\n\nprint(sum(pre.values()) % MOD)", "n = int(input())\nA = [int(i) for i in input().split()]\n\ndef fct(x):\n    ans = []\n    for i in range(1, x+1):\n        if i*i>x:\n            break\n        if x%i==0:\n            ans.append(i)\n            if i*i!=x:\n                ans.append(x//i)\n    return sorted(ans)[::-1]\n\ndp = [0 for i in range(10**6 + 5)]\n\nmod = 10**9 + 7\n\ndp[0] = 1\nfor i in A:\n    do = fct(i)\n    for j in do:\n        dp[j] = (dp[j]+dp[j-1])%mod\n\nc = 0\nfor i in dp:\n    c+=i\n    if c>=mod:\n        c-=mod\n        \nprint((c-1)%mod)\n", "import math\nfrom functools import reduce\nn = int(input())\n \nlis = [int(x) for x in input().split()]\ndic = {0:0,1:0,2:0}\nmax_num = 2\nfor j,i in enumerate(lis):\n    \n    temp_dic = {}\n    lis = set()\n    for k in range(1,math.ceil(math.sqrt(i))+2):\n        if i%k == 0:\n            lis.add(k)\n            if i % i//k ==0:\n                lis.add(i//k)\n    \n    for k in lis:\n        if (k-1) in dic:\n            temp_dic[k]=(temp_dic.get(k,0)+dic.get(k-1)) % 1000000007\n    for k in list(temp_dic.keys()):\n        \n        dic[k]=dic.get(k,0)+temp_dic[k]\n                \n                \n    dic[1]+=1 \nsu = 0\n#print(dic)\nfor i in list(dic.keys()):\n    su += dic[i] % 1000000007\n \nprint(su%1000000007)\n\n", "def getFacts(n):\n    facts = []\n    for i in range(1,int(n**0.5)+1):\n        if n%i == 0:\n            facts.append(i)\n            if i != n//i:\n                facts.append(n//i)\n\n    return facts\n\ndef main():\n    n = int(input())\n    arr = list(map(int,input().split()))\n\n    dp = [0]*(n+1)\n    mod = 10**9+7\n\n    for i in arr:\n        facts = getFacts(i)\n        vals = {}\n        for j in facts:\n            if j <= n:\n                vals[j] = dp[j-1]\n\n        for j in facts:\n            if j <= n:\n                dp[j] += vals[j]\n                dp[j] %= mod\n\n        dp[1] += 1\n\n    #print(dp)\n    total = sum(dp)%mod\n\n    print(total)\n\n\nmain()\n", "from sys import stdin\nfrom collections import deque\nmod = 10**9 + 7\nimport sys\n# sys.setrecursionlimit(10**5)\n# def rl():\n#     return [int(w) for w in stdin.readline().split()]\nfrom bisect import bisect_right\nfrom bisect import bisect_left\nfrom collections import defaultdict\nfrom math import sqrt,factorial,gcd,log2,inf,ceil\n# map(int,input().split())\n# # l = list(map(int,input().split()))\n# from itertools import permutations\nimport heapq\n# input = lambda: sys.stdin.readline().rstrip()\ninput = lambda : sys.stdin.readline().rstrip()\nfrom sys import stdin, stdout\nfrom heapq import heapify, heappush, heappop\n\n\nn = int(input())\n\nl = list(map(int,input().split()))\ndef solve(n):\n\n    for i in range(1,int(sqrt(n))+1):\n        if n%i == 0:\n            hash[n].add(i)\n            hash[n].add(n//i)\n\n    hash[n] = sorted(list(hash[n]))[::-1]\n\nhash = defaultdict(set)\ndp = [0]*(10**6 + 1)\ndp[0] = 1\nfor i in l:\n    if hash[i] == set():\n        solve(i)\n\n        for j in hash[i]:\n            dp[j] = dp[j]%mod + dp[j-1]%mod\n            dp[j]%=mod\n    else:\n        for j in hash[i]:\n            dp[j] = dp[j]%mod + dp[j-1]%mod\n            dp[j]%=mod\n\n# print(dp)\nprint(sum(dp[1:])%mod)\n\n\n\n\n\n"]