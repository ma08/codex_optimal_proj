["# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         # my no6, 56ms, beats 100%\n         if len(intervals)==0:\n             return [newInterval]\n         start = 0; end = 0\n         foundl = foundr = -1\n         for i, n in enumerate(intervals):\n             if foundl==-1 and newInterval.start<=n.end:\n                 foundl = 1\n                 start = i\n                 break\n             else:\n                 continue\n         for i, n in enumerate(intervals[::-1]):\n             if foundr==-1 and newInterval.end>=n.start:\n                 foundr = 1\n                 end = len(intervals)-1-i\n                 break\n             else:\n                 continue\n         print(start, end,foundl,foundr)\n         if foundl==1 and foundr==1:\n             if start<=end:\n                 s = min(intervals[start].start, newInterval.start)\n                 e = max(intervals[end].end, newInterval.end)\n                 return intervals[:start]+[Interval(s,e)]+intervals[end+1:]\n             else:\n                 return intervals[:start]+[newInterval]+intervals[end+1:]\n         elif foundl==1:\n             return [newInterval]+intervals\n         else:\n             return intervals+[newInterval]\n         \n         # others'\n         # s, e = newInterval.start, newInterval.end\n         # left, right = [], []\n         # for i in intervals:\n         #     if i.end < s:\n         #         left += i,\n         #     elif i.start > e:\n         #         right += i,\n         #     else:\n         #         s = min(s, i.start)\n         #         e = max(e, i.end)\n         # return left + [Interval(s, e)] + right\n \n             \n         ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         if intervals == []:\n             return [newInterval]\n         \n         index = 0\n         while index < len(intervals):\n             if newInterval.start < intervals[index].start:\n                 break\n             index += 1\n         del_index = 0\n         insert_index = 0\n         if index == 0:\n             s = newInterval.start\n             e = newInterval.end\n             insert_index = index \n         else:\n             if newInterval.start <= intervals[index - 1].end:\n                 s = intervals[index - 1].start\n                 e = max(intervals[index - 1].end, newInterval.end)\n                 insert_index = index - 1\n                 del_index += 1\n             else:\n                 s = newInterval.start\n                 e = newInterval.end\n                 insert_index = index\n             \n         while index < len(intervals):\n             if intervals[index].start <= e:\n                 e = max(e, intervals[index].end)\n                 del_index += 1\n                 index += 1\n             else:\n                 break\n         i = 0\n         while i < del_index:\n             intervals.pop(insert_index)\n             i += 1\n         intervals.insert(insert_index, Interval(s,e))\n         return intervals\n                     \n                 \n         ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n import operator\n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         #Leetcode \u7b2c56\u9898\u7684\u601d\u8def\n         returnedList = []\n         if(len(intervals) == 0):\n             returnedList.append(newInterval)\n             return returnedList\n \n         p = 1       #\u5224\u65ad\u662f\u5faa\u73af\u7ed3\u675f\u8df3\u51fa\u5faa\u73af\uff0c\u8fd8\u662fnewInterval.end < intervals[i].start\u8df3\u51fa\u5faa\u73af\uff0c\u524d\u8005\u4e0d\u8fdb\u884c\u62fc\u63a5\n         for i in range(len(intervals)):\n             if(intervals[i].end < newInterval.start):\n                 returnedList.append(intervals[i])\n             elif(intervals[i].end == newInterval.start):\n                 newInterval.start = intervals[i].start\n             elif(newInterval.start < intervals[i].end and newInterval.end > intervals[i].start): #\u76f8\u4ea4\n                 newInterval.start = min(newInterval.start, intervals[i].start)\n                 newInterval.end = max(newInterval.end, intervals[i].end)\n             elif(newInterval.end == intervals[i].start):\n                 newInterval.end = intervals[i].end\n             elif(newInterval.end < intervals[i].start):\n                 p = 0\n                 break\n \n \n         returnedList.append(newInterval)\n         if(p == 0):\n             returnedList.extend(intervals[i:])\n         return returnedList", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         \n         ans = []\n         \n         # some boundary conditions\n         if intervals == []:\n             return [newInterval]\n         elif newInterval.end < intervals[0].start:\n             return [newInterval] + intervals\n         elif newInterval.start > intervals[-1].end:\n             return intervals + [newInterval]\n         \n         new_start = newInterval.start\n         new_end = newInterval.end\n         \n         for i in range(0, len(intervals)):\n             if intervals[i].end < new_start: # intertval[i].start <= interval[i].end < new_start\n                 ans.append(intervals[i])\n             elif i and (intervals[i-1].end < new_start) and (new_end < intervals[i].start): # i >= 1\n                 ans.append(newInterval)\n                 for j in range(i, len(intervals)):\n                     ans.append(intervals[j])\n                 return ans\n             else:\n                 merge_start = min(intervals[i].start, new_start)\n                 merge_end = max(intervals[i].end, new_end)\n                 break\n                 \n         #print(\"i:\", i)\n         #print(merge_start, merge_end)\n         \n         notStop = 1\n         for ii in range(i+1, len(intervals)):\n             if intervals[ii].start > merge_end: # merge_start <= merge_end < intervals[ii].start\n                 notStop = 0\n                 break\n         \n         if notStop: # after traversing remaining intervals, merge_intvl overlaps the last (i.e. entire remaining) intervals\n             merge_end = max(intervals[-1].end, merge_end) # or index ii\n             ans.append(Interval(merge_start, merge_end))\n             return ans\n \n         merge_end = max(intervals[ii-1].end, merge_end)\n         #print(\"ii:\", ii)\n         #print(merge_start, merge_end)\n         ans.append(Interval(merge_start, merge_end))\n         \n         \n         for iii in range(ii, len(intervals)):\n             ans.append(intervals[iii])\n         \n         return ans", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         start, end = newInterval.start, newInterval.end\n         left = [i for i in intervals if start > i.end]\n         right = [i for i in intervals if end < i.start]\n         if left + right != intervals:\n             start = min(start, intervals[len(left)].start)\n             end = max(end, intervals[~len(right)].end)\n         return left + [Interval(start, end)] + right\n             \n                 \n             ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         s, e = newInterval.start, newInterval.end\n         left, right = [], []\n         for i in intervals:\n             if i.end < s:\n                 left += i,\n             elif i.start > e:\n                 right += i,\n             else:\n                 s = min(s, i.start)\n                 e = max(e, i.end)\n         return left + [Interval(s, e)] + right", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         start, end = newInterval.start, newInterval.end\n         left, right = [], []\n         for i in intervals:\n             if i.end < start:\n                 left.append(i)\n             elif i.start > end:\n                 right.append(i)\n             else:\n                 start = min(start, i.start)\n                 end = max(end,i.end)\n         return left + [Interval(start, end)] + right", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         left = 0\n         right = len(intervals) - 1\n         tar = newInterval.start\n         while True:\n             if left > right:\n                 break\n             mid = (left + right) // 2\n             value = intervals[mid].start\n             if value == tar:\n                 left = mid\n                 break\n             elif value > tar:\n                 right = mid - 1\n             else:\n                 left = mid + 1\n         intervals.insert(left, newInterval)\n         ret = []\n         tmp = intervals[0]\n         ret.append(tmp)\n         it = iter(intervals)\n         next(it)\n         for i in it:\n             if i.start <= ret[-1].end:\n                 prev = ret.pop()\n                 ret.append(Interval(prev.start, max(i.end, prev.end)))\n             else:\n                 ret.append(i)\n         return ret\n             ", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         if not intervals:\n             return [newInterval]\n         v = []\n         a =newInterval.start\n         b =newInterval.end\n         flag =0\n         s=a\n         e=b\n         for i in intervals:\n             if i.start<=a<=i.end:\n                 s = i.start\n             if i.start<=b<=i.end:\n                 e = i.end\n                 v.append(Interval(s,e))\n                 flag =1\n             if not flag and i.start >b:\n                 v.append(Interval(s,e))\n                 flag =1\n             if i.end<a or i.start>b:\n                 v.append(i)\n         if not flag:\n             v.append(Interval(s,e))\n         return v", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         res = []\n         for interval in intervals:\n             if self.merge(interval, newInterval):\n                 newInterval = Interval(min(interval.start, newInterval.start), max(interval.end, newInterval.end))\n             else:\n                 if newInterval != None and newInterval.end < interval.start:\n                     res.append(newInterval)\n                     newInterval = None\n                 res.append(interval)\n         if newInterval != None:\n             res.append(newInterval)\n         return res\n     \n     def merge(self, a, b):\n         if b is None or a.start > b.end or a.end < b.start:\n             return False\n         return True", "class Solution:\n     def insert(self, intervals, newInterval):\n         start = len(intervals)\n         for i in range(len(intervals)):\n             if newInterval.start<intervals[i].start:\n                 start = min(start, i)\n             if not (newInterval.start > intervals[i].end or newInterval.end < intervals[i].start):\n                 newInterval = Interval(min(newInterval.start, intervals[i].start), max(newInterval.end, intervals[i].end))\n                 start, intervals[i] = min(i,start), []\n         intervals = [ele for ele in intervals if ele!=[]]\n         intervals.insert(start,newInterval)\n         return intervals", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         intervals.append(newInterval)\n         if len(intervals) <= 1:\n           return intervals\n         \n         intervals.sort(key=lambda x:x.start)\n         \n         i = 0\n         while i < len(intervals) - 1:\n           left = intervals[i]\n           right = intervals[i+1]\n           if left.end >= right.start:\n             intervals[i] = Interval(s=left.start, e=max(left.end, right.end))\n             del intervals[i+1]\n           else:\n             i += 1\n         \n         return intervals", "# Definition for an interval.\n # class Interval:\n #     def __init__(self, s=0, e=0):\n #         self.start = s\n #         self.end = e\n \n class Solution:\n     def insert(self, intervals, newInterval):\n         \"\"\"\n         :type intervals: List[Interval]\n         :type newInterval: Interval\n         :rtype: List[Interval]\n         \"\"\"\n         result = []\n         for interval in intervals:\n             if newInterval and newInterval.end >= interval.start and newInterval.start <= interval.end:\n                 newInterval.start = min(interval.start, newInterval.start)\n                 newInterval.end = max(interval.end, newInterval.end)\n             else:\n                 if newInterval and newInterval.end < interval.start:\n                     result.append(newInterval)\n                     result.append(interval)\n                     newInterval = None\n                 else:\n                     result.append(interval)\n         if newInterval:\n             result.append(newInterval)\n         return result"]