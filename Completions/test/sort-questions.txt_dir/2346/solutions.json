["n = int(input())\nparent = [-1]*n\nisresp = [1]*n\nfor i in range(n):\n\tp, r = list(map(int, input().split()))\n\tp -= 1\n\tif r == 0:\n\t\tisresp[i] = 0\n\t\tif p>=0:\n\t\t\tisresp[p] = 0\nnore = []\nfor i in range(n):\n\tif isresp[i] == 1:\n\t\tnore.append(i+1)\nif not nore:\n\tprint(-1)\nelse:\n\tprint(\" \".join(map(str, nore)))\n", "n = int(input())\n\ntree  = [[] for _ in range(n)]\ninf = [0] * n\n\nfor i in range(n):\n    ind, f = map(int, input().split())\n    inf[i] = f\n    if ind != -1:\n        tree[ind - 1].append(i)\n\nflag = False\n\nfor i in range(n):\n    if inf[i] == 1:\n        for x in tree[i]:\n            if inf[x] != 1:\n                break\n        else:\n            flag = True\n            print(i + 1, end=' ')\n\nif not flag:\n    print(-1)", "import sys\n\nn = int(sys.stdin.readline().strip())\nR = [0] * n\n\nfor i in range (0, n):\n    line = sys.stdin.readline().strip().split()\n    p = int(line[0])\n    c = int(line[1])\n    if c == 0:\n        R[i] = 1\n        if p != -1:\n            R[p - 1] = 1\n\nans = [0] * (n - sum(R))\nj = 0\nfor i in range (0, n):\n    if R[i] == 0:\n        ans[j] = str(i + 1)\n        j = j + 1\nans = \" \".join(ans)\n\nif ans == \"\":\n    print(-1)\nelse:\n    print(ans)", "a=int(input())\nA = [0]*(a+2)\nB = [0]*a\nfor i in range(a):\n    q,w = map(int,input().split())\n    A[i]+=1\n    A[q-1]+=1\n    if w == 1:\n        B[q-1]+=1\n        B[i]+=1\nC = []\nfor i in range(a):\n    if A[i] == B[i]:\n        C.append(i+1)\nif len(C)==0:\n    print(-1)\nelse:\n    print(*C)", "n = int(input())\nlis = []\nfor _ in range(n):\n    lis.append(list(map(int, input().split())))\n    \nx = list([0]*n)\np = list([0]*n)\n\nres = []\nfor i in lis:\n    if i[0] != -1:\n        p[i[0]-1] += (i[-1])\n        x[i[0]-1] += 1    \nfor i in range(n):\n    if lis[i][-1] == 1:\n        if x[i] == p[i]:\n            res.append(i+1)\n\nif len(res) == 0:\n    print(-1)\nelse:\n    print(\" \".join(map(str, sorted(res))))\n", "from collections import defaultdict\n\n\nn = int(input())\ng = defaultdict(list)\ncs = [None] * n\n\nfor v, _ in enumerate(range(n)):\n    p, c = map(int, input().split())\n    if p != -1:\n        g[p - 1].append(v)\n    cs[v] = c\n\nr = []\nused = [False] * n\n\ndef dfs(g, stack):\n    nonlocal r, used\n    while stack:\n        v = stack.pop()\n        used[v] = True\n\n        flag = True if cs[v] == 1 else False\n        for u in g[v]:\n            if not used[u]:\n                stack.append(u)\n            if cs[u] == 0:\n                flag = False\n\n        if flag:\n            r.append(v)\n\n\nfor v in range(n):\n    if not used[v]:\n        dfs(g, [v])\n\nif r:\n    for el in sorted(r):\n        print(el + 1, end=\" \")\nelse:\n    print(-1)\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nEDGE=[list(map(int,input().split())) for i in range(n)]\n\nCHILDLIST=[[] for i in range(n+1)]\n\n\nfor i in range(n):\n    if EDGE[i][0]==-1:\n        continue\n    CHILDLIST[EDGE[i][0]].append(i+1)\n\nANS=[]\n\nfor i in range(1,n+1):\n    if EDGE[i-1][1]==1:\n\n        \n        for chi in CHILDLIST[i]:\n            if EDGE[chi-1][1]==0:\n                break\n\n        else:\n            ANS.append(i)\n\nANS.sort()\nif ANS==[]:\n    print(-1)\nprint(*ANS)\n", "import sys\nN = int(input())\nEr = set(range(1, N+1))\nfor i in range(1, N + 1):\n    p, c = map(int, sys.stdin.readline().split())\n    if c == 0:\n        if i in Er:\n            Er.remove(i)\n        if p in Er:\n            Er.remove(p)\nEr = list(Er)\nif not Er:\n    print(-1)\nelse:\n    Er.sort()\n    print(*Er)", "from collections import defaultdict as dd\nimport math\nimport heapq\ndef nn():\n\treturn int(input())\n\ndef li():\n\treturn list(input())\n\ndef mi():\n\treturn list(map(int, input().split()))\n\ndef lm():\n\treturn list(map(int, input().split()))\n\nn=nn()\n\n\nparentlist=[]\n\n\nfor i in range(n):\n\tparentlist.append(lm())\n\n\n\n\nchildlist=dd(list)\n\nfor i in range(1,n+1):\n\tchildlist[i]=[]\n\n\n\nfor vertex, pair in enumerate(parentlist):\n\t#print(vertex,pair)\n\t#print(childlist)\n\tparent=pair[0]\n\t#print(parent)\n\tif not parent==-1:\n\t\t#print(childlist[parent])\n\t\t(childlist[parent]).append((vertex+1,pair[1]))\n\nblist=[]\n\nfor vertex in childlist:\n\tif childlist[vertex]==[] or all([child[1]==1 for child in childlist[vertex]]):\n\t\tif parentlist[vertex-1][1]==1:\n\t\t\tblist.append(vertex)\n\ndeleted=sorted(blist)\n\n\nif len(deleted)==0:\n\tprint(-1)\n\nelse:\n\tprint(*deleted)\n\t\n\n\n\n\n\n\n\n\n", "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n\n\"\"\"\n549 C\n\"\"\"\n\nn = int(input())\nd = [1 for i in range(n+1)]\n\nfor i in range(1, n+1):\n    pi, ci = list(map(int, input().split()))\n    if ci == 0:\n        d[i] = 0\n        if pi != -1:\n            d[pi] = 0\n\ne = []\nfor i in range(1, n+1):\n    if d[i] == 1:\n        e.append(i)\n\nif len(e) == 0:\n    print(-1)\n    quit()\nelse:\n    print(\" \".join(map(str, e)))\n", "n = int(input().strip())\n\nparent = [None for i in range(n+1)]\nchildren = [[] for i in range(n+1)]\ncs = [None for i in range(n+1)]\n\nfor i in range(1, n+1):\n\tp, c = list(map(int, input().split()))\n\tparent[i] = p\n\tif p != -1:\n\t\tchildren[p].append(i)\n\tcs[i] = c\n\n# print(parent)\n# print(children)\n# print(cs)\n\nto_delete = []\nfor i in range(1, n+1):\n\tif parent[i] > 0 and cs[i] == 1 and sum([cs[item] for item in children[i]]) == len(children[i]):\n\t\tto_delete.append(i)\n\nif len(to_delete) > 0:\n\tprint(' '.join([str(item) for item in to_delete]))\nelse:\n\tprint(-1)\n", "3\n\ndef ir(): return int(input())\ndef ia(): return [int(i) for i in input().split()]\n\nn = ir()\n\np = [None] * n\nc = [None] * n\nadj =  [ [ ] for i in range(n) ]\n\ngood = [False] * n\n\nfor i in range(n):\n\tp0, c0 = ia()\n\tc[i] = c0\n\tif p0 == -1:\n\t\tp[i] = p0\n\t\tgood[i] = True\n\telse:\n\t\tp0 -= 1\n\t\tp[i] = p0\n\t\tadj[p0].append(i)\n\t\tif c0 == 0:\n\t\t\tgood[i] = True\n\t\t\tgood[p0] = True\n\nans = [ ]\nfor i, e in enumerate(good):\n\tif not e:\n\t\tans.append(i)\n\nans.sort()\n\nif ans == []:\n\tprint(-1)\nelse:\n\tans = [str(e + 1) for e in ans]\n\tprint( \" \".join(ans) )", "n = int(input())\nmass = [0 for i in range(n + 10)]\narr = [0 for i in range(n + 10)]\nnnn = [0 for i in range(n + 10)]\nfor i in range(n):\n    a, b = map(int, input().split())\n    if a != -1:\n        mass[a] += 1\n        arr[a] += b\n    nnn[i + 1] = b\nans = []\nfor i in range(n):\n    if mass[i + 1] == arr[i + 1] and nnn[i + 1] == 1:\n        ans.append(i + 1)\nif len(ans) == 0:\n    ans.append(-1)\nfor i in ans:\n    print(i, end = ' ')", "'''input\n5\n-1 0\n1 1\n1 1\n2 0\n3 0\n'''\nfrom sys import stdin, stdout\nimport sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(15000)\n\n\ndef bfs(graph, parent, n):\n\tmyq = deque()\n\tmyq.append([parent, 0])\n\tans = []\n\twhile len(myq) != 0:\n\t\tnode = myq.popleft()\n\t\tflag = 0\n\t\tfor i in graph[node[0]]:\n\t\t\tmyq.append(i)\n\t\t\tif i[1] == 1:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tflag = 1\n\t\tif flag == 0 and node[1] == 1:\n\t\t\tans.append(node[0])\n\treturn ans\n\n# main starts\nn  = int(stdin.readline().strip())\ngraph = defaultdict(list)\nparent = -1\nfor i in range(1, n + 1):\n\tnode, key = list(map(int, stdin.readline().split()))\n\tif node == -1:\n\t\tparent = i\n\t\tcontinue\t\t\n\tgraph[node].append([i, key])\n#print(graph)\nans = bfs(graph, parent, n)\nans.sort()\nif len(ans) > 0:\n\tprint(*ans)\nelse:\n\tprint(-1)", "class node:\n    def __init__(self, value, parent, respect):\n        self.value = value\n        self.children = []\n        self.parent = parent\n        self.respect = respect\n\nall_nodes = {}\nroot = -1\n\nnot_respectors = []\n\nimport sys\n\nn = int(sys.stdin.readline())\nfor i in range(n):\n    line = sys.stdin.readline()[:-1]\n    node_parent, node_res = line.split(\" \")\n    if i+1 in all_nodes:\n        all_nodes[i+1].parent = int(node_parent)\n        all_nodes[i+1].respect = int(node_res)\n    else:\n        all_nodes[i+1] = node(i+1, int(node_parent), int(node_res))\n\n    if int(node_parent) == -1:\n        root = all_nodes[i+1]\n    else:\n        int_node_parent = int(node_parent)\n        if int_node_parent not in all_nodes:\n            all_nodes[int_node_parent] = node(int_node_parent, -1, -1)\n        all_nodes[int_node_parent].children.append(all_nodes[i+1])\n\n    if int(node_res) == 1:\n        not_respectors.append(all_nodes[i+1])\n\ndef get_val(n):\n    return n.value\n\n\nnot_respecters = sorted(not_respectors, key=get_val)\ntot = []\nfor n in not_respectors:\n    b = True\n    for c in n.children:\n        if c.respect == 0:\n            b = False\n            break\n    if b:\n        tot.append(n)\n\n\nif len(tot) == 0:\n    print(\"-1\")\nelse:\n    print(\" \".join(map(str, list(map(get_val, tot)))))\n", "n = int(input())\np = [0]\nc = [0]\na = []\nm = dict()\nfor i in range(n+1):\n\tm[i] = []\nfor i in range(n):\n\tx,y = list(map(int,input().split()))\n\tp.append(x)\n\tc.append(y)\n\tif x!=-1:\n\t\tm[x].append(i+1)\nfor i in range(1,n+1):\n\tif c[i]==1:\n\t\tif len(m[i])==0:\n\t\t\ta.append(i)\n\t\telse:\n\t\t\tfor j in m[i]:\n\t\t\t\tif c[j]==0:\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ta.append(i)\n\nif len(a)==0:\n\tprint(-1)\nelse:\n\tprint(*sorted(a))\n", "def bs (arr, l, r, x): \n  \n    # Check base case \n    if r >= l: \n  \n        mid = l + (r - l)//2\n  \n        # If element is present at the middle itself \n        if arr[mid] == x: \n            return 1 \n          \n        # If element is smaller than mid, then it can only \n        # be present in left subarray \n        elif arr[mid] > x: \n            return bs(arr, l, mid-1, x) \n  \n        # Else the element can only be present in right subarray \n        else: \n            return bs(arr, mid+1, r, x) \n  \n    else: \n        # Element is not present in the array \n        return 0\n\nn=int(input())\nnrp=[]\nrc=[]\nfor i in range(n):\n    p,c=map(int,input().split())\n    if c:nrp.append(i+1)\n    if not c:rc.append(p)\ns=[]\nrc.sort()\nfor i in nrp:\n    if not bs(rc,0,len(rc)-1,i):s.append(i)\nif not s:print(\"-1\")\nelse:print(*sorted(s))", "n = int(input())\nparent_respect = [0] * (n + 1)\ngraph = [[] for i in range(n + 1)]\nroot = None\nfor i in range(1, n + 1):\n    p, r = [int(j) for j in input().split()]\n    if p == -1:\n        root = i\n        continue\n    graph[p].append(i)\n    parent_respect[i] = r\n\n# print(graph)\nresult = []\n\nfor i in range(1, n + 1):\n    if parent_respect[i] == 1:\n        all_c_r = False\n        for c in graph[i]:\n            if parent_respect[c] == 0:\n                all_c_r = True\n\n        if not all_c_r:\n            result.append(i)\n\nif result:\n    for i in result:\n        print(i, end=' ')\nelse:\n    print(-1)\n", "v = int(input())\n\nneed_check = {}\ntree = {}\n\nkids = {}\n\ncount = 1\nwhile count <= v:\n    parent, to_check = list(map(int, input().split()))\n    node = count\n\n    tree[node] = parent\n\n    if to_check:\n        need_check[node] = 1\n\n    if parent not in kids:\n        kids[parent] = []\n\n    kids[parent].append(node)\n\n    count += 1\n\ndeletion = []\nfor node in sorted(need_check.keys()):\n    # determine if we'll delete him\n    if node in kids and kids[node]:\n        to_delete = True\n\n        for kid in kids[node]:\n            if kid not in need_check:\n                to_delete = False\n                break\n\n        if not to_delete:\n            continue\n\n        next_parent = tree[node]\n        for kid in kids[node]:\n            tree[kid] = next_parent\n\n        del kids[node]\n    deletion.append(node)\n\nif not deletion:\n    print('-1')\nelse:\n    print(' '.join(map(str, deletion)))\n", "import sys\nsys.setrecursionlimit(2000)\nfrom collections import Counter\nfrom functools import reduce\n# sys.stdin.readline()\nfrom copy import deepcopy\n\n\ndef __starting_point():\n\n    # single variables\n    n = [int(val) for val in sys.stdin.readline().split()][0]\n\n    # On each step you select such a non-root vertex that it does not \n    # respect its parent and none of its children respects it\n\n    tree = {i+1 : [[], []] for i in range(n)}\n    for i in range(n):\n        p, c = [int(val) for val in sys.stdin.readline().split()]\n            \n        tree[i+1][0].append((p, c))\n        if(p != -1):\n            tree[p][1].append((i, c))\n\n    d = []\n    for i in range(1, n+1):\n        p, c = tree[i]\n        if(p[0][1] == 1 and sum([x[1] for x in c]) == len(c)):\n            d.append(i)\n\n   \n    if(len(d) == 0):\n        print(-1)\n    else: \n        for val in d:\n            print(val, end=' ')\n        print('')\n\n\n\n\n__starting_point()", "n = int(input())\n\nrespectingChildren = [0 for i in range(n)]\ntotalChildren = [0 for i in range(n)]\nCi = []\nPi = []\nroot = 0\n\nfor i in range(n):\n    pi, ci = list(map(int, input().split()))\n    Ci.append(ci)\n    if pi==-1:\n        Pi.append(pi)\n        root = i\n        continue\n\n    Pi.append(pi-1)\n    totalChildren[pi-1] += 1\n    if ci==0:\n        respectingChildren[pi-1] += 1\n\nans = []\nfor i in range(n):\n    if i==root:\n        continue\n\n    if Ci[i]==1:\n        if respectingChildren[i]==0:\n            ans.append(i+1)\n            parentOfI = Pi[i]\n            totalChildren[parentOfI] += totalChildren[i]\n\nif ans==[]:\n    print(-1)\nelse:\n    print(*ans)\n        \n    \n"]