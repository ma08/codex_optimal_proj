["# cook your dish here\nfrom sys import stdin, stdout\nimport math\n# from itertools import permutations, combinations\nfrom collections import defaultdict,deque\n# import bisect\n# import heapq as hq\n\ndef bfs(d,n,d1,s):\n high=[-1 for x in range(n+1)]\n q=deque([0])\n high[0]=0\n while q:\n  node=q.popleft()\n  for x in d1[int(s[node])]:\n   if high[x]==-1:\n    high[x]=high[node]+1\n    q.append(x)\n  for x in d[node]:\n   if high[x]==-1:\n    high[x]=high[node]+1\n    q.append(x)\n print(high[n])\ndef main():\n try:\n  s=stdin.readline().strip()\n  n=len(s)\n  d=defaultdict(list)\n  \n  for i in range(1,len(s)):\n   d[int(s[i])].append(i)\n\n  high=[0]*(n+1)\n  visit=[False] *(n+1)\n  q=deque([0])\n  while q:\n   node=q.popleft()\n   if node==n-1:\n    break\n   for x in d[int(s[node])]:\n    if visit[x]==False:\n     visit[x]=True\n     q.append(x)\n     high[x]=high[node]+1\n   d[int(s[node])].clear()\n   if node-1>=0 and not visit[node-1]:\n    visit[node-1]=True\n    q.append(node-1)\n    high[node-1]=high[node]+1\n   if node+1<n and not visit[node+1]:\n    visit[node+1]=True\n    q.append(node+1)\n    high[node+1]=high[node]+1\n  print(high[n-1])\n except:\n  pass\n \ndef add(a, b, c):\n res = a + b;\n if (res >= c):return res - c;\n else:return res;\ndef mod(a, b, c):\n res = a * b\n if (res >= c):return res % c\n else:return res\ndef gcd(a, b):\n while b:\n  a, b = b, a % b\n return a\ndef lcm(a, b):\n w = a // gcd(a, b)\n return w * b\ndef expo(a, b):\n x, y = 1, a\n while (b > 0):\n  if (b & 1):\n   x = x * y\n  y = y * y\n  b >>= 1\n return x\ndef power(a, b, m):\n x, y = 1,\n while (b > 0):\n  if (b & 1):x = mod(x, y, m)\n  y = mod(y, y, m)\n  b >>= 1\n return x\ndef L():\n return list(map(int, stdin.readline().split()))\ndef In():\n return list(map(int, stdin.readline().split()))\ndef I():\n return int(stdin.readline())\nP = 1000000007\n\ndef __starting_point():\n main()\n\n\n\n__starting_point()", "from collections import defaultdict\nfrom collections import deque\n\ng=defaultdict(lambda :[])\n\ns=input().strip()\nls=len(s)\n\nvis=[False for i in range(ls)]\ndis=[0 for i in range(ls)]\n\nfor i in range(1, ls):\n g[s[i]].append(i)\n\n\nque=deque()\n\nque.append(0)\nvis[0]=True\n\nwhile que:\n indx=que.popleft()\n\n if indx==ls-1:\n  break\n\n temp=s[indx]\n\n for i in g[temp]:\n  if not vis[i]:\n   vis[i]=True \n   que.append(i)\n   dis[i]=dis[indx]+1 \n\n g[temp].clear()\n \n if indx-1>=0 and not vis[indx-1]:\n  vis[indx-1]=True\n  que.append(indx-1)\n  dis[indx-1]=dis[indx]+1 \n\n if indx+1<ls and not vis[indx+1]:\n  vis[indx+1]=True\n  que.append(indx+1)\n  dis[indx+1]=dis[indx]+1 \n\n\nprint(dis[-1])", "from collections import defaultdict\na=input().strip()\nn=len(a)\ng=defaultdict(list)\nfor i in range(n):\n g[a[i]].append(i)\nvis={}\nvis[0]=0\nq=[0]\nwhile len(q)!=0:\n tmp=q.pop(0)\n if tmp==n-1:\n  break \n val=a[tmp]\n s=len(g[val])\n for i in range(s):\n  if g[val][i] not in vis:\n   vis[g[val][i]]=vis[tmp]+1 \n   q.append(g[val][i])\n g[val]=[]\n if tmp+1<=n-1 and tmp+1 not in vis:\n  q.append(tmp+1)\n  vis[tmp+1]=vis[tmp]+1 \n if tmp-1>=0 and tmp-1 not in vis:\n  q.append(tmp-1)\n  vis[tmp-1]=vis[tmp]+1\nprint(vis[n-1])\n \n   \n", "from collections import defaultdict,deque\ntext=input().strip()\nv=len(text)\ng=defaultdict(list)\nstore=defaultdict(list)\nfor i in range(1,v):\n temp=ord(text[i])\n store[temp].append(i) \nque=[0]\ndist=[0]*v\nvis=[False]*v\nvis[0]=True\nwhile(len(que)):\n index=que.pop(0)\n if index==v-1:\n  break\n temp=ord(text[index])\n for i in store[temp]:\n  if not vis[i]:\n   vis[i]=True\n   que.append(i)\n   dist[i]=dist[index]+1\n del store[temp]\n left=index-1\n right=index+1\n if left>=0 and not vis[left]:\n  vis[left]=True\n  que.append(left)\n  dist[left]=dist[index]+1\n if right<v and not vis[right]:\n  vis[right]=True\n  que.append(right)\n  dist[right]=dist[index]+1\nprint(dist[v-1])", "from collections import defaultdict\nfrom collections import deque\n\ng=defaultdict(lambda :[])\n\ns=input().strip()\nls=len(s)\n\nvis=[False for i in range(ls)]\ndis=[0 for i in range(ls)]\n\nfor i in range(1, ls):\n g[s[i]].append(i)\n\n\nque=deque()\n\nque.append(0)\nvis[0]=True\n\nwhile que:\n indx=que.popleft()\n\n if indx==ls-1:\n  break\n\n temp=s[indx]\n\n for i in g[temp]:\n  if not vis[i]:\n   vis[i]=True \n   que.append(i)\n   dis[i]=dis[indx]+1 \n\n g[temp].clear()\n \n if indx-1>=0 and not vis[indx-1]:\n  vis[indx-1]=True\n  que.append(indx-1)\n  dis[indx-1]=dis[indx]+1 \n\n if indx+1<ls and not vis[indx+1]:\n  vis[indx+1]=True\n  que.append(indx+1)\n  dis[indx+1]=dis[indx]+1 \n\n\nprint(dis[-1])", "from collections import defaultdict\nfrom collections import deque\n\ns = input().strip()\nn = len(s)\ndist = [0]*(n)\nvisited = [False]*n\nd = defaultdict(list)\nfor i in range(n):\n d[s[i]].append(i)\nvisited[0] = True\nstk = deque()\nstk.append(0)\nwhile stk:\n node = stk.popleft()\n if node == n-1:\n  break\n for i in d[s[node]]:\n  if not visited[i] and i != node:\n   dist[i] = dist[node]+1\n   visited[i] = True\n   stk.append(i)\n d[s[node]] = []\n if node > 0 and not visited[node-1]:\n  stk.append(node-1)\n  visited[node-1] = True\n  dist[node-1] = dist[node]+1\n if node < n-1 and not visited[node+1]:\n  stk.append(node+1)\n  visited[node+1] = True\n  dist[node+1] = dist[node]+1\n# print(d)\n# print(dist)\nprint(dist[-1])\n", "from collections import defaultdict\na=input().strip()\nn=len(a)\ng=defaultdict(list)\nfor i in range(n):\n g[a[i]].append(i)\nvis={}\nvis[0]=0\nq=[0]\nwhile len(q)!=0:\n tmp=q.pop(0)\n if tmp==n-1:\n  break \n val=a[tmp]\n s=len(g[val])\n for i in range(s):\n  if g[val][i] not in vis:\n   vis[g[val][i]]=vis[tmp]+1 \n   q.append(g[val][i])\n g[val]=[]\n if tmp+1<=n-1 and tmp+1 not in vis:\n  q.append(tmp+1)\n  vis[tmp+1]=vis[tmp]+1 \n if tmp-1>=0 and tmp-1 not in vis:\n  q.append(tmp-1)\n  vis[tmp-1]=vis[tmp]+1\nprint(vis[n-1])\n \n   \n", "from sys import stdin, stdout\n\nS = [int(z) for z in stdin.readline().strip()]\nn = len(S)\ngraph = {}\nd = {}\nvisited = {}\nfor i in range(n):\n graph[S[i]] = []\n visited[i] = 0\n d[i] = 0\nif n>1:\n for i in range(n):\n  graph[S[i]].append(i)\n queue = [0]\n\n while len(queue) != 0:\n  u = queue.pop(0)\n  for v in graph[S[u]]:\n   if visited[v] == 0 and v!=u:\n    d[v] = d[u] + 1\n    queue.append(v)\n    visited[v] = 1\n  graph[S[u]] = []\n  if u-1>=0:\n   if visited[u-1] == 0:\n    d[u-1] = d[u] + 1\n    visited[u-1] = 1\n    queue.append(u-1)\n  if u+1<n:\n   if visited[u+1] == 0:\n    d[u+1] = d[u] + 1\n    visited[u+1] = 1\n    queue.append(u+1)\n\n  visited[u] = 1\n stdout.write(\"%d\\n\"%d[n-1])\nelse:\n stdout.write(\"0\\n\")", "from sys import stdin, stdout\n\nS = [int(z) for z in stdin.readline().strip()]\nn = len(S)\ngraph = {}\nd = {}\nvisited = {}\nfor i in range(n):\n graph[S[i]] = []\n visited[i] = 0\n d[i] = 0\nif n>1:\n for i in range(n):\n  graph[S[i]].append(i)\n queue = [0]\n\n while len(queue) != 0:\n  u = queue.pop(0)\n  for v in graph[S[u]]:\n   if visited[v] == 0 and v!=u:\n    d[v] += d[u] + 1\n    queue.append(v)\n    visited[v] = 1\n  graph[S[u]] = []\n  if u-1>=0:\n   if visited[u-1] == 0:\n    d[u-1] = d[u] + 1\n    visited[u-1] = 1\n    queue.append(u-1)\n  if u+1<n:\n   if visited[u+1] == 0:\n    d[u+1] = d[u] + 1\n    visited[u+1] = 1\n    queue.append(u+1)\n\n  visited[u] = 1\n stdout.write(\"%d\\n\"%d[n-1])\nelse:\n stdout.write(\"0\\n\")", "from collections import defaultdict\n\ndef solve():\n\n a = input().strip()\n n = len(a)\n #print(n)\n g = defaultdict(list)\n for i in range(n):\n  g[a[i]].append(i)\n vis = {}\n vis[0] = 0\n q = [0]\n # print(g)\n while len(q)!=0:\n  tmp = q.pop(0)\n  if tmp==n-1:\n   break\n  val = a[tmp]\n  x = len(g[val])\n  for i in range(x):\n   if g[val][i] not in vis:\n    q.append(g[val][i])\n    vis[g[val][i]] = vis[tmp]+1\n  g[val] = []\n  if tmp+1<=n-1 and tmp+1 not in vis:\n   q.append(tmp+1)\n   vis[tmp+1] = vis[tmp]+1\n  if tmp-1>=0 and tmp-1 not in vis:\n   q.append(tmp-1)\n   vis[tmp-1] = vis[tmp]+1\n print(vis[n-1])\n\n\ndef __starting_point():\n solve()\n__starting_point()", "from collections import defaultdict,deque\ntext=input().strip()\nv=len(text)\ng=defaultdict(list)\nstore=defaultdict(list)\nfor i in range(1,v):\n temp=ord(text[i])\n store[temp].append(i) \nque=deque([0])\ndist=[0]*v\nvis=[False]*v\nvis[0]=True\nwhile(len(que)):\n index=que.popleft()\n if index==v-1:\n  break\n temp=ord(text[index])\n for i in store[temp]:\n  if not vis[i]:\n   vis[i]=True\n   que.append(i)\n   dist[i]=dist[index]+1\n del store[temp]\n left=index-1\n right=index+1\n if left>=0 and not vis[left]:\n  vis[left]=True\n  que.append(left)\n  dist[left]=dist[index]+1\n if right<v and not vis[right]:\n  vis[right]=True\n  que.append(right)\n  dist[right]=dist[index]+1\nprint(dist[v-1])", "from collections import defaultdict,deque\ntext=input().strip()\nv=len(text)\ng=defaultdict(list)\nstore=defaultdict(list)\nfor i in range(1,v):\n temp=ord(text[i])\n store[temp].append(i) \nque=[0]\ndist=[0]*v\nvis=[False]*v\nvis[0]=True\nwhile(len(que)):\n index=que.pop(0)\n if index==v-1:\n  break\n temp=ord(text[index])\n for i in store[temp]:\n  if not vis[i]:\n   vis[i]=True\n   que.append(i)\n   dist[i]=dist[index]+1\n del store[temp]\n left=index-1\n right=index+1\n if left>=0 and not vis[left]:\n  vis[left]=True\n  que.append(left)\n  dist[left]=dist[index]+1\n if right<v and not vis[right]:\n  vis[right]=True\n  que.append(right)\n  dist[right]=dist[index]+1\nprint(dist[v-1])", "# cook your dish here\nfrom collections import defaultdict,deque\ntext=input().strip()\nv=len(text)\ng=defaultdict(list)\nstore=defaultdict(list)\nfor i in range(1,v):\n temp=ord(text[i])-48\n store[temp].append(i) \nque=[0]\ndist=[0]*v\nvis=[False]*v\nvis[0]=True\nwhile(len(que)):\n index=que.pop(0)\n if index==v-1:\n  break\n temp=ord(text[index])-48\n for i in store[temp]:\n  if not vis[i]:\n   vis[i]=True\n   que.append(i)\n   dist[i]=dist[index]+1\n del store[temp]\n left=index-1\n right=index+1\n if left>=0 and not vis[left]:\n  vis[left]=True\n  que.append(left)\n  dist[left]=dist[index]+1\n if right<v and not vis[right]:\n  vis[right]=True\n  que.append(right)\n  dist[right]=dist[index]+1\nprint(dist[v-1])", "from collections import defaultdict as dd\ns = input().strip()\nn = len(s)\nvis = [ False for i in range(n)]\nd = [ False for i in range(n)]\nV = dd(list)\nfor i in range(1,n):\n val = ord(s[i])-48\n V[val].append(i)\nd[0] = 0\nvis[0] = True\nQ = []\nQ.append(0)\nwhile(len(Q)):\n idx = Q[0]\n if(idx == n-1):\n  break\n Q.pop(0)\n val = ord(s[idx])-48\n vsz = len(V[val])\n for j in range(vsz):\n  nidx = V[val][j]\n  if not (vis[nidx]):\n   vis[nidx] = True\n   Q.append(nidx)\n   d[nidx] = d[idx]+1\n V[val].clear()\n if(idx-1 >=0 and not vis[idx-1]):\n  vis[idx-1] = True\n  Q.append(idx-1)\n  d[idx-1] = d[idx] + 1\n if(idx+1<n and not vis[idx+1]):\n  vis[idx+1] = True\n  Q.append(idx+1)\n  d[idx+1] = d[idx] + 1\nprint(d[n-1])\n", "from collections import defaultdict\nclass Graph:\n def __init__(self,v):\n  self.adj=defaultdict(list)\n  self.V = v\n def findstep(self,s):\n  visit = [0]*(self.V)\n  dist =[0]*self.V\n  q = []\n  q.append(0)\n  while q:\n   t = q.pop(0)\n   visit[t] =1\n   for i in self.adj[s[t]]:\n    if visit[i] == 0 and i != t:\n      q.append(i)\n      visit[i] = 1\n      dist[i] = dist[t] + 1\n   self.adj[s[t]] = []\n   if t > 0 and visit[t-1] == 0:\n    q.append(t-1)\n    visit[t-1]= 1\n    dist[t-1] = dist[t] + 1\n   if t < self.V -1 and visit[t+1] == 0:\n    q.append(t+1)\n    visit[t+1]= 1\n    dist[t+1] = dist[t] + 1\n  return dist[-1]\ns = list(map(int, input().strip()))\nn = len(s)\ng = Graph(n)\nfor i in range(n):\n g.adj[s[i]].append(i)\nprint(g.findstep(s))\n\n\n", "from queue import Queue\nS = list(map(int, input().strip()))\nN = len(S)\ngraph = {}\nfor i in range(N):\n graph[S[i]] = []\nif N > 1:\n for i in range(N):\n  graph[S[i]].append(i)\n visited = [0] * N\n distance = [0] * N\n Q = Queue()\n Q.put(0)\n while (not Q.empty()):\n  t = Q.get()\n  for i in graph[S[t]]:\n   if visited[i] == 0 and i != t:\n    Q.put(i)\n    visited[i] = 1\n    distance[i] = distance[t] + 1\n  graph[S[t]] = [] \n  if t > 0:\n   if visited[t-1] == 0:\n    Q.put(t-1)\n    visited[t-1] = 1\n    distance[t-1] = distance[t]+1\n  if t < N-1:\n   if visited[t+1] == 0:\n    Q.put(t+1)\n    visited[t+1] = 1\n    distance[t+1] = distance[t]+1\n  visited[t] = 1\n print(distance[-1])\nelse:\n print(0)", "from queue import Queue\nS = list(map(int, input().strip()))\nN = len(S)\ngraph = {}\nfor i in range(N):\n graph[S[i]] = []\nif N > 1:\n for i in range(N):\n  graph[S[i]].append(i)\n visited = [0] * N\n distance = [0] * N\n Q = Queue()\n Q.put(0)\n while (not Q.empty()):\n  t = Q.get()\n  for i in graph[S[t]]:\n   if visited[i] == 0 and i != t:\n    Q.put(i)\n    visited[i] = 1\n    distance[i] = distance[t] + 1\n  graph[S[t]] = [] \n  if t > 0:\n   if visited[t-1] == 0:\n    Q.put(t-1)\n    visited[t-1] = 1\n    distance[t-1] = distance[t]+1\n  if t < N-1:\n   if visited[t+1] == 0:\n    Q.put(t+1)\n    visited[t+1] = 1\n    distance[t+1] = distance[t]+1\n  visited[t] = 1\n print(distance[-1])\nelse:\n print(0)", "from sys import stdin, stdout\n\nS = [int(z) for z in stdin.readline().strip()]\nn = len(S)\ngraph = {}\nd = {}\nvisited = {}\nfor i in range(n):\n graph[S[i]] = []\n visited[i] = 0\n d[i] = 0\nif n>1:\n for i in range(n):\n  graph[S[i]].append(i)\n queue = [0]\n\n while len(queue) != 0:\n  u = queue.pop(0)\n  for v in graph[S[u]]:\n   if visited[v] == 0 and v!=u:\n    d[v] += d[u] + 1\n    queue.append(v)\n    visited[v] = 1\n  graph[S[u]] = []\n  if u-1>=0:\n   if visited[u-1] == 0:\n    d[u-1] = d[u] + 1\n    visited[u-1] = 1\n    queue.append(u-1)\n  if u+1<n:\n   if visited[u+1] == 0:\n    d[u+1] = d[u] + 1\n    visited[u+1] = 1\n    queue.append(u+1)\n\n  visited[u] = 1\n stdout.write(\"%d\\n\"%d[n-1])\nelse:\n stdout.write(\"0\\n\")", "import heapq\n\ndef digitJump(text):\n L = len(text)\n\n if L == 1 or L == 2:\n  return L - 1\n\n numPos = [ [] for i in range(10) ]\n minJump = [ 2000000 for _ in range(L) ]\n minJump[L-1] = 0\n\n maxJumpForNum = [ 2000000 for _ in range(10) ]\n\n for i in range(L):\n  numPos[ int(text[i]) ].append(i)\n \n h = []\n heapq.heappush(h, (0, int(text[L-1]), L - 1))\n\n while len(h) > 0:\n  minJ, num, idx = heapq.heappop(h)\n  setJump = minJ + 1\n\n  # print(f\"minJ: {minJ}  num: {num}  idx: {idx}\")\n\n  if maxJumpForNum[num] > setJump:\n   maxJumpForNum[num] = setJump\n\n   for i in numPos[num]:\n    if i == idx:\n     continue\n    if minJump[i] > setJump:\n     minJump[i] = setJump\n     heapq.heappush(h, (setJump, num, i))\n   \n  if idx > 0:\n   if minJump[idx-1] > setJump:\n    minJump[idx-1] = setJump\n    heapq.heappush(h, (setJump, int(text[idx-1]), idx-1))\n  \n  if idx < L - 2:\n   if minJump[idx+1] > setJump:\n    minJump[idx+1] = setJump\n    heapq.heappush(h, (setJump, int(text[idx+1]), idx+1))\n   \n return minJump[0]\n   \n\ndef __starting_point():\n text = input().strip()\n print( digitJump(text) )\n__starting_point()", "\"\"\"\n-----------------------------Pseudo---------------------------------\n\"\"\"\nimport copy\nimport sys\nfrom collections import defaultdict, Counter\n\ndef input(): return sys.stdin.readline()\ndef mapi(): return map(int,input().split())\ndef maps(): return map(str,input().split())\n#\ndef print(arg, *argv, end=None):\n sys.stdout.write(str(arg))\n for i in argv: sys.stdout.write(\" \"+str(i))\n sys.stdout.write(end) if end else sys.stdout.write(\"\\n\")\n#---------------------------------------------------------------#\n\ndef solve():\n t = 1\n #t = int(input())\n while(t):\n  t-=1\n  a = input().strip()\n  n = len(a)\n  #print(n)\n  g = defaultdict(list)\n  for i in range(n):\n   g[a[i]].append(i)\n  vis = {}\n  vis[0] = 0\n  q = [0]\n  #print(g)\n  while len(q)!=0:\n   tmp = q.pop(0)\n   if tmp==n-1:\n    break\n   val = a[tmp]\n   x = len(g[val])\n   for i in range(x):\n    if g[val][i] not in vis:\n     q.append(g[val][i])\n     vis[g[val][i]] = vis[tmp]+1\n   g[val] = []\n   if tmp+1<=n-1 and tmp+1 not in vis:\n    q.append(tmp+1)\n    vis[tmp+1] = vis[tmp]+1\n   if tmp-1>=0 and tmp-1 not in vis:\n    q.append(tmp-1)\n    vis[tmp-1] = vis[tmp]+1\n  print(vis[n-1])\n\n#---------------------------------------------------------------#\ndef __starting_point():\n solve()\n\n\n__starting_point()", "from queue import Queue\ns = input().strip()\nt = [[] for i in range(10)]\nfor a in range(len(s)):\n b = int(s[a])\n t[b].append(a)\nd = [-1]*len(s)\nd[0] = 0\nq = Queue()\nq.put(0)\nwhile q.empty() == False:\n if d[len(s) - 1] != -1:\n  break\n h = q.get(0)\n value = int(s[h])\n for c in t[value]:\n  if d[c] == -1:\n   d[c] = d[h] + 1\n   q.put(c)\n t[value] = []\n if h + 1 < len(s)and d[h + 1] == -1:\n  d[h + 1] = d[h] + 1\n  q.put(h + 1)\n if h - 1 > 0 and d[h - 1] == -1:\n  d[h - 1] = d[h] + 1\n  q.put(h - 1)\n\nprint(d[len(s) - 1])", "from queue import Queue\ns = input().strip()\n\n#contains a list of some the neibours indexes of a certain node (some are not \u00a0\u00a0\u00a0\u00a0counted here : the one with index+1 and index-1)\nneighbours = [[] for _ in range(10)]\nfor index_node in range(len(s)):\n value_node = int(s[index_node])\n neighbours[value_node].append(index_node)\n \n#distance of every nodes to the source\ndistances = [-1]*len(s)\ndistances[0]=0 #the distance of the source to itself with is 0\n\n#This queue contains the index of the nodes we have not yet visited.\nq = Queue()\nq.put(0) #initialize the q with the source node\n\nwhile q.empty()==False :\n if distances[len(s)-1]!=-1:\n  break\n #get() is same as the generic pop() operation\n current_node_index = q.get(0)\n value = int(s[current_node_index])\n ### Relaxtion steps \n ## check most of the neighbours\n for neighbour_index in neighbours[value]:\n  #check if this neibhour was not visited before\n  if distances[neighbour_index]==-1:\n   distances[neighbour_index]=distances[current_node_index]+1\n   q.put(neighbour_index)\n neighbours[value] = []\n ## check 2 others neighbours \n if current_node_index + 1 < len(s)and distances[current_node_index+1]==-1:\n  distances[current_node_index+1]=distances[current_node_index]+1\n  q.put(current_node_index+1)\n if current_node_index - 1 > 0 and distances[current_node_index-1]==-1:\n  distances[current_node_index-1]=distances[current_node_index]+1\n  q.put(current_node_index-1)\n\nprint(distances[len(s)-1])", "\n#https://www.codechef.com/problems/DIGJUMP\n \nimport sys\nimport math\nfrom collections import defaultdict\n \ntry: \n sys.stdin = open('input.txt', 'r') \n sys.stdout = open('output.txt', 'w')\n \nexcept: \n pass\n \n\nclass Graph:\n def __init__(self):\n  self.neighbours=defaultdict(set)\n\n def addEdge(self,u,v):\n  if(v not in self.neighbours[u]):\n   self.neighbours[u].add(v)\n   self.neighbours[v].add(u)\n\n def BFS(self,n,s,at):\n  visited=defaultdict(lambda:False)\n  dist=defaultdict(lambda:float(\"inf\"))\n  visited[0]=True\n  dist[0]=0\n  queue=[0]\n  added={}\n  while queue:\n   u=queue.pop(0)\n   char=s[u]\n   if(char not in added):\n    added[char]=True\n    for idx in at[char]:\n     g.addEdge(u,idx)\n   for v in self.neighbours[u]:\n    if(not visited[v]):\n     visited[v]=True\n     queue.append(v)\n     dist[v]=dist[u]+1\n  return dist[n-1]\n\n\n \n \ns=input().strip()\nat={}\nn=len(s)\ng=Graph()\n\nat=defaultdict(list)\nfor i in range(n):\n at[s[i]].append(i)\n\nfor i in range(1,n):\n g.addEdge(i-1,i)\n\nfor i in range(n-1):\n g.addEdge(i,i+1)\n\n\nprint(g.BFS(n,s,at))\n\n", "\n#https://www.codechef.com/problems/DIGJUMP\n \nimport sys\nimport math\nfrom collections import defaultdict\n \ntry: \n sys.stdin = open('input.txt', 'r') \n sys.stdout = open('output.txt', 'w')\n \nexcept: \n pass\n \n\n\n \n \ns = input().strip()\nat={}\nn=len(s)\nat=defaultdict(list)\nfor i in range(n):\n at[int(s[i])].append(i)\n\nvisited=defaultdict(lambda:False)\ndist=defaultdict(lambda:float(\"inf\"))\nvisited[0]=True\ndist[0]=0\nqueue=[0]\nadded={}\nwhile queue:\n u=queue.pop(0)\n char=int(s[u])\n for v in at[char]:\n  if(not visited[v]):\n   visited[v]=True\n   queue.append(v)\n   dist[v]=dist[u]+1\n\n at[char]=[]\n if(u!=0):\n  v=u-1\n  if(not visited[v]):\n   visited[v]=True\n   queue.append(v)\n   dist[v]=dist[u]+1\n if(u!=n-1):\n  v=u+1\n  if(not visited[v]):\n   visited[v]=True\n   queue.append(v)\n   dist[v]=dist[u]+1\n\nprint(dist[n-1])\n\n"]