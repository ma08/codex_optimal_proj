["import math\nimport bisect\n\n\nn, x, k = list(map(int, input().split()))\na = sorted(list(map(int, input().split())))\nans = 0\n\nfor num in a:\n    l = math.ceil(num/x)*x + (k-1)*x\n    r = l + x - 1\n    l = num if l < num else l\n    # print(l, r, bisect.bisect_left(a, l), bisect.bisect_right(a, r), bisect.bisect_right(a, r) - bisect.bisect_left(a, l))\n    ans += bisect.bisect_right(a, r) - bisect.bisect_left(a, l)\n\nprint(ans)\n\n\n'''\n7 3 2\n1 3 5 9 11 16 25\n'''\n\n'''\n4 2 0\n5 3 1 7\n'''\n", "n, x, k = list(map(int, input().split()))\narray = list(map(int, input().split()))\n\ndef next_x(n):\n    return ((n+x-1)//x)*x\n\nvalcount = {}\nfor a in array:\n    valcount[a] = valcount.get(a, 0) + 1\n\nbegs = {}\npairs = 0\nfor val, count in sorted(valcount.items()):\n    if k > 0 or val % x != 0:\n        beg = next_x(val)\n        begs[beg] = begs.get(beg, 0) + count\n        from_ = next_x(val - k*x + 1)\n        pairs += count*begs.get(from_, 0)\nprint(pairs)\n", "import sys\nsys.setrecursionlimit(100000000)\n# def input(): return sys.stdin.readline()[:-1]\ndef iin(): return int(input())\ndef impin(): return list(map(int, input().split()))\ndef irrin(): return [int(x) for x in input().split()]\ndef imrin(n): return [int(input()) for _ in range(n)]\n\n\ndef c(n, k):\n    if n<k:\n        return 0\n    s = 1\n    for i in range(1, k+1):\n        s *= n-i+1\n        s //= i\n    return s\n\n\nn, x, k = impin()\narr = irrin()\nif k==0:\n    trr = {}\n    frr = {}\n    for a in arr:\n        if a%x!=0:\n            p = a//x\n            if p in trr:\n                trr[p] += 1\n            else:\n                trr[p] = 1\n            if a in frr:\n                frr[a] += 1\n            else:\n                frr[a] = 1\n    s = 0\n    # print(trr)\n    for p in trr:\n        s += c(trr[p]+1, 2)\n        # print(trr[p], s)\n    for a in frr:\n        s += c(frr[a], 2)\n    print(s)\nelse:\n    urr = {}\n    lrr = {}\n    for a in arr:\n        u = (a-1)//x+1\n        l = a//x\n        # print(a, u, l)\n        if u in urr:\n            urr[u] += 1\n        else:\n            urr[u] = 1\n        if l in lrr:\n            lrr[l] += 1\n        else:\n            lrr[l] = 1\n    s = 0\n    for u in urr:\n        # print(urr[u])\n        l = u+k-1\n        # print(u, l)\n        if l in lrr:\n            s += urr[u]*lrr[l]\n    print(s)\n\n\n# s = 0\n# for i in range(n):\n#     for j in range(n):\n#         if arr[i]>arr[j]:\n#             continue\n#         c = 0\n#         for y in range(arr[i], arr[j]+1):\n#             if y%x==0:\n#                 c += 1\n#         if c==k:\n#             print(arr[i], arr[j])\n#             s += 1\n# print(s)\n", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2017/11/27 01:27\n\n\"\"\"\n\n\nN, X, K = map(int, input().split())\n\nA = [int(x) for x in input().split()]\n\n# consider special case firstly\nif X == 1 and K == 0:\n    print(0)\n    return\n\nA.sort()\n\ndef right(start):\n    # find the end for [start, end] has K elements divisible by X\n    x = start//X if start%X != 0 else start//X-1\n    endmin = max((x+K) * X, start)\n    endmax = (x+K+1) * X - 1\n\n    return endmin, endmax\n\nans = 0\nfor i, v in enumerate(A):\n    rmin, rmax = right(v)\n    rl = bisect.bisect_left(A, rmin)\n    rr = bisect.bisect_right(A, rmax)\n    ans += rr - rl\n\nprint(ans)", "import bisect\nimport math\n\nn, x, k = map(int, input().split())\na = sorted(list(map(int, input().split())))\nans = 0\nfor i in a:\n    l = math.ceil(i/x)*x + (k-1)*x\n    r = l + x - 1\n    if (l < i): l = i  \n    else: l = l\n    ans += bisect.bisect_right(a, r) - bisect.bisect_left(a, l)\nprint(ans)", "n,x,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nfrom collections import Counter\nans=0\nif k!=0:\n    dn=Counter()\n    un=Counter()\n    for i in a:\n        dn[i//x]+=1\n        un[(i-0.1)//x]+=1\n    for item,kol in list(un.items()):\n        ans+=kol*dn[item+k]\n    print(ans)\nelse:\n    dn = Counter()\n    un = Counter()\n    s=set()\n    for i in a:\n        if i%x!=0:\n            un[i]+=1\n            dn[i//x]+=1\n    #print(dn,un,sep='\\n')\n    for item, kol in list(dn.items()):\n        ans += kol*(kol+1)//2\n    for item, kol in list(un.items()):\n        ans += kol*(kol-1)//2\n    print(ans)\n", "n,x,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nfrom collections import Counter\nans=0\nif k!=0:\n    dn=Counter()\n    un=Counter()\n    for i in a:\n        dn[i//x]+=1\n        un[(i-0.1)//x]+=1\n    for item,kol in list(un.items()):\n        ans+=kol*dn[item+k]\n    print(ans)\nelse:\n    dn = Counter()\n    un = Counter()\n    s=set()\n    for i in a:\n        if i%x!=0:\n            un[i]+=1\n            dn[i//x]+=1\n    #print(dn,un,sep='\\n')\n    for kol in list(dn.values()):\n        ans += kol*(kol+1)//2\n    for kol in list(un.values()):\n        ans += kol*(kol-1)//2\n    print(ans)\n", "import sys\nfrom bisect import *\nimport math\n\nN,X,K = list(map(int, input().split()))\np = sorted(list(map(int, input().split())))\n\ndef get(l, r):\n\treturn (r//X) - (l-1)//X\n\np = sorted(p)\nmp = {}\nn = len(p)\n\nfor i in range(n):\n\tif p[i] in mp:\n\t\tcontinue\n\telse:\n\t\tmp[p[i]] = i\nx = 5\nans = 0\nmx = 0\n\nfor i in range(0,n):\n\tx = p[i]\n\ta = x//X\n\tmn = 0\n\tmx = 0\n\n\tif x % X == 0 :\n\t\tmn = x + (K-1)*X\n\t\tmx = mn + X-1\n\telse:\n\t\tmn =(x//X)*X + (K)*X\n\t\tmx = mn + X-1\n\tif K == 0:\n\t\tif x%X == 0 :\n\t\t\tcontinue\n\t\tmn = x\n\t\tmx = (x//X)*X+X-1\n\t#print(x,mn,mx)\n\tif mn > mx:\n\t\tcontinue\n\tans = ans + bisect_right(p,mx) - bisect_left(p,mn)\n\nprint(ans)\n", "from bisect import bisect_left\nR=lambda:list(map(int,input().split()))\nn,x,k=R()\na=sorted(R())\ncnt=0\nfor u in a:\n    l=((u+x-1)//x+k-1)*x\n    cnt+=bisect_left(a,l+x)-bisect_left(a,max(u,l))\nprint(cnt)\n", "from bisect import bisect_left\nR=lambda:map(int,input().split())\nn,m,k=R()\na=sorted(R())\ns=0\nfor i in a:\n    l = ((i - 1) // m + k) * m\n    s+=bisect_left(a,l+m)-bisect_left(a,max(i,l))\nprint(s)", "from bisect import bisect_left\nR=lambda:list(map(int,input().split()))\nn,x,k=R()\na=sorted(R())\ns=0\nfor u in a:\n    l=((u-1)//x+k)*x\n    s+=bisect_left(a,l+x)-bisect_left(a,max(u,l))\nprint(s)\n", "from bisect import bisect_left\nR=lambda:list(map(int,input().split()))\nn,x,k=R()\na=sorted(R())\nz=list(zip(a,(((u-1)//x+k)*x for u in a)))\nprint(sum(bisect_left(a,l+x)-bisect_left(a,max(u,l)) for u,l in z))\n", "from bisect import bisect_left\nR=lambda:list(map(int,input().split()))\nn,x,k=R()\na=sorted(R())\nz=((u,((u-1)//x+k)*x) for u in a)\nprint(sum(bisect_left(a,l+x)-bisect_left(a,max(u,l)) for u,l in z))\n", "from bisect import bisect_left\nR=lambda:list(map(int,input().split()))\nn,x,k=R()\na=sorted(R())\nb=(((u-1)//x+k)*x for u in a)\nprint(sum(bisect_left(a,l+x)-bisect_left(a,max(u,l)) for u,l in zip(a,b)))\n", "from bisect import bisect_left\nR=lambda:list(map(int,input().split()))\nn,x,k=R()\na=sorted(R())\nprint(sum(bisect_left(a,l+x)-bisect_left(a,max(u,l)) for u,l in ((u,((u-1)//x+k)*x) for u in a)))\n", "from bisect import bisect_left, bisect_right\n\nn, x, k = [int(i) for i in input().split(' ')]\nar = sorted([int(i) for i in input().split(' ')])\n\nlk, nk = -1, 0\n\nn_tup = 0\n\nif x != 1 or k != 0:\n    for i in range(len(ar)):\n        nk = ar[i]\n        if lk != nk:\n            xf = (k + (ar[i] - 1) // x)\n            lo = bisect_left(ar, ar[i])\n            # Find rightmost value less than xf*x\n            lt = bisect_left(ar, (xf+1)*x, lo)\n            # Find leftmost value greater than (xf+1)*x\n            gt = bisect_right(ar, xf*x-1, lo)\n        n_tup += lt - gt\n        lk = nk\n\nprint(n_tup)", "from bisect import bisect_left as b\nR=lambda:list(map(int,input().split()))\nn,x,k=R()\na=sorted(R())\nprint(sum(b(a,l+x)-b(a,max(u,l)) for u,l in ((u,((u-1)//x+k)*x) for u in a)))\n", "from bisect import bisect_left\n\nn, x, k = list(map(int, input().split()))\narr = sorted(list(map(int, input().split())))\n\nranges = []\nfor a in arr:\n    if k == 0:\n        a1 = (((a - 1) // x) + 1) * x\n        l = a\n        r = a1 + x * (k - 1) + x\n    else:\n        a1 = (((a - 1) // x) + 1) * x\n        l = a1 + x * (k - 1)\n        r = a1 + x * (k - 1) + x\n    ranges.append((min(l, r), max(l, r)))\nres = 0\n\n# print(arr)\n# print(ranges)\n\nfor l, r in ranges:\n    left_index = bisect_left(arr, l)\n    right_index = bisect_left(arr, r)\n    res += right_index - left_index\n    # print(left_index, right_index)\n\nprint(res)\n", "n, x, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\na.sort()\n\nans = 0\ns, t = 0, 0\nfor j in range(n):\n\tcur = ((a[j] // x) - k) * x\n\t\n\twhile s < n and a[s] <= min(cur,a[j]):\n\t\ts += 1\n\t\t\n\twhile t < n and a[t] <= min(cur + x, a[j]):\n\t\tt += 1\n\t\n\tans += (t-s)\n\t\nprint(ans)", "import bisect\ndef lower_bound(A, x):\n    low = 0\n    high = len(A)\n    while(low < high):\n        mid = (low + high) // 2\n        if(int(A[mid]) < x):\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\ndef upper_bound(A, x):\n    low = 0\n    high = len(A)\n    while(low < high):\n        mid = (low + high) // 2\n        if(int(A[mid]) <= x):\n            low = mid + 1\n        else:\n            high = mid\n    return low\nline = input().split()\nn = int(line[0])\nx = int(line[1])\nk = int(line[2])\na = [int(x) for x in input().split()]\na.sort()\n\nans = 0\nfor i in a:\n    left = (i + x - 1) // x * x\n    right = left + x * k - 1\n    left = left + (k - 1) * x\n    left = max(left, i)\n    ans = ans + bisect.bisect_right(a, right) - bisect.bisect_left(a, left)\n    # print(left, right, ans)\nprint(ans)\n\n", "from bisect import bisect_left as b\nf = lambda: map(int, input().split())\nn, x, k = f()\ns, t = 0, sorted(f())\np = [(q, ((q - 1) // x + k) * x) for q in t]\nfor q, d in p: s += b(t, d + x) - b(t, max(q, d))\nprint(s)", "f = lambda: map(int, input().split())\nn, x, k = f()\nt = sorted(f())\ns = i = j = 0\nfor y in t:\n    d = (y // x - k) * x\n    while i < n and t[i] <= min(d, y): i += 1\n    while j < n and t[j] <= min(d + x, y): j += 1\n    s += j - i\nprint(s)"]