["from copy import deepcopy\nimport itertools\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nimport math\nfrom collections import deque\nfrom collections import Counter\n\n\ndef read():\n    return int(input())\n\n\ndef readmap():\n    return map(int, input().split())\n\n\ndef readlist():\n    return list(map(int, input().split()))\n\n\nn, m, d = readmap()\nA = readlist()\nAind = dict([(A[i], i) for i in range(n)])\nA.sort()\n\nq = deque()\na = A[0]\nans = [0] * n\nans[Aind[a]] = 1\nmaxday = 1\n\nq.append((a, 1))\nfor i in range(1, n):\n    if A[i] > q[0][0] + d:\n        ans[Aind[A[i]]] = q[0][1]\n        q.append((A[i], q[0][1]))\n        q.popleft()\n    else:\n        maxday += 1\n        ans[Aind[A[i]]] = maxday\n        q.append((A[i], maxday))\n\nprint(maxday)\nprint(\" \".join(list(map(str, ans))))", "n, m, d = list(map(int, input().split()))\nbreaks = list(map(int, input().split()))\n\nbreaks_S = sorted(breaks)\nindex_s = [i[0] for i in sorted(enumerate(breaks), key=lambda x:x[1])]\n\nd += 1\n\nanswer = [-1] * n\n\nx = 1\n\n\nfor i in range(n):\n\twhile True:\n\t\tif i >= x and breaks_S[i] - breaks_S[i - x] < d:\n\t\t\tx += 1\n\t\telif n - i > x and breaks_S[i + x] - breaks_S[i] < d:\n\t\t\tx += 1\n\t\telse:\n\t\t\tbreak\n\n\nfor i in range(n):\n\tanswer[index_s[i]] = i % x + 1\n\n\nprint(x)\nprint(*answer)\n\n\n\n\n", "n,m,d=list(map(int,input().split()))\narr=list(map(int,input().split()))\narrx=[]\nfor i in range(n):\n    arrx.append((arr[i],i))\narrx.sort()\narr1=[0]*n\narr1[arrx[0][1]]=1\ncount=1\nindex=0\nfor i in range(1,n):\n    if(arrx[i][0]>=arrx[index][0]+d+1):\n        arr1[arrx[i][1]]=arr1[arrx[index][1]]\n        index+=1\n    else:\n        count+=1\n        arr1[arrx[i][1]]=count\nprint(count)\nprint(*arr1)\n\n\n", "from collections import deque\n\n\ndef follow(idx, this_or_first_free):\n    if idx == -2:\n        return -2\n\n    if this_or_first_free[idx] == -1:\n        return idx\n    if this_or_first_free[idx] == -2:\n        return -2\n\n    root = follow(this_or_first_free[idx], this_or_first_free)\n    this_or_first_free[idx] = root\n    return root\n\n\ndef take(idx, this_or_first_free, initial_next):\n    this_or_first_free[idx] = initial_next[idx]  # this can be -2 or an index to follow\n\n\ndef legit(idx):\n    return idx != -1 and idx != -2\n\n\n(n, m, d) = list(map(int, input().split()))\nbreak_list = list([(int(idx_val[1]), idx_val[0]) for idx_val in enumerate(input().split())])\n\nbreak_list.sort()\n\nassignment = [-1] * n\nbreaks_initial_next = [-2] * n\n\nTFO = [False] * n\n\ndeq = deque()\nfor i in range(n):\n    val = break_list[i][0]  # pos of this break\n    deq.append((val, i))  # append the pos and its index in the array\n\n    while len(deq) > 0 and val - deq[0][0] - 1 >= d:\n        breaks_initial_next[deq[0][1]] = i\n        deq.popleft()\n\nhead_initial_next = [i + 1 for i in range(n)]\nhead_initial_next[-1] = -2\nhead_first_free = [-1] * n\n\nfirst_not_taken = 0\ndays_count = 0\nwhile legit(first_not_taken):\n    current = first_not_taken\n    days_count += 1\n\n    while legit(current):\n        take(current, head_first_free, head_initial_next)  # invalidate head\n        assignment[break_list[current][1]] = days_count\n\n        if not TFO[current]:\n            TFO[current] = True\n            current = breaks_initial_next[current]\n\n        current = follow(current, head_first_free)\n\n    first_not_taken = follow(first_not_taken, head_first_free)  # find next head\n\nprint(days_count)\nprint(str(assignment)[1:-1].replace(\",\", \"\"))\n", "def check(p):\n    for i in range(n - p):\n        if a[i + p] - a[i] - 1 < d:\n            return False\n    \n    return True\n\n\ndef binSearch(a, b):\n    left, right = a - 1, b + 1\n\n    while right - left > 1:\n        mid = (left + right) // 2\n\n        if check(mid):\n            right = mid\n\n        else:\n            left = mid\n\n    return right\n\n\nn, m, d = map(int, input().split())\na = list(map(int, input().split()))\n\na_ind = {i: a[i] for i in range(n)}\na.sort()\n\nb = binSearch(1, n)\nans = {el: 0 for el in a}\n\nfor i, el in enumerate(a, 1):\n    ans[el] = (i - 1) % b + 1\n\nprint(b)\nprint(' '.join(map(str, [ans[a_ind[i]] for i in range(n)])))", "n , m , d = map(int,input().split())\na = list(map(int,input().split()))\nid = {a[i] : i for i in range(n)}\n\na.sort()\n\n#for i in range(0,n) :\n#    print(i , a[i] , id[i])\n\ndef Solve(x) :\n    for i in range(x,n) :\n        if (a[i] - a[i-x]) <= d :\n            return False\n    return True\n\nl = 1\nr = n\nwhile l < r :\n    mid = int((l+r)/2)\n    if Solve(mid) :\n        r = mid\n    else :\n        l = mid + 1\nans = [0 for i in range(n)]\nfor i in range(n) :\n    ans[id[a[i]]] = (i % l) + 1\nprint(l)\nprint(' '.join(map(str, ans)))", "from collections import deque\n\n\ndef main():\n    n, m, d = list(map(int, input().split()))\n    aa = list(map(int, input().split()))\n    q, cnt = deque(((-d, 1),)), 1\n    for i in sorted(list(range(n)), key=aa.__getitem__):\n        a = aa[i]\n        b, j = q.popleft()\n        if a <= b + d:\n            q.appendleft((b, j))\n            j = cnt = cnt + 1\n        aa[i] = j\n        q.append((a, j))\n    print(cnt)\n    print(' '.join(list(map(str, aa))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import heapq\nn, m, d = list(map(int, input().split()))\na = list(map(int, input().split()))\nans = []\na = [(x,i) for i,x in enumerate(a)]\na.sort()\nheap = []\nday = 0\nfor b, i in a:\n\tfound = False\n\tif len(heap) > 0:\n\t\tif heap[0][0] + d < b:\n\t\t\theapq.heappush(heap, (b,i,heap[0][2]))\n\t\t\tans.append(heapq.heappop(heap))\n\t\t\tfound = True\n\tif not found:\n\t\theapq.heappush(heap, (b,i,day+1))\n\t\tday += 1\nfor t in heap:\n\tans.append(t)\nidx = [0]*n\nprint(day)\nfor i in range(len(ans)):\n\tidx[ans[i][1]] = ans[i][2]\nfor i in idx:\n\tprint(i, end=' ')", "from operator import itemgetter\nn,m,d = map(int,input().split())\nai = list(map(int,input().split()))\nai2 = [[ai[i],i] for i in range(n)]\nd += 1\nai2.sort(key = itemgetter(0))\nai4 = [0] * n\nai5 = [0] * n\nai4[0] = ai2[0][0]\nai5[0] = 1\nai[ai2[0][1]] = 1\nj = 1\ni = 1\nz = 0\nwhile i < n:\n    if ai2[i][0] < ai4[z] + d:\n        ai4[j + z] = ai2[i][0]\n        ai5[j + z] = j + 1\n        j += 1\n        ai[ai2[i][1]] = j\n    else:\n        ai4[j + z] = ai2[i][0]\n        ai5[j + z] = ai5[z]\n        ai[ai2[i][1]] = ai5[z]\n        z += 1\n    i += 1\nprint(j)\nfor i in range(n):\n    print(ai[i],end=\" \")\n", "from collections import Counter, defaultdict, deque\nread = lambda: list(map(int,input().split()))\n\ndef solve(a,d,df):\n    cnt = 1\n    res = [0] * n\n    Q = deque([(a[0], cnt)])\n    res[df[a[0]]] = 1\n    for i in range(1,n):\n        if a[i] > Q[0][0] + d:\n            val, day = Q.popleft()\n            res[df[a[i]]] = day\n            Q.append((a[i], day))\n        else:\n            cnt += 1\n            res[df[a[i]]] = cnt\n            Q.append((a[i], cnt))\n    print(cnt)\n    print(' '.join(map(str, res)))\n\nn,m,d = read()\na = read()\ndf = {v:i for i,v in enumerate(a)}\na.sort()\nsolve(a,d,df)", "import math\nimport sys\nfrom bisect import bisect_right, bisect_left, insort_right\nfrom collections import Counter, defaultdict\nfrom heapq import heappop, heappush\nfrom itertools import accumulate\nfrom sys import stdout\n\nR = lambda: map(int, input().split())\nn, m, d = R()\na = sorted((x, i) for i, x in enumerate(R()))\nres = [-1] * len(a)\nres[0] = 0\ncnt = 0\nq = [(a[0][0], 0)]\nfor r in range(1, n):\n    h = heappop(q)\n    if a[r][0] - h[0] > d:\n        res[r] = h[1]\n    else:\n        cnt += 1\n        res[r] = cnt\n        heappush(q, h)\n    heappush(q, (a[r][0], res[r]))\nprint(max(res) + 1)\nfor t in sorted(zip(a, res), key=lambda x: x[0][1]):\n    print(t[1] + 1, end=' ')\n", "R = lambda: map(int, input().split())\nn, m, d = R()\na = sorted((x, i) for i, x in enumerate(R()))\nres = [-1] * len(a)\nres[0] = 0\ncnt = 0\nl = 0\nfor r in range(1, n):\n    if a[r][0] - d <= a[l][0]:\n        cnt += 1\n        res[r] = cnt\n    else:\n        res[r] = res[l]\n        l += 1\nprint(max(res) + 1)\nfor t in sorted(zip(a, res), key=lambda x: x[0][1]):\n    print(t[1] + 1, end=' ')", "n,m,d=map(int,input().split())\na=list(map(int,input().split()))\no=[0]*n\nx=[(a[i],i) for i in range(n)]\nx.sort()\nu=0\ni=j=0\nwhile i<n:\n    if x[i][0]-d<=x[j][0]:u+=1;o[x[i][1]]=u\n    else:o[x[i][1]]=o[x[j][1]];j+=1\n    i+=1\nprint(u)\nprint(' '.join(list(map(str,o))))", "a,b,c=list(map(int,input().split()))\nl=list(map(int,input().split()))\nl1=[(l[i],i) for i in range(a)]\notv=[0]*a\nl1=sorted(l1,key=lambda x:x[0])\ni=j=0\nk=0\nfor i in range(a) :\n    if l1[i][0]-c<=l1[j][0] :\n        k+=1\n        otv[l1[i][1]]=k\n    else :\n        otv[l1[i][1]]=otv[l1[j][1]]\n        j+=1\nprint(k)\nprint(\" \".join(map(str,otv)))\n        \n", "n, m, k = list(map(int, input().split()))\nl = list(map(int, input().split()))\nfor i in range(n):\n    l[i] = [l[i], i]\nl.sort()\n\nuk1 = 1\nuk2 = n\n\ndef pos(n):\n    cnt = [-10000000001] * len(l)\n    nonlocal k\n    for i in range(len(l)):\n        if l[i][0] - cnt[i % n] <= k:\n            return False\n        else:\n            cnt[i % n] = l[i][0]\n\n    return True\nwhile uk2 - uk1 > 1:\n    if pos((uk2 + uk1) // 2):\n        uk2 = (uk1 + uk2) // 2\n    else:\n        uk1 = (uk1 + uk2) // 2\n\nans = [0] * n\nif not pos(uk1):\n    for i in range(n):\n        ans[l[i][1]] = i % uk2 + 1\n    print(uk2)\n    for i in range(n):\n        print(ans[i], end =' ')\nelse:\n    for i in range(n):\n        ans[l[i][1]] = i % uk1 + 1\n    print(uk1)\n    for i in range(n):\n        print(ans[i], end =' ')", "n, work, gap = list(map(int, input().split()))\na = list(map(int, input().split()))\na = sorted([(a[i], i) for i in range(n)])\nret = [0] * n\nday = 0\nleft = right = 0\nwhile right < n:\n    if a[right][0] - a[left][0] <= gap:\n        day += 1\n        ret[a[right][1]] = day\n    else:\n        ret[a[right][1]] = ret[a[left][1]]\n        left += 1\n    right += 1\nprint(day)\nprint(*ret)\n", "a,b,c=map(int,input().split())\nl=list(map(int,input().split()))\nl1=[(l[i],i) for i in range(a)]\notv=[0]*a\nl1=sorted(l1,key=lambda x:x[0])\ni=j=0\nk=0\nfor i in range(a) :\n    if l1[i][0]-c<=l1[j][0] :\n        k+=1\n        otv[l1[i][1]]=k\n    else :\n        otv[l1[i][1]]=otv[l1[j][1]]\n        j+=1\n    # print(j,i)\nprint(k)\nprint(\" \".join(map(str,otv)))", "n,m,D=map(int,input().split())\nlst=[*map(int,input().split())]\nd={}\nfor i,x in enumerate(lst):d[x]=i\nlst.sort()\nres,j,result=[0]*n,0,0\nfor i,x in enumerate(lst):\n    if x-lst[j]>D:\n        res[d[x]]=res[d[lst[j]]]\n        j+=1\n    else:\n        result+=1\n        res[d[x]]=result\nprint(result)\nprint(*res)", "n,m,D=map(int,input().split())\nlst=[*map(int,input().split())]\nd={x:i for i,x in enumerate(lst)}\nlst.sort()\nres,j,result=[0]*n,0,0\nfor i,x in enumerate(lst):\n    if x-lst[j]>D:\n        res[d[x]]=res[d[lst[j]]]\n        j+=1\n    else:\n        result+=1\n        res[d[x]]=result\nprint(result)\nprint(*res)", "n , m , d = map(int , input().split())\na = list(map(int , input().split()))\na = sorted([(a[i] , i) for i in range(n)])\n\nright = 0\nleft = 0\nday = 0\nret = [0] * n\nwhile right < n :\n    if a[right][0] - a[left][0] <= d :\n        day += 1\n        ret[a[right][1]] = day\n    else :\n        ret[a[right][1]] = ret[a[left][1]]\n        left += 1\n    right += 1\nprint(day)\nprint(*ret)", "n,m,d = list(map(int,input().split()))\nlis = list(map(int,input().split()))\nl1=[[lis[i],i] for i in range(n)]\nl1.sort()\nans=[0]*n\n#print(l1)\nj=k=0\nfor i in range(n):\n    if l1[i][0]-l1[j][0]<=d:\n        k+=1\n        ans[l1[i][1]]=k\n    else:\n        ans[l1[i][1]]=ans[l1[j][1]]\n        j+=1\nprint(k)\nprint(*ans)        \n\n\n            \n    \n", "n, m, d = map(int, input().split())\na = list(map(int, input().split()))\na = sorted([(a[i],i) for i in range(n)])\ncoffeeTable = [0] * n\nminimumDays = 0\ni = j = 0\nwhile i<n:\n\tif a[i][0] - d <= a[j][0] :\n\t\tminimumDays += 1\n\t\tcoffeeTable[a[i][1]] = minimumDays\n\telse:\n\t\tcoffeeTable[a[i][1]] = coffeeTable[a[j][1]]\n\t\tj += 1\n\ti += 1\nprint(minimumDays)\nprint(' '.join(list(map(str, coffeeTable))))", "\nn,m,d=list(map(int,input().split()))\na=list(map(int,input().split()))\nl=[]\nfor i in range(n):\n\tl.append((a[i],i))\nl.sort()\nj=0\nans=[0]*n\nc=0\nfor i in range(n):\n\tif l[i][0]-d<=l[j][0]:\n\t\tc+=1\n\t\tans[l[i][1]]=c\n\telse:\n\t\tans[l[i][1]]=ans[l[j][1]]\n\t\tj+=1\nprint(c)\nprint(*ans)\n", "\nn,m,d=list(map(int,input().split()))\na=list(map(int,input().split()))\nl=[]\nfor i in range(n):\n\tl.append((a[i],i))\nl.sort()\nj=0\nans=[0]*n\nc=0\nfor i in range(n):\n\tif l[i][0]-d<=l[j][0]:\n\t\tc+=1\n\t\tans[l[i][1]]=c\n\telse:\n\t\tans[l[i][1]]=ans[l[j][1]]\n\t\tj+=1\nprint(c)\nprint(*ans)\n", "# -*- coding: utf-8 -*-\n\n# Baqir Khan\n# Software Engineer (Backend)\n\nfrom sys import stdin\n\ninp = stdin.readline\n\nn, m, d = list(map(int, inp().split()))\na = [(int(minute), index) for index, minute in enumerate(inp().split())]\nans = [0] * n\n\na.sort()\nans[a[0][1]] = 1\nmax_cur_day = 1\nj = 0\ncount = 1\n\nfor i in range(1, n):\n    if a[i][0] - a[j][0] > d:\n        ans[a[i][1]] = ans[a[j][1]]\n        j += 1\n    else:\n        count += 1\n        ans[a[i][1]] = count\n\nprint(count)\nprint(*ans)\n\n\n\n"]