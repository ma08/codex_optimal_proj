["class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         start = self.firstGreaterEqaul(nums, target)\n         if start==len(nums) or nums[start]!=target:\n             return [-1, -1]\n         return [start, self.firstGreaterEqaul(nums, target+1)-1]\n     def firstGreaterEqaul(self, nums, target):\n         lo, hi = 0, len(nums)\n         while lo<hi:\n             mid = (hi+lo)//2\n             if nums[mid]<target:\n                 lo = mid + 1\n             else:\n                 hi = mid\n         return lo", "class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         import bisect\n         lo=bisect.bisect_left(nums,target)\n         if target in nums[lo:lo+1]:\n             hi=bisect.bisect(nums,target)-1\n             return [lo, hi]\n         else:\n             return [-1, -1]", "class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         result = []\n         left, right = 0, len(nums)-1\n         while left <= right:\n             mid = (left+right) // 2\n             print(('mid:', mid))\n             if nums[mid] == target:\n                 print('hello')\n                 if mid == 0 or nums[mid-1] < target:\n                     result.append(mid)\n                     break\n                 else:\n                     right = mid -1\n             elif nums[mid] < target:\n                 left = mid+1\n             else:\n                 right = mid-1\n         left, right = 0, len(nums)-1\n         while left <= right:\n             mid = (left+right) // 2\n             if nums[mid] == target:\n                 if mid == len(nums)-1 or nums[mid+1] > target:\n                     result.append(mid)\n                     break\n                 else:\n                     left = mid + 1\n             elif nums[mid] < target:\n                 left = mid+1\n             else:\n                 right = mid-1\n         if len(result) == 0:\n             return [-1, -1]\n         return result\n         \n", "\n \n class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         \n         if len(nums) == 0:\n             return [-1, -1]\n \n         nums = [target - 1] + nums + [target + 1]\n \n         lbound = -1\n \n         l, r = 1, len(nums) - 2\n \n         while l <= r:\n \n             m = (l + r)//2\n \n             if nums[m] == target and nums[m - 1] < target:\n                 lbound = m\n                 break\n \n             if nums[m] < target:\n                 l = m + 1\n             else: # nums[m] >= target:\n                 r = m - 1\n \n         if lbound == -1:\n             return [-1, -1]\n \n         rbound = -1\n         l, r = 1, len(nums) - 2\n \n         while l <= r:\n \n             m = (l + r)//2\n \n             if nums[m] == target and nums[m + 1] > target:\n                 rbound = m\n                 break\n \n             if nums[m] <= target:\n                 l = m + 1\n             else: # target < nums[m]\n                 r = m - 1\n \n         return [lbound - 1, rbound - 1]\n \n", "class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         if not nums:\n             return [-1,-1]\n         a=self.findLeft(nums,target)\n         b=self.findRight(nums,target)\n         if nums[a]!=target:\n             return [-1,-1]\n         return [a,b]\n         \n     def findLeft(self,nums,target):\n         low,high=0,len(nums)-1\n         while low<high:\n             mid=(low+high)//2\n             \n             if nums[mid]>=target:\n                 high=mid\n             else:\n                 low=mid+1\n         return low\n     \n     def findRight(self,nums,target):\n         low,high=0,len(nums)-1\n         while low<high:\n             mid=(low+high)//2+1\n             if nums[mid]>target:\n                 high=mid-1\n             else:\n                 low=mid\n         return high\n     \n     \n", "class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         #m = int(len(nums)/2)\n         #upper, lower = nums[:m], nums[m:]\n         s, e = -1, -1\n         l, u = 0, len(nums)-1\n         if not nums or target > nums[u] or target < nums[l]:\n             return [s, e]\n         m = int((l+u)/2)\n         while u >= l:\n             if nums[m] > target:\n                 if m == u:\n                     break\n                 u = m\n                 #if int((l+u)/2) == u:\n                 #    break\n                 m = int((l+u)/2)\n             elif nums[m] < target:\n                 l = m\n                 if int((l+u)/2) == l:\n                     m = l+1\n                 else:\n                     m = int((l+u)/2)\n             else:\n                 s = e = m\n                 while 0 < s and nums[s-1] == nums[s]:\n                     s-=1\n                 while e < len(nums)-1 and nums[e+1] == nums[e]:\n                     e+=1\n                 break\n         return [s, e]\n", "class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         s, e = -1, -1\n         l, u = 0, len(nums)\n         if not nums or target > nums[u-1] or target < nums[l]:\n             return [s, e]\n         m = (l+u)//2\n         while u > l:\n             if nums[m] > target:\n                 u = m\n                 m = (l+u)//2\n             elif nums[m] < target:\n                 l = m+1\n                 m = (l+u)//2\n             else:\n                 s = e = m\n                 while 0 < s and nums[s-1] == nums[s]:\n                     s-=1\n                 while e < len(nums)-1 and nums[e+1] == nums[e]:\n                     e+=1\n                 break\n         return [s, e]\n", "class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         left = 0; right = len(nums) - 1\n         while left <= right:\n             mid = int((left + right) / 2)\n             if nums[mid] > target:\n                 right = mid - 1\n             elif nums[mid] < target:\n                 left = mid + 1\n             else:\n                 list = [0, 0]\n                 if nums[left] == target: list[0] = left\n                 if nums[right] == target: list[1] = right\n                 for i in range(mid, right+1):\n                     if nums[i] != target: list[1] = i - 1; break\n                 for i in range(mid, left-1, -1):\n                     if nums[i] != target: list[0] = i + 1; break\n                 return list\n         return [-1, -1]", "class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"           \n         def findBoundary(nums, left, right, target):\n             [l_boundary, r_boundary] = [len(nums), -1]\n             middle = int((left+right)/2)\n             if left <= right and nums[left] <= target and nums[right] >= target:\n                 if nums[left] == target:\n                     l_boundary = left\n                 if nums[right] == target:\n                     r_boundary = right\n                 if nums[middle] < target:\n                     [l_boundary, r_boundary] = findBoundary(nums, middle+1, right, target)\n                 elif nums[middle] > target:\n                     [l_boundary, r_boundary] = findBoundary(nums, left, middle, target)\n                 else:\n                     l_boundary = min(findBoundary(nums, left, middle-1, target)[0], middle)\n                     r_boundary = max(findBoundary(nums, middle+1, right, target)[1], middle)\n             return [l_boundary, r_boundary]\n         \n         boundary = findBoundary(nums, 0, len(nums)-1, target)\n         if boundary[1] == -1:\n             return [-1, -1]\n         else:\n             return boundary\n \n                 \n", "class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         # self made, two times binary search, beats 93%\n         if not nums:\n             return [-1, -1]\n         # find left most index\n         l, r = 0, len(nums) - 1\n         while l + 1 < r:\n             mid = l + (r - l) // 2\n             if nums[mid] < target:\n                 l = mid\n             else:\n                 r = mid\n         left = l if nums[l] == target else r\n         # find right most index\n         l, r = 0, len(nums) - 1\n         while l + 1 < r:\n             mid = l + (r - l) // 2\n             if nums[mid] <= target:\n                 l = mid\n             else:\n                 r = mid\n         right = r if nums[r] == target else l\n         if nums[left] != target:\n             return [-1, -1]\n         \n         return [left, right]\n", "class Solution:\n     def getRange(self, nums, index):\n         prev = index - 1 \n         after = index + 1\n         while prev >= 0 and nums[prev] == nums[index]:\n             prev -= 1\n         while after < len(nums) and nums[after] == nums[index]:\n             after += 1\n         return [prev + 1, after -1]\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         if nums == []: return [-1, -1]\n         m = int(len(nums)/2)\n         if target == nums[0]:   return self.getRange(nums, 0)\n         elif target == nums[-1]: return self.getRange(nums, len(nums) -1)\n         elif target == nums[m]: return self.getRange(nums, m)\n         else:\n             if target < nums[0] or target > nums[-1]:   return [-1,-1]\n             elif target < nums[m]:\n                 return self.searchRange(nums[: m], target)\n             else:\n                 tempRange = self.searchRange(nums[m:], target)\n                 if tempRange[0] == -1:  return [-1, -1]\n                 else: return [r + m  for r in tempRange]", "class Solution:\n     def getRange(self, nums, index):\n         prev = index - 1 \n         after = index + 1\n         while prev >= 0 and nums[prev] == nums[index]:\n             prev -= 1\n         while after < len(nums) and nums[after] == nums[index]:\n             after += 1\n         return [prev + 1, after -1]\n     def getIndex(self, nums, target):\n         if nums == [] or target < nums[0] or target > nums[-1]:  return -1\n         if target == nums[0]:  return 0\n         if target == nums[-1]:  return len(nums) -1\n         \n         m = int(len(nums)/2)\n         \n         if target < nums[m]:\n             return self.getIndex(nums[:m], target) \n         else:\n             return -1 if self.getIndex(nums[m: ], target) < 0 else self.getIndex(nums[m: ], target) + m\n             \n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         index = self.getIndex(nums, target)\n         if index == -1: return [-1, -1]\n         else:\n             return self.getRange(nums, index)\n", "class Solution:\n     def getRange(self, nums, index):\n         prev = index\n         after = index\n         while prev >= 0 and nums[prev] == nums[index]:\n             prev -= 1\n         while after < len(nums) and nums[after] == nums[index]:\n             after += 1\n         return [prev + 1, after -1]\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         if nums == []: return [-1, -1]\n         m = int(len(nums)/2)\n         if target == nums[0]:   return self.getRange(nums, 0)\n         elif target == nums[-1]: return self.getRange(nums, len(nums) -1)\n         elif target == nums[m]: return self.getRange(nums, m)\n         else:\n             if target < nums[0] or target > nums[-1]:   return [-1,-1]\n             elif target < nums[m]:\n                 return self.searchRange(nums[: m], target)\n             else:\n                 tempRange = self.searchRange(nums[m:], target)\n                 if tempRange[0] == -1:  return [-1, -1]\n                 else: return [r + m  for r in tempRange]", "class Solution:\n     def searchRange(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: List[int]\n         \"\"\"\n         start = 0\n         end = len(nums) - 1\n         mid = 0\n         ans = [-1, -1]\n         while (start <= end):\n             mid = int((start + end) / 2)\n             if (nums[mid] == target):\n                 ans[0] = mid  \n                 ans[1] = mid  \n                   \n                 i = mid - 1  \n                 while i >= 0 and nums[i] == target:  \n                     ans[0] = i  \n                     i -= 1  \n                   \n                 i = mid + 1  \n                 while i < len(nums) and nums[i] == target:  \n                     ans[1] = i  \n                     i += 1  \n                       \n                 break  \n             elif (nums[mid] > target):\n                 end = mid - 1\n             else:\n                 start = mid + 1\n             \n         return ans\n         \n"]