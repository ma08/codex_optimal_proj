["for q in range(int(input())):\n    n, k, l = map(int, input().split())\n    line = list(map(int, input().split()))\n    line.append(-1000)\n    dp = [[False] * (2 * k) for i in range(n + 2)]\n    for i in range(2 * k):\n        dp[0][i] = True\n    for i in range(1, n + 2):\n        for j in range(2 * k):\n            if j < k and line[i - 1] + j <= l:\n                if dp[i - 1][(j - 1) % (2 * k)]:\n                    dp[i][j] = True\n                elif dp[i][(j - 1) % (2 * k)]:\n                    dp[i][j] = True\n            if j >= k and line[i - 1] + 2 * k - j <= l:\n                if dp[i - 1][j - 1]:\n                    dp[i][j] = True\n                elif dp[i][j - 1]:\n                    dp[i][j] = True\n    if max(dp[n + 1]) == True:\n        print(\"Yes\")\n    else:\n        print(\"No\")", "#\n#    ------------------------------------------------\n#           ____          _     Generatered using\n#          / ___|        | |\n#         | |    __ _  __| | ___ _ __  ______ _\n#         | |   / _` |/ _` |/ _ \\ '_ \\|_  / _` |\n#         | |__| (_| | (_| |  __/ | | |/ / (_| |\n#          \\____\\____|\\____|\\___|_| |_/___\\____|\n#\n#      GNU Affero General Public License v3.0\n#    ------------------------------------------------\n#    Author   : prophet\n#    Created  : 2020-07-24 11:18:32.110309\n#    UUID     : dhIFbAnMq2yrA0IR\n#    ------------------------------------------------\n#\nproduction = True\n\nimport sys, math, collections\n\ndef input(input_format = 0, multi = 0):\n\n    if multi > 0: return [input(input_format) for i in range(multi)]\n    else:\n        next_line = sys.stdin.readline()[:-1]\n\n        if input_format >= 10:\n            use_list = False\n            input_format = int(str(input_format)[-1])\n        else: use_list = True\n\n        if input_format == 0: formatted_input = [next_line]\n        elif input_format == 1: formatted_input = list(map(int, next_line.split()))\n        elif input_format == 2: formatted_input = list(map(float, next_line.split()))\n        elif input_format == 3: formatted_input = list(next_line)\n        elif input_format == 4: formatted_input = list(map(int, list(next_line)))\n        elif input_format == 5: formatted_input = next_line.split()\n        else: formatted_input = [next_line]\n\n        return formatted_input if use_list else formatted_input[0]\n\ndef out(output_line, output_format = 0, newline = True):\n\n    formatted_output = \"\"\n\n    if output_format == 0: formatted_output = str(output_line)\n    elif output_format == 1: formatted_output = \" \".join(map(str, output_line))\n    elif output_format == 2: formatted_output = \"\\n\".join(map(str, output_line))\n    elif output_format == 3: formatted_output = \"\".join(map(str, output_line))\n\n    print(formatted_output, end = \"\\n\" if newline else \"\")\n\ndef log(*args):\n    if not production:\n        print(\"$$$\", end = \"\")\n        print(*args)\n\nenu = enumerate\nter = lambda a, b, c: b if a else c\nceil = lambda a, b: -(-a // b)\nflip = lambda a: (a + 1) & 1\n\ndef mapl(iterable, format = 0):\n    \n    if format == 0: return list(map(int, iterable))\n    elif format == 1: return list(map(str, iterable))\n    elif format == 2: return list(map(list, iterable))\n#\n#   >>>>>>>>>>>>>>> START OF SOLUTION <<<<<<<<<<<<<<\n#\n\n\ndef solve():\n\n    n, k, l = input(1)\n    d = input(1)\n\n    log(k, l)\n    log(d)\n\n    f = [l - i for i in d]\n\n    log(f)\n\n    t =  list(range(k, -1, -1)) + list(range(1, k))\n    log(\"t\", t)\n    p = [(0, 2 * k - 1)]\n\n    for i in f:\n        a, b = p[-1]\n        if i >= k:\n            p.append((0, 2 * k - 1))\n        else:\n            fb = k + i\n            fa = max(a + 1, k - i)\n            log(i, fb, fa)\n            if fb < fa:\n                out(\"No\")\n                return\n\n            p.append((fa, fb))\n        log(p)\n    else:\n        out(\"Yes\")\n\n    log(\"\")\n    return\n\n\nfor i in range(input(11)): solve()\n\n#\n#   >>>>>>>>>>>>>>>> END OF SOLUTION <<<<<<<<<<<<<<<\n#\n", "t = int(input())\nfor _ in range(t):\n    n, k, l = list(map(int, input().split()))\n    d = list(map(int, input().split()))\n    p = list(range(k)) + list(range(k, 0, -1))\n\n    pos = list(range(2*k))\n    ans = 'Yes'\n    for i in range(n):\n        new_pos = []\n        for t in pos:\n            j = 1\n            for j in range(1, 2*k + 1):\n                if d[i] + p[(t+j) % (2*k)] > l:\n                    break\n                new_pos.append((t+j) % (2*k))\n        pos = list(set(new_pos))\n        if len(pos) == 0:\n            ans = 'No'\n    print(ans)\n", "for _ in range(int(input())):\n    n, k, l = list(map(int, input().split()))\n    dd = list(map(int, input().split()))\n    t = 0\n    curld = 0\n    di = False\n    for d in [-(2**30), *dd]:\n        if d > l:\n            break\n        ld = l - d\n        if d + k <= l:\n            curld = ld\n            di = False\n            continue\n        if di:\n            if ld >= curld + 1:\n                curld += 1\n            else:\n                break\n        else:\n            curld = min(curld - 1, ld)\n            if curld == 0:\n                di = True\n    else:\n        print('Yes')\n        continue\n    print('No')\n", "import sys\ninput = sys.stdin.readline\n \nt = int(input())\nletters = 'abcdefghijklmnopqrst'\n \nfor _ in range(t):\n\n    n,k,l = list(map(int,input().split()))\n    d = list(map(int,input().split()))\n    \n    ll = []\n    \n    tot = len(d)\n    \n    while len(d) > 0:\n        ddd = []\n        c= 0 \n        for el in d:\n            ddd.append(el)\n            c += 1\n            if el + k <= l:\n                d = d[c:]\n                break\n        \n        for j in range(2*k):\n            ok = 1\n            for s in range(len(ddd)):\n                modif = (j + s + 1) % (2*k)\n                modif = min(modif, 2*k - modif)\n                \n                depth = ddd[s] + modif\n                #if j==3:\n                #    print(depth, j)\n                if depth > l:\n                    ok = 0\n                    \n            if ok==1:\n                break\n            \n        ll.append(ok)\n        \n        if len(d)==tot:\n            break\n        \n        tot = len(d)\n    \n    if min(ll) == 1:\n        print('Yes')\n    else:\n        print('No')\n    \n", "inp = lambda : map(int, input().split())\nt = int(input())\nfor _ in range(t):\n    n, k, l = inp()\n    d = list(inp())\n    remain = [i for i in range((-1) * (k - 1), 0)] + [i for i in range(k + 1)]\n    f = True\n    for i in range(n):\n        #print(remain)\n        f = False\n        new_remain = []\n        for j in range(len(remain)):\n            temp = (remain[j] + 1)\n            if temp > k:\n                temp = - k + 1\n            if abs(temp) + d[i] <= l:\n                f = True\n                new_remain.append(temp)\n        if not f:\n            print(\"No\")\n            break\n        remain = []\n        flag = False if k + d[i] > l else True\n        for j in range(1 - k, k + 1):\n            if j in new_remain:\n                flag = True\n            if abs(j) + d[i] <= l and flag:\n                remain.append(j)\n            if abs(j) + d[i] > l:\n                flag = False\n        \n    if f:\n        print(\"Yes\")", "T = int(input())\nfor _ in range(T):\n    N,K,L = list(map(int,input().split()))\n    D = list(map(int,input().split()))\n    P = list(range(K)) + list(range(K,0,-1))\n    dp = [[0]*(len(P)) for _ in range(N+1)]\n    for i in range(len(P)):\n        dp[0][i] = 1\n    for i in range(N):\n        for _ in range(2):\n            for j in range(len(P)):\n                if dp[i][j]==0: continue\n                if i and dp[i][(j+1)%len(P)]==0 and D[i-1] + P[(j+1)%len(P)] <= L:\n                    dp[i][(j+1)%len(P)] = 1\n                if D[i] + P[(j+1)%len(P)] <= L:\n                    dp[i+1][(j+1)%len(P)] = 1\n    print('No' if all(a==0 for a in dp[-1]) else 'Yes')\n", "def go(n, k, l, d):\n    p = [0] * (2 * k)\n    for t in range(0, 2 * k):\n        if t <= k:\n            p[t] = t\n        else:\n            p[t] = 2 * k - t\n\n    h = []\n    for x in range(n):\n        h_x = [0] * (2 * k)\n        for t in range(0, 2 * k):\n            h_x[t] = d[x] + p[t]\n        h.append(h_x)\n\n    dp = []\n    for x in range(n):\n        dp.append([False] * (2 * k))\n    for t in range(0, 2 * k):\n        if h[0][t] <= l:\n            dp[0][t] = True\n        else:\n            dp[0][t] = False\n    #print(dp)\n    for x in range(1, n):\n        for t in range(0, 2 * k):\n            if dp[x-1][(t-1)%(2*k)] and h[x-1][(t-1)%(2*k)] <= l and h[x][t] <= l:\n                dp[x][t] = True\n        for t in range(0, 2 * k):\n            if dp[x][(t-1)%(2*k)] and h[x][(t-1)%(2*k)] <= l and h[x][t] <= l:\n                dp[x][t] = True\n\n    #print(dp)\n    for t in range(0, 2 * k):\n        if dp[n-1][t]:\n            return True\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n, k ,l = map(int, input().split())\n    d = list(map(int, input().split()))\n\n    if go(n, k, l, d):\n        print(\"Yes\")\n    else:\n        print(\"No\")", "import sys\nimport math \nfrom decimal import *\ndef I(): return int(sys.stdin.readline())\ndef IL(): return list(map(int,sys.stdin.readline().strip().split()))\ndef ILS(): return list(map(str,sys.stdin.readline().strip().split()))\n\n\n\n\n\n\ndef solve():\n\ttt = I()\n\tfor ii in range(tt):\n\t\tn,k,l = IL()\n\t\td = IL()\n\t\ttmp = []\n\t\tkl = []\n\t\tfor i in range(k+1):\n\t\t\ttmp.append(0);\n\t\tfor i in range(k-1,0,-1):\n\t\t\ttmp.append(0)\n\t\tdp = [tmp.copy() for dd in d]\n\t\t# print(dp)\n\t\tfor i in range(k+1):\n\t\t\tkl.append(i);\n\t\tfor i in range(k-1,0,-1):\n\t\t\tkl.append(i)\n\n\t\tfor i in range(len(tmp)):\n\t\t\tif d[0] + kl[i] <= l : dp[0][i] = 1\n\t\t\telse : dp[0][i] = 0\n\t\tfor i in range(1,len(d)):\n\t\t\tfor j in range(len(dp[i])):\n\t\t\t\tk = j-1\n\t\t\t\tif k <0 : k = len(dp[i])-1\n\t\t\t\tif d[i]+kl[j] <= l : \n\t\t\t\t\tdp[i][j] = 1 if dp[i-1][k]+dp[i][k] > 0 else 0\n\t\t\t\telse : dp[i][j] = 0\n\t\t\t\t\n\t\t# print(dp)\n\t\t# for pp in dp :\n\t\t# \tprint(pp)\n\t\tflag = 0\n\t\tfor i in range(len(dp[-1])):\n\t\t\tif dp[-1][i] == 1 : flag = 1; break;\n\t\tif flag == 1 : print(\"Yes\")\n\t\telse : print(\"No\")\n\t\t# cal(d,-1)\n\t\tpass\n\nsolve()", "import sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 19\nMOD = 10 ** 9 + 7\n\ndef bfs(grid, src):\n    from collections import deque\n\n    H, W = len(grid), len(grid[0])\n    visited = list3d(2, H, W, 0)\n    que = deque()\n    for h, w in src:\n        que.append((0, h, w))\n        que.append((1, h, w))\n        visited[0][h][w] = 1\n        visited[1][h][w] = 1\n    while que:\n        up, h, w = que.popleft()\n        if w == N-1:\n            return True\n        if h == 0:\n            up = 1\n        if h == K:\n            up = 0\n        if up:\n            if not visited[up][h+1][w] and grid[h+1][w] <= L:\n                visited[up][h+1][w] = 1\n                que.append((up, h+1, w)) \n            if not visited[up][h+1][w+1] and grid[h+1][w+1] <= L:\n                visited[up][h+1][w+1] = 1\n                que.append((up, h+1, w+1))\n        else:\n            if not visited[up][h-1][w]:\n                visited[up][h-1][w] = 1\n                que.append((up, h-1, w))\n            if not visited[up][h-1][w+1] and grid[h-1][w+1] <= L:\n                visited[up][h-1][w+1] = 1\n                que.append((up, h-1, w+1))\n    return False\n\nfor _ in range(INT()):\n    N, K, L = MAP()\n    A = LIST()\n\n    grid = list2d(K+1, N, 0)\n    for i in range(K+1):\n        for j in range(N):\n            grid[i][j] = A[j] + i\n\n    src = []\n    for i in range(K+1):\n        if grid[i][0] <= L:\n            src.append((i, 0))\n    ok = False\n    for x in range(K+1):\n        if bfs(grid, src):\n            Yes()\n            break\n    else:\n        No()\n"]