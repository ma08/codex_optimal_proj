["from collections import defaultdict\nm = 1000000007\n\nf = [0] * 15001\nf[0] = 1\nfor i in range(1, 15001): f[i] = (f[i - 1] * i) % m\n\ndef c(n, k): return (f[n] * pow((f[k] * f[n - k]) % m, m - 2, m)) % m\ndef prime(n):\n    m = int(n ** 0.5) + 1\n    t = [1] * (n + 1)\n    for i in range(3, m):\n        if t[i]: t[i * i :: 2 * i] = [0] * ((n - i * i) // (2 * i) + 1)\n    return [2] + [i for i in range(3, n + 1, 2) if t[i]]\n\np = prime(31650)\ns = defaultdict(int)\n\ndef g(n):\n    for j in p:\n        while n % j == 0:\n            n //= j\n            s[j] += 1\n        if j * j > n:\n            s[n] += 1\n            break\n\nn = int(input()) - 1\na = list(map(int, input().split()))\n\nfor i in a: g(i)\nif 1 in s: s.pop(1)\n\nd = 1\nfor k in list(s.values()): d = (d * c(k + n, n)) % m\nprint(d)\n", "Mod = 1000000007\nMAX = 33000\nn = int( input() )\nA = list( map( int, input().split() ) )\n\nB = [0] * MAX\nbePrime = [0] * MAX;\nprimNum = []\nC = []\n\nfac=[1]\nfor j in range(1, MAX):\n    fac.append( fac[-1] * j % Mod )\n\ndef calc( M, N ):\n    return fac[M] * pow( fac[N] * fac[M-N] % Mod, Mod-2,Mod ) % Mod\n\nfor j in range(2, MAX):\n    if bePrime[j] == 0: \n        primNum.append( j )\n        i = j\n        while i < MAX:\n            bePrime[i] = 1\n            i = i + j\n\nfor x in A:\n    tmp = x\n    for j in primNum:\n        while tmp % j == 0:\n            tmp /= j\n            B[j] += 1\n    if tmp > 1:\n        C.append( tmp )\n\nans = 1\n\nfor j in range(2,MAX): \n    if B[j] > 0:\n        ans = ans * calc( n + B[j] -1 , n - 1 ) % Mod\n\nl = len( C )\nfor j in range(0, l ):\n    num= 0;\n    for k in range(0, l ):\n        if C[k] == C[j]:\n            num = num + 1\n            if k > j:\n                num = 0\n                break\n    if num > 0:\n        ans = ans * calc( n + num -1, n - 1 ) % Mod\n\nprint( str( ans % Mod ) )\n", "from math import sqrt, factorial as f\nfrom collections import Counter\nfrom operator import mul\nfrom functools import reduce\n\n\ndef comb(n, m):\n    o = n - m\n    if m and o:\n        if m < o:\n            m, o = o, m\n        return reduce(mul, list(range(m + 1, n)), n) // f(o)\n    return 1\n\n\ndef main():\n    n = int(input())\n    aa = list(map(int, input().split()))\n    if n == 1:\n        print(1)\n        return\n    lim = int(sqrt(max(aa)) // 6) + 12\n    sieve = [False, True, True] * lim\n    lim = lim * 3 - 1\n    for i, s in enumerate(sieve):\n        if s:\n            p, pp = i * 2 + 3, (i + 3) * i * 2 + 3\n            le = (lim - pp) // p + 1\n            if le > 0:\n                sieve[pp::p] = [False] * le\n            else:\n                break\n    sieve[0] = sieve[3] = True\n    primes = [i * 2 + 3 for i, f in enumerate(sieve) if f]\n    for i, p in enumerate((2, 3, 5, 7)):\n        primes[i] = p\n    del sieve\n    c = Counter()\n    for x in aa:\n        for p in primes:\n            cnt = 0\n            while not x % p:\n                x //= p\n                cnt += 1\n            if cnt:\n                c[p] += cnt\n                if x == 1:\n                    break\n        if x > 1:\n            c[x] += 1\n    x, inf = 1, 1000000007\n    for p, cnt in list(c.items()):\n        x = x * comb(cnt + n - 1, n - 1) % inf\n    print(x)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# Made By Mostafa_Khaled \nbot = True \nMod = 1000000007\n\nMAX = 33000\n\nn = int( input() )\n\nA = list( map( int, input().split() ) )\n\n\n\nB = [0] * MAX\n\nbePrime = [0] * MAX;\n\nprimNum = []\n\nC = []\n\n\n\nfac=[1]\n\nfor j in range(1, MAX):\n\n    fac.append( fac[-1] * j % Mod )\n\n\n\ndef calc( M, N ):\n\n    return fac[M] * pow( fac[N] * fac[M-N] % Mod, Mod-2,Mod ) % Mod\n\n\n\nfor j in range(2, MAX):\n\n    if bePrime[j] == 0: \n\n        primNum.append( j )\n\n        i = j\n\n        while i < MAX:\n\n            bePrime[i] = 1\n\n            i = i + j\n\n\n\nfor x in A:\n\n    tmp = x\n\n    for j in primNum:\n\n        while tmp % j == 0:\n\n            tmp /= j\n\n            B[j] += 1\n\n    if tmp > 1:\n\n        C.append( tmp )\n\n\n\nans = 1\n\n\n\nfor j in range(2,MAX): \n\n    if B[j] > 0:\n\n        ans = ans * calc( n + B[j] -1 , n - 1 ) % Mod\n\n\n\nl = len( C )\n\nfor j in range(0, l ):\n\n    num= 0;\n\n    for k in range(0, l ):\n\n        if C[k] == C[j]:\n\n            num = num + 1\n\n            if k > j:\n\n                num = 0\n\n                break\n\n    if num > 0:\n\n        ans = ans * calc( n + num -1, n - 1 ) % Mod\n\n\n\nprint( str( ans % Mod ) )\n\n\n\n# Made By Mostafa_Khaled\n", "MOD = 10**9+7\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n\n        if (prime[p] == True):\n\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n\n    l = []\n    for p in range(2, n):\n        if prime[p]:\n            l.append(p)\n    return l\n\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,p - 2, p)) % p\n\n\nprimes = SieveOfEratosthenes(31623)\nn = int(input())\nl = [int(zax) for zax in input().split()]\n\nmap = {}\nfor x in l:\n    for p in primes:\n        if p>x:\n            break\n        if x%p==0:\n            check = False\n            while x%p==0:\n                if p in map:\n                    map[p]+=1\n                else:\n                    map[p]=1\n                x//=p\n    if x!=1:\n        if x in map:\n            map[x]+=1\n        else:\n            map[x]=1\n\ncount = 1\nfor x in map:\n    count *= ncr(n-1+map[x],n-1,MOD)\n    count %= MOD\n\ncount %= MOD\nprint(count)", "Mod = 1000000007\n \nMAX = 33000\n \nn = int( input() )\n \nA = list( map( int, input().split() ) )\n \n \n \nB = [0] * MAX\n \nbePrime = [0] * MAX;\n \nprimNum = []\n \nC = []\n \n \n \nfac=[1]\n \nfor j in range(1, MAX):\n \n    fac.append( fac[-1] * j % Mod )\n \n \n \ndef calc( M, N ):\n \n    return fac[M] * pow( fac[N] * fac[M-N] % Mod, Mod-2,Mod ) % Mod\n \n \n \nfor j in range(2, MAX):\n \n    if bePrime[j] == 0: \n \n        primNum.append( j )\n \n        i = j\n \n        while i < MAX:\n \n            bePrime[i] = 1\n \n            i = i + j\n \n \n \nfor x in A:\n \n    tmp = x\n \n    for j in primNum:\n \n        while tmp % j == 0:\n \n            tmp /= j\n \n            B[j] += 1\n \n    if tmp > 1:\n \n        C.append( tmp )\n \n \n \nans = 1\n \n \n \nfor j in range(2,MAX): \n \n    if B[j] > 0:\n \n        ans = ans * calc( n + B[j] -1 , n - 1 ) % Mod\n \n \n \nl = len( C )\n \nfor j in range(0, l ):\n \n    num= 0;\n \n    for k in range(0, l ):\n \n        if C[k] == C[j]:\n \n            num = num + 1\n \n            if k > j:\n \n                num = 0\n \n                break\n \n    if num > 0:\n \n        ans = ans * calc( n + num -1, n - 1 ) % Mod\n \n \n \nprint( str( ans % Mod ) )\n", "# Design_by_JOKER\nimport math\nimport cmath\n\nMod = 1000000007\n\nMAX = 33000\n\nn = int(input())\n\nA = list(map(int, input().split()))\n\nB = [0] * MAX\n\nbePrime = [0] * MAX;\n\nprimNum = []\n\nC = []\n\nfac = [1]\n\nfor j in range(1, MAX):\n    fac.append(fac[-1] * j % Mod)\n\n\ndef calc(M, N):\n    return fac[M] * pow(fac[N] * fac[M - N] % Mod, Mod - 2, Mod) % Mod\n\n\nfor j in range(2, MAX):\n\n    if bePrime[j] == 0:\n\n        primNum.append(j)\n\n        i = j\n\n        while i < MAX:\n            bePrime[i] = 1\n\n            i = i + j\n\nfor x in A:\n\n    tmp = x\n\n    for j in primNum:\n\n        while tmp % j == 0:\n            tmp /= j\n\n            B[j] += 1\n\n    if tmp > 1:\n        C.append(tmp)\n\nans = 1\n\nfor j in range(2, MAX):\n\n    if B[j] > 0:\n        ans = ans * calc(n + B[j] - 1, n - 1) % Mod\n\nl = len(C)\n\nfor j in range(0, l):\n\n    num = 0;\n\n    for k in range(0, l):\n\n        if C[k] == C[j]:\n\n            num = num + 1\n\n            if k > j:\n                num = 0\n\n                break\n\n    if num > 0:\n        ans = ans * calc(n + num - 1, n - 1) % Mod\n\nprint(str(ans % Mod))\n", "from math import factorial as f\ndef primes(n):\n    sieve = [True] * n\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)\n    return [2] + [i for i in range(3,n,2) if sieve[i]]\np = primes(31627)\ns = [0]*(31623)\ns1={}\ndef factorize(n):\n  for i in p:\n    if n<=1:\n      return 56\n    while n%i==0:\n      s[p.index(i)]+=1\n      n//=i\n  if n>1:\n    if n in s1:\n      s1[n]+=1\n    else:\n      s1[n]=1\nn = int(input())\nfor i in map(int,input().split()):\n  factorize(i)\ns = list(filter(lambda a: a != 0, s))\nfor i in s1.values():\n  s.append(i)\nans = 1\nfor i in s:\n  ans*=f(i+n-1)//(f(n-1)*f(i))\nprint(int(ans)%1000000007)", "from math import factorial as f\ndef primes(n):\n    sieve = [True] * n\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)\n    return [2] + [i for i in range(3,n,2) if sieve[i]]\np = primes(31627)\ns = [0]*(31623)\ns1={}\ndef factorize(n):\n  for i in p:\n    if n<=1:\n      return 56\n    while n%i==0:\n      s[p.index(i)]+=1\n      n//=i\n  if n>1:\n    if n in s1:\n      s1[n]+=1\n    else:\n      s1[n]=1\nn = int(input())\nfor i in map(int,input().split()):\n  factorize(i)\ns = list(filter(lambda a: a != 0, s))\nfor i in s1.values():\n  s.append(i)\nans = 1\nfor i in s:\n  ans*=f(i+n-1)//(f(n-1)*f(i))\nprint(int(ans)%1000000007)", "from math import factorial as f\ndef primes(n):\n    sieve = [True] * n\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)\n    return [2] + [i for i in range(3,n,2) if sieve[i]]\np = primes(31627)\ns = [0]*(31623)\ns1={}\ndef factorize(n):\n  for i in p:\n    if n<=1:\n      return 56\n    while n%i==0:\n      s[p.index(i)]+=1\n      n//=i\n  if n>1:\n    if n in s1:\n      s1[n]+=1\n    else:\n      s1[n]=1\nn = int(input())\nfor i in map(int,input().split()):\n  factorize(i)\ns = list(filter(lambda a: a != 0, s))\nfor i in s1.values():\n  s.append(i)\nans = 1\nfor i in s:\n  ans*=f(i+n-1)//(f(n-1)*f(i))\nprint(int(ans)%1000000007)", "f=[1]*15001\nfi=[1]*15001\na=1\nb=1\nm=10**9+7\nfrom collections import defaultdict\nfor i in range(1,15001):\n    a*=i\n    b*=pow(i,m-2,m)\n    a%=m\n    b%=m\n    f[i]=a\n    fi[i]=b\nd=defaultdict(int)\ndef factorize(n): \n    count = 0;  \n    while ((n % 2 > 0) == False):  \n          \n        # equivalent to n = n / 2; \n        n >>= 1;  \n        count += 1; \n    if (count > 0): \n        d[2]+=count \n    for i in range(3, int(n**0.5) + 1): \n        count = 0; \n        while (n % i == 0):  \n            count += 1; \n            n = int(n / i); \n        if (count > 0): \n            d[i]+=count \n        i += 2; \n  \n    # if n at the end is a prime number. \n    if (n > 2): \n        d[n]+=1\nans=1\nn=int(input())\nl=list(map(int,input().split()))\nfor i in l:\n    factorize(i)\nfor i in d:\n    ans*=(f[d[i]+n-1]*fi[n-1]*fi[d[i]])%m\n    ans%=m\nprint(ans)\n        \n\n    \n", "import math\nimport sys\ninput=sys.stdin.readline\n \np=(10**9)+7\npri=p\nfac=[1 for i in range((10**6)+1)]\nfor i in range(2,len(fac)):\n    fac[i]=(fac[i-1]*(i%pri))%pri\ndef modi(x):\n    return (pow(x,p-2,p))%p;\n    \ndef ncr(n,r):\n    x=(fac[n]*((modi(fac[r])%p)*(modi(fac[n-r])%p))%p)%p\n    return x;\n\ndef prime(x):\n    ans=[]\n    while(x%2==0):\n        x=x//2\n        ans.append(2)\n    for i in range(3,int(math.sqrt(x))+1,2):\n        while(x%i==0):\n            ans.append(i)\n            x=x//i\n    if(x>2):\n        ans.append(x)\n\n    return ans;\n\n\n\nn=int(input())\n\nz=list(map(int,input().split()))\nans=[]\nfor i in range(len(z)):\n    m=prime(z[i])\n    ans.extend(m)\n  \nans.sort()\nif(ans.count(1)==len(ans)):\n    print(1)\n    return\ncn=[]\ncount=1\nfor i in range(1,len(ans)):\n    if(ans[i]==ans[i-1]):\n        count+=1\n    else:\n        cn.append(count)\n        count=1\ncn.append(count)\nal=1\n\nfor i in range(len(cn)):\n    al=al*ncr(n+cn[i]-1,n-1)\n    al%=pri\nprint(al)\n    \n    \n"]