["n, m = [int(i) for i in input().split()]\nif m > n//2:\n    m = n-m\nans = [1]\ncount = 0\nc = 1\nfor i in range(n):\n    count+=m\n    if count>n:\n        c+=1\n        count-=n\n        ans.append(ans[-1] +c)\n        c+=1\n    else:\n        ans.append(ans[-1] +c)\nans = ans[1:]\nprint(*ans)", "\n\n\ndef __starting_point():\n    n,k = list(map(int, input().strip().split()))\n\n    if k > n//2:\n        k = n - k\n\n    intersection = n * [0]\n\n    count = 1\n\n    done = False\n    i=0\n    result = []\n    for i in range(1,n+1):\n        nn = (i*k) // n\n        j = (i*k)%n\n        if j < k:\n            count += (2*nn )\n        else:\n            count += (2*nn +1)\n        result.append(count)\n\n    result[-1] -= 1\n    print(\" \".join([str(r) for r in result]))\n\n\n\n\n\n\n\n\n__starting_point()", "n, k = list(map(int, input().split()))\nif n // 2 < k:\n    k = n - k\ni = 1\ncount = 1\nans = [1]\nfor _ in range(n):\n    i += k\n    if i > n + 1:\n        count += 1\n        ans.append(ans[-1] + count)\n        count += 1\n        i -= n\n    else:\n        ans.append(ans[-1] + count)\nprint(*ans[1:])\n", "n, k = list(map(int, input().split()))\nif n // 2 < k:\n    k = n - k\ni = 1\ncount = 1\nans = [1]\nfor _ in range(n):\n    i += k\n    if i > n + 1:\n        count += 1\n        ans.append(ans[-1] + count)\n        count += 1\n        i -= n\n    else:\n        ans.append(ans[-1] + count)\nprint(*ans[1:])\n", "# input = raw_input\n# range = xrange\n\nclass Fen:\n\tdef __init__(self, n):\n\t\tself.value = [0] * n\n\tdef get(self, fro, to):\n\t\treturn self.get1(to) - self.get1(fro - 1)\n\tdef get1(self, to):\n\t\tto = min(to, len(self.value))\n\t\tresult = 0\n\t\twhile to >= 0:\n\t\t\tresult += self.value[to]\n\t\t\tto = (to & (to + 1)) - 1\n\t\treturn result\n\tdef add(self, at, value):\n\t\twhile at < len(self.value):\n\t\t\tself.value[at] += value\n\t\t\tat = at | (at + 1)\n\ndef solve():\n\tn, k = map(int, input().split())\n\tk = min(k, n - k)\n\tcount = [0] * n\n\tres = [None] * n\n\tans = 1\n\tcur = 0\n\tfen = Fen(n)\n\tfor iteration in range(n):\n\t\tnxt = (cur + k) % n\n\t\there = 0\n\t\tif cur < nxt:\n\t\t\there = fen.get(cur + 1, nxt - 1)\n\t\telse:\n\t\t\there = fen.get(0, nxt - 1) + fen.get(cur + 1, n - 1)\n\t\tfen.add(cur, 1)\n\t\tfen.add(nxt, 1)\n\t\tcur = nxt\n\t\tans += here + 1\n\t\tres[iteration] = ans\n\tprint(\" \".join(map(str, res)))\n\nsolve()", "def __starting_point():\n    n,k = list(map(int, input().strip().split()))\n\n    if k > n//2:\n        k = n - k\n\n    intersection = n * [0]\n\n    count = 1\n\n    done = False\n    i=0\n    result = []\n    for i in range(1,n+1):\n        nn = (i*k) // n\n        j = (i*k)%n\n        if j < k:\n            count += (2*nn )\n        else:\n            count += (2*nn +1)\n        result.append(count)\n\n    result[-1] -= 1\n    print(\" \".join([str(r) for r in result]))\n\n__starting_point()", "import sys\n\ninf = (1 << 31) - 1\n\ndef solve():\n    n, k = map(int, input().split())\n\n    if k > n - k:\n        k = n - k\n\n    bit = BinaryIndexedTree([0]*n)\n\n    s = 0\n    res = 1\n    ans = []\n\n    for i in range(n):\n        t = (s + k) % n\n\n        if s < t:\n            res += bit.get_sum(t) - bit.get_sum(s + 1) + 1\n            ans.append(res)\n        else:\n            res += bit.get_sum(n) - bit.get_sum(s + 1)\n            res += bit.get_sum(t) + 1\n            ans.append(res)\n\n        bit.add(s, 1)\n        bit.add(t, 1)\n\n        s = t\n\n    print(*ans)\n\nclass BinaryIndexedTree:\n    ''' 1-origin Binary Indexed Tree '''\n\n    def __init__(self, a):\n        self.n = len(a)\n        self.bit = [0]*(self.n + 1)\n\n        for i in range(1, self.n + 1):\n            self.bit[i] += a[i - 1]\n\n            if i + (i & (-i)) <= self.n:\n                self.bit[i + (i & (-i))] += self.bit[i]\n\n    def add(self, i, x):\n        ''' a_i += x '''\n        i += 1 # 0-origin -> 1-origin\n\n        while i <= self.n:\n            self.bit[i] += x\n            i += i & (-i)\n\n    def get_sum(self, r):\n        ''' sum(a[0 .. r)) '''\n        res = 0\n\n        while r > 0:\n            res += self.bit[r]\n            r -= r & (-r)\n\n        return res\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\n\ninf = (1 << 31) - 1\n\ndef solve():\n    n, k = map(int, input().split())\n\n    if k > n - k:\n        k = n - k\n\n    s = 0\n    res = 1\n    a = 1\n    ans = [0]*n\n\n    for i in range(n):\n        t = (s + k) % n\n\n        if t < s and t > 0:\n            res += a + 1\n            a += 2\n        else:\n            res += a\n\n        ans[i] = res\n\n        s = t\n\n    print(*ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\n\ninf = (1 << 31) - 1\n\ndef solve():\n    n, k = map(int, input().split())\n\n    if k > n - k:\n        k = n - k\n\n    s = 0\n    res = 1\n    a = 1\n    ans = [0]*n\n\n    for i in range(n):\n        t = (s + k) % n\n\n        if t < s and t > 0:\n            res += a + 1\n            a += 2\n        else:\n            res += a\n\n        ans[i] = res\n\n        s = t\n\n    print(*ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "l=input().split()\nn=int(l[0])\nk=int(l[1])\ncurr=0\nans=1\nif(k>n//2):\n    k=n-k\nfor i in range(n):\n    curr+=k\n    if(i==n-1):\n        ans=ans+2*(curr//n)-1\n    elif(curr%n<k):\n        ans=ans+2*((curr)//n)\n    else:\n        ans=ans+2*((curr)//n)+1\n    print(ans,end=\" \")\n"]