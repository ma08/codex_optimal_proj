["n = int(input())\na = input()\ns = input()\nd1, d2 = [], []\nfor q in range(n):\n    if a[q] == 'a' and s[q] == 'b':\n        d1.append(q+1)\n    elif a[q] == 'b' and s[q] == 'a':\n        d2.append(q+1)\nif (len(d1)+len(d2)) % 2 == 1:\n    print(-1)\nelse:\n    print((len(d1)+len(d2))//2+len(d1) % 2)\n    for q in range(1, len(d1), 2):\n        print(d1[q-1], d1[q])\n    for q in range(1, len(d2), 2):\n        print(d2[q-1], d2[q])\n    if len(d1) % 2 == 1:\n        print(d1[-1], d1[-1])\n        print(d1[-1], d2[-1])\n", "n =  int(input())\ns = input()\nt = input()\na, b = [], []\nfor i in range(n):\n    if(s[i] != t[i]):\n        if(s[i] == 'a'):\n            a.append(i+1)\n        else:\n            b.append(i+1)\nm = len(a) + len(b)\nif(m&1):\n    print(-1)\nelse:\n    ans = m//2\n    if(len(a)&1):\n        ans += 1\n    print(ans)\n    if(len(a)&1):\n        print(a[-1], a[-1])\n        print(a[-1], b[-1])\n    for i in range(0, len(a)-1, 2):\n        # print(i)\n        print(a[i], a[i+1])\n    for i in range(0, len(b)-1, 2):\n        print(b[i], b[i+1])\n", "n = int(input())\ns = input()\nt = input()\nlenS = len(s)\nta = []\ntb = []\nlenTa = lenTb = 0\nres = []\n\nfor i in range(lenS):\n    if s[i] != t[i]:\n        if t[i] == 'a':\n            ta.append(i)\n            lenTa += 1\n        else:\n            tb.append(i)\n            lenTb += 1\n\nwhile lenTa > 1:\n    res.append((ta[-1], ta[-2]))\n    ta.pop()\n    ta.pop()\n    lenTa -= 2\n\nwhile lenTb > 1:\n    res.append((tb[-1], tb[-2]))\n    tb.pop()\n    tb.pop()\n    lenTb -= 2\n\nif lenTa and lenTb:\n    res.append((ta[-1], ta[-1]))\n    res.append((ta[-1], tb[-1]))\n    \n    print(len(res))\n    \n    for i in res:\n        print(i[0]+1, i[1]+1)\nelif lenTa or lenTb:\n    print(-1)\nelse:\n    print(len(res))\n    \n    for i in res:\n        print(i[0]+1, i[1]+1)", "import math\nimport sys\nimport collections\n\n\n# imgur.com/Pkt7iIf.png\n\ndef getdict(n):\n    d = {}\n    if type(n) is list:\n        for i in n:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n    else:\n        for i in range(n):\n            t = ii()\n            if t in d:\n                d[t] += 1\n            else:\n                d[t] = 1\n    return d\ndef sieve(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = prime[1] = False\n    r = [p for p in range(n + 1) if prime[p]]\n    return r\ndef cdiv(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return map(int, input().split())\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep = ' '): print(sep.join(map(str, a)))\n\nn = ii()\ns = input()\nt = input()\nif (s.count('a') + t.count('a'))%2:\n    print(-1);return()\n\nab = []\nba = []\nfor i in range(n):\n    if s[i] == 'a' and t[i] == 'b':\n        ab.append(i + 1)\n    elif s[i] == 'b' and t[i] == 'a':\n        ba.append(i + 1)\n\nr = []\nwhile len(ab) >= 2:\n    v = ab.pop()\n    u = ab.pop()\n    r.append(f'{u} {v}')\nwhile len(ba) >= 2:\n    v = ba.pop()\n    u = ba.pop()\n    r.append(f'{u} {v}')\n\nif len(ab) != len(ba):\n    print(-1);return()\nelif len(ab) > 0:\n    u = ab[0]\n    v = ba[0]\n    r.append(f'{u} {u}')\n    r.append(f'{u} {v}')\n\nprint(len(r))\nfor i in r:\n    print(i)", "n = int(input())\na = [int(c == 'b') for c in input()]\nb = [int(c == 'b') for c in input()]\nx = [i + 1 for i in range(n) if (a[i], b[i]) == (0, 1)]\ny = [i + 1 for i in range(n) if (a[i], b[i]) == (1, 0)]\nif (len(x) & 1) ^ (len(y) & 1) == 1:\n    print(-1)\n    return\ncnt = 0\nres = []\nwhile len(x) > 1:\n    res.append(f'{x.pop()} {x.pop()}')\n    cnt += 1\nwhile len(y) > 1:\n    res.append(f'{y.pop()} {y.pop()}')\n    cnt += 1\nif len(x) == 1:\n    c, d = x[0], y[0]\n    res.append(f'{c} {c}')\n    res.append(f'{c} {d}')\n    cnt += 2\nprint(cnt)\nprint('\\n'.join(res))", "n = int(input())\ns = input()\nt = input()\n\ncnt_s_a = 0\ncnt_t_a = 0\nfor i in range(n):\n    if s[i] == \"a\":\n        cnt_s_a += 1\n    if t[i] == \"a\":\n        cnt_t_a += 1\nif (cnt_t_a + cnt_s_a) % 2 == 1:\n    print(-1)\n    return\n\nb_a = []\na_b = []\n\nfor i in range(n):\n    if s[i] == \"a\" and t[i] == \"b\":\n        a_b.append(i)\n    if s[i] == \"b\" and t[i] == \"a\":\n        b_a.append(i)\n\nans = []\nfor i in range(len(a_b)//2):\n    ans.append((a_b[2*i]+1, a_b[2*i+1]+1))\nfor i in range(len(b_a)//2):\n    ans.append((b_a[2*i]+1, b_a[2*i+1]+1))  \n\nif len(a_b) % 2 == 1:\n    ans.append((a_b[-1]+1, a_b[-1]+1))\n    ans.append((a_b[-1]+1, b_a[-1]+1))\nprint(len(ans))\nfor i in ans:\n    print(*i)\n\n\n    \n\n", "\nn = int(input())\ns1 = input()\ns2 = input()\nif (s1.count('a') + s2.count('a')) % 2 == 1 or (s1.count('b') + s2.count('b')) % 2 == 1:\n    print(-1)\n    return\n\nsort1 = []\nsort2 = []\nfor i in range(n):\n    if s1[i] != s2[i]:\n        if s1[i] == 'a':\n            sort1.append(i)\n        else:\n            sort2.append(i)\nmoves = []\nwhile len(sort1) > 1:\n    moves.append([sort1[-1], sort1[-2]])\n    sort1.pop()\n    sort1.pop()\nwhile len(sort2) > 1:\n    moves.append([sort2[-1], sort2[-2]])\n    sort2.pop()\n    sort2.pop()\nif len(sort1) == 1:\n    moves.append([sort1[0], sort1[0]])\n    moves.append([sort1[0], sort2[0]])\nprint(len(moves))\nfor x in moves:\n    print(x[0] + 1, x[1] + 1)\n", "import sys \nfrom collections import defaultdict\ninput = lambda : sys.stdin.readline().rstrip()\n\nn = int(input())\ns = input()\nt = input()\n\nx = s.count(\"a\")\ny = t.count(\"a\")\n\nif not ( (x + y) % 2 == 0 and (2 * n - x - y) % 2 == 0 ):\n  print(\"-1\")\n  return\n\n\n\nab = []\nba = []\nfor i in range(n):\n  if s[i] == t[i]:\n    continue\n  elif s[i] == \"a\":\n    ab.append(i + 1)\n  else:\n    ba.append(i + 1)\n\nans = []\nwhile len(ab) >= 2:\n  x, y = ab.pop(), ab.pop()\n  ans.append((x, y))\n\n\nwhile len(ba) >= 2:\n  x, y = ba.pop(), ba.pop()\n  ans.append((x, y))\n\nif len(ab) + len(ba) == 0:\n  print(len(ans))\n  for i in ans:\n    print(*i)\n\nelse:\n  x = ab[0]\n  y = ba[0]\n  ans.append((x, x))\n  ans.append((x, y))\n\n  print(len(ans))\n  for i in ans:\n    print(*i)\n", "n = int(input())\ns = input()\nt = input()\nb_a = 0\nba = []\na_b = 0\nab = []\nfor i in range(n):\n    if s[i] == 'a' and t[i] == 'b':\n        a_b += 1\n        ab.append(i)\n    if s[i] == 'b' and t[i] == 'a':\n        b_a += 1\n        ba.append(i)\nans = -1\nif (a_b % 2 == b_a % 2):\n    ans = a_b // 2 + b_a // 2\n    ans += 2 * (a_b % 2)\n    print(ans)\n    for i in range(1, len(ab), 2):\n        print(ab[i - 1] + 1, ab[i] +1)\n    for i in range(1, len(ba), 2):\n        print(ba[i - 1] + 1, ba[i] +1)\n    if a_b % 2 != 0:\n        print(ab[-1] + 1, ab[-1] + 1)\n        print(ab[-1] + 1, ba[-1] + 1)\n\nif ans == -1:\n    print(ans)", "n=int(input())\ns=list(input())\nt=list(input())\nplat1=[]\nplat2=[]\ntot=[]\nfor i in range(n):\n    if (s[i]=='a' and t[i]=='b'):\n        plat1.append(i+1)\n    elif s[i]=='b' and t[i]=='a':\n        plat2.append(i+1)\nm=len(plat1)\nk=len(plat2)\nfor i in range(1,m,2):\n    tot.append((plat1[i-1],plat1[i]))\nfor i in range(1,k,2):\n    tot.append((plat2[i-1],plat2[i]))\nif m%2==1 and k%2==1:\n    x,y=plat1[-1],plat2[-1]\n    tot.append((x,x))\n    tot.append((x,y))\nelif m%2==1 and k%2==0 or m%2==0 and k%2==1:\n    print(-1)\n    return\nprint(len(tot))\nfor item in tot:\n    print(*item)\n        \n        \n", "import sys\n\nn = int(sys.stdin.readline().strip())\ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\nA = []\nB = []\nC = []\nD = []\na, b, c, d = 0, 0, 0, 0\nfor i in range (0, n):\n    if s[i] == \"a\" and t[i] == \"a\":\n        a = a + 1\n        A.append(i)\n    if s[i] == \"a\" and t[i] == \"b\":\n        c = c + 1\n        C.append(i)\n    if s[i] == \"b\" and t[i] == \"a\":\n        d = d + 1\n        D.append(i)\n    if s[i] == \"b\" and t[i] == \"b\":\n        b = b + 1\n        B.append(i)\n\nif (c + d) % 2 != 0:\n    print(-1)\nelse:\n    print((c+1)//2 + (d+1)//2)\n    lc = len(C)\n    ld = len(D)\n    while lc >= 2:\n        print(str(C[lc - 1]+1) + \" \" + str(C[lc - 2]+1))\n        lc = lc - 2\n        B.append(lc-1)\n        A.append(lc-2)\n    while ld >= 2:\n        print(str(D[ld - 1]+1) + \" \" + str(D[ld - 2]+1))\n        ld = ld - 2\n        A.append(ld-1)\n        B.append(ld-2)\n    if lc == ld == 1:\n        print(str(C[0]+1) + \" \" + str(C[0]+1))\n        print(str(C[0]+1) + \" \" + str(D[0]+1))\n", "n = int(input())\ns1 = input()\ns2 = input()\nab = []\nba = []\nfor i in range(n):\n    if s1[i] == 'a' and s2[i] == 'b':\n        ab.append(i)\n    elif s1[i] == 'b' and s2[i] == 'a':\n        ba.append(i)\nif (len(ab) + len(ba)) % 2:\n    print(-1)\nelse:\n    print(len(ab) // 2 + len(ba) // 2 + (len(ab) % 2) * 2)\n    for i in range(1, len(ab), 2):\n        print(ab[i - 1] + 1, ab[i] + 1)\n    for i in range(1, len(ba), 2):\n        print(ba[i - 1] + 1, ba[i] + 1)\n    if len(ab) % 2:\n        print(ab[-1] + 1, ab[-1] + 1)\n        print(ab[-1] + 1, ba[-1] + 1)", "'''input\n8\nbabbaabb\nabababaa\n\n\n\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nfrom  heapq import heappush as hpush\nfrom heapq import heappop as hpop\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nn = ri(1)\n\na= input()\nb = input()\none =[] #ab\ntwo=[]  #ba\n\nfor i in range(n):\n\tif a[i]==b[i]:\n\t\tpass\n\telse:\n\t\tif a[i]==\"a\":\n\t\t\tone.append(i+1)\n\t\telse:\n\t\t\ttwo.append(i+1)\n\nif (len(one)+len(two)) %2 ==1:\n\tprint(-1)\nelse:\n\tk = len(one)+len(two)\n\tsteps=[]\n\n\tfor i in range(0,len(one),2):\n\n\t\tif i+1<len(one):\n\t\t\tsteps.append((one[i],one[i+1]))\n\n\tfor i in range(0,len(two),2):\n\t\tif i+1<len(two):\n\t\t\tsteps.append((two[i],two[i+1]))\n\n\t#print(one,two)\n\tif len(one)%2==1:\n\n\t\tsteps.append((one[-1],one[-1]))\n\t\tsteps.append((one[-1],two[-1]))\n\n\tprint(len(steps))\n\tfor i in steps:\n\t\tprint(*i)\n\n\n\n\n\n", "def countchar(s1,s2):\n    vala = s1.count(\"a\") + s2.count(\"a\")\n    valb = s2.count(\"b\") + s2.count(\"b\")\n    if(vala%2 == 0 and valb%2 == 0):\n        return True\n    else:\n        return False\n\ndef calcarr(s1,s2):\n    a2b,b2a=[],[]\n    sol=[]\n    for i in range(len(s1)):\n        if(s1[i]==\"a\" and s2[i]==\"b\"):\n            a2b.append(i)\n        elif(s1[i]==\"b\" and s2[i]==\"a\"):\n            b2a.append(i)\n    \n    k=0\n    if(len(a2b)%2 ==0 and len(b2a)%2==0):\n\n        for i in range(1,len(a2b),2):\n            sol.append([a2b[i-1]+1,a2b[i]+1])\n            k+=1\n\n        for i in range(1,len(b2a),2):\n            sol.append([b2a[i-1]+1,b2a[i]+1])\n            k+=1\n\n    else:\n\n        for i in range(1,len(a2b),2):\n            sol.append([a2b[i-1]+1,a2b[i]+1])\n            k+=1\n\n        for i in range(1,len(b2a),2):\n            sol.append([b2a[i-1]+1,b2a[i]+1])\n            k+=1\n\n        sol.append([a2b[-1]+1,a2b[-1]+1])\n        sol.append([a2b[-1]+1,b2a[-1]+1])\n        k+=2\n\n    print(k)\n    for i in sol:\n        print(i[0],i[1])\n\n\ndef main():\n\n    n= int(input())\n    s1 = input()\n    s2 = input()\n\n    if(countchar(s1,s2)):\n        calcarr(s1,s2)\n    else:\n        print(\"-1\")\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n = int(input())\ns = input()\nt = input()\n\nab = []\nba = []\n\nfor i in range(n):\n    if s[i] == t[i]:\n        continue\n    else:\n        if s[i] == \"a\":\n            ab.append(i)\n        else:\n            ba.append(i)\n\nif (len(ab) + len(ba)) % 2 == 0:\n    ans = []\n    for i in range(len(ab)//2):\n        ans.append([ab[2*i], ab[2*i+1]])\n    for i in range(len(ba)//2):\n        ans.append([ba[2*i], ba[2*i+1]])\n    if len(ab) % 2 != 0:\n        ans.append([ab[-1], ab[-1]])\n        ans.append([ab[-1], ba[-1]])\n    print(len(ans))\n    for i, j in ans:\n        print(i+1, j+1)\n\nelse:\n    print(-1)\n", "def out(l):\n\ti = 0\n\twhile i + 1 < len(l):\n\t\tprint(l[i], l[i +1])\n\t\ti += 2\n\nn = int(input())\ns = input()\nt = input()\nab = []\nba = []\nfor i in range(n):\n\tif s[i] == 'a' and t[i] == 'b':\n\t\tab.append(i + 1)\n\tif s[i] == 'b' and t[i] == 'a':\n\t\tba.append(i + 1)\n\nif len(ab) % 2 == len(ba) % 2:\n\tcnt = len(ab) // 2 + len(ba) // 2\n\tif len(ab) % 2 == 1:\n\t\tcnt += 2\n\tprint(cnt)\n\tout(ab)\n\tout(ba)\n\tif len(ab) % 2 == 1:\n\t\ta = ab[len(ab) - 1]\n\t\tb = ba[len(ba) - 1] \n\t\tprint(a, a)\n\t\tprint(a, b)\nelse:\n\tprint(-1)\n", "n = int(input())\ns = input()\nt = input()\n\nab = []\nba = []\n\nfor i in range(n):\n    if (s[i] != t[i]):\n        if (s[i] == 'a'):\n            ab.append(i)\n        else:\n            ba.append(i)\n\nif ((len(ab)+len(ba)) % 2 > 0):\n    print(-1)\n    return\n\nswaps = []\n\nwhile (len(ab) > 1):\n    swaps.append((ab.pop(), ab.pop()))\n\nwhile (len(ba) > 1):\n    swaps.append((ba.pop(), ba.pop()))\n\nif (len(ab) > 0):\n    t1 = ab.pop()\n    t2 = ba.pop()\n    swaps.append((t1, t1))\n    swaps.append((t1, t2))\n\nprint(len(swaps))\nfor (t1, t2) in swaps:\n    print(t1 + 1, t2 + 1)", "n=int(input())\ns=input()\nt=input()\n\nresult = 0\nout = []\nab=ba=-1\nfor i in range(n):\n    if s[i]==t[i]:\n        continue\n    if s[i]=='a' and t[i]=='b':\n        if ab != -1:\n            out.append((ab+1,i+1))\n            result += 1\n            ab = -1\n        else:\n            ab = i\n    else:\n        if ba != -1:\n            out.append((ba+1,i+1))\n            result += 1\n            ba = -1\n        else:\n            ba = i\n\nif (ab == -1) != (ba == -1):\n    print(-1)\nelif (ab == ba == -1):\n    print(result)\n    for i,j in out:\n        print(i,j)\nelse:\n    print(result+2)\n    for i,j in out:\n        print(i,j)\n    print(ab+1,ab+1)\n    print(ab+1,ba+1)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\n\nsys.setrecursionlimit(10 ** 6)  # max depth of recursion\nthreading.stack_size(2 ** 27)  # new thread will get stack of such size\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\n\nclass MergeFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            a, b = b, a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\n\ndef prime_factors(n):  # n**0.5 complex\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return (factors)\n\n\ndef all_factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\n\ndef fibonacci_modP(n, MOD):\n    if n < 2: return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(\n        fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\n\ndef factorial_modP_Wilson(n, p):\n    if (p <= n):\n        return 0\n    res = (p - 1)\n    for i in range(n + 1, p):\n        res = (res * cached_fn(InverseEuler, i, p)) % p\n    return res\n\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\n\ndef is_prime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\n\n\nfactorial_modP = []\n\n\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP, fac_warm_up\n    if fac_warm_up: return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = (factorial_modP[i - 1] * i) % MOD\n    fac_warm_up = True\n\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return (factorial_modP[n] * (\n                (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD)) % MOD)) % MOD\n\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\n\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm += i\n        res.append(sm)\n    return res\n\n\ndef get_int():\n    return int(stdin.readline().strip())\n\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\n\nmemory = dict()\n\n\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\n\n\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:  # Change this condition 2 to whatever you like\n            x += b\n        b = b // 2\n    return x\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\n\n\nTestCases = False\nfac_warm_up_size = 10 ** 5 + 100\noptimise_for_recursion = False  # Can not be used clubbed with TestCases WHen using recursive functions, use Python 3\n\n\ndef main():\n    n = get_int()\n    s = list(stdin.readline().strip())\n    t = list(stdin.readline().strip())\n    type1, type2 = [], []\n    res = []\n    for i in range(n):\n        if s[i]!=t[i]:\n            if s[i]>t[i]:\n                type1.append(i)\n            else:\n                type2.append(i)\n    if len(type1)%2 != len(type2)%2:\n        print(-1)\n    else:\n        k = (len(type1))//2\n        #print(k, type1)\n        for i in range(k):\n            res.append([type1[2*i]+1, type1[2*i + 1]+1])\n        k = (len(type2))//2\n        #print(k, type2)\n        for i in range(k):\n            res.append([type2[2*i]+1, type2[2*i + 1]+1])\n        if len(type1)%2!=0:\n            i = type1[-1]\n            j = type2[-1]\n            res.append([i+1,i+1])\n            res.append([i+1,j+1])\n        print(len(res))\n        for li in res:\n            display_list(li)\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()", "n = int(input())\ns = input()\nt = input()\n\nab = 0\nabs_ = set()\nba = 0\nbas = set()\n\nfor i in range(n):\n    ss = s[i]\n    tt = t[i]\n    if ss != tt:\n        if ss == 'a':\n            ab += 1\n            abs_.add(i+1)\n        else:\n            ba += 1\n            bas.add(i+1)\n\nif (ab + ba)%2 != 0:\n    print(-1)\n    return\n\nres = []\nif len(abs_)%2 == 1:\n    first = abs_.pop()\n    second = bas.pop()\n    res.append((first, first))\n    res.append((first, second))\n\nwhile abs_:\n    first = abs_.pop()\n    second = abs_.pop()\n    res.append((first, second))\n\nwhile bas:\n    first = bas.pop()\n    second = bas.pop()\n    res.append((first, second))\n\nprint(len(res))\nfor x, y in res:\n    print(x, y)", "n = int(input())\ns1= input()\ns2= input()\ndif = 0 \ns1_a = []\ns2_a = []\nfor idx in range(n):\n    if s1[idx] != s2[idx]:\n        dif +=1\n        if s1[idx]=='a': s1_a.append(idx+1)\n        else: s2_a.append(idx+1)\nif dif%2:\n    print(-1)\nelse:\n    print(len(s1_a)//2 + len(s2_a)//2 + 2*(len(s1_a)%2))\n    while len(s1_a)>=2:\n        print(s1_a.pop(), s1_a.pop())\n    while len(s2_a)>=2:\n        print(s2_a.pop(), s2_a.pop())\n    while s1_a:\n        t = s1_a.pop()\n        print(t, t)\n        print(s2_a.pop(), t)\n\n", "n = int(input())\ns = input().rstrip()\nt = input().rstrip()\n\ntobe_a = []\ntobe_b = []\nfor i, (sch, tch) in enumerate(zip(s, t)):\n    if sch == \"b\" and tch == \"a\":\n        tobe_a.append(i + 1)\n    elif sch == \"a\" and tch == \"b\":\n        tobe_b.append(i + 1)\n\nif (len(tobe_a) + len(tobe_b)) % 2 != 0:\n    print(-1)\n    return\n\nans = []\nfor a1, a2 in zip(tobe_a[::2], tobe_a[1::2]):\n    ans.append((a1, a2))\nfor b1, b2 in zip(tobe_b[::2], tobe_b[1::2]):\n    ans.append((b1, b2))\n\nif len(tobe_a) % 2 == 1:\n    ans.append((tobe_a[-1], tobe_a[-1]))\n    ans.append((tobe_a[-1], tobe_b[-1]))\n\nprint(len(ans))\nfor a, b in ans:\n    print(a, b)", "n = int(input())\nx = input()\ny = input()\n\n\nab = []\nba = []\nfor i, (xi, yi) in enumerate(zip(x, y), 1):\n    s = xi+yi\n    if s == 'ab':\n        ab.append(i)\n    elif s == 'ba':\n        ba.append(i)\n\nif len(ab)%2 != len(ba)%2:\n    print(-1)\nelse:\n    n1 = len(ab)\n    n2 = len(ba)\n    print(n1//2+n2//2+(2 if n1%2 == 1 else 0))\n    for i in range(n1//2):\n        print(ab[i*2], ab[i*2+1])\n    for i in range(n2//2):\n        print(ba[i*2], ba[i*2+1])\n    if n1 % 2 == 1:\n        print(ab[n1-1], ab[n1-1])\n        print(ab[n1-1], ba[n2-1])\n    \n", "SI = lambda : input()\nfrom collections import Counter\n\nn = int(input())\na = SI()\nb = SI()\n\ndef solve(n,a,b):\n\td = Counter(a)+Counter(b)\n\tfor i in d:\n\t\tif(d[i]&1):\n\t\t\tprint(-1)\n\t\t\treturn\n\txa = d[a]//2\n\tnewa = []\n\tnewb = []\n\tfor i in range(n):\n\t\tif(a[i]!=b[i]):\n\t\t\tnewa.append((a[i],i))\n\t\t\tnewb.append((b[i],i))\n\ta,b = newa,newb\n\taux = len(a)\n\tif(aux==0):\n\t\tprint(0)\n\t\treturn\n\tcanta = 0\n\tfor i in a:\n\t\tif(i[0]=='a'):\n\t\t\tcanta+=1\n\tif(canta&1):\n\t\tprint(len(a)//2+1)\n\t\tprint(a[0][1]+1,a[0][1]+1)\n\t\ta[0],b[0] = b[0],a[0]\n\t\t\t\n\telse:\n\t\tprint(len(a)//2)\n\tlastA,lastB = -1,-1\n\tfor i in range(aux):\n\t\tif(a[i][0]=='a'):\n\t\t\tif(lastA==-1):\n\t\t\t\tlastA=a[i][1]\n\t\t\telse:\n\t\t\t\tprint(lastA+1,a[i][1]+1)\n\t\t\t\tlastA=-1\n\t\telse:\n\t\t\tif(lastB==-1):\n\t\t\t\tlastB=a[i][1]\n\t\t\telse:\n\t\t\t\tprint(lastB+1,a[i][1]+1)\n\t\t\t\tlastB=-1\nsolve(n,a,b)\n\n\n\n\n"]