["#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        #print(*args, **kwargs, file=sys.stderr)\n        # in python 3.4 **kwargs is invalid???\n        print(*args,  file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN  = getIntList()\nza  = getIntList()\n\ncc = collections.Counter(za)\nzt = []\nfor x in cc:\n    zt.append( cc[x] )\n\nzt.sort( )\n\nre = zt[-1] \n\ndef findmid(l,r, e):\n    if l>= len(zt):\n        return -1\n    if e<=zt[l]: return l;\n    if e>zt[r]: return -1\n    while l+1 <r:\n        mid = (l+r)//2\n        if zt[mid] < e:\n            l = mid\n        else:\n            r = mid\n    return r\nfor first in range(1, re//2 + 1):\n    nowr = 0\n    t = first\n    ind = -1\n    while 1:\n        ind = findmid(ind+1,len(zt)-1, t)\n        if ind<0:\n            break\n        nowr += t\n        t*=2\n    re = max(re, nowr)\nprint(re)\n\n\n\n\n\n\n\n\n", "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\nn = mints()\na = list(mints())\na.sort()\np = -1\nc = -1\nb = []\nfor i in range(len(a)):\n\tif a[i] != p:\n\t\tif c != -1:\n\t\t\tb.append((c, p))\n\t\tc = 1\n\t\tp = a[i]\n\telse:\n\t\tc += 1\nif c != -1:\n\tb.append((c, p))\nb.sort(reverse=True)\np = -1\nr = 0\nfor i in range(len(b)):\n\tif p == -1:\n\t\tp = b[i][0]\n\telse:\n\t\tp = min(p//2,b[i][0])\n\tif p != 0:\n\t\tr = max(r, p*((2**(i+1))-1))\nprint(r)", "\ndef main():\n    buf = input()\n    n = int(buf)\n    buf = input()\n    buflist = buf.split()\n    a = list(map(int, buflist))\n    appearance = {}\n    for i in a:\n        if not i in appearance:\n            appearance.update({i : 1})\n        else:\n            appearance[i] += 1\n    appearance = [[k, v] for k ,v in list(dict(sorted(list(appearance.items()), key=lambda x:x[1])).items())]\n    max_num = appearance[-1][1]\n    pos = 0\n    for i in range(1, max_num + 1):\n        num = 0\n        prob = i\n        for j in range(pos, len(appearance)):\n            if appearance[j][1] >= prob:\n                num += prob\n                prob *= 2\n        if num > max_num:\n            max_num = num\n        while appearance[pos][1] == i and pos < len(appearance) - 1:\n            pos += 1\n    print(max_num)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# from collections import Counter as C\n# n, k_ = map(int, input().split())\n# l = [*map(int, input().split())]\n\n# c = C(l)\n# d = {}\n# for k, v in c.items():\n#     d[v] = d.get(v, []) + [str(k)]\n\n# ld = sorted([(k, v) for k, v in d.items()], reverse = True)\n\n# res = []\n# # print(ld)\n# for e in ld:\n#     res += [e[1]]\n#     if e[0] * len(res) >= k_:\n#         i = 0\n#         while k_ > e[0] * len(res[i]):\n#             print((' '.join(res[i]) + ' ') * e[0])\n#             i += 1\n#             k_ -= e[0] * len(res[i])\n#         # if k_:\n#         #     print((res[i] + ' ') * k_)\n#         return\n\n\nfrom bisect import bisect_left, bisect_right\nfrom collections import Counter as C\n\nn_ = int(input())\nl = sorted(C(map(int, input().split())).values())\nn = len(l)\ni = res = 0\n\n# print(l)\n\ndef f(x):\n    i = 0\n    for m in range(33):\n        t = x << m\n        i = bisect_left(l, t, i)\n        if i == n:\n            return t - x\n        i += 1\n\n\nres = 0\nfor x in range(1, n_ + 1):\n    res = max(res, f(x))\n\nprint(res)", "n = int(input())\na = [int(x) for x in input().split()]\ndtt = dict()\nfor t in a:\n    if t in dtt:\n        dtt[t] += 1\n    else:\n        dtt[t] = 1\nlts = [dtt[x] for x in dtt]\nlts.sort(reverse=True)\nmt = [lts[0]]\npl = lts[0]\nfor d in range(1, len(lts)):\n    cl = min(pl // 2, lts[d])\n    if cl == 0:\n        break\n    cs = cl * (2**(d+1) - 1)\n    mt.append(cs)\n    pl = cl\nprint(max(mt))\n", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport itertools\nimport sys\n\n\"\"\"\ncreated by shhuan at 2018/11/16 23:49\n\n\"\"\"\nN = int(input())\nA = [int(x) for x in input().split()]\n\nwc = collections.Counter(A)\n\ncounts = [c for w, c in wc.items()]\ncounts.sort()\nlencounts = len(counts)\n\nvals = {v:v for v in range(1, counts[0]+1)}\nfor i in range(1, lencounts):\n    new_vals = {}\n    for v in range(1, counts[i] + 1):\n        if v % 2 == 0:\n            new_vals[v] = (vals[v//2] + v) if v//2 in vals else v\n        else:\n            new_vals[v] = v\n\n    for k, v in new_vals.items():\n        if k in vals:\n            vals[k] = max(vals[k], v)\n        else:\n            vals[k] = v\n\nprint(max(vals.values()))", "import sys\nn=int(sys.stdin.readline())\nA=list(map(int,sys.stdin.readline().split()))\n\nfrom collections import Counter\nc=Counter(A)\n\nLIST=list(c.values())\nLIST.sort(reverse=True)\n\nif len(LIST)==1:\n    print(LIST[0])\n    return\n\nLL=len(LIST)\ny=LIST[0]\nANS=y\nif y%2==1:\n    y=y-1\n\n#count2=0\n#while y%2==0:\n#    y=y//2\n#    count2+=1\n\nfor x in range(y,0,-2):\n    an=0\n    for j in range(LL):\n        if x%(2**j)==0 and LIST[j]>=x//(2**j):\n            an+=x//(2**j)\n        else:\n            break\n    if an>ANS:\n        ANS=an\n\nprint(ANS)\n", "n = list(map(int, input().split()))\na = list(map(int, input().strip().split()))\nalla = {}\nfor x in a:\n\tif(alla.get(x) == None):\n\t\talla.update({x: 0})\n\talla.update({x: alla[x] + 1})\nals = set(a)\nres = []\nfor x in als:\n\tres.append(alla[x])\nres.sort()\n\nn = len(res)\nans = 0\nfor i in range(1, res[n-1]+1):\n\tcurs = i\n\tcur = i \n\tans = max(ans, curs)\n\tj = n-2\n\tif(cur % 2 == 1):          \n\t\tcontinue\n\tcur = cur // 2\n\twhile(j >= 0 and res[j] >= cur):\n\t\tcurs += cur\n\t\tans = max(ans, curs)\n\t\tj -= 1\n\t\tif(cur % 2 != 0):\t\n\t\t\tbreak\n\t\tcur = cur // 2\n\nprint(ans)\n\t\t\n", "n = int(input())\na = [int(x) for x in input().split()]\ndtt = dict()\nfor t in a:\n    if t in dtt:\n        dtt[t] += 1\n    else:\n        dtt[t] = 1\nlts = [dtt[x] for x in dtt]\nlts.sort(reverse=True)\nmt = [lts[0]]\npl = lts[0]\nfor d in range(1, len(lts)):\n    cl = min(pl // 2, lts[d])\n    if cl == 0:\n        break\n    cs = cl * (2**(d+1) - 1)\n    mt.append(cs)\n    pl = cl\nprint(max(mt))\n", "n=int(input())\narr=list(map(int,input().split()))\nd={}\npowers=[]\nfor i in range(32):\n    powers.append(2**i)\nfor i in arr:\n    if i in list(d.keys()):\n        d[i]+=1\n    else:\n        d[i]=1 \narr1=[]\nfor i in list(d.keys()):\n    arr1.append(d[i])\narr1.sort(reverse=True)\nmaxx=arr1[0]\ncurr=arr1[0] \nfor i in range(1,len(arr1)):\n    if curr>2*arr1[i]:\n        maxx=max(maxx,arr1[i]*(powers[i+1]-1))\n        curr=arr1[i]\n    else:\n        maxx=max(maxx,(curr//2)*(powers[i+1]-1))\n        curr=curr//2\n    if curr==0:\n        break\nprint(maxx)\n\n", "def fun(l,r,bound):\n\tnonlocal val;\n\tind = -1;\n\twhile(l<=r):\n\t\tmid = (l+r)//2;\n\t\tif (val[mid]>=bound):\n\t\t\tr = mid-1;\n\t\t\tind = mid;\n\t\telse:\n\t\t\tl = mid+1;\n\treturn ind;\n\nn = int(input());\na = list(map(int,input().split()))\nd = {};\nfor i in range(n):\n\ttry:\n\t\td[a[i]]+=1;\n\texcept:\n\t\td[a[i]]=1;\nval = list(d.values());\nval.sort();\nans = 0;\nfor i in range(1,200100):\n\ttemp = 0;\n\tadd = i;\n\tind = fun(0,len(val)-1,add);\n\twhile(ind!=-1):\n\t\ttemp += add;\n\t\tadd = add*2;\n\t\tind = fun(ind+1,len(val)-1,add);\n\tans = max(ans,temp);\nprint(ans)\n\n", "n = int(input())\na = [int(x) for x in input().split()]\ndtt = dict()\nfor t in a:\n    if t in dtt:\n        dtt[t] += 1\n    else:\n        dtt[t] = 1\nlts = [dtt[x] for x in dtt]\nlts.sort(reverse=True)\nmt = [lts[0]]\npl = lts[0]\nfor d in range(1, len(lts)):\n    cl = min(pl // 2, lts[d])\n    if cl == 0:\n        break\n    cs = cl * (2**(d+1) - 1)\n    mt.append(cs)\n    pl = cl\nprint(max(mt))\n", "from collections import Counter\n\n\ndef main():\n    from sys import stdin, stdout\n\n    # stdin = open(\"in.txt\", \"r\")\n    it = iter(map(int, stdin.read().split()))\n\n    n = next(it)\n    topic_list = [next(it) for _ in range(n)]\n\n    cnt_list = sorted(Counter(topic_list).values())\n    mx_val = cnt_list[-1]\n    res = 0\n\n    for curr_val in range(1, mx_val+1):\n        curr_res = curr_val\n        idx = len(cnt_list) - 1\n\n        while curr_val % 2 == 0 and idx > 0:\n            curr_val //= 2\n            idx -= 1\n            if cnt_list[idx] < curr_val:\n                break\n            curr_res += curr_val\n\n        res = max(res, curr_res)\n\n    stdout.write(str(res))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "p_line = [int(x) for x in input().strip().split(' ')]\nsize = p_line[0]\n\t\t\na = [int(x) for x in input().strip().split(' ')]\nnum_to_occ = {}\nfor x in a:\n\tif x not in num_to_occ:\n\t\tnum_to_occ[x] = 0\n\tnum_to_occ[x] += 1\n\ntopics = []\nfor _, occ in num_to_occ.items():\n\ttopics.append(occ)\ntopics.sort(reverse = True)\n\nba = 0\nfor start in range(1, topics[0] + 1):\t\n\tmy_a = start\n\t\n\tact = start\n\tfor i in range(1, len(topics)):\n\t\tif act % 2 == 1:\n\t\t\tbreak\n\t\t\n\t\tact = act / 2\n\t\tif act > 0 and topics[i] >= act:\n\t\t\tmy_a += act\n\t\telse:\n\t\t\tbreak\n\tba = max(ba, my_a)\n\nprint(int(ba))", "n = int(input())\na = [int(i) for i in input().split()]\n\ndtt = dict()\n\nfor v in a:\n    if v not in dtt:\n        dtt[v] = 0\n    dtt[v] += 1\n\nlts = [dtt[i] for i in dtt]\nlts.sort(reverse=True)\n\nmt = [lts[0]]\npl = lts[0]\n\nfor i in range(1,len(lts)):\n    cl = min(pl//2,lts[i])\n    if cl == 0:\n        break\n    cs = cl*(2**(i+1)-1)\n    mt.append(cs)\n    pl = cl\n\nprint(max(mt))\n", "from collections import defaultdict\nfrom sys import stdin\n\n\nclass Solver:\n\n    @staticmethod\n    def build_dict(l):\n        mp = defaultdict(int)\n        for val in l:\n            mp[val] = mp[val] + 1\n        return mp\n\n    @staticmethod\n    def build_cnt_list(mp):\n        lst = [v for (k, v) in list(mp.items())]\n        return lst\n\n    def __init__(self, l):\n        self.__L = l\n\n    @staticmethod\n    def get_largest_power_of_2(n):\n        # for p in reversed(range(31)):\n        for p in range(30, -1, -1):\n            if 1 << p <= n:\n                return 1 << p\n        return 1\n\n    def solve(self):\n        mp = Solver.build_dict(self.__L)\n        cnt_lst = Solver.build_cnt_list(mp)\n        cnt_lst.sort()\n        cnt_lst.reverse()\n\n        ans = cnt_lst[0]\n\n        for start_cand in range(cnt_lst[0], 0, -1):\n            if start_cand % 2 == 0 :\n                ans2 = 0\n                nxt = start_cand\n                for cnt in cnt_lst:\n                    if cnt >= nxt:\n                        ans2 += nxt\n                        if nxt % 2 != 0:\n                            break\n                        nxt //= 2\n                    else:\n                        break\n                ans = max(ans, ans2)\n\n        return ans\n\n\ndef main():\n    n = int(stdin.readline())\n    inp = list(map(int, stdin.readline().split()))\n\n    # print(n)\n    # print(inp)\n    solver = Solver(inp)\n    # print(Solver.build_dict(inp))\n    print(solver.solve())\n\n\nmain()\n", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    data_stat = {}\n    for i in range(n):\n        t = data_stat.get(a[i], 0) + 1\n        data_stat[a[i]] = t\n    current = sorted(list(data_stat.items()), key = lambda x: x[1])\n    answer = 0\n    for i in range(1, current[-1][1] + 1):\n        pos = len(current) - 1\n        cur = i\n        res = cur\n        while cur % 2 == 0 and pos > 0:\n            cur //= 2\n            pos -= 1\n            if current[pos][1] < cur:\n                break\n            res += cur\n        answer = max(answer, res)\n    print(answer)\n    return\n    \ndef __starting_point():\n    main()\n\n__starting_point()", "def calc(am, con):\n    ans = am\n    for i in range(len(con)):\n        if am % 2 != 0:\n            if con[i] >= am and i != 0:\n                ans += am\n            return ans\n        if i == 0:\n            am //=2\n            continue\n        if con[i] >= am:\n            ans += am\n            am //=2\n        else:\n            return ans\n    return ans\n\n\ndef main():\n    n = int(input())\n    l = list(map(int, input().split()))\n    dic = dict()\n    for i in range(n):\n        dic[l[i]] = 0\n    for i in range(n):\n        dic[l[i]] += 1\n    l = list(dic.values())\n    l.sort(reverse=True)\n    ans = [0] * (l[0] + 1)\n\n    for i in range(1, l[0] + 1):\n        ans[i] = calc(i, l)\n    print(max(ans))\nmain()", "n=int(input())\npro=[int(i) for i in input().split()]\nbook={}\nfor i in pro:\n    if i in book:\n        book[i]+=1\n    else:\n        book[i]=1\nbook=[book[i] for i in book]\nbook=sorted(book,reverse=True)\nbook.insert(0,0)\nans=0\nl=len(book)\nfor i in range(1,book[1]+1):\n    pos,cur,tem=2,i,i\n    while cur&1 == 0 and pos <l:\n        cur>>=1\n        if book[pos]<cur :\n            break\n        tem+=cur\n        pos+=1\n    ans=max(ans,tem)\nprint(ans)", "from collections import Counter\nn = int(input())\na = list(map(int, input().split()))\nc = Counter(a)\nl = sorted(c.values())\nsize = len(l)\nans = 0\nfor i in range(1, l[-1] + 1):\n    temp_ans = 0\n    cur = i\n    pos = size - 1  # pointer of the l array\n    while cur <= l[pos] and pos >= 0:  # no index overflow\n        temp_ans += cur\n        pos -= 1\n        if cur & 1:\n            break\n        cur >>= 1\n    ans = max(ans, temp_ans)\nprint(ans)\n", "from collections import Counter\nn = int(input())\na = list(map(int, input().split()))\nc = Counter(a)\nl = sorted(c.values())\nsize = len(l)\nans = 0\nfor i in range(1, l[-1] + 1):\n    temp_ans = 0\n    cur = i\n    pos = size - 1  # pointer of the l array\n    while cur <= l[pos] and pos >= 0:  # no index overflow\n        temp_ans += cur\n        pos -= 1\n        if cur & 1:\n            break\n        cur >>= 1\n    ans = max(ans, temp_ans)\nprint(ans)", "# -*- coding: utf-8 -*-\n\"\"\"\n@author: zzf\n@file: main.py\n@time: 2018/11/13\n\"\"\"\nfrom collections import defaultdict\n\nn = int(input())\na = list(map(int, input().split()))\n\nm = defaultdict(int)\n\nfor i in range(n):\n    m[a[i]] += 1\n\ncount = []\nfor k in m:\n    count.append(m[k])\ncount.sort()\n\nk = len(count)-1\nans = 0\n\nif k == 0:\n    print(count[k])\n    return\n\nfor i in range(count[-1], 0, -1):\n    tmp = i\n    res = i\n    pos = k\n    while tmp %2 == 0 and pos > 0:\n        tmp = tmp //2\n        pos -= 1\n        if count[pos] < tmp:\n            break\n        res += tmp\n    ans = max(res, ans)\n\nprint(ans)\n\n\n\n", "def nono(nu, a, b, c):\n\tif c == len(nu):\n\t\treturn a\n\tif nu[c] >= b:\n\t\tsilo = b * (2**(c+1) - 1)\n\t\treturn nono(nu, max(a, silo), b//2, c+1)\n\telse:\n\t\tsilo = nu[c] * (2**(c+1) - 1)\n\t\treturn nono(nu, max(a, silo), nu[c]//2, c+1)\n\nn = int(input())\nnums = list(map(int, input().split()))\nmapa = {}\nli = []\nfor nu in nums:\n\tmapa[nu] = mapa.get(nu, 0) + 1\nfor ma, c in list(mapa.items()):\n\tli.append(c)\nli.sort(reverse=True)\n# print(li)\nres = li[0]\n# print(nono(li, res, li[0]//2, 1))\nnu = li\na = li[0]\nb = li[0]//2\nc = 1\nwhile len(nu) > c:\n\tif nu[c] >= b:\n\t\tsilo = b * (2**(c+1) - 1)\n\t\ta = max(a, silo)\n\t\tb = b//2\n\t\tc += 1\n\telse:\n\t\tsilo = nu[c] * (2**(c+1) - 1)\n\t\ta = max(a, silo)\n\t\tb = nu[c]//2\n\t\tc += 1\nprint(a)\n\n\n", "n = int(input())\nnums = list(map(int, input().split()))\nmapa = {}\n\nfor nu in nums:\n\tmapa[nu] = mapa.get(nu, 0) + 1\nli = [mapa[x] for x in mapa]\n\nli.sort(reverse=True)\n\na = li[0]\nb = li[0]//2\nc = 1\nwhile len(li) > c:\n\tif b == 0:\n\t\tbreak\n\tif li[c] >= b:\n\t\tsilo = b * (2**(c+1) - 1)\n\t\ta = max(a, silo)\n\t\tb = b//2\n\t\tc += 1\n\telse:\n\t\tsilo = li[c] * (2**(c+1) - 1)\n\t\ta = max(a, silo)\n\t\tb = li[c]//2\n\t\tc += 1\nprint(a)\n\n\n"]