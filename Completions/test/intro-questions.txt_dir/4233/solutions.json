["n, m = map(int, input().split())\npole = []\nmetka = []\nfor i in range(n):\n    pole.append([])\n    metka.append([])\n    s = input()\n    for j in range(m):\n        pole[i].append(s[j])\n        if s[j] == '.':\n            metka[i].append(0)\n        else:\n            metka[i].append(1)\nk = 0\nans = []\n\nfor i in range(n):\n    for j in range(m):\n        if pole[i][j] == '*':\n            e = 0\n            while i - e - 1>= 0 and j - e - 1>= 0 and i + e + 1 < n and j + e + 1< m and pole[i - e - 1][j] == '*' and pole[i][j - e - 1] == '*' and pole[i + e + 1][j] == '*' and pole[i][j + e + 1] == '*':\n                e = e + 1\n                metka[i][j] = 0\n                metka[i - e][j] = 0\n                metka[i][j - e] = 0\n                metka[i + e][j] = 0\n                metka[i][j + e] = 0\n            if e != 0:\n                k = k + 1\n                ans.append((i + 1,j + 1, e))\nflag = True\nfor i in range(n):\n    if 1 in metka[i]:\n        flag = False\n        break\nif not flag:\n    print(-1)\nelse:\n    print(k)\n    for i in range(k):\n        print(ans[i][0], ans[i][1], ans[i][2], end='\\n')", "n, m = map(int,input().split())\ntable = [[0]*(m+2)]\nfor i in range(n):\n    table.append([0])\n    s = input()\n    for j in range(m):\n        table[i+1].append(2 if s[j]=='*' else 0)\n    table[i+1].append(0)\ntable.append([0]*(m+2))\ndx = [-1, 0, 1, 0]\ndy = [0, 1, 0, -1]\nanswer = []\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if table[i][j] == 0:\n            continue\n        able = True\n        size = 0\n        while able:\n            size += 1\n            for k in range(4):\n                if table[i + dx[k]*size][j + dy[k]*size] == 0:\n                    able = False\n        size -= 1\n        if size > 0:\n            table[i][j] = 1\n            for k in range(1, size+1):\n                for q in range(4):\n                    table[i + dx[q]*k][j + dy[q]*k] = 1\n            answer.append([i, j, size])\nOk = True\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if table[i][j] == 2:\n            Ok = False\nif not Ok:\n    print(-1)\nelse:\n    print(len(answer))\n    for i in answer:\n        print(*i)", "n, m = list(map(int, input().split()))\nused = [[True] * m for i in range(n)]\nPole = [0] * n\nM = []\nfor i in range(n):\n    Pole[i] = list(input())\nfor i in range(n):\n    for g in range(m):\n        if Pole[i][g] == '*':\n            k = 0\n            while i - k - 1 >= 0 and i + k + 1 < n and g - k - 1 >= 0 and g + k + 1 < m:\n                if Pole[i - k - 1][g] == '*' and Pole[i + k + 1][g] == '*' and Pole[i][g - k - 1] == '*' and Pole[i][g + k + 1] == '*':\n                    used[i - k - 1][g] = False\n                    used[i + k + 1][g] = False\n                    used[i][g - k - 1] = False\n                    used[i][g + k + 1] = False\n                    k += 1\n                    continue\n                break\n            if k != 0:\n                used[i][g] = False\n                M.append([i + 1, g + 1, k])\nfor i in range(n):\n    for g in range(m):\n        if Pole[i][g] == '*':\n            if used[i][g]:\n                print(-1)\n                break\n    else:\n        continue\n    break\nelse:\n    print(len(M))\n    for i in range(len(M)):\n        print(*M[i])\n                \n                \n", "n, m = map(int, input().split())\nnum = []\nused = []\nfor i in range(n):\n    num.append(input())\n    used.append([False] * m)\nans = []\nfor i in range(1, n - 1):\n    for j in range(1, m - 1):\n        if num[i][j] == '*':\n            d1 = 0\n            d2 = 0\n            d3 = 0\n            d4 = 0\n            for x in range(j + 1, m):\n                if num[i][x] == '.':\n                    d1 = x - j - 1\n                    break\n            else:\n                d1 = m - j - 1\n            for x in range(j - 1, -1, -1):\n                if num[i][x] == '.':\n                    d2 = abs(j - x - 1)\n                    break\n            else:\n                d2 = j\n            for y in range(i + 1, n):\n                if num[y][j] == '.':\n                    d3 = y - i - 1\n                    break\n            else:\n                d3 = n - i - 1\n            for y in range(i - 1, -1, -1):\n                if num[y][j] == '.':\n                    d4 = abs(i - y - 1)\n                    break\n            else:\n                d4 = i\n            dist = min(d1, d2, d3, d4)\n            if dist != 0:\n                ans.append([i + 1, j + 1, dist])\n                for x in range(j - dist, j + dist + 1):\n                    used[i][x] = True\n                for y in range(i - dist, i + dist + 1):\n                    used[y][j] = True\nfl = True\nfor i in range(n):\n    for j in range(m):\n        if num[i][j] == '*' and not used[i][j]:\n            fl = False\nif not fl:\n    print(-1)\nelse:\n    print(len(ans))\n    for i in range(len(ans)):\n        print(*ans[i])", "n, m = [int(i) for i in input().split()]\nstars = []\ndirectionx = [0, -1, 0, 1]\ndirectiony = [1, 0, -1, 0]\nfor i in range(n):\n    stars.append(list(input()))\n\ns = 0\nf = [[False] * m for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if stars[i][j] == \"*\":\n            s += 1\n\nanslist = []\nans = 0\nfor i in range(1, n - 1):\n    for j in range(1, m - 1):\n        if (stars[i][j] == \"*\") and (stars[i][j - 1] == \"*\") and (stars[i - 1][j] == \"*\") and (stars[i][j + 1] == \"*\") and (stars[i + 1][j] == \"*\"):\n            wkf = True\n            count = 0\n            while wkf:\n                for k in range(4):\n                    f[i + directionx[k] * count][j + directiony[k] * count] = True\n                count += 1\n                for k in range(4):\n                    if i + directionx[k] * count >= n:\n                        wkf = False\n                        break\n                    if j + directiony[k] * count >= m:\n                        wkf = False\n                        break\n                    if i + directionx[k] * count < 0:\n                        wkf = False\n                        break\n                    if j + directiony[k] * count < 0:\n                        wkf = False\n                        break\n                    if stars[i + directionx[k] * count][j + directiony[k] * count] != \"*\":\n                        wkf = False\n                        break\n            anslist.append([i + 1, j + 1, count - 1])\n            ans += 1\nif sum([sum(f[i]) for i in range(n)]) == s:\n    print(ans)\n    for i in range(ans):\n        for j in anslist[i]:\n            print(j, end = \" \")\n        print()\nelse:\n    print(\"-1\")\n\n\n\n", "n, m = list(map(int, input().split()))\narr = [input() for i in range(n)]\ns1 = set()\ns2 = set()\nres = list()\nfor i in range(n):\n    for j in range(m):\n        if arr[i][j] == '*':\n            s1.add((i, j))\n            l = 1\n            while True:\n                if i - l >= 0 and i + l < n and j - l >= 0 and j + l < m:\n                    if arr[i - l][j] == arr[i + l][j] == arr[i][j - l] == arr[i][j + l] == '*':\n                        s2 |= {(i - l, j), (i + l, j), (i, j - l), (i, j + l)}\n                        l += 1\n                    else:\n                        break\n                else:\n                    break\n            l -= 1\n            if l > 0:\n                s2.add((i, j))\n                res.append([i + 1, j + 1, l])\nif len(s1 - s2) > 0:\n    print(-1)\nelse:\n    print(len(res))\n    for x in res:\n        print(*x)\n", "n, m  = list(map(int, input().split()))\npole = []\nunfitted = []\n\ndef star_fits(x,y,r):\n\n    if x-r >=0 and x+r<m and y-r>=0 and y+r <n:\n        res = True\n        for k in range(x - r, x + r + 1):\n            if pole[y][k] != '*':\n                res = False\n        for k in range(y - r, y + r + 1):\n            if pole[k][x] != '*':\n                res = False\n    else:\n        return False\n    return res\n\ndef get_max_r(x,y):\n    r=1\n    while (x-r >= 0) and (x+r < m) and (y-r >= 0) and (y+r < n):\n        if pole[y][x+r] == '*' and  pole[y][x-r] == '*' and pole[y+r][x] == '*' and  pole[y-r][x] == '*':\n            r+=1\n        else:\n            return r-1\n    return r-1\n\n\ndef mark_star(x,y,r):\n    if x-r >= 0 and x+r < m and y-r >= 0 and y+r <n:\n        for k in range(x - r, x + r + 1):\n            unfitted[y][k] = False\n        for k in range(y - r, y + r + 1):\n            unfitted[k][x] = False\n\n\nfor i in range(n):\n    pole.append(input().strip()[:m])\n    unfitted.append([True]*m)\n\nfin_res  =[]\nfor x in range(m):\n    for y in range(n):\n        if pole[y][x] == '*':\n            r = get_max_r(x,y)\n            if r>0:\n                mark_star(x,y,r)\n                # print('found atar at', x,y,r)\n                fin_res.append((y+1,x+1,r))\n\n\nfor x in range(m):\n    for y in range(n):\n        if pole[y][x] == '*' and unfitted[y][x]:\n            print(-1)\n            return\n\nprint(len(fin_res))\nfor t in fin_res:\n    print(*t)\n\n\n\n\n\n", "# import logging\n\n\n# fmt = r'%(levelname)s - %(name)s (line:%(lineno)s) - %(message)s'\n# formatter = logging.Formatter(fmt)\n\n# ch = logging.StreamHandler()\n# ch.setLevel(logging.ERROR)\n# ch.setFormatter(formatter)\n\n# logger = logging.getLogger()\n# logger.setLevel(logging.ERROR)\n# logger.addHandler(ch)\n\n\nclass StarCell:\n    def __init__(self, row, col, top=None, bot=None, left=None, right=None):\n        self.row = row\n        self.col = col\n\n        self.covered = False\n\n        self.top = top\n        self.bot = bot\n        self.left = left\n        self.right = right\n\n        self._size = None\n        self._size_top = None\n        self._size_bot = None\n        self._size_left = None\n        self._size_right = None\n    \n\n    def set_adjacents(self, cells):\n        row, col = self.row, self.col\n        self.top = cells.get((row - 1, col), None)\n        self.bot = cells.get((row + 1, col), None)\n        self.left = cells.get((row, col - 1), None)\n        self.right = cells.get((row, col + 1), None)\n\n    def set_covered(self):\n        size = self.size\n        ctop = self\n        cbot = self\n        cleft = self\n        cright = self\n        for _ in range(size):\n            ctop = ctop.top\n            cbot = cbot.bot\n            cleft = cleft.left\n            cright = cright.right\n            ctop.covered = True\n            cbot.covered = True\n            cleft.covered = True\n            cright.covered = True\n\n    @property\n    def size_top(self):\n        if not self.top:\n            return 0\n        if not self._size_top:\n            # Update cache\n            self._size_top = 1 + self.top.size_top\n        return self._size_top\n    \n    @property\n    def size_bot(self):\n        if not self.bot:\n            return 0\n        if not self._size_bot:\n            self._size_bot = 1 + self.bot.size_bot\n        return self._size_bot\n    \n    @property\n    def size_left(self):\n        if not self.left:\n            return 0\n        if not self._size_left:\n            self._size_left = 1 + self.left.size_left\n        return self._size_left\n    \n    @property\n    def size_right(self):\n        if not self.right:\n            return 0\n        if not self._size_right:\n            self._size_right = 1 + self.right.size_right\n        return self._size_right\n    \n    @property\n    def size(self):\n        if not self._size:\n            self._size = min(\n                [self.size_top,\n                self.size_bot,\n                self.size_left,\n                self.size_right])\n        return self._size\n    \n    def __repr__(self):\n        if self.size > 0:\n            return 'Star of max size {}'.format(self.size)\n        return 'Cell covered? {}'.format(self.covered)\n\n\ndef solve(grid):\n    n, m = len(grid), len(grid[0])\n    \n    cells = {}\n    for row in range(n):\n        for col in range(m):\n            if grid[row][col] == '.':\n                continue\n            cells[(row, col)] = StarCell(row, col)\n    \n    for key, val in list(cells.items()):\n        val.set_adjacents(cells)\n\n    for key, val in list(cells.items()):\n        val.set_covered()\n\n    # for key, val in cells.items():\n    #     print(key, val)\n\n\n    ans = []\n    for key, val in list(cells.items()):\n        if val.size == 0 and not val.covered:\n            return None\n        if val.size > 0:\n            ans.append([val.row + 1, val.col + 1, val.size])  # Rebase index 1\n    return ans\n\n\ndef main():\n    n, m = list(map(int, input().strip().split()))\n    grid = [list(input().strip()) for _ in range(n)]\n\n    results = solve(grid)\n    if results is None:\n        print('-1')\n    else:\n        print(len(results))\n        for result in results:\n            print(*result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = input().split()\nn = int(n)\nm = int(m)\nlst = [[0]*m for i in range(n)]\nrec = [[0]*m for i in range(n)]\nfin = [[0]*m for i in range(n)]\nans = 0\ncnt = 0\nfor i in range(n):\n    tmp = input()\n    for j, x in enumerate(tmp):\n        if x == '*':\n            lst[i][j] = 1\nfor i in range(n):\n    for j in range(m):\n        if lst[i][j] == 1 and i > 0 and j > 0 and i < n-1 and j < m-1:\n            tmp = min(i, j, n-1-i, m-1-j)\n            for k in range(tmp, 0, -1):\n                flag = True\n                for x in range(1, k+1):\n                    if lst[i][j-x] == 0 or lst[i][j+x] == 0 or lst[i-x][j] == 0 or lst[i+x][j] == 0:\n                        flag = False\n                if flag:\n                    fin[i][j] = k\n                    break\nfor i in range(n):\n    for j in range(m):\n        if fin[i][j] > 0:\n            tmp = fin[i][j]\n            ans += 1\n            cnt += 1 + tmp * 4\n            rec[i][j] = 1\n            for x in range(tmp+1):\n                rec[i][j+x] = 1\n                rec[i][j-x] = 1\n                rec[i-x][j] = 1\n                rec[i+x][j] = 1\nif rec != lst:\n    print(-1)\nelse:\n    print(ans)\n    for i in range(n):\n        for j in range(m):\n            if fin[i][j] > 0:\n                print(i+1, j+1, fin[i][j])\n", "n, m = map(int, input().split())\nT = [[] for i in range(n)]\nfor i in range(n):\n    a = list(input())\n    T[i] = a\n\nS = [[0] * m for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if T[i][j] == \"*\":\n            S[i][j] = 1\n\nrec = []\nfor i in range(n):\n    for j in range(m):\n        if 1 <= i < n - 1 and 1 <= j < m - 1 and T[i][j] == \"*\" and T[i - 1][j] == \"*\" and T[i][j - 1] == \"*\" and T[i + 1][j] == \"*\" and T[i][j + 1] == \"*\":\n            S[i][j] = 0\n            S[i - 1][j] = 0\n            S[i][j - 1] = 0\n            S[i + 1][j] = 0\n            S[i][j + 1] = 0\n            k = 2\n            while True:\n                if not (0 <= i - k and i + k < n and 0 <= j - k and j + k < m):\n                    break\n                if T[i - k][j] == \"*\" and T[i][j - k] == \"*\" and T[i + k][j] == \"*\" and T[i][j + k] == \"*\":\n                    S[i - k][j] = 0\n                    S[i][j - k] = 0\n                    S[i + k][j] = 0\n                    S[i][j + k] = 0\n                    k += 1\n                else:\n                    break\n            rec.append((i + 1, j + 1, k - 1))\n\nq = 0\nfor i in range(n):\n    for j in range(m):\n        q += S[i][j]\n\nif q == 0:\n    print(len(rec))\n    for i in range(len(rec)):\n        print(\"{} {} {}\".format(rec[i][0], rec[i][1], rec[i][2]))\nelse:\n    print(-1)", "def all_true(stars, n, m):\n    for i in range(n):\n        for j in range(m):\n            if not stars[i][j]:\n                return False\n    return True\n\ndef get_biggest_star(ar, i, j):\n    ans = 0\n    cur = i - 1\n    while cur >= 0 and ar[cur][j] == '*':\n        ans += 1\n        cur -= 1\n\n    length = 0\n    cur = i + 1\n    while cur < n and ar[cur][j] == '*':\n        length += 1\n        cur += 1\n    ans = min(ans, length)\n\n    length = 0\n    cur = j - 1\n    while cur >= 0 and ar[i][cur] == '*':\n        length += 1\n        cur -= 1\n    ans = min(ans, length)\n\n    length = 0\n    cur = j + 1\n    while cur < m and ar[i][cur] == '*':\n        length += 1\n        cur += 1\n    ans = min(ans, length)\n\n    return ans\n\nn, m = list(map(int, input().split()))\n\nar = []\n\nstars = []\n\nfor i in range(n):\n    cur = input()\n    st = []\n    for i in range(m):\n        if cur[i] == '.': st.append(True)\n        else: st.append(False)\n    stars.append(st)\n    ar.append(cur)\n\nfinalAns = []\nans = 0\nfor i in range(1, n - 1):\n    for j in range(1, m - 1):\n        if ar[i][j] == '.': continue\n        length = get_biggest_star(ar, i, j)\n        if length > 0:\n            ans += 1\n            finalAns.append([i+1, j+1, length])\n            stars[i][j] = True\n            temp = 0\n            while temp < length:\n                temp += 1\n                stars[i-temp][j] = True\n            temp = 0\n            while temp < length:\n                temp += 1\n                stars[i+temp][j] = True\n            temp = 0\n            while temp < length:\n                temp += 1\n                stars[i][j-temp] = True\n            temp = 0\n            while temp < length:\n                temp += 1\n                stars[i][j+temp] = True\n\n##print(*stars, sep = '\\n')\n\nif all_true(stars, n, m):\n    print(ans)\n    for i in finalAns:\n        print(*i)\nelse:\n    print(-1)\n            \n", "def main():\n\tinp = []\n\tn, m = list(map(int, input().split()))\n\tremaining = 0\n\tfor _ in range(n):\n\t\tcur_inp = input()\n\t\tinp.append(cur_inp)\n\t\tremaining += cur_inp.count(\"*\")\n\tremaining2 = [[True]*m for _ in range(n)]\n\tres = []\n\tfor x in range(1, n-1):\n\t\tfor y in range(1, m-1):\n\t\t\tif inp[x][y] == \"*\":\n\t\t\t\tlast_size = None\n\t\t\t\tfor size in range(1, min(x+1, n-x, y+1, m-y)):\n\t\t\t\t\tif inp[x-size][y] == inp[x+size][y] == inp[x][y-size] == inp[x][y+size] == \"*\":\n\t\t\t\t\t\tfor x1, y1 in (x-size, y), (x+size, y), (x, y-size), (x, y+size):\n\t\t\t\t\t\t\tif remaining2[x1][y1]:\n\t\t\t\t\t\t\t\tremaining -= 1\n\t\t\t\t\t\t\t\tremaining2[x1][y1] = False\n\t\t\t\t\t\tlast_size = size\n\t\t\t\t\telse:\n\t\t\t\t\t\tbreak\n\t\t\t\tif last_size is not None:\n\t\t\t\t\tif remaining2[x][y]:\n\t\t\t\t\t\tremaining -= 1\n\t\t\t\t\t\tremaining2[x][y] = False\n\t\t\t\t\tres.append((x+1, y+1, last_size))\n\tif remaining:\n\t\tprint('-1')\n\telse:\n\t\tprint(len(res))\n\t\tfor x in res:\n\t\t\tprint(*x)\nmain()\n", "\nimport sys\nimport math\nimport os.path\nfrom copy import deepcopy\nfrom functools import reduce\nfrom pprint import pprint\n\nfrom collections import Counter, ChainMap, defaultdict\nfrom itertools import cycle, chain\nfrom queue import Queue, PriorityQueue, deque\nfrom heapq import heappush, heappop, heappushpop, heapify, heapreplace, nlargest, nsmallest\nimport bisect\n\nfrom statistics import mean, mode, median, median_low, median_high\n\n\n# CONFIG\nsys.setrecursionlimit(10**9)\n\n# LOG \ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return list(map(int, input().split()))\n\n\ndef nio(offset):\n    return [int(x) + offset for x in input().split()]\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n\n# CONVERT\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef toMapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\n\n# SORT\ndef sortId(arr):\n    return sorted(list(range(len(arr))), key=lambda k: arr[k])\n\n\n# MAIN\n\nn,m = ni()\n\ns = [0]*n\n\nfor i in range(n):\n    ss = input()\n    s[i] = ss\n\ndd = [['.' for j in range(m)] for i in range(n)]\n\n# pprint(s)\n# pprint(dd)\n\nres = deque()\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == '*':            \n            # print(i,j)\n            k = 1\n            while 0 <= i - k < n and 0 <= i + k < n and 0 <= j - k < m and 0 <= j + k < m and s[i-k][j] == \"*\" and s[i+k][j] == \"*\" and s[i][j-k] == \"*\" and s[i][j+k] == \"*\":\n                dd[i-k][j] = \"*\"\n                dd[i+k][j] = \"*\"\n                dd[i][j-k] = \"*\"\n                dd[i][j+k] = \"*\"\n                if k == 1:\n                    dd[i][j] = \"*\"\n                    res.append((i+1, j+1, k))\n                else:\n                    res[-1] = (i+1, j+1, k)\n                # print(i,j,k)\n                k+=1\n\n# pprint(dd)\n\ndef check():\n    for i in range(n):\n        for j in range(m):\n            if s[i][j] != dd[i][j]:\n                return False\n    return True\n\nif check():\n    lres = len(res)\n    print(lres)\n    if (lres > 0):\n        print(\"\\n\".join((\" \".join(str(y) for y in x)) for x in res))\nelse:\n    print(-1)\n", "N,M=list(map(int,input().split()))\nL=[]\nfor a in range(N):\n    L.append(list(input()))\nANS=[]\nfor i in range(N):\n    for j in range(M):\n        if(L[i][j]=='*' or L[i][j]=='-'):\n            k=1\n            l=min(i,j,(N-1-i),(M-1-j))\n            while(k<=l):\n                if((L[i+k][j]=='*' or L[i+k][j]=='-') and (L[i][j+k]=='*' or L[i][j+k]=='-') and (L[i-k][j]=='*' or L[i-k][j]=='-') and (L[i][j-k]=='*' or L[i][j-k]=='-')):\n                    L[i][j]='-'\n                    L[i+k][j]='-'\n                    L[i-k][j]='-'\n                    L[i][j+k]='-'\n                    L[i][j-k]='-'\n                    k+=1\n                else:\n                    break\n            if(k>1):\n                ANS.append((i+1,j+1,k-1))\nf=True\nfor a in L:\n    if('*' in a):\n        f=False\n        break\nif(f):\n    print(len(ANS))\n    for a in ANS:\n        print(' '.join(map(str,a)))\nelse:\n    print(-1)\n", "n,m=map(int,input().split())\ng=[[*input()] for _ in range(n)]\nc=[[0 for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n v=0\n for j in range(m):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=v\n v=0\n for j in range(m-1,-1,-1):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=min(c[i][j],v)\nfor j in range(m):\n v=0\n for i in range(n):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=min(c[i][j],v)\n v=0\n for i in range(n-1,-1,-1):\n  v=(v+1)*(g[i][j]=='*')\n  c[i][j]=min(c[i][j],v)\nfor i in range(n):\n for j in range(m):\n  if c[i][j]==1: c[i][j]=0\nfor i in range(n):\n v=0\n for j in range(m):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\n v=0\n for j in range(m-1,-1,-1):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\nfor j in range(m):\n v=0\n for i in range(n):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\n for i in range(n-1,-1,-1):\n  v=max(v-1,c[i][j])\n  if v:g[i][j]='.'\nif all(g[i][j]=='.' for i in range(n) for j in range(m)):\n r=[(i+1,j+1,c[i][j]-1) for i in range(n) for j in range(m) if c[i][j]]\n print(len(r))\n for t in r: print(*t)\nelse:\n print(-1)", "import math as ma\nfrom decimal import Decimal as dec\n\n\ndef li():\n\treturn list(map(int , input().split()))\n\n\n# https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/\ndef modInverse(a , m):\n\tm0 = m\n\ty = 0\n\tx = 1\n\tif (m == 1):\n\t\treturn 0\n\twhile (a > 1):\n\t\tq = a // m\n\t\tt = m\n\t\tm = a % m\n\t\ta = t\n\t\tt = y\n\t\ty = x - q * y\n\t\tx = t\n\tif (x < 0):\n\t\tx = x + m0\n\treturn x\n\n\nm = 10000019\n\n\ndef binomialCoefficient(n , k):\n\tif (k > n - k):\n\t\tk = (n - k) % m\n\tres = 1\n\tfor i in range(k):\n\t\tres = (res * (n - i)) % m\n\t\tres = (res * modInverse((i + 1) , m)) % m\n\treturn res\n\n\ndef num():\n\treturn map(int , input().split())\n\n\ndef nu():\n\treturn int(input())\n\n\ndef find_gcd(x , y):\n\twhile (y):\n\t\tx , y = y , x % y\n\treturn x\n\n\nn , m = num()\na = [0] * n\nb = [0] * n\nfor i in range(n):\n\tx = input()\n\ta[i] = [0] * m\n\tb[i] = [0] * m\n\tfor j in range(m):\n\t\tif (x[j] == \"*\"):\n\t\t\ta[i][j] = 1\npp=[]\nfor i in range(n):\n\tfor j in range(m):\n\t\tu = 0\n\t\td = 0\n\t\tl = 0\n\t\tr = 0\n\t\tif (a[i][j] == 1):\n\t\t\tfor k in range(i - 1 , -1 , -1):\n\t\t\t\tif (a[k][j] == 1):\n\t\t\t\t\tu += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tfor k in range(i + 1 , n):\n\t\t\t\tif (a[k][j] == 1):\n\t\t\t\t\td += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tfor k in range(j - 1 , -1 , -1):\n\t\t\t\tif (a[i][k] == 1):\n\t\t\t\t\tl += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tfor k in range(j + 1 , m):\n\t\t\t\tif (a[i][k] == 1):\n\t\t\t\t\tr += 1\n\t\t\t\telse:\n\t\t\t\t\tbreak\n\t\t\tzz = min(u , d , l , r)\n\t\t\t#print(i,j,zz)\n\t\t\tif(zz==0):\n\t\t\t\tcontinue\n\t\t\tpp.append((i+1,j+1,zz))\n\t\t\tb[i][j] = 1\n\t\t\tc=0\n\t\t\tfor k in range(i - 1 , -1 , -1):\n\t\t\t\tb[k][j]=1\n\t\t\t\tc+=1\n\t\t\t\tif(c==zz):\n\t\t\t\t\tbreak\n\t\t\tc=0\n\t\t\tfor k in range(i + 1 , n):\n\t\t\t\tb[k][j] = 1\n\t\t\t\tc += 1\n\t\t\t\tif (c == zz):\n\t\t\t\t\tbreak\n\t\t\tc=0\n\t\t\tfor k in range(j - 1 , -1 , -1):\n\t\t\t\tb[i][k]=1\n\t\t\t\tc += 1\n\t\t\t\tif (c == zz):\n\t\t\t\t\tbreak\n\t\t\tc=0\n\t\t\tfor k in range(j + 1 , m):\n\t\t\t\tb[i][k] = 1\n\t\t\t\tc+=1\n\t\t\t\tif(c==zz):\n\t\t\t\t\tbreak\nfl=True\nfor i in range(n):\n\tfor j in range(m):\n\t\tif(a[i][j]==1 and b[i][j]==0):\n\t\t\tfl=False\n\t\t\tbreak\nif(fl):\n\tprint(len(pp))\n\tfor i in range(len(pp)):\n\t\tprint(pp[i][0],pp[i][1],pp[i][2])\nelse:\n\tprint(-1)", "def find_stars(h, w, matrix):\n    max_size = 0\n    if matrix[h][w] == '.':\n        return max_size\n\n    size = 1\n    while True:\n        for next_h in range(h, h + size + 1):\n            if next_h >= height or matrix[next_h][w] != '*':\n                return max_size\n        for next_h in range(h, h - size - 1, -1):\n            if next_h < 0 or matrix[next_h][w] != '*':\n                return max_size\n        for next_w in range(w, w + size + 1):\n            if next_w >= width or matrix[h][next_w] != '*':\n                return max_size\n        for next_w in range(w, w - size - 1, -1):\n            if next_w < 0 or matrix[h][next_w] != '*':\n                return max_size\n\n        max_size = size\n        size += 1\n\n\nheight, width = list(map(int, input().split()))\nmatrix = []\nfor h in range(height):\n    row = input()\n    matrix.append(row)\n\nresult_matrix = [['.'] * width for h in range(height)]\nresult_stars = []\nfor h in range(height):\n    for w in range(width):\n        found_max_size = find_stars(h, w, matrix)\n        if found_max_size == 0:\n            continue\n\n        for next_h in range(h, h + found_max_size + 1):\n            result_matrix[next_h][w] = '*'\n        for next_h in range(h, h - found_max_size - 1, -1):\n            result_matrix[next_h][w] = '*'\n        for next_w in range(w, w + found_max_size + 1):\n            result_matrix[h][next_w] = '*'\n        for next_w in range(w, w - found_max_size - 1, -1):\n            result_matrix[h][next_w] = '*'\n\n        result_stars.append(str(h + 1) + ' ' + str(w + 1) + ' ' + str(found_max_size))\n\nis_equal = True\nfor h in range(height):\n    for w in range(width):\n        if matrix[h][w] != result_matrix[h][w]:\n            is_equal = False\n\nif is_equal:\n    print(len(result_stars))\n    for star in result_stars:\n        print(star)\nelse:\n    print(-1)\n", "n, m = map(int, input().split())\nG = []\nL = [[0 for x in range(m + 2)] for x in range(n + 2)]\nR = [[0 for x in range(m + 2)] for x in range(n + 2)]\nU = [[0 for x in range(m + 2)] for x in range(n + 2)]\nD = [[0 for x in range(m + 2)] for x in range(n + 2)]\n\nfor i in range(n):\n    s = input()\n    G.append(s)\n    \nfor i in range(n):\n    \n    nm = 0\n    for j in range(m):\n        if(G[i][j] == '*'):\n            nm += 1\n        else:\n            nm = 0\n        L[i][j] = nm\n        \n    nm = 0\n    for j in range(m - 1, -1, -1):\n        if(G[i][j] == '*'):\n            nm += 1\n        else:\n            nm = 0\n        R[i][j] = nm\n        \nfor j in range(m):\n    \n    nm = 0\n    for i in range(n):\n        if(G[i][j] == '*'):\n            nm += 1\n        else:\n            nm = 0\n        U[i][j] = nm\n    \n    nm = 0\n    for i in range(n - 1, -1, -1):\n        if(G[i][j] == '*'):\n            nm += 1\n        else:\n            nm = 0\n        D[i][j] = nm\n\ncol = [[0 for x in range(m + 2)] for x in range(n + 2)]\nrow = [[0 for x in range(m + 2)] for x in range(n + 2)]\nANS = []\n\nfor i in range(n):\n    for j in range(m):\n        if(G[i][j] == '.'):\n            continue\n        ans = min(U[i][j], L[i][j], R[i][j], D[i][j]) - 1\n        if(ans <= 0):\n            continue\n        ANS.append([i + 1, j + 1, ans])\n        row[i][j - ans] += 1\n        row[i][j + ans + 1] -=1\n        col[i - ans][j] += 1\n        col[i + ans + 1][j] -= 1\n        \n        \nfor i in range(n):\n    for j in range(1, m):\n        row[i][j] += row[i][j - 1]\n\nfor j in range(m):\n    for i in range(1, n):\n        col[i][j] += col[i - 1][j]\n        \nokay = True\nfor i in range(n):\n    for j in range(m):\n        if(G[i][j] == '*' and row[i][j] == 0 and col[i][j] == 0):\n            okay = False\n            \nif(okay):\n    print(len(ANS))\n    for x in ANS:\n        print(x[0], x[1], x[2])\nelse:\n    print(-1)", "n, m = map(int, input().split())\nsky = [0] * (n + 1)\nfor i in range(n):\n    sky[i] = list(input()) + ['.']\nsky[n] = ['.'] * m\nused = [[False] * m for i in range(n)]\nans = []\nfor i in range(n):\n    for j in range(m):\n        if sky[i][j] == '.':\n            continue\n        ln = 1\n        while sky[i - ln][j] == '*' and sky[i + ln][j] == '*' and sky[i][j - ln] == '*' and sky[i][j + ln] == '*':\n            used[i - ln][j] = used[i + ln][j] = used[i][j - ln] = used[i][j + ln] = True\n            ln += 1\n        if ln > 1:\n            used[i][j] = True\n            ans += [[i + 1, j + 1, ln - 1]]\nfor i in range(n):\n    for j in range(m):\n        if sky[i][j] == '*' and not used[i][j]:\n            print(-1)\n            return\nprint(len(ans))\nfor i in range(len(ans)):\n    print(*ans[i])", "import sys\nn,m=list(map(int,input().split()))\ns=[input() for i in range(n)]\ndp=[[-1 for i in range(m)] for j in range(n)]\nans=[]\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if (s[i][j]=='*' and s[i+1][j]=='*' and s[i-1][j]=='*' and s[i][j-1]=='*' and s[i][j+1]=='*'):\n            x=0\n            while i-x>-1 and x+i<n and j-x>-1 and x+j<m and s[i+x][j]=='*' and s[i-x][j]=='*' and s[i][j-x]=='*' and s[i][j+x]=='*':\n                dp[i+x][j],dp[i-x][j],dp[i][j-x],dp[i][j+x]=1,1,1,1\n                x+=1\n            if x!=1:  ans.append([i+1,j+1,x-1])\n            else:dp[i][j]=-1\nfor i in range(n):\n    for j in range(m):\n        if s[i][j]=='*' and dp[i][j]==-1:\n            print(-1)\n            return\nprint(len(ans))\nfor i in ans:\n    print(*i)\n", "import sys\nn,m=list(map(int,input().split()))\ns=[input() for i in range(n)]\ndp=[[-1 for i in range(m)] for j in range(n)]\nans=[]\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if (s[i][j]=='*' and s[i+1][j]=='*' and s[i-1][j]=='*' and s[i][j-1]=='*' and s[i][j+1]=='*'):\n            x=0\n            while i-x>-1 and x+i<n and j-x>-1 and x+j<m and s[i+x][j]=='*' and s[i-x][j]=='*' and s[i][j-x]=='*' and s[i][j+x]=='*':\n                dp[i+x][j],dp[i-x][j],dp[i][j-x],dp[i][j+x]=1,1,1,1\n                x+=1\n            if x!=1:  ans.append([i+1,j+1,x-1])\n            else:dp[i][j]=-1\nfor i in range(n):\n    for j in range(m):\n        if s[i][j]=='*' and dp[i][j]==-1:\n            print(-1)\n            return\nprint(len(ans))\nfor i in ans:\n    print(*i)\n"]