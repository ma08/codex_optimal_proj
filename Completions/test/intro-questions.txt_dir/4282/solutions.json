["n = int(input())\n\nA = [-1]\nans = [1]\n\nfor i in range(n):\n    A.append(tuple(map(int, input().split())))\n\na = A[1][0]\nb = A[1][1]\n\nc = A[a][0]\nd = A[a][1]\n\nif b == c or b == d:\n    ans.append(a)\n    ans.append(b)\nelse:\n    ans.append(b)\n    ans.append(a)\n\nwhile len(ans) != n:\n    p = A[ans[-2]]\n    \n    if p[0] == ans[-1]:\n        ans.append(p[1])\n    else:\n        ans.append(p[0])\n\nfor i in ans:\n    print(i, end=' ')", "from sys import stdin\nn=int(stdin.readline().strip())\nif n==3:\n    print(\"1 2 3\")\n    return\nadj=[(0,0)]\n\nfor i in range(n):\n    a,b=list(map(int,stdin.readline().strip().split()))\n    adj.append((a,b))\ns=[]\nx=1\n\nwhile len(s)<n:\n    if adj[x][0] in adj[adj[x][1]]:\n        s.append(adj[x][1])\n        s.append(adj[x][0])\n        x=adj[x][0]\n    if adj[x][1] in adj[adj[x][0]]:\n        s.append(adj[x][0])\n        s.append(adj[x][1])\n        x=adj[x][1]\nprint(*s[0:n])\n", "def read_nums():\n    return [int(x) for x in input().split()]\n\n\ndef main():\n    n, = read_nums()\n    d = {}\n    for i in range(1, n + 1):\n        d[i] = read_nums()\n\n    circle = {1: d[1][0] if d[1][1] in d[d[1][0]] else d[1][1]}\n\n    prev = 1\n    cur = circle[1]\n    while cur != 1:\n        circle[cur] = list(set(d[prev]) & set(d[cur]))[0]\n        prev = cur\n        cur = circle[cur]\n\n    nums = [1]\n    cur = circle[1]\n    while cur != 1:\n        nums.append(cur)\n        cur = circle[cur]\n    print(' '.join([str(x) for x in nums]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nimport bisect\nimport itertools\nimport sys\nI=lambda : sys.stdin.readline()\nmod=10**9 +7\n'''fact=[1]*100001\nifact=[1]*100001\nfor i in range(1,100001):\n    fact[i]=((fact[i-1])*i)%mod\n    ifact[i]=((ifact[i-1])*pow(i,mod-2,mod))%mod\ndef ncr(n,r):\n    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod\ndef npr(n,r):\n    return (((fact[n]*ifact[n-r])%mod))\n    '''\n\n\ndef mindiff(a):\n    b=a[:]\n    b.sort()\n    m=10000000000\n    for i in range(len(b)-1):\n        if b[i+1]-b[i]<m:\n            m=b[i+1]-b[i]\n    return m\n    \ndef lcm(a,b):\n    return a*b//math.gcd(a,b)\n\n    \ndef merge(a,b):\n    i=0;j=0\n    c=0\n    ans=[]\n    while i<len(a) and j<len(b):\n        if a[i]<b[j]:\n            ans.append(a[i])\n            i+=1\n        else:\n            ans.append(b[j])\n            c+=len(a)-i\n            j+=1\n    ans+=a[i:]\n    ans+=b[j:]\n    return ans,c\ndef mergesort(a):\n    if len(a)==1:\n        return a,0\n    mid=len(a)//2   \n    left,left_inversion=mergesort(a[:mid])\n    right,right_inversion=mergesort(a[mid:])\n    m,c=merge(left,right)\n    c+=(left_inversion+right_inversion)\n    return m,c\n    \ndef is_prime(num):\n    if num == 1: return False\n    if num == 2: return True\n    if num == 3: return True\n    if num%2 == 0: return False\n    if num%3 == 0: return False\n    t = 5\n    a = 2\n    while t <= int(math.sqrt(num)):\n        if num%t == 0: return False\n        t += a\n        a = 6 - a\n    return True\n    \n  \ndef ceil(a,b):\n    if a%b==0:\n        return a//b\n    else:\n        return (a//b + 1)\n\ndef binsearch(arr,b,low,high):\n    if low==high:\n        return low\n    if arr[math.ceil((low+high)/2)]<b:\n        return binsearch(arr,b,low,math.ceil((low+high)/2) -1 )\n    else:\n        return binsearch(arr,b,math.ceil((low+high)/2),high)\ndef ncr1(n,r):\n    s=1\n    for i in range(min(n-r,r)):\n        s*=(n-i)\n        s%=mod\n        s*=pow(i+1,mod-2,mod)\n        s%=mod\n    return s\n    \ndef calc(n,m,r):\n    s=0\n    for i in range(0,r+1,2):\n        s+=ncr1(n,i)*ncr1(m,i)\n        s%=mod\n    return s    \n        \n        \n\n#/////////////////////////////////////////////////////////////////////////////////////////////////\nn=int(input())\nd={}\nfor i in range(1,n+1):\n    x,y=map(int,input().split())\n    d[i]=[x,y]\nd1={}    \nif n==3:\n    print(1,2,3);return\n    \nfor i in range(1,n+1):\n    if d[i][0] in d[d[i][1]]:\n        d1[i]=d[i][1]\n    else:\n        d1[i]=d[i][0]\nk=d1[1]\n\nfor i in range(n):\n    print(k,end=' ')\n    k=d1[k]\n    ", "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\nt = 1\nfrom heapq import heappop, heappush\nfor test in range(t):\n    n = int(input())\n    # a = list(map(int, input().split()))\n    D = {}\n    for i in range(1, n+1):\n        a,b = list(map(int, input().split()))\n        D[i] = [a,b]\n\n    if n==3:\n        ans=(1,2,3)\n    else:\n        ans=[1]    \n        a,b = D[1]\n        if a in D[b]:\n            ans.append(b)\n            ans.append(a)\n        else:\n            ans.append(a)\n            ans.append(b)\n        \n        while len(ans)<n:  \n            a,b = D[ans[-2]]\n            if ans[-1]==a:\n                ans.append(b)\n            else:\n                ans.append(a)\n    print(*ans)\n        \n   \n\n\n", "n = int( input() )\nm = [[0 for i in range(2)] for j in range(n)]\nfor k in range(n):\n\tm[k][0],m[k][1] = map(lambda x: int(x)-1,input().split())\nl=list()\nl.append(0)\nif(m[0][0] in m[m[0][1]]):\n\tl.append(m[0][1])\n\tl.append(m[0][0])\nelse:\n\tl.append(m[0][0])\n\tl.append(m[0][1])\ncpt = 2\nwhile( l[-1] != l[0]):\n\tif( m[l[-2]][0] == l[-1] ):\n\t\tl.append(m[l[-2]][1])\n\telse:\n\t\tl.append(m[l[-2]][0])\nprint(\" \".join(map(lambda x : str(x+1),l[:len(l)-1])))", "import sys\nn=int(sys.stdin.readline())\nl=[]\ndct={}\nfor i in range(n):\n    x=list(map(int,sys.stdin.readline().split()))\n    dct[str(x)]=0\n    l.append(x)\nthis=1\nnxt=-1\nnxt2nxt=-1\nx,y=l[0][0],l[0][1]\nif str([1,y]) in dct or str([y,1]) in dct:\n    nxt=y\n    nxt2nxt=x\nelse:\n    nxt=x\n    nxt2nxt=y\nfor i in range(n):\n    sys.stdout.write(str(this)+\" \")\n    this=nxt\n    nxt=nxt2nxt\n    if(l[this-1][0]==nxt):\n        nxt2nxt=l[this-1][1]\n    else:\n        nxt2nxt=l[this-1][0]", "n=int(input())\np=[]\nfor i in range(n):\n\tx,y=map(int,input().split())\n\tp.append([x-1,y-1])\nans=[]\nk=0\ni=0\n#print(p)\nwhile 1:\n\t#print(i,p[i][0],p[i][1])\n\t#print(p[p[i][0]],p[p[i][1]])\n\tif p[i][0] in p[p[i][1]]:\n\t\tans+=[i,p[i][1]]\n\t\ti = p[i][0]\n\telse:\n\t\tans += [i,p[i][0]]\n\t\ti=p[i][1]\n\t#print(ans,i)\n\tk+=2\n\tif k>=n:\n\t\tbreak\n#print(ans)\nfor i in range(n):\n\tprint(ans[i]+1,end=\" \")\n", "n = int(input())\nsosed = dict()\nfor c in range(n):\n    sosed[c+1] = set()\nz1, z2 = map(int, input().split())\nsosed[z1].add(z2)\nsosed[z2].add(z1)\ni = [z1, z2]\nfor __ in range(1, n):\n    z1, z2 = map(int, input().split())\n    sosed[z1].add(z2)\n    sosed[z2].add(z1)\n    if z1 == 1 or z2 == 1:\n        if max(z1, z2) in i:\n            i = [max(z1, z2)]\npred = set()\ncnt = 0\ni = i[0]\nprint(1, end=\" \")\npred.add(1)\nwhile cnt < n-1:\n    cnt += 1\n    print(i, end=\" \")\n    pred.add(i)\n    for y in sosed[i]:\n        if y not in pred:\n            i = y\n", "n = int(input())\n\nv = {}\n\nfor i in range(1, n + 1):\n    v[i] = set(map(int, input().split()))\n\nans = []\n\nans_s = set()\n\nans.append(1)\n\nans_s.add(1)\n\nwhile len(ans) < n:\n    for i in v[ans[-1]]:\n        if len(v[i].intersection(v[ans[-1]])) > 0 and i not in ans_s:\n            ans.append(i)\n            ans_s.add(i)\n            break\n\n\nprint(\" \".join(map(str, ans)))", "n=int(input())\nmas=[]\nitog=[]\nfor i in range(n):\n    a=list(map(int,input().split()))\n    mas.append(a)\nitog.append(1)\np=0\nwhile len(itog)<n-1:\n    if (mas[p][1] in mas[mas[p][0]-1]):\n        itog.append(mas[p][0])\n        p=mas[p][0]-1\n    else:\n        itog.append(mas[p][1])\n        p=mas[p][1]-1\n        \nif (mas[p][1] in mas[mas[p][0]-1]) and not(mas[p][0] in itog):\n    itog.append(mas[p][0])\n    p=mas[p][0]-1\nelse:\n    itog.append(mas[p][1])\n    p=mas[p][1]-1\n    \nfor i in itog:\n    print(i,end=\" \")\n", "n = int(input())\nd = []\nfor i in range(n):\n    x = input().split()\n    d.append([int(x[0]) - 1, int(x[1]) - 1])\nfirst = d[0][0]\nsecond = d[0][1]\nif (d[first][0] != second and d[first][1] != second):\n    t = first;\n    first = second\n    second = t\nans = [1, first + 1]\nnex = second\nwhile (nex != 0):\n    ans.append(nex + 1)\n    if (d[first][0] == second):\n        nex = d[first][1]\n    else:\n        nex = d[first][0]\n    first = second\n    second = nex\nfor i in ans:\n    print(i, end=\" \")", "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn = ii()\nif n == 3:\n    ans = [1, 2, 3]\nelse:\n    a = [None] + [li() for i in range(n)]\n    ans = []\n    i = 1\n    while 1:\n        ans.append(i)\n        j = a[i][0]\n        if a[i][1] not in a[j]:\n            j = a[i][1]\n        i = j\n        if i == 1: break\nprint(*ans)\n", "n = int(input())\nL = []\nfor _ in range(n):\n    x,y = [int(x)-1 for x in input().split()]\n    L.append((x,y))\n\nif n == 3:\n    print('1 2 3')\nelse:\n    order = ['1']\n    count = 1\n    current = 0\n    while count < n:\n        a,b = L[current]\n        if b in L[a]:\n            order.append(str(a+1))\n            count += 1\n            current = a\n        else:\n            order.append(str(b+1))\n            count += 1\n            current = b\n    print(' '.join(order))\n", "n = int(input())\ng = {i: set() for i in range(1, n + 1)}\nd = {i: set() for i in range(1, n + 1)}\n\nfor i in range(1, n + 1):\n    x, y = list(map(int, input().split()))\n    g[x].add(y)\n    g[y].add(x)\n    d[i].add(x)\n    d[i].add(y)\n\na = [1]\nb = set(a)\ni = 1\nc = 0\nwhile c < n:\n    x = g[i]\n    y = d[i]\n    for j in y:\n        if j in x and j not in b:\n            a.append(j)\n            b.add(j)\n            i = j\n            break\n    c += 1\nprint(*a)\n", "n = int(input())\nd = {}\nfor i in range(1, n + 1):\n    d[i] = [*map(int, input().split())]\n\nu = n - 1\nc1 = 1\na, b = d[c1]\nif b in d[a]:\n    c2 = a\nelse:\n    c2 = b\n\n\np = lambda x: print(x, end=' ')\n\np(c1)\nwhile u > 0:\n    p(c2)\n    (c3,) = set(d[c1]).intersection(set(d[c2]))\n    c2, c1 = c3, c2\n    u -= 1", "n = int(input())\na = [[0, 0]]\nans = [1]\nfor i in range(n):\n    a.append([int(x) for x in input().split()])\n    \noptions  = a[1]\nans.append(options[0])\nans.append(options[1])\n\nif ans[-1] not in a[ans[-2]]:\n    ans[1], ans[2] = ans[2], ans[1]\n\n\nfor i in range(1, n - 1):\n    \n    options = a[ans[i]]\n    #print('We are at', ans[i], options, ans)\n    idx = options.index(ans[-1])\n    rem = options[1 - idx]\n    ans.append(rem)\n\nprint(*ans[:-1])\n    \n", "n = int(input())\nd = {}\nsees = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    if a not in d:\n        d[a] = set()\n    if b not in d:\n        d[b] = set()\n    d[a].add(b)\n    d[b].add(a)\n    sees.append(set((a, b)))\nres = []\nif b in sees[a-1]:\n    res.extend([a, b])\n    d[b].remove(a)\nelse:\n    res.extend([b, a])\n    d[a].remove(b)\nfor _ in range(n-2):\n    last = res[-1]\n    nex = d[last].pop()\n    d[nex].remove(last)\n    res.append(nex)\nfor r in res:\n    print(r, end=' ')\nprint()\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nP=[list(map(int,input().split())) for i in range(n)]\n\nx,y=P[0]\n\nif y in P[x-1]:\n    print(1,x,end=\" \")\n    n=x\n    nn=y\nelse:\n    print(1,y,end=\" \")\n    n=y\n    nn=x\n\nwhile nn!=1:\n    k,u=P[n-1]\n    print(nn,end=\" \")\n    if k==nn:\n        n,nn=nn,u\n    else:\n        n,nn=nn,k\n    \n", "def func():\n    n = int(input())\n    g = [()] + [set(map(int, input().split())) for i in range(n)]\n    # print(g)\n    if n == 3:\n        print(1, 2, 3)\n        return None\n\n    xor = [1]\n    for i in range(n-1):\n        # print(xor)\n        x, y = (j for j in g[xor[-1]])\n        # print(x,y)\n        if x in g[y]:\n            xor.append(y)\n        elif y in g[x]:\n            xor.append(x)\n    print(' '.join(map(str, xor)))\n\n\nfunc()", "n = int(input())\na = [list(map(lambda x: x - 1, map(int, input().split()))) for i in range(n)]\nstart = 0\nflag = False\nans = []\nshould_be = -1\nwhile True:\n  if start == 0 and flag == True:\n    break\n  ans.append(start + 1)\n  flag = True\n  next = a[start][0]\n  ok = should_be == -1 or should_be == next\n  if ok and (a[start][1] == a[next][0] or a[start][1] == a[next][1]):\n    if should_be > -1:\n      assert next == should_be\n    should_be = a[start][1]\n    start = next\n    continue\n  next = a[start][1]\n  ok = should_be == -1 or should_be == next\n  if ok and (a[start][0] == a[next][0] or a[start][0] == a[next][1]):\n    if should_be > -1:\n      assert next == should_be\n    should_be = a[start][0]\n    start = next\n    continue\n  assert False\nfor x in ans:\n  print(x, end=' ')\n", "def read(type = 1):\n    if type:\n        file = open(\"input.dat\", \"r\")\n        n = int(file.readline())\n        a = []\n        for i in range(n):\n            a.append(list(map(int, file.readline().split())))\n        file.close()\n    else:\n        n = int(input().strip())\n        a = []\n        for i in range(n):\n            a.append(list(map(int, input().strip().split())))\n    return n, a\n\n\ndef solve():\n    sol = [1]\n    used = [0 for i in range(n)]\n    while len(sol) < n - 1:\n        last = sol[-1] - 1\n        used[last] = 1\n        if a[last][0] in a[a[last][1]-1]:\n            sol.append(a[last][1])\n            used[a[last][1]-1] = 1\n            sol.append(a[last][0])\n        else:\n            sol.append(a[last][0])\n            used[a[last][0] - 1] = 1\n            sol.append(a[last][1])\n    used[sol[-1] - 1] = 1\n    if len(sol) != n:\n        for i in range(n):\n            if used[i] == 0:\n                sol.append(i+1)\n    return sol\n\n\ndef write(sol):\n    line = \"\"\n    for v in sol:\n        line += str(v) + \" \"\n    print(line)\n\n\nn, a = read(0)\nsol = solve()\nwrite(sol)", "n = int(input())\n\narr = [-1]\n\na = [[]]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\n\narr.append(1)\nif a[1][0] not in a[a[1][1]]:\n    arr.append(a[1][0])\n    arr.append(a[1][1])\nelse:\n    arr.append(a[1][1])\n    arr.append(a[1][0])\nwhile(len(arr) < n+1):\n    if a[arr[-2]][0]  != arr[-1]:\n        arr.append(a[arr[-2]][0])\n    else:\n        arr.append(a[arr[-2]][1])\n\nfor i in range(1,len(arr)-1):\n    print(arr[i],end=\" \")\nprint(arr[n])", "n = int(input())\n\narr = [-1]\n\na = [[]]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\n\narr.append(1)\nif a[1][0] not in a[a[1][1]]:\n    arr.append(a[1][0])\n    arr.append(a[1][1])\nelse:\n    arr.append(a[1][1])\n    arr.append(a[1][0])\nwhile(len(arr) < n+1):\n    if a[arr[-2]][0]  != arr[-1]:\n        arr.append(a[arr[-2]][0])\n    else:\n        arr.append(a[arr[-2]][1])\n\nfor i in range(1,len(arr)-1):\n    print(arr[i],end=\" \")\nprint(arr[n])", "#15:35\n\nn = int(input())\ncirc = []\nl = []\n\nfor i in range(n):\n    a1, a2 = map(int, input().split())\n    a1 -= 1\n    a2 -= 1\n\n    l.append((a1, a2))\n\ncirc.append(l[0][0])\ncirc.append(l[0][1])\n\nfor i in range(0, n - 1):\n    p = l[circ[i]]\n    \n    if circ[i + 1] not in p:\n        circ[i], circ[i + 1] = circ[i + 1], circ[i]\n\n    p = l[circ[i]]\n\n    if circ[i + 1] == p[0]:\n        circ.append(p[1])\n\n    else:\n        circ.append(p[0])\n\nfor i in range(n):\n    print(circ[i] + 1, end = ' ')\n"]