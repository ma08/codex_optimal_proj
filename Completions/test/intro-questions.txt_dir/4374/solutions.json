["import math\nn,m=map(int,input().split())\nneigh=[]\nfor i in range(n):\n    neigh.append([])\nfor i in range(m):\n    a,b=map(int,input().split())\n    neigh[a-1].append(b-1)\n    neigh[b-1].append(a-1)\nseen=set()\nindex=[0]*n\ndiams=[]\ntrees=0\nfor i in range(n):\n    if i not in seen:\n        trees+=1\n        index[i]=trees\n        seen.add(i)\n        layer=[i]\n        prev=None\n        pars=[None]\n        while layer!=[]:\n            newlayer=[]\n            newpars=[]\n            for i in range(len(layer)):\n                vert=layer[i]\n                par=pars[i]\n                for child in neigh[vert]:\n                    if child!=par:\n                        newlayer.append(child)\n                        newpars.append(vert)\n                        index[child]=trees\n                        seen.add(child)\n            prev=layer\n            layer=newlayer\n            pars=newpars\n        far=prev[0]\n        layer=[[far]]\n        pars=[None]\n        prev=None\n        while layer!=[]:\n            newlayer=[]\n            newpars=[]\n            for i in range(len(layer)):\n                vert=layer[i][-1]\n                par=pars[i]\n                for child in neigh[vert]:\n                    if child!=par:\n                        newlayer.append(layer[i]+[child])\n                        newpars.append(vert)\n            prev=layer\n            layer=newlayer\n            pars=newpars\n        diam=prev[0]\n        lent=len(diam)\n        mid=diam[lent//2]\n        diams.append((lent-1,mid))\ndiams.sort(reverse=True)\nposs=[diams[0][0]]\nif len(diams)>1:\n    poss.append(math.ceil(diams[0][0]/2)+1+math.ceil(diams[1][0]/2))\nif len(diams)>2:\n    poss.append(math.ceil(diams[1][0]/2)+2+math.ceil(diams[2][0]/2))\nprint(max(poss))\ncent=diams[0][1]\nfor i in range(len(diams)-1):\n    print(cent+1,diams[i+1][1]+1)", "import sys\n\n\ndef dfs(v, d, prev, i):\n    nonlocal mid\n    nonlocal M\n    M[v] = False\n    way[d] = v\n    if way[d + 1] == 0:\n        mid[i] = way[d // 2]\n    mx = (d, v)\n    for x in E[v]:\n        if x != prev:\n            mx = max(mx, dfs(x, d + 1, v, i))\n\n    return mx\n\n\nsys.setrecursionlimit(2000)\nn, m = list(map(int, input().split()))\n\nE = [[] for i in range(n + 1)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    E[a].append(b)\n    E[b].append(a)\n\nmid = [0] * (n + 2)\nc = 0\nk = 0\nway = [0] * (n + 2)\n\nM = [True] * (n + 1)\nM[0] = False\ni = -1\nwhile True in M:\n    i += 1\n    idx = M.index(True)\n    p1 = dfs(idx, 0, 0, i)[1]\n    way = [0] * (n + 2)\n    s, p2 = dfs(p1, 0, 0, i)\n    if s > c:\n        c = s\n        k = i\nr = []\nfor j in range(0, i + 1):\n    if j == k:\n        continue\n    r.append((mid[k], mid[j]))\n    E[mid[k]].append(mid[j])\n    E[mid[j]].append(mid[k])\np1 = dfs(1, 0, 0, n + 1)[1]\ns, p2 = dfs(p1, 0, 0, n + 1)\nprint(s)\nfor item in r:\n    print(item[0], item[1])\n", "import sys\nsys.setrecursionlimit(1100)\n\ndef dfs1(u,pre):            #find the components\n    vis[u] = True\n    now.append(u)\n    for v in to[u]:\n        if v!=pre:dfs1(v,u)\n\ndef dfs2(u,pre):            #calulate the distance\n    mxdist[u]=dist[u]\n    for v in to[u]:\n        if v!=pre:\n            dist[v] = dist[u]+1\n            dfs2(v,u)\n            mxdist[u]=max(mxdist[u],mxdist[v])\n\ntry:\n    lab = 1\n    n, m = [int(x) for x in input().split()]\n    to = [[] for i in range(n+10)]\n    dist = [0 for i in range(n+10)]\n    mxdist = [0 for  i in range(n+10)]\n\n    lab = 2\n    for i in range(m):\n        u,v = [int(x) for x in input().split()]\n        to[u].append(v)\n        to[v].append(u)\n\n    com=[]\n    vis=[False for i in range(n+10)]\n    for i in range(1,n+1):\n        if vis[i]==False:\n            now=[]\n            dfs1(i,0)\n            com.append(now)\n\n    lab = 3\n    ct = []\n    mx = 0\n    for lis in com:\n        tmp = []\n        d = 0\n        for root in lis:\n            for u in lis:dist[u]=mxdist[u]=0\n            dfs2(root,0)\n            tmp.append((mxdist[root],root))\n            d = max( d, sum( sorted([ mxdist[u] for u in to[root] ])[-2:] ) )\n            #print(*[mxdist[u] for u in lis])\n        mx = max(mx,d)\n        #print('d =',d)\n        for x in tmp:\n            if x[0]==(d+1)//2:\n                center = [x[1] for x in tmp if x[0]==(d+1)//2][0]\n        ct.append( ((d+1)//2,center) )\n\n    #print(*ct)\n\n    lab = 4\n    ct.sort(reverse=True)\n    ans = []\n    for i in range(1,len(ct)):\n        mx = max(mx,ct[i][0]+1+ct[0][0])\n        if i>1:mx = max(mx,ct[i][0]+2+ct[1][0])\n        ans.append((ct[i][1],ct[0][1]))\n    print(mx)\n    for p in ans:\n        print(*p)\nexcept Exception as e:\n    print('error after lable',lab,', type =',e)\n", "import sys\nsys.setrecursionlimit(10000)\nclass Tree():\n   def __init__(self, nodes):\n     self.root = None\n\nclass Node():\n  def __init__(self, val):\n    self.parent = None\n    self.val = val\n    self.children = []\n  def add(self, child):\n    self.children.append(child)\n  def get_max_dist(self, parent,dist):\n     max_dist = dist\n     for i in self.children:\n        if i != parent:\n           d = i.get_max_dist(self, dist+1)\n           if max_dist < d:\n              max_dist = d\n     return max_dist\n  def get_dist(self):\n     return self.get_max_dist(self, 0)\n  def get_count_ch(self, parent):\n     count = len(self.children)\n     for i in self.children:\n        if i != parent:\n           count += i.get_count_ch(self)-1\n     return count\n  def calc_child(self):\n     return (self.get_count_ch(None),len(self.children), self.val)\n     \nclass Forest():\n  def __init__(self, count):\n    self.nodes = []  \n    self.count = count\n    self.set_nodes = set()\n  def build(self):\n    roots = []\n    max_dist = []\n    #diam = []\n    list_root = []\n    for i in self.nodes:\n       tree =(list([x.get_dist() for x in i]))\n       ma = max(tree)\n       max_dist.append(ma)\n       #diam.append(ma)\n       m = i[tree.index(min(tree))]\n       roots.append(m)#.val)\n    if len(roots) > 1:\n       ind = max_dist.index(max(max_dist))\n       if len(roots) > 1 and ind != 0:\n          roots[0], roots[ind] = roots[ind], roots[0]\n    s = set()\n    for i in self.nodes:\n      for j in i:\n        s.add(j.val)\n    r = list(set(range(1, n+1))-s)\n    \n    if len(roots) > 0:# and len(diam) > 0:\n       for i in range(1, len(roots)):\n          self.add(roots[0].val, roots[i].val)\n          list_root.append((roots[0].val, roots[i].val))\n       #print(roots + r)\n   \n       for i in r:\n         self.add(roots[0].val, i)\n         list_root.append((roots[0].val, i))\n    else:\n       if len(r) == 1:\n          print(0)\n          return\n       elif len(r) > 1:\n          for i in range(1, len(r)):\n             self.add(r[0], r[i])\n             list_root.append((r[0], r[i]))\n    distances = []\n    for i in self.nodes[0]:\n       dist =(i.get_dist())\n       distances.append(dist)\n    print(max(distances))\n    for i in list_root:\n       print(*i)\n       \n  def add(self, v, u):\n    self.set_nodes.add(v)\n    self.set_nodes.add(u)\n    v_node, v_list = self.find(v)\n    u_node, u_list = self.find(u)\n    #print(v_node, u_node)\n    if v_node == None and u_node == None:\n      v_node = Node(v)\n      u_node = Node(u)\n      v_node.add(u_node)\n      u_node.add(v_node)\n      self.nodes.append([v_node, u_node])\n    elif v_node != None and u_node != None and v_list != u_list:\n      v_node.add(u_node)\n      u_node.add(v_node)\n      v_list += u_list\n      self.nodes.remove(u_list)\n    elif v_node == None and u_node != None:\n      v_node = Node(v)\n      u_node.add(v_node)\n      v_node.add(u_node)\n      u_list.append(v_node)\n    elif v_node != None and u_node == None:\n      u_node = Node(u)\n      v_node.add(u_node)\n      u_node.add(v_node)\n      v_list.append(u_node)\n  def find(self, value):\n    for i_list in self.nodes:\n      for i in i_list:        \n        if i.val == value:\n          return i, i_list\n    return None, None\nn,m = list(map(int,input().split()))\nf = Forest(n)\nfor i in range(m):\n  v,u = list(map(int,input().split()))\n  f.add(v, u)\n\n#print(f.nodes)\nf.build()\n"]