["from collections import defaultdict\nN, M = list(map(int, input().split()))\n\nd = defaultdict(list)\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    d[a].append(b)\n    d[b].append(a)\n\n\ndef dfs(n, path):\n    count = 0\n    path.append(n)\n    if len(path) == N:\n        count += 1\n        return count\n    for i in d[n]:\n        if i not in path:\n            count += dfs(i, path)\n            path.pop()\n\n    return count\n\n\nprint((dfs(1, [])))\n", "import itertools\nn,m=map(int,input().split())\nedge=[[] for i in range(n+1)]\nfor i in range(m):\n  a,b=map(int,input().split())\n  edge[a].append(b)\n  edge[b].append(a)\nans=0\nfor junretu in list(itertools.permutations(list(range(2,n+1)))):\n  now=1\n  flag=True\n  for i in list(junretu):\n    if not(i in edge[now]):\n      flag=False\n      break\n    now=i\n  if flag:\n    ans+=1\nprint(ans)  ", "import itertools\n\nn, m = list(map(int, input().split()))\nlis = []\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    lis.append((a, b))\n\nLIS = [i for i in range(2, n + 1)]\nbig_lis = list(itertools.permutations(LIS))\nL = len(big_lis)\n\nans2 = 0\nfor j in range(L):\n    i = 1\n    ans1 = 1\n    for k in big_lis[j]:\n        if((i, k) not in lis) & ((k, i) not in lis):\n            ans1 = 0\n        i = k\n    ans2 += ans1\nprint(ans2)\n", "N, M = map(int, input().split())\nEdge = [tuple(map(int, input().split())) for _ in range(M)]\n\nGraph = [[] for _ in range(N)]\nfor a,b in Edge:\n    Graph[a-1].append(b-1)\n    Graph[b-1].append(a-1)\n\n\ndef dfs(v, seen):\n    nonlocal Graph\n    seen.add(v)\n    if len(seen) == N:\n        seen.remove(v)\n        return 1\n    Res = [dfs(nv, seen) for nv in Graph[v] if not nv in seen]\n    seen.remove(v)\n    return sum(Res)\n\nprint(dfs(0, set()))", "from itertools import permutations\nfrom math import factorial\n\nn, m = map(int, input().split(' '))\nedge = []\nfor i in range(m):\n    ai, bi = map(int, input().split(' '))\n    edge.append([ai, bi])\n\nl = [i for i in range(1, n+1)]\nls = list(permutations(l))\nans = 0\nfor i in range(factorial(n-1)):\n    y = 0\n    for j in range(n-1):\n        for k in edge:\n            if (ls[i][j+1] in k) and (ls[i][j] in k):\n                y += 1\n    if y == n-1:\n        ans += 1\n\nprint(ans)", "import itertools\n\nn,m=map(int,input().split())\nrin=[[]for _ in range(n)]\nfor _ in range(m):\n  a,b=map(int,input().split())\n  rin[a-1].append(b-1)\n  rin[b-1].append(a-1)\n  \nli=[ i for i in range(2,n+1)]\n\nans=0\n\nfor v in itertools.permutations(li):\n  pas=0\n  ch=0\n  st=1\n  for x in range(n-1):\n    if v[x]-1 not in rin[st-1]:\n      ch+=1\n      break\n    else:\n      st=v[x]\n  if ch==0:\n    ans+=1\n    \nprint(ans)", "from itertools import permutations\n\nN, M = map(int, input().split())\npath = [[False] * N for _ in range(N)]\n\nfor i in range(M):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    path[a][b] = path[b][a] = True\n\n    ans = 0\n    for i in permutations(range(N), N):\n        if i[0] == 0:\n            for j in range(N):\n                if j == N - 1:\n                    ans += 1\n                    break\n                if not path[i[j]][i[j + 1]]:\n                    break\n\nprint(ans)", "N, M = map(int, input().split())\nleng = [set() for i in range(N+1)]\nres = 0\nfor _ in range(M):\n  a,b = map(int, input().split())\n  leng[a].add(b)\n  leng[b].add(a)\ndef check(arr):\n  for i in range(N-1):\n    if arr[i+1] not in leng[arr[i]]:\n      return False\n  return True\n\nimport itertools\nfor i in itertools.permutations([x for x in range(2,N+1)]):\n  if check([1]+list(i)):\n    res += 1\nprint(res)", "import itertools\n\nN, M = list(map(int, input().split()))\n\ngraph = [[False]*N for _ in range(N)]\n\nfor _ in range(M):\n    a, b = [int(x)-1 for x in input().split()]\n    graph[a][b] = True\n    graph[b][a] = True\n\nans = 0\n\n#\u9802\u70b9\u3092\u4e26\u3073\u66ff\u3048\u308b\u9806\u5217\u3092\u751f\u6210\u3057\u3066\u30eb\u30fc\u30d7\nfor path in itertools.permutations(list(range(N)), N):\n    if path[0] == 0: #\u5148\u982d\u304c\u9802\u70b91\u306e\u6642\n        for i in range(N):\n            if i==N-1:\n                ans += 1\n                break\n            if not graph[path[i]][path[i+1]]:\n                break\nprint(ans)\n", "import itertools\n\nn, m = map(int, input().split())\ng = [[0]*n for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    g[a][b] = 1\n    g[b][a] = 1\n\na = list(itertools.permutations(range(n)))\nans = 0\nfor i in a:\n    if i[0] != 0:\n        break\n    for j in range(n-1):\n        if g[i[j]][i[j+1]] == 0:\n            break\n    else:\n        ans += 1\nprint(ans)", "import itertools\n\nn, m = map(int, input().split())\nab = [list(map(int, input().split())) for _ in range(m)]\n\n# generate permunations from Node 2 to Node n\np = itertools.permutations(range(2, n + 1), n - 1)\n\ncnt = 0\nfor v in p:\n    if [1, v[0]] not in ab and [v[0], 1] not in ab:\n        continue\n    else:\n        if all([n0, n1] in ab or [n1, n0] in ab for n0, n1 in zip(v, v[1:])):\n            cnt += 1\nprint(cnt)", "def dfs(place,number,checkedList,path):\n  checkedList[place] = 1\n  if sum(checked) == number:\n    return 1\n  pathNumber = 0\n  for i in path[place]:\n    if checkedList[i] == 1:\n      continue\n    pathNumber += dfs(i,number,checkedList,path)\n    checkedList[i] = 0\n  return pathNumber  \n\nn, m = map(int, input().split())\n\nchecked = [0] * 8\npath = [ [] for _ in range(8)]\nfor i in range(m):\n  a, b = map(int, input().split())\n  path[a-1].append(b-1)\n  path[b-1].append(a-1)\n  #print(path)\n  \nprint(dfs(0,n,checked,path))", "N, M = map(int,input().split())\nadj = [set() for i in range(N+1)]\nfor i in range(M):\n\tu, v = map(int,input().split())\n\tadj[u].add(v)\n\tadj[v].add(u)\n\ndef good(p):\n\tfor i in range(N-1):\n\t\tif p[i+1] not in adj[p[i]]:\n\t\t\treturn False\n\treturn True\n\nans = 0\n\nfrom itertools import permutations\nfor p in permutations(range(2,N+1)):\n\tif good([1]+list(p)):\n\t\tans += 1\n\nprint(ans)", "import itertools\n\nn,m=map(int,input().split())\nemp=[[] for i in range(n)]\ncount=0\n\nfor i in range(m):\n    a,b=map(int,input().split())\n    emp[a-1].append(b-1)\n    emp[b-1].append(a-1)\n\nnlis=[i for i in range(n)]\nperm=list(itertools.permutations(nlis))\n\nfor one_case in perm:\n    if one_case[0]==0:\n        cou=0\n        for i in range(n-1):\n            if one_case[i+1] in emp[one_case[i]]:\n                cou+=1\n            \n            if cou==n-1:\n                count+=1\nprint(count)", "import itertools\nN, M = map(int, input().split())\nedges = [list(map(int, input().split())) for i in range(M)]#\u8fba\u306e\u96c6\u5408\ngraph =[[] for i in range(N+1)]#\u96a3\u63a5\u30ea\u30b9\u30c8\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\nnode = [i for i in range(1, N+1)]\nper_list = list(itertools.permutations(node))#\u9806\u5217\u751f\u6210\ncount = 0\nfor l in per_list:#\u5168\u3066\u306e\u9806\u5217\u306b\u3064\u3044\u3066\u6761\u4ef6\u3092\u6e80\u305f\u3059\u304b\u3069\u3046\u304b\u63a2\u7d22\n    if l[0] != 1:#\u958b\u59cb\u30ce\u30fc\u30c9\u304c1\u3058\u3083\u306a\u304b\u3063\u305f\u3089\u30c0\u30e1\n        continue\n    flg = 0\n    for i in range(len(l)-1):\n        if not (l[i+1] in graph[l[i]]):#\u30b0\u30e9\u30d5\u306e\u9593\u306b\u8fba\u304c\u306a\u304b\u3063\u305f\u3089\n            flg = 1\n            break\n    if not flg:#\u30d5\u30e9\u30b0\u304c\u305f\u3063\u3066\u306a\u304b\u3063\u305f\u3089\n        count += 1\n\nprint(count)", "N, M = list(map(int, input().split()))\n\n\ndef dfs(node):\n    if sum([1 for v in visited if v]) == N:\n        return 1\n    ret = 0\n    for n in graph[node]:\n        if visited[n]:\n            continue\n        visited[n] = True\n        ret += dfs(n)\n        visited[n] = False\n    return ret\n\n\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n\nvisited = [False for _ in range(N)]\nvisited[0] = True\nprint((dfs(0)))\n", "import itertools\n\nn, m = list(map(int, input().split()))\n\n#\u96a3\u63a5\u884c\u5217\npath=[[False]* n for _ in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    path[a][b] = True\n    path[b][a] = True\n\nans = 0\n\nfor i in itertools.permutations(list(range(n))):\n\t#\u9802\u70b9\uff11\u304c\u59cb\u70b9\n\tif i[0]==0:\n\t\t# \u751f\u6210\u3057\u305f\u9806\u5217\u306e\u4e2d\u3092\u3055\u3089\u306b\u30eb\u30fc\u30d7\n\t\tfor j in range(n):\n\t\t\t# n - 1 \u307e\u3067\u7d9a\u3044\u305f\u3089\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30d1\u30b9\u304c\u5b58\u5728\u3059\u308b\n\t\t\tif j == n-1:\n\t\t\t\tans+=1\n\t\t\t\tbreak\n\t\t\t# i[j] \u304b\u3089 i[j + 1] \u306b\u884c\u304f\u30d1\u30b9\u304c\u306a\u3051\u308c\u3070\u7d42\u4e86\n\t\t\tif not path[i[j]][i[j + 1]]:\n\t\t\t\tbreak\nprint(ans)\n", "def dfs(g,v,depth):\n    if seen[v]==True:return 0\n    if depth==n:return 1\n    seen[v] = True\n    paths = 0\n    for next_v in g[v]:\n        paths += dfs(g,next_v,depth+1)\n    seen[v] = False\n    return paths\n        \nn,m = map(int,input().split())\n\ng = [[]*(n+1) for _ in range(n+1)]\n\nfor _ in range(m):\n    a,b = map(int,input().split())\n    g[a].append(b)\n    g[b].append(a)\n\nseen = [False]*(n+1)\n    \nprint(dfs(g,1,1))", "import itertools\n\nN,M=map(int,input().split())\ns=[list(map(int,input().split())) for _ in range(M)]\n\nlst=[x for x in range(2,N+1)]   \nl=itertools.permutations(lst)\n\nans=0\nfor num in l:\n\tt=[1]+list(num)\n\tok=True\n\tfor j in range(N-1):\n\t\tp=sorted([t[j], t[j+1]])\n\t\tif not p in s:\n\t\t\tok=False\n\t\t\tbreak\n\tif ok:\n\t\tans+=1\n\t\t\t\t\nprint(ans)", "def dfs(start,path):\n    res = 0\n    path.append(start)\n    if len(path) == N:\n        res += 1\n        return res\n    for i in graph[start]:\n        if i not in path:\n            res += dfs(i,path)\n            path.pop()\n    return res\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N)]\nfor i in range(M):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\nprint(dfs(0,[]))", "\nN,M=map(int,input().split())\npath_matrix=[]\nfor i in range(N):\n    path_matrix.append([False]*N)\n\nfor i in range(M):\n    a,b=map(int,input().split())\n    path_matrix[a-1][b-1]=True\n    path_matrix[b-1][a-1]=True\nview=[False]*N\n\ndef path(x,depth):\n    if view[x-1]:\n        return False\n    \n    if depth==N-1:\n        return True\n\n    view[x-1]=True\n    total_ans=0\n    for i in range(N):\n        if path_matrix[x-1][i]:\n            total_ans+=int(path(i+1,depth+1))\n    \n    view[x-1]=False\n\n    return total_ans\n\nprint(path(1,0))", "#\u7121\u5411\u30b0\u30e9\u30d5\nfrom itertools import permutations\nn,m=map(int,input().split())\ndata=[[False]*n for i in range(n)]\nfor i in range(m):\n  a,b=map(int,input().split())\n  a-=1\n  b-=1\n  data[a][b]=True\n  data[b][a]=True\nans=0\nfor i in permutations(range(n),n):\n  if i[0]==0:\n    for j in range(n):\n      if j==n-1:\n        ans+=1\n        break\n      if not data[i[j]][i[j+1]]:\n        break\nprint(ans)", "from networkx import *\nN,M = map(int,input().split())\nA = [list(map(int,input().split())) for m in range(M)]\nG = Graph(A)\nans = 0\n\nfor n in range(2,N+1):\n  for p in all_simple_paths(G,1,n):\n    if len(p)==N:\n      ans+=1\n\nprint(ans)", "N, M = map(int, input().split())\nG = [[] for _ in range(N)]\nseen = [False] * N\nfor i in range(M):\n    a, b = map(lambda x: int(x) - 1 ,input().split())\n    G[a].append(b)\n    G[b].append(a)\n\ndef dfs(x, G, seen):\n    seen[x] = True\n    flag = True\n    for i in seen:\n        if i == False:\n            flag = False\n    if flag:\n        return 1\n    res = 0\n    for i in G[x]:\n        if seen[i]:\n            continue\n        res += dfs(i, G, seen)\n        seen[i] = False\n    return res\n\nprint(dfs(0, G, seen))", "N,M=map(int, input().split())\n\nchecked = [0] * 8\npath = [[] for _ in range(8)]\n\nfor i in range(M):\n  a,b=map(int, input().split())\n  path[a-1].append(b-1)\n  path[b-1].append(a-1)\n\nans = 0\n\ndef dfs(place):\n  checked[place] = 1\n  if sum(checked) == N:\n    return 1\n  ret = 0\n  for i in path[place]:\n    if checked[i] == 1:\n      continue\n    ret += dfs(i)\n    checked[i] = 0\n  return ret\n\nprint(dfs(0))", "import sys\nimport itertools\nsys.setrecursionlimit(10**6)\n\nN,M=list(map(int,input().split()))\ntmp=[x for x in range(1,N)]\nCases=itertools.permutations(tmp)\nG=[[] for _ in range(N)]\nseen=[0]*N\n\nfor _ in range(M):\n    a,b=list(map(int,input().split()))\n    a-=1\n    b-=1\n    G[a].append(b)\n    G[b].append(a)\n\ndef solve(v,case,cnt,N):\n    if cnt==N-1: return True\n    for nv in G[v]:\n        if nv==case[cnt]:\n            return solve(nv,case,cnt+1,N)\n    return False\n\nans=0\nfor case in Cases:\n    if solve(0,case,0,N): ans+=1\nprint(ans)\n", "N,M = map(int,input().split())\nAB = [tuple(map(int,input().split())) for i in range(M)]\nes = [[0]*N for _ in range(N)]\nfor a,b in AB:\n    a,b = a-1,b-1\n    es[a][b] = es[b][a] = 1\n\nans = 0\nimport itertools\nfor ptn in itertools.permutations(range(1,N)):\n    ptn = list(ptn)\n    for a,b in zip([0]+ptn, ptn):\n        if not es[a][b]: break\n    else:\n        ans += 1\nprint(ans)", "N,M = list(map(int,input().split()))\n\n\n#i\u304b\u3089\u9032\u3081\u308b\u5834\u6240\u3092\u30ea\u30b9\u30c8\u306b\u3057\u3066\u4fdd\u7ba1\nedges = {i:[] for i in range(1,N+1)}\nfor i in range(M):\n  a,b = list(map(int,input().split()))\n  edges[a].append(b)\n  edges[b].append(a)\n\n\n#\u6df1\u3055\u512a\u5148\u63a2\u7d22\ndef dfs(list):\n    #lst(\u901a\u904e\u70b9)\u306e\u6570\u304cN(\u9802\u70b9\u6570)\u3068\u7b49\u3057\u304f\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\uff08\u6210\u529f\uff09\n  if len(list) == N:\n    return 1\n  else:\n    a = list[-1]\n    #lst\u306e\u6700\u5f8c\u5c3e\uff08\u73fe\u5728\u5730\uff09\u304c\u6b21\u306b\u9032\u3081\u308b\u5834\u6240\u3092next\u3068\u3057\u3066\u30ea\u30b9\u30c8\u5316\n    #next\u306b\u4ee5\u524d\u901a\u3063\u305f\u5834\u6240\u304c\u5165\u3063\u3066\u3044\u306a\u3044\u304b\u78ba\u8a8d\n    next = [n for n in edges[a] if n not in list]\n    #\u6b21\u306b\u9032\u3081\u308b\u5834\u6240\u304c\u306a\u304f\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\uff08\u5931\u6557\uff09\n    if len(next) == 0:\n      return 0\n\n    total = 0\n    #\u518d\u5e30\u3067\u3055\u3089\u306b\u63a2\u7d22\n    for n in next:\n      total += dfs(list + [n])\n\n    return total\n\n\nans = dfs([1])\n\nprint(ans)\n", "import copy\n\n\ndef dfs(i, path, reached, n):\n    if reached[i]:\n        return n\n    reached[i] = True\n\n    if all(reached):\n        n += 1\n        return n\n\n    for p in path[i]:\n        org_reached = copy.deepcopy(reached)\n        n = dfs(p, path, org_reached, n)\n\n    return n\n\n\ndef main():\n    N, M = list(map(int, input().split()))\n    AB = [list(map(int, input().split())) for _ in range(M)]\n\n    path = [[] for _ in range(N)]\n\n    for a, b in AB:\n        a -= 1\n        b -= 1\n        path[a].append(b)\n        path[b].append(a)\n\n    reached = [False for _ in range(N)]\n    n = 0\n\n    n = dfs(0, path, reached, n)\n    print(n)\n\n\nmain()\n", "from itertools import permutations, islice\n\n\ndef window(seq, n):\n    it = iter(seq)\n    result = tuple(islice(it, n))\n    if len(result) == n:\n        yield result\n    for elem in it:\n        result = result[1:] + (elem,)\n        yield result\n\n\nN, M, *ab = list(map(int, open(0).read().split()))\ng = [[0] * N for _ in range(N)]\nfor a, b in zip(*[iter(ab)] * 2):\n    g[a - 1][b - 1] = 1\n    g[b - 1][a - 1] = 1\n\nans = 0\nfor path in permutations(list(range(1, N))):\n    path = [0] + list(path)\n    if all(g[v][nv] for v, nv in window(path, 2)):\n        ans += 1\nprint(ans)\n", "from itertools import permutations\n\n\nN, M, *ab = list(map(int, open(0).read().split()))\ng = [[] for _ in range(N)]\nfor a, b in zip(*[iter(ab)] * 2):\n    a -= 1\n    b -= 1\n    g[a].append(b)\n    g[b].append(a)\n\nans = 0\nfor path in permutations(list(range(1, N))):\n    v = 0\n    for nv in path:\n        if nv not in g[v]:\n            break\n        v = nv\n    else:\n        ans += 1\nprint(ans)\n\n", "n, m = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nG = [list() for _ in range(n + 1)]\nfor a, b in edges:\n    G[a].append(b)\n    G[b].append(a)\n\nchecked = [False for _ in range(n)]\n\nans = 0\n\ndef dfs(v):\n    nonlocal ans\n    if all(checked):\n        ans += 1\n        return\n    for u in G[v]:\n        if not checked[u - 1]:\n            checked[u - 1] = True\n            dfs(u)\n            checked[u - 1] = False\n    return\n\nchecked[0] = True\ndfs(1)\nprint(ans)\n", "N,M = [int(a) for a in input().split()]\n\n\n#i\u304b\u3089\u9032\u3081\u308b\u5834\u6240\u3092\u30ea\u30b9\u30c8\u306b\u3057\u3066\u4fdd\u7ba1\nedges = {i:[] for i in range(1,N+1)}\nfor i in range(M):\n  a,b = [int(a) for a in input().split()]\n  edges[a].append(b)\n  edges[b].append(a)\n\n\n#\u6df1\u3055\u512a\u5148\u63a2\u7d22\ndef search(lst):\n    #lst(\u901a\u904e\u70b9)\u306e\u6570\u304cN(\u9802\u70b9\u6570)\u3068\u7b49\u3057\u304f\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\uff08\u6210\u529f\uff09\n  if len(lst) == N:\n    return 1\n  else:\n    a = lst[-1]\n    #lst\u306e\u6700\u5f8c\u5c3e\uff08\u73fe\u5728\u5730\uff09\u304c\u6b21\u306b\u9032\u3081\u308b\u5834\u6240\u3092next\u3068\u3057\u3066\u30ea\u30b9\u30c8\u5316\n    #next\u306b\u4ee5\u524d\u901a\u3063\u305f\u5834\u6240\u304c\u5165\u3063\u3066\u3044\u306a\u3044\u304b\u78ba\u8a8d\n    next = [n for n in edges[a] if n not in lst]\n    #\u6b21\u306b\u9032\u3081\u308b\u5834\u6240\u304c\u306a\u304f\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\uff08\u5931\u6557\uff09\n    if len(next) == 0:\n      return 0\n\n    tot = 0\n    #\u518d\u5e30\u3067\u3055\u3089\u306b\u63a2\u7d22\n    for n in next:\n      tot += search(lst + [n])\n\n    return tot\n\n\nans = search([1])\n\nprint(ans)\n", "import itertools\nn,m=map(int,input().split())\ntbl=[[0]*n for _ in range(n)]\nfor _ in range(m):\n    a,b=map(int,input().split())\n    tbl[a-1][b-1]=1\n    tbl[b-1][a-1]=1\nans=0\nl=[i+1 for i in range(n-1)]\nfor p in itertools.permutations(l,n-1):\n    flag=True\n    p=[0]+list(p)\n    for i in range(n-1):\n        if tbl[p[i]][p[i+1]]==0:\n            flag=False\n            break\n    if flag:\n      ans+=1\nprint(ans)", "N,M = list(map(int,input().split()))\nG = [[] for i in range(N)]\nfor i in range(M):\n    a,b = list(map(int,input().split()))\n    G[a-1].append(b-1)\n    G[b-1].append(a-1)\ncnt = [0]\ndef dfs(V,s):\n    V[s] = 1\n    if sum(V) == N:\n        cnt[0] += 1\n    else:\n        for adj in G[s]:\n            if V[adj] == 0:\n                dfs(V[:adj] + [1] + V[adj + 1:], adj)\ndfs([0] * N,0)\nprint((cnt[0]))\n", "N,M=list(map(int,input().split()))\nA=[[] for i in range(N)]\n\nfor i in range(M):\n    x,y=list(map(int,input().split()))\n    A[x-1].append(y)\n    A[y-1].append(x)\n\ncolor=[\"W\" for i in range(N)]\n\nclear=[\"B\" for i in range(N)]\n\ndef path(x,d):\n    if color[x-1]==\"B\":\n        return False\n        \n    color[x-1]=\"B\"\n\n    if color==clear:\n        color[x-1]=\"W\"\n        return True\n    \n    ans=0\n    for i in range(len(A[x-1])):\n        ans+=int(path(A[x-1][i],d+1))\n\n    color[x-1]=\"W\"\n    return ans\n\nprint((path(1,0)))\n", "N,M = [int(a) for a in input().split()]\nedges = {i:[] for i in range(1,N+1)}\nfor i in range(M):\n  a,b = [int(a) for a in input().split()]\n  edges[a].append(b)\n  edges[b].append(a)\n\ndef search(lst):\n  if len(lst) == N:\n    return 1\n  else:\n    a = lst[-1]\n    next = [n for n in edges[a] if n not in lst]\n    if len(next) == 0:\n      return 0\n\n    tot = 0\n    for n in next:\n      tot += search(lst + [n])\n    \n    return tot\n\n\nans = search([1])\n\nprint(ans)\n\n      \n", "from itertools import permutations\nfrom math import factorial\n\nn, m = list(map(int, input().split(' ')))\nedge = []\n\nfor i in range(m):\n    ai, bi = list(map(int, input().split(' ')))\n    edge.append([ai,bi])\n\n\nx = [i for i in range(1,n+1)]\nls = list(permutations(x))\nans = 0\nfor l in range(factorial(n-1)):\n    cnt = 0\n    for i in range(n-1):\n        for j in range(m):\n            if (ls[l][i] in edge[j]) and (ls[l][i+1] in edge[j]):\n                cnt += 1\n    if cnt == n-1:\n        ans += 1\n\n\nprint(ans)\n", "import itertools as it\n\nn, m = list(map(int, input().split()))\na = list(list(map(int, input().split())) for _ in range(m))\n\n#print(a)\n\n#\u7121\u5411\u30b0\u30e9\u30d5\u306e\u30eb\u30fc\u30c8\u4f5c\u6210\uff08\u30ea\u30b9\u30c8\uff09\nfor i in range(len(a)):\n    a.append([a[i][1],a[i][0]])\n#print(a)\n\n\n#\uff11\u3092\u59cb\u70b9\u3068\u3059\u308b\u30eb\u30fc\u30c8\u3092\u5168\u63a2\u7d22\u3067\u4f5c\u6210\nlis  = list(it.permutations(list(range(2, n + 1))))\n#print(lis)\nfor i in range(len(lis)):\n    lis[i] = (1,) + lis[i]\n#print(lis)\n\n#\u30ea\u30b9\u30c8\u306b\u5909\u63db\nlis2 = []\nfor i in range(len(lis)):\n    lis[i] = list(lis[i])\n    lis2.append(lis[i])\n#print(lis2)\n\n#\u30eb\u30fc\u30c8\u63a2\u7d22\n#lis3 = []\nans = 0\nfor i in range(len(lis2)):\n    check = True\n    for j in range(len(lis2[i]) - 1):\n        if lis2[i][j : j + 2] not in a:\n            check = False\n    if check:\n        ans += 1\nprint(ans)\n", "N,M = list(map(int,input().split()))\n\n\n#i\u304b\u3089\u9032\u3081\u308b\u5834\u6240\u3092\u30ea\u30b9\u30c8\u306b\u3057\u3066\u4fdd\u7ba1\nedges = {i:[] for i in range(1,N+1)}\nfor i in range(M):\n  a,b = [int(a) for a in input().split()]\n  edges[a].append(b)\n  edges[b].append(a)\n\n\n#\u6df1\u3055\u512a\u5148\u63a2\u7d22\ndef dfs(list):\n    #lst(\u901a\u904e\u70b9)\u306e\u6570\u304cN(\u9802\u70b9\u6570)\u3068\u7b49\u3057\u304f\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\uff08\u6210\u529f\uff09\n  if len(list) == N:\n    return 1\n  else:\n    a = list[-1]\n    #lst\u306e\u6700\u5f8c\u5c3e\uff08\u73fe\u5728\u5730\uff09\u304c\u6b21\u306b\u9032\u3081\u308b\u5834\u6240\u3092next\u3068\u3057\u3066\u30ea\u30b9\u30c8\u5316\n    #next\u306b\u4ee5\u524d\u901a\u3063\u305f\u5834\u6240\u304c\u5165\u3063\u3066\u3044\u306a\u3044\u304b\u78ba\u8a8d\n    next = [n for n in edges[a] if n not in list]\n    #\u6b21\u306b\u9032\u3081\u308b\u5834\u6240\u304c\u306a\u304f\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\uff08\u5931\u6557\uff09\n    if len(next) == 0:\n      return 0\n\n    total = 0\n    #\u518d\u5e30\u3067\u3055\u3089\u306b\u63a2\u7d22\n    for n in next:\n      total += dfs(list + [n])\n\n    return total\n\n\nans = dfs([1])\n\nprint(ans)\n", "N, M = map(int, input().split())\nEdge = [tuple(map(int, input().split())) for _ in range(M)]\n\nGraph = [[] for _ in range(N)]\nfor a,b in Edge:\n    Graph[a-1].append(b-1)\n    Graph[b-1].append(a-1)\n\nseen = set()\ndef dfs(v):\n    seen.add(v)\n    if len(seen) == N:\n        seen.remove(v)\n        return 1\n    Res = [dfs(nv) for nv in Graph[v] if not nv in seen]\n    seen.remove(v)\n    return sum(Res)\n\nprint(dfs(0))", "N, M = map(int, input().split())\nD = {}\nfor i in range(M):\n  a, b = map(int, input().split())\n  if a not in D:\n    D[a] = set()\n  if b not in D:\n    D[b] = set()\n  D[a].add(b)\n  D[b].add(a)\nif 1 not in D or len(D) != N:\n  print(0)\nelse:\n  S = set(D.keys())\n  ans = 0\n  task = [(1, set())]\n  while len(task) > 0:\n    pos = 0\n    log = set()\n    pos, log = task.pop(0)\n    log.add(pos)\n    for i in D[pos]:\n      if i not in log:\n        task.append((i, log.copy()))\n    else:\n      if log == S:\n        ans += 1\n  print(ans)", "from typing import List, Tuple\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    g = []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        g.append((a, b))\n    print((osp(n, g)))\n\n\ndef osp(n: int, g: List[Tuple[int, int]]) -> int:\n    v = [False] * n\n\n    return dfs(0, v, n, g)\n\n\ndef dfs(i, v, n, g):\n    v[i] = True\n    if all(v):\n        v[i] = False\n        return 1\n\n    cnt = 0\n    for j in range(n):\n        if v[j]:\n            continue\n        if not ((i + 1, j + 1) in g or (j + 1, i + 1) in g):\n            continue\n        cnt += dfs(j, v, n, g)\n\n    v[i] = False\n    return cnt\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import itertools\nn,m=list(map(int,input().split()))\nnum=[[] for _ in range(n)]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    num[a-1].append(b)\n    num[b-1].append(a)\ncnt=list(itertools.permutations(list(range(2,n+1))))\nans=0\nfor i in range(len(cnt)):\n    num1=1\n    num2=cnt[i]\n    yn=0\n    for j in range(n-1):\n        if num2[j] not in num[num1-1]:\n            yn=1\n            break\n        num1=num2[j]\n    if yn==0:\n        ans+=1\nprint(ans)\n", "from collections import defaultdict\nN, M = list(map(int, input().split()))\nd = defaultdict(list)\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    d[a].append(b)\n    d[b].append(a)\n\n\ndef dfs(n, path):\n    count = 0\n    path.append(n)\n    if len(path) == N:\n        count += 1\n        return count\n\n    for i in range(len(d[n])):\n        if d[n][i] not in path:\n            count += dfs(d[n][i], path)\n            path.pop()\n\n    return count\n\n\nprint((dfs(1, [])))\n", "#N\u306f\u30ce\u30fc\u30c9\u6570\u3001M\u306f\u30a8\u30c3\u30b8\u6570\nN, M = map(int, input().split())\n\npath_matrix = []\n\n#\u7121\u5411\u884c\u5217\u306e\u521d\u671f\u5316\nfor n in range(N):\n    path_matrix.append([False] * N)\n\n#\u307e\u305a\u7121\u5411\u30b0\u30e9\u30d5\u3092\u8868\u3059\u884c\u5217\u3092\u4f5c\u308b\nfor m in range(M):\n    line = map(int, input().split())\n    paths = [x - 1 for x in line]\n    path_matrix[paths[0]][paths[1]] = True\n    path_matrix[paths[1]][paths[0]] = True\n\n#\u6700\u521d\u306fvisited\u3001\u3064\u307e\u308a\u8a2a\u554f\u3057\u305f\u3053\u3068\u306e\u3042\u308b\u30ce\u30fc\u30c9\u306f\u3072\u3068\u3064\u3082\u306a\u3044\u306e\u3067\u3001False\u306b\u3059\u308b\nvisited = [False] * N\n\n\n#\u518d\u5e30\u95a2\u6570\u3001\u3053\u3053\u304c\u96e3\u3057\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002\ndef dfs(now, depth):\n    if visited[now]:\n        return 0\n    if depth == N - 1:\n        return 1\n\n    visited[now] = True\n    total_paths = 0\n    for i in range(0, N):\n        if path_matrix[now][i]:\n            total_paths += dfs(i, depth + 1)\n\n    visited[now] = False\n\n    return total_paths\n\nprint(dfs(0, 0))", "def OneStrokePath():\n    from collections import deque\n    import copy\n    n, m = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    ans = 0\n    \n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n    q = deque()\n    q.append([0, []])\n        \n    while q:\n        x0, route0 = q.pop()\n        if x0 in route0:\n            continue\n        route1 = copy.deepcopy(route0)\n        route1.append(x0)\n        if len(route1) == n:\n            ans += 1\n        for i in graph[x0]:\n            if i in route1:\n                continue\n            q.append([i, route1])\n    print(ans)  \n\ndef __starting_point():\n    OneStrokePath()\n    \n\n__starting_point()", "import queue \nn,m = map(int, input().split())\n\nma = [[] for i in range(n+1)]\nfor i in range(m):\n  a,b = map(int, input().split())\n  ma[a].append(b)\n  ma[b].append(a)\n\nans = 0\ndef dfs(i):\n  nonlocal ans\n  if all(reach[1:]):\n    ans += 1\n  for j in ma[i]:\n    if reach[j] == 1:\n      continue\n    reach[j] = 1\n    dfs(j)\n    reach[j] = 0\n\nreach=[0]*(n+1)\nreach[1] = 1\ndfs(1)\nprint(ans)", "import itertools\nN,M = map(int,input().split())\n\ng = [[] for _ in range(N)]\nfor _ in range(M):\n  a,b = map(int,input().split())\n  g[a-1].append(b-1)\n  g[b-1].append(a-1)\n\np = list(itertools.permutations(range(0,N)))\n\nans = 0\nfor pair in p:\n  if pair[0] != 0:\n    continue\n  ok = True\n  for node1, node2 in zip(pair[0:],pair[1:]):\n    if node1 not in g[node2]:\n      ok = False\n      break\n  if ok:\n    ans += 1\n\nprint(ans)", "#\u30b0\u30e9\u30d5\u306e\u30d1\u30b9\u3092\u5168\u63a2\u7d22\u3059\u308b\u95a2\u6570(\u518d\u5e30)\ndef dfs(now_node, depth):#deptt:\u4eca\u307e\u3067\u5217\u6319\u3057\u305f\u9802\u70b9\u6570\n    if seen[now_node]:#\u63a2\u7d22\u6e08\u307f\u3067\u3042\u3063\u305f\u5834\u5408\u306freturn\n        return 0\n    if depth == N:#\u5168\u3066\u306e\u9802\u70b9\u3092\u901a\u3063\u3066\u3044\u305f\u5834\u5408\u30011\u3092\u8fd4\u3059\n        return 1\n    seen[now_node] = True  #\u4eca\u304b\u3089\u63a2\u7d22\u3059\u308b\u30ce\u30fc\u30c9\u3092\u63a2\u7d22\u6e08\u307f\u306b\u3059\u308b\n    connect_nodes = graph[now_node]\n    ans = 0\n    for node in connect_nodes:#\u5168\u3066\u306e\u9077\u79fb\u5148\u3092\u30c1\u30a7\u30c3\u30af\u3059\u308b\n        ans += dfs(node, depth+1)\n    seen[now_node] = False  # \u63a2\u7d22\u6e08\u307f\u30d5\u30e9\u30b0\u3092\u6298\u308b(\u30dd\u30a4\u30f3\u30c8)\n    return ans\n\nN, M = map(int, input().split())\nedges = [list(map(int, input().split())) for i in range(M)]#\u8fba\u306e\u96c6\u5408\ngraph =[[] for i in range(N+1)]#\u96a3\u63a5\u30ea\u30b9\u30c8\nfor edge in edges:\n    graph[edge[0]].append(edge[1])\n    graph[edge[1]].append(edge[0])\n\n#\u8a2a\u554f\u6e08\u307f\u304b\u3069\u3046\u304b\u3092\u8868\u3059\u30ea\u30b9\u30c8\u3092\u7528\u610f\nseen = [False for i in range(N+1)]\nseen[0] = True\n\nprint(dfs(1, 1))", "from itertools import permutations\nN, M = map(int, input().split())\nAB = [tuple(map(int, input().split())) for _ in range(M)]\nm = [set() for _ in range(27)]\nfor a, b in AB:\n    m[a].add(b)\n    m[b].add(a)\n\ndef main():\n    ans = []\n    def traverse(n, visits):\n        visits = visits | set([n])\n        if len(visits) == N:\n            ans.append(1)\n            return\n        for c in m[n] - visits:\n            traverse(c, visits)\n    traverse(1, set())\n    return len(ans)\n\nprint(main())", "from typing import List, Tuple\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    g = []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        g.append((a, b))\n    print((osp(n, g)))\n\n\ndef osp(n: int, g: List[Tuple[int, int]]) -> int:\n    v = [False] * n\n    g = set(g)\n\n    return dfs(0, v, n, g)\n\n\ndef dfs(i, v, n, g):\n    v[i] = True\n    if all(v):\n        v[i] = False\n        return 1\n\n    cnt = 0\n    for j in range(n):\n        if v[j]:\n            continue\n        if not ((i + 1, j + 1) in g or (j + 1, i + 1) in g):\n            continue\n        cnt += dfs(j, v, n, g)\n\n    v[i] = False\n    return cnt\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def abc054c_one_stroke_path():\n    import itertools\n    n, m = map(int, input().split())\n    e = [set() for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        e[a].add(b)\n        e[b].add(a)\n    pattern = itertools.permutations(range(2, n + 1))\n    cnt = 0\n    for p in pattern:\n        p_m = [1] + list(p)\n        for i in range(n - 1):\n            if p_m[i+1] not in e[p_m[i]]:\n                break\n        else:\n            cnt += 1\n    print(cnt)\n\n\nabc054c_one_stroke_path()", "import collections\nimport copy\n\ndef dfs(i,basho,memo):\n    nonlocal ans\n    #print(i,basho,memo)\n    if memo[basho]==1:\n        return\n    memo[basho]=1\n    if i == n:\n        if sum(memo)==n:\n            ans += 1\n        return\n    tmp = collections.Counter(graph[basho])\n    #print(tmp)\n    for next_basho in tmp.keys():\n        copy_memo = copy.copy(memo)\n        dfs(i+1,next_basho,copy_memo)\n\nn,m = map(int,input().split())\ngraph = [[] for i in range(n+1)]\nfor i in range(m):\n    a,b = map(int,input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nmemo = [0 for i in range(n+1)]\nans = 0\ndfs(1,1,memo)\nprint(ans)", "from itertools import permutations\n\nN,M = list(map(int, input().split()))\nl = [list(map(int, input().split())) for _ in range(M)]\n\ngraph = [[False]*(N+1) for _ in range(N+1)]\n\nfor i,j in l:\n    graph[i][j] = True\n    graph[j][i] = True\n\npattern = permutations(list(range(1,N+1)))\n\ncnt = 0\nfor i in pattern:\n    flag = True\n    if i[0] != 1:\n        continue\n    for j in range(N-1):\n        if graph[i[j]][i[j+1]] == False:\n            flag = False\n            break\n    \n    if flag:\n        cnt += 1\n\nprint(cnt)\n", "n,m = map(int,input().split())\nvisit = [False]*n\nr = [[] for _ in range(n)]\nfor i in range(m):\n  a,b = map(lambda x:int(x)-1,input().split())\n  r[a].append(b)\n  r[b].append(a)\ndef dfs(x,v):\n  if v[x]:\n    return\n  v = list(v)\n  v[x] = True\n  if all(v):\n    nonlocal ans\n    ans += 1\n    return\n  for y in r[x]:\n    dfs(y,v)\nans = 0\ndfs(0,[False]*n)\nprint(ans)", "import itertools\nfrom collections import deque\n\nN,M = map(int,input().split())\ntable = [[0]*N for _ in range(N)]\nans = 0\nfor i in range(M):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    table[a][b] = 1\n    table[b][a] = 1\n\np = [i for i in range(1,N)]\nq = list(itertools.permutations(p))\n\ns = deque()\nfor i in range(len(q)):\n    x = 0\n    flag = 0\n    for y in q[i]:\n        if table[x][y] == 0:\n            flag = 1\n            break\n        x = y\n    if flag == 0:\n        ans += 1\n\nprint(ans)", "import itertools\nn,m = list(map(int,input().split()))\nroutes = list(itertools.permutations([i for i in range(2,n+1)]))\nnodes = {}\nans = 0\nfor i in range(1,n+1):\n    nodes[i] = []\nfor _ in range(m):\n    a,b = list(map(int,input().split()))\n    nodes[a].append(b)\n    nodes[b].append(a)\nfor i in range(len(routes)):\n    jud = 1\n    if routes[i][0] not in nodes[1]:\n        jud = 0\n    for j in range(n-2):\n        if routes[i][j+1] not in nodes[routes[i][j]]:\n            jud = 0\n    ans += jud\nprint(ans)\n", "import sys\n\n\ndef dfs(A: list):\n    if len(A) == n:\n        for i in range(len(A)-1):\n            if A[i+1] not in node[A[i]]:\n                break\n            if i == n-2:\n                ans[0] += 1\n        return\n    for v in range(2, n+1):\n        if v not in A:\n            A.append(v)\n            dfs(A)\n            A.pop()\n\n\nn, m = list(map(int, input().split()))\nnode = [set() for _ in range(n+1)]\nfor x in sys.stdin.readlines():\n    a, b = list(map(int, x.split()))\n    node[a].add(b)\n    node[b].add(a)\nans = [0]\ndfs([1])\nprint((ans[0]))\n", "from itertools import permutations\n\n\nN, M = map(int, input().split())\nS = []\nfor i in range(M):\n    a, b = map(int, input().split())\n    S.append([a, b])\n    \nvertex = (i+1 for i in range(N))\nall_path = list(permutations(vertex))\n\nans = 0\nfor p in all_path:\n    flag = True\n    if p[0] == 1:\n        for i in range(N-1):\n            if [p[i], p[i+1]] not in S and [p[i+1], p[i]] not in S:\n                flag = False\n                break\n        if flag:\n            ans += 1\n                \nprint(ans)", "#\n# abc054 c\n#\n\nimport sys\nfrom io import StringIO\nimport unittest\nimport itertools\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"3 3\n1 2\n1 3\n2 3\"\"\"\n        output = \"\"\"2\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"7 7\n1 3\n2 7\n3 4\n4 5\n4 6\n5 6\n6 7\"\"\"\n        output = \"\"\"1\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    N, M = list(map(int, input().split()))\n    P = [list(map(int, input().split())) for _ in range(M)]\n\n    R = itertools.permutations(list(range(1, N+1)))\n\n    ans = 0\n    for r in R:\n        flag = True\n        r = list(r)\n        if r[0] != 1:\n            break\n        for i in range(1, N):\n            for p in P:\n                if (r[i-1] == p[0] and r[i] == p[1]) or (r[i-1] == p[1] and r[i] == p[0]):\n                    break\n            else:\n                flag = False\n        if flag == True:\n            ans += 1\n\n    print(ans)\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "import itertools as it\nn,m=map(int,input().split())\ne=[[0 for i in range(n)] for j in range(n)]\nfor i in range(m):\n  a,b=map(lambda x:int(x)-1,input().split())\n  e[a][b]=1\n  e[b][a]=1\n\nc=0\nfor t in it.permutations([j+1 for j in range(n-1)]):\n  i=(0,)+t\n  c+=1\n  for j in range(n-1):\n    if e[i[j]][i[j+1]]==0:\n      c-=1\n      break\nprint(c)", "# coding: utf-8\n# Your code here!\n\nimport itertools\n\nN, M = list(map(int, input().split()))\n\ngraph= [[False]*N for i in range(N)]\n\nfor i in range(M):\n    a, b = [int(x)-1 for x in input().split()]\n    graph[a][b] = True\n    graph[b][a] = True\n\nlst = [i-1 for i in range(N)]\ncnt = 0\n\nfor v in itertools.permutations(lst, N):\n    if v[0] != 0:\n        continue\n    for i in range(N-1):\n        if graph[v[i]][v[i+1]] == False:\n            break\n        if i == N-2:\n            cnt += 1\n\nprint(cnt)\n\n\n\n\n\n\n\n", "N, M = map(int, input().split())\nto = [[] for i in range(N)]\n\nfor i in range(M):\n    a, b = map(int, input().split())\n    to[a-1].append(b-1)\n    to[b-1].append(a-1)\n\nans = 0\nv = [0] * N\n\ndef DFS(n):\n    nonlocal ans\n    v[n] = 1\n    #print(v)\n    if sum(v) == N:\n        ans += 1\n    for i in to[n]:\n        if v[i] == 0:\n            DFS(i)\n    v[n] = 0\n\nDFS(0)\nprint(ans)", "from typing import List, Tuple\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    g = []\n    for _ in range(m):\n        a, b = list(map(int, input().split()))\n        g.append((a, b))\n    print((osp(n, g)))\n\n\ndef osp(n: int, g: List[Tuple[int, int]]) -> int:\n    graph = [[False] * n for _ in range(n)]\n    for a, b in g:\n        graph[a - 1][b - 1] = True\n        graph[b - 1][a - 1] = True\n    v = [False] * n\n\n    return dfs(0, v, n, graph)\n\n\ndef dfs(i, v, n, graph):\n    v[i] = True\n    if all(v):\n        v[i] = False\n        return 1\n\n    cnt = 0\n    for j in range(n):\n        if v[j]:\n            continue\n        if not graph[i][j]:\n            continue\n        cnt += dfs(j, v, n, graph)\n\n    v[i] = False\n    return cnt\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import itertools\n\nN,M = map(int,input().split())\nadj_matrix = [[0] * N for _ in range(N)]\n\nfor i in range(M):\n    a,b = map(int,input().split())\n    adj_matrix[a-1][b-1] = 1\n    adj_matrix[b-1][a-1] = 1\n    \ncnt = 0\n\nfor each in itertools.permutations(range(N)):\n    if each[0] != 0:\n        break\n    factor = 1\n    for i in range(N-1):\n        factor *= adj_matrix[each[i]][each[i+1]]\n    cnt += factor\n\nprint(cnt)", "def dfs(x, l):\n  if l.count(False) == 0:\n    return 1\n  cnt = 0\n  for i in a[x]:\n    if not l[i]:\n      cnt += dfs(i, [[True] if j == i else l[j] for j in range(n)])\n  return cnt\n\nn, m = map(int, input().split())\na = [[] for i in range(n)]\nfor i in range(m):\n  x = list(map(int, input().split()))\n  a[x[0]-1].append(x[1]-1)\n  a[x[1]-1].append(x[0]-1)\nprint(dfs(0, [True]+[False]*(n-1)))", "N,M = [int(a) for a in input().split()]\n\n\n#i\u304b\u3089\u9032\u3081\u308b\u5834\u6240\u3092\u30ea\u30b9\u30c8\u306b\u3057\u3066\u4fdd\u7ba1\nedges = {i:[] for i in range(1,N+1)}\nfor i in range(M):\n  a,b = [int(a) for a in input().split()]\n  edges[a].append(b)\n  edges[b].append(a)\n\n\n#\u6df1\u3055\u512a\u5148\u63a2\u7d22\ndef dfs(list):\n    #lst(\u901a\u904e\u70b9)\u306e\u6570\u304cN(\u9802\u70b9\u6570)\u3068\u7b49\u3057\u304f\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\uff08\u6210\u529f\uff09\n  if len(list) == N:\n    return 1\n  else:\n    a = list[-1]\n    #lst\u306e\u6700\u5f8c\u5c3e\uff08\u73fe\u5728\u5730\uff09\u304c\u6b21\u306b\u9032\u3081\u308b\u5834\u6240\u3092next\u3068\u3057\u3066\u30ea\u30b9\u30c8\u5316\n    #next\u306b\u4ee5\u524d\u901a\u3063\u305f\u5834\u6240\u304c\u5165\u3063\u3066\u3044\u306a\u3044\u304b\u78ba\u8a8d\n    next = [n for n in edges[a] if n not in list]\n    #\u6b21\u306b\u9032\u3081\u308b\u5834\u6240\u304c\u306a\u304f\u306a\u3063\u305f\u3089\u63a2\u7d22\u7d42\u4e86\uff08\u5931\u6557\uff09\n    if len(next) == 0:\n      return 0\n\n    total = 0\n    #\u518d\u5e30\u3067\u3055\u3089\u306b\u63a2\u7d22\n    for n in next:\n      total += dfs(list + [n])\n\n    return total\n\n\nans = dfs([1])\n\nprint(ans)\n", "from itertools import permutations\n\n\nN, M, *ab = list(map(int, open(0).read().split()))\ng = [[0] * N for _ in range(N)]\nfor a, b in zip(*[iter(ab)] * 2):\n    g[a - 1][b - 1] = 1\n    g[b - 1][a - 1] = 1\n\nans = 0\nfor path in permutations(list(range(1, N))):\n    path = [0] + list(path)\n    if all(g[v][nv] for v, nv in zip(path, path[1:])):\n        ans += 1\nprint(ans)\n", "import sys\nreadline = sys.stdin.readline\n\nN,M = map(int,readline().split())\nG = [[] for i in range(N)]\n\nfor i in range(M):\n  a,b = map(int,readline().split())\n  G[a - 1].append(b - 1)\n  G[b - 1].append(a - 1)\n\nstack = []\nstack.append([0, set()])\nans = 0\nwhile stack:\n  v, visited = stack.pop()\n  visited.add(v)\n  if len(visited) == N:\n    ans += 1\n    continue\n  for child in G[v]:\n    if child in visited:\n      continue\n    visited_c = visited.copy()\n    stack.append([child, visited_c])\n  \nprint(ans)", "def dfs(v):\n    if sum(visited) == N:\n        return 1\n    res = 0\n    for nv in g[v]:\n        if visited[nv]:\n            continue\n        visited[nv] = 1\n        res += dfs(nv)\n        visited[nv] = 0\n    return res\n\n\nN, M, *ab = list(map(int, open(0).read().split()))\ng = [[] for _ in range(N)]\nfor a, b in zip(*[iter(ab)] * 2):\n    a -= 1\n    b -= 1\n    g[a].append(b)\n    g[b].append(a)\n\nvisited = [0] * N\nvisited[0] = 1\nprint((dfs(0)))\n", "\nimport itertools as itt\n\nn, m = map(int, input().split())\nl = set()\nfor i in range(m):\n    a, b = map(int, input().split())\n    l.add((a, b))\n    l.add((b, a))\n\nlis = [i for i in range(1, n+1)]\np_lis = list(itt.permutations(lis))\n\ncnt = 0\n\nfor i in range(len(p_lis)):\n    if p_lis[i][0] != 1:\n        continue\n    flg = [0]*(n-1)\n    for j in range(n-1):\n        x = (p_lis[i][j], p_lis[i][j+1])\n        if x in l:\n            flg[j] = 1\n    if all(flg):\n        cnt += 1\n\nprint(cnt)", "n,m=list(map(int,input().split()))\n#\u96a3\u63a5\u30ea\u30b9\u30c8\u8868\u73fe\nes=[[0 for i in range(n)] for i in range(n)]\nfor i in range(m):\n  a,b=list(map(int,input().split()))\n  es[a-1][b-1]=1\n  es[b-1][a-1]=1\n\n# \u518d\u5e30\u306e\u6df1\u3055\u304c1000\u3092\u8d85\u3048\u305d\u3046\u306a\u3068\u304d\u306f\u3053\u308c\u3092\u3084\u3063\u3066\u304a\u304f\nimport sys\nsys.setrecursionlimit(10**7)\n\n\n#\u6df1\u3055\u512a\u5148\u63a2\u7d22\n#n\u500b\u306e\u9802\u70b9\u304c\u672a\u63a2\u7d22\u3067\u3042\u308b\u3068\u3057\u3066\u304a\u304f\nvisited=[0 for i in range(n)]\ncheck=[1 for i in range(n)]\n\ndef dfs(v,visited):\n  #ans\u306f\u9802\u70b9v\u304b\u3089\u59cb\u307e\u308b\u30d1\u30b9\u306e\u6570\n  ans=0\n  #\u81ea\u5206\u304c\u3044\u308b\u3053\u3068\u308d\u3092\u63a2\u7d22\u6e08\u306b\u3057\u3066\u304a\u304f\n  visited[v-1]=1\n\n  if visited==check:\n    visited[v-1]=0\n    return 1\n  #\u305d\u3053\u304b\u3089\u884c\u3051\u308b\u3068\u3053\u308d\u306b\u5bfe\u3057\u3066\u6df1\u3055\u512a\u5148\u63a2\u7d22\n  for i in range(n):\n    #\u3064\u306a\u304c\u3063\u3066\u3044\u3066\u672a\u63a2\u7d22\n    if es[v-1][i]==1 and visited[i]==0:\n        ans+=dfs(i+1,visited)\n  #\u5168\u90e8\u63a2\u7d22\u3057\u7d42\u308f\u3063\u305f\u3089\u4eca\u81ea\u5206\u304c\u3044\u308b\u3068\u3053\u308d\u306f\u672a\u63a2\u7d22\u306b\u623b\u3057\u3066\u304a\u304f\n  visited[v-1]=0\n  return ans\n\nprint((dfs(1,visited)))\n", "import itertools\n\nn, m = map(int, input().split())\n\n#\u7e4b\u304c\u3063\u3066\u3044\u308b\u9802\u70b9\u30ea\u30b9\u30c8\na_list = []\nfor j in range(m) :\n    a = list(map(int, input().split()))\n    a_list.append(a)\na_list.sort()\n\n#\u9053\u9806\u30ea\u30b9\u30c8(\u6700\u521d\u304c1\u306b\u9650\u308b)\nb_list = [k for k in itertools.permutations([l for l in range(1, n + 1)]) if k[0] == 1]\n\n#\u9053\u9806\u30ea\u30b9\u30c8\u306e\u4e2d\u3067\u9802\u70b9\u30ea\u30b9\u30c8\u304c\u542b\u307e\u308c\u3066\u3044\u308b\u3082\u306e\ncnt = 0\nfor x in b_list :\n    tf_list = []\n    for y in range(n - 1) :\n        tf_list.append([x[y], x[y + 1]] in a_list or [x[y + 1], x[y]] in a_list)\n    \n    if all(tf_list) == True :\n        cnt += 1\n\nprint(cnt)", "import sys, itertools\n\nload = []\nfor i,row in enumerate(sys.stdin.readlines()):\n    if i == 0:\n        n,m = [int(x) for x in row.split()]\n    else:\n        load.append({int(x) for x in row.split()})\n\nsum = 0\nfor one_load in itertools.permutations([i for i in range(1,n+1)]):\n    #print(\"one_load:\",one_load)\n    if one_load[0] != 1:\n        continue\n    else:\n        for i,dot in enumerate(one_load):\n            if i == 0:\n                old_dot = dot\n            else:\n              #  print(\"old_dot,dot:\",old_dot,dot)\n                if {old_dot,dot} in load:\n                    old_dot = dot\n                else:\n                    break\n        else:\n            sum += 1\nprint(sum)", "N,M = [int(a) for a in input().split()]\nedges = {i:[] for i in range(1,N+1)}\nfor i in range(M):\n  a,b = [int(a) for a in input().split()]\n  edges[a].append(b)\n  if a not in edges[b]:\n    edges[b].append(a)\n\ndef search(lst):\n  if len(lst) == N:\n    return 1\n  else:\n    a = lst[-1]\n    next = [n for n in edges[a] if n not in lst]\n    if len(next) == 0:\n      return 0\n\n    tot = 0\n    for n in next:\n      tot += search(lst + [n])\n    \n    return tot\n\n\nans = search([1])\n\nprint(ans)\n\n", "import copy\nfrom collections import deque\n\nn, m = map(int,input().split())\n\ne = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int,input().split())\n    a -= 1\n    b -= 1\n    e[a].append(b)\n    e[b].append(a)\nvisited = [False]*n\nvisited[0] = True\nd = deque([[0, visited]])\n\ncnt = 0\nwhile d:\n    f, visited = d.pop()\n    for t in e[f]:\n        v = copy.deepcopy(visited)\n        if not v[t]:\n            v[t] = True\n            if False in v:\n                d.append([t, v])\n            else:\n                cnt += 1\nprint(cnt)", "from collections import deque\n\nn,m = list(map(int, input().split()))\ng = [[] for _ in range(n)]\nprev = [0] * n\n\nfor i in range(m):\n    a,b = list(map(int, input().split()))\n    g[a-1].append(b)\n    g[b-1].append(a)\n\ncount = 0\nprev[0] = 1\n\ndef keiro(pre,q,now):\n    nonlocal count\n    if len(q) == 0:\n            return\n\n    now = q.popleft()\n    \n    for no in g[now-1]:\n        if pre[no-1] == 0:\n\n            pre_1 = pre.copy()\n            pre_1[no-1] = 1\n            if sum(pre_1) == n:\n                count+=1\n                return\n            q.append(no)\n            keiro(pre_1,q,no)\n        else:\n\n            keiro(pre,q,no)\n\n\nkeiro(prev,deque([1]),1)\nprint(count)\n\n", "import itertools \n\nn,m=map(int,input().split())\nli=[]\nfor _ in range(m):\n  a,b=map(int,input().split())\n  li.append([a,b])\ncount=0\nfor comb in itertools.permutations(range(n),n):\n  if comb[0]!=0:\n    continue\n  judge=True\n  for i in range(n-1):\n    if judge==False:\n      break\n    a=comb[i]+1\n    b=comb[i+1]+1\n    if ([a,b] in li) or ([b,a] in li):\n      continue\n    else:\n      judge=False\n      break\n  if judge==True:\n    count+=1\nprint(count)", "N,M = map(int, input().split())\nli = []\nfor i in range(N):\n li.append([-1 for i in range(N)])\n\nfor i in range(M):\n    a,b = map(int, input().split())\n    li[a-1][b-1] = 1\n    li[b-1][a-1] = 1\nimport itertools\nan = 0\nfor i in itertools.permutations(range(1,N)):\n  jun = [0]\n  jun+= list(i)\n  st = jun[0]\n  for t in range(1,N):\n      if li[jun[t]][st] == -1:\n          break\n      st = jun[t]\n      if t == N-1:\n          an += 1\nprint(an)", "from itertools import permutations\n\nN,M = map(int,input().split())\nAB = [0 for i in range(M)]\n\nfor i in range(M):\n  ab = list(map(int,input().split()))\n  AB[i] = ab\n\ncount = 0\nnums = [i for i in range(1,N+1)]\npers =permutations(nums,N)\nfor i in pers:\n  if i[0] == 1:\n    flag1 = 0\n    for j in range(N-1):\n      flag2 = False\n      for k in range(M):\n        if (i[j] == AB[k][0] and i[j+1] == AB[k][1]) or (i[j] == AB[k][1] and i[j+1] == AB[k][0]):\n          flag2 = True\n          #print(i,i[j],i[j+1],AB[k])\n      if flag2:\n        flag1 += 1\n    if flag1 == N-1:\n      #print(i)\n      count += 1\nprint(count)", "import itertools as it\n\nn, m = list(map(int, input().split()))\na = list(list(map(int, input().split())) for _ in range(m))\n\n#\u7121\u5411\u30b0\u30e9\u30d5\u306e\u30eb\u30fc\u30c8\u4f5c\u6210\uff08\u30ea\u30b9\u30c8\uff09\nfor i in range(len(a)):\n    a.append([a[i][1],a[i][0]])\n\nlis  = list(it.permutations(list(range(2, n + 1))))\nfor i in range(len(lis)):\n    lis[i] = (1,) + lis[i]\n\nlis2 = []\nfor i in range(len(lis)):\n    lis[i] = list(lis[i])\n    lis2.append(lis[i])\n\n#\u30eb\u30fc\u30c8\u63a2\u7d22\nans = 0\nfor i in range(len(lis2)):\n    check = True;\n    for j in range(len(lis2[i]) - 1):\n        if lis2[i][j : j + 2] not in a:\n            check = False;\n    if(check):\n        ans += 1\nprint(ans)\n", "import itertools\n\nn, m = map(int, input().split())\npath = [[False] * n for _ in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    path[a-1][b-1] = True\n    path[b-1][a-1] = True\n\nans = 0\n\nfor i in itertools.permutations(range(n), n):  #iterools.permutations(list, size)\n    # \u9802\u70b9\u306f0\u304b\uff1f\n    if i[0] == 0:  # \u9802\u70b9\u306f\uff11\u3067\u306f\u306a\u3044\u3053\u3068\u306b\u6ce8\u610f\n        for j in range(n):\n            if j == n-1:\n                ans += 1\n                break\n            if not path[i[j]][i[j+1]]:\n                break\n\nprint(ans)", "import itertools\n \nN,M=map(int,input().split())\ns=[list(map(int,input().split())) for _ in range(M)]\n \nlst=[x for x in range(1,N+1)]   \nl=itertools.permutations(lst)\n \nans=0\ncnt=0\nfor num in l:\n\tif num[0]==1:\n\t\tfor j in range(N-1):\n\t\t\tif [num[j], num[j+1]] in s or [num[j+1], num[j]] in s:\n\t\t\t\tcnt+=1\n\tif cnt==N-1:\n\t\tans+=1\n\t\tcnt=0\n\telse:\n\t\tcnt=0\n \nprint(ans)", "from itertools import groupby, accumulate, product, permutations, combinations\nimport numpy as np\nN, M = map(int, input().split())\nadj = np.zeros((N,N),np.int64)\nfor i in range(M):\n  a,b = map(lambda x:int(x)-1, input().split())\n  adj[a,b] = 1\n  adj[b,a] = 1\nans = 0\nfor per in permutations(range(1,N),N-1):\n  if adj[0,per[0]]==0:\n    continue\n  for i in range(N-2):\n    if adj[per[i],per[i+1]]==0:\n      break\n  else:\n    ans += 1\nprint(ans)", "N, M = list(map(int, input().split()))\nto = [[] for _ in range(N)]\n\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    a, b = a - 1, b - 1\n    to[a].append(b)\n    to[b].append(a)\n\n\ndef dfs(v, seen):\n    if seen == [1] * N:\n        return 1\n    \n    res = 0\n    for nv in to[v]:\n        if not seen[nv]:\n            seen[nv] = 1\n            res += dfs(nv, seen)\n            seen[nv] = 0\n    return res\n\n\ndef main():\n    seen = [0] * N\n    seen[0] = 1\n    print((dfs(0, seen)))    \n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nN, M = list(map(int, input().split()))\ngraph = [[] for _ in range(N)]\nfor i in range(M):\n    a, b = [int(x) - 1 for x in input().split()]\n    graph[a].append(b)\n    graph[b].append(a)\ndef dfs(cur, visited):\n    if visited == (1 << N) - 1:\n        return 1\n    res = 0\n    for to in graph[cur]:\n        if not (visited >> to) & 1:\n            res += dfs(to, visited | (1 << to))\n    return res\nprint((dfs(0, 1)))\n", "def dfs(v, used):\n  if not False in used: return 1\n  ans = 0\n  for i in range(n):\n    if not matrix[v][i]: continue\n    if used[i]: continue\n    used[i] = True\n    ans += dfs(i, used)\n    used[i] = False\n  return ans\n\nn, m = map(int, input().split())\nmatrix = [[0]*n for _ in range(n)]\nfor i in range(m):\n  a, b = map(int, input().split())\n  matrix[a-1][b-1] = 1\n  matrix[b-1][a-1] = 1\n\nused = [False]*n\nused[0] = True\n\nprint(dfs(0, used))", "n,m=list(map(int,input().split()))\nroot=[[] for _ in range(n+1)]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    root[a].append(b)\n    root[b].append(a)\ns=[0]*(n+1)\ns[0]=1\ns[1]=1\nans=0\ndef f(a,x):\n    nonlocal ans\n    for i in root[a]:\n        if x[i]==0:\n            x[i]=1\n            f(i,x)\n            x[i]=0\n    if x.count(1)==n+1:\n        ans+=1\nf(1,s)\nprint(ans)\n\n", "N, M = map(int, input().split())\nEdge = [tuple(map(int, input().split())) for _ in range(M)]\n\nGraph = [[] for _ in range(N)]\nfor a,b in Edge:\n    Graph[a-1].append(b-1)\n    Graph[b-1].append(a-1)\n\nseen = set()\ndef dfs(v):\n    nonlocal Graph, seen\n    seen.add(v)\n    if len(seen) == N:\n        seen.remove(v)\n        return 1\n    Res = [dfs(nv) for nv in Graph[v] if not nv in seen]\n    seen.remove(v)\n    return sum(Res)\n\nprint(dfs(0))", "\"\"\"\n1 ----- 2 ----- ai ----- bi -----\n                    \u8fba:i\n\"\"\"\nimport itertools\n\ndef one_stroke_path():\n    \"\"\"\n    N : \u9802\u70b9\n    M : \u8fba\u6570\n    ai, bi : \u8fbai\u306e\u4e21\u7aef\u306e\u9802\u70b9\n    \"\"\"\n    # \u5165\u529b\n    N, M = list(map(int, input().split()))\n    a = list()\n    b = list()\n    for _ in range(M):\n        A, B = list(map(int, input().split()))\n        a.append(A)\n        b.append(B)\n    \n    # \u51e6\u7406\n    permutations_list = itertools.permutations([x for x in range(1,N+1)])\n    count = 0\n    for one_case in permutations_list:\n        is_ok = False\n        if one_case[0] == 1:\n            for i in range(len(one_case)-1):\n                for j in range(M):\n                    if (one_case[i] == a[j] and one_case[i+1] == b[j]) or (one_case[i] == b[j] and one_case[i+1] == a[j] ):\n                        is_ok = True\n                        break\n                    else:\n                        is_ok = False\n                if is_ok == False:\n                    break\n        else:\n            is_ok = False\n        if is_ok:\n            count += 1\n    return count\n\nresult = one_stroke_path()\nprint(result)\n\n", "from itertools import permutations\n\nN, M = map(int, input().split())\nedges = set(tuple(map(int, input().split())) for _ in range(M))\n\nans = 0\nfor t in permutations(range(2, N + 1)):\n    p = [1] + list(t)\n    ok = True\n    for i in range(N - 1):\n        e = tuple(sorted((p[i], p[i + 1])))\n        if not (e in edges):\n            ok = False\n            break\n    if ok:\n        ans += 1\n\nprint(ans)", "import itertools\nn, m = map(int, input().split())\npath = [[False] * n for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    path[a][b] = True\n    path[b][a] = True\nans = 0\n# \u9802\u70b9\u3092\u4e26\u3073\u66ff\u3048\u308b\u9806\u5217\u3092\u751f\u6210\u3057\u3066\u30eb\u30fc\u30d7\nfor i in itertools.permutations(range(n), n):\n    # \u9802\u70b91\u304c\u59cb\u70b9\n    if i[0] == 0:\n        # \u751f\u6210\u3057\u305f\u9806\u5217\u306e\u4e2d\u3092\u3055\u3089\u306b\u30eb\u30fc\u30d7\n        for j in range(n):\n            # n - 1 \u307e\u3067\u7d9a\u3044\u305f\u3089\u6761\u4ef6\u3092\u6e80\u305f\u3059\u30d1\u30b9\u304c\u5b58\u5728\u3059\u308b\n            if j == n - 1:\n                ans += 1\n                break\n            # i[j] \u304b\u3089 i[j + 1] \u306b\u884c\u304f\u30d1\u30b9\u304c\u306a\u3051\u308c\u3070\u7d42\u4e86\n            if not path[i[j]][i[j + 1]]:\n                break\nprint(ans)", "import itertools as it\nn,m=map(int,input().split())\ne=[[0 for i in range(n)] for j in range(n)]\nfor i in range(m):\n  a,b=map(lambda x:int(x)-1,input().split())\n  e[a][b]=1\n  e[b][a]=1\n \nc=0\nfor t in it.permutations([j+1 for j in range(n-1)]):\n  i=(0,)+t\n  c+=1\n  for j in range(n-1):\n    if e[i[j]][i[j+1]]==0:\n      c-=1\n      break\nprint(c)", "import itertools\n\nn,m = map(int,input().split())\n\npath = [[False]*n for i in range(n)]\nfor i in range(m):\n    a,b = map(int,input().split())\n    a -= 1\n    b -= 1\n    path[a][b] = True\n    path[b][a] = True\n\nans = 0\n\nfor i in itertools.permutations(range(n),n):\n    #\u9802\u70b9\u304c0\u306e\u3082\u306e\u3060\u3051\u62bd\u51fa\n    if i[0] == 0:\n        #\u78ba\u304b\u3081\u308b\n        for j in range(n):\n            if j == n - 1:\n                ans += 1\n                break\n\n            if not path[i[j]][i[j+1]]:\n                break\n\nprint(ans)", "from itertools import permutations\n\nN,M = map(int,input().split())\nAlist = [list(map(int,input().split())) for i in range(M)]\n\ngraph = [[False]*(N+1) for i in range(N+1)]\n\nfor i ,j in Alist:\n  graph[i][j] = True\n  graph[j][i] = True\n\nroute = permutations(range(1,N+1))\n\ncount = 0\nfor i in route:\n  flag = True\n  if i[0] !=1:\n    continue\n  for j in range(N-1):\n    if graph[i[j]][i[j+1]] == False:\n      flag = False\n      break\n  \n  if flag == True:\n    count += 1\n\nprint(count)", "from itertools import permutations\n\nn,m = map(int,input().split())\nv = [set() for _ in range(n)]\nfor i in range(m):\n    ai,bi = map(int,input().split())\n    v[ai-1].add(bi-1)\n    v[bi-1].add(ai-1)\n\nans = 0\nfor ci in permutations(range(n)):\n    if not ci[0]:\n        for i in range(n-1):\n            if not (ci[i+1] in v[ci[i]]):\n                break\n        else:\n            ans += 1\nprint(ans)", "N,M = map(int,input().split())\n\npath = [[0]*(N+1) for _ in range(N+1)]\n\nfor i in range(M):\n    a,b = map(int,input().split())\n    path[a][b] = 1\n    path[b][a] = 1\n\nvisited = [0]*(N+1)\n\ndef dfs(now,depth):\n    if visited[now]:\n        return 0\n    if depth == N:\n        return 1 # \u6700\u5f8c\u307e\u3067\u63a2\u7d22\u3057\u305f\u3089\u306f\u3058\u3081\u3066+1\n    \n    visited[now] = 1\n    \n    total_paths = 0\n    \n    for i in range(1,N+1):\n        if path[now][i]:\n            total_paths += dfs(i, depth + 1)\n            \n    visited[now] = 0\n    \n    return total_paths\n\nprint(dfs(1,1))", "from itertools import permutations\n\nN, M = map(int, input().split())\nG = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    G[a].append(b)\n    G[b].append(a)\n\nres = 0\nfor P in permutations(range(N), N):\n    if P[0] != 0:\n        continue\n    for i in range(N - 1):\n        if P[i + 1] not in G[P[i]]:\n            break\n    else:\n        res += 1\n\nprint(res)"]