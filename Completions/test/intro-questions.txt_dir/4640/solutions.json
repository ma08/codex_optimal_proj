["import bisect\n\ndef solve(n,x_coords,y_coords,k,ans):\n    x_coords.sort()\n    dp = []\n    for i in range(n):\n        x = x_coords[i]\n        index = bisect.bisect(x_coords,x+k)-1\n        dp.append(index-i+1)\n\n    dp_max = []\n    for i in reversed(dp):\n        if not dp_max:\n            dp_max.append(i)\n        else:\n            dp_max.append(max(dp_max[-1],i))\n\n    dp_max.reverse()\n    max_val = 0\n    for i in range(n):\n        x = x_coords[i]\n        index = bisect.bisect(x_coords,x+k)-1\n        val = index-i+1\n        if index+1 < n:\n            val += dp_max[index+1]\n\n        max_val = max(max_val,val)\n\n    ans.append(str(max_val))\n\ndef main():\n    t = int(input())\n    ans = []\n    for i in range(t):\n        n,k = list(map(int,input().split()))\n        x_coords = list(map(int,input().split()))\n        y_coords = list(map(int,input().split()))\n        solve(n,x_coords,y_coords,k,ans)\n\n    print('\\n'.join(ans))\n\n    \nmain()\n", "class SortedList:\n    def __init__(self, iterable=[], _load=200):\n        \"\"\"Initialize sorted list instance.\"\"\"\n        values = sorted(iterable)\n        self._len = _len = len(values)\n        self._load = _load\n        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]\n        self._list_lens = [len(_list) for _list in _lists]\n        self._mins = [_list[0] for _list in _lists]\n        self._fen_tree = []\n        self._rebuild = True\n\n    def _fen_build(self):\n        \"\"\"Build a fenwick tree instance.\"\"\"\n        self._fen_tree[:] = self._list_lens\n        _fen_tree = self._fen_tree\n        for i in range(len(_fen_tree)):\n            if i | i + 1 < len(_fen_tree):\n                _fen_tree[i | i + 1] += _fen_tree[i]\n        self._rebuild = False\n\n    def _fen_update(self, index, value):\n        \"\"\"Update `fen_tree[index] += value`.\"\"\"\n        if not self._rebuild:\n            _fen_tree = self._fen_tree\n            while index < len(_fen_tree):\n                _fen_tree[index] += value\n                index |= index + 1\n\n    def _fen_query(self, end):\n        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        x = 0\n        while end:\n            x += _fen_tree[end - 1]\n            end &= end - 1\n        return x\n\n    def _fen_findkth(self, k):\n        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"\n        _list_lens = self._list_lens\n        if k < _list_lens[0]:\n            return 0, k\n        if k >= self._len - _list_lens[-1]:\n            return len(_list_lens) - 1, k + _list_lens[-1] - self._len\n        if self._rebuild:\n            self._fen_build()\n\n        _fen_tree = self._fen_tree\n        idx = -1\n        for d in reversed(range(len(_fen_tree).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:\n                idx = right_idx\n                k -= _fen_tree[idx]\n        return idx + 1, k\n\n    def _delete(self, pos, idx):\n        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len -= 1\n        self._fen_update(pos, -1)\n        del _lists[pos][idx]\n        _list_lens[pos] -= 1\n\n        if _list_lens[pos]:\n            _mins[pos] = _lists[pos][0]\n        else:\n            del _lists[pos]\n            del _list_lens[pos]\n            del _mins[pos]\n            self._rebuild = True\n\n    def _loc_left(self, value):\n        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        lo, pos = -1, len(_lists) - 1\n        while lo + 1 < pos:\n            mi = (lo + pos) >> 1\n            if value <= _mins[mi]:\n                pos = mi\n            else:\n                lo = mi\n\n        if pos and value <= _lists[pos - 1][-1]:\n            pos -= 1\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value <= _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def _loc_right(self, value):\n        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"\n        if not self._len:\n            return 0, 0\n\n        _lists = self._lists\n        _mins = self._mins\n\n        pos, hi = 0, len(_lists)\n        while pos + 1 < hi:\n            mi = (pos + hi) >> 1\n            if value < _mins[mi]:\n                hi = mi\n            else:\n                pos = mi\n\n        _list = _lists[pos]\n        lo, idx = -1, len(_list)\n        while lo + 1 < idx:\n            mi = (lo + idx) >> 1\n            if value < _list[mi]:\n                idx = mi\n            else:\n                lo = mi\n\n        return pos, idx\n\n    def add(self, value):\n        \"\"\"Add `value` to sorted list.\"\"\"\n        _load = self._load\n        _lists = self._lists\n        _mins = self._mins\n        _list_lens = self._list_lens\n\n        self._len += 1\n        if _lists:\n            pos, idx = self._loc_right(value)\n            self._fen_update(pos, 1)\n            _list = _lists[pos]\n            _list.insert(idx, value)\n            _list_lens[pos] += 1\n            _mins[pos] = _list[0]\n            if _load + _load < len(_list):\n                _lists.insert(pos + 1, _list[_load:])\n                _list_lens.insert(pos + 1, len(_list) - _load)\n                _mins.insert(pos + 1, _list[_load])\n                _list_lens[pos] = _load\n                del _list[_load:]\n                self._rebuild = True\n        else:\n            _lists.append([value])\n            _mins.append(value)\n            _list_lens.append(1)\n            self._rebuild = True\n\n    def discard(self, value):\n        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_right(value)\n            if idx and _lists[pos][idx - 1] == value:\n                self._delete(pos, idx - 1)\n\n    def remove(self, value):\n        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"\n        _len = self._len\n        self.discard(value)\n        if _len == self._len:\n            raise ValueError('{0!r} not in list'.format(value))\n\n    def pop(self, index=-1):\n        \"\"\"Remove and return value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        value = self._lists[pos][idx]\n        self._delete(pos, idx)\n        return value\n\n    def bisect_left(self, value):\n        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_left(value)\n        return self._fen_query(pos) + idx\n\n    def bisect_right(self, value):\n        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"\n        pos, idx = self._loc_right(value)\n        return self._fen_query(pos) + idx\n\n    def count(self, value):\n        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"\n        return self.bisect_right(value) - self.bisect_left(value)\n\n    def __len__(self):\n        \"\"\"Return the size of the sorted list.\"\"\"\n        return self._len\n\n    def __getitem__(self, index):\n        \"\"\"Lookup value at `index` in sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        return self._lists[pos][idx]\n\n    def __delitem__(self, index):\n        \"\"\"Remove value at `index` from sorted list.\"\"\"\n        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)\n        self._delete(pos, idx)\n\n    def __contains__(self, value):\n        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"\n        _lists = self._lists\n        if _lists:\n            pos, idx = self._loc_left(value)\n            return idx < len(_lists[pos]) and _lists[pos][idx] == value\n        return False\n\n    def __iter__(self):\n        \"\"\"Return an iterator over the sorted list.\"\"\"\n        return (value for _list in self._lists for value in _list)\n\n    def __reversed__(self):\n        \"\"\"Return a reverse iterator over the sorted list.\"\"\"\n        return (value for _list in reversed(self._lists) for value in reversed(_list))\n\n    def __repr__(self):\n        \"\"\"Return string representation of sorted list.\"\"\"\n        return 'SortedList({0})'.format(list(self))\n\nt = int(input())\n\nfor _ in range(t):\n    n,k = map(int,input().split())\n    xs = list(map(int, input().split()))\n    ys = list(map(int, input().split()))\n    \n    s = SortedList(xs)\n    saved = [None]*n\n    for i,x in enumerate(s):\n        saved[i] = s.bisect_right(x+k)-s.bisect_left(x)\n    #print(s)\n    #print(saved)\n    base = 1\n    while base<n:\n        base*=2\n    tree = [0]*base + saved + [0]*(base-n)\n    for i in range(base-1,0,-1):\n        tree[i] = max(tree[2*i],tree[2*i+1])\n    \n    def query(a,b):\n        a+=base\n        b+=base\n        m = 0\n        while a<b:\n            if a%2==1:\n                m = max(m, tree[a])\n                a+=1\n            if b%2==1:\n                m = max(m, tree[b-1])\n                b-=1\n            a//=2\n            b//=2\n        return m\n    \n    m = 0\n    for i in range(n):\n        #print(i,s[i],saved[i] + query(i+saved[i], n))\n        m = max(m,saved[i] + query(i+saved[i], n))\n    print(m)", "from bisect import bisect_left as lower_bound,bisect_right as upper_bound\nfor _ in range(int(input())):\n    n,k=map(int,input().split())\n    x=sorted(map(int,input().split()))\n    input()\n    mxr=[0]*n\n    for i in range(n-1,-1,-1):\n        mxr[i]=i-lower_bound(x,x[i]-k)+1\n    ans=1\n    cmxr=mxr[0]\n    for i in range(1,n):\n        res=cmxr\n        cmxr=max(cmxr,mxr[i])\n        cf=upper_bound(x,x[i]+k)-i\n        ans=max(ans,res+cf)\n    print(ans)\n\n'''\n1\n7 1\n1 5 2 3 1 5 4\n\n'''", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop,heapify\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n\nfrom itertools import accumulate\nfrom functools import lru_cache\n\n\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\nclass Node:\n    def __init__(self,s,e):\n        self.start=s\n        self.end=e\n        self.val = 0\n        self.left=None\n        self.right=None\n \ndef build(nums,l,r):\n    if l == r:\n        temp = Node(l,l)\n        temp.val = nums[l]\n    else:\n        mid=(l+r)>>1\n        temp=Node(l,r)\n        temp.left=build(nums,l,mid)\n        temp.right=build(nums,mid+1,r)\n        temp.val = max(temp.left.val,temp.right.val)\n    return temp\n\ndef update(root,start,value):\n    if root.start == start == root.end:\n        root.val = value\n    elif root.start <= start and root.end >= start:\n        update(root.left,start,value)\n        update(root.right,start,value)\n        root.val = max(root.left.val,root.right.val)\n\n\n\n\n\ndef query(root,start,end):\n    if root.start>=start and root.end<=end:return root.val\n    elif root.start>end or root.end<start:return -float('inf')\n    else:\n        temp1 = query(root.left,start,end)\n        temp2 = query(root.right,start,end)\n        return max(temp1,temp2)\n\nfor _ in range(val()):\n    n, k = li()\n    l = li()\n    y = li()\n\n    l.sort()\n    \n    dp = [0] * (n + 1)\n\n    for i in range(n - 1, -1, -1):\n        curright = br(l, l[i] + k)\n        totnow = curright - i\n        dp[i] = totnow\n    \n\n    # print(l, k)\n    # print(dp)\n\n    root = build(dp, 0, n)\n\n\n    for i in range(n):\n        curright = br(l, l[i] + k)\n        dp[i] += query(root, curright, n)\n    print(max(dp))", "import sys, math\nimport io, os\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n# from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\nfrom decimal import Decimal\n# from fractions import Fraction\n# sys.setrecursionlimit(100000)\nmod = int(1e9) + 7\nINF=2**32\n\ndef cal(n):\n    ans=0\n    while n:\n        ans+=n%10\n        n//=10\n    return ans\n\nfor t in range(int(data())):\n   n,k=mdata()\n   ans=1\n   X=sorted(mdata())\n   Y=mdata()\n   q=deque()\n   d=dd(int)\n   m=0\n   for i in range(n):\n        while q and X[i]-k>q[0]:\n            m=max(m,d[q.popleft()])\n        q.append(X[i])\n        d[X[i]]=len(q)\n        ans=max(ans,m+len(q))\n   out(ans)\n", "import bisect\nfrom collections import deque\nfrom sys import stdin\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    n,k = map(int,stdin.readline().split())\n    x = list(map(int,stdin.readline().split()))\n    y = list(map(int,stdin.readline().split()))\n\n    x.sort()\n    unAB = deque([])\n    nmax = 0\n    ans = 0\n\n    for i in range(n):\n\n        while len(unAB) > 0 and unAB[0][0] < x[i]-k:\n            tx,val = unAB.popleft()\n            nmax = max(nmax , val)\n\n        ind = bisect.bisect_right(x,x[i]+k)\n        val = ind - i\n        ans = max(ans , nmax + val)\n        unAB.append((x[i],val))\n\n    print (ans)", "import sys\nINF = 10**20\nMOD = 10**9 + 7\nI = lambda:list(map(int,input().split()))\nfrom math import gcd\nfrom math import ceil\nfrom collections import defaultdict as dd, Counter\nfrom bisect import bisect_left as bl, bisect_right as br\n\n\n\"\"\"\nFacts and Data representation\nConstructive? Top bottom up down\n\"\"\"\ndef solve():\n  n, k = I()\n  a = I()\n  y = I()\n  a.sort()\n  max_till = [0] * (2 * n)  \n  ans = 0\n  for i in range(n - 1, -1, -1):\n    left, right = a[i], a[i] + k\n    idxR = br(a, right)\n    idxL = bl(a, left)\n    cur = (idxR - idxL)\n    max_till[i] = max(max_till[i + 1], cur)\n    ans = max(ans, cur + max_till[idxR])\n  print(ans)\n\nt, = I()\nwhile t:\n  t -= 1\n  solve()", "\"\"\"\nNTC here\n\"\"\"\n\n\ndef iin(): return int(input())\n\n\ndef lin(): return list(map(int, input().split()))\n\n\ndef main():\n    from bisect import bisect_right as br, bisect_left as bl\n    t = iin()\n    while t:\n        t-=1 \n        n, k = lin()\n        x = lin()\n        y = lin()\n        x.sort()\n        sol = []\n        for i in range(n):\n            val = x[i] + k\n            pos = br(x, val)\n            sol.append([x[i], pos-i])\n        # print(sol)\n        s1 = [i for i, j in sol]\n        a1 = [j for i, j in sol]\n        for i in range(n-2, -1, -1):a1[i] = max(a1[i], a1[i+1])\n        # print(a1, s1)\n        ans = max(sol, key=lambda x: x[1])[1]\n        for i in range(n):\n            val, count = sol[i]\n            pos = bl(s1, val+k+1)\n            if pos<n:\n                # print(count, a1[pos], ans)\n                ans = max(count + a1[pos], ans)\n        print(ans)\n\nmain()", "import bisect\nt=int(input())\nfor you in range(t):\n    l=input().split()\n    n=int(l[0])\n    k=int(l[1])\n    l=input().split()\n    li=[int(i) for i in l]\n    l=input()\n    li.sort()\n    dp=[[0 for i in range(2)]for i in range(n)]\n    maxas=[0 for i in range(n)]\n    dp[-1][0]=1\n    dp[-1][1]=1\n    maxas[-1]=1\n    for i in range(n-2,-1,-1):\n        if(li[i]+k>=li[-1]):\n            dp[i][0]=n-i\n            dp[i][1]=n-i\n            maxas[i]=max(maxas[i+1],dp[i][0])\n            continue\n        z=bisect.bisect_right(li,li[i]+k)\n        dp[i][0]=z-i\n        maxas[i]=max(maxas[i+1],dp[i][0])\n        dp[i][1]=z-i+maxas[z]\n    maxa=0\n    for i in range(n):\n        maxa=max(maxa,dp[i][0])\n        maxa=max(maxa,dp[i][1])\n    print(maxa)", "\n\nimport bisect \n\nfor _ in range(int(input())):\n    \n    n, k = map(int, input().split())\n    \n    x = list(map(int, input().split()))\n    y = input()\n    x.sort()\n    X = [bisect.bisect_right(x, x[i] + k) for i in range(n)]\n    Y = [0]\n    for i in range(n - 1, -1, -1):\n        Y += [max(Y[-1], X[i] - i)]\n    Y.reverse()\n    ans = 0\n    for i in range(n):\n        ans = max(ans, X[i] - i + Y[X[i]])\n    print(ans)"]