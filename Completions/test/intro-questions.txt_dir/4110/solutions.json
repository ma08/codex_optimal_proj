["import sys\nsys.setrecursionlimit(10 ** 6)\n\nD,G=map(int,input().split())\np=[]\nc=[]\nfor i in range(D):\n  a,b=map(int,input().split())\n  p += [a]\n  c += [b]\n\ndef solve(bit):\n  if bit >= (1<<D):\n    return 1000\n  p_sum=0\n  num=0\n  for i in range(D):\n    if bit & (1<<i):\n      p_sum += c[i] + p[i] * 100*(i+1)\n      num += p[i]\n  if p_sum >= G:\n    return min(num,solve(bit+1))\n  else:\n    for i in reversed(range(D)):\n      if bit & 1<<i:\n        continue\n      for j in range(p[i]):\n        if p_sum >= G:\n          break\n        p_sum += 100*(i+1)\n        num += 1\n      else:\n        return solve(bit+1)\n    return min(num,solve(bit+1))\n\nprint(solve(0))", "def main():\n  ans = 1000\n  d,g  = map(int,input().split())\n  pc = [list(map(int,input().split())) for i in range(d)]\n  pc.reverse()\n  #print(pc)\n  for i in range( 2 ** d):\n    score = 0\n    count = 0\n    for j in range(d):\n      if i & (1<<j):\n        score += pc[j][0] * (d-j) * 100 + pc[j][1]\n        count += pc[j][0]\n    if score >= g:\n      if ans > count:\n        ans = count\n      #print(bin(i),count,score)\n      continue\n    for j in range(d):\n      if not(i &(1<<j)):\n        #print(\"nokori\"+str(j))\n        c = 0\n        for k in range(1,pc[j][0]):\n          score += (d-j) * 100\n          count += 1\n          c += 1\n          if score >= g:\n            if ans > count:\n              ans = count\n            #print(bin(i),j,c,count,score)\n            break\n        break\n  print(ans)\n\ndef __starting_point():\n  ans = 0\n  main()\n__starting_point()", "def dfs(i, sum, count, rest):\n    nonlocal ans\n    if i == d:\n        if sum < g:\n            rest_max = max(rest)\n            n = min(l[rest_max-1][0], -(-(g-sum)//(rest_max*100)))\n            count += n\n            sum += n * rest_max * 100\n        if sum >= g:\n            ans = min(ans, count)\n    else :\n        dfs(i+1, sum, count, rest) #\u4e8c\u5206\u5c90\u306e\u3046\u3061\u89e3\u304b\u306a\u3044\u9078\u629e\n        dfs(i+1, sum + l[i][0]*(i+1)*100+l[i][1], count + l[i][0], rest - {i+1}) #\u89e3\u304f\u9078\u629e\n\nd, g = list(map(int, input().split()))\nl = [list((list(map(int, input().split())))) for _ in range(d)]\nans = float(\"inf\")\ndfs(0, 0, 0, set(range(1, d+1)))\nprint(ans)\n", "d,g = map(int, input().split())\npoint = [list(map(int,input().split())) for i in range(d)]\n\npoint = point[::-1]\n\nans = float(\"inf\")\nfor bit in range(1<<d):\n  total=0\n  cnt=0\n  for i in range(d):\n    if (bit>>i)&1:\n      total += (100*(d-i)*point[i][0]+point[i][1])\n      cnt += point[i][0]\n  if total >= g:\n    ans = min(ans,cnt)\n    continue\n  for j in range(d):\n    if (bit>>j)&1 == False:\n      for k in range(point[j][0]):\n        total += 100*(d-j)\n        cnt += 1\n        if total >= g:\n          ans=min(ans,cnt)\n          break\n      break\nprint(ans)", "d, g = map(int, input().split())\npc = [0] + [list(map(int, input().split())) for i in range(d)]\ndef dfs(ind,score):\n  if ind == 0:\n    return float(\"inf\")\n  cnt = min(score//(ind*100),pc[ind][0])\n  add_sc = cnt*(ind*100)\n  if cnt == pc[ind][0]:\n    add_sc += pc[ind][1]\n  if add_sc < score:\n    cnt += dfs(ind-1,score-add_sc)\n  return min(cnt,dfs(ind-1,score))\n \nprint(dfs(d,g))", "import itertools as itr\n\nD,G=map(int, input().split())\np=[list(map(int, input().split()))  for _ in range(D)]\nb=list(itr.product(range(2),repeat=D))\n\nans=float('INF')\n\nfor i in range(len(b)):\n    temp=0\n    pnt=0\n    for j in range(D):\n        if b[i][j]==1:\n            temp+=p[j][0]\n            pnt+=(j+1)*100*p[j][0]\n            pnt+=p[j][1]\n\n    if pnt>=G:\n        ans=min(ans,temp)\n        \n    else:\n        for j in range(D):\n            if b[i][-j-1]==0:\n                for k in range(p[-j-1][0]-1):\n                    temp+=1\n                    pnt+=(D-j)*100\n                    if pnt>=G:  \n                        ans=min(ans,temp)\n                        break\n                break\n                \nprint(int(ans))", "D,G = map(int,input().split())\ndic1 = {}\ndic2 = {}\ndic3 = []\nmin_ans = 10000000000\n#dic\u306fdic[\u70b9\u6570][\u554f\u984c\u6570][\u30b3\u30f3\u30d7\u30ea\u30fc\u30c8]\nfor i in range(1,D+1):\n    p,c = map(int,input().split())\n    dic1[i*100] = p\n    dic2[i*100] = i*100*p+c\n    dic3.append(i*100)\n\nn = len(dic1)\nfor i in range(2 ** n):\n    bag = []\n    bag_sum = 0\n    bag_len = 0\n    for j in range(n):\n        if ((i >> j) & 1):\n            bag.append(dic3[j])\n    for k in range(len(bag)):\n        bag_sum += dic2[bag[k]]\n        bag_len += dic1[bag[k]]\n\n    if bag_sum >= G:\n        min_ans = min(min_ans,bag_len)\n    else:\n        for i in range(len(dic3)):\n            if dic3[(i+1)*-1] in bag:\n                continue\n            for u in range(dic1[dic3[(i+1)*-1]]-1):\n                bag_len += 1\n                bag_sum+=dic3[(i+1)*-1]\n                if bag_sum >= G:\n\n                    min_ans = min(min_ans,bag_len)\n                    break\n\n    \nprint(min_ans)", "D,G=list(map(int,input().split()))\ns=[list(map(int,input().split())) for _ in range(D)]\n\nans=10000\nfor i in range(2**D):\n    score=0\n    cnt=0\n    rest=[]\n    for j in range(D):\n        if (i>>j)&1:\n            score+=100*(j+1)*s[j][0]+s[j][1]\n            cnt+=s[j][0]\n        else:\n            rest.append(j)\n\n    if score<G:\n        r=rest[-1]\n        for _ in range(s[r][0]-1):\n            score+=100*(r+1)\n            cnt+=1\n            if score>=G: break\n\n    if score>=G:\n        ans=min(cnt,ans)\n\nprint(ans)\n", "[D,G],*li = [list(map(int,i.split())) for i in open(0)]\n\nans = float('inf')\n\ndef dfs(i,ten,num,p):\n    nonlocal ans\n    if i==D:\n        if ten >= G:\n            ans = min(ans,num)\n        else:\n            for q in p:\n                for r in range(li[q][0]):\n                    ten += (q+1)*100\n                    num += 1\n                    if r==li[q][0]:\n                        ten += li[q][1]\n                    if ten >= G:\n                        ans = min(ans,num)\n                        break\n                else:continue\n                break\n    else:\n        dfs(i+1,ten+(i+1)*100*li[i][0]+li[i][1],num+li[i][0],p)\n        dfs(i+1,ten,num,[i]+p)\ndfs(0,0,0,[])\nprint(ans)", "D, G = list(map(int, input().split())) #D: \u554f\u984c\u6570, G: \u76ee\u6a19\u70b9\nPC = [list(map(int, input().split())) for i in range(D)]\n\nans = float(\"inf\")\n\nfor i in range(2**D):\n    tmp = 0\n    cnt = 0\n    dic = set(range(1, D+1))\n    for j in range(D):\n        if (i >> j)&1: #\u305d\u306e\u554f\u984c\u306f\u5168\u3066\u89e3\u304f\n            tmp += PC[j][0] * (j+1) * 100 + PC[j][1]\n            cnt += PC[j][0]\n            dic.discard(j+1)\n\n    if tmp < G:\n        t = max(dic)\n        p, c = PC[t-1][0], PC[t-1][1]\n        if t*100*p+c+tmp >= G:\n            while p:\n                tmp += t*100\n                cnt += 1\n                if tmp >= G:\n                    break\n            ans = min(ans, cnt)\n    else:\n        ans = min(ans, cnt)\nprint(ans)\n", "from math import ceil\nD, G = map(int,input().split())\nps, cs = [], []\nfor _ in range(D):\n    p, c = map(int,input().split())\n    ps.append(p)\n    cs.append(c)\nans = float(\"inf\")\nfor i in range(2**D):\n    cnt = 0\n    point = 0\n    for j in range(D):\n        if (i>>j)&1:\n            cnt += ps[j]\n            point += ps[j]*100*(j+1)+cs[j]\n    if point >= G:\n        ans = min(ans, cnt)\n        continue\n    for j in range(D-1, -1, -1):\n        if (i>>j)&1 == 0:\n            if (ps[j]-1)*100*(j+1)+point >= G:\n                cnt += ceil((G-point)/100/(j+1))\n                point += ceil((G-point)/100/(j+1))*100*(j+1)\n                break\n            else:\n                cnt += (ps[j]-1)\n                point += (ps[j]-1)*100*(j+1)\n    if point >= G:\n        ans = min(ans, cnt)\nprint(ans)", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float('inf')\n\nfor i in range(1<<d):\n  count = 0\n  sum = 0\n  nokori = set(range(1, d+1))\n  \n  for j in range(d):\n    if i & (1 << j):\n      sum += pc[j][0]*(j+1)*100 + pc[j][1]\n      count += pc[j][0]\n      nokori.discard(j+1)\n      \n  if sum<g:\n    use = max(nokori)\n    n = min(pc[use-1][0], -(-(g-sum)//(use*100)))\n    count += n\n    sum += n*use*100\n    \n  if sum>=g:\n    ans = min(ans, count)\n    \nprint(ans)", "def dfs(i, sum, count, nokori):\n    nonlocal ans\n    if i == d:\n        if sum < g:\n            use = max(nokori)\n\n            n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n            count += n\n            sum += n * use * 100\n\n        if sum >= g:\n            ans = min(ans, count)\n            \n    else:\n        dfs(i+1, sum, count, nokori)\n        dfs(i+1, sum + pc[i][0] * (i+1) * 100 + pc[i][1], count + pc[i][0], nokori - {i + 1})\n\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float(\"inf\")\n\ndfs(0, 0, 0, set(range(1, d+1)))\nprint(ans)", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d + 1))\n\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            count += pc[i][0]\n            nokori.discard(i + 1)\n\n    # G \u70b9\u306b\u6e80\u305f\u306a\u3051\u308c\u3070 nokori \u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u3092\u89e3\u304f\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n        count += n\n        sum += n * use * 100\n\n    if sum >= g:\n        ans = min(ans, count)\n\nprint(ans)", "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    D, G = LI()\n    pc = [LI() for _ in range(D)]\n\n    # \u30b3\u30f3\u30d7\u30ea\u30fc\u30c8\u3059\u308b\u554f\u984c\u3092\u5168\u30d1\u30bf\u30fc\u30f3\u8a66\u3059\n    # \u8db3\u308a\u306a\u3044\u5206\u304c\u3042\u308c\u3070\u89e3\u3044\u3066\u306a\u3044\u6700\u9ad8\u70b9\u6570\u306e\u554f\u984c\u3067\u57cb\u3081\u308b\n    ans = sum([i[0] for i in pc])\n    for i in range(2 ** D):\n        score = 0\n        num = 0\n        not_completed_max = -1\n        for j in range(D):\n            if i >> j & 1:\n                score += pc[j][0] * (j + 1) * 100  + pc[j][1]\n                num += pc[j][0]\n            else:\n                not_completed_max = max(j, not_completed_max)\n        if score >= G:\n            ans = min(num, ans)\n        elif (G - score) // ((not_completed_max + 1) * 100) <= pc[not_completed_max][0]:\n            ans = min(num + (G - score - 1) // ((not_completed_max + 1) * 100) + 1, ans)\n\n    print(ans)\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "#\n# abc104 c\n#\nimport sys\nfrom io import StringIO\nimport unittest\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"2 700\n3 500\n5 800\"\"\"\n        output = \"\"\"3\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"2 2000\n3 500\n5 800\"\"\"\n        output = \"\"\"7\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"2 400\n3 500\n5 800\"\"\"\n        output = \"\"\"2\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_4(self):\n        input = \"\"\"5 25000\n20 1000\n40 1000\n50 1000\n30 1000\n1 1000\"\"\"\n        output = \"\"\"66\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    D, G = list(map(int, input().split()))\n    PC = [list(map(int, input().split())) for _ in range(D)]\n\n    ans = float(\"inf\")\n    for bit in range(1 << D):\n        s = 0\n        c = 0\n        un = set(range(D))\n        for i in range(D):\n            if bit & 1 << i:\n                s += 100*(i+1)*PC[i][0] + PC[i][1]\n                c += PC[i][0]\n                un.discard(i)\n\n        if s >= G:\n            ans = min(ans, c)\n        else:\n            u = max(un)\n            for i in range(1, PC[u][0]):\n                if s+(u+1)*100*i >= G:\n                    c += i\n                    break\n            else:\n                continue\n            ans = min(ans, c)\n\n    print(ans)\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "# \u672a\u77e5\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u304b\u5929\u624d\u7cfbDP\u304b\u3068\u601d\u3063\u3066\u3059\u3050\u8ae6\u3081\u3066\u89e3\u8aac\u8aad\u3093\u3067\u3057\u307e\u3063\u305f\n\nd, g = list(map(int, input().split()))\npoints = []\nfor _ in range(d):\n    p, c = list(map(int, input().split()))\n    points.append((p, c))\nans = 10**12\nfor bit in range(2**d):\n    arr = [False] * d\n    for i in range(d):\n        if bit >> i & 1 == 1:\n            arr[i] = True\n    tmp_sum = 0\n    count = 0\n    for i in range(d):\n        if arr[i]:\n            # kompuli-to\n            tmp_sum += points[i][1]\n            tmp_sum += (i + 1) * 100 * points[i][0]\n            count += points[i][0]\n    if tmp_sum < g:\n        # \u9054\u6210\u3067\u304d\u308b\u307e\u3067\u5f97\u70b9\u306e\u9ad8\u3044\u3084\u3064\u304b\u3089\u3084\u3063\u3066\u3044\u304f\n        for i in range(d - 1, -1, -1):\n            if arr[i]:\n                # \u3059\u3067\u306bkompuli-to\u3057\u3066\u308b\u306e\u3067\n                continue\n            used = 0\n            for j in range(points[i][0]):\n                if tmp_sum < g:\n                    tmp_sum += (i + 1) * 100\n                    count += 1\n                    used += 1\n            if used == points[i][0]:\n                tmp_sum += points[i][1]\n            if tmp_sum >= g:\n                break\n    ans = min(ans, count)\nprint(ans)\n", "D, G = list(map(int, input().split()))\npc = [list(map(int, input().split())) for i in range(D)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << D):\n    count = 0\n    sum = 0\n    rest = list(range(1, D+1))\n\n    for i in range(D):\n        if bit & (1 << i):\n            sum += (i + 1) * pc[i][0] * 100 + pc[i][1]\n            count += pc[i][0]\n            rest.remove(i + 1)\n\n    if sum < G:\n        max_num = max(rest)\n        n = min(pc[max_num - 1][0], -(-(G - sum) // (max_num * 100)))\n        count += n\n        sum += n * max_num * 100\n\n    if sum >= G:\n        ans = min(ans, count)\n\nprint(ans)\n", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\nans = float('inf')\nfor i in range(2**d):\n    score = 0\n    cnt = 0\n    check = [0]*d\n    for j in range(d):\n        if (i>>j) & 1:\n            check[j] = 1\n            score += (j+1)*100*pc[j][0] + pc[j][1]\n            cnt += pc[j][0]\n    j = d-1\n    while score < g and j >=0:\n        if check[j] == 0:\n            n = min(pc[j][0], -(-(g-score) // ((j+1)*100)))\n            score += n*(j+1)*100\n            cnt += n\n        j -= 1\n    if score >= g:\n        ans = min(ans, cnt)\nprint(ans)", "from itertools import product\nimport math\nD, G = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(D)]\n\nans = []\n\nfor lst in product([0, 1], repeat=D):\n    temp = 0\n    cnt = 0\n    max0 = -1\n    p = 0\n    for i, j in enumerate(lst):\n        temp += (pc[i][0] * 100 * (i+1) + pc[i][1]) * j\n        cnt += pc[i][0] * j\n        if j == 0 and max0 < i: max0 = i\n    if temp < G and max0 != -1:\n        p = math.ceil((G - temp)/(100 * (max0 + 1)))\n        if p < pc[max0][0]:\n            cnt += p\n            temp += p * 100 * (max0 + 1)\n    if temp >= G: ans.append(cnt)\n\nprint(min(ans))", "import math\n\nD, G = list(map(int, input().split()))\npc = [list(map(int, input().split())) for i in range(D)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << D):\n    count = 0\n    sum = 0\n    rest = list(range(1, D+1))\n\n    for i in range(D):\n        if bit & (1 << i):\n            sum += (i + 1) * pc[i][0] * 100 + pc[i][1]\n            count += pc[i][0]\n            rest.remove(i + 1)\n\n    if sum < G:\n        max_num = max(rest)\n        n = min(pc[max_num - 1][0], math.ceil((G - sum) / (max_num * 100)))\n        count += n\n        sum += n * max_num * 100\n\n    if sum >= G:\n        ans = min(ans, count)\n\nprint(ans)\n", "#!/usr/bin/env python3\n\nimport math\n#\u00a0\u30b9\u30da\u30fc\u30b9\u533a\u5207\u308a\u306e\u6574\u6570\u306e\u5165\u529b\nd, g = list(map(int, input().split()))\n#\u914d\u5217\u306e\u5165\u529b\ndata = [list(map(int, input().split())) for _ in range(d)]\nsn=1000\n\nfor i in range(2**d):\n    ts = [False]*d\n    score = 0\n    tmp_sn = 0\n    flg = True\n    for j in range(d):\n        if (i>>j)&1:\n            ts[j] = True\n            score += data[j][0]*100*(j+1)+data[j][1]\n            tmp_sn += data[j][0]\n\n\n    if score < g:\n        for k in reversed(list(range(len(ts)))):\n            if  ts[k] == False:\n                need = g - score\n                s1 = (k+1) * 100\n                nnum = math.ceil(need / s1)\n                if nnum < data[k][0]:\n                    tmp_sn += nnum\n                    break\n                else:\n                    flg = False\n                    break\n\n    if flg == True and sn > tmp_sn:\n        sn = tmp_sn\n\nprint(sn)\n\n\n\n\n\n\n", "import math\nd,g=map(int,input().split())\np=[list(map(int,input().split())) for _ in range(d)]\nans=sum([i[0] for i in p])\nfor i in range(2**d-1):\n    bit=bin(i)[2:].zfill(d)\n    c,s,a=0,0,0\n    for j in range(d):\n        if bit[j]=='1':\n            c+=p[j][0]\n            s+=p[j][1]+100*(j+1)*p[j][0]\n        else:\n            a=max(a,j)\n    short=g-s\n    pc=max(math.ceil(short/((a+1)*100)),0)\n    if pc<p[a][0]:\n        ans=min(c+pc,ans)\nprint(ans)", "D,G=map(int,input().split())\npc=[list(map(int,input().split())) for i in range(D)]\nans=G // 100\n\nfor i in range(2**D):\n    score=0\n    b=0\n    cnt=0\n    for j in range(D):\n        if ((i>>j)&1):\n            score+=100*(j+1)*pc[j][0]+pc[j][1]\n            cnt+=pc[j][0]\n        else:\n            b=j\n    for k in range(pc[b][0]):\n        if score>=G and cnt<ans:\n            ans=cnt\n        score+=(b+1)*100\n        cnt+=1\nprint(ans)", "d, gl = map(int, input().split())\np = []\ng = []\nfor i in range(d):\n  P,G = map(int, input().split())\n  p.append(P)\n  g.append(G)\nans = sum(p)\nfor i in range(1<<d):\n  tmp = 0\n  c = 0\n  b = [0 for i in range(d)]\n  for j in range(d):\n    if i&(1<<j):\n      tmp += g[j] + (j+1)*p[j]*100\n      c += p[j]\n      b[j] = 1\n  s = d-1\n  while tmp < gl and s >= 0:\n    if b[s] == 1:\n      s -= 1\n    else:\n      for k in range(p[s]):\n        tmp += 100*(s+1)\n        c += 1\n        if tmp >= gl:\n          break\n      s -= 1\n  ans = min(ans,c)\nprint (ans)", "import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\ndef main():\n    D, G = NMI()\n    pc = [NLI() for _ in range(D)]\n    ans = 1000\n    \n    bit_len = D\n    for i in range(2**bit_len):\n        ls = [0 for _ in range(bit_len)]\n        for j in range(bit_len):\n            if (i >> j) & 1:\n                ls[j] = 1\n        \n        point = 0\n        solved = 0\n        half_way = \"\"\n        \n        for n in range(D):\n            if ls[n] == 1:\n                solved += pc[n][0]\n                point += pc[n][0]*100*(n+1) +pc[n][1]\n            else:\n                half_way = n\n        \n        if G > point:\n            if half_way != \"\":\n                remain = int(math.ceil((G-point)/((half_way+1)*100)))\n                if remain <pc[half_way][0]:\n                    solved += remain\n                    ans = min(ans,solved)\n        else:\n            ans = min(ans,solved)\n        \n    print(ans)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "import copy\nimport heapq\n\nfrom typing import List, Tuple\n\n\ndef main():\n    d, g = list(map(int, input().split()))\n    v = []\n    for _ in range(d):\n        p, c = list(map(int, input().split()))\n        v.append((p, c))\n\n    print((ag(v, g)))\n\n\ndef ag(v: List[Tuple[int, int]], g: int) -> int:\n    rs = []\n    # ex. [(3, 500), (5, 800)] -> [(1, 3, 500), (2, 5, 800)]\n    v = [(i, p, c) for i, (p, c) in enumerate(v, 1)]\n\n    for j in range(2 ** len(v)):\n        cb = []\n        for k in range(len(v)):\n            if ((j >> k) & 1):\n                cb.append(v[k])\n\n        sc = 0\n        cnt = 0\n        # calc bonus score\n        for (i, p, c) in cb:\n            sc += i * 100 * p + c\n            cnt += p\n\n        vv = [x for x in copy.copy(v) if not x in cb]\n        while sc < g:\n            if not vv:\n                break\n            i, p, _ = vv.pop()\n            for _ in range(p - 1):\n                if sc >= g:\n                    break\n                sc += i * 100\n                cnt += 1\n\n        if sc >= g:\n            heapq.heappush(rs, cnt)\n    return heapq.heappop(rs)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n \nans = float(\"inf\")\n \nfor bit in range(1 << d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d + 1))\n \n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            count += pc[i][0]\n            nokori.discard(i + 1)\n \n    # G \u70b9\u306b\u6e80\u305f\u306a\u3051\u308c\u3070 nokori \u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u3092\u89e3\u304f\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n        count += n\n        sum += n * use * 100\n \n    if sum >= g:\n        ans = min(ans, count)\n \nprint(ans)", "D,G=map(int,input().split())\np=[0]*D\nc=[0]*D\nfor i in range(D):\n    p[i],c[i]=map(int,input().split())\n\nans=1000\nfor i in range(2 ** D):\n    op = [\"-\"] * D\n    for j in range(D):\n        if ((i >> j) & 1):\n            op[D - 1 - j] = \"+\"\n    s=0\n    cnt=0\n    for j in range(D):\n        if op[j]==\"+\":\n            s+=100*(j+1)*p[j]\n            s+=c[j]\n            cnt+=p[j]\n    if s<G:\n        for j in range(D-1,-1,-1):\n            if op[j]==\"-\":\n                for k in range(p[j]):\n                    if s>=G:\n                        break\n                    s+=100*(j+1)\n                    cnt+=1\n    ans=min(cnt,ans)\n\nprint(ans)", "def dsf(i,sum,count,nokori):\n    nonlocal ans\n    # \u968e\u5c64\u304c\u6700\u4e0b\u5c64\u306b\u306a\u3063\u305f\u6642\n    if i == d:\n        #sum\u306f\u7d76\u5bfe\u7b54\u3048\u3067\u306f\u306a\u3044\n        if sum < g:\n            use = max(nokori)\n            n = min(pc[use - 1][0],-(-(g - sum) // (100 * use)))\n            count += n\n            sum += n * use * 100\n\n\n\n        # sum\u306f\u7b54\u3048\u306b\u306a\u308b\u53ef\u80fd\u6027\u3042\u308a\n        if sum >= g:\n            ans = min(ans,count)\n    else:\n        #\u554f\u984c\u3092\u89e3\u304b\u306a\u3044\u30d1\u30bf\u30fc\u30f3\n        dsf(i+1,sum,count,nokori)\n        #\u554f\u984c\u3092\u89e3\u304f\u30d1\u30bf\u30fc\u30f3(\u968e\u5c64\u3001\u5408\u8a08+\u6700\u5927\u306e\u30dc\u30fc\u30ca\u30b9\u3001\u73fe\u5728\u306e\u5408\u8a08\u306e\u6570+\u6700\u5927\u306e\u6570\u3001\u6b8b\u308a\u306e\u554f\u984c\u3092\u7ba1\u7406)\n        dsf(i + 1,sum + pc[i][0] * (i + 1) * 100 + pc[i][1],count + pc[i][0],nokori - {i + 1})\n# \u89e3\u304f\u554f\u984c\u3068\u3068\u304b\u306a\u3044\u554f\u984c\nd,g = map(int,input().split())\npc = [list(map(int,input().split())) for i in range(d)]\nans = float('inf')\n\n#\u968e\u5c64\u3001\u5408\u8a08\u3001\u73fe\u5728\u306e\u5408\u8a08\u306e\u6570\u3001\u6b8b\u308a\u306e\u554f\u984c\u3092\u7ba1\u7406\ndsf(0,0,0,set(range(1,d + 1)))\nprint(ans)", "from itertools import product\n\nD, G = map(int, input().split())\nG //= 100\nprob = []\n\nfor i in range(1, D+1):\n  p, c = map(int, input().split())\n  prob.append((i, p, c//100))\n\nans = 1000\nfor comp in product((0, 1), repeat=D):\n  cnt, score = 0, 0\n  for i, c in enumerate(comp):\n    if c:\n      cnt += prob[i][1]\n      score += prob[i][0]*prob[i][1] + prob[i][2]\n  j = D-1\n  while score < G and j >= 0:\n    if comp[j] == 0:\n      if score + prob[j][0]*prob[j][1] <= G:\n        cnt += prob[j][1]\n        score += prob[j][0]*prob[j][1]\n      else:\n        temp = -(-(G - score)//prob[j][0])\n        cnt += temp\n        score += prob[j][0]*temp\n    j -= 1\n  ans = min(ans, cnt)\n\nprint(ans)", "def dfs(i, sum, count, nokori):\n    nonlocal ans\n    if i == d:\n        # G \u70b9\u306b\u6e80\u305f\u306a\u3051\u308c\u3070 nokori \u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u3092\u89e3\u304f\n        if sum < g:\n            use = max(nokori)\n            # \u89e3\u304f\u554f\u984c\u304c\u554f\u984c\u6570\u3092\u8d85\u3048\u306a\u3044\u3088\u3046\u306b\u6ce8\u610f\n            n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n            count += n\n            sum += n * use * 100\n\n        if sum >= g:\n            ans = min(ans, count)\n    else:\n        # \u7dcf\u5408\u30b9\u30b3\u30a2\u3001\u89e3\u3044\u305f\u554f\u984c\u6570\u3001\u307e\u3060\u89e3\u3044\u3066\u306a\u3044\u554f\u984c\u3092\u66f4\u65b0\n        dfs(i + 1, sum, count, nokori)\n        dfs(i + 1, sum + pc[i][0] * (i + 1) * 100 + pc[i][1], count + pc[i][0], nokori - {i + 1})\n\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float(\"inf\")\n\ndfs(0, 0, 0, set(range(1, d + 1)))\nprint(ans)", "D, G = map(int, input().split())\n\nP = []\nC = []\nfor _ in range(D):\n  p, c = map(int, input().split())\n  P.append(p)\n  C.append(c)\n\nans = []\nfor bit in range(1<<D):\n  total_score = 0\n  solved = 0\n  for i in range(D):\n    if bit & (1<<i):\n      total_score += C[i] + ((i+1)*100) * P[i]\n      solved += P[i]\n\n  for i in range(D - 1, -1, -1):\n    if G <= total_score:\n      ans.append(solved)\n      break\n      \n    if bit & (1<<i):\n      continue\n      \n    s = (i+1) * 100\n    required_score = G - total_score\n    required_problem = (required_score + s - 1) // s\n    total_score += min(required_problem, P[i]-1) * s\n    solved += min(required_problem, P[i]-1)\n\n    if G <= total_score:\n      ans.append(solved)\n    \n    break\n    \nprint(min(ans))", "d, g = map(int, input().split())\npc = [list(map(int,input().split())) for _ in range(d)]\nans = g//100 + 1\n\nfor i in range(2**d):\n    count = 0\n    total = 0\n    for j in range(d):\n        if (i >> j) & 1 == 1:\n            count += pc[j][0]\n            total += (j+1)*100*pc[j][0] + pc[j][1]\n\n    if total >= g:\n        ans = min(ans, count)\n    else:\n        for k in reversed(range(d)):\n            if ((i >> k) & 1) == 0:\n                for _ in range(pc[k][0]-1):\n                    count += 1\n                    total += (k+1)*100\n                    if total >= g:\n                        ans = min(ans, count)\n                        break\n\nprint(ans)", "# \u307e\u3060\u89e3\u3044\u3066\u306a\u3044\u914d\u70b9\u3092 nokori \u3068\u3057\u3066\u6301\u3064\ndef dfs(i, sum, count, nokori):\n    nonlocal ans\n    if i == d:\n        # G \u70b9\u306b\u6e80\u305f\u306a\u3051\u308c\u3070 nokori \u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u3092\u89e3\u304f\n        if sum < g:\n            use = max(nokori)\n            # \u89e3\u304f\u554f\u984c\u304c\u554f\u984c\u6570\u3092\u8d85\u3048\u306a\u3044\u3088\u3046\u306b\u6ce8\u610f\n            n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n            count += n\n            sum += n * use * 100\n\n        if sum >= g:\n            ans = min(ans, count)\n    else:\n        # \u7dcf\u5408\u30b9\u30b3\u30a2\u3001\u89e3\u3044\u305f\u554f\u984c\u6570\u3001\u307e\u3060\u89e3\u3044\u3066\u306a\u3044\u554f\u984c\u3092\u66f4\u65b0\n        dfs(i + 1, sum, count, nokori)\n        dfs(i + 1, sum + pc[i][0] * (i + 1) * 100 + pc[i][1], count + pc[i][0], nokori - {i + 1})\n\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float(\"inf\")\n\ndfs(0, 0, 0, set(range(1, d + 1)))\nprint(ans)", "d, g = map(int, input().split())\npoint = [[int(x) for x in input().split()] for i in range(d)]\n\nans = 100000000\nfor i in range(2**d):\n  sub = 0\n  count = 0\n  complete = [False]*d\n  for j in range(d):\n    if (i>>j)&1:\n      complete[j] = True\n      sub += 100*(j+1)*point[j][0]+point[j][1]\n      count += point[j][0]\n  for j in range(d-1, -1, -1):\n    if sub >= g:\n      break\n    if complete[j]:\n      continue\n    c = min((g-sub-1)//(100*(j+1))+1, point[j][0])\n    count += c\n    sub += c*100*(j+1)\n    if c == point[j][0]:\n      sub += point[j][1]\n  if ans > count:\n    ans = count\n\nprint(ans)", "d, g = map(int, input().split())\npc = [0] + [list(map(int, input().split())) for i in range(d)]\ndef dfs(ind,score):\n  if ind == 0:\n    return float(\"inf\")\n  cnt = min(score//(ind*100),pc[ind][0])\n  add_sc = cnt*(ind*100)\n  if cnt == pc[ind][0]:\n    add_sc += pc[ind][1]\n  if add_sc < score:\n    cnt += dfs(ind-1,score-add_sc)\n  return min(cnt,dfs(ind-1,score))\n\nprint(dfs(d,g))", "d,G = map(int,input().split())\ng = G//100\nplist = [list() for _ in range(d)]\npp = []\npe = []\nfor i in range(d):\n    p,C = map(int,input().split())\n    c = C//100\n    pp += [p]\n    if p==1:\n        pe += [i]\n    plist[i] += [i+1]*(p-1)\n    plist[i] += [i+1+c]\n\npoli = [list() for _ in range(d)]\nfor i in range(d):\n    poli[i] += [plist[i][0]]\n    for j in range(pp[i]-1):\n        poli[i] += [poli[i][j]+plist[i][j+1]]\n\nimport math\nnumli = []\nfor i in range(2**d):\n    kari = 0\n    nkanli = []\n    karimon = 0\n    for j in range(d):\n        if (i>>j)&1 == 1:\n            kari += poli[j][-1]\n            karimon += pp[j]\n        else:\n            nkanli +=[j]\n    if kari>=g:\n        numli += [karimon]\n    else:\n        if nkanli == []:\n            continue\n        else:\n            for k in range(len(nkanli)-1,-1,-1):\n                if nkanli[k] in pe:\n                    continue\n                else:\n                    if kari + poli[nkanli[k]][-2]>=g:\n                        karimon += math.ceil((g-kari)/(nkanli[k]+1))\n                        numli += [karimon]\n                        break\n                    else:\n                        break\n    #print(kari,nkanli,karimon)\n#print(numli)\nprint(min(numli))", "from math import ceil\n\nd,g = map(int,input().split())\npc = [list(map(int,input().split())) for i in range(d)]\n\nans = float(\"inf\")\nfor bit in range(1<<d):\n    sum = 0\n    cnt = 0\n    #\u6b8b\u3063\u3066\u308b\u3084\u3064\u306emax\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u53d6\u5f97\u3059\u308b\u305f\u3081set\u3092\u8a2d\u5b9a\n    nokori = set(range(1, d + 1))\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0]*100*(i+1) + pc[i][1]\n            cnt += pc[i][0]\n            nokori.discard(i+1)\n    \n    if sum < g:\n        use = max(nokori)\n        husoku = min(ceil((g-sum)/(use*100)),pc[use-1][0])\n        cnt += husoku\n        sum += husoku*use*100\n    \n    if sum >= g:\n        ans = min(cnt,ans)\n\nprint(ans)", "# -*- coding: utf-8 -*-\nD, G = list(map(int, input().split()))\ndata = [list(map(int, input().split())) for i in range(D)]\nps, cs = list(zip(*data))\nclear_cnt = D\nmin_prb = 1000\nfor i in range(1 << D):\n    result = 0\n    num_prb = 0\n    not_selected_list = list()\n    for j in range(D):\n        if (i >> j & 1):\n            result += ps[j] * 100 * (j+1) + cs[j]\n            num_prb += ps[j]\n        else:\n            not_selected_list.append(j)\n    if result < G:\n        not_selected = max(not_selected_list)\n        add_num_prb = min(ps[not_selected], -(-(G - result)//(100*(not_selected+1))) )\n        num_prb += add_num_prb\n        result += add_num_prb * (not_selected+1) * 100\n    if result >= G:\n        min_prb = min(min_prb, num_prb)\nprint((int(min_prb)))\n", "d,g = map(int, input().split())\npc = list(list(map(int,input().split())) for _ in range(d))\nans = float(\"inf\")\n          \nfor i in range(1<<d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d+1))\n    \n    # \u30dc\u30fc\u30ca\u30b9\u3092\u3082\u3089\u3048\u308b\u89e3\u7b54\u306e\u307f\u3067\u30b9\u30b3\u30a2\u3092\u8a08\u7b97\n    for j in range(d):\n        if i & 1<<j:\n            sum += pc[j][0]*(j+1)*100+pc[j][1]\n            count += pc[j][0]\n            nokori.discard(j+1)\n            \n    # \u30b9\u30b3\u30a2\u304cG\u70b9\u306b\u5c4a\u304b\u306a\u3044\u5834\u5408\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use-1][0], -(-(g-sum)//(use*100)))\n        count += n\n        sum += n*use*100\n        \n    # \u30b9\u30b3\u30a2\u304cG\u70b9\u306b\u5c4a\u3044\u305f\u5834\u5408\n    if sum >= g:\n        ans = min(ans, count)\nprint(ans)", "d, g = map(int, input().split())\ndp = [0 for i in range(1001)]\ndp[0] = 0\nnum = 0\nfor i in range(1, d + 1):\n    p, c = map(int, input().split())\n    for j in range(num, -1, -1):\n        for k in range(1, p + 1):\n            if k != p:\n                dp[j + k] = max(dp[j + k], dp[j] + 100 * i * k)\n            else:\n                dp[j + k] = max(dp[j + k], dp[j] + 100 * i * k + c)\n    num += p\nfor i in range(1001):\n    if dp[i] >= g:\n        print(i)\n        break", "D, G = map(int, input().split())\nproblem = [list(map(int, input().split())) for _ in range(D)]\n\nans = 10**15\nfor i in range(2**D):\n    score = 0\n    prob = 0\n    lst = []\n    for j in range(D):\n        if((i >> j) & 1):\n            score += (j+1)*100*problem[j][0]+problem[j][1]\n            prob += problem[j][0]\n        else:\n            lst.append(j)\n            \n            \n    if(score < G):\n        r = lst[-1]\n        for _ in range(problem[r][0]-1):\n            score += 100*(r+1)\n            prob += 1\n            if(score >= G):\n                break\n        \n    if(score >= G):\n        ans = min(ans, prob)\n            \nprint(ans)", "d,g=map(int,input().split())\np=[]\nc=[]\nfor i in range(d):\n    P,C=map(int,input().split())\n    p.append(P)\n    c.append(C)\nans=sum(p)\nfor i in range(2**d):\n    z=i\n    x=[]\n    for j in range(d):\n        x.append(z%2)\n        z=z//2\n    po=0\n    m=0\n    for j in range(d):\n        if x[j]==1:\n            po+=100*(j+1)*p[j]+c[j]\n            m+=p[j]\n    q=[[] for j in range(d)] #\u6b8b\u308ap\u3001c\n    s=0\n    for j in range(d):\n        if x[j]==0:\n            q[s].append(100*(j+1))\n            q[s].append(p[j])\n            s+=1\n    q=[q[j] for j in range(d) if q[j]!=[]]\n    q=sorted(q,reverse=True)\n    w=len(q)\n    for j in range(w):\n        q[j][1]-=1\n    if po>=g:\n        ans=min(ans,m)\n    else:\n        for j in range(w):\n            if po+q[j][0]*q[j][1]>=g:\n                m+=(g-po+q[j][0]-1)//q[j][0]\n                ans=min(ans,m)\n                break\n            else:\n                po+=q[j][0]*q[j][1]\n                m+=q[j][1]\nprint(ans)", "d, g = map(int, input().split())\npc = [0] + [list(map(int, input().split())) for i in range(d)]\ndef dfs(d_, g_):\n    if d_ == 0:\n        return float(\"inf\")\n    cnt = min(g_ // (d_ * 100), pc[d_][0])\n    cur = cnt * 100 * d_\n    if cnt == pc[d_][0]:\n        cur += pc[d_][1]\n    if g_ > cur:\n        cnt += dfs(d_ - 1, g_ - cur)\n    return min(cnt, dfs(d_ - 1, g_))\nprint(dfs(d, g))", "import math\n\nD, G = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(D)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << D):\n    cnt = 0\n    sum = 0\n    pids = set(range(D))\n\n    for i in range(D):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            cnt += pc[i][0]\n            pids.discard(i)\n\n    if sum < G:\n        pid = max(pids)\n        n = min(pc[pid][0], math.ceil((G - sum) / ((pid + 1) * 100)))\n        cnt += n\n        sum += n * (pid + 1) * 100\n        \n    if sum >= G:\n        ans = min(ans, cnt)\n\nprint(ans)", "d, g = map(int, input().split())\npc = [list(map(int,input().split())) for _ in range(d)]\nans = g//100 + 1\n\nfor i in range(2**d):\n    count = 0\n    total = 0\n    for j in range(d):\n        if (i >> j) & 1 == 1:\n            count += pc[j][0]\n            total += (j+1)*100*pc[j][0] + pc[j][1]\n\n    if total >= g:\n        ans = min(ans, count)\n    else:\n        for k in reversed(range(d)):\n            if ((i >> k) & 1) == 0:\n                for _ in range(pc[k][0]):\n                    if total >= g:\n                        ans = min(ans, count)\n                        break\n                    count += 1\n                    total += (k+1)*100\n\nprint(ans)", "from math import ceil\n\nD, G = map(int,input().split())\npc = [list(map(int,input().split())) for i in range(D)]\n\nans = float(\"inf\")\nfor bit in range(1 << D):\n    cnt = 0\n    sum = 0\n    remain = set(range(1,D+1))\n\n    for i in range(D):\n        if bit & (1 << i):\n            cnt += pc[i][0]\n            sum += pc[i][0]*(i+1)*100 + pc[i][1]\n            remain.discard(i+1)\n\n    if sum < G:\n        use = max(remain)\n        n = min(pc[use-1][0], ceil((G-sum)/(use*100)))\n        cnt += n\n        sum += n*use*100\n\n    if sum >= G:\n        ans = min(ans,cnt)\n\nprint(ans)", "from collections import defaultdict\n\ndef main():\n    D, G = map(int, input().split())\n    problem = []\n    for _ in range(D):\n        p, c = map(int, input().split())\n        problem.append([p,c])\n    ans = float('inf')\n    for i in range(2**D):\n        all_solve = []\n        others = []\n        score = 0\n        cnt = 0\n        for j in range(D):\n            if (i >> j) & 1:\n                all_solve.append(j)\n                cnt += problem[j][0]\n                score += 100 * (j+1) * problem[j][0] + problem[j][1]\n            else:\n                others.append(j)\n        if score >= G:\n            ans = min(cnt,ans)\n            continue\n\n        others.sort(reverse=True)\n        for k in others:\n            for m in range(problem[k][0]):\n                score += 100*(k+1)\n                cnt += 1\n                if score >= G:\n                    ans = min(ans, cnt)\n                    break\n            else:\n                score += problem[k][1]\n                if score >= G:\n                    ans = min(ans, cnt)\n            if score >= G:\n                break\n        \n        if score >= G:\n            ans = min(ans, cnt)\n\n        \n    print(ans)    \n\ndef __starting_point():\n    main()\n__starting_point()", "import itertools\nfrom typing import List, Tuple\n \n \ndef main():\n    d, g = list(map(int, input().split()))\n    v = []\n    for _ in range(d):\n        p, c = list(map(int, input().split()))\n        v.append((p, c))\n \n    print((ag(v, g)))\n \n \ndef ag(v: List[Tuple[int, int]], g: int) -> int:\n    ret = 10 ** 10\n    for comb in itertools.product((False, True), repeat=len(v)):\n        cnt, score = 0, 0\n        for i, bit in enumerate(comb):\n            if bit:\n                score += (i + 1) * 100 * v[i][0] + v[i][1]\n                cnt += v[i][0]\n        if score < g:\n            idx = len(v) - list(reversed(comb)).index(False) - 1\n            add = ((g - score) + ((idx + 1) * 100) - 1) // ((idx + 1) * 100)\n            if add < v[idx][0]:\n                cnt += add\n            else:\n                cnt = 10 ** 10  # impossible\n        ret = min(ret, cnt)\n    return ret\n \n \ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nD,G=map(int,input().split())\npc=[list(map(int,input().split())) for _ in range(D)]\n\ndef solve(bit):\n  if bit >= (1<<D):\n    return 1000\n  p_sum=0\n  num=0\n  \n  for i in range(D):\n    if bit & (1<<i):\n      p_sum += pc[i][1] + pc[i][0] * 100*(i+1)\n      num += pc[i][0]\n  if p_sum >= G:\n    return min(num,solve(bit+1))\n  else:\n    for i in reversed(range(D)):\n      if bit & 1<<i:\n        continue\n      for j in range(pc[i][0]):\n        if p_sum >= G:\n          break\n        p_sum += 100*(i+1)\n        num += 1\n      else:\n        return solve(bit+1)\n    return min(num,solve(bit+1))\n\nprint(solve(0))", "d,g=map(int,input().split())\ng//=100\nA=[]\nfor i in range(d):\n    p,c=map(int,input().split())\n    c//=100\n    A.append([i+1, p, c])\nans=float(\"inf\")\n# print(A)\nfor bit in range(1<<d):\n    now=0 ; mon=0\n    for i in range(d):\n        if bit>>i &1:\n            now+=A[i][0]*A[i][1]+A[i][2]\n            mon+=A[i][1]\n    # print(bit,now,mon)\n    if now>=g:\n        ans=min(ans,mon)\n        continue\n        \n    for i in range(d-1,-1,-1):\n        if bit>>i &1==0:\n            for j in range(A[i][1]): #\u4f59\u308a\u306b\u4f55\u554f\u3068\u304f\u304b\n                now+=A[i][0] ; mon+=1\n                if now>=g:\n                    ans=min(ans,mon)\n                    continue\n                else:\n                    continue\nprint(ans)", "# coding: utf-8\n# Your code here!\nfrom itertools import product\n\nans = 10**9\n\nD, G=list(map(int, input().split())) \nproblem=[list(map(int,list(input().split()))) for i in range(D)]\n\nfor p in product([True, False], repeat=D):\n    \n    point = 0\n    num = 0\n    \n    for i in range(D):\n        if p[i]:\n            point += (i+1) * 100 * problem[i][0] + problem[i][1]\n            num += problem[i][0]\n            \n    if point >= G:\n        ans = min(ans, num)\n    \n    for i in reversed(list(range(D))):\n        if p[i] == False:\n            if point >= G:\n                ans = min(ans, num)\n                break\n            for j in range(problem[i][0]):\n                point += (i+1) * 100\n                num += 1\n                if point >= G:\n                    break\n    if point >= G:\n        ans = min(ans, num)\nprint(ans)\n\n", "D, G = map(int,input().split())\ntable = []\nans = 0\n\nfor i in range(D):\n    p,c = map(int,input().split())\n    ans += p\n    table.append((p,c))\n\n\nfor i in range(2**D):\n    score = 0\n    n = 0\n    solved = [0] * D\n    for j in range(D):\n        if i>>j & 1:\n            p,c = table[j]\n            solved[j] = 1\n            score += 100*(j+1)*p+c\n            n += p\n    if score<G:\n        for k in range(D-1,-1,-1):\n            if solved[k] == 0:\n                p = table[k][0]\n                for l in range(1,p):\n                    score += 100*(k+1)\n                    n += 1\n                    if score>=G:\n                        break\n                break\n\n    if score>=G:\n        ans = min(n,ans)\nprint(ans)", "def cal():\n    d, g = list(map(int, input().split()))\n    a = [list(map(int, input().split())) for i in range(d)]\n    ans = float('inf')\n\n    for i in range(2**d):\n        b = ['-']*d\n        for j in range(d):\n            if (i>>j)&1:\n                b[j] = '+'\n        count0, count1 = 0, 0\n        for j in range(d):\n            if b[j] == '+':\n                count0 += 100*(j+1)*a[j][0]+a[j][1]\n                count1 += a[j][0]\n        if count0 < g:\n            for j in range(d-1, -1, -1):\n                if b[j] == '-':\n                    for k in range(a[j][0]):\n                        if count0 >= g:\n                            break\n                        count0 += 100*(j+1)\n                        count1 += 1\n        ans = min(ans, count1)\n    print(ans)\ncal()\n", "from itertools import product\n\nd, g = list(map(int, input().split()))\ng //= 100\np, c = [], []\nfor _ in range(d):\n    i, j = list(map(int, input().split()))\n    p.append(i)\n    c.append(j // 100)\n\n# full search about complete bonuses\nans = sum(p)\nfor tf in product([True, False], repeat=d):\n    score = 0\n    cnt = 0\n\n    for ind in range(d):\n        if tf[ind]:\n            cnt += p[ind]\n            score += (ind + 1) * p[ind] + c[ind]\n    \n    for ind in range(d-1, -1, -1):\n        if score >= g:\n            break\n\n        if tf[ind]:\n            continue\n        \n        if (ind + 1) * p[ind] + score <= g:\n            cnt += p[ind]\n            score += (ind + 1) * p[ind]\n        else:\n            cnt += (g - score - 1) // (ind + 1) + 1\n            score = g\n    \n    if score >= g and ans > cnt:\n        ans = cnt\n\nprint(ans)\n", "d,g = map(int,input().split())\npc = list(list(map(int, input().split())) for _ in range(d))\nans = float(\"inf\")\n\nfor i in range(1<<d):\n    score = 0\n    cnt = 0\n    nokori = set(range(1, d+1))\n    \n    for j in range(d):\n        if i>>j &1:\n            score += (j+1)*pc[j][0]*100+pc[j][1]\n            cnt += pc[j][0]\n            nokori.discard(j+1)\n            \n    if score < g:\n        use = max(nokori)\n        n = min(pc[use-1][0], -(-(g-score)//(use*100))) # (g-sum)//(use*100)\uff1e0\n        cnt += n\n        score += n*use*100\n    if score >= g:\n        ans = min(ans, cnt)\nprint(ans)", "import math\nd,g = list(map(int,input().split()))\nprob = []\nfor i in range(d):\n  p,c = list(map(int,input().split()))\n  prob.append([p,c,p*(i+1)*100+c])\n  \nmindays = 10**9\nfor i in range(2**d):\n  point = 0\n  days = 0\n  one = []\n  for j in range(d):\n    if ((i>>j)&1)==0:\n      point += prob[j][2]\n      days += prob[j][0]\n    else:\n      one.append(j+1)\n  if point>=g:\n    mindays = min(mindays,days)\n  elif point<g:\n    for k in range(len(one)):\n        day =days\n        tmp = math.ceil((g-point)/(one[k]*100))\n        if tmp<=prob[one[-1]-1][0]:\n          day += tmp\n          mindays = min(mindays,day)\nprint(mindays)\n", "#!/usr/bin/env python3\nimport itertools\nimport math\n\nd, g = list(map(int, input().split()))\npc = [list(map(int, input().split())) for i in range(d)]\n\n\nans = 100*d*100\nfor d in itertools.product([0, 1], repeat=d):\n    ans_tmp = 0\n    value = 0\n\n    for i, j in enumerate(d):\n        if j == 0:\n            continue\n        ans_tmp += pc[i][0]\n        value += (i+1)*100*pc[i][0] + pc[i][1]\n\n    iter_ = [[i, j] for i, j in enumerate(d)]\n    # print(iter_)\n    for i, j in reversed(iter_):\n        if j == 1:\n            continue\n        base = (i+1)*100\n\n        shortage = g-value\n        if g-value <= 0:\n            break\n\n        num = min(math.ceil(shortage/base), pc[i][0]-1)\n        ans_tmp += num\n        value += base*num\n    # print(d)\n    # print(value, ans_tmp)\n    if value >= g:\n        ans = min(ans, ans_tmp)\n\nprint(ans)\n", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\nans = 100*11\nfor i in range(2**d):\n    sum = 0\n    cnt = 0\n    a = []\n    for j in range(d):\n        if (i >> j) & 1 == 1:\n            sum += (j+1)*100*pc[j][0] + pc[j][1]\n            cnt += pc[j][0]\n            a.append(j)\n    if sum < g:\n        for j in range(d):\n            if d-j-1 not in a:\n                for k in range(pc[d-j-1][0]):\n                    if sum >= g:\n                        break\n                    sum += (d-j)*100\n                    cnt += 1\n    ans = min(ans, cnt)\nprint(ans)", "d,g = map(int,input().split())\np,c = [],[]\nans = 1<<32\nfor i in range(d):\n    x,y = map(int,input().split())\n    p.append(x)\n    c.append(y)\nfor i in range(1<<d):\n    cnt = 0\n    tmp = 0\n    for j in range(d):\n        if i&(1<<j):\n            tmp+=(j+1)*100*p[j]+c[j]\n            cnt+=p[j]\n    if tmp<g:\n        for j in range(d-1,-1,-1):\n            if i&(1<<j)==0:\n                for k in range(p[j]):\n                    if tmp>=g:\n                        break\n                    tmp+=(j+1)*100\n                    cnt+=1\n                else:\n                    tmp+=c[j]\n    ans = min(cnt,ans)\nprint(ans)", "d,g=map(int,input().split())\nT=[]\nfor _ in range(d):\n  p,c=map(int,input().split())\n  T.append([p,c])\n\nans=float('inf')\nfor i in range(1<<d):\n  Q=[]\n  cnt=0\n  score=0\n  for j in range(d):\n    if (i>>j)&1:\n      Q.append(j)\n  for v in Q:\n    score+=100*(v+1)*(T[v][0])+T[v][1]\n    cnt+=T[v][0]\n  if score>=g:\n    ans=min(ans,cnt)\n  else:\n    for i in range(d-1,-1,-1):\n      if i in Q:\n        continue\n      if score>=g:\n        continue\n      rest=T[i][0]\n      while rest:\n        if score>=g:\n          break\n        score+=100*(i+1)\n        rest-=1\n        cnt+=1\n    ans=min(ans,cnt)\nprint(ans)      ", "# -*- coding: utf-8 -*-\n# \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\nimport math\n\n# \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\nD, G = list(map(int, input().split()))\np, c = [], []\nfor i in range(D):\n    p_i, c_i = list(map(int, input().split()))\n    p.append(p_i)\n    c.append(c_i)\n\n# \u6c42\u89e3\u51e6\u7406\nans = sum(p)\nfor bit in range(2 << D):\n    d = 0\n    cnt = 0\n    score = 0\n    for i in range(D):\n        if (bit >> i) & 1:\n            cnt += p[i]\n            score += 100 * (i + 1) * p[i] + c[i]\n        else:\n            d = i\n    if score < G:\n        cnt_d = min(math.ceil((G - score) / (100 * (d + 1))), p[d] - 1)\n        cnt += cnt_d\n        score += 100 * (d + 1) * cnt_d\n\n    if score >= G:\n        ans = min(ans, cnt)\n\n# \u7d50\u679c\u51fa\u529b\nprint(ans)\n", "D,G = list(map(int,input().split()))\npc = []\nfor i in range(D):\n    pc.append(list(map(int,input().split())))\n\nscoreList = [0 for i in range(D)]\n\nfor i in range(D):\n    scoreList[i] = (i + 1) * 100 * pc[i][0] + pc[i][1]\n\nchoiceList = [[] for i in range(2 ** D)]\nfor i in range(2 ** D):\n    for j in range(D):\n        choiceList[i].append(i // (2 ** j) % 2)\n\nminCount = 10 ** 8\nfor choice in choiceList:\n    score = 0\n    count = 0\n    for i in range(len(choice)):\n        if choice[i] == 1:\n            score += scoreList[i]\n            count += pc[i][0]\n    for j in range(D):\n        countTmp = count\n        extraScore = (j + 1) * 100 * pc[j][0]\n        delta = G - score\n        if delta < 0:\n            countTmp = count\n        elif delta == 0:\n            countTmp = count\n        elif delta > 0:\n            if delta <= extraScore and choice[j] == 0:\n                countTmp += delta // ((j + 1) * 100)\n                if delta % ((j + 1) * 100) > 0:\n                    countTmp += 1\n            else:\n                countTmp = 10 ** 8\n        if countTmp < minCount:\n            minCount = countTmp\nprint(minCount)", "# \u307e\u3060\u89e3\u3044\u3066\u306a\u3044\u914d\u70b9\u3092 nokori \u3068\u3057\u3066\u6301\u3064\ndef dfs(i, sum, count, nokori):\n    nonlocal ans\n    if i == d:\n        # G \u70b9\u306b\u6e80\u305f\u306a\u3051\u308c\u3070 nokori \u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u3092\u89e3\u304f\n        if sum < g:\n            use = max(nokori)\n            # \u89e3\u304f\u554f\u984c\u304c\u554f\u984c\u6570\u3092\u8d85\u3048\u306a\u3044\u3088\u3046\u306b\u6ce8\u610f\n            n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n            count += n\n            sum += n * use * 100\n\n        if sum >= g:\n            ans = min(ans, count)\n    else:\n        # \u7dcf\u5408\u30b9\u30b3\u30a2\u3001\u89e3\u3044\u305f\u554f\u984c\u6570\u3001\u307e\u3060\u89e3\u3044\u3066\u306a\u3044\u554f\u984c\u3092\u66f4\u65b0\n        dfs(i + 1, sum, count, nokori)\n        dfs(i + 1, sum + pc[i][0] * (i + 1) * 100 + pc[i][1], count + pc[i][0], nokori - {i + 1})\n\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float(\"inf\")\n\ndfs(0, 0, 0, set(range(1, d + 1)))\nprint(ans)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    D, G, *PC = list(map(int, read().split()))\n    P = PC[::2]\n    C = PC[1::2]\n\n    ans = INF\n    for mask in range(1 << D):\n        problems = score = 0\n        for i in range(D):\n            if mask & (1 << i):\n                problems += P[i]\n                score += 100 * (i + 1) * P[i] + C[i]\n            else:\n                idx_max = i\n\n        if score >= G:\n            if ans > problems:\n                ans = problems\n            continue\n\n        if score + 100 * (idx_max + 1) * (P[idx_max] - 1) >= G:\n            problems += (G - score + 100 * (idx_max + 1) - 1) // (100 * (idx_max + 1))\n            if ans > problems:\n                ans = problems\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(D, G, pc):\n    point_map = []\n    point_sum = []\n    for i in range(D):\n        p, c = pc[i]\n        tmp = [100 * (i + 1)] * p\n        tmp[-1] += c\n        point_map.append(tmp)\n        point_sum.append(sum(tmp))\n\n    ans = 100 * 11\n    for i in range(2 ** D):\n        count = 0\n        point = 0\n        other_problems = []\n        for j in range(D):\n            if i >> j & 1:\n                count += pc[j][0]\n                point += point_sum[j]\n            else:\n                other_problems = point_map[j][:-1] + other_problems\n        if point < G:\n            for op in other_problems:\n                count += 1\n                point += op\n                if point >= G:\n                    break\n        if point >= G:\n            ans = min(ans, count)\n    print(ans)\n\n\ndef __starting_point():\n    D, G = list(map(int, input().split()))\n    pc = [[int(i) for i in input().split()] for _ in range(D)]\n    solve(D, G, pc)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "d,g = map(int,input().split())\np,c = [],[]\nans = float('inf')\nfor i in range(d):\n    x,y = map(int,input().split())\n    p.append(x)\n    c.append(y)\nfor i in range((1<<d)):\n    tmp,cnt = 0,0\n    for j in range(d):\n        if i&(1<<j):\n            tmp = tmp + 100*(j+1)*p[j]+c[j]\n            cnt += p[j]\n    if tmp>=g:\n        if cnt<ans: ans=cnt\n    else:\n        for j in range(d-1,-1,-1):\n            if i&(1<<j): continue\n            for k in range(p[j]):\n                if tmp>=g: break\n                tmp = tmp + 100*(j+1)\n                cnt+=1\n        if cnt<ans: ans = cnt\nprint(ans)", "import sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    D, G, *PC = list(map(int, read().split()))\n    P = PC[::2]\n    C = PC[1::2]\n\n    ans = INF\n    for mask in range(1 << D):\n        problems = score = 0\n        available = [False] * D\n        for i in range(D):\n            if mask & (1 << i):\n                problems += P[i]\n                score += 100 * (i + 1) * P[i] + C[i]\n            else:\n                available[i] = True\n\n        if score >= G:\n            if ans > problems:\n                ans = problems\n            continue\n\n        for i in range(D - 1, -1, -1):\n            if not available[i]:\n                continue\n            if score + 100 * (i + 1) * P[i] + C[i] < G:\n                problems += P[i]\n                score += 100 * (i + 1) * P[i] + C[i]\n            else:\n                n = (G - score + 100 * (i + 1) - 1) // (100 * (i + 1))\n                problems += n\n                score += 100 * (i + 1) * n\n                break\n\n        if score >= G and ans > problems:\n            ans = problems\n\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(D: int, G: int, p: \"List[int]\", c: \"List[int]\"):\n    from itertools import product, compress\n    from math import ceil\n    def f():\n        for selectors in product([True, False], repeat=D):\n            n, g = 0, G\n            for i, (pp, cc) in compress(enumerate(zip(p, c), 1), selectors):\n                n += pp\n                g -= i * 100 * pp + cc\n            for i in range(D, 0, -1):\n                if selectors[i-1]:\n                    continue\n                if g <= 0:\n                    break\n                nn = min(p[i-1], ceil(g / i / 100))\n                n += nn\n                g -= nn * i * 100\n            yield n\n    return min(f())\n                \n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    D = int(next(tokens))  # type: int\n    G = int(next(tokens))  # type: int\n    p = [int()] * (D)  # type: \"List[int]\"\n    c = [int()] * (D)  # type: \"List[int]\"\n    for i in range(D):\n        p[i] = int(next(tokens))\n        c[i] = int(next(tokens))\n    print((solve(D, G, p, c)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d + 1))\n\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            count += pc[i][0]\n            nokori.discard(i + 1)\n\n    # G \u70b9\u306b\u6e80\u305f\u306a\u3051\u308c\u3070 nokori \u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u3092\u89e3\u304f\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n        count += n\n        sum += n * use * 100\n\n    if sum >= g:\n        ans = min(ans, count)\n\nprint(ans)", "d, gl = map(int, input().split())\np = []\ng = []\nfor i in range(d):\n  P,G = map(int, input().split())\n  p.append(P)\n  g.append(G)\nans = sum(p)\nfor i in range(1<<d):\n  tmp = 0\n  c = 0\n  b = [0 for i in range(d)]\n  for j in range(d):\n    if i&(1<<j):\n      tmp += g[j] + (j+1)*p[j]*100\n      c += p[j]\n      b[j] = 1\n  s = d-1\n  while tmp < gl and s >= 0:\n    if b[s] == 1:\n      s -= 1\n    else:\n      for k in range(p[s]):\n        tmp += 100*(s+1)\n        c += 1\n        if tmp >= gl:\n          break\n      s -= 1\n  if tmp >= gl:\n    ans = min(ans,c)\nprint (ans)", "D, G = map(int, input().split())\n\nP = []\nC = []\n\nfor i in range(D):\n    p,c = map(int,input().split())\n    P.append(p)\n    C.append(c)\n\nans = 1000\nfor i in range(2**D):\n    point = 0\n    num = 0\n    unsolved = []\n    for j in range(D):\n        if (i >> j)&1 == 1:\n            point += 100*(j + 1)*P[j] + C[j]\n            num += P[j]\n        \n        else:\n            unsolved.append(j)\n\n    if G <= point:\n        ans = min(num, ans)\n    \n    \n    else:\n        l = []\n        unsolved.reverse()\n        for i in unsolved:\n            l += [100*(i + 1)]*(P[i] - 1)\n        for j in range(len(l)):\n            point += l[j]\n            num += 1\n\n            if G <= point:\n                ans = min(num, ans)\nprint(ans)", "\"\"\"\n\u4e2d\u9014\u534a\u7aef\u306b\u3068\u304f\u554f\u984c\u306f\u4e00\u7a2e\u985e\u306e\u307f\u3067\u826f\u3044\u3002\n\u5168\u63a2\u7d22\u3067\u5168\u3066\u306e\u70b9\u6570\u5e2f\u306b\u3064\u3044\u3066\u3001\u30dc\u30fc\u30ca\u30b9\u3092\u3068\u308b\u304b\u30fb\u4e00\u554f\u3082\u3068\u304b\u306a\u3044\u304b\u3067\u5168\u63a2\u7d22\n\u3082\u3057\u70b9\u304cG\u306b\u6e80\u305f\u306a\u3044\u5834\u5408\u306f\u4e00\u756a\u70b9\u304c\u9ad8\u3044\u3082\u306e\u3092\u89e3\u304f\u3002\n\"\"\"\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << d):  #2^d\u901a\u308a\u8a66\u3059\n    count = 0\n    sum = 0\n    rest = list(range(1, d + 1))  #\u4e00\u554f\u3082\u89e3\u3044\u3066\u3044\u306a\u3044\u70b9\u6570\u5e2f\u306e\u96c6\u5408\n\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            count += pc[i][0]\n            rest.remove(i + 1)\n\n    # G \u70b9\u306b\u6e80\u305f\u306a\u3051\u308c\u3070 nokori \u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u3092\u89e3\u304f\n    if sum < g:\n        use = max(rest)\n        n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))  ##\u5168\u90e8\u89e3\u3044\u3066\u3082\u8db3\u308a\u306a\u3044\u304b\u3082\u3057\u308c\u306a\u3044\u3002-(-a//b))\u3067\u5207\u308a\u4e0a\u3052\u3092\u3057\u3066\u3044\u308b\u3002\n        count += n\n        sum += n * use * 100\n\n    if sum >= g:\n        ans = min(ans, count)\n\nprint(ans)", "from itertools import product\nmax2 = lambda x,y: x if x > y else y\nmin2 = lambda x,y: x if x < y else y\n\nD,G = list(map(int,input().split()))\n\npc = [tuple(map(int,input().split())) for _ in range(D)]\npc = [(p,c,100*i) for i,(p,c) in enumerate(pc, start=1)]\nres = sum(p for p,c,k in pc)\nfor choice in product((True,False),repeat=D):\n    t = sum(c+p*k for (p,c,k),f in zip(pc,choice) if f)\n    steps = sum(p for (p,c,k),f in zip(pc,choice) if f)\n\n    if t >= G:\n        res = min2(res,steps)\n        continue\n\n    for (p,c,k),f in zip(reversed(pc), reversed(choice)):\n        if not f:\n            break\n\n    if p*k+t >= G:\n        steps += (G-t-1)//k + 1\n        res = min2(res,steps)\n\nprint(res)\n", "D, G = map(int,input().split())\npc = [list(map(int,input().split())) for i in range(D)]\n\nans = float(\"inf\")\nfor bit in range(1 << D):\n    cnt = 0\n    sum = 0\n    remain = set(range(1,D+1))\n\n    for i in range(D):\n        if bit & (1 << i):\n            cnt += pc[i][0]\n            sum += pc[i][0]*(i+1)*100 + pc[i][1]\n            remain.discard(i+1)\n\n    if sum < G:\n        use = max(remain)\n        n = min(pc[use-1][0],-(-(G - sum)//(use*100)))\n        cnt += n\n        sum += n*use*100\n\n    if sum >= G:\n        ans = min(ans,cnt)\n\nprint(ans)", "D, G = [int(x) for x in input().split()]\nP, C = [], []\nfor _ in range(D):\n    p, c = [int(x) for x in input().split()]\n    P.append(p)\n    C.append(c)\n\nans = 1000\nfor b in range(2**D):\n    score = 0\n    solve = 0\n    unsolved = []\n    for i in range(D):\n        if (b >> i) & 1:\n            score += C[i] + 100 * (i + 1) * P[i]\n            solve += P[i]\n        else:\n            unsolved.append(i)\n    if G > score:\n        resprbs = []\n        unsolved.reverse()\n        for i in unsolved:\n            resprbs += [100 * (i + 1)] * (P[i] - 1)\n        for j in range(len(resprbs)):\n            score += resprbs[j]\n            solve += 1\n            if G <= score:\n                break\n    if G <= score:\n        ans = min(ans, solve)\n\nprint(ans)", "D,G=map(int,input().split())\nG/=100\nP=[]\nC=[]\nfor _ in range(D):\n    x,y=map(int,input().split())\n    P.append(x)\n    C.append(y//100)\n\nans=10**9\nfor x in range(2**D):\n    cost=0\n    value=0\n    for i in range(D):\n        if (x>>i)%2==1:\n            value += P[i]*(i+1) + C[i]\n            cost += P[i]\n    for i in range(D-1,-1,-1):\n        if value >= G:\n            break\n        elif (x>>i)%2==0:\n            for _ in range(P[i]-1):\n                value += i+1\n                cost += 1\n                if value>=G:\n                    break\n    if value>=G:\n        ans=min(ans,cost)\nprint(ans)", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\ndef completed(ii):\n    return(100 * (ii + 1) * pc[ii][0] + pc[ii][1])\n\ndef items(gg, ii):\n    return((gg + 100 * (ii + 1) - 1) // (100 * (ii + 1)))\n\n\ncount = [0] * (2 ** d)\nmeet = [1] * (2 ** d)\nfor i in range(2 ** d):\n    score = 0\n    cnt = 0\n    for j in range(d):\n        if (i >> j) & 1 == 1:\n            score += completed(j)\n            cnt += pc[j][0]\n\n    if score >= g:\n        count[i] = cnt\n        continue\n    \n    for j in range(d)[::-1]:\n        if (~i >> j) & 1 == 1:\n            if items(g - score, j) < pc[j][0]:\n                tmp = items(g - score, j)\n                cnt += tmp\n                score += 100 * (j + 1) * tmp\n            else:\n                cnt += pc[j][0] - 1\n                score += 100 * (j + 1) * (pc[j][0] - 1)\n        if score >= g:\n            count[i] = cnt\n            break\n\n    if score < g:\n        count[i] = cnt\n        meet[i] = 0\n\nans = sum([pc[s][0] for s in range(d)])\nfor i in range(2 ** d):\n    if meet[i] == 1:\n        ans = min(ans, count[i])\nprint(ans)", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for _ in range(d)]\n\nans = float('inf')\n\nfor i in range(1 << d):\n  count = 0\n  sum = 0\n  nokori = set(range(1, d+1))\n  \n  for j in range(d):\n    if i & (1<<j):\n      sum += pc[j][0] * (j+1) * 100 + pc[j][1]\n      count += pc[j][0]\n      nokori.discard(j+1)\n      \n  if sum < g:\n    use = max(nokori)\n    n = min(pc[use-1][0], -(-(g-sum)//(use*100)))\n    count += n\n    sum += n*use*100\n    \n  if sum >= g:\n    ans = min(ans, count)\n\nprint(ans)", "D, G = map(int, input().split())\nPC = [list(map(int, input().split())) for i in range(D)]\n\n\npoints = []\npatterns = []\n    \ndef flagfun(flag):\n    if len(flag) == D:\n        patterns.append(flag)\n        return\n    \n    flagfun(flag+'0')\n    flagfun(flag+'1')\n    \ndef index_pattern():\n    flagfun('')\n    idxes = []\n    for pattern in patterns:\n        tmp_idx = []\n        for idx, flag in enumerate(pattern):\n            if flag == '1':\n                tmp_idx.append(idx)\n        idxes.append(tmp_idx)\n    return idxes\n\ndef culc_points():\n    for i, scores in enumerate(PC):\n        max_score = (i+1)*scores[0]*100 + scores[1]\n        points.append([scores[0], max_score])\n\nculc_points()\n\nidxes = index_pattern()\ncount = 1000000\n\nfor idx in idxes:\n    tmp_count = 0\n    tmp_score = 0\n    remain_idx = [i for i in range(D)]\n    for i in idx:\n        tmp_count += points[i][0]\n        tmp_score += points[i][1]\n        num_index = remain_idx.index(i)\n        remain_idx.pop(num_index)\n           \n    if tmp_count >= count:\n        continue\n    \n    if tmp_score >= G:\n        count = tmp_count\n        continue\n    \n    max_idx = remain_idx.pop(-1)\n    for i in range(1, points[max_idx][0]):\n        tmp_count += 1\n        tmp_score +=(max_idx+1)*100\n        if tmp_count >= count:\n            break\n            \n        if tmp_score >= G:\n            count = tmp_count\n            break\n\nprint(count)", "def main():\n\tD,G = map(int,input().split())\n\tListPC = [list(map(int,input().split())) for d in range(D)]\n\tans = sum([i[0] for i in ListPC])\n\n\tfor i in range(2**D):\n\t\t# \u70b9\u6570,\u6b63\u89e3\u6570,\u89e3\u3044\u3066\u306a\u3044\u6700\u9ad8\u70b9\u6570idx\n\t\tTempPoint,num,restmax = 0,0,-1\n\t\t# \u5168\u57cb\u3081\u554f\u984c\u52a0\u7b97\n\t\tfor j in range(D):\n\t\t\tif i>>j & 1:\n\t\t\t\tTempPoint += 100*(j+1)*ListPC[j][0]+ListPC[j][1]\n\t\t\t\tnum += ListPC[j][0]\n\t\t\telse:\n\t\t\t\trestmax = max(j,restmax)\n\t\t# \u5408\u683c\u306a\u3089\u66f4\u65b0\n\t\tif TempPoint >= G:\n\t\t\tans = min(num,ans)\n\t\t# \u6700\u9ad8\u554f\u984c\u89e3\u3044\u3066\u5408\u683c\u306a\u3089\u66f4\u65b0\n\t\telif (G - TempPoint) // ((restmax + 1) * 100) <= ListPC[restmax][0]:\n\t\t\tans = min(num + (G - TempPoint - 1) // ((restmax + 1) * 100) + 1, ans)\n\tprint(ans)\n\ndef __starting_point():\n\tmain()\n__starting_point()", "D, G = map(int, input().split())\n\nPC = [list(map(int, input().split())) for _ in range(D)]\n\nans = 10**9\nfor bit in range(2**D):\n    cnt = 0\n    score = 0\n    dic = set(range(D))\n    for i in range(D):\n        if (bit>>i)&1:\n            score += PC[i][0] * 100 * (i+1) + PC[i][1]\n            cnt += PC[i][0]\n            dic.discard(i)\n\n    if score < G:\n        t = max(dic)\n        p, c = PC[t][0], PC[t][1]\n        if (t+1)*100*p+c+score >= G:\n            while p:\n                score += (t+1)*100\n                cnt += 1\n                p -= 1\n                if score >= G:\n                    break\n            ans = min(ans, cnt)\n    else:\n        ans = min(ans, cnt)\nprint(ans)", "d,g=list(map(int,input().split()))\np=[]\nc=[]\nfor i in range(d):\n    P,C=list(map(int,input().split()))\n    p.append(P)\n    c.append(C)\nans=sum(p)\nfor i in range(2**d):\n    z=i\n    x=[]\n    for j in range(d):\n        x.append(z%2)\n        z=z//2\n    po=0\n    m=0\n    for j in range(d):\n        if x[j]==1:\n            po+=100*(j+1)*p[j]+c[j]\n            m+=p[j]\n    q=[[] for j in range(d)] #\u6b8b\u308ap\u3001c\n    s=0\n    for j in range(d):\n        if x[j]==0:\n            q[s].append(100*(j+1))\n            q[s].append(p[j])\n            s+=1\n    q=[q[j] for j in range(d) if q[j]!=[]]\n    q=sorted(q,reverse=True)\n    w=len(q)\n    for j in range(w):\n        q[j][1]-=1\n    if po>=g:\n        ans=min(ans,m)\n    else:\n        for j in range(w):\n            if po+q[j][0]*q[j][1]>=g:\n                m+=(g-po+q[j][0]-1)//q[j][0]\n                ans=min(ans,m)\n                break\n            else:\n                po+=q[j][0]*q[j][1]\n                m+=q[j][1]\nprint(ans)\n", "def ForBaseConvert(Roop,MaxD,Base):\n    if all(type(TT) is int for TT in [Roop,MaxD,Base]):\n        if Base>=2 and MaxD>=1:\n            ConvertN = []\n            while Roop>0:\n                ConvertN.append(Roop%Base)\n                Roop = Roop//Base\n\n            BaseConv = [0]*(MaxD-len(ConvertN))+ConvertN[::-1]\n            BaseSInd = [[] for TB in range(0,Base)]\n            for TB in range(0,Base):\n                BaseSInd[TB] = [SInd for SInd,SNum in enumerate(BaseConv) if SNum==TB]\n            return BaseConv,BaseSInd\n        else:\n            return []\n    else:\n        return []\n\nimport math\nD,G = (int(T) for T in input().split())\nPCList = [[] for TD in range(0,D)]\nMINSolve = 1000\nfor TD in range(0,D):\n    PCList[TD] = [int(T) for T in input().split()]\n\nfor Roop in range(0,2**D):\n    Failed = False\n    BaseConv,BaseSInd = ForBaseConvert(Roop,D,2)\n    Solve = 0\n    Point = 0\n    for TD in range(0,D):\n        if BaseConv[TD]==1:\n            Solve += PCList[TD][0]\n            Point += (100*(TD+1)*PCList[TD][0])+PCList[TD][1]\n    \n    if len(BaseSInd[0])>0:\n        Add = BaseSInd[0][-1]\n        Ned = math.ceil(max(G-Point,0)/(100*(Add+1)))\n        if Ned<=(PCList[Add][0]-1):\n            Solve += Ned\n            Point += 100*(Add+1)*Ned\n     \n    if Point>=G and Solve<MINSolve:\n        MINSolve = Solve\nprint(MINSolve)", "#!/usr/bin/env python3\nimport sys\nfrom itertools import combinations_with_replacement,product\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    D,G=list(map(int, input().split()))\n    problem=[]\n    for i in range(1,D+1):\n        p,c=list(map(int, input().split()))\n        problem.append([i,p,c])\n    ans=10000000\n    for bit in list(product([0,1],repeat=D)):\n        pnum=0\n        nokori=G\n        notcomp=[]\n        for i in range(D):\n            if bit[i]==1:\n                pnum+=problem[i][1]\n                nokori-=problem[i][2]+problem[i][1]*problem[i][0]*100\n            else:\n                notcomp.append(problem[i])\n        while nokori>0 and notcomp:\n            score,p,c=notcomp.pop()\n            if score*(p-1)*100<=nokori:\n                nokori-=score*(p-1)*100\n                pnum+=p-1\n            else:\n                tmp=score*100\n                pnum+=(nokori+tmp-1)//tmp\n                nokori=0\n        if nokori<=0:\n            ans=min(ans,pnum)\n    print(ans)\n    \n\n\ndef __starting_point():\n    main()\n\n\n__starting_point()", "D, G = list(map(int, input().split()))\np = [0] * D\nc = [0] * D\nfor i in range(D):\n    p[i], c[i] = list(map(int, input().split()))\n\nans = 1001\nimport math\nfor i in range(2**D):\n    pp = 0\n    t = 0\n    b = format(i, \"0\" + str(D) + \"b\")\n    #print(b)\n    for j in range(D):\n        pp += (100 * (j + 1) * p[j] + c[j]) * int(b[j])\n        t += p[j] * int(b[j])\n    if pp >= G:\n        ans = min(ans, t)\n        continue\n    for k in range(D-1, -1, -1):\n        if b[k] == \"0\":\n            a = math.ceil((G - pp)//100/(k+1))\n            if a < p[k]:\n                t += a\n                ans = min(ans, t)\n                break\n            else:\n                t += p[k]-1\n                pp += 100* (k + 1) *(p[k] - 1)\n\nprint(ans)\n", "from itertools import accumulate\nfrom itertools import product\n\nD,G = list(map(int, input().split()))\npoints = []\nfor i,_ in enumerate(list(range(D)), 1):\n    P,C = list(map(int, input().split()))\n    point = list(accumulate([100*i] * P))\n    point[-1] += C\n    points.append(point)\n\n# \u4e2d\u9014\u534a\u7aef\u306b\u89e3\u304f\u554f\u984c\u306f1\u554f\u3060\u3051\u3002\u89e3\u304f\u306a\u3089\u9ad8\u5f97\u70b9\u307b\u3069\u826f\u3044\u3002\nans = 1000\nfor completes in product(list(range(2)), repeat=D):\n    solves = 0\n    total = 0\n    ex_points = []\n    for comp, point in zip(completes, points):\n        if comp:\n            total += point[-1]\n            solves += len(point)\n        else:\n            ex_points = point\n\n    # \u76ee\u6a19\u306b\u5c4a\u304b\u306a\u3044\u5834\u5408\u3001\u9ad8\u914d\u70b9\u3092\u8ffd\u52a0\u3067\u89e3\u304f\n    if total < G:\n        for i,p in enumerate(ex_points,1):\n            if total + p >= G:\n                # \u76ee\u6a19\u306b\u5c4a\u3044\u305f\n                solves += i\n                break\n        else:\n            # \u76ee\u6a19\u306b\u5c4a\u304b\u306a\u3044\n            continue\n        \n    ans = min(ans, solves)\n                \nprint(ans)\n", "# \u307e\u3060\u89e3\u3044\u3066\u306a\u3044\u914d\u70b9\u3092 nokori \u3068\u3057\u3066\u6301\u3064\ndef dfs(i, sum, count, nokori):\n    nonlocal ans\n    if i == d:\n        # G \u70b9\u306b\u6e80\u305f\u306a\u3051\u308c\u3070 nokori \u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u3092\u89e3\u304f\n        if sum < g:\n            use = max(nokori)\n            # \u89e3\u304f\u554f\u984c\u304c\u554f\u984c\u6570\u3092\u8d85\u3048\u306a\u3044\u3088\u3046\u306b\u6ce8\u610f\n            n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n            count += n\n            sum += n * use * 100\n\n        if sum >= g:\n            ans = min(ans, count)\n    else:\n        # \u7dcf\u5408\u30b9\u30b3\u30a2\u3001\u89e3\u3044\u305f\u554f\u984c\u6570\u3001\u307e\u3060\u89e3\u3044\u3066\u306a\u3044\u554f\u984c\u3092\u66f4\u65b0\n        dfs(i + 1, sum, count, nokori)\n        dfs(i + 1, sum + pc[i][0] * (i + 1) * 100 + pc[i][1], count + pc[i][0], nokori - {i + 1})\n\n\nd, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float(\"inf\")\n\ndfs(0, 0, 0, set(range(1, d + 1)))\nprint(ans)", "import itertools\nfrom typing import List, Tuple\n\n\ndef main():\n    d, g = list(map(int, input().split()))\n    v = []\n    for _ in range(d):\n        p, c = list(map(int, input().split()))\n        v.append((p, c))\n\n    print((ag(v, g)))\n\n\ndef ag(v: List[Tuple[int, int]], g: int) -> int:\n    # ex. [(3, 500), (5, 800)] -> [(1, 3, 500), (2, 5, 800)]\n    v = [(i + 1, v[i][0], v[i][1]) for i in range(len(v))]\n\n    result = 100 ** 10\n\n    for j in range(len(v) + 1):\n        for cb in itertools.combinations(v, j):\n            sc = 0\n            cnt = 0\n            # calc bonus score\n            for (i, p, c) in cb:\n                sc += i * 100 * p + c\n                cnt += p\n\n            for idx in reversed(list(range(len(v)))):\n                if sc >= g:\n                    break\n                if v[idx] in cb:\n                    continue\n                i, p, _ = v[idx]\n                for _ in range(p - 1):\n                    if sc >= g:\n                        break\n                    sc += i * 100\n                    cnt += 1\n\n            if sc >= g:\n                result = min(result, cnt)\n    return result\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# -*- coding: utf-8 -*-\n# \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30a4\u30f3\u30dd\u30fc\u30c8\nimport math\n\n\ndef get_input() -> tuple:\n    \"\"\"\n    \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\u3059\u308b.\n\n    Returns:\\n\n        tuple: \u6a19\u6e96\u5165\u529b\n    \"\"\"\n    D, G = list(map(int, input().split()))\n    p, c = [], []\n    for i in range(D):\n        p_i, c_i = list(map(int, input().split()))\n        p.append(p_i)\n        c.append(c_i)\n\n    return D, G, p, c\n\n\ndef main(D: int, G: int, p: list, c: list) -> None:\n    \"\"\"\n    \u30e1\u30a4\u30f3\u51e6\u7406.\n\n    Args:\\n\n        D (int): \u96e3\u6613\u5ea6\u306e\u6570(1 <= D <= 10)\n        G (int): \u76ee\u6a19\u30b9\u30b3\u30a2(100 <= G, 100\u306e\u500d\u6570)\n        p (list): \u554f\u984c\u6570(1 <= p_i <= 100)\n        c (list): \u30b3\u30f3\u30d7\u30ea\u30fc\u30c8\u30dc\u30fc\u30ca\u30b9(100 <= c_i <= 10^6, 100\u306e\u500d\u6570)\n    \"\"\"\n    # \u6c42\u89e3\u51e6\u7406\n    ans = sum(p)\n    for bit in range(2 << D):\n        d = 0\n        cnt = 0\n        score = 0\n        for i in range(D):\n            if (bit >> i) & 1:\n                cnt += p[i]\n                score += 100 * (i + 1) * p[i] + c[i]\n            else:\n                d = i\n        if score < G:\n            cnt_d = min(math.ceil((G - score) / (100 * (d + 1))), p[d] - 1)\n            cnt += cnt_d\n            score += 100 * (d + 1) * cnt_d\n\n        if score >= G:\n            ans = min(ans, cnt)\n\n    # \u7d50\u679c\u51fa\u529b\n    print(ans)\n\n\ndef __starting_point():\n    # \u6a19\u6e96\u5165\u529b\u3092\u53d6\u5f97\n    D, G, p, c = get_input()\n\n    # \u30e1\u30a4\u30f3\u51e6\u7406\n    main(D, G, p, c)\n\n__starting_point()", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = 100000000000000\n\nfor bit in range(1 << d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d + 1))\n\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            count += pc[i][0]\n            nokori.discard(i + 1)\n\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n        count += n\n        sum += n * use * 100\n\n    if sum >= g:\n        ans = min(ans, count)\n\nprint(ans)", "d,g=[int(_) for _ in input().split()]\nl=[0]+[list(map(int,input().split())) for _ in  range(d)]\ndef f(i,g):\n\tif i==0:return 10**9\n\tc=min(g//(100*i),l[i][0])\n\ts=100*i*c\n\tif c==l[i][0]:s+=l[i][1]\n\tif s<g:\n\t\tc+=f(i-1,g-s)\n\treturn min(c,f(i-1,g))\nprint(f(d,g))", "import copy\n\nfrom typing import List, Tuple\n\n\ndef main():\n    d, g = list(map(int, input().split()))\n    v = []\n    for _ in range(d):\n        p, c = list(map(int, input().split()))\n        v.append((p, c))\n\n    print((ag(v, g)))\n\n\ndef ag(v: List[Tuple[int, int]], g: int) -> int:\n    # ex. [(3, 500), (5, 800)] -> [(1, 3, 500), (2, 5, 800)]\n    v = [(i, p, c) for i, (p, c) in enumerate(v, 1)]\n\n    result = 100 ** 10\n    for j in range(2 ** len(v)):\n        cb = []\n        for k in range(len(v)):\n            if ((j >> k) & 1):\n                cb.append(v[k])\n\n        sc = 0\n        cnt = 0\n        # calc bonus score\n        for (i, p, c) in cb:\n            sc += i * 100 * p + c\n            cnt += p\n\n        for idx in reversed(list(range(len(v)))):\n            if sc >= g:\n                break\n            if v[idx] in cb:\n                continue\n            i, p, _ = v[idx]\n            for _ in range(p - 1):\n                if sc >= g:\n                    break\n                sc += i * 100\n                cnt += 1\n\n        if sc >= g:\n            result = min(result, cnt)\n    return result\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,k = map(int,input().split())\nL = []\nfor i in range(n):\n    a,b = map(int,input().split())\n    L.append([(i+1)*100,a,b])\n#print(L)\nans = 10**10\nif k < L[-1][0]*L[-1][1]:\n    if k%L[-1][0] != 0:\n        ans = (k//L[-1][0]+1)\n    else:\n        ans = (k//L[-1][0])\n\nfor i in range(1<<n):\n    li = []\n    score,score_zan,cnt = 0,0,0\n    for j in range(n):\n        if i>>j&1:\n            score +=(L[j][0]*L[j][1] + L[j][2])\n            cnt +=L[j][1]\n            score_zan = k-score\n        else:\n            li.append(L[j])\n    if score > 0 and score_zan <= 0:\n        ans = min(ans,cnt)\n    li.sort(reverse = True)\n    #print(score,li,cnt,score_zan)\n    if li and score_zan > 0:\n        if score_zan < li[0][0]*li[0][1]:\n            ans = min(ans,cnt + score_zan//li[0][0])\nprint(ans)", "d, g = map(int, input().split())\npc = [list(map(int, input().split())) for i in range(d)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d + 1))\n\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            count += pc[i][0]\n            nokori.discard(i + 1)\n\n    # G \u70b9\u306b\u6e80\u305f\u306a\u3051\u308c\u3070 nokori \u306e\u3046\u3061\u4e00\u756a\u5927\u304d\u3044\u3082\u306e\u3092\u89e3\u304f\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use - 1][0], -(-(g - sum) // (use * 100)))\n        count += n\n        sum += n * use * 100\n\n    if sum >= g:\n        ans = min(ans, count)\n\nprint(ans)", "d, g = list(map(int, input().split()))\npc = [0] + [list(map(int, input().split())) for i in range(d)]\ndef dfs(d_, g_):\n    if d_ == 0:\n        return float(\"inf\")\n    cnt = min(g_ // (d_ * 100), pc[d_][0])\n    cur = cnt * 100 * d_\n    if cnt == pc[d_][0]:\n        cur += pc[d_][1]\n    if g_ > cur:\n        cnt += dfs(d_ - 1, g_ - cur)\n    return min(cnt, dfs(d_ - 1, g_))\nprint((dfs(d, g)))\n", "D,G=list(map(int,input().split()))\np=list()\nc=list()\nfor _ in range(D):\n  P,C=list(map(int,input().split()))\n  p.append(P)\n  c.append(C)\nans=1<<29\nfor bit in range(1<<D):\n  sum_=0\n  num_=0\n  for i in range(D):\n    if bit&(1<<i):\n      sum_+=c[i]+p[i]*100*(i+1)\n      num_+=p[i]\n  if sum_>=G:\n    ans=min(ans,num_);\n  else:\n    for i in range(D-1,-1,-1):\n      if bit&(1<<i):\n        continue\n      for j in range(p[i]):\n        if sum_>=G:\n          break\n        sum_+=100*(i+1)\n        num_+=1\n    ans=min(ans,num_);\nprint(ans)\n"]