["ii = lambda: int(input())\nmi = lambda: map(int, input().split())\nli = lambda: list(mi())\n\nfrom collections import defaultdict as dd\n\nn = ii()\na, b = input().strip(), input().strip()\nda, db = dd(list), dd(list)\nqa, qb = [], []\nfor i in range(n):\n    if a[i] == '?':\n        qa.append(i)\n    else:\n        da[a[i]].append(i)\n    if b[i] == '?':\n        qb.append(i)\n    else:\n        db[b[i]].append(i)\n\nans = []\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    u, v = da[c], db[c]\n    while u and v:\n        ans.append((u.pop(), v.pop()))\n    while u and qb:\n        ans.append((u.pop(), qb.pop()))\n    while v and qa:\n        ans.append((qa.pop(), v.pop()))\nwhile qa and qb:\n    ans.append((qa.pop(), qb.pop()))\n\nprint(len(ans))\nprint(*('%d %d' % (i + 1, j + 1) for i, j in ans), sep='\\n')", "import string\ndef ind(x):\n  sample=list(string.ascii_lowercase)\n  if x==\"?\":\n    return 26\n  else:\n    return sample.index(x)\ndef main():\n  n=int(input())\n  l=input()\n  r=input()\n  l_arr=[[] for x in range(27)]\n  r_arr=[[] for x in range(27)]\n\n  for x in range(n):\n    l_arr[ind(l[x])].append(x+1)\n    r_arr[ind(r[x])].append(x+1)\n  count=0\n  pair=[]\n  for x in range(26):\n    while len(l_arr[x])!=0 and len(r_arr[x])!=0:\n      pair.append((l_arr[x][-1],r_arr[x][-1]))\n      del l_arr[x][-1]\n      del r_arr[x][-1]\n      count+=1\n  for x in range(26):\n    while len(l_arr[-1])!=0 and len(r_arr[x])!=0:\n      pair.append((l_arr[-1][-1],r_arr[x][-1]))\n      del l_arr[-1][-1]\n      del r_arr[x][-1]\n      count+=1\n  for x in range(26):\n    while len(l_arr[x])!=0 and len(r_arr[-1])!=0:\n      pair.append((l_arr[x][-1],r_arr[-1][-1]))\n      del l_arr[x][-1]\n      del r_arr[-1][-1]\n      count+=1\n  for x in range(26):\n    while len(l_arr[-1])!=0 and len(r_arr[-1])!=0:\n      pair.append((l_arr[-1][-1],r_arr[-1][-1]))\n      del l_arr[-1][-1]\n      del r_arr[-1][-1]\n      count+=1\n  print(count)\n  for x in range(count):\n    print(pair[x][0],end=\" \")\n    print(pair[x][1])\n  \n      \nmain()\n", "n = int(input())\nl = input()\nr = input()\nrr = {'?':[]}\nfor i in range(n):\n    if r[i] in rr:\n        rr[r[i]].append(i)\n    else:\n        rr[r[i]] = [i]\nll = []\nfor i in range(n):\n    if l[i] == '?':\n        ll.append(i)\nq = []\nres = []\nfor i in range(n):\n    c = l[i]\n    if c != '?':\n        if c in rr and len(rr[c]):\n            res.append([i, rr[c].pop()])\n        else:\n            if len(rr['?']):\n                res.append([i, rr['?'].pop()])\nfor i in rr:\n    for j in rr[i]:\n        if len(ll):\n            res.append([ll.pop(), j])\nprint(len(res))\nfor i in res:\n    a, b = i\n    print(a + 1, b + 1)\n", "n = int(input())\n\nl = input()\nr = input()\n\nl = sorted(enumerate(l), key=lambda x: x[1])\nl_ = []\nlq = []\nfor pos, c in l:\n\tif c==\"?\":\n\t\tlq.append(pos)\n\telse:\n\t\tl_.append((pos, c))\n\nr = sorted(enumerate(r), key=lambda x: x[1])\nr_ = []\nrq = []\nfor pos, c in r:\n\tif c==\"?\":\n\t\trq.append(pos)\n\telse:\n\t\tr_.append((pos, c))\n\n\npairs = []\ni = j = 0\nwhile i < len(l_) and j < len(r_):\n\tposl, cl = l_[i]\n\tposr, cr = r_[j]\n\n\tif cl == cr:\n\t\tpairs.append((posl, posr))\n\t\ti+=1\n\t\tj+=1\n\telif cl < cr:\n\t\tif rq:\n\t\t\tpairs.append((posl, rq.pop(0)))\n\t\ti += 1\n\telse:\n\t\tif lq:\n\t\t\tpairs.append((lq.pop(0), posr))\n\t\tj += 1\n\nwhile i < len(l_) and rq:\n\tposl, cl = l_[i]\n\tpairs.append((posl, rq.pop(0)))\n\ti+=1\n\nwhile j < len(r_) and lq:\n\tposr, cr = r_[j]\n\tpairs.append((lq.pop(0), posr))\n\tj+=1\n\nfor posl, posr in zip(lq, rq):\n\tpairs.append((posl, posr))\n\nprint(len(pairs))\nfor posl, posr in pairs:\n\tprint(posl+1, posr+1)", "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\nn = mint()\nl = [[] for i in range(27)]\nr = [[] for i in range(27)]\ns = minp()\nfor i in range(n):\n\tif s[i] == '?':\n\t\tl[26].append(i)\n\telse:\n\t\tl[ord(s[i])-ord('a')].append(i)\ns = minp()\nfor i in range(n):\n\tif s[i] == '?':\n\t\tr[26].append(i)\n\telse:\n\t\tr[ord(s[i])-ord('a')].append(i)\nres = [0]*n\nrp = 0\nbest = 0\nfor i in range(26):\n\tfor j in range(min(len(l[i]),len(r[i]))):\n\t\tres[rp] = (l[i].pop()+1, r[i].pop()+1)\n\t\trp += 1\n\t\tbest += 1\nfor i in range(26):\n\twhile len(l[i]) > 0 and len(r[26]) > 0:\n\t\tres[rp] = (l[i].pop()+1, r[26].pop()+1)\n\t\trp += 1\n\t\tbest += 1\nfor i in range(26):\n\twhile len(r[i]) > 0 and len(l[26]) > 0:\n\t\tres[rp] = (l[26].pop()+1, r[i].pop()+1)\n\t\trp += 1\n\t\tbest += 1\ni = 0\nj = 0\nwhile i < 27 or j < 27:\n\tif i < 27 and len(l[i]) == 0:\n\t\ti += 1\n\telif j < 27 and len(r[j]) == 0:\n\t\tj += 1\n\telse:\n\t\tif i == j or i == 26 or j == 26:\n\t\t\tbest += 1\n\t\t\tres[rp] = (l[i].pop()+1, r[j].pop()+1)\n\t\t\trp += 1\n\t\telse:\n\t\t\tl[i].pop()+1\n\t\t\tr[j].pop()+1\nprint(best)\nfor i in range(rp):\n\tprint(*res[i])\n", "n=int(input())\nl=input()\nr=input()\n\nl2=[[l[i],i+1] for i in range(n)]\nr2=[[r[i],i+1] for i in range(n)]\n\nl2.sort(reverse=True)\nr2.sort(reverse=True)\n\nl_i=0\nr_i=0\n\nANS=[]\n\ncheck_l=[0]*n\ncheck_r=[0]*n\nwhile l_i<n and r_i<n and l2[l_i][0]!=\"?\" and r2[r_i][0]!=\"?\":\n    if l2[l_i][0]==r2[r_i][0]:\n        ANS.append([l2[l_i][1],r2[r_i][1]])\n        check_l[l_i]=1\n        check_r[r_i]=1\n        l_i+=1\n        r_i+=1\n    elif l2[l_i][0]>r2[r_i][0]:\n        l_i+=1\n    elif l2[l_i][0]<r2[r_i][0]:\n        r_i+=1\n\nj=0    \nfor i in range(n-1,-1,-1):\n    if l2[i][0]!=\"?\":\n        break\n    if check_l[i]==1:\n        continue\n    while check_r[j]==1:\n        j+=1\n    ANS.append([l2[i][1],r2[j][1]])\n    check_l[i]=1\n    check_r[j]=1\n\nj=0    \nfor i in range(n-1,-1,-1):\n    if r2[i][0]!=\"?\":\n        break\n    if check_r[i]==1:\n        continue\n    while check_l[j]==1:\n        j+=1\n    ANS.append([l2[j][1],r2[i][1]])\n    check_l[j]=1\n    check_r[i]=1\n\nprint(len(ANS))\nfor ans in ANS:\n    print(*ans)\n    \n", "n = int(input())\nl = input().strip()\nr = input().strip()\n\ncntl = [[] for x in range(27)]\ncntr = [[] for x in range(27)]\n\nfor i in range(n):\n  if l[i] == '?':\n    cntl[26].append(i)\n  else:\n    cntl[ord(l[i])-ord('a')].append(i)\n\nfor i in range(n):\n  if r[i] == '?':\n    cntr[26].append(i)\n  else:\n    cntr[ord(r[i])-ord('a')].append(i)\n\novrL = []\novrR = []\nr = []\n\nfor i in range(26):\n  to = min(len(cntl[i]), len(cntr[i]))\n  for j in range(min(len(cntl[i]), len(cntr[i]))):\n    r.append((cntl[i][j], cntr[i][j]))\n  ovrL[len(ovrL):] = cntl[i][to:]\n  ovrR[len(ovrR):] = cntr[i][to:]\n\nfor i in range(min(len(ovrL), len(cntr[26]))):\n  r.append((ovrL[i], cntr[26].pop()))\n\nfor i in range(min(len(ovrR), len(cntl[26]))):\n  r.append((cntl[26].pop(), ovrR[i]))\n\nfor i in range(min(len(cntl[26]), len(cntr[26]))):\n  r.append((cntl[26][i], cntr[26][i]))\n\nr = [str(a+1) + \" \" + str(b+1) for a,b in r]\nprint(len(r))\nprint(\"\\n\".join(r))\n", "n = int(input())\ns = input()\nt = input()\nletter_index_s = {}\nletter_index_t = {}\nbase_s = set()\nbase_t = set()\nfor i in set(s):\n    letter_index_s[i] = set()\nfor i in set(t):\n    letter_index_t[i] = set()\nans = []\nfor i in range(n):\n    if s[i] != '?':\n        letter_index_s[s[i]].add(i + 1)\n    else:\n        base_s.add(i + 1)\n    if t[i] != '?':\n        letter_index_t[t[i]].add(i + 1)\n    else:\n        base_t.add(i + 1)\nfor i in letter_index_s:\n    if i in letter_index_t:\n        while len(letter_index_s[i]) and len(letter_index_t[i]):\n            z1 = letter_index_s[i].pop()\n            z2 = letter_index_t[i].pop()\n            ans.append((z1, z2))\nfor i in letter_index_s:\n    for z in letter_index_s[i]:\n        if base_t != set():\n            ans.append((z, base_t.pop()))\n        else:\n            break\nfor i in letter_index_t:\n    for z in letter_index_t[i]:\n        if base_s != set():\n            ans.append((base_s.pop(), z))\n        else:\n            break\nfor a in base_s:\n    if base_t != set():\n        ans.append((a, base_t.pop()))\n    else:\n        break\nprint(len(ans))\nfor i in ans:\n    print(i[0], i[1])", "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\n# prime = 998244353 \nINF = 100_000_000\n# from heapq import heappush, heappop\nfrom collections import defaultdict\nt = 1#int(input())\n# from math import sqrt\n\n\nfor test in range(t):\n    n = int(input())\n    # n,m = (map(int, input().split()))\n    # a = []\n    # for i in range(n):\n    l = input()\n    r = input()\n    # q = (list((map(int, input().split()))))\n    L = defaultdict(list)\n    usedL = [False for i in range(n)]\n    usedR = [False for i in range(n)]\n\n    quesL = []\n    quesR = []\n    for i in range(n):\n        if l[i]==\"?\":\n            quesL.append(i)\n            usedL[i] = True\n        else:\n            L[l[i]].append(i)\n\n    ans = []\n    for i in range(n):\n        if r[i]==\"?\":\n            quesR.append(i)\n            usedR[i] = True\n        else:\n            if len(L[r[i]])>0:\n                tmp = L[r[i]].pop()\n                ans.append((tmp+1, i+1))\n                usedL[tmp] = True\n                usedR[i] = True\n\n    usedL2 = []\n    usedR2 = []\n    for i in range(n):\n        if not usedL[i]:\n            usedL2.append(i)\n        if not usedR[i]:\n            usedR2.append(i)\n\n    while len(quesL)>0 and len(usedR2)>0:\n        ans.append((quesL.pop()+1, usedR2.pop()+1))\n    \n    while len(quesR)>0 and len(usedL2)>0:\n        ans.append((usedL2.pop()+1, quesR.pop()+1))\n\n    while len(quesL)>0 and len(quesR)>0:\n        ans.append((quesL.pop()+1, quesR.pop()+1))\n    \n    print(len(ans))\n    for i in ans:\n        print(i[0], i[1])", "from collections import defaultdict\nn = int(input())\ns = input()\nt = input()\ncol1 = defaultdict(list)\ncol2 = defaultdict(list)\nany1 = []\nany2 = []\na = ord('a')\nfor i in range(n):\n    if s[i] == '?':\n        any1 .append(i)\n    else:\n        col1[ord(s[i]) - a].append(i)\n\nfor i in range(n):\n    if t[i] == '?':\n        any2 .append(i)\n    else:\n        col2[ord(t[i]) - a].append(i)\n\nrec = []\nmo1 = []\nmo2 = []\nfor i in range(26):\n    for j in range(max(len(col1[i]), len(col2[i]))):\n        if j < min(len(col1[i]), len(col2[i])):\n            rec.append((col1[i][j], col2[i][j]))\n        else:\n            if len(col1[i]) > len(col2[i]):\n                mo1.append(col1[i][j])\n            else:\n                mo2.append(col2[i][j])\n\nwhile len(mo1) > 0 and len(any2) > 0:\n    a, b = mo1.pop(), any2.pop()\n    rec.append((a, b))\n\nwhile len(mo2) > 0 and len(any1) > 0:\n    a, b = any1.pop(), mo2.pop()\n    rec.append((a, b))\n\nfor i in range(min(len(any1), len(any2))):\n    rec.append((any1[i], any2[i]))\n\nprint(len(rec))\nfor i, j in rec:\n    print(i + 1, j + 1)", "n = int(input())\nl = input()\nr = input()\nli = [0] * 27\nli2 = [[] for i in range(27)]\nri = [0] * 27\nri2 = [[] for i in range(27)]\nalth = \"qwertyuiopasdfghjklzxcvbnm?\"\nfor i in range(n):\n    i1 = alth.find(l[i])\n    i2 = alth.find(r[i])\n    li[i1] += 1\n    ri[i2] += 1\n    li2[i1] += [i]\n    ri2[i2] += [i]\n    \nfor i in range(27):\n    li2[i] += [len(li2[i]) - 1]\n    ri2[i] += [len(ri2[i]) - 1]\n\nans = [0] * n\nnum = 0\nfor i in range(26):\n    while li2[i][-1] > -1 and ri2[i][-1] > -1:\n        ans[num] = [li2[i][li2[i][-1]],ri2[i][ri2[i][-1]]]\n        num += 1\n        li2[i][-1] -= 1\n        ri2[i][-1] -= 1\n        \nfor i in range(26):\n    while li2[i][-1] > -1 and ri2[-1][-1] > -1:\n        ans[num] = [li2[i][li2[i][-1]],ri2[-1][ri2[-1][-1]]]\n        num += 1\n        li2[i][-1] -= 1\n        ri2[-1][-1] -= 1\n\nfor i in range(26):\n    while li2[-1][-1] > -1 and ri2[i][-1] > -1:\n        ans[num] = [li2[-1][li2[-1][-1]],ri2[i][ri2[i][-1]]]\n        num += 1\n        li2[-1][-1] -= 1\n        ri2[i][-1] -= 1\nwhile li2[-1][-1] > -1 and ri2[-1][-1] > -1:\n        ans[num] = [li2[-1][li2[-1][-1]],ri2[-1][ri2[-1][-1]]]\n        num += 1\n        li2[-1][-1] -= 1\n        ri2[-1][-1] -= 1\nprint(num)\nfor i in range(num):\n    print(ans[i][0] + 1, ans[i][1] + 1)\n", "n = int(input())\n\nleft = [[] for _ in range(27)]\nright = [[] for _ in range(27)]\n\nfor i, c in enumerate(input().strip()):\n    if c == '?':\n        left[26].append(i + 1)\n    else:\n        left[ord(c) - ord('a')].append(i + 1)\nfor i, c in enumerate(input().strip()):\n    if c == '?':\n        right[26].append(i + 1)\n    else:\n        right[ord(c) - ord('a')].append(i + 1)\n\nresult = []\nfor i in range(26):\n    count = min(len(left[i]), len(right[i]))\n    for j in range(count):\n        result.append((left[i][j], right[i][j]))\n\ni = 0\nleft_q = 0\nwhile True:\n    if left_q == len(left[26]) or i == 26:\n        break\n    for j in range(len(left[i]), len(right[i])):\n        result.append((left[26][left_q], right[i][j]))\n        left_q += 1\n        if left_q == len(left[26]):\n            break\n    i += 1\n\ni = 0\nright_q = 0\nwhile True:\n    if right_q == len(right[26]) or i == 26:\n        break\n    for j in range(len(right[i]), len(left[i])):\n        result.append((left[i][j], right[26][right_q]))\n        right_q += 1\n        if right_q == len(right[26]):\n            break\n    i += 1\n\nwhile left_q < len(left[26]) and right_q < len(right[26]):\n    result.append((left[26][left_q], right[26][right_q]))\n    left_q += 1\n    right_q += 1\n\nprint(len(result))\nfor i, j in result:\n    print(i, j)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\nfrom math import factorial\n\ndef main():\n    n = get_int()\n    s1 = list(input())\n    s2 = list(input())\n    li = [[] for _ in range(27)]\n    lj=[[] for _ in range(27)]\n    for index,i in enumerate(s1):\n        if i=='?':\n            li[0].append(index)\n        else:\n            li[ord(i)-ord('a')+1].append(index)\n    for index,i in enumerate(s2):\n        if i=='?':\n            lj[0].append(index)\n        else:\n            lj[ord(i)-ord('a')+1].append(index)\n    #display_2D_list(li)\n    #display_2D_list(lj)\n    res = []\n    for i in range(1,27):\n        while len(li[i])>0 and len(lj[i])>0:\n            #print(li[i],lj[i],i)\n            res.append([li[i].pop()+1,lj[i].pop()+1])\n        if len(li[i])>0:\n            while len(li[i])>0 and len(lj[0])>0:\n               res.append([li[i].pop()+1,lj[0].pop()+1]) \n        elif len(lj[i])>0:\n            while len(lj[i])>0 and len(li[0])>0:\n               res.append([li[0].pop()+1,lj[i].pop()+1])\n    while len(li[0])>0 and len(lj[0])>0:\n        res.append([li[0].pop()+1,lj[0].pop()+1])\n    print(len(res))\n    for li in res:\n        display_list(li)\n\n         \n\n\n\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n = int(input())\n\nl = [x for x in input()]\nr = [x for x in input()]\nL = {}\nR = {}\n\nfor i, e in enumerate(l):\n    i += 1\n    if e in L:\n        L[e].append(i)\n    else:\n        L[e] = [i]\n\nfor i, e in enumerate(r):\n    i += 1\n    if e in R:\n        R[e].append(i)\n    else:\n        R[e] = [i]\n\n\n\nres = []\n\nq = '?'\n\nfor e in L:\n    if e == q:\n        continue\n\n    if e in R:\n        while len(R[e]) and len(L[e]):\n            res.append((L[e].pop(), R[e].pop()))\n\n\nif q in L:\n    for e in R:\n        if e == q:\n            continue\n        while L[q] and R[e]:\n            res.append((L[q].pop(), R[e].pop()))\n\nif q in R:\n    for e in L:\n        while L[e] and R[q]:\n            res.append((L[e].pop(), R[q].pop()))\n\n\nprint(len(res))\nfor e in res:\n    print(*e)\n", "n = int(input())\ns1 = input()\ns2 = input()\na1 = [0 for i in range(26)]\nb1 = [[] for i in range(26)]\na2 = [0 for i in range(26)]\nb2 = [[] for i in range(26)]\nv1 = []\nv2 = []\ncntv1 = 0\nfor i in range(n):\n    if s1[i] == '?':\n        cntv1 += 1\n        v1.append(i)\n    else:\n        a1[ord(s1[i]) - 97] += 1\n        b1[ord(s1[i]) - 97].append(i)\ncntv2 = 0\nfor i in range(n):\n    if s2[i] == '?':\n        cntv2 += 1\n        v2.append(i)\n    else:\n        a2[ord(s2[i]) - 97] += 1\n        b2[ord(s2[i]) - 97].append(i)\ncnt = 0\nc = []\n\nfor i in range(26):\n    while a1[i] > 0 and a2[i] > 0:\n        cnt += 1\n        a1[i] -= 1\n        a2[i] -= 1\n        c.append([b1[i].pop() + 1, b2[i].pop() + 1])\nfor i in range(26):\n    while a1[i] > 0 and cntv2 > 0:\n        cntv2 -= 1\n        a1[i] -= 1\n        cnt += 1\n        c.append([b1[i].pop() + 1, v2.pop() + 1])\nfor i in range(26):\n    while a2[i] > 0 and cntv1 > 0:\n        cntv1 -= 1\n        a2[i] -= 1\n        cnt += 1\n        c.append([v1.pop() + 1, b2[i].pop() + 1])\nif cntv2 != 0 and cntv1 != 0:\n    while cntv2 > 0 and cntv1 > 0:\n        cnt += 1\n        cntv1 -= 1\n        cntv2 -= 1\n        c.append([v1.pop() + 1, v2.pop() + 1])\nprint(cnt)\nfor i in range(len(c)):\n    print(*c[i])\n", "l = int(input())\nle = input().strip()\nri = input().strip()\nla = list(sorted(((y, x) for x, y in enumerate(le)), reverse=True))\nlb = list(sorted(((y, x) for x, y in enumerate(ri)), reverse=True))\n# print(la)\n# print(lb)\ni,j = 0,0\nres = 0\nresp = []\nui, ul = l-1, l-1\nwhile i<=ui and j<=ul:\n\tai, aa = la[i]\n\tbi, bb = lb[j]\n\t# print(ai, bi, i, j)\n\tif ai == bi or ai == '?' or bi == '?':\n\t\tresp.append(\"{} {}\".format(aa+1, bb+1))\n\t\ti+=1\n\t\tj+=1\n\telif ai > bi:\n\t\ti+=1\n\t\tif lb[ul][0] == '?':\n\t\t\tresp.append(\"{} {}\".format(aa+1, lb[ul][1]+1))\n\t\t\tul -= 1\n\telse:\n\t\tj+=1\n\t\tif la[ui][0] == '?':\n\t\t\tresp.append(\"{} {}\".format(la[ui][1]+1, bb+1))\n\t\t\tui -= 1\n\nprint(len(resp))\nfor r in resp:\n\tprint(r)\n", "import string\n\n\nn = int(input())\n\nl = input()\nr = input()\nlefts = [[] for _ in range(256)]\nrights = [[] for _ in range(256)]\n\noq = ord('?')\n\npairs = []\n\nfor i in range(n):\n    lefts[ord(l[i])].append(i+1)\n    rights[ord(r[i])].append(i+1)\n\nq_store = [lefts[oq], rights[oq]]\nq_used = [0, 0]\nfor c in string.ascii_lowercase:\n    oc = ord(c)\n    same_pairs = min(len(lefts[oc]), len(rights[oc]))\n    for i in range(same_pairs):\n        pairs.append((lefts[oc][i], rights[oc][i]))\n\n    if same_pairs == len(rights[oc]):\n        extras = lefts[oc]\n        q_idx = 1\n    else:\n        extras = rights[oc]\n        q_idx = 0\n\n    for i in range(same_pairs, len(extras)):\n        if q_used[q_idx] >= len(q_store[q_idx]):\n            break\n        if q_idx == 0:\n            pairs.append((q_store[q_idx][q_used[q_idx]], extras[i]))\n        else:\n            pairs.append((extras[i], q_store[q_idx][q_used[q_idx]]))\n        q_used[q_idx] += 1\n\nwhile q_used[0] < len(q_store[0]) and q_used[1] < len(q_store[1]):\n    pairs.append((q_store[0][q_used[0]], q_store[1][q_used[1]]))\n    q_used[0] += 1\n    q_used[1] += 1\n\nprint(len(pairs))\nfor pair in pairs:\n    print(*pair)\n", "from collections import deque\nn = int(input())\nl = input()\nr = input()\na = [0 for i in range(0,ord('z')+1)]\nb = [0 for i in range(0,ord('z')+1)]\nc = [deque() for i in range(0,ord('z')+1)]\nd = [deque() for i in range(0,ord('z')+1)]\nfor i in range(len(l)):\n\tif l[i]=='?':\n\t\ta[0]+=1\n\t\tc[0].append(i+1)\n\telse:\n\t\ta[ord(l[i])]+=1\n\t\tc[ord(l[i])].append(i+1)\nfor i in range(len(l)):\n\tif r[i]=='?':\n\t\tb[0]+=1\n\t\td[0].append(i+1)\n\telse:\n\t\tb[ord(r[i])]+=1\n\t\td[ord(r[i])].append(i+1)\nvopra = a[0]\nvoprb = b[0]\nsch = 0\nout = []\nfor i in range(1,len(a)):\n\tsch+=min(a[i],b[i])\n\tsch+=min(voprb,a[i]-min(a[i],b[i]))\n\tfor j in range(min(a[i],b[i])):\n\t\tif min(a[i],b[i])>0:\n\t\t\tout.append([c[i].popleft(),d[i].popleft()])\n\tfor j in range(min(voprb,a[i]-min(a[i],b[i]))):\n\t\tif (min(voprb,a[i]-min(a[i],b[i])))>0:\n\t\t\tout.append([c[i].popleft(),d[0].popleft()])\n\tvoprb-=min(voprb,a[i]-min(a[i],b[i]))\n\tsch+=min(vopra,b[i]-min(a[i],b[i]))\n\tfor j in range(min(vopra,b[i]-min(a[i],b[i]))):\n\t\tif (min(vopra,b[i]-min(a[i],b[i])))>0:\n\t\t\tout.append([c[0].popleft(),d[i].popleft()])\n\tvopra-=min(vopra,b[i]-min(a[i],b[i]))\n\t\nif vopra>0 and voprb>0:\n\tsch+=min(vopra,voprb)\n\tfor j in range(min(vopra,voprb)):\n\t\tif min(vopra,voprb)>0:\n\t\t\tout.append([c[0].popleft(),d[0].popleft()])\nprint(sch)\nfor i in out:\n\tprint(*i)\n\n\t\n\n\t\n", "n = int(input())\na = list(input())\nb = list(input())\nl = dict()\nr = dict()\nfor i in range(n):\n    if a[i] in l:\n        l[a[i]].append(i + 1)\n    else:\n        l[a[i]] = [i + 1]\n\n    if b[i] in r:\n        r[b[i]].append(i + 1)\n    else:\n        r[b[i]] = [i + 1]\n\n# print(l)\n# print(r)\n\nans = []\nfor i in list(l.keys()):\n    if i in r and i != '?':\n        for j in range(min(len(l[i]), len(r[i]))):\n            ans.append(str(l[i].pop()) + ' ' + str(r[i].pop()))\n\np1 = []\nfor i in list(l.keys()):\n    if i != '?':\n        for el in l[i]:\n            p1.append(el)\np2 = []\nfor i in list(r.keys()):\n    if i != '?':\n        for el in r[i]:\n            p2.append(el)\n\nif '?' in l:\n    for i in range(min(len(p2), len(l['?']))):\n        ans.append(str(l['?'].pop()) + ' ' + str(p2.pop()))\nif '?' in r:\n    for i in range(min(len(p1), len(r['?']))):\n        ans.append(str(p1.pop()) + ' ' + str(r['?'].pop()))\nif '?' in r and '?' in l:\n    for i in range(min(len(l['?']), len(r['?']))):\n        ans.append(str(l['?'].pop()) + ' ' + str(r['?'].pop()))\n\nprint(len(ans))\nprint('\\n'.join(ans))\n", "n = int(input())\nl = input()\nr = input()\nlc = [[] for i in range(27)]\nrc = [[] for i in range(27)]\nx = 0\nfor i in l:\n    if i == '?':\n        lc[26].append(x)\n    else:\n        lc[ord(i) - 97].append(x)\n    x += 1\nx = 0\nfor i in r:\n    if i == '?':\n        rc[26].append(x)\n    else:\n        rc[ord(i) - 97].append(x)\n    x += 1\nans = []\nql = []\nqr = []\nfor i in range(26):\n    if len(lc[i]) > len(rc[i]):\n        for t in range(len(lc[i]) - len(rc[i])):\n            ql.append(lc[i].pop())\n    else:\n        for t in range(len(rc[i]) - len(lc[i])):\n            qr.append(rc[i].pop())\n    for j in range(len(lc[i])):\n        ans.append([lc[i].pop(), rc[i].pop()])\nfor i in range(min(len(ql), len(rc[26]))):\n    ans.append([ql.pop(), rc[26].pop()])\nfor i in range(min(len(qr), len(lc[26]))):\n    ans.append([lc[26].pop(), qr.pop()])\nfor i in range(min(len(lc[26]), len(rc[26]))):\n    ans.append([lc[26].pop(), rc[26].pop()])\nprint(len(ans))\nfor i in ans:\n    print(i[0] + 1, i[1] + 1)\n", "\"\"\"\nNTC here\n\"\"\"\nfrom sys import setcheckinterval,stdin\nsetcheckinterval(1000)\n\nfrom collections import defaultdict\n\niin=lambda :int(stdin.readline())\nlin=lambda :list(map(int,stdin.readline().split()))\n\nn=iin()\na=input()\nb=input()\nl=defaultdict(list)\ncntl=defaultdict(int)\nfor i in range(n):\n    l[a[i]].append(i+1)\ncl=len(l['?'])\nleft=defaultdict(list)\nans=[]\nfor i in range(n):\n    if b[i]=='?':left['?'].append(i+1);continue\n    if b[i] in l:\n        if l[b[i]]:\n            ans.append((l[b[i]].pop(),i+1))\n        else:\n            left[b[i]].append(i+1)\n    else:\n        left[b[i]].append(i+1)\ncr=len(left['?'])\nif cl!=0:\n    for i in left:\n        if i=='?':continue\n        if cl<=0:break\n        while left[i] and cl>0:\n            ans.append((l['?'].pop(),left[i].pop()))\n            cl-=1\nif cr!=0:\n    for i in l:\n        if l[i]:\n            while l[i] and cr>0:\n                ans.append((l[i].pop(),left['?'].pop()))\n                cr-=1\nprint(len(ans))\nfor i,j in ans:\n    print(i,j)\n\n\n", "n=int(input())\nl=list(input())\nr=list(input())\nla=[[] for i in range(26)]\nra=[[] for i in range(26)]\nir=[]\nil=[]\nfor i in range(n):\n    if l[i]!='?':\n        la[ord(l[i])-ord('a')].append(i)\n    else:\n        il.append(i)\nfor i in range(n):\n    if r[i]!='?':\n        ra[ord(r[i])-ord('a')].append(i)\n    else:\n        ir.append(i)\nans=[]\nfor i in range(26):\n    while len(la[i])>0 and len(ra[i])>0:\n        x,y=la[i].pop(),ra[i].pop()\n        ans.append([x+1,y+1])\nfor i in range(26):\n    while len(ir)>0 and len(la[i])>0:\n        x,y=la[i].pop(),ir.pop()\n        ans.append([x+1,y+1])\nfor i in range(26):\n    while len(il)>0 and len(ra[i])>0:\n        x,y=il.pop(),ra[i].pop()\n        ans.append([x+1,y+1])\nwhile len(il)>0 and len(ir)>0:\n    x,y=il.pop(),ir.pop()\n    ans.append([x+1,y+1])\nprint(len(ans))\nfor i in ans:\n    print(*i)", "n = int(input())\na = list(input())\nb = list(input())\n\ncnt_a = 0\ncnt_b = 0\nfor i in range(n):\n    if a[i] != \"?\":\n        a[i] = [ord(a[i]), i + 1]\n    else:\n        a[i] = [1000, i + 1]\n        cnt_a += 1\n    if b[i] != \"?\":\n        b[i] = [ord(b[i]), i + 1]\n    else:\n        b[i] = [1000, i + 1]\n        cnt_b += 1\n\na.sort()\nb.sort()\nans = 0\n# print(a)\n# print(b)\n\nj = 0\ni = 0\nused_a = [0] * n\nused_b = [0] * n\nans_m = []\nwhile i < n and j < n:\n    if a[i][0] == b[j][0] and a[i][0] != 1000 and used_a[i] == 0 and used_b[j] == 0:\n        ans_m.append([a[i][1], b[j][1]])\n        used_a[i] = 1\n        used_b[j] = 1\n        ans += 1\n        j += 1\n        i += 1\n    elif a[i][0] > b[j][0]:\n        j += 1\n    else:\n        i += 1\n\n# print(used_a, used_b)\n\n# print(a)\n# print(b)\nprint(min(n, ans + cnt_a + cnt_b))\nfor q in range(ans):\n    print(ans_m[q][0], ans_m[q][1])\nj = 0\n\nfor i in range(n):\n    if a[i][0] == 1000 and used_a[i] == 0:\n        while used_b[j] == 1 and j < n:\n            j += 1\n            if j == n:\n                break\n        if j == n:\n            break\n        if used_b[j] == 0 and used_a[i] == 0:\n            print(a[i][1], b[j][1])\n            used_a[i] = 1\n            used_b[j] = 1\n\nj = 0\n# print(used_a)\n# print(used_b)\nfor i in range(n):\n    if b[i][0] == 1000 and used_b[i] == 0:\n        while used_a[j] == 1 and j < n:\n            j += 1\n            if j == n:\n                break\n        if j == n:\n            break\n        if used_a[j] == 0 and used_b[i] == 0:\n            print(a[j][1], b[i][1])\n            used_a[j] = 1\n            used_b[i] = 1\n", "n = int(input())\nl = input()\nr = input()\n\ns = \"abcdefghijklmnopqrstuvwxyz\"\n\nd1 = {}\nd2 = {}\n\nfor c in s:\n    d1[c] = []\n    d2[c] = []\n\nd1['?'] = []\nd2['?'] = []\n\nfor i in range(n):\n    d1[l[i]].append(i)\n    d2[r[i]].append(i)\n\nansleft = []\nansright = []\n\ncheckedleft = [0 for i in range(n)]\ncheckedright = [0 for j in range(n)]\n\n\nfor j in range(26):\n    let = s[j]\n\n    l1 = list(d1[let])\n    l2 = list(d2[let])\n\n    c1 = len(l1)\n    c2 = len(l2)\n\n    cnt = min(c1,c2)\n\n    i = 0\n    while(i < cnt):\n        ansleft.append(l1[i])\n        ansright.append(l2[i])\n        checkedright[l2[i]] = 1\n        checkedleft[l1[i]] = 1\n        i+=1\n\n\nnonques1 = []\nnonques2 = []\nques1 = list(d1['?'])\nques2 = list(d2['?'])\n\nfor i in range(n):\n    if l[i] != '?' and checkedleft[i] == 0:\n        nonques1.append(i)\n    if r[i] != '?' and checkedright[i] == 0:\n        nonques2.append(i)\n\nj = 0\nk = 0\nfor i in range(len(ques1)):\n    if(ques1[i] != -1):\n        if(j < len(nonques2)):\n            ansleft.append(ques1[i])\n            ansright.append(nonques2[j])\n            nonques2[j] = -1\n            j+=1\n            ques1[i] = -1\n        elif(k < len(ques2)):\n            ansleft.append(ques1[i])\n            ansright.append(ques2[k])\n            ques2[k] = -1\n            k+=1\n            ques1[i] = -1\n\nj = 0\nk = 0\nfor i in range(len(ques2)):\n    if(ques2[i] != -1):\n        if(j < len(nonques1)):\n            ansright.append(ques2[i])\n            ansleft.append(nonques1[j])\n            nonques1[j] = -1\n            j+=1\n            ques2[i] = -1\n        elif(k < len(ques1)):\n            ansright.append(ques2[i])\n            ansleft.append(ques1[k])\n            ques1[k] = -1\n            k+=1\n            ques2[i] = -1\n\nprint(len(ansleft))\nfor i in range(len(ansleft)):\n    print(ansleft[i]+1,ansright[i]+1)", "def main():\n  n = int(input())\n  l = input().strip()\n  r = input().strip()\n  pairs = solve(n, l, r)\n  print(len(pairs))\n  print(\"\\n\".join(\" \".join(str(xx) for xx in x) for x in pairs))\n\ndef solve(n, l, r):\n  from collections import deque\n  answer = deque()\n\n  l_enum_by_color = count([x for x in enumerate(l)])\n  r_enum_by_color = count([x for x in enumerate(r)])\n\n  l_q_list = l_enum_by_color.pop(\"?\") if \"?\" in l_enum_by_color else deque()\n  r_q_list = r_enum_by_color.pop(\"?\") if \"?\" in r_enum_by_color else deque()\n\n  for key in l_enum_by_color:\n    if key not in r_enum_by_color:\n      continue\n    to_take_count = min(len(l_enum_by_color[key]), len(r_enum_by_color[key]))\n    for _ in range(to_take_count):\n      answer.append((l_enum_by_color[key].popleft(), r_enum_by_color[key].popleft()))\n\n  for key in l_enum_by_color:\n    if len(l_enum_by_color[key]) == 0:\n      continue\n    to_take_count = min(len(l_enum_by_color[key]), len(r_q_list))\n    for _ in range(to_take_count):\n      answer.append((l_enum_by_color[key].popleft(), r_q_list.popleft()))\n\n  for key in r_enum_by_color:\n    if len(r_enum_by_color[key]) == 0:\n      continue\n    to_take_count = min(len(r_enum_by_color[key]), len(l_q_list))\n    for _ in range(to_take_count):\n      answer.append((l_q_list.popleft(), r_enum_by_color[key].popleft()))\n\n  for _ in range(min(len(l_q_list), len(r_q_list))):\n    answer.append((l_q_list.popleft(), r_q_list.popleft()))\n\n  return answer\n\ndef count(it):\n  from collections import deque\n  d = {}\n  for a in it:\n    if a[1] in d:\n      d[a[1]].append(a[0]+1)\n    else:\n      d[a[1]] = deque([a[0]+1])\n  return d\n\n\nmain()"]