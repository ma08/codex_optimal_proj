["n = int(input())\na = [int(x) for x in input().split()]\n\nres = {}\n\nfor i in range(n):\n  sm = 0\n  for j in range(i, n):\n    sm += a[j]\n    if sm in res:\n      res[sm].append((i, j))\n    else:\n      res[sm] = [(i, j)]\n\nbest = 0\nbestI = -1\nfor key in res:\n  r = -1\n  cnt = 0\n  for (a,b) in sorted(res[key]):\n    if a > r:\n      cnt += 1\n      r = b\n    elif b < r:\n      r = b\n  if cnt > best:\n    best = cnt\n    bestI = key\n\nx = []\nr = -1\nfor (a, b) in sorted(res[bestI]):\n  if a > r:\n    x.append(str(a+1) + \" \" + str(b+1))\n    r = b\n  elif b < r:\n    r = b\n    x.pop()\n    x.append(str(a+1) + \" \" + str(b+1))\n  \nprint(best)\nprint(\"\\n\".join(x))\n", "from collections import defaultdict\nn = int(input())\na = list(map(int, input().split()))\n\nrec = defaultdict(list)\nfor j in range(n):\n    for k in range(j, n):\n        rec[sum(a[j:k + 1])].append((j, k))\n\nans = []\nfor k in rec.keys():\n    tmp = []\n    rec[k] = sorted(rec[k], key=lambda x: x[1])\n    pre = -1\n    for a, b in rec[k]:\n        if pre >= a:\n            continue\n        else:\n            tmp.append((a + 1, b + 1))\n            pre = b\n    if len(tmp) > len(ans):\n        ans = tmp\n\nprint(len(ans))\nfor a, b in ans:\n    print(a, b)", "# alpha = \"abcdefghijklmnopqrstuvwxyz\"\n# prime = 998244353 \nINF = 100_000_000\n# from heapq import heappush, heappop\nfrom collections import defaultdict\nt = 1#int(input())\n# from math import sqrt\n\n\nfor test in range(t):\n    n = int(input())\n    # H, n = (map(int, input().split()))\n    # a = []\n    # for i in range(n):\n    # l = input()\n    # r = input()\n    a = (list((list(map(int, input().split())))))\n    pre = [0 for i in range(n+1)]\n\n    for i in range(n):\n        pre[i+1] = pre[i]+a[i]\n    \n    Sum = defaultdict(list)\n\n    for i in range(n):\n        for j in range(i, n):\n            tmp = pre[j+1]-pre[i]\n            # print(i,j,tmp)\n            Sum[tmp].append((i,j))\n\n    maxVal = 0\n    maxSum = -1\n    for key, val in list(Sum.items()):\n        val.sort()\n        tmp = 1\n        cur = val[0][1]\n        for i in range(1,len(val)):\n            if val[i][0]>cur:\n                tmp+=1\n                cur = val[i][1]\n            elif val[i][1]<=cur:\n                cur = val[i][1]\n        if maxVal < tmp:\n            maxVal = tmp\n            maxSum = key\n\n    print(maxVal)\n    val = Sum[maxSum]\n    val.sort()\n    ans = []\n    ans.append(val[0])\n    cur = val[0][1]\n    for i in range(1,len(val)):\n        if val[i][0]>cur:\n            ans.append(val[i])\n            cur = val[i][1]\n        elif val[i][1]<=cur:\n            ans.pop()\n            ans.append(val[i])\n            cur = val[i][1]\n    for i in ans:\n        print(i[0]+1, i[1]+1)\n\n\n\n", "n = int(input())\nA = list(map(int, input().split()))\nif n == 1:\n    print(1)\n    print(1, 1)\n    return\nprefA = [0]\nhah = {}\nfor i in A:\n    prefA.append(prefA[-1] + i)\nfor i in range(n):\n    for j in range(i + 1, n + 1):\n        s = prefA[j] - prefA[i]\n        if s not in hah:\n            hah[s] = []\n        hah[s].append([i + 1, j])\n\n\ndef lol(a):\n    return a[1], a[0]\n\n\nansq = 0\nbm = []\nfor s in hah:\n    Q = hah[s]\n    cnt = 0\n    Q.sort(key=lol)\n    ans = []\n    for i in Q:\n        if i[0] > cnt:\n            cnt = i[1]\n            ans.append(i)\n    if ansq < len(ans):\n        ansq = len(ans)\n        bm = ans\nprint(ansq)\nfor i in bm:\n    print(*i)\n", "n = int(input())\nA = list(map(int, input().split()))\nif n == 1:\n    print(1)\n    print(1, 1)\n    return\nprefA = [0]\nhah = {}\nfor i in A:\n    prefA.append(prefA[-1] + i)\nfor i in range(n):\n    for j in range(i + 1, n + 1):\n        s = prefA[j] - prefA[i]\n        if s not in hah:\n            hah[s] = []\n        hah[s].append([i + 1, j])\n\n\ndef lol(a):\n    return a[1], a[0]\n\n\nansq = 0\nbm = []\nfor s in hah:\n    Q = hah[s]\n    cnt = 0\n    Q.sort(key=lol)\n    ans = []\n    for i in Q:\n        if i[0] > cnt:\n            cnt = i[1]\n            ans.append(i)\n    if ansq < len(ans):\n        ansq = len(ans)\n        bm = ans\nprint(ansq)\nfor i in bm:\n    print(i[0], i[1])\n", "def main():\n    n = int(input())\n    A = list(map(int, input().split()))\n    if n == 1:\n        print(1)\n        print(1, 1)\n        return\n    prefA = [0]\n    hah = {}\n    for i in A:\n        prefA.append(prefA[-1] + i)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            s = prefA[j] - prefA[i]\n            if s not in hah:\n                hah[s] = []\n            hah[s].append([i + 1, j])\n\n\n    def lol(a):\n        return a[1], a[0]\n\n\n    ansq = 0\n    bm = []\n    for s in hah:\n        Q = hah[s]\n        cnt = 0\n        Q.sort(key=lol)\n        ans = []\n        for i in Q:\n            if i[0] > cnt:\n                cnt = i[1]\n                ans.append(i)\n        if ansq < len(ans):\n            ansq = len(ans)\n            bm = ans\n    print(ansq)\n    for i in bm:\n        print(i[0], i[1])\n\n\nmain()", "def main():\n    n = int(input())\n    A = list(map(int, input().split()))\n    if n == 1:\n        print(1)\n        print(1, 1)\n        return\n    prefA = [0]\n    hah = {}\n    for i in A:\n        prefA.append(prefA[-1] + i)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            s = prefA[j] - prefA[i]\n            if s not in hah:\n                hah[s] = []\n            hah[s].append([i + 1, j])\n\n\n    def lol(a):\n        return a[1], a[0]\n\n\n    ansq = 0\n    bm = []\n    for s in hah:\n        Q = hah[s]\n        cnt = 0\n        Q.sort(key=lol)\n        ans = []\n        for i in Q:\n            if i[0] > cnt:\n                cnt = i[1]\n                ans.append(i)\n        if ansq < len(ans):\n            ansq = len(ans)\n            bm = ans\n    print(ansq)\n    for i in bm:\n        print(i[0], i[1])\n\n\nmain()", "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nfrom collections import defaultdict\n\n\ndef find_max_non_intersecting(segments):\n    n = len(segments)\n\n    r = -1\n    result = []\n    for i in range(n):\n        a, b = segments[i]\n        if a > r:\n            result.append((a, b))\n            r = b\n\n    return result\n\n\ndef __starting_point():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    s = []\n    for ai in a:\n        s.append((s[-1] if s else 0) + ai)\n\n    d = defaultdict(list)\n    for j in range(n):\n        for i in range(j + 1):\n            d[s[j] - (s[i - 1] if i - 1 >= 0 else 0)].append((i, j))\n\n    vals = []\n    for v in list(d.values()):\n        non_inters = find_max_non_intersecting(v)\n        if len(non_inters) > len(vals):\n            vals = non_inters\n\n    print(len(vals))\n    for l, r in vals:\n        print(l + 1, r + 1)\n\n__starting_point()", "#!/usr/bin/env python3\nfrom collections import defaultdict\n\n\ndef main():\n    n = int(input())\n    a = [int(ai) for ai in input().split()]\n\n    pref_sums = [0] * (n + 1)\n    for i, ai in enumerate(a):\n        pref_sums[i + 1] = pref_sums[i] + ai\n\n    block_sums = defaultdict(list)\n    for j in range(1, n + 1):\n        for i in range(1, j + 1):\n            block_sums[pref_sums[j] - pref_sums[i - 1]].append((i, j))\n\n    ans = []\n    for A in list(block_sums.values()):\n        res, k = [A[0]], 0\n        for i in range(1, len(A)):\n            if A[i][0] > A[k][1]:\n                res.append(A[i])\n                k = i\n\n        if len(res) > len(ans):\n            ans = res\n\n    print(len(ans))\n    print('\\n'.join(['%d %d' % s for s in ans]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\na=list(map(int,input().split()))\ndic={}\nfor i in range(n):\n    sm=0\n    for j in range(i,n):\n        sm+=a[j]\n        if sm in dic:\n            dic[sm].append((i,j))\n        else:\n            dic[sm]=[(i,j)]\nans=0\nanskey=-1\nfor key in dic:\n    cnt=0\n    last=-1\n    for a,b in sorted(dic[key]):\n        if a>last:\n            cnt+=1\n            last=b\n        elif b<last:\n            last=b\n    if cnt>ans:\n        ans=cnt\n        anskey=key\nlast=-1\ntmp=[]\nfor a,b in sorted(dic[anskey]):\n    if a>last:\n        last=b\n        tmp.append(str(a+1)+\" \"+str(b+1))\n    elif b<last:\n        last=b\n        tmp.pop()\n        tmp.append(str(a+1)+\" \"+str(b+1))\nprint(ans,'\\n'.join(tmp),sep='\\n')", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nA=list(map(int,input().split()))\n\nfrom itertools import accumulate\nSUM=list(accumulate(A))\nSUM.append(0)\n\nBLIST=[[0]*n for i in range(n)]\nB2=[]\n\nfor i in range(n):\n    for j in range(i,n):\n        BLIST[i][j]=SUM[j]-SUM[i-1]\n        B2.append(SUM[j]-SUM[i-1])\n\nB2=sorted(set(B2))\nDICT={B2[i]:i for i in range(len(B2))}\nUSED=[-1]*len(B2)\n\nANS=[[] for i in range(len(B2))]\n\nfor i in range(n):\n    for j in range(i+1):\n        x=BLIST[j][i]\n\n        if USED[DICT[x]]<j:\n            ANS[DICT[x]].append([j+1,i+1])\n            USED[DICT[x]]=i\n\nANS0=max(ANS,key=lambda x:len(x))\nprint(len(ANS0))\nfor ans in ANS0:\n    print(*ans)\n        \n        \n", "from collections import defaultdict\nfrom itertools import accumulate\n\nN = int(input())\nH = defaultdict(lambda: [])\nA = list(map(int, input().split()))\nAA = [0] + list(accumulate(A))\nfor i in range(1, N+1):\n    for j in range(i):\n        H[AA[i] - AA[j]].append((i, j)) \nctr = 0\nans = []\nfor L in list(H.values()):\n    if ctr >= len(L):\n        continue\n    L.sort()\n    ansc = []\n    pi = -1\n    for i, j in L:\n        if j >= pi:\n            ansc.append((j+1, i))\n            pi = i\n    if ctr < len(ansc):\n        ans = ansc.copy()\n        ctr = len(ans)\nprint(ctr)\nfor j, i in ans:\n    print(j, i)\n", "franxx = int(input())\n\nlife = input()\nlife = life.split()\n\ndarling = {}\n\noh_pay = \"I love my darling\"\n\nfor i in range(franxx, 0, -1):\n\ttmp = 0\n\tfor j in range(i - 1, franxx):\n\t\ttmp += int(life[j])\n\t\tif (tmp in darling):\n\t\t\tif (darling[tmp][0] > j):\n\t\t\t\tdarling[tmp] = (i - 1, 1 + darling[tmp][1])\n\t\telse:\n\t\t\tdarling[tmp] = (i - 1, 1)\n\t\tif (oh_pay == \"I love my darling\" or darling[tmp][1] > darling[oh_pay][1]):\n\t\t\toh_pay = tmp\n\nprint(darling[oh_pay][1])\n\nstrelizia = (franxx, 0)\n\nfor i in range(franxx, 0, -1):\n\ttmp = 0\n\tfor j in range(i - 1, franxx):\n\t\ttmp += int(life[j])\n\t\tif (tmp != oh_pay):\n\t\t\tcontinue;\n\t\tif (strelizia[0] > j):\n\t\t\tprint(i, j + 1)\n\t\t\tstrelizia = (i - 1, 1 + strelizia[1])", "from collections import defaultdict\nn = int(input())\nnums = list(map(int, input().split()))\nfreq = defaultdict(list)\n\nfor i in range(n):\n\tfor j in range(i+1, n+1):\n\t\tfreq[sum(nums[i:j])].append((i+1, j))\n\nans = []\nfor k in freq:\n\tl = freq[k]\n\tl.sort(key=lambda x: x[1])\n\ttmp = [l[0]]\n\tfor i, j in l:\n\t\tif i <= tmp[-1][1]:\n\t\t\tcontinue\n\t\ttmp.append([i, j])\n\t\n\tif len(tmp) > len(ans):\n\t\tans = tmp\nprint (len(ans))\nfor i, j in ans:\n\tprint (i, j)", "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/21 12:10\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : F2. Same Sum Blocks (Hard).py\n\nfrom collections import defaultdict\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    sum_dict = defaultdict(list)\n    for r in range(n):\n        tmp = 0\n        for l in range(r, -1, -1):\n            tmp += a[l]\n            sum_dict[tmp].append((l + 1, r + 1))\n\n    ret, blocks = 0, []\n    for k, v in list(sum_dict.items()):\n        right, tmp = -1, 0\n        curr_list = []\n        for s in v:\n            if s[0] > right:\n                tmp += 1\n                curr_list.append(s)\n                right = s[1]\n        if tmp > ret:\n            ret = tmp\n            blocks = curr_list\n\n    print(ret)\n    for s in blocks:\n        print(*s)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\n\na=[int(i) for i in input().split()]\n\npref=[0]\n\nd={}\n\nfor x in range(len(a)):\n\tpref.append(pref[x]+a[x])\n\nfor r in range(n):\n\tfor l in range(0,r+1):\n\t\tv=pref[r+1]-pref[l]\n\n\t\tif(v in d):\n\t\t\td[v].append([l,r])\n\t\telse:\n\t\t\td[v]=[[l,r]]\n\nmaxi=-2\n\nmax_set=[]\n\nfor key in d:\n\n\tstart=-1\n\n\ttmp_set=[]\n\n\tctr=0\n\n\tfor e in range(len(d[key])):\n\n\t\tif(d[key][e][0]>start):\n\t\t\ttmp_set.append(d[key][e])\n\t\t\tstart=d[key][e][1]\n\t\t\tctr+=1\n\n\tif(ctr>maxi):\n\t\tmaxi=ctr\n\t\tmax_set=tmp_set\n\nprint(maxi)\nfor w in range(maxi):\n\tprint(max_set[w][0]+1,max_set[w][1]+1)\n\n\n", "from itertools import accumulate\n\nn = int(input())\narr = list(map(int, input().split()))\narr_sums = [0] + list(accumulate(arr))\n\nblocks = {}\nfor i in range(1, n+1):\n    for j in range(i):\n        total = arr_sums[i] - arr_sums[j]\n        if total not in blocks:\n            blocks[total] = [(j+1, i)]\n        else:\n            if blocks[total][-1][1] < j+1:\n                blocks[total].append((j+1, i))\n\nmax_block = sorted([(i, len(x)) for i, x in list(blocks.items())], key=lambda y: (-y[1], y[0]))\nprint(max_block[0][1])\nfor item in blocks[max_block[0][0]]:\n    print(item[0], item[1])\n\n", "def find(v: int, s: int):\n    nonlocal d, a, n\n    left, r = 0, v\n    if s == -5:\n        print('v', v, d[s][v], d[s][:v])\n    while r - left > 1:\n        mid = (left + r) // 2\n        if s == -5 and v == 6:\n            print(d[s][v][0], d[s][mid][1])\n        if d[s][v][0] > d[s][mid][1]:\n            left = mid\n        else:\n            r = mid\n    return left\n\n\nn = int(input())\na = list(map(int, input().split()))\nd = dict()\nfor i in range(n):\n    s = 0\n    for j in range(i, n):\n        s += a[j]\n        if s in d:\n            d[s].append((i + 1, j + 1))\n        else:\n            d[s] = [(i + 1, j + 1)]\nfor i in list(d.keys()):\n    d[i].sort(key=lambda x: x[1])\n\n# print(d)\nar = []\nfor el in list(d.keys()):\n    cur = []\n    r = 0\n    for i in d[el]:\n        if i[0] > r:\n            cur.append(i)\n            r = i[1]\n    if len(ar) < len(cur):\n        ar = cur\n\nprint(len(ar))\nfor i in ar:\n    print(*i)\n", "# import time\ndef index(key, item, index):\n    if key in index:\n        index[key].append(item)\n    else:\n        index[key] = [item]\n\ndef schedule_(times, n):\n    \"A slower implementation.\"\n    d = [None] * (n + 1)\n    for start, end in times:\n        for i in range(start + 1):\n            if d[i] is None or end < d[i][1]:\n                d[i] = (start, end)\n    # print('d:', d)\n    result = []\n    next_ = d[0]\n    while next_:\n        result.append(next_)\n        s = next_[1]\n        next_ = d[s]\n    return result\n\ndef schedule(times):\n    # assume this is true as times.sort(key=lambda x: x[0])\n    # times.sort(key=lambda x: x[1])\n    index_by_b = {}\n    for time in times:\n        index(time[1], time, index_by_b)\n    b_keys = sorted(list(index_by_b.keys()))\n    result = []\n    a_min = 0\n    # Get interval with minimun end time whose start time >= a_min.\n    for end_time in b_keys:\n        start = index_by_b[end_time][-1][0]\n        if start >= a_min:\n            result.append((start, end_time)) \n            a_min = end_time\n    return result\n                \ndef test_schedule():\n    i = [(0, 4), (2, 4), (0, 2), (0, 1), (1, 2), (2, 3), (3, 4)]\n    result = schedule(i)\n    print('len:', len(result))\n    for ele in result:\n        print(ele)\n\ndef solve(n, a_l):\n    index_by_sum = {}\n    # for j in range(1, n + 1):\n        # sum_ = 0\n        # for i in range(j - 1, -1, -1):\n    for i in range(n):\n        sum_ = 0\n        for j in range(i + 1, n + 1):\n            sum_ += a_l[j - 1]\n            # print(i, j, sum_)\n            if sum_ in index_by_sum:\n                index_by_sum[sum_].append((i, j))\n            else:\n                index_by_sum[sum_] = [(i, j)]\n    # print('haha')\n    result = []\n    for sum_, times in index_by_sum.items():\n        # print('Finished sum:', sum_)\n        sub_result = schedule(times)\n        if len(sub_result) > len(result):\n            result = sub_result\n    return result\n\ndef main():\n    n = int(input())\n    a_l = list(map(int, input().split()))\n    # n = 1500\n    # a_l = range(1, n + 1)\n    # tick = time.time()\n    result = solve(n, a_l)\n    print(len(result))\n    for a, b in result:\n        print(a + 1, b)\n    # tock = time.time()\n    # print('T:', round(tock - tick, 5))\n\ndef __starting_point():\n    main()\n__starting_point()", "def index(key, item, index):\n    if key in index:\n        index[key].append(item)\n    else:\n        index[key] = [item]\n\ndef schedule(times):\n    index_by_b = {}\n    for time in times:\n        index(time[1], time, index_by_b)\n    b_keys = sorted(list(index_by_b.keys()))\n    result = []\n    a_min = 0\n    # Get interval with minimun end time whose start time >= a_min.\n    for end_time in b_keys:\n        start = index_by_b[end_time][-1][0]\n        if start >= a_min:\n            result.append((start, end_time)) \n            a_min = end_time\n    return result\n                \ndef solve(n, a_l):\n    index_by_sum = {}\n    for i in range(n):\n        sum_ = 0\n        for j in range(i + 1, n + 1):\n            sum_ += a_l[j - 1]\n            if sum_ in index_by_sum:\n                index_by_sum[sum_].append((i, j))\n            else:\n                index_by_sum[sum_] = [(i, j)]\n    result = []\n    for sum_, times in index_by_sum.items():\n        sub_result = schedule(times)\n        if len(sub_result) > len(result):\n            result = sub_result\n    return result\n\ndef main():\n    n = int(input())\n    a_l = list(map(int, input().split()))\n    result = solve(n, a_l)\n    print(len(result))\n    for a, b in result:\n        print(a + 1, b)\n\ndef __starting_point():\n    main()\n__starting_point()"]