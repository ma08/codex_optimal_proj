["\nalp = \"abcdefghijklmnopqrstuvwxyz\"\n\ndic = {}\nfor i,s in enumerate(alp):\n    dic[s] = i\n\nlis = [0] * 27\n\nn = int(input())\nS = input()\nans = []\n\nfor i,s in enumerate(S):\n\n    ind = dic[s]\n\n    ans.append(max(lis[ind+1:]) + 1)\n\n    lis[ind] = ans[-1]\n\nprint(max(ans))\nprint(\" \".join(map(str,ans)))\n", "n = int(input())\ns = input()\nf = [0 for _ in range(26)]\nres = [1 for _ in range(n)]\nfor i in range(n):\n    c = ord(s[i]) - ord('a')\n    for j in range(c + 1, 26):\n        res[i] = max(res[i], f[j] + 1)\n    f[c] = max(f[c], res[i])\n    \nmaxres = max(res)\nprint(maxres)\nfor i in res:\n    print(i, end = ' ')", "from math import *\nn = int(input())\ns = input()\npre = [0 for i in range(n)]\npre[0] = 1\nprev = s[0]\nlst = [-1 for i in range(26)]\nlst[0] = s[0]\nct = 1\nfor i in range(1,n):\n\tfor j in range(26):\n\t\tif(lst[j] == -1 or lst[j] <= s[i]):\n\t\t\tlst[j] = s[i]\n\t\t\tpre[i] = j+1\n\t\t\tct = max(ct,j+1)\n\t\t\tbreak\n\nprint(ct)\nfor i in pre:\n\tprint(i,end = \" \")\n", "n = int(input())\na = list([ord(c)-97 for c in input()])\ncolor = [0]*26\nans = [0]*n\nlast = -1\n\nfor i, c in enumerate(a):\n    col = 0\n    if last <= c:\n        last = c\n        if color[c] == 0:\n            col = 1\n        else:\n            col = color[c] & (-color[c])\n    else:\n        col = 1\n        for j in range(last, c, -1):\n            while col & color[j]:\n                col <<= 1\n\n    color[c] |= col\n    ans[i] = len(bin(col)) - 2\n\nprint(max(ans))\nprint(*ans)\n", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nclass SegmentTree:\n    def __init__(self, a):\n        # Operator\n        self.op = lambda a, b : max(a, b)\n        # Identity element\n        self.e = 0 \n\n        self.n = len(a)\n        self.lv = (self.n - 1).bit_length()\n        self.size = 2**self.lv\n        self.data = [self.e] * (2*self.size - 1)\n        # Bisect checking function \n        self._check = lambda x, acc : acc >= x\n        self._acc = self.e\n\n        self.initialize(a)\n\n    # Initialize data\n    def initialize(self, a):\n        for i in range(self.n):\n            self.data[self.size + i - 1] = a[i]\n        for i in range(self.size-2, -1, -1):\n            self.data[i] = self.op(self.data[i*2 + 1], self.data[i*2 + 2])\n\n    # Update ak as x (0-indexed)\n    def update(self, k, x):\n        k += self.size - 1\n        self.data[k] = x\n        while k > 0:\n            k = (k - 1) // 2\n            self.data[k] = self.op(self.data[2*k+1], self.data[2*k+2])\n\n    # Min value in [l, r) (0-indexed)\n    def fold(self, l, r):\n        L = l + self.size; R = r + self.size\n        s = self.e\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.op(s, self.data[R-1])\n            if L & 1:\n                s = self.op(s, self.data[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\n    def _bisect_forward(self, x, start, k):\n        # When segment-k is at the bottom, accumulate and return.\n        if k >= self.size - 1:\n            self._acc = self.op(self._acc, self.data[k])\n            if self._check(x, self._acc):\n                return k - (self.size - 1)\n            else:\n                return -1\n        width = 2**(self.lv - (k+1).bit_length() + 1)\n        mid = (k+1) * width + width // 2 - self.size \n        # When left-child isn't in range, just look at right-child. \n        if mid <= start:\n            return self._bisect_forward(x, start, 2*k + 2)\n        # When segment-k is in range and has no answer in it, accumulate and return -1\n        tmp_acc = self.op(self._acc, self.data[k])\n        if start <= mid - width // 2 and not self._check(x, tmp_acc):\n            self._acc = tmp_acc\n            return -1\n        # Check left-child then right-child\n        vl = self._bisect_forward(x, start, 2*k + 1)\n        if vl != -1:\n            return vl\n        return self._bisect_forward(x, start, 2*k + 2)\n    \n    # Returns min index s.t. start <= index and satisfy check(data[start:idx)) = True\n    def bisect_forward(self, x, start=None):\n        if start:\n            ret = self._bisect_forward(x, start, 0)\n        else:\n            ret = self._bisect_forward(x, 0, 0)\n        self._acc = self.e\n        return ret\n\n    def _bisect_backward(self, x, start, k):\n        # When segment-k is at the bottom, accumulate and return.\n        if k >= self.size - 1:\n            self._acc = self.op(self._acc, self.data[k])\n            if self._check(x, self._acc):\n                return k - (self.size - 1)\n            else:\n                return -1\n        width = 2**(self.lv - (k+1).bit_length() + 1)\n        mid = (k+1) * width + width // 2 - self.size \n        # When right-child isn't in range, just look at right-child. \n        if mid >= start:\n            return self._bisect_backward(x, start, 2*k + 1)\n        # When segment-k is in range and has no answer in it, accumulate and return -1\n        tmp_acc = self.op(self._acc, self.data[k])\n        if start > mid + width // 2 and not self._check(x, tmp_acc):\n            self._acc = tmp_acc\n            return -1\n        # Check right-child then left-child\n        vl = self._bisect_backward(x, start, 2*k + 2)\n        if vl != -1:\n            return vl\n        return self._bisect_backward(x, start, 2*k + 1)\n    \n    # Returns max index s.t. index < start and satisfy check(data[idx:start)) = True\n    def bisect_backward(self, x, start=None):\n        if start:\n            ret = self._bisect_backward(x, start, 0)\n        else:\n            ret = self._bisect_backward(x, self.n, 0)\n        self._acc = self.e\n        return ret\n\n\nn = int(input())\ns = input().rstrip()\narray = [0] * n\nST = SegmentTree(array)\n\nevent = []\nfor i, ch in enumerate(s):\n    event.append((ch, i))\nevent.sort(reverse=True)\n\nans = [0] * n\nfor ch, index in event:\n    val = ST.fold(0, index) + 1\n    ans[index] = val\n    ST.update(index, val)\nprint(max(ans))\nprint(*ans)", "n = int(input())\ns = list(input())\n\ndg = 10**6\nfor i in range(n):\n    s[i] = ord(s[i])*dg + i\ns.sort()\n\ndef init_max(init_max_val):\n    #set_val\n    for i in range(n):\n        seg_max[i+num_max-1]=init_max_val[i]    \n    #built\n    for i in range(num_max-2,-1,-1) :\n        seg_max[i]=max(seg_max[2*i+1],seg_max[2*i+2]) \n    \ndef update_max(k,x):\n    k += num_max-1\n    seg_max[k] = x\n    while k:\n        k = (k-1)//2\n        seg_max[k] = max(seg_max[k*2+1],seg_max[k*2+2])\n    \ndef query_max(p,q):\n    if q<=p:\n        return ide_ele_max\n    p += num_max-1\n    q += num_max-2\n    res=ide_ele_max\n    while q-p>1:\n        if p&1 == 0:\n            res = max(res,seg_max[p])\n        if q&1 == 1:\n            res = max(res,seg_max[q])\n            q -= 1\n        p = p//2\n        q = (q-1)//2\n    if p == q:\n        res = max(res,seg_max[p])\n    else:\n        res = max(max(res,seg_max[p]),seg_max[q])\n    return res\n\nide_ele_max = 0\n\nnum_max =2**(n-1).bit_length()\nseg_max=[ide_ele_max]*2*num_max\n\n\nres = [0]*n\nfor e in s:\n    ind = e%dg\n    ad = query_max(ind,n)\n    res[ind] = ad+1\n\n    update_max(ind,ad+1)\nprint(max(res))\nprint(*res)", "n=int(input())\ns=list(map(ord,input()))\nb=[0 for i in range(26)] #what the heck is an alphabet without 33 letters\nans=[]\nfor i in s:\n    for j in range(26):\n        if b[j]<=i:\n            b[j]=i\n            ans.append(j+1)\n            break\nprint(26-b.count(0))\nprint(*ans)\n", "import sys\n\n# inf = open('input.txt', 'r')\n# reader = (line.rstrip() for line in inf)\nreader = (line.rstrip() for line in sys.stdin)\ninput = reader.__next__\n\ndef ceil(tails, L, R, key): \n    while L + 1 < R: \n        m = (L + R) // 2\n        if key < tails[m]:\n            L = m \n        else: \n            R = m \n    return R\n   \ndef LIS(a, n):\n    \n    tails = [0] * (n + 1)\n    tails[0] = a[0]\n    seq_len = 1  # LIS for a[:1]\n    for i in range(1, n):\n        \n        if (a[i] > tails[0]):  # edit for other order\n            tails[0] = a[i]    # new LIS start\n            ans.append(1)\n        \n        elif (a[i] < tails[seq_len - 1]):  # edit for other order\n            tails[seq_len] = a[i]          # extend existing LIS\n            seq_len += 1\n            ans.append(seq_len)\n        \n        else:  # find LIS that ends in a[i] and update tail value for it\n            pos = ceil(tails, -1, seq_len - 1, a[i])\n            tails[pos] = a[i]\n            ans.append(pos + 1)\n   \n    return seq_len\n\nn = int(input())\ns = input()\nans = [1]\nres = LIS(s, n)\nprint(res)\nprint(*ans)\n    \n# inf.close()\n", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\n# sys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef bisearch_min(mn, mx, func):\n    ok = mx\n    ng = mn\n    while ng+1 < ok:\n        mid = (ok+ng) // 2\n        if func(mid):\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef check(m):\n    if m == len(B):\n        return True\n    if B[m][-1][0] <= a:\n        return True\n    else:\n        return False\n\nN = INT()\nA = [ord(c)-97 for c in input()]\n\nB = [[] for i in range(1)]\nB[0].append((A[0], 0))\nfor i, a in enumerate(A[1:], 1):\n    idx = bisearch_min(-1, len(B), check)\n    if idx == len(B):\n        B.append([(a, i)])\n    else:\n        B[idx].append((a, i))\n\nans = [0] * N\nfor a, li in enumerate(B):\n    for _, idx in li:\n        ans[idx] = a + 1\nprint(len(B))\nprint(*ans)\n", "n = int(input())\ns = input()\nkol = [-1] * n\ncur = 1\nind = 0\nwhile ind < n:\n    if kol[ind] != -1:\n        ind += 1\n    else:\n        kol[ind] = cur\n        best = s[ind]\n        for i in range(ind+1, n):\n            if kol[i] != -1:\n                continue\n            else:\n                if s[i] >= best:\n                    kol[i] = cur\n                    best = s[i]\n        ind += 1\n        cur += 1\nprint(max(kol))\nfor i in range(n):\n    print(kol[i], end = \" \")"]