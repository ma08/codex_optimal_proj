["from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) + [i] for i in range(n)]\ninfo = sorted(info, key = itemgetter(1))\nmax_num = info[-1][1]\n\nN = max_num\nINF = 0\nLV = (N-1).bit_length()\nN0 = 2**LV\ndata = [0]*(2*N0)\nlazy = [0]*(2*N0)\n\ndef gindex(l, r):\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & -L).bit_length()\n    rc = 0 if r & 1 else (R & -R).bit_length()\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if L < R and lc <= i:\n            yield L\n        L >>= 1; R >>= 1\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i-1]\n        if not v:\n            continue\n        lazy[2*i-1] += v; lazy[2*i] += v\n        data[2*i-1] += v; data[2*i] += v\n        lazy[i-1] = 0\n\ndef update(l, r, x):\n    *ids, = gindex(l, r)\n    propagates(*ids)\n\n    L = N0 + l; R = N0 + r\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R-1] += x; data[R-1] += x\n        if L & 1:\n            lazy[L-1] += x; data[L-1] += x\n            L += 1\n        L >>= 1; R >>= 1\n    for i in ids:\n        data[i-1] = max(data[2*i-1], data[2*i])\n\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l; R = N0 + r\n\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = max(s, data[R-1])\n        if L & 1:\n            s = max(s, data[L-1])\n            L += 1\n        L >>= 1; R >>= 1\n    return s\n\nans = []\nfor i in range(n):\n    l, r, j = info[i]\n    r += 1\n    if query(l, r) < m:\n        update(l, r, 1)\n    else:\n        ans.append(j+1)\nprint(len(ans))\nprint(*ans)", "import heapq\n\nn,k = list(map(int,input().split()))\n\nllis = [ [] for i in range(2 * (10**5) + 1) ]\nrlis = [ [] for i in range(2 * (10**5) + 1) ]\nflag = [0] * (2 * (10**5) + 1)\n\nfor i in range(n):\n\n    l,r = list(map(int,input().split()))\n    \n    llis[l].append([i+1,r])\n    rlis[r].append([i+1,l])\n\nnow = 0\nrq = []\nans = []\nfor i in range(2 * (10 ** 5)):\n    \n    i += 1\n\n    for j in llis[i]:\n        now += 1\n        ind = j[0]\n        r = j[1]\n        flag[ind] = 1\n        heapq.heappush(rq,[-1 * r,ind])\n\n    for j in rlis[i-1]:\n        \n        ind = j[0]\n        if flag[ind] == 1:\n            now -= 1\n            flag[ind] = 0\n\n    while now > k:\n\n        nowq = heapq.heappop(rq)\n        ind = nowq[1]\n\n        if flag[ind] == 1:\n            ans.append(ind)\n            now -= 1\n            flag[ind] = 0\n\n\nprint(len(ans))\nprint(\" \".join(map(str,ans)))\n\n        \n", "import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\n\nS=[tuple(map(int,input().split()))+(i+1,) for i in range(n)]\nS.sort()\n\nsegtemp=2*10**5\nseg_el=1<<((segtemp).bit_length())# Segment tree\u306e\u53f0\u306e\u8981\u7d20\u6570\nSEG=[0]*(2*seg_el)# 1-indexed\u306a\u306e\u3067\u3001\u8981\u7d20\u65702*seg_el.Segment tree\u306e\u521d\u671f\u5024\u3067\u521d\u671f\u5316\n\ndef getvalue(n,seg_el):# \u4e00\u70b9\u306e\u5024\u3092\u53d6\u5f97\n    i=n+seg_el\n    ANS=0\n    \n    ANS+=SEG[i]\n    i>>=1# \u5b50\u30ce\u30fc\u30c9\u3078\n    \n    while i!=0:\n        ANS+=SEG[i]\n        i>>=1\n\n    return ANS\n\ndef updates(l,r,x):# \u533a\u9593[l,r)\u306emin\u3092\u66f4\u65b0.\n    L=l+seg_el\n    R=r+seg_el\n\n    while L<R:\n        if L & 1:\n            SEG[L]+=x\n            L+=1\n\n        if R & 1:\n            R-=1\n            SEG[R]+=x\n        L>>=1\n        R>>=1\n\nind=0\nSH=[]\nANS=[]\nimport heapq\n\nfor point in range(segtemp):\n    while ind<n and S[ind][0]<=point:\n        l,r,x=S[ind]\n        updates(l,r+1,1)\n        ind+=1\n\n        heapq.heappush(SH,(-r,l,x))\n\n    #print(getvalue(point,seg_el),SH)\n\n    while getvalue(point,seg_el)>k:\n        r,l,x=heapq.heappop(SH)\n        r=-r\n        ANS.append(x)\n        updates(l,r+1,-1)\n\n    #print(point,ANS,getvalue(point,seg_el))\n        \nprint(len(ANS))\nprint(*ANS)\n        \n", "from heapq import *\n\n\ndef main():\n    n, k = map(int, input().split())\n    E = []\n    opent = {}\n    for i in range(n):\n        l, r = map(int, input().split())\n        E.append([l, 1, i])\n        E.append([r, -1, i])\n        opent[i] = r\n    E.sort(key=lambda x: (x[0], -x[1]))\n    now_r = []\n    heapify(now_r)\n    cnt_delet = 0\n    ans = []\n    deleted = set()\n    for x, t, i in E:\n        if t == 1:\n            heappush(now_r, -(opent[i] * 10 ** 6 + i))\n        else:\n            if i not in deleted:\n                cnt_delet += 1\n        if len(now_r) - cnt_delet > k:\n            for _ in range(len(now_r) - cnt_delet - k):\n                nm = heappop(now_r)\n                ind = (-nm) % 10 ** 6\n                ans.append(ind + 1)\n                deleted.add(ind)\n    print(len(ans))\n    print(' '.join(list(map(str, ans))))\n\n\nmain()", "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass SegTreeIndex:\n \n    def __init__(self, n, func, init):\n\n        self.n = n\n        self.func = func\n        self.init = init\n        n2 = 1\n        while n2 < n:\n            n2 <<= 1\n        self.n2 = n2\n        self.tree = [self.init] * (n2 << 1)\n        self.index = [self.init] * (n2 << 1)\n        for i in range(n2):\n            self.index[i+n2] = i\n        for i in range(n2-1, -1, -1):\n            self.index[i] = self.index[i*2]\n\n    def update(self, i, x):\n\n        i += self.n2\n        self.tree[i] = x\n        while i > 1:\n            left, right = min(i, i^1), max(i, i^1)\n            if self.func(self.tree[left], self.tree[right]) == self.tree[left]:\n                self.tree[i >> 1] = self.tree[left]\n                self.index[i >> 1] = self.index[left]\n            else:\n                self.tree[i >> 1] = self.tree[right]\n                self.index[i >> 1] = self.index[right]\n            i >>= 1\n \n    def query(self, a, b):\n\n        l = a + self.n2\n        r = b + self.n2\n        s = (self.init, -1)\n        while l < r:\n            if r & 1:\n                r -= 1\n                res = self.func(s[0], self.tree[r])\n                if res == s[0]:\n                    pass\n                else:\n                    s = (self.tree[r], self.index[r])\n            if l & 1:\n                res = self.func(self.tree[l], s[0])\n                if res == self.tree[l]:\n                    s = (self.tree[l], self.index[l])\n                else:\n                    pass\n                l += 1\n            l >>= 1\n            r >>= 1\n        return s\n\nN, K = MAP()\nMAX = 200007\n\nLRs = [[] for i in range(MAX+2)]\nR = [0] * (N+1)\nfor i in range(N):\n    l, r = MAP()\n    LRs[l].append(i+1)\n    LRs[r+1].append(-(i+1))\n    R[i+1] = r\n\nsti = SegTreeIndex(N+1, max, -INF)\nsegcnt = 0\nans = []\nremoved = set()\nfor i in range(1, MAX+2):\n    for idx in LRs[i]:\n        if idx > 0:\n            sti.update(idx, R[idx])\n            segcnt += 1\n        else:\n            idx = abs(idx)\n            if idx not in removed:\n                sti.update(idx, -INF)\n                segcnt -= 1\n    while segcnt > K:\n        mx, idx = sti.query(0, N+1)\n        sti.update(idx, -INF)\n        ans.append(idx)\n        removed.add(idx)\n        segcnt -= 1\nprint(len(ans))\nprint(*ans)\n", "'''\ntemplate author-: Pyduper\n'''\nimport sys\n\n# stdin = open(\"testdata.txt\", \"r\")\n# ip = stdin\n# def input():\n# \treturn ip.readline().strip()\n\ndef input():\n\treturn sys.stdin.readline().strip()\n\nimport heapq\nmaxn = 200005\ndef lowbit(x):\n\treturn x&-x\ndef add(t,i,v):\n\twhile i<len(t):\n\t\tt[i]+=v\n\t\ti += lowbit(i)\ndef sum(t,i):\n\tans = 0\n\twhile i>0:\n\t\tans += t[i]\n\t\ti -= lowbit(i)\n\treturn ans\ntrees = [0]*maxn\n \nn,k = map(int,input().split(\" \"))\nseg = []\npoints = [0]*maxn\ncand = []\nfor i in range(n):\n\tl,r = map(int,input().split(\" \"))\n\tseg.append((l,r,i+1))\n\tpoints[l]   += 1\n\tpoints[r+1] -= 1\nst = 0\nfor i in range(maxn):\n\tst += points[i]\n\tif st > k:\n\t\tcand.append((i,st-k))\n \nseg.sort(key = lambda x:(x[0],x[1]))\npq = []\nj = 0\nans = []\nfor i,v in cand:\n\tv = v-sum(trees,i)\n\tif v <= 0:\n\t\tcontinue\n\twhile j<n and seg[j][0] <= i:\n\t\theapq.heappush(pq,(-seg[j][1],seg[j][0],seg[j][2]))\n\t\tj += 1\n \n\tfor t in range(v):\n\t\tr,l,idx = heapq.heappop(pq)\n\t\tans.append(idx)\n\t\tadd(trees,l,1)\n\t\tadd(trees,-r+1,-1)\n \nprint(len(ans))\nprint(*ans)", "# -*- coding: utf-8 -*-\n\nimport sys\nimport bisect\nimport heapq\n\nline_count = 0\nsegments = [None]\nnum_points = 200000\nfor line in sys.stdin.readlines():\n    inputs = line.split()\n    if line_count == 0:\n        n = int(inputs[0])\n        k = int(inputs[1])\n        opening = {}\n        closing = {}\n        removed_right = {}\n        segment_index = 0\n        for i in range(1, num_points + 1):\n            opening[i] = []\n            closing[i] = []\n            removed_right[i] = 0\n    else:\n        l = int(inputs[0])\n        r = int(inputs[1])\n        segment_index += 1\n        segments.append((l, r))\n        opening[l].append(segment_index)\n        closing[r].append(segment_index)\n    if line_count == n:\n        break\n    line_count += 1\n\nworking = []\nworking_count = 0\nremoved = []\nfor i in range(1, num_points + 1):\n    for segment_index in opening[i]:\n        _, r = segments[segment_index]\n        heapq.heappush(working, (- r, segment_index))\n        working_count += 1\n#        bisect.insort_right(working, (r, segment_index))\n    while working_count > k:\n        r, segment_index = heapq.heappop(working)\n#        r, segment_index = working.pop()\n        working_count -= 1\n        removed.append(segment_index)\n        removed_right[- r] += 1\n    squeezed_out = len(closing[i]) - removed_right[i]\n    working_count -= squeezed_out\n#    working = working[squeezed_out: ]\n\nprint(len(removed))\nfor j in removed:\n    print(j, end = \" \")", "import heapq\nn, k = list(map(int, input().split()))\nlength = 2 * (10 ** 5)\nllist = [[] for x in range(length + 1)]\nrlist = [[] for x in range(length + 1)]\nflag = [0] * (length + 1)\nfor i in range(n):\n    l, r = list(map(int, input().split()))\n    llist[l].append([i + 1, r])\n    rlist[r].append([i + 1, l])\nheap = []\nans = []\nnow = 0\nfor i in range(length):\n    i += 1\n    for j in llist[i]:\n        now += 1\n        currents = j[0]\n        r = j[1]\n        flag[currents] = 1\n        heapq.heappush(heap, [-1 * r, currents])\n    for j in rlist[i - 1]:\n        currents = j[0]\n        if flag[currents] == 1:\n            now -= 1\n            flag[currents] = 0\n    while now > k:\n        removing = heapq.heappop(heap)\n        currents = removing[1]\n        if flag[currents] == 1:\n            ans.append(currents)\n            now -= 1\n            flag[currents] = 0\nprint(len(ans))\nprint(\" \".join(map(str, ans)))\n", "import heapq\n\nN, K = [int(x) for x in input().split()]\nL2RI = [[] for i in range(200000)]\nfor i in range(N):\n    l, r = [int(x) for x in input().split()]\n    L2RI[l-1].append([-(r-1), i+1])\n\nans = []\nque = []\nheapq.heapify(que)\n\nhist = [0]*200000\nexited = 0\n\nfor l in range(200000):\n    for ri in L2RI[l]:\n        heapq.heappush(que, ri)\n        hist[-ri[0]] += 1\n    while len(que) - exited > K:\n        top = heapq.heappop(que)\n        hist[-top[0]] -= 1\n        ans.append(top[1])\n    exited += hist[l]\n\nprint(len(ans))\nprint(*ans)", "import sys\nfrom heapq import *\nn, k = list(map(int, input().split()))\nN = int(2e5+2)\nll = [[] for _ in range(N)]\nrr = [[] for _ in range(N)]\nvis = [0] * N\n\nfor i in range(n):\n    l, r = list(map(int, sys.stdin.readline().split()))\n    ll[l].append((-r, i+1))\n    rr[r].append(i+1)\n\nq = []\nans = []\nsize = 0\n\nfor i in range(1, N):\n    for j in ll[i]:\n        heappush(q, j)\n        size += 1\n\n    while size > k:\n        cur = heappop(q)\n        while vis[cur[1]]:\n            cur = heappop(q)\n        vis[cur[1]] = 1\n        ans.append(cur[1])\n        size -= 1\n    for j in rr[i]:\n        if not vis[j]:\n            vis[j] = 1\n            size -= 1\n\nprint(len(ans))\nprint(*ans)\n\n\n", "import heapq\n \nN, K = [int(x) for x in input().split()]\nL2RI = [[] for i in range(200000)]\nfor i in range(N):\n    l, r = [int(x) for x in input().split()]\n    L2RI[l-1].append([-(r-1), i+1])\n \nans = []\nque = []\nheapq.heapify(que)\n \nhist = [0]*200000\nexited = 0\n \nfor l in range(200000):\n    for ri in L2RI[l]:\n        heapq.heappush(que, ri)\n        hist[-ri[0]] += 1\n    while len(que) - exited > K:\n        top = heapq.heappop(que)\n        hist[-top[0]] -= 1\n        ans.append(top[1])\n    exited += hist[l]\n \nprint(len(ans))\nprint(*ans)", "# DP\u3063\u307d\u3044\u306a\n# \u611a\u76f4\u306b\u66f8\u304f\n\nimport sys\nreader = (s.rstrip() for s in sys.stdin)\ninput = reader.__next__\n\nfrom heapq import heappop, heappush\n\nclass RangeAddQuery:\n    def __init__(self, n):\n        self.n0 = 2**(n-1).bit_length()\n        self.data = [0]*(2*self.n0-1)\n\n    def add(self, l,r,v):\n        l += self.n0\n        r += self.n0\n        while l < r:\n            if r&1:\n                r -= 1\n                self.data[r-1] += v\n            if l&1:\n                self.data[l-1] += v\n                l += 1\n            l >>=1\n            r >>=1\n\n    def query(self, i):\n        i += self.n0-1\n        res = 0\n        while i+1:\n            if self.data[i]:\n                res += self.data[i]\n            i = ~-i//2\n        return res\n\nn,k = list(map(int, input().split()))\nm = 2*10**5\nRAQ = RangeAddQuery(m+10)\n\nsegments = []\nfor i in range(n):\n    a,b = list(map(int, input().split()))\n    a,b = a-1,b-1\n    RAQ.add(a,b+1, 1)\n    segments.append((a,b,i+1))\n\nsegments.sort()\ncursor = 0\n# \u53f3\u7aef\u3001\u5de6\u7aef\nheap = []\nans = []\n# \u524d\u304b\u3089\u307f\u3066\u3044\u304f\nfor i in range(m):\n    # segments\u8db3\u3059\u304b\u3069\u3046\u304b\n    # \u5168\u4f53\u3067O(N)\n    while cursor != n and segments[cursor][0] == i:\n        # -\u53f3\u7aef, \u5de6\u7aef\n        heappush(heap, (-segments[cursor][1], segments[cursor][0], segments[cursor][2]))\n        cursor += 1\n    cnt = max(0, RAQ.query(i)-k)\n    #ans += cnt\n    # cnt\u500b\u30bb\u30b0\u30e1\u30f3\u30c8\u3092\u6d88\u3055\u306a\u304d\u3083\u3044\u3051\u306a\u3044\n    while cnt:\n        r,l,p = heappop(heap)\n        r = -r\n        if r<i:\n            continue\n        RAQ.add(l, r+1, -1)\n        cnt -= 1\n        ans.append(p)\nprint(len(ans))\nprint(*ans)\n\n", "import heapq\n \nN, K = [int(x) for x in input().split()]\nL2RI = [[] for i in range(200000)]\nfor i in range(N):\n    l, r = [int(x) for x in input().split()]\n    L2RI[l-1].append([-(r-1), i+1])\n \nans = []\nque = []\nheapq.heapify(que)\n \nhist = [0]*200000\nexited = 0\n \nfor l in range(200000):\n    for ri in L2RI[l]:\n        heapq.heappush(que, ri)\n        hist[-ri[0]] += 1\n    while len(que) - exited > K:\n        top = heapq.heappop(que)\n        hist[-top[0]] -= 1\n        ans.append(top[1])\n    exited += hist[l]\n \nprint(len(ans))\nprint(*ans)", "from bisect import bisect_right, bisect_left\n# instead of AVLTree\nclass BITbisect():\n    def __init__(self, InputProbNumbers):\n        # \u5ea7\u5727\n        self.ind_to_co = [-10**18]\n        self.co_to_ind = {}\n        for ind, num in enumerate(sorted(list(set(InputProbNumbers)))):\n            self.ind_to_co.append(num)\n            self.co_to_ind[num] = ind+1\n        self.max = len(self.co_to_ind)\n        self.data = [0]*(self.max+1)\n    \n    def __str__(self):\n        retList = []\n        for i in range(1, self.max+1):\n            x = self.ind_to_co[i]\n            if self.count(x):\n                c = self.count(x)\n                for _ in range(c):\n                    retList.append(x)\n        return \"[\" + \", \".join([str(a) for a in retList]) + \"]\"\n    \n    def __getitem__(self, key):\n        key += 1\n        s = 0\n        ind = 0\n        l = self.max.bit_length()\n        for i in reversed(range(l)):\n            if ind + (1<<i) <= self.max:\n                if s + self.data[ind+(1<<i)] < key:\n                    s += self.data[ind+(1<<i)]\n                    ind += (1<<i)\n        if ind == self.max or key < 0:\n            raise IndexError(\"BIT index out of range\")\n        return self.ind_to_co[ind+1]\n    \n    def __len__(self):\n        return self._query_sum(self.max)\n    \n    def __contains__(self, num):\n        if not num in self.co_to_ind:\n            return False\n        return self.count(num) > 0\n    \n    # 0\u304b\u3089i\u307e\u3067\u306e\u533a\u9593\u548c\n    # \u5de6\u306b\u9032\u3093\u3067\u3044\u304f\n    def _query_sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    # i\u756a\u76ee\u306e\u8981\u7d20\u306bx\u3092\u8db3\u3059\n    # \u4e0a\u306b\u767b\u3063\u3066\u3044\u304f\n    def _add(self, i, x):\n        while i <= self.max:\n            self.data[i] += x\n            i += i & -i\n    \n    # \u5024x\u3092\u633f\u5165\n    def push(self, x):\n        if not x in self.co_to_ind:\n            raise KeyError(\"The pushing number didnt initialized\")\n        self._add(self.co_to_ind[x], 1)\n            \n    # \u5024x\u3092\u524a\u9664\n    def delete(self, x):\n        if not x in self.co_to_ind:\n            raise KeyError(\"The deleting number didnt initialized\")\n        if self.count(x) <= 0:\n            raise ValueError(\"The deleting number doesnt exist\")\n        self._add(self.co_to_ind[x], -1)\n\n    # \u8981\u7d20x\u306e\u500b\u6570\n    def count(self, x):\n        return self._query_sum(self.co_to_ind[x]) - self._query_sum(self.co_to_ind[x]-1)\n    \n    # \u5024x\u3092\u8d85\u3048\u308b\u6700\u4f4eind\n    def bisect_right(self, x):\n        if x in self.co_to_ind:\n            i = self.co_to_ind[x]\n        else:\n            i = bisect_right(self.ind_to_co, x) - 1\n        return self._query_sum(i)\n\n    # \u5024x\u3092\u4e0b\u56de\u308b\u6700\u4f4eind\n    def bisect_left(self, x):\n        if x in self.co_to_ind:\n            i = self.co_to_ind[x]\n        else:\n            i = bisect_left(self.ind_to_co, x)\n        if i == 1:\n            return 0\n        return self._query_sum(i-1)\n\n\nimport sys\ninput = sys.stdin.readline\nfrom collections import Counter\nMAX = 2*10**5+3\n\nN, K = map(int, input().split())\nQuery = [list(map(int, input().split())) for _ in range(N)]\nA = [[] for _ in range(MAX)]\nB = BITbisect(list(range(MAX)))\nP = [[] for _ in range(MAX)]\nfor i, (l, r) in enumerate(Query):\n    A[l].append(r)\n    P[r].append((l, i+1))\n\nmustL = []\nfor n in range(MAX):\n    for r in A[n]:\n        B.push(r)\n    while len(B) > 0:\n        b = B[0]\n        if b < n:\n            B.delete(b)\n        else:\n            break\n    l = len(B)\n    d = l - K\n    if d > 0:\n        for _ in range(d):\n            b = B[l-1]\n            B.delete(b)\n            mustL.append(b)\n            l -= 1\n\nC = Counter(mustL)\nans = []\nfor r, c in C.items():\n    P[r].sort()\n    for i in range(c):\n        ans.append(P[r][i][1])\n    \nprint(len(ans))\nprint(*ans)", "class FTree:\n    def __init__(self, f):\n        self.n = len(f)\n        self.ft = [0] * (self.n + 1)\n\n        for i in range(1, self.n + 1):\n            self.ft[i] += f[i - 1]\n            if i + self.lsone(i) <= self.n:\n                self.ft[i + self.lsone(i)] += self.ft[i]\n\n    def lsone(self, s):\n        return s & (-s)\n\n    def query(self, i, j):\n        if i > 1:\n            return self.query(1, j) - self.query(1, j - 1)\n\n        s = 0\n        while j > 0:\n            s += self.ft[j]\n            j -= self.lsone(j)\n\n        return s\n\n    def update(self, i, v):\n        while i <= self.n:\n            self.ft[i] += v\n            i += self.lsone(i)\n\n    def select(self, k):\n        lo = 1\n        hi = self.n\n\n        for i in range(30):\n            mid = (lo + hi) // 2\n            if self.query(1, mid) < k:\n                lo = mid\n            else:\n                hi = mid\n\n        return hi\n\nclass RUPQ:\n    def __init__(self, n):\n        self.ftree = FTree([0] * n)\n\n    def query(self, i):\n        return self.ftree.query(1, i)\n\n    def update(self, i, j, v):\n        self.ftree.update(i, v)\n        self.ftree.update(j + 1, -v)\n\nclass RURQ:\n    def __init__(self, n):\n        self.f = FTree([0] * n)\n        self.r = RUPQ(n)\n\n    def query(self, i, j):\n        if i > 1:\n            return self.query(1, j) - self.query(1, i - 1)\n        return self.r.query(j) * j - self.f.query(1, j)\n\n    def update(self, i, j, v):\n        self.r.update(i, j, v)\n        self.f.update(i, v * (i - 1))\n        self.f.update(j + 1, -1 * v * j)\n\n\n# f = [0, 1, 0, 1, 2, 3, 2, 1, 1, 0]\n# ft = FTree(f)\n# print(ft.query(1, 6) == 7)\n# print(ft.query(1, 3) == 1)\n# print(ft.select(7) == 6)\n# ft.update(5, 1)\n# print(ft.query(1, 10) == 12)\n\n# r = RUPQ(10)\n# r.update(2, 9, 7)\n# r.update(6, 7, 3)\n# print(r.query(1) == 0)\n# print(r.query(2) == 7)\n# print(r.query(3) == 7)\n# print(r.query(4) == 7)\n# print(r.query(5) == 7)\n# print(r.query(6) == 10)\n# print(r.query(7) == 10)\n# print(r.query(8) == 7)\n# print(r.query(9) == 7)\n# print(r.query(10) == 0)\n\n\nimport sys, heapq\nn, k = [int(i) for i in sys.stdin.readline().split()]\n\nmmn = 1\nmmx = 200000\nftree = RUPQ(mmx)\nlns = sys.stdin.readlines()\nbds = []\nqqq = 0\nfor ln in lns:\n    qqq += 1\n    t = [int(i) for i in ln.split()]\n    t.append(qqq)\n    bds.append(t)\n    ftree.update(bds[-1][0], bds[-1][1], 1)\n\n# bds.sort(key=lambda a: mmx*a[0] - a[1])\nbds.sort()\n\nbind = 0\nheap = []\nans = []\nfor i in range(1, mmx+1):\n    while bind < n and bds[bind][0] == i:\n        heapq.heappush(heap, (-1*bds[bind][1], bds[bind][2]))\n        bind += 1\n\n    while ftree.query(i) > k:\n        bd, bnd = heapq.heappop(heap) \n        ans.append(bnd)\n        ftree.update(i,-1*bd, -1)\nprint(len(ans))\nprint(*ans)\n\n    \n\n\n\n\n\n\n\n# r = RURQ(10)\n# r.update(2, 9, 7)\n# r.update(6, 7, 3)\n# print(r.query(3, 5) == 21)\n# print(r.query(7, 8) == 17)\n\n# Example for https://open.kattis.com/problems/fenwick\n# from sys import stdin, stdout\n#\n# def main():\n#     n, q = [int(i) for i in stdin.readline().split(' ')]\n#     f = FTree([0] * n)\n#     for l in stdin.read()[:-1].split('\\n'):\n#         a = l.split(' ')\n#         if a[0] == '?':\n#             if a[1] == '0':\n#                 stdout.write(\"0\\n\")\n#             else:\n#                 stdout.write(\"{}\\n\".format(f.q(1, int(a[1]))))\n#         else:\n#             f.u(int(a[1]) + 1, int(a[2]))\n#\n# main()\n", "import sys, heapq\nmmx = 200000\nftree = [0]*(mmx+1)\ndef uu(i, j, v):\n    while i <= mmx:\n        ftree[i] += v\n        i += (i&-i)\n    j += 1\n    while j <= mmx:\n        ftree[j] -= v\n        j += (j&-j)\ndef qq(j):\n    s = 0\n    while j > 0:\n        s += ftree[j]\n        j -= (j & -j)\n    return s\nn, k = [int(i) for i in sys.stdin.readline().split()]\nlns = sys.stdin.readlines()\nbds = []\nfor j in range(n):\n    t = [int(i) for i in lns[j].split()]\n    t.append(j+1)\n    bds.append(t)\n    uu(bds[-1][0], bds[-1][1], 1)\nbds.sort()\nbind = 0\nheap = []\nans = []\nfor i in range(1, mmx+1):\n    while bind < n and bds[bind][0] == i:\n        heapq.heappush(heap, (-1*bds[bind][1], bds[bind][2]))\n        bind += 1\n    while qq(i) > k:\n        bd, bnd = heapq.heappop(heap) \n        ans.append(str(bnd))\n        uu(i,-1*bd, -1)\nprint(len(ans))\nprint(\" \".join(ans))\n", "import heapq\nN, K = [int(x) for x in input().split()]\nh = [[] for i in range(200000)]\nfor i in range(N):\n    l, r = [int(x) for x in input().split()]\n    h[l-1].append([-(r-1), i+1])\ng = []\nt = []\nheapq.heapify(t)\nhist = [0]*200000\nexited = 0\nfor l in range(200000):\n    for ri in h[l]:\n        heapq.heappush(t, ri)\n        hist[-ri[0]] += 1\n    while len(t) - exited > K:\n        top = heapq.heappop(t)\n        hist[-top[0]] -= 1\n        g.append(top[1])\n    exited += hist[l]\nprint(len(g))\nprint(*g)", "import sys\nfrom heapq import *\n\nn, k = map(int, input().split())\nN = int(2e5 + 2)\nll = [[] for _ in range(N)]\nrr = [[] for _ in range(N)]\nvis = [0] * N\n\nfor i in range(n):\n    l, r = map(int, sys.stdin.readline().split())\n    ll[l].append((-r, i + 1))\n    rr[r].append(i + 1)\n# print(ll)\n# print(rr)\n\nq = []\nans = []\nsize = 0\n\nfor i in range(1, N):\n    for j in ll[i]:\n        heappush(q, j)\n        # print(q)\n        size += 1\n\n    while size > k:\n        cur = heappop(q)\n        # while vis[cur[1]]:\n        #     print(vis[cur],\"pao\")\n        #     cur = heappop(q)\n        vis[cur[1]] = 1\n        ans.append(cur[1])\n        size -= 1\n    for j in rr[i]:\n        if not vis[j]:\n            vis[j] = 1\n            size -= 1\n\nprint(len(ans))\nprint(*ans)", "import sys\nfrom heapq import *\n#sys.stdin = open('in', 'r')\n#n = int(input())\nn,k = list(map(int, input().split()))\nseg = []\nfor i in range(n):\n    l, r = list(map(int, input().split()))\n    seg.append((l, r, i+1))\nseg.sort()\nc = 0\nres = []\ni = 0\nhmin = []\nhmax = []\nrem = set()\nwhile i < n:\n    l,r,si = seg[i]\n    while i < n and seg[i][0] == l:\n        _,r,si = seg[i]\n        heappush(hmax, (-r, si))\n        heappush(hmin, (r, si))\n        i += 1\n        c += 1\n    while len(hmin) > 0 and hmin[0][0] < l:\n        mr,ind = heappop(hmin)\n        if ind not in rem:\n            c -= 1\n    while c > k:\n        mr,ind = heappop(hmax)\n        res.append(ind)\n        rem.add(ind)\n        c -= 1\nprint(len(res))\nif len(res) > 0:\n    print(' '.join(map(str, res)))\n        \n        \n\n\n\n\n\n#sys.stdout.write('YES\\n')\n#sys.stdout.write(f'{res}\\n')\n#sys.stdout.write(f'{y1} {x1} {y2} {x2}\\n')\n"]