["n = int(input())\nv = list(map(int, input().split()))\nodd = [0] * (10 ** 5 + 5)\neven = [0] * (10 ** 5 + 5)\nfor i in range(n):\n    if i % 2 == 0:\n        even[v[i]] += 1\n    else:\n        odd[v[i]] += 1\nsum_odd = sum(odd)\nsum_even = sum(even)\nans = sum_odd + sum_even\nmax_odd = max(odd)\nmax_even = max(even)\nif odd.index(max_odd) != even.index(max_even):\n    print(sum_odd + sum_even - max_even - max_odd)\nelse:\n    odd.sort()\n    even.sort()\n    if odd[-1] - odd[-2] > even[-1] - even[-2]:\n        ans -= odd[-1] + even[-2]\n    else:\n        ans -= odd[-2] + even[-1]\n    print(ans)", "# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\nimport collections\n\n\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, Vi):\n    V1 = Vi[::2]\n    V2 = Vi[1::2]\n    c_V1 = dict(collections.Counter(V1))\n    c_V2 = dict(collections.Counter(V2))\n    c_V1 = sorted(list(c_V1.items()), key=lambda x: x[1], reverse=True)\n    c_V2 = sorted(list(c_V2.items()), key=lambda x: x[1], reverse=True)\n    c_V1.append((-1, 0))\n    c_V2.append((-1, 0))\n    ans = 0\n    if c_V1[0][0] == c_V2[0][0]:\n        ans = min(len(V1) - c_V1[0][1] + len(V2) - c_V2[1][1],\n                  len(V1) - c_V1[1][1] + len(V2) - c_V2[0][1])\n    else:\n        ans = len(V1) - c_V1[0][1] + len(V2) - c_V2[0][1]\n    print(ans)\n\n\ndef __starting_point():\n    N = int(input())\n    Vi = [int(i) for i in input().split()]\n    solve(N, Vi)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n\n\n__starting_point()", "import collections\nN = int(input())\nv = list(map(int,input().split()))\nv1,v2 = v[::2],v[1::2]\nA1 = collections.Counter(v1)\nA2 = collections.Counter(v2)\nB = list(A1.values())\nC = list(A2.values())\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nif A1.most_common()[0][0] == A2.most_common()[0][0]:\n    if len(A1) == 1:\n        ans = N//2\n    else:\n        if B[1] > C[1]: ans = N//2 - B[0] + N//2 - B[1]\n        else: ans = N//2 - B[0] + N//2 - C[1]\n\nelse:\n    ans = N//2 - B[0] + N//2 - C[0]\nprint(ans)", "import collections\n\nn = int(input())\nn_half = n//2\nv = list(map(int, input().split()))\nv_gusu = v[0::2]\nv_odd = v[1::2]\nans = 0\nc1 = collections.Counter(v)\nc2 = collections.Counter(v_gusu)\nc3 = collections.Counter(v_odd)\n\nif c1.most_common()[0][1] == n:\n    print(n_half)\n    return\n\nif c2.most_common()[0][0] == c3.most_common()[0][0]:\n    print(min((n_half - c2.most_common()[1][1]) + (n_half - c3.most_common()[0][1]),(n_half - c2.most_common()[0][1]) + (n_half - c3.most_common()[1][1])))\n    return\nelse:\n    print((n_half - c2.most_common()[0][1]) + (n_half - c3.most_common()[0][1]))\n    return", "from collections import Counter\nn = int(input())\na = list(map(int,input().split()))\n\ne = Counter(a[0::2]).most_common()\no = Counter(a[1::2]).most_common()\ne.append((0, 0))\no.append((0, 0))\n\nif e[0][0] != o[0][0]:\n  print(n - o[0][1] - e[0][1])\nelse:\n  print(min(n-o[0][1] -e[1][1],n-o[1][1] -e[0][1]))", "import collections\nimport math\n\nn=int(input())\na=list(map(int,input().split()))\nev=[a[2*i] for i in range(n//2)]\nod=[a[2*i+1] for i in range(n//2)]\n\nccev=collections.Counter(ev)\nccod=collections.Counter(od)\n\nmcev=ccev.most_common()\nmcod=ccod.most_common()\n\nif mcev[0][0]!=mcod[0][0]:\n    print((n-mcev[0][1]-mcod[0][1]))\n    return\nelif len(mcev)==1 and len(mcod)==1:\n    print((n-mcev[0][1]))\n    return\nelif len(mcev)==1:\n    print((n-mcod[1][1]))\n    return\nelif len(mcod)==1:\n    print((n-mcev[1][1]))\n    return\nelse:\n    tt=max(mcev[1][1],mcod[1][1])\n    print((n-mcev[0][1]-tt))\n    return\n", "n = int(input())\nv = list(map(int,input().split()))\nv0 = v[0:n-1:2]\nv1 = v[1:n:2]\nfrom collections import Counter\nV0 = Counter(v0)\nV1 = Counter(v1)\nif V0.most_common()[0][0] != V1.most_common()[0][0]:\n    a = V0.most_common()[0][1]\n    b = V1.most_common()[0][1]\nelse:\n    if V0.most_common()[0][1] > V1.most_common()[0][1]:\n        if len(V1) > 1:\n            a = V0.most_common()[0][1]\n            b = V1.most_common()[1][1]\n        else:\n            a = V0.most_common()[0][1]\n            b = 0\n    elif V0.most_common()[0][1] < V1.most_common()[0][1]:\n        if len(V0) > 1:\n            a = V1.most_common()[0][1]\n            b = V0.most_common()[1][1]\n        else:\n            a = 0\n            b = V1.most_common()[0][1]\n    else:\n        if len(V0) == 1 and len(V1) == 1:\n            a = 0\n            b = V0.most_common()[0][1]\n        elif len(V0) == 1:\n            a = V0.most_common()[0][1]\n            b = V1.most_common()[1][1]\n        elif len(V1) == 1:\n            a = V0.most_common()[1][1]\n            b = V1.most_common()[0][1]\n        else:\n            a = V0.most_common()[0][1]\n            b = max(V0.most_common()[1][1],V1.most_common()[1][1])\nprint((n-a-b))\n", "import collections\nn = int(input())\nlsp = list(map(int,input().split()))\nlse = []\nlso = []\nfor i in range(n):\n    if i%2 == 0:\n        lse.append(lsp[i])\n    else:\n        lso.append(lsp[i])\n\ncountere = collections.Counter(lse)\ncountero = collections.Counter(lso)\n\nvaluee = sorted(list(countere.values()),reverse=True)+[0]\nvalueo = sorted(list(countero.values()),reverse=True)+[0]\n\nkeyse = []\nfor i in countere.keys():\n    if countere[i] == valuee[0]:\n        keyse.append(i)\nkeyso = []\nfor i in countero.keys():\n    if countero[i] == valueo[0]:\n        keyso.append(i)\nfactor = 0\nif len(keyse) == 1 and len(keyso) == 1 and keyso == keyse:\n    factor = min(valuee[0]-valuee[1],valueo[0]-valueo[1])\n\nprint(n-valuee[0]-valueo[0]+factor)", "N = int(input())\nV = list(map(int,input().split()))\nO = []\nE = []\nnums_O = []\nnums_E = []\n\nfor i in range(0,N,2):\n  O.append(V[i])\n  E.append(V[i+1])\n\nfor j in range(100000):\n  nums_O.append([0,j])\n  nums_E.append([0,j])\n\nfor k in range(N//2):\n  nums_O[O[k]-1][0] += 1\n  nums_E[E[k]-1][0] += 1\n  \nnums_O.sort()\nnums_E.sort()\n##print(O,E,nums_O[-1],nums_E[-1])\nif nums_O[-1][1] != nums_E[-1][1]:\n  print(N-(nums_O[-1][0] + nums_E[-1][0]))\nelse:\n  print(N-max(nums_E[-2][0]+nums_O[-1][0],nums_O[-2][0]+nums_E[-1][0]))", "N=int(input())\nZ=list(map(int,input().split()))\nfrom collections import Counter\nc=Counter(Z[::2]).most_common(2)+[(0,0)]\nc2=Counter(Z[1::2]).most_common(2)+[(0,0)]\nif c[0][0]!=c2[0][0]:\n    print(N-c[0][1]-c2[0][1])\nelse:\n    print(min(N-c[1][1]-c2[0][1],N-c[0][1]-c2[1][1]))", "import sys\nfrom collections import Counter\n\ninput = sys.stdin.readline\nN = int(input())\nV = list(map(int, input().split()))\n\nans = 0\ncounter = Counter(V)\nif len(counter) == 1:\n    ans = N//2\nelif N == 2:\n    ans = 1\nelse:\n    counter1 = Counter(V[0::2])\n    counter2 = Counter(V[1::2])\n\n    counter1 = sorted(counter1.items(), key=lambda x: x[1], reverse=True)\n    counter2 = sorted(counter2.items(), key=lambda x: x[1], reverse=True)\n    if counter1[0][0] == counter2[0][0]:\n        ans = N - counter1[1][1] - counter2[0][1]\n        ans = min(ans, N - counter1[0][1] - counter2[1][1])\n    else:\n        ans = N - counter1[0][1] - counter2[0][1]\n\nprint(ans)", "from collections import Counter\nn = int(input())\nvs = list(map(int, input().split()))\n\neq_lis = []\nodd_lis = []\nfor i in range(n):\n    if i %2 ==0:\n        eq_lis.append(vs[i])\n    else:\n        odd_lis.append(vs[i])\n        \na = Counter(eq_lis)\nb = Counter(odd_lis)\na_val = list(a.values())\nb_val = list(b.values())\na_max = max(a_val)\nb_max = max(b_val)\n\na_sorted = sorted(a.items(), key= lambda x:x[1])\nb_sorted = sorted(b.items(), key= lambda x:x[1])\n\nif a_sorted[-1][0] == b_sorted[-1][0]:\n    if len(a_sorted) == 1 and len(b_sorted) == 1:\n        print(n-a_max)\n    elif len(a_sorted)==1 and len(b_sorted) >1:\n        print(n-a_max-b_sorted[-2][1])\n    elif len(a_sorted)>1 and len(b_sorted) ==1:\n        print(n-b_max-a_sorted[-2][1])\n    else:\n        if b_sorted[-2][1] >= a_sorted[-2][1]:\n            print(n-a_max-b_sorted[-2][1])\n        else:\n            print(n-b_max-a_sorted[-2][1])    \nelse:\n    print(n-a_max-b_max)", "N = int(input())\nV = list(map(int,input().split()))\n\nfrom collections import Counter\n\ndef get_counter(X):\n  counter = Counter(X)\n  X = sorted(list(counter.items()), key = lambda x:x[1], reverse = True)\n  X.append((0,0))\n  return X\n\nV1 = get_counter(V[::2])\nV2 = get_counter(V[1::2])\n\nif V1[0][0] != V2[0][0]:\n  print((N - (V1[0][1] + V2[0][1])))\nelse:\n  print((N - max(V1[0][1] + V2[1][1],V1[1][1] + V2[0][1])))\n", "n = int(input())\nV = list(map(int, input().split()))\nfrom collections import Counter\neven = Counter(V[0::2])\neven[\"0\"]=0\neven = sorted(even.items(), key=lambda x:x[1], reverse=True)\nodd = Counter(V[1::2])\nodd[\"-1\"]=0\nodd = sorted(odd.items(), key=lambda x:x[1], reverse=True)\ni=0\neven_top2, odd_top2 = [], []\nfor (e, o) in zip(even, odd):\n  i+=1\n  even_top2.append(e)\n  odd_top2.append(o)\n  if i==2:\n    break\nif even_top2[0][0] != odd_top2[0][0]:\n  notchange = even_top2[0][1] + odd_top2[0][1]\nelse:\n  notchange = max(even_top2[0][1]+odd_top2[1][1], even_top2[1][1]+odd_top2[0][1])\nprint(n-notchange)", "n=int(input())\nv=list(map(int,input().split()))\nnumg=[]\nnumk=[]\nfor i in range(n):\n    if i%2==0:\n        numk.append(v[i])\n    else:\n        numg.append(v[i])\nnumk.sort()\nnumg.sort()\nnumk2=[]\nnumg2=[]\nnum1=0\ncnt=0\nfor i in range(len(numk)):\n    if num1!=numk[i]:\n        numk2.append([num1,cnt])\n        num1=numk[i]\n        cnt=1\n    else:\n        cnt+=1\nnumk2.append([num1,cnt])\nnum1=0\ncnt=0\nfor i in range(len(numg)):\n    if num1!=numg[i]:\n        numg2.append([num1,cnt])\n        num1=numg[i]\n        cnt=1\n    else:\n        cnt+=1\nnumg2.append([num1,cnt])\nstr1= lambda val: val[1]\nnumg2.sort(key=str1)\nnumk2.sort(key=str1)\nif numg2[-1][0]==numk2[-1][0]:\n    print((n-max(numg2[-1][1]+numk2[-2][1],numg2[-2][1]+numk2[-1][1])))\nelse:\n    print((n-(numg2[-1][1]+numk2[-1][1])))\n", "from collections import Counter\nn = int(input())\nv = list(map(int, input().split()))\n\nv1_c = Counter(v[::2])\nv2_c = Counter(v[1::2])\nv1_c = sorted(list(v1_c.items()), key=lambda x: x[1])\nv2_c = sorted(list(v2_c.items()), key=lambda x: x[1])\n\nv1 = v1_c\nv2 = v2_c\n\nans_1 = 0\n\nif v1[-1][0]==v2[-1][0]:\n    ans_1 += v1[-1][1]\n    v1 = v1[:-1]\n\nif len(v1)>=2:\n    for i, j in v1[:-1]:\n        ans_1 += j\n\nif len(v2)>=2:\n    for i, j in v2[:-1]:\n        ans_1 += j\n\nv1 = v1_c\nv2 = v2_c\n\nans_2 = 0\n\nif v1[-1][0]==v2[-1][0]:\n    ans_2 += v2[-1][1]\n    v2 = v2[:-1]\n\nif len(v2)>=2:\n    for i, j in v2[:-1]:\n        ans_2 += j\n\nif len(v1)>=2:\n    for i, j in v1[:-1]:\n        ans_2 += j\n\nprint(min(ans_1, ans_2))", "from collections import *\nn = int(input())\nv = list(map(int,input().split()))\nif len(set(v))==1:\n    print(len(v)//2)\n    return\nn_even = v[0::2]\nn_odd = v[1::2]\na = Counter(n_even).most_common()+[(0,0)]\nb = Counter(n_odd).most_common()+[(0,0)]\n#print(a)\n#print(b)\nif a[0][0] == b[0][0]:\n    ans = min(n-a[0][1]-b[1][1],n-a[1][1]-b[0][1])\nelse:\n    ans = n - a[0][1] - b[0][1]\nprint(ans)", "from collections import Counter\nn = int(input())\nV = list(map(int, input().split()))\nx = len(set(V))\nif x == 1:\n    print((n // 2))\nelse:\n    A = list()\n    B = list()\n    for i, v in enumerate(V):\n        if i & 1:\n            A.append(v)\n        else:\n            B.append(v)\n    A = Counter(A).most_common()\n    B = Counter(B).most_common()\n    a = A[0]\n    b = B[0]\n    if a[0] == b[0]:\n        if len(A) == 1:\n            b = B[1]\n        elif len(B) == 1:\n            a = A[1]\n        else:\n            if A[1][1] >= B[1][1]:\n                a = A[1]\n            else:\n                b = B[1]\n    print((n - a[1] - b[1]))\n", "import collections\n\nn = int(input())\nv = list(map(int, input().split()))\neven_odd_length = n / 2\nreplace_total = 0\n\nlist_odd = v[0::2]\nlist_even = v[1::2]\n\ndict_c_odd = dict(collections.Counter(list_odd))\ndict_c_even = dict(collections.Counter(list_even))\ndict_c_even_bk = dict_c_even.copy()\ndict_c_odd_bk = dict_c_odd.copy()\n\nreplace_total_tmp = 0\nreplace_total_tmp2 = 0\nmax_count_c_odd = max(dict_c_odd.values())\nmax_count_c_even = max(dict_c_even.values())\nmax_count_c_even_bk = max_count_c_even\nmax_c_odd_keys = [k for k, v in dict_c_odd.items() if v == max_count_c_odd]\nmax_c_even_keys = [k for k, v in dict_c_even.items() if v == max_count_c_even]\n\nif len(set(v)) == 1:\n    print(int(even_odd_length))\nelse:    \n    if max_c_odd_keys[0] in dict_c_even:\n        del dict_c_even[max_c_odd_keys[0]]\n    max_count_c_even = max(dict_c_even.values())\n    replace_total_tmp = (n - max_count_c_odd - max_count_c_even)\n    \n    dict_c_even = dict_c_even_bk\n    max_count_c_even = max_count_c_even_bk\n    \n    if max_c_even_keys[0] in dict_c_odd:\n        del dict_c_odd[max_c_even_keys[0]]\n    max_count_c_odd = max(dict_c_odd.values())\n    replace_total_tmp2 = (n - max_count_c_odd - max_count_c_even)\n    \n    if replace_total_tmp >= replace_total_tmp2:\n         replace_total = replace_total_tmp2\n    else:\n         replace_total = replace_total_tmp\n    print(replace_total)", "from collections import Counter\n\nn = int(input())\nv = list(map(int, input().split()))\n\neven = v[::2]\nodd = v[1::2]\n\nc_even = Counter(even)\nc_odd = Counter(odd)\n\ne_max1 = [0, 0]\ne_max2 = [0, 0]\no_max1 = [0, 0]\no_max2 = [0, 0]\n\nfor x, y in list(c_even.items()):\n    if y > e_max1[1]:\n        e_max2 = e_max1\n        e_max1 = [x, y]\n    elif y > e_max2[1]:\n        e_max2 = [x, y]\n\nfor x, y in list(c_odd.items()):\n    if y > o_max1[1]:\n        o_max2 = o_max1\n        o_max1 = [x, y]\n    elif y > o_max2[1]:\n        o_max2 = [x, y]\n\n\nif e_max1[0] == o_max1[0]:\n    print((min(n - e_max1[1] - o_max2[1], n - e_max2[1] - o_max1[1])))\nelse:\n    print((n - e_max1[1] - o_max1[1]))\n", "from collections import Counter\n\nn = int(input())\nlist_A = list(map(int, input().split()))\nL, R = [], []\n\nfor i in range(n):\n    if i % 2 == 0:\n        L.append(list_A[i])\n    else:\n        R.append(list_A[i])\n\nA = Counter(L)\nA = sorted(list(A.items()), key=lambda x:x[1], reverse=True)\nA.append((-1, 0))\n\nB = Counter(R)\nB = sorted(list(B.items()), key=lambda x:x[1], reverse=True)\nB.append((-1, 0))\n\nif A[0][0] != B[0][0]:\n    print((n - A[0][1] - B[0][1]))\nelse:\n    print((min(n - A[1][1] - B[0][1], n - A[0][1] - B[1][1])))\n", "n = int(input())\nV = list(map(int, input().split()))\nd={}\nfor i in range(0,n,2):\n    d[V[i]] = d.get(V[i], 0)+1\nm1 = 0\no = 0\no2 = 0\nfor i in d:\n    if m1 <= d[i]:\n        m1 = d[i]\n        o = i\nd[o] = 0\nm2 = -1\nfor i in d:\n    if m2 <= d[i]:\n        m2 = d[i]\n        o2 = i\n    \nd = {}\nfor i in range(1,n,2):\n    d[V[i]] = d.get(V[i], 0)+1\nm3 = 0\ne = 0\ne2 = 0\nfor i in d:\n    if m3 <= d[i]:\n        m3 = d[i]\n        e = i\nd[e] = 0\nm4 = -1\nfor i in d:\n    if m4 <= d[i]:\n        m4 = d[i]\n        e2 = i\n\nif e!=o:\n    print(n - m1 - m3)\nelse:\n    print(min(n-m1-m4, n-m2-m3))", "import collections\n\nn=int(input())\nm=n//2\na=list(map(int,input().split()))\ng=[]\nk=[]\nfor x in range(n):\n  if (x+1)%2==1:\n    k.append(a[x])\n  else:\n    g.append(a[x])\n    \ngg=collections.Counter(g)\nkk=collections.Counter(k)\naa=collections.Counter(a)\n\nif len(aa)==1:\n  print((n//2))\n  \nelse:\n  if gg.most_common()[0]==kk.most_common()[0]:\n    if len(gg)>1 and len(kk)>1:\n      print((min(m-gg.most_common()[0][1]+m-kk.most_common()[1][1],m-kk.most_common()[0][1]+m-gg.most_common()[1][1])))\n    elif len(gg)==1:\n      print((m-kk.most_common()[1][1]))\n    else:\n      print((m-gg.most_common()[1][1]))\n  else:\n    print((n-gg.most_common()[0][1]-kk.most_common()[0][1]))\n", "from collections import Counter\nn = int(input())\nv = list(map(int, input().split()))\nl,r = Counter(v[0::2]).most_common(), Counter(v[1::2]).most_common()\nl.append((0,0))\nr.append((0,0))\nif l[0][0] != r[0][0]:\n  print(n-(l[0][1]+r[0][1]))\nelse:\n  print(min(n-(l[1][1]+r[0][1]), n-(l[0][1]+r[1][1])))", "import collections\n\nn=int(input())\nm=n//2\na=list(map(int,input().split()))\ng=[]\nk=[]\nfor x in range(n):\n  if (x+1)%2==1:\n    k.append(a[x])\n  else:\n    g.append(a[x])\n    \ngg=collections.Counter(g)\nkk=collections.Counter(k)\naa=collections.Counter(a)\n\nif len(aa)==1:\n  print((n//2))\n  \nelse:\n  if gg.most_common()[0]==kk.most_common()[0]:\n    \n      print((min(m-gg.most_common()[0][1]+m-kk.most_common()[1][1],m-kk.most_common()[0][1]+m-gg.most_common()[1][1])))\n   \n     \n  else:\n    print((n-gg.most_common()[0][1]-kk.most_common()[0][1]))\n", "import collections\nN = int(input())\n\nO = []\nE = []\nA = list([int(a) for a in input().split(\" \")])\nfor i in range(N):\n  if i % 2 == 0:\n    E.append(A[i])\n  else:\n    O.append(A[i])\n\nCE = collections.Counter(E)\nCO = collections.Counter(O)\nCE2 = CE.most_common(2)\nCO2 = CO.most_common(2)\nif CE2[0][0] != CO2[0][0]:\n  print((len(E) + len(O) - CE2[0][1] - CO2[0][1]))\nelif CE2[0][0] == CO2[0][0]:\n  if len(CE2) == 1 and len(CO2) == 1:\n    print((min([CE2[0][1], CO2[0][1]])))\n  elif len(CE2) > 1 and len(CO2) == 1:\n    print((len(E) + len(O) - CE2[1][1] - CO2[0][1]))\n  elif len(CE2) == 1 and len(CO2) > 1:\n    print((len(E) + len(O) - CE2[0][1] - CO2[1][1]))\n  elif CE2[0][1] + CO2[1][1] > CO2[0][1] + CE2[1][1]:\n    print((len(E) + len(O) - CE2[0][1] - CO2[1][1]))\n  elif CE2[0][1] + CO2[1][1] <= CO2[0][1] + CE2[1][1]:\n    print((len(E) + len(O) - CE2[1][1] - CO2[0][1]))\n", "from collections import Counter\n\nn = int(input())\nv = list(map(int, input().split()))\n\nif len(set(v)) <= 1:\n    print((int(n/2)))\n    return\n\nodd = [v[i] for i in range(0, n, 2)]\nodd_val, odd_cnt = list(zip(*Counter(odd).most_common()))\n\neven = [v[i] for i in range(1, n, 2)]\neven_val, even_cnt = list(zip(*Counter(even).most_common()))\n\nif even_val[0] != odd_val[0]:\n    ans = n-even_cnt[0]-odd_cnt[0]\nelse:\n    if (even_cnt[0] + odd_cnt[1]) >= (even_cnt[1] + odd_cnt[0]):\n        ans = n-even_cnt[0]-odd_cnt[1]\n    else:\n        ans = n-even_cnt[1]-odd_cnt[0]\nprint(ans)\n", "from collections import Counter\nn = int(input())\nv = list(map(int, input().split()))\na = v[1::2]\nb = v[0::2]\na2 = Counter(a)\nb2 = Counter(b)\n\nif a2.most_common()[0][0] != b2.most_common()[0][0]:\n    print((n-a2.most_common()[0][1]-b2.most_common()[0][1]))\nelse:\n    if len(a2.most_common()) == len(b2.most_common()) == 1:\n        print((len(a)-a2.most_common()[0][1]+len(b)))\n    elif len(a2.most_common()) == 1:\n        if len(b)-b2.most_common()[1][1] >= len(a)+len(b)-b2.most_common()[0][1]:\n            print((len(a)+len(b)-b2.most_common()[0][1]))\n        else:\n            print((len(b)-b2.most_common()[1][1]))\n    elif len(b2.most_common()) == 1:\n        if len(a)-a2.most_common()[1][1] >= len(a)+len(b)-a2.most_common()[0][1]:\n            print((len(a)+len(b)-a2.most_common()[0][1]))\n        else:\n            print((len(a)-a2.most_common()[1][1]))\n    else:\n        if len(a)-a2.most_common()[0][1]+len(b)-b2.most_common()[1][1] >= len(a)-a2.most_common()[1][1]+len(b)-b2.most_common()[0][1]:\n            print((len(a)-a2.most_common()[1][1]+len(b)-b2.most_common()[0][1]))\n        else:\n            print((len(a)-a2.most_common()[0][1]+len(b)-b2.most_common()[1][1]))\n\n", "#!/usr/bin/env python3\n\n#import\n#import math\n#import numpy as np\nn = int(input())\nV = list(map(int, input().split()))\n\neven = {0:0}\nodd = {0:0}\n\nfor i in range(n):\n    v = V[i]\n    if i % 2 == 0:\n        if v in even:\n            even[v] += 1\n        else:\n            even[v] = 1\n    else:\n        if v in odd:\n            odd[v] += 1\n        else:\n            odd[v] = 1\n\nomax = 0\nemax = 0\nonext = 0\nenext = 0\n\nfor e in even:\n    if even[e] > even[emax]:\n        if even[emax] > even[enext]:\n            enext = emax\n        emax = e\n    elif even[e] > even[enext]:\n        enext = e\n\nfor o in odd:\n    if odd[o] > odd[omax]:\n        if odd[omax] > odd[onext]:\n            onext = omax\n        omax = o\n    elif odd[o] > odd[onext]:\n        onext = o\n\nif omax != emax:\n    print((n - even[emax] - odd[omax]))\nelse:\n    print((n - even[emax] - odd[omax] + min(even[emax] - even[enext], odd[omax] - odd[onext])))\n", "N = int(input())\nV = list(map(int,input().split()))\n\nfrom collections import Counter\n\ndef get_counter(X):\n  counter = Counter(X)\n  X = counter.most_common()\n  X.append((0,0))\n  return X\n\nV1 = get_counter(V[::2])\nV2 = get_counter(V[1::2])\n\nif V1[0][0] != V2[0][0]:\n  print((N - (V1[0][1] + V2[0][1])))\nelse:\n  print((N - max(V1[0][1] + V2[1][1],V1[1][1] + V2[0][1])))\n", "n=int(input())\na=list(map(int,input().split()))\nl1=[0]*100001\nl2=[0]*100001\nif a.count(a[0])==n:\n    print((n//2))\n    return\n\nfor i in range(0,n,2):\n    l1[a[i]]+=1\nfor i in range(1,n,2):\n    l2[a[i]]+=1\n\nx,y=max(l1),max(l2)\n#print(x,y)\ni_x,i_y=l1.index(x),l2.index(y)\n#print(i_x,i_y)\n\nL1=sorted(l1,reverse=True)\nL2=sorted(l2,reverse=True)\n\nif i_x == i_y:\n    #\u5947\u6570\u756a\u76ee\u30922\u756a\u76ee\u306b\u591a\u3044\u6570\u3067\u305d\u308d\u3048\u308b\u5834\u5408\n    ans=min(((n//2-L1[1])+(n//2-L2[0])),((n//2-L1[0])+(n//2-L2[1])))\nelse:\n    ans=((n//2-L1[0])+(n//2-L2[0]))\nprint(ans)\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# FileName: \tsample\n# CreatedDate:  2020-09-27 14:00:12 +0900\n# LastModified: 2020-09-27 14:35:21 +0900\n#\n\n\nimport os\nimport sys\n# import numpy as np\n# import pandas as pd\nfrom collections import Counter\n\n\ndef main():\n    n = int(input())\n    v = list(map(int, input().split()))\n    v_even = [v[i] for i in range(0, len(v), 2)]\n    v_odd = [v[i] for i in range(1, len(v), 2)]\n    even_cnt = sorted(map(list, list(Counter(v_even).items())), key=lambda x: x[1], reverse=True)\n    odd_cnt = sorted(map(list, list(Counter(v_odd).items())), key=lambda x: x[1], reverse=True)\n    odd_impo = 0\n    even_impo = 0\n    if len(even_cnt) == 1 and len(odd_cnt) == 1:\n        if even_cnt[0][0] == odd_cnt[0][0]:\n            if even_cnt[0][1] < odd_cnt[0][1]:\n                print((even_cnt[0][1]))\n                return\n\n            else:\n                print((even_cnt[0][1]))\n                return\n\n    if even_cnt[0][0] == odd_cnt[0][0]:\n        if even_cnt[0][1] == odd_cnt[0][1]:\n            if even_cnt[1][1] < odd_cnt[1][1]:\n                odd_impo = 1\n                even_impo = 0\n\n            elif even_cnt[1][1] > odd_cnt[1][1]:\n                odd_impo = 0\n                even_impo = 1\n\n            else:\n                odd_impo = 1\n                even_impo = 0\n\n        elif even_cnt[0][1] < odd_cnt[0][1]:\n            odd_impo = 0\n            even_impo = 1\n\n        else:\n            odd_impo = 1\n            even_impo = 0\n\n    ans = len(v_even) - even_cnt[even_impo][1] + len(v_odd) - odd_cnt[odd_impo][1]\n\n    print(ans)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import collections\nN = int(input())\nV = list(map(int, input().split()))\n\nans = 0\neve = V[0::2]\nodd = V[1::2]\ncntEve = collections.Counter(eve)\ncntOdd = collections.Counter(odd)\n\nif cntEve.most_common()[0][0] == cntOdd.most_common()[0][0]:\n    if len(cntEve) == 1 and len(cntOdd) > 1:\n        ans = N - max(cntEve.most_common()[0][1],cntOdd.most_common()[0][1]) - cntOdd.most_common()[1][1]\n    elif len(cntEve) > 1 and len(cntOdd) == 1:\n        ans = N - max(cntEve.most_common()[0][1],cntOdd.most_common()[0][1]) - cntEve.most_common()[1][1]\n    elif len(cntEve) == 1 and len(cntOdd) == 1:\n        ans = N - max(cntEve.most_common()[0][1],cntOdd.most_common()[0][1])\n    else:\n        ans = N - max(cntEve.most_common()[0][1],cntOdd.most_common()[0][1]) - max(cntEve.most_common()[1][1],cntOdd.most_common()[1][1])\nelse:\n    ans = N - int(cntEve.most_common()[0][1]) - int(cntOdd.most_common()[0][1])\n\nprint(ans)", "n=int(input())\n\nv=list(map(int,input().split()))\n\nlisa=[0 for _ in range(10**5)]\nlisb=[0 for _ in range(10**5)]\n\nfor i in range(n):\n  if i%2==0:\n    lisa[v[i]-1]+=1\n  else:\n    lisb[v[i]-1]+=1\n\nmaxnuma=-1\nmaxnumb=-1\n\nmaxa=max(lisa)\nmaxb=max(lisb)\n\n\nfor i in range(10**5):\n  if lisa[i]==maxa:\n    maxnuma=i\nfor i in range(10**5):\n  if lisb[i]==maxb:\n    maxnumb=i\n\n\nif maxnuma!=maxnumb:\n  print((n-maxa-maxb))\nelse:\n  lisa.sort(reverse=True)\n  lisb.sort(reverse=True)\n  print((n-max(lisa[0]+lisb[1],lisa[1]+lisb[0])))\n\n", "import collections\n\nn = int(input())\na = list(map(int,input().split()))\na1 = collections.Counter(a[0::2]).most_common()\na2 = collections.Counter(a[1::2]).most_common()\na1.append((0,0))\na2.append((0,0))\n#print(a1)\n#print(a2)\n\nif a1[0] != a2[0]:\n    print((n-a1[0][1]-a2[0][1]))\nelse:\n    print((min(n-a1[0][1]-a2[1][1],n-a1[1][1]-a2[0][1])))\n\n", "n = int(input())\nal = list(map(int, input().split()))\n\nol =al[::2]\nel =al[1::2]\n\nfrom collections import Counter\ncol = Counter(ol)\ncel = Counter(el)\nscol = sorted(col.items(), key=lambda x: x[1], reverse=True)  \nscel = sorted(cel.items(), key=lambda x: x[1], reverse=True)  \nscol.append((\"x\",0))\nscel.append((\"y\",0))\n\n\ntemp = scol[0][1] + scel[0][1]\n\nif scol[0][0]==scel[0][0]:\n    temp2 = scol[0][1]+scel[1][1]\n    temp3 = scol[1][1]+scel[0][1]\n    print(n-max(temp2,temp3))\n    \nelse:\n    print(n-temp)", "N=int(input())\n*V,=map(int,input().split())\nimport collections\n\nc1=collections.Counter(V[0::2]).most_common()\nc2=collections.Counter(V[1::2]).most_common()\nc1.append([0,0])\nc2.append([0,0])\nif c1[0][0]!=c2[0][0]:\n    print(N-c1[0][1]-c2[0][1])\nelse:\n    print(min(N-c1[0][1]-c2[1][1],N-c1[1][1]-c2[0][1]))", "n = int(input())\nl = list(map(int, input().split()))\na = {}\nb = {}\nfor i in range(n // 2):\n    key_a = l[i * 2]\n    key_b = l[i * 2 + 1]\n    if key_a in a:\n        a[key_a] = a[key_a] + 1\n    else:\n        a[l[i * 2]] = 1\n    if key_b in b:\n        b[key_b] = b[key_b] + 1\n    else:\n        b[key_b] = 1\na = sorted(a.items(), key=lambda x: x[1], reverse=True)\nb = sorted(b.items(), key=lambda x: x[1], reverse=True)\n# a = list(a.items())\n# b = list(b.items())\n# print(a)\n# print(b)\nca_max = a[0][0]\ncb_max = b[0][0]\nca_max_num = a[0][1]\ncb_max_num = b[0][1]\nsame_num = ca_max_num + cb_max_num\nif ca_max == cb_max:\n    if len(a) > 1:\n        next_ca_max = a[1][1]\n    else:\n        next_ca_max = 0\n    if len(b) > 1:\n        next_cb_max = b[1][1]\n    else:\n        next_cb_max = 0\n    same_num = max(ca_max_num + next_cb_max, cb_max_num + next_ca_max)\nprint(n - same_num)", "n=int(input())\nv=list(map(int,input().split()))\ncnt1=[0 for i in range(100001)]\ncnt2=[0 for i in range(100001)]\nfor i in range(n):\n    if i%2==0:\n        cnt1[v[i]]+=1\n    else:\n        cnt2[v[i]]+=1\nk1=0\nk1m=0\nk2=0\nk2m=0\nfor i in range(100001):\n    if cnt1[i]>=cnt1[k1]:\n        k1,k1m=i,k1\n    elif cnt1[i]>cnt1[k1m]:\n        k1m=i\nfor i in range(100001):\n    if cnt2[i]>=cnt2[k2]:\n        k2,k2m=i,k2\n    elif cnt2[i]>cnt2[k2m]:\n        k2m=i\nif k1!=k2:\n    print((n-cnt1[k1]-cnt2[k2]))\nelse:\n    print((n-(cnt1[k1]+max(cnt1[k1m],cnt2[k2m]))))\n", "from collections import Counter\nn = int(input())\nv = list(map(int,input().split()))\na = Counter(v[::2])\nb = Counter(v[1::2])\na = a.most_common()\nb = b.most_common()\na1 = a[0][1]\nb1 = b[0][1]\nif len(a) == 1:\n    a2 = 0\nelse:\n    a2 = a[1][1]\nif len(b) == 1:\n    b2 = 0\nelse:\n    b2 = b[1][1]\nif a[0][0] != b[0][0]:\n    print(n-(a1+b1))\nelse:\n    print(min(n-(a1+b2),n-(a2+b1)))", "from collections import Counter\nn = int(input())\nls = list(map(int,input().split()))\nlso = ls[::2]\nlse = ls[1::2]\nlso.sort()\nlse.sort(reverse=True)\nco = Counter(lso)\nce = Counter(lse)\nco1,co2 = co.most_common()[0][0],co.most_common()[0][1]\nce1,ce2 = ce.most_common()[0][0],ce.most_common()[0][1]\ncoo1,coo2,cee1,cee2 = 0,0,0,0\nif co2 != n//2:\n    coo1,coo2 = co.most_common()[1][0],co.most_common()[1][1]\nif ce2 != n//2:\n    cee1,cee2 = ce.most_common()[1][0],ce.most_common()[1][1]\nif co1 == ce1:\n    print(n-max(co2+cee2,ce2+coo2))\nelse:\n    print(n-co2-ce2)", "def find_max( list ):\n    x = 0\n    x2 = 0\n    x_i = 0\n    x2_i = 0\n    for i in range( len(list) ):\n        if x < list[i]:\n            x = list[i]\n            x_i = i\n    for i in range( len(list) ):\n        if i == x_i:\n            continue\n        if x2 < list[i] <= x:\n            x2 = list[i]\n            x2_i = i\n    return x,x2,x_i,x2_i\n\nn = int( input() )\nv = list ( int(x) for x in input().split() )\n\nv_sort = sorted( v )\n\nv_odd = [ 0 for i in range( v_sort[-1] + 1 ) ]\n#\u5947\u6570\nv_eve = [ 0 for i in range( v_sort[-1] + 1 ) ]\n#\u5076\u6570\nfor i in range( n ):\n    if i % 2 == 0:\n        v_eve[ v[i] ] += 1\n    if i % 2 == 1:\n        v_odd[ v[i] ] += 1\n\nvex,vex2,vex_i,vex2_i = find_max( v_eve )\nvox,vox2,vox_i,vox2_i = find_max( v_odd )\n\nok = 0\n# ok: figure that need not to fix\nif vex_i != vox_i:\n    ok = vex + vox\nelse:\n    ok = max( vex + vox2 , vex2 + vox )\n\nans = n - ok\nprint( ans )", "n=int(input())\nv=list(map(int,input().split()))\nimport collections as col\no=col.Counter(v[0:n:2])\ne=col.Counter(v[1:n:2])\nook=o.most_common()\neok=e.most_common()\nok=ook[0][1]+eok[0][1]\nif ook[0][0]==eok[0][0]:\n    if len(ook)<2 and len(eok)<2:\n        print(n//2)\n        return\n    elif len(ook)<2:\n        ok=ook[0][1]+eok[1][1]\n    elif len(eok)<2:\n        ok=ook[1][1]+eok[0][1]\n    else:\n        ok=max(ook[0][1]+eok[1][1],ook[1][1]+eok[0][1])\nprint(n-ok)", "import collections\nN = int(input())\nN_List = list(map(int,input().split()))\nhanN = N//2\nki = N_List[1::2]\ngu = N_List[0::2]\nkicnt = collections.Counter(ki)\ngucnt = collections.Counter(gu)\n\nkidict = kicnt.most_common()\ngudict = gucnt.most_common()\n\nkilen = len(kidict)\ngulen = len(gudict)\n\nif kilen == 1 & gulen == 1:\n    if kidict == gudict:\n        ans = hanN\n    else:\n        ans = 0\nelif kidict[0][0] == gudict[0][0]:\n    if kidict[0][1] > gudict[0][1]:\n        ans = sum(map(lambda x:x[1],kidict[1:])) + sum(map(lambda x:x[1],gudict[2:])) + gudict[0][1]\n    elif kidict[0][1] < gudict[0][1]:\n        ans = sum(map(lambda x:x[1],gudict[1:])) + sum(map(lambda x:x[1],kidict[2:])) + kidict[0][1]\n    else:\n        if gudict[1][1] >= kidict[1][1]:\n            ans = sum(map(lambda x:x[1],kidict[1:])) + sum(map(lambda x:x[1],gudict[2:])) + gudict[0][1]\n        else:\n            ans = sum(map(lambda x:x[1],gudict[1:])) + sum(map(lambda x:x[1],kidict[2:])) + kidict[0][1]\nelse:\n    ans = sum(map(lambda x:x[1],gudict[1:])) + sum(map(lambda x:x[1],kidict[1:]))\n\nprint(ans)", "import copy\nimport numpy as np\n\nn = int(input())\nv = list(map(int,input().split()))\na = v[0::2] \nb = v[1::2]\n\ncnta = np.zeros(10**5+1, dtype=int)\ncntb = np.zeros(10**5+1, dtype=int)\nfor i in range(n//2):\n    ca, cb = a[i], b[i]\n    cnta[ca] += 1\n    cntb[cb] += 1\n\nla = np.zeros((2,2), dtype=int)\nlb = np.zeros((2,2), dtype=int)\nfor i in range(2):\n    ia = cnta.argmax()\n    ib = cntb.argmax()\n    la[i][0], la[i][1] = ia, cnta[ia]\n    lb[i][0], lb[i][1] = ib, cntb[ib]\n    cnta[ia] = 0\n    cntb[ib] = 0\n\nif la[0][0] != lb[0][0]:\n    ans = n//2 - la[0][1] + n//2 - lb[0][1]\nelse:\n    ans = min(n//2 - la[0][1] + n//2 - lb[1][1], n//2 - la[1][1] + n//2 - lb[0][1])\nprint(ans)\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Sep 17 20:29:30 2020\n\n@author: liang\n\"\"\"\n\nn = int(input())\nE = list()\nO = list()\ni = 0\nfor v in input().split():\n    if i%2 == 0:\n        E.append(int(v))\n    else:\n        O.append(int(v))\n    i += 1\n#print(E)\n#print(O)\nedic = {-1:0}\nodic = {-1:0}\nfor e in E:\n    if e not in edic.keys():\n        edic[e] = 1\n    else:\n        edic[e] += 1\n\nfor o in O:\n    if o not in odic.keys():\n        odic[o] = 1\n    else:\n        odic[o] += 1\n\netup = list()\notup = list()\nfor e in edic.keys():\n    etup.append((e,edic[e]))\nfor o in odic.keys():\n    otup.append((o,odic[o]))    \netup.sort(reverse=True,key=lambda x:x[1])\notup.sort(reverse=True,key=lambda x:x[1])\n\n#print(etup)\n#print(otup)\ni = 0\nj = 0\nwhile True:\n    ekey, etmp = etup[i]\n    okey, otmp = otup[j]\n    if ekey != okey:\n        break\n    if etup[i+1][1] < otup[j+1][1]:\n        j += 1\n    else:\n        i += 1\n    #rint(\"calc\")\n\n#print(edic)\n\nans = n - etmp - otmp\n    \nprint(ans)", "from collections import Counter\nn = int(input())\nv = list(map(int ,input().split()))\n\no = Counter(v[::2]).most_common() # \u5076\u6570\u5217\u306e\u6700\u983b\u5024\u306e\u9806\u306b\u4e26\u3079\u308b\ne = Counter(v[1::2]).most_common() # \u5947\u6570\u5217\u306e\u6700\u983b\u5024\u306e\u9806\u306b\u4e26\u3079\u308b\n\nif o[0][0] == e[0][0]: # \u6700\u983b\u5024\u304c\u5076\u6570\u5217\u3068\u5947\u6570\u5217\u3067\u540c\u3058\u304b\u3069\u3046\u304b\u5224\u5b9a\n  if len(o) == 1: print(n//2) # \u5024\u306e\u30d0\u30ea\u30a8\u30fc\u30b7\u30e7\u30f3\u304c\u6700\u983b\u5024\u306e\u307f\u306e\u5834\u5408\u306f\u7247\u65b9\u306e\u6570\u5217\u3092\u66f8\u304d\u63db\u3048\u3066\u7d42\u308f\u308a\n  else:\n    # \u6700\u7d42\u7684\u306b\u6570\u5217\u4e0a\u306b\u6b8b\u308b\u5024\u306e\u7a2e\u985e\u306f2\u7a2e\u985e\u306e\u307f\u306e\u70ba\u3001\u4e0a\u4f4d2\u7a2e\u306e\u5024\u3078\u5168\u3066\u63c3\u3048\u308b\n    # \u4e0b\u8a18\u306e2\u30d1\u30bf\u30fc\u30f3\u3067\u66f8\u304d\u63db\u3048\u308b\u6570\u304c\u5c11\u306a\u3044\u65b9\u304c\u56de\u7b54\u306b\u306a\u308b\n    o1,o2 = e[0][1], e[1][1]\n    e1,e2 = o[0][1], o[1][1]\n    \n    ans = min(n-e1-o2, n-e2-o1)\n    print(ans)\nelse:\n  print(n - o[0][1] - e[0][1]) #\u6700\u983b\u5024\u304c\u7570\u306a\u308b\u5834\u5408\u306f\u3001\u5168\u4f53\u306e\u6570\u304b\u3089\u305d\u308c\u305e\u308c\u306e\u6700\u983b\u5024\u306e\u6570\u3092\u5f15\u304f", "import collections\nn = int(input())\na = [int(x) for x in input().split()]\neven = []\nuneven = []\nfor i in range(n):\n  if i%2 == 0:\n    uneven.append(a[i])\n    continue\n  even.append(a[i])\n\nuneven_counter = collections.Counter(uneven)\nsortede_uneven_counter = sorted(uneven_counter.items(),key=lambda x:x[1],reverse=True)\neven_counter = collections.Counter(even)\nsortede_even_counter = sorted(even_counter.items(),key=lambda x:x[1],reverse=True)\n  \nans = (n/2 - sortede_uneven_counter[0][1]) + (n/2 - sortede_even_counter[0][1])\n\nif sortede_uneven_counter[0][0] == sortede_even_counter[0][0]:\n  if len(set(a)) == 1:\n    ans = n/2\n  elif sortede_uneven_counter[0][0] ==sortede_even_counter[0][0]:\n    ans = (n/2 - sortede_uneven_counter[1][1]) + (n/2 - sortede_even_counter[0][1])\n    ans2 = (n/2 - sortede_uneven_counter[0][1]) + (n/2 - sortede_even_counter[1][1])\n    if ans2<ans:\n      ans = ans2\n\nprint(int(ans))", "n=int(input())\nl=list(map(int, input().split()))\nl1=l[0::2]\nl2=l[1::2]\nimport collections\nc1 = collections.Counter(l1)\n#print(c1)\n# Counter({'a': 4, 'c': 2, 'b': 1})\nc2 =collections.Counter(l2)  \nc0 =collections.Counter(l)\nif len(c0)==1:\n  print((int(n/2)))\nelse:\n  if c1.most_common()[0]==c2.most_common()[0]:\n    print((min(n-c1.most_common()[0][1]-c2.most_common()[1][1], n-c1.most_common()[1][1]-c2.most_common()[0][1])))\n  else:\n    print((n-c1.most_common()[0][1]-c2.most_common()[0][1]))\n    \n", "from collections import Counter\ndef main():\n    N = int(input())\n    V = [int(a) for a in input().split()]\n    \n    even = list()\n    odd = list()\n\n    for i in range(N):\n        if (i + 1) % 2 == 0:\n            odd.append(V[i])\n        else:\n            even.append(V[i])\n\n    even_counter = Counter(even).most_common()\n    odd_counter = Counter(odd).most_common()\n\n    ans = 0\n    if even_counter[0][0] != odd_counter[0][0]:\n        if len(even_counter) >= 2:\n            ans += len(even) - even_counter[0][1]\n\n        if len(odd_counter) >= 2:\n            ans += len(odd) - odd_counter[0][1]\n\n    else:\n        if len(even_counter) == 1 and len(odd_counter) == 1:\n            ans += even_counter[0][1]\n\n        elif len(even_counter) == 1 and len(odd_counter) >= 2:\n            ans += len(odd) - odd_counter[1][1]\n\n        elif len(even_counter) >= 2  and len(odd_counter) == 1:\n            ans += len(even) - even_counter[1][1]\n\n        elif len(even_counter) >= 2 and len(odd_counter) >= 2:\n            cost_even = len(even) - even_counter[0][1] + len(odd)  - odd_counter[1][1]\n            cost_odd  = len(odd)  - odd_counter[0][1]  + len(even) - even_counter[1][1]\n\n            ans += min(cost_even, cost_odd)\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "import collections\nurl = \"https://atcoder.jp//contests/abc111/tasks/arc103_a\"\n\ndef main():\n    input()\n    t = list(map(int, input().split()))\n    even_lis = t[::2]\n    odd_lis = t[1::2]\n    e = collections.Counter(even_lis).most_common()\n    odd = collections.Counter(odd_lis).most_common()\n    if e[0][0] == odd[0][0]:\n        if e[0][1] + odd[0][1] == len(t):\n            print((e[0][1]))\n            return\n        else:\n            print((len(t) - max(e[0][1], odd[0][1]) - max(e[1][1], odd[1][1])))\n            return\n    else:\n        print((len(t) - e[0][1] - odd[0][1]))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nv = list(map(int, input().split()))\nodd = dict()\neven = dict()\nodd[-1] = 0\neven[-1] = 0\n\nfor i in range(n):\n    if (i + 1) % 2 == 1:\n        if v[i] not in odd:\n            odd[v[i]] = 1\n        else:\n            odd[v[i]] += 1\n    else:\n        if v[i] not in even:\n            even[v[i]] = 1\n        else:\n            even[v[i]] += 1\n\nodd_values = sorted(list(odd.values()), reverse=True)\nfor key, val in list(odd.items()):\n    if val == odd_values[0]:\n        odd_1 = key\n    elif val == odd_values[1]:\n        odd_2 = key\n\neven_values = sorted(list(even.values()), reverse=True)\nfor key, val in list(even.items()):\n    if val == even_values[0]:\n        even_1 = key\n    elif val == even_values[1]:\n        even_2 = key\n\nif odd_1 != even_1:\n    res = n - odd_values[0] - even_values[0]\nelse:\n    res = min(n - odd_values[0] - even_values[1], \n              n - odd_values[1] - even_values[0])\nprint(res)\n# print(odd)\n# print(even)\n", "import sys\nfrom collections import Counter\n\n\nstdin = sys.stdin\ndef ns(): return stdin.readline().rstrip()\ndef ni(): return int(stdin.readline().rstrip())\ndef nm(): return list(map(int, stdin.readline().split()))\ndef nl(): return list(map(int, stdin.readline().split()))\n\n\ndef get_ans(v, ans):\n    while len(v) != 1:\n        ans += v.pop()\n    return ans\n\n\ndef main():\n    n = ni()\n    V = nl()\n    V_e = V[0::2]\n    V_o = V[1::2]\n    V_e_c = Counter(V_e)\n    V_o_c = Counter(V_o)\n    # num_V_e = sorted(list(V_e_c.values()))[::-1]\n    # num_V_o = sorted(list(V_o_c.values()))[::-1]\n\n    if V_e_c.most_common()[0][0] != V_o_c.most_common()[0][0]:\n        ans = len(V) - \\\n            V_e_c.most_common()[0][1] - V_o_c.most_common()[0][1]\n\n    else:\n        if len(V_e_c.most_common()) == 1 or len(V_o_c.most_common()) == 1:\n            if len(V_e_c.most_common()) == 1 and len(V_o_c.most_common()) == 1:\n                ans = len(V) // 2\n            else:\n                if len(V_e_c.most_common()) != 1:\n                    ans = len(V) // 2 - V_e_c.most_common()[1][1]\n                else:\n                    ans = len(V) // 2 - V_o_c.most_common()[1][1]\n\n        else:\n            ans = len(V) - max(\n                V_e_c.most_common()[0][1] + V_o_c.most_common()[1][1],\n                V_e_c.most_common()[1][1] + V_o_c.most_common()[0][1],\n            )\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nV = list(map(int, input().split()))\nodd_dict = {}\neven_dict = {}\nfor i in range(N):\n    if i % 2 == 0:\n        if odd_dict.get(V[i]) is None:\n            odd_dict[V[i]] = 1\n        else:\n            odd_dict[V[i]] += 1\n    else:\n        if even_dict.get(V[i]) is None:\n            even_dict[V[i]] = 1\n        else:\n            even_dict[V[i]] += 1\n\nodd_dict_sorted = sorted(list(odd_dict.items()), key=lambda a: a[1])\neven_dict_sorted = sorted(list(even_dict.items()), key=lambda a: a[1])\n\nodd_dict_max = odd_dict_sorted.pop()\neven_dict_max = even_dict_sorted.pop()\nif odd_dict_max[0] == even_dict_max[0] and N // 2 == odd_dict_max[1]:\n    ans = N // 2\nelif odd_dict_max[0] == even_dict_max[0]:\n    odd_dict_max_t = odd_dict_sorted.pop()\n    even_dict_max_t = even_dict_sorted.pop()\n    ans = N - odd_dict_max[1] - max(even_dict_max_t[1],odd_dict_max_t[1])\nelse:\n    ans = N - odd_dict_max[1] - even_dict_max[1]\nprint(ans)\n", "from collections import Counter\ndef main():\n    N = int(input())\n    V = [int(a) for a in input().split()]\n    \n    even = list()\n    odd = list()\n\n    for i in range(N):\n        if (i + 1) % 2 == 0:\n            odd.append(V[i])\n        else:\n            even.append(V[i])\n\n    even_counter = Counter(even).most_common()\n    odd_counter = Counter(odd).most_common()\n\n    ans = 0\n    if even_counter[0][0] != odd_counter[0][0]:\n        if len(even_counter) >= 2:\n            ans += len(even) - even_counter[0][1]\n\n        if len(odd_counter) >= 2:\n            ans += len(odd) - odd_counter[0][1]\n\n    else:\n        if len(even_counter) == 1 and len(odd_counter) == 1:\n            ans += even_counter[0][1]\n\n        elif len(even_counter) == 1 and len(odd_counter) >= 2:\n            ans += len(odd) - odd_counter[1][1]\n\n        elif len(even_counter) >= 2  and len(odd_counter) == 1:\n            ans += len(even) - even_counter[1][1]\n\n        elif len(even_counter) >= 2 and len(odd_counter) >= 2:\n            cost_even = len(even) - even_counter[0][1] + len(odd)  - odd_counter[1][1]\n            cost_odd  = len(odd)  - odd_counter[0][1]  + len(even) - even_counter[1][1]\n            ans += min(cost_even, cost_odd)\n\n    print(ans)\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import Counter\nn = int(input())\nv = list(map(int, input().split()))\n\no = Counter(v[::2]).most_common()\ne = Counter(v[1::2]).most_common()\nif o[0][0] == e[0][0]:\n  if len(o) == 1: print(e[0][1])\n  else:\n    o1,o2 = e[0][1], e[1][1]\n    e1,e2 = o[0][1], o[1][1]\n  \n    ans = min(n-o1-o2, n-e1-e2)\n    print(ans)\nelse: print(n-o[0][1]-e[0][1])", "from collections import Counter\nn = int(input())\nv = list(map(int, input().split()))\n\nv1 = Counter(v[::2])\nv2 = Counter(v[1::2])\nv1 = sorted(list(v1.items()), key=lambda x: x[1])\nv2 = sorted(list(v2.items()), key=lambda x: x[1])\n\nans_1 = 0\n\nif v1[-1][0]==v2[-1][0]:\n    ans_1 += v1[-1][1]\n    v1 = v1[:-1]\n\nif len(v1)>=2:\n    for i, j in v1[:-1]:\n        ans_1 += j\n\nif len(v2)>=2:\n    for i, j in v2[:-1]:\n        ans_1 += j\n\nv1 = Counter(v[::2])\nv2 = Counter(v[1::2])\nv1 = sorted(list(v1.items()), key=lambda x: x[1])\nv2 = sorted(list(v2.items()), key=lambda x: x[1])\n\nans_2 = 0\n\nif v1[-1][0]==v2[-1][0]:\n    ans_2 += v2[-1][1]\n    v2 = v2[:-1]\n\nif len(v2)>=2:\n    for i, j in v2[:-1]:\n        ans_2 += j\n\nif len(v1)>=2:\n    for i, j in v1[:-1]:\n        ans_2 += j\n\nprint(min(ans_1, ans_2))", "import sys, bisect, math, itertools, string, queue, copy\n#import numpy as np\n#import scipy\nfrom collections import Counter,defaultdict,deque\nfrom itertools import permutations, combinations\nfrom heapq import heappop, heappush\nfrom fractions import gcd\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\ndef inp(): return int(input())\ndef inpm(): return list(map(int,input().split()))\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\ndef inplm(n): return list(int(input()) for _ in range(n))\ndef inplL(n): return [list(input()) for _ in range(n)]\ndef inplT(n): return [tuple(input()) for _ in range(n)]\ndef inpll(n): return [list(map(int, input().split())) for _ in range(n)]\ndef inplls(n): return sorted([list(map(int, input().split())) for _ in range(n)])\n\nn = inp()\na = inpl()\n\ncnt_even = Counter(a[::2]).most_common()+[(0,0)]\ncnt_odd = Counter(a[1::2]).most_common()+[(0,0)]\n\nans = 0\nif cnt_even[0][0] == cnt_odd[0][0]:\n  ans = n - max(cnt_even[0][1],cnt_odd[0][1]) - max(cnt_even[1][1],cnt_odd[1][1])\nelse:\n  ans = n - cnt_even[0][1] - cnt_odd[0][1]\n\nprint(ans)\n", "import sys\nfrom collections import Counter\nfrom operator import itemgetter\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    n, *V = list(map(int, read().split()))\n\n    counter1 = Counter(V[::2])\n    counter2 = Counter(V[1::2])\n\n    vec1 = sorted(list(counter1.items()), reverse=True, key=itemgetter(1))\n    vec2 = sorted(list(counter2.items()), reverse=True, key=itemgetter(1))\n\n    if vec1[0][0] != vec2[0][0]:\n        ans = n - vec1[0][1] - vec2[0][1]\n    elif len(vec1) == len(vec2) == 1:\n        ans = n // 2\n    else:\n        tmp = []\n        if len(vec1) > 1:\n            tmp.append(vec1[1][1] + vec2[0][1])\n        if len(vec2) > 1:\n            tmp.append(vec1[0][1] + vec2[1][1])\n        ans = n - max(tmp)\n\n    print(ans)\n\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from  collections import Counter\n\nn = int(input())\nv = list(map(int, input().split()))\n\nc = Counter(v[::2])\nd = Counter(v[1::2])\n\nx = c.most_common()\ny = d.most_common()\n\ns = 0\n\nif x[0][0] == y[0][0]:\n    if len(x) > 1 and len(y) > 1:\n        s = min(n - x[0][1] - y[1][1], n - x[1][1] - y[0][1])\n    elif len(x) > 1:\n        s = n - x[1][1] - y[0][1]\n    elif len(y) > 1:\n        s = n - x[0][1] - y[1][1]\n    else:\n        s = n // 2\nelse:\n    s = n - x[0][1] - y[0][1]\n\nprint(s)", "n = int(input())\nv = list(map(int,input().split()))\n\nv1 = [v[i] for i in range(n) if i%2 == 1]\nv2 = [v[i] for i in range(n) if i%2 == 0]\n            \nimport collections\n\nv1n = collections.Counter(v1)\nv2n = collections.Counter(v2)\n\nv1ns = v1n.most_common(2)\nv2ns = v2n.most_common(2)\n\na = v2ns[0][1]\nc = v1ns[0][1]\nif v1ns[0][0]!=v2ns[0][0]:\n    print(n-a-c)\nelse:\n    if len(v1ns)==1:\n        d = 0\n    else:\n        d = v1ns[1][1]\n    if len(v2ns)==1:\n        b = 0\n    else:\n        b = v2ns[1][1]\n    print(min(n-a-d,n-c-b))", "import collections\nn = int(input())\nv = list(map(int, input().split()))\neven = [v[2*i] for i in range(n//2)]\nodd = [v[2*i+1] for i in range(n//2)]\ndEven = collections.Counter(even).most_common()\ndOdd = collections.Counter(odd).most_common()\nif dEven[0][0] != dOdd[0][0]:\n    ans = n - dEven[0][1]  - dOdd[0][1]\nelse:\n    if len(dEven) >=2 and len(dOdd) >= 2:\n        ans = n - max(dEven[0][1]+dOdd[1][1], dEven[1][1]+dOdd[0][1])\n    elif len(dEven) < len(dOdd):\n        ans = n - (dEven[0][1]+dOdd[1][1])\n    elif len(dEven) > len(dOdd):\n        ans = n - (dEven[1][1]+dOdd[0][1])\n    else:\n        ans = n//2\nprint(ans)", "from collections import Counter\nn = int(input())\nv_lis = list(map(int,input().split()))\n\nv_odd = [0] * (n // 2)\nv_even = [0] * (n // 2)\n\nfor i in range(n):\n  if (i + 1) % 2 == 1:\n    v_odd[i//2] += v_lis[i]\n  else:\n    v_even[i//2] += v_lis[i]\n    \nv_odd, v_even = Counter(v_odd).most_common(), Counter(v_even).most_common()\n\nif v_odd[0][0] != v_even[0][0]:\n  cnt = v_odd[0][1] + v_even[0][1]\n\nelse:\n  tmp1 = v_odd[0][1] + (v_even[1][1] if len(v_even) >= 2 else 0)\n  tmp2 = v_even[0][1] + (v_odd[1][1] if len(v_odd) >= 2 else 0)\n  cnt = max(tmp1, tmp2)\n\nprint(n - cnt)", "#!/usr/bin/env python3\nfrom collections import Counter\n# from numba import njit\n\n# input = stdin.readline\n\n# @njit\ndef solve(n,v):\n  if all(x == v[0] for x in v):\n    return n//2\n  v_even = v[::2]\n  v_odd  = v[1::2]\n\n  d_even = list(sorted(list(Counter(v_even).items()),key=lambda x: x[1],reverse=True))\n  d_odd  = list(sorted(list(Counter(v_odd).items()),key=lambda x: x[1],reverse=True))\n  e0 = d_even[0]\n  o0 = d_odd[0]\n  if e0[0] != o0[0]:\n    return n - e0[1] - o0[1]\n  e1 = d_even[1]\n  o1 = d_odd[1]\n  return min(n-e0[1]-o1[1],n-e1[1]-o0[1])\n\n\n\ndef main():\n  N = int(input())\n  # N,M = map(int,input().split())\n  v = list(map(int,input().split()))\n  print((solve(N,v)))\n  return\n\ndef __starting_point():\n  main()\n\n__starting_point()", "from collections import defaultdict\nODD = defaultdict(int)\nEVEN = defaultdict(int)\nALL = set([])\nN = int(input())\n\nA = list(map(int,input().split()))\nfor i in range(N):\n  ALL.add(A[i])\n  if i%2 == 0:\n    EVEN[A[i]] += 1\n  else:\n    ODD[A[i]] += 1\nif len(ALL) == 1:\n  ans = N//2\n  print(ans)\n  return\nmodd = max(ODD.values())\nmeven = max(EVEN.values())\nmlodd = [];mleven = []\ndicodd = sorted(list(ODD.items()), key=lambda x:x[1], reverse = True)\ndiceven = sorted(list(EVEN.items()), key=lambda x:x[1], reverse = True)\nans = N\nif len(dicodd) > 1:\n  X = [dicodd[0],dicodd[1]]\nelse:\n  X = [dicodd[0]]\nif len(diceven) > 1:\n  Y = [diceven[0],diceven[1]]\nelse:\n  Y = [diceven[0]]\n#print(X)\n#print(Y)\nfor x,v in X:\n  for y,w in Y:\n    if x == y:\n      continue\n    temp = N-(v+w)\n    ans = min(ans,temp)\n\nprint(ans)\n\n\n", "from collections import Counter\nn=int(input())\na=list(map(int,input().split()))\n\nf=Counter(a[0::2]).most_common(2)\nb=Counter(a[1::2]).most_common(2)\n\nif f[0][0]!=b[0][0]:print(n-f[0][1]-b[0][1]);return\n\nif f[0][1]==n//2:print(n//2)\nelse:print(n-b[0][1]-f[1][1] if f[1][1]>b[1][1] else n-f[0][1]-b[1][1])", "N=int(input())\n*V,=map(int,input().split())\nfrom collections import Counter\n\nc1=Counter(V[0::2]).most_common()+[(0,0)]\nc2=Counter(V[1::2]).most_common()+[(0,0)]\nif c1[0][0]!=c2[0][0]:\n    print(N-c1[0][1]-c2[0][1])\nelse:\n    print(min(N-c1[0][1]-c2[1][1],N-c1[1][1]-c2[0][1]))", "n=int(input())\na=[int(i) for i in input().split()]\n\none=[]\ntwo=[]\n\nfor i in range(n):\n    if i%2==0:\n        one.append(a[i])\n    else:\n        two.append(a[i])\n\none_count=[0]*(10**5+1)\ntwo_count=[0]*(10**5+1)\n\nfor i in one:\n    one_count[i]+=1\nfor i in two:\n    two_count[i]+=1\n\none_first_index=0\none_max_count=0\nfor i,value in enumerate(one_count):\n    if one_max_count<value:\n        one_max_count=value\n        one_first_index=i\none_second_index=0\none_second_max_count=0\nfor i,value in enumerate(one_count):\n    if one_second_max_count<value and i!=one_first_index:\n        one_second_max_count=value\n        one_second_index=i\n\ntwo_first_index=0\ntwo_max_count=0\nfor i,value in enumerate(two_count):\n    if two_max_count<value:\n        two_max_count=value\n        two_first_index=i\ntwo_second_index=0\ntwo_second_max_count=0\nfor i,value in enumerate(two_count):\n    if two_second_max_count<value and i!=two_first_index:\n        two_second_max_count=value\n        two_second_index=i\n\n\n\nif one_first_index!=two_first_index:\n    print((n-one_max_count-two_max_count))\nelif one_max_count-one_second_max_count<=two_max_count-two_second_max_count:\n    print((n - one_second_max_count - two_max_count))\nelse:\n    print((n - two_second_max_count - one_max_count))\n\n\n\n", "#!/usr/bin/env python3\nfrom collections import Counter\n\nn, *v = list(map(int, open(0).read().split()))\nodd = [v[i] for i in range(0, n, 2)]\neven = [v[i] for i in range(1, n, 2)]\no = Counter(odd)\ne = Counter(even)\n\nif o.most_common()[0][0] != e.most_common()[0][0]:\n    print((n - o.most_common()[0][1] - e.most_common()[0][1]))\nelse:\n    a = n - o.most_common()[0][1] - max(sorted(e.values())[:-1] + [0])\n    b = n - e.most_common()[0][1] - max(sorted(o.values())[:-1] + [0])\n    print((min(a, b)))\n", "import re\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\nimport functools\ndef get_primenumber(number):#\u7d20\u6570\u5217\u6319\n    prime_list = []\n    search_list = list(range(2,number+1))\n    #search_list\u306e\u5148\u982d\u306e\u5024\u304c\u221an\u306e\u5024\u3092\u8d85\u3048\u305f\u3089\u7d42\u4e86\n    while search_list[0] <= math.sqrt(number):\n      #search_list\u306e\u5148\u982d\u306e\u5024\u304c\u221an\u306e\u5024\u3092\u8d85\u3048\u305f\u3089\u7d42\u4e86\n      #search_list\u306e\u5148\u982d\u3092prime_list\u306b\u5165\u308c\u3066\u3001\u5148\u982d\u3092\u30ea\u30b9\u30c8\u306b\u8ffd\u52a0\u3057\u3066\u524a\u9664\n        head_num = search_list.pop(0)\n        prime_list.append(head_num)\n        #head_num\u306e\u500d\u6570\u3092\u9664\u53bb\n        search_list = [num for num in search_list if num % head_num != 0]\n    #prime_list\u306bsearch_list\u3092\u7d50\u5408\n    prime_list.extend(search_list)\n    return prime_list\ndef factrization_prime(number):#\u7d20\u56e0\u6570\u5206\u89e3\n    factor = {}\n    div = 2\n    s = math.sqrt(number)\n    while div < s:\n        div_cnt = 0\n        while number % div == 0:\n            div_cnt += 1\n            number //= div\n        if div_cnt != 0:\n            factor[div] = div_cnt\n        div += 1\n    if number > 1:\n        factor[number] = 1\n    return factor\ndef v(): return input()\ndef k(): return int(input())\ndef S(): return input().split()\ndef I(): return map(int,input().split())\ndef X(): return list(input())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b//math.gcd(a,b)\nsys.setrecursionlimit(10 ** 6)\nmod = 10**9+7\ncnt = 0\nans = 0\nnum = []\ninf = float(\"inf\")\nal = \"abcdefghijklmnopqrstuvwxyz\"\nAL = al.upper()\n\nn = k()\nV = l()\n\nodd = [i for i in V[::2]]\neven = [i for i in V[1::2]]\n\nO = Counter(odd).most_common()\nE = Counter(even).most_common()\na = len(V)//2\n\nif O[0][0] == E[0][0]:\n    if O[0][1] == a:\n        print(a)\n    else:\n        print(min((a-O[0][1])+(a-E[1][1]), (a-O[1][1])+(a-E[0][1])))\nelse:\n    print((a-O[0][1])+(a-E[0][1]))", "import collections\n\nn = int(input())\nv = list(map(int, input().split()))\neven_odd_length = n / 2\nreplace_total = 0\n\nlist_odd = v[0::2]\nlist_even = v[1::2]\n\ndict_c_odd = dict(collections.Counter(list_odd))\ndict_c_even = dict(collections.Counter(list_even))\ndict_c_even_bk = dict_c_even.copy()\n\nreplace_total_tmp = 0\nreplace_total_tmp2 = 0\n\nmax_count_c_odd = max(dict_c_odd.values())\nmax_count_c_even = max(dict_c_even.values())\nmax_count_c_even_bk = max_count_c_even\n\nmax_c_odd_keys = [k for k, v in dict_c_odd.items() if v == max_count_c_odd]\nmax_c_even_keys = [k for k, v in dict_c_even.items() if v == max_count_c_even]\n\nif len(set(v)) == 1:\n    print(int(even_odd_length))\nelse:    \n    if max_c_odd_keys[0] in dict_c_even:\n        del dict_c_even[max_c_odd_keys[0]]\n    max_count_c_even = max(dict_c_even.values())\n    replace_total_tmp = (n - max_count_c_odd - max_count_c_even)\n    \n    dict_c_even = dict_c_even_bk\n    max_count_c_even = max_count_c_even_bk\n    \n    if max_c_even_keys[0] in dict_c_odd:\n        del dict_c_odd[max_c_even_keys[0]]\n    max_count_c_odd = max(dict_c_odd.values())\n    replace_total_tmp2 = (n - max_count_c_odd - max_count_c_even)\n    \n    if replace_total_tmp >= replace_total_tmp2:\n         replace_total = replace_total_tmp2\n    else:\n         replace_total = replace_total_tmp\n\n    print(replace_total)", "n = int(input())\na = list(map(int, input().split()))\na1 = a[::2]\na2 = a[1::2]\n\nfrom collections import Counter\nc = Counter(a1)\nc1 = []\nfor i in c:\n    c1.append([c[i],i])\nc1.sort(reverse = True)\n\nc = Counter(a2)\nc2 = []\nfor i in c:\n    c2.append([c[i],i])\nc2.sort(reverse = True)\n\nans = n\nif c1[0][1] != c2[0][1]:\n    ans -= c1[0][0]\n    ans -= c2[0][0]\nelse:\n    buf1 = 0\n    buf1 += c1[0][0]\n    if len(c2) > 1: buf1 += c2[1][0]\n    buf2 = 0\n    buf2 += c2[0][0]\n    if len(c1) > 1: buf2 += c1[1][0]\n    ans -= max(buf1,buf2)\nprint(ans)", "import collections as co\ndef __starting_point():\n\n\tn = int(input())\n\tA = list(map(int,input().split()))\n\n\tS = A[1::2]\n\tT = A[0::2]\n\n\ttotal_cnt = 0\n\n\t#\u5168\u4f53\u3092\u30c1\u30a7\u30c3\u30af\n\tU = set(A)\n\tif len(U) == 1:\n\t\ttotal_cnt = len(A[1::2])\n\t\tprint(total_cnt)\n\t\treturn\n\n\tc1 = []\n\tc2 = []\n\t#\u5947\u6570\u5217\u3092\u30c1\u30a7\u30c3\u30af\n\ts = co.Counter(S)\n\tc1 = s.most_common()\n\t#\u3053\u308c\u304c\u79d8\u7b56\n\tc1.append((0,0))\n\t#\u5076\u6570\u5217\u3092\u30c1\u30a7\u30c3\u30af\n\tt = co.Counter(T)\n\tc2 = t.most_common()\n\t#\u3053\u308c\u304c\u79d8\u7b56\n\tc2.append((0,0))\n\n\n\t#\u30c1\u30a7\u30c3\u30af\n\t#\u6700\u983b\u5024\u304c\u7570\u306a\u308b\u306a\u3089\n\tif c1[0][0] != c2[0][0]:\n\t\t#\u305d\u308c\u4ee5\u5916\u306e\u6570\u3092\u7dcf\u30ab\u30a6\u30f3\u30c8-1\n\t\ttotal_cnt = len(S) - c1[0][1] \n\t\ttotal_cnt += len(T) - c2[0][1]\n\telse:\n\t\t#\u6700\u983b\u5024\u304c\u540c\u3058\u306a\u3089\u305d\u306e\u6570\u304c\u540c\u3058\u304b\uff1f\n\t\tif c1[0][1] > c2[0][1]:\n\t\t\ttotal_cnt = len(S) - c1[0][1]\n\t\t\ttotal_cnt += len(T) - c2[1][1]\n\t\telif c1[0][1] < c2[0][1]:\n\t\t\ttotal_cnt = len(S) - c1[1][1]\n\t\t\ttotal_cnt += len(T) - c2[0][1]\n\t\telse:\n\t\t\t#\u540c\u3058\u5834\u5408\u3001\uff12\u756a\u76ee\u306e\u6570\u5024\u3092\u6bd4\u8f03\u3057\u3066\u53d6\u308a\u63db\u3048\n\t\t\tif c1[1][1] > c2[0][1]:\n\t\t\t\ttotal_cnt = len(S) - c1[1][1]\n\t\t\t\ttotal_cnt += len(T) - c2[0][1]\n\t\t\telif c1[1][1] < c2[1][1]:\n\t\t\t\ttotal_cnt = len(T) - c2[1][1]\n\t\t\t\ttotal_cnt += len(S) - c1[0][1]\n\t\t\telse:\n\t\t\t\t#\u3069\u3061\u3089\u3067\u3082\u3088\u3044\n\t\t\t\ttotal_cnt = len(S) - c1[1][1]\n\t\t\t\ttotal_cnt += len(T) - c2[0][1]\n\t\t\t\t\n\tprint(total_cnt)\n\n\n__starting_point()", "from collections import Counter\n\nn = int(input())\nV = list(map(int, input().split()))\n\ne = Counter(V[0::2]).most_common()\no = Counter(V[1::2]).most_common()\ne.append((0, 0))\no.append((0, 0))\nres = 0\n\nif(e[0][0] == o[0][0]):\n    print((min(n - o[0][1] - e[1][1], n - o[1][1] - e[0][1])))\nelse:\n    print((n - o[0][1] - e[0][1]))\n", "from collections import Counter\n\nn = int(input())\nA = list(map(int, input().split()))\n\nkisu = A[0::2]\ngusu = A[1::2]\n\nCK = Counter(kisu)\nCG = Counter(gusu)\nCKM = CK.most_common(2)\nCGM = CG.most_common(2)\n\nif len(CKM) == 1 and len(CGM) == 1:\n    if CKM[0][0] == CGM[0][0]:\n        ans = n // 2\n    else:\n        ans = 0\nelif len(CKM) == 1:\n    if CKM[0][0] == CGM[0][0]:\n        ans = n // 2 - CGM[1][1]\n    else:\n        ans = n // 2 - CGM[0][1]\nelif len(CGM) == 1:\n    if CKM[0][0] == CGM[0][0]:\n        ans = n // 2 - CKM[1][1]\n    else:\n        ans = n // 2 - CKM[0][1]\nelse:\n    if CKM[0][0] == CGM[0][0]:\n        ans1 = n // 2 - CKM[1][1] + n // 2 - CGM[0][1]\n        ans2 = n // 2 - CGM[1][1] + n // 2 - CKM[0][1]\n        ans = min(ans1, ans2)\n    else:\n        ans = n - (CKM[0][1] + CGM[0][1])\n\nprint(ans)\n", "\nfrom collections import Counter\n\n\ndef resolve():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    O = Counter(A[::2])\n    E = Counter(A[1::2])\n\n    most_O = O.most_common(2)\n    most_E = E.most_common(2)\n    # \u756a\u5175\n    most_O.append((0, 0))\n    most_E.append((0, 0))\n\n    cnt = 0\n    # key comp\n    if most_O[0][0] == most_E[0][0]:\n        # value\n        res1 = most_O[0][1] + most_E[1][1]\n        res2 = most_O[1][1] + most_E[0][1]\n        cnt = max(res1, res2)\n    else:\n        cnt = most_O[0][1] + most_E[0][1]\n\n    # \u6570\u5b57\u304c\u5c11\u306a\u3044\u3082\u306e\u3092\u66f8\u304d\u63db\u3048\u308b\u70ba\u3001N\u3067\u5f15\u304f\n    print((N - cnt))\n\n\ndef __starting_point():\n    resolve()\n\n__starting_point()", "import sys, bisect, math, itertools, string, queue, copy\n#import numpy as np\n#import scipy\nfrom collections import Counter,defaultdict,deque\nfrom itertools import permutations, combinations\nfrom heapq import heappop, heappush\nfrom fractions import gcd\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\ndef inp(): return int(input())\ndef inpm(): return list(map(int,input().split()))\ndef inpl(): return list(map(int, input().split()))\ndef inpls(): return list(input().split())\ndef inplm(n): return list(int(input()) for _ in range(n))\ndef inplL(n): return [list(input()) for _ in range(n)]\ndef inplT(n): return [tuple(input()) for _ in range(n)]\ndef inpll(n): return [list(map(int, input().split())) for _ in range(n)]\ndef inplls(n): return sorted([list(map(int, input().split())) for _ in range(n)])\n\nn = inp()\na = inpl()\n\ncnt_even = defaultdict(int)\ncnt_odd = defaultdict(int)\nfor i in range(0,n,2):\n  cnt_even[a[i]] += 1\nfor i in range(1,n,2):\n  cnt_odd[a[i]] += 1\n\ncnt_even = list(reversed(sorted(list(cnt_even.items()),key=lambda x:x[1])))\ncnt_odd  = list(reversed(sorted(list(cnt_odd.items()),key=lambda x:x[1])))\n\nflg = False\nfor i in range(min(2,len(cnt_even),len(cnt_odd))):\n  a,b = (cnt_even[i],cnt_odd[i])\n  if a[0] != b[0]:\n    if flg == False:\n      n -= a[1]+b[1]\n    else:\n      n -= max(a[1],b[1])\n    break\n  else:\n    n -= a[1]\n    flg = True\n\nprint(n)\n", "n = int(input())\nv = list(map(int, input().split()))\nv1 = v[0::2]\nv2 = v[1::2]\n\nfrom collections import Counter\nc1 = list(Counter(v1).items())\nc2 = list(Counter(v2).items())\n\nc1 = sorted(c1, key= lambda x: x[1], reverse= True)\nc2 = sorted(c2, key= lambda x: x[1], reverse= True)\n\nc1.append((0,0))\nc2.append((0,0))\n\n#print(c1[:3], c2[:3])\nif c1[0][0] != c2[0][0]:\n    print(n - c1[0][1] - c2[0][1])\nelse:\n    a = c1[0][1] + c2[1][1]\n    b = c1[1][1] + c2[0][1]\n    if a < b:\n        print(n - b)\n    else:\n        print(n - a)", "def main():\n    n = int(input())\n    inlis = list(map(int, input().split()))\n\n    tmp = 0\n    dic1 = {}\n    dic2 = {}\n\n    for i in range(n):\n        if i % 2 == 0:\n            if inlis[i] in dic1:\n                dic1[inlis[i]] += 1\n            else:\n                dic1[inlis[i]] = 1\n        else:\n            if inlis[i] in dic2:\n                dic2[inlis[i]] += 1\n            else:\n                dic2[inlis[i]] = 1\n    diclis1 = list(dic1.items())\n    diclis2 = list(dic2.items())\n\n    diclis1 = sorted(diclis1, key = lambda x:x[1], reverse=True)\n    diclis2 = sorted(diclis2, key = lambda x:x[1], reverse=True)\n\n    key1, val1 = diclis1[0][0], diclis1[0][1]\n    key2, val2 = diclis2[0][0], diclis2[0][1]\n    \n\n    if key1 != key2:\n        print((n- val1 - val2))\n    else:\n        #print(diclis1, diclis2, len(diclis1))\n        if len(diclis1) > 1 and len(diclis2) > 1:\n            ans = min(n-diclis1[0][1]-diclis2[1][1], n-diclis1[1][1]-diclis2[0][1])\n        \n        elif len(diclis2) > 1:\n            ans = min(n//2 + n//2 - diclis2[1][1], n/2 - diclis2[0][1])\n        elif len(diclis1) > 1:\n            ans = min(n//2 + n//2 - diclis1[1][1], n/2 - diclis1[0][1])\n        else:\n            ans = n//2\n\n\n        print(ans)\n    \n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\nalist  = list(map(int,input().split()))\nlist1 = alist[1::2]\nlist2 = alist[0::2]\nfrom collections import Counter\ndic1 = Counter(list1).most_common()\ndic2 = Counter(list2).most_common()\ndic1.append([0,0])\ndic2.append([0,0])\nif dic1[0][0]!=dic2[0][0]:\n  print(n - dic1[0][1] - dic2[0][1])\nelse:\n  print(min(n - dic1[0][1] - dic2[1][1], n -dic1[1][1] - dic2[0][1]))", "n=int(input())\nv=list(input().split())\nv0={}\nv1={}\nfor i in range(0,n,2):\n    if v[i] in v0:\n        v0[v[i]]+=1\n    else:\n        v0[v[i]]=1\nfor i in range(1,n,2):\n    if v[i] in v1:\n        v1[v[i]]+=1\n    else:\n        v1[v[i]]=1\nv0=sorted(v0.items(), key=lambda x:x[1], reverse=True)\nv1=sorted(v1.items(), key=lambda x:x[1], reverse=True)\nif v0[0][0]==v1[0][0]:\n    if len(v0)==1:\n        print(int(n/2))\n    else:\n        print(n-v0[0][1]-(v0[1][1] if v0[1][1]>v1[1][1] else v1[1][1] ))\nelse:\n    print(n-v0[0][1]-v1[0][1])", "n = int(input())\nalist  = list(map(int,input().split()))\nlist1 = alist[1::2]\nlist2 = alist[0::2]\nfrom collections import Counter\ndic1 = Counter(list1).most_common()\ndic2 = Counter(list2).most_common()\ndic1.append([0,0])\ndic2.append([0,0])\nif dic1[0][0]!=dic2[0][0]:\n  print(n - dic1[0][1] - dic2[0][1])\nelse:\n  print(min(n - dic1[0][1] - dic2[1][1], n -dic1[1][1] - dic2[0][1]))", "from collections import Counter\ndef solve():\n  ans = 0\n  N = int(input())\n  V = list(map(int, input().split()))\n  V1 = [V[i] for i in range(0,N,2)]\n  V2 = [V[i] for i in range(1,N,2)]\n  v1 = Counter(V1)\n  v2 = Counter(V2)\n  v1 = sorted(v1.items(),key=lambda x:-x[1])\n  v2 = sorted(v2.items(),key=lambda x:-x[1])\n  if v1[0][0]!=v2[0][0]:\n    ans = N-(v1[0][1]+v2[0][1])\n  else:\n    if len(v1)==1:\n      if len(v2)==1:\n        return N//2\n      return N-(v1[0][1]+v2[1][1])\n    if len(v2)==1:\n      return N-(v1[1][1]+v2[0][1])\n    ans = N-max(v1[1][1]+v2[0][1],v1[0][1]+v2[1][1])\n  return ans\nprint(solve())", "from collections import Counter\nimport sys\nn = int(input())\nv = [[], []]\nfor i, j in enumerate(input().split()):\n    if i & 1:\n        v[0].append(int(j))\n    else:\n        v[1].append(int(j))\n\nv1, v2 = Counter(v[0]), Counter(v[1])\nmx1 , mx2 = v1.most_common()[0], v2.most_common()[0]\nif mx1[0] == mx2[0]:\n    if mx1[1] + mx2[1] == n:\n        print((n//2))\n        return \n    nx1, nx2 = v1.most_common()[1][1], v2.most_common()[1][1]# \u6b21\u306b\u6700\u3082\u591a\u3044\u6570\n    if nx1 > nx2:\n        print((n - nx1 - mx2[1]))\n    else:\n        print((n - mx1[1] - nx2))\nelse:\n    print((n - mx1[1] - mx2[1]))\n    \n", "from collections import Counter\nN=int(input())\nv=list(map(int,input().split()))\n\nlist_odd=v[1::2]\nlist_even=v[0::2]\n\ncnt_odd=Counter(list_odd)\ncnt_even=Counter(list_even)\n\ncnt_odd_sorted=sorted(cnt_odd.items(),reverse=True,key=lambda x:x[1])\ncnt_even_sorted=sorted(cnt_even.items(),reverse=True,key=lambda x:x[1])\n\nif cnt_odd_sorted[0][0]!=cnt_even_sorted[0][0]:\n    ans=len(list_odd)-cnt_odd_sorted[0][1]\n    ans+=len(list_even)-cnt_even_sorted[0][1]\n\nelse:\n    if len(cnt_odd)==1 and len(cnt_even)==1:\n        ans=len(list_even)\n    elif len(cnt_odd)==1:\n        ans=len(list_even)-cnt_even_sorted[1][1]\n    elif len(cnt_even)==1:\n        ans=len(list_odd)-cnt_odd_sorted[1][1]\n    else:\n        ans1=len(list_even)-cnt_even_sorted[1][1]\n        ans1+=len(list_odd)-cnt_odd_sorted[0][1]\n\n        ans2=len(list_odd)-cnt_odd_sorted[1][1]\n        ans2+=len(list_even)-cnt_even_sorted[0][1]\n        ans=min(ans1,ans2)\n\nprint(ans)", "n = int(input())\nv = list(map(int, input().split()))\n\nfirst = {}\nsecond = {}\n\nfor i in range(n):\n    if i % 2 == 0:\n        if v[i] in first:\n            first[v[i]] += 1\n        else:\n            first[v[i]] = 1\n    else:\n        if v[i] in second:\n            second[v[i]] += 1\n        else:\n            second[v[i]] = 1\n\nfirst = sorted(first.items(), key=lambda x: x[1])\nsecond = sorted(second.items(), key=lambda x: x[1])\n\nf = first.pop()\ns = second.pop()\n\nif f[0] == s[0]:\n    if len(first) >= 1:\n        if len(second) >= 1:\n            f2 = first.pop()\n            s2 = second.pop()\n\n            if f2[1] + s[1] > f[1] + s2[1]:\n                f = f2\n            else:\n                s = s2\n        else:\n            s = second.pop()\n    elif len(second) >= 1:\n        f = first.pop()\n    else:\n        s = (0, 0)\n\nprint(n-f[1]-s[1])", "from collections import defaultdict\nN = int(input())\nA = list(map(int,input().split()))\nD1 = defaultdict(int)\nD2 = defaultdict(int)\n\nfor i in range(0,N,2):\n  D1[A[i]]+=1\nfor i in range(1,N,2):\n  D2[A[i]]+=1\n  \nD1_sorted = sorted(D1.items(), key=lambda x:x[1], reverse = True) + [(-1,0)]\nD2_sorted = sorted(D2.items(), key=lambda x:x[1], reverse = True) + [(-1,0)]\ni, j = 0, 0\nwhile i < len(D1_sorted) -1 and j < len(D2_sorted) -1:\n  if D1_sorted[i][0] != D2_sorted[j][0]:\n    break\n  elif D1_sorted[i][1] > D2_sorted[j][1]:\n    j+=1\n  elif D1_sorted[i][1] < D2_sorted[j][1]:\n    i+=1\n  else:\n    if D1_sorted[i+1][1] > D2_sorted[j+1][1]:\n      i+=1\n    else:\n      j+=1\n\nprint(N-D1_sorted[i][1]-D2_sorted[j][1])", "N=int(input())\n*V,=map(int,input().split())\nimport collections\n\nimport collections\n\nc1=collections.Counter(V[0::2])\nc1=sorted(c1.items(), key=lambda x: x[1], reverse=True)\ne=c1[0][0]\n\nc2=collections.Counter(V[1::2])\nc2=sorted(c2.items(), key=lambda x: x[1], reverse=True)\no=c2[0][0]\n\ncnt=0\nif e!=o:\n    cnt=sum(e!=i for i in V[0::2])\n    cnt+=sum(o!=i for i in V[1::2])\nelse:\n    if len(c1)==1 and len(c2)==1:\n        cnt=N//2\n    elif len(c1)==1:\n        cnt1=sum(e!=i for i in V[0::2])\n        cnt1+=sum(c2[1][0]!=i for i in V[1::2])\n        \n        cnt2=sum(e!=i for i in V[0::2])\n        cnt2+=sum(c2[1][1]!=i for i in V[1::2])\n        cnt=min(cnt1,cnt2)\n    elif len(c2)==1:\n        cnt1=sum(c1[1][0]!=i for i in V[0::2])\n        cnt1+=sum(o!=i for i in V[1::2])\n\n        cnt2=sum(c1[1][1]!=i for i in V[0::2])\n        cnt2+=sum(o!=i for i in V[1::2])\n        cnt=min(cnt1,cnt2)\n    else:    \n        cnt1=sum(e!=i for i in V[0::2])\n        cnt1+=sum(c2[1][0]!=i for i in V[1::2])\n        \n        cnt2=sum(c1[1][0]!=i for i in V[0::2])\n        cnt2+=sum(o!=i for i in V[1::2])\n        cnt=min(cnt1,cnt2)\nprint(cnt)", "from collections import Counter\n\nn = int(input())\nv = list(map(int, input().split()))\n\nif len(set(v)) == 1:\n    print((n // 2))\n    return\n\nkisu = Counter(v[::2]).most_common(2)\ngusu = Counter(v[1::2]).most_common(2)\n\nif kisu[0][0] == gusu[0][0]:\n    keep = max(kisu[1][1] + gusu[0][1],\n               kisu[0][1] + gusu[1][1])\nelse:\n    keep = kisu[0][1] + gusu[0][1]\n\nprint((n - keep))\n", "n = int(input())\nl = list(map(int, input().split()))\na = {}\nb = {}\nfor i in range(n // 2):\n    key_a = l[i * 2]\n    key_b = l[i * 2 + 1]\n    if key_a in a:\n        a[key_a] = a[key_a] + 1\n    else:\n        a[l[i * 2]] = 1\n    if key_b in b:\n        b[key_b] = b[key_b] + 1\n    else:\n        b[key_b] = 1\na = sorted(a.items(), key=lambda x: x[1], reverse=True)\nb = sorted(b.items(), key=lambda x: x[1], reverse=True)\nca_max = a[0][0]\ncb_max = b[0][0]\nca_max_num = a[0][1]\ncb_max_num = b[0][1]\nsame_num = ca_max_num + cb_max_num\nif ca_max == cb_max:\n    if len(a) > 1:\n        next_ca_max = a[1][1]\n    else:\n        next_ca_max = 0\n    if len(b) > 1:\n        next_cb_max = b[1][1]\n    else:\n        next_cb_max = 0\n    same_num = max(ca_max_num + next_cb_max, cb_max_num + next_ca_max)\nprint(n - same_num)", "import collections\n\nn = int(input())\nvs = list(map(int, input().split()))\n\nvs_even = vs[0::2]\nvs_odd = vs[1::2]\n\ncount_e = collections.Counter(vs_even).most_common()\ncount_o = collections.Counter(vs_odd).most_common()\n\n#\u30c0\u30df\u30fc\ncount_e.append((0,0))\ncount_o.append((0,0))\n\n\ne_max = len(vs_even) - count_e[0][1]\ne_second = len(vs_even) - count_e[1][1]\no_max = len(vs_odd) - count_o[0][1]\no_second = len(vs_odd) - count_o[1][1]\n\nif(count_e[0][0] != count_o[0][0]):\n    print(e_max + o_max)\n\nelse:\n    print(min(e_second+o_max, e_max+o_second))", "import sys\nfrom collections import Counter\n\ninput = sys.stdin.readline\nN = int(input())\nV = list(map(int, input().split()))\n\nv1 = []\nv2 = []\n \nfor i, v in enumerate(V):\n    if i % 2 == 0:\n        v1.append(v)\n    else:\n        v2.append(v)\n \nv1c = Counter(v1).most_common()\nv2c = Counter(v2).most_common()\n \nk1, v1 = v1c[0][0], v1c[0][1]\nk2, v2 = v2c[0][0], v2c[0][1]\n\nans = N \nif k1 == k2:\n    ans -= v1\n    m = 0\n    if len(v1c) >= 2:\n        m = max(m, v1c[1][1])\n    if len(v2c) >= 2:\n        m = max(m, v2c[1][1])\n    ans -= m\nelse:\n    ans -= v1 + v2\n \nprint(ans)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Thu Sep 17 21:11:38 2020\n\n@author: liang\n\"\"\"\n\n\"\"\"\n\u3010\uff12\u756a\u76ee\u306e\u53d6\u5f97\u3011\n\"\"\"\nn = int(input())\nE = list()\nO = list()\ni = 0\nfor v in input().split():\n    if i%2 == 0:\n        E.append(int(v))\n    else:\n        O.append(int(v))\n    i += 1\n#print(E)\n#print(O)\nedic = {}\nodic = {}\nfor e in E:\n    if e not in edic.keys():\n        edic[e] = 1\n    else:\n        edic[e] += 1\n\nfor o in O:\n    if o not in odic.keys():\n        odic[o] = 1\n    else:\n        odic[o] += 1\n        \netmp = [(-1,0),(-1,0)]\notmp = [(-1,0),(-1,0)]\n\nfor key in edic.keys():\n    #first\n    if edic[key] > etmp[0][1]:\n        etmp[1] = etmp[0]\n        etmp[0] = (key, edic[key])\n    #second\n    elif edic[key] > etmp[1][1]:\n        etmp[1] = (key,edic[key])\n\nfor key in odic.keys():\n    #first\n    if odic[key] > otmp[0][1]:\n        otmp[1] = otmp[0]\n        otmp[0] = (key, odic[key])\n    #second\n    elif odic[key] > otmp[1][1]:\n        otmp[1] = (key,odic[key])\n\nif etmp[0][0] == otmp[0][0]:\n    ans = max(etmp[0][1]+otmp[1][1],etmp[1][1]+otmp[0][1])\nelse:\n    ans = etmp[0][1]+otmp[0][1]\nprint(n-ans)", "n = int(input())\nv = list(map(int, input().split()))\n\nv_even = [0]*100000\nv_odd = [0]*100000\n\nfor i in range(n):\n  if i%2==0:\n    v_even[v[i]-1] += 1 \n  else:\n    v_odd[v[i]-1] += 1\n    \nres1 = max(v_even)\nres2 = max(v_odd)\nif v_even.index(res1) == v_odd.index(res2):\n  if res1 > res2:\n    v_odd[v_odd.index(res2)] = 0\n    res2 = max(v_odd)\n  elif res2 > res1:\n    v_even[v_even.index(res1)] = 0\n    res1 = max(v_even)\n  elif res1 == res2:\n    v_odd[v_odd.index(res2)] = 0\n    v_even[v_even.index(res1)] = 0\n    res3 = max(v_even)\n    res4 = max(v_odd)\n    if res3 > res4:\n      res1 = res3\n    else:\n      res2 = res4\n      \nprint(n//2-res1 + n//2-res2)", "import collections\n\nn = int(input())\nv = [int(i) for i in input().split()]\ncon_odd = []\ncon_even = []\nfor i in range(0,n,2):\n    con_odd.append(v[i]) \n    con_even.append(v[i+1])\n\nb = collections.Counter(con_odd)\nc = sorted(b.items(), key=lambda x:x[1],reverse = True)\nb_2 = collections.Counter(con_even)\nc_2 = sorted(b_2.items(), key=lambda x:x[1],reverse = True)\nif len(c) == 1 and len(c_2) == 1:\n    if c[0][0] == c_2[0][0]:\n        ans = n//2\n    else:\n        ans = 0\nelif len(c) == 1 or len(c_2) == 1:\n    if c[0][0] == c_2[0][0]:\n        if len(c) == 1:\n            ans_1 = len(con_odd) - c[0][1]\n            ans_2 = len(con_even) - c_2[1][1]\n            ans = ans_1 + ans_2\n        else:\n            ans_1 = len(con_odd) - c[1][1]\n            ans_2 = len(con_even) - c_2[0][1]\n            ans = ans_1 + ans_2\n    else:\n        ans_1 = len(con_odd) - c[0][1]\n        ans_2 = len(con_even) - c_2[0][1]\n        ans = ans_1 + ans_2\n            \nelif c[0][0] == c_2[0][0]:\n    if c[0][1] + c_2[1][1] > c[1][1] + c_2[0][1]:\n        ans_1 = len(con_odd) - c[0][1]\n        ans_2 = len(con_even) - c_2[1][1]\n        ans = ans_1 + ans_2\n    else:\n        ans_1 = len(con_odd) - c[1][1]\n        ans_2 = len(con_even) - c_2[0][1]\n        ans = ans_1 + ans_2\nelse:\n    ans_1 = len(con_odd) - c[0][1]\n    ans_2 = len(con_even) - c_2[0][1]\n    ans = ans_1 + ans_2\nprint(ans)", "import copy\n\nn = int(input())\nv = list(map(int, input().split()))\n# print(v)\n\nla = [0 for i in range(5+10**5)]\nlb = [0 for i in range(5+10**5)]\n\nfor i in range(0, n, 2):\n    la[v[i]] += 1\nfor i in range(1, n, 2):\n    lb[v[i]] += 1\n\n# print(sum(la))\n# print(sum(lb))\n# print(max(la))\n# print(max(lb))\n# print(la.index(max(la)))\n# print(lb.index(max(lb)))\n\nsla = sum(la)\nslb = sum(lb)\nmaxla = max(la)\nmaxlb = max(lb)\nargmaxla = la.index(max(la))\nargmaxlb = lb.index(max(lb))\n\nif argmaxla != argmaxlb:\n    if sla-maxla == 0 and slb-maxlb == 0:\n        print((0))\n    else:\n        print((sla-maxla+slb-maxlb))\nelse:\n    # la\u306e2\u756a\u76ee\u306b\u5927\u304d\u3044\u5024\u3092\u4f7f\u3046\n    _la = copy.deepcopy(la)\n    _la[argmaxla] = 0\n    _maxla = max(_la)\n    aa = sla-_maxla+slb-maxlb\n    # lb\u306e2\u756a\u76ee\u306b\u5927\u304d\u3044\u5024\u3092\u4f7f\u3046\n    _lb = copy.deepcopy(lb)\n    _lb[argmaxlb] = 0\n    _maxlb = max(_lb)\n    bb = sla-maxla+slb-_maxlb\n    if bb > aa:\n        print(aa)\n    else:\n        print(bb)\n", "import sys\nfrom collections import Counter\n\n\nstdin = sys.stdin\ndef ns(): return stdin.readline().rstrip()\ndef ni(): return int(stdin.readline().rstrip())\ndef nm(): return list(map(int, stdin.readline().split()))\ndef nl(): return list(map(int, stdin.readline().split()))\n\n\ndef main():\n    n = ni()\n    V = nl()\n    V_e = V[0::2]\n    V_o = V[1::2]\n    V_e_c = Counter(V_e)\n    V_o_c = Counter(V_o)\n\n    if V_e_c.most_common()[0][0] != V_o_c.most_common()[0][0]:\n        ans = len(V) - \\\n            V_e_c.most_common()[0][1] - V_o_c.most_common()[0][1]\n\n    else:\n        if len(V_e_c.most_common()) == 1 or len(V_o_c.most_common()) == 1:\n            if len(V_e_c.most_common()) == 1 and len(V_o_c.most_common()) == 1:\n                ans = len(V) // 2\n            else:\n                if len(V_e_c.most_common()) != 1:\n                    ans = len(V) // 2 - V_e_c.most_common()[1][1]\n                else:\n                    ans = len(V) // 2 - V_o_c.most_common()[1][1]\n\n        else:\n            ans = len(V) - max(\n                V_e_c.most_common()[0][1] + V_o_c.most_common()[1][1],\n                V_e_c.most_common()[1][1] + V_o_c.most_common()[0][1],\n            )\n\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]