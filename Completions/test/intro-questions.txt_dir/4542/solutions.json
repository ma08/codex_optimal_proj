["s= input()\ncolor = \"chokudai\"\nd = []\n\nfor c in s:\n    if c != color:\n        d.append(c)\n        color = c\nprint(len(d)-1)", "s = input()\ncnt = 1\ncw = s[0]\nfor i in range(len(s)):\n  if s[i] != cw: \n    cnt += 1\n    cw = s[i]\nprint(cnt - 1)", "S = str(input())\nSum = 0  \nfor i in range(len(S) - 1):\n    if S[i] != S[i + 1]:\n        Sum += 1\n\nprint(Sum)", "s = input()\nprint((sum((s[i] != s[i+1] for i in range(len(s)-1)))))\n", "s=input()\nans=0\nfor i in range(len(s)-1):\n    if s[i]!=s[i+1]:\n        ans+=1\nprint(ans)\n", "s = input()\ntmp = s[0]\ncnt = 0\nfor c in s:\n    if tmp != c:\n        tmp = c\n        cnt += 1\nprint(cnt)", "S = list(input())\ncount = 0\nt = ''\nfor i in S:\n    if t == i:\n        continue\n    else:\n        t = i\n        count += 1\nprint(count - 1)", "s=input()\n\ncolor = s[0]\nresult = 0\nfor i in range(len(s)):\n  if color != s[i]:\n    result += 1\n    color = s[i]\nprint(result)", "S = input()\ncount = 0\nfor i in range(len(S)-1):\n    if S[i] != S[i+1]:\n        count += 1\nprint(count)", "s=list(input())\ntmp=0\nfor i in range(1,len(s)):\n    if s[i-1] != s[i]:\n        tmp+=1\nprint(tmp)", "S = input()\n#0\u56de\u5224\u5b9a\nx = len(S)\nif S.count(\"B\") == x or S.count(\"W\") == x:\n    print(0)\n    return\n\n\n\ncntw=0\nfor s in S.split(\"W\"):\n    if s:\n        cntw += 1\ncntb=0\nfor s in S.split(\"B\"):\n    if s:\n        cntb += 1\nprint(abs(cntb - cntw) + min(cntb, cntw) * 2 - 1)", "def main():\n    S = input()\n    ans = 0\n    for i, s in enumerate(S):\n        if i == 0:\n            t = s\n            continue\n        if t == s:\n            continue\n        else:\n            ans += 1\n            t = s\n    print(ans)\n        \ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\nans = 0\nfor i in range(len(s)-1):\n    if s[i] != s[i+1]:\n        ans += 1\nprint(ans)", "s = input()\ncnt = 0\nfor i in range(1, len(s)):\n    if s[i] != s[i-1]:\n        cnt += 1\nprint(cnt)", "def main():\n    s = str(input())\n    b_count = s.count('B')\n    w_count = len(s) - b_count\n\n    if b_count == len(s) or w_count == len(s):\n        count = 0\n    else:\n        count = 0\n        index = 0\n        alp = s[index]\n\n        while True:\n            if b_count == 0 or w_count == 0:\n                break\n            else:\n                if s[index] == 'B':\n                    b_count -= 1\n                else:\n                    w_count -= 1\n\n                if s[index] == alp:\n                    index += 1\n                else:\n                    count += 1\n                    alp = s[index]\n                    index += 1\n\n        if not (b_count == 0 and w_count == 0):\n            count += 1\n\n    print(count)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "S=input()\nprint(S.count(\"BW\")+S.count(\"WB\"))", "s=input()\nc=0\nt=s[0]\nfor k in s[1:]:\n    if t!=k:\n        t=k\n        c+=1\nprint(c)\n", "S = input()\ncnt = 0\nnow = S[0]\n\nfor i in S:\n    if i != now:\n        now = i\n        cnt += 1\nprint(cnt)", "S = input()\nprev = S[0]\ncnt = 0\nfor s in S:\n    if prev != s:\n        cnt += 1\n    prev = s\nprint(cnt)", "S = input()\nans = 0\n\nfor i in range(len(S)-1):\n  if S[i] != S[i+1]:\n    ans += 1\n\nprint(ans)", "s = input()\ncnt = 0\nfor i in range(1,len(s)):\n  if s[i] != s[i-1]: \n    cnt += 1\nprint(cnt)", "s = input()\nc = s[0]\nans = 0\nfor i in range(1, len(s)):\n    if c != s[i]:\n        ans += 1\n    c = s[i]\nprint(ans)", "#from statistics import median\n#import collections\n#aa = collections.Counter(a) # list to list || .most_common(2)\u3067\u6700\u5927\u306e2\u500b\u3068\u308a\u3060\u305b\u308b\u304a a[0][0]\nfrom math import gcd\nfrom itertools import combinations,permutations,accumulate, product # (string,3) 3\u56de\n#from collections import deque\nfrom collections import deque,defaultdict,Counter\nimport decimal\nimport re\nimport math\nimport bisect\nimport heapq\n#\n#\n#\n# python\u3067\u7121\u7406\u306a\u3068\u304d\u306f\u3001pypy\u3067\u3084\u308b\u3068\u6b63\u89e3\u3059\u308b\u304b\u3082\uff01\uff01\n#\n#\n# my_round_int = lambda x:np.round((x*2 + 1)//2)\n# \u56db\u6368\u4e94\u5165g\n#\n# \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u7cfb\n# int min_y = max(0, i - 2), max_y = min(h - 1, i + 2);\n# int min_x = max(0, j - 2), max_x = min(w - 1, j + 2);\n#\n#\nimport sys\nsys.setrecursionlimit(10000000)\nmod = 10**9 + 7\n# mod = 9982443453\n# mod = 998244353\nINF = float('inf')\nfrom sys import stdin\nreadline = stdin.readline\ndef readInts():\n  return list(map(int,readline().split()))\ndef readTuples():\n    return tuple(map(int,readline().split()))\ndef I():\n    return int(readline())\nS = input()\nans = 0\nfor i in range(len(S)-1):\n    if S[i+1] != S[i]:\n        ans += 1\nprint(ans)\n", "S = input()\nl = len(S)\nans = sum(a != b for a,b in zip(S[:l-1],S[1:]))\nprint(ans)", "from collections import Counter\nS = input()\n\nc = Counter(S)\nif c['W'] == 0 or c['B'] == 0:\n    print((0))\n    return\n\nnow = ''\ncount = 0\nfor i in range(len(S)):\n    if i == 0:\n        now = S[i]\n        continue\n    if now == S[i]:\n        continue\n    else:\n        count += 1\n        now = S[i]\n        continue\n\nprint(count)\n", "s = list(input())\nans = 0\nfor i in range(1, len(s)):\n    if s[i] != s[i-1]:\n        ans += 1\nprint(ans)", "s = input()\ncount = 0\nfor i in range(len(s)-1):\n    if s[i] != s[i+1]:\n        count += 1\nprint(count)", "S = input()\n\nls = [\"WB\", \"BW\"]\n\ncnt = 0\nif S[0] == \"W\":\n  i = 0\nelse:\n  i = 1\n\nfor j in range(len(S)-1):\n  if i == 0 and S[j:j+2] == \"WB\":\n    cnt += 1\n    i = 1\n  if i == 1 and S[j:j+2] == \"BW\":\n    cnt += 1\n    i = 0\n    \nprint(cnt)", "s = input()\nans = 0\nfor i in range(1, len(s)):\n    if s[i] != s[i - 1]:\n        ans += 1\nprint(ans)", "prev = '0'\nS = ''\nfor c in input():\n    if c != prev:\n        S += c\n    prev = c\nprint(len(S) - 1)", "s = list(input())\nn = len(s)\nb = False\nif s[0] == \"B\":\n    b = True\n\nans = 0\nfor i in range(1, n):\n    if b and s[i] == \"W\":\n        b = False\n        ans += 1\n    elif not b and s[i] == \"B\":\n        b = True\n        ans += 1\nprint(ans)", "s=input()\ncount=0\nfor i in range(1,len(s)):\n    if s[i-1]!=s[i]:\n        count+=1\nprint(count)\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 30 02:12:31 2020\n\n@author: liang\n\"\"\"\n\nS = input()\nans = 0\nfor i in range(len(S) - 1):\n    if S[i] != S[i+1]:\n        ans += 1\n\nprint(ans)", "import math\nfrom math import gcd,pi,sqrt\nINF = float(\"inf\")\n\nimport sys\nsys.setrecursionlimit(10**6)\nimport itertools\nfrom collections import Counter,deque\ndef i_input(): return int(input())\ndef i_map(): return list(map(int, input().split()))\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\n\n\ndef main():\n    s = s_input()\n    ans = 0\n    trial = s[0]\n    for i in s[1:]:\n        if trial != i:\n            ans += 1\n            trial = i\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "S = input()\nc = 0\n\nbs = '_'\nfor s in S:\n  if s != bs:\n    c += 1\n    bs = s\n\nprint(c - 1)", "class Combination:\n    def __init__(self, n, mod):\n        self.n = n\n        self.mod = mod\n        self.fac = [1 for i in range(self.n + 1)]\n        self.finv = [1 for i in range(self.n + 1)]\n        for i in range(2, self.n+1):\n            self.fac[i] = (self.fac[i - 1] * i) % self.mod\n            self.finv[i] = (self.finv[i - 1] * pow(i, -1, self.mod)) % self.mod\n\n    def comb(self, n, m):\n        return self.fac[n] * (self.finv[n - m] * self.finv[m] % self.mod) % self.mod\n        \ndef iparse():\n    return list(map(int, input().split()))\n\ndef RLE(s):\n    res = []\n    prev = \"\"\n    cnt = 0\n    for e in s:\n        if prev == \"\":\n            prev = e\n            cnt += 1\n        elif prev == e:\n            cnt += 1\n        else:\n            res.append((cnt,prev))\n            prev = e\n            cnt = 1\n    res.append((cnt,prev))\n    return res\n\n\ndef __starting_point():\n    s = input()\n    rle = RLE(s)\n    # print(rle)\n    print(len(rle)-1)\n__starting_point()", "s = input()\ncounter = 0\n\nfor i in range(1, len(s)):\n    if s[i] != s[i - 1]:\n        counter += 1\n\nprint(counter)\n", "from itertools import groupby\ns = input()\ncount = 0\nfor k, g in groupby(s):\n    count += 1\nprint(count - 1)", "s=input()\nans=[]\npre=\"\"\nfor i in s:\n    if pre!=i:\n        ans.append(i)\n        pre=i\n\nprint(len(ans)-1)", "S = input()\n\ns = S.replace('WB', 'W B').replace('BW', 'B W')\ns = list(s.split())\nprint(len(s) -1)", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# FileName: \tC\n# CreatedDate:  2020-10-09 16:08:34 +0900\n# LastModified: 2020-10-09 16:19:59 +0900\n#\n\n\nimport os\nimport sys\n# import numpy as np\n# import pandas as pd\nfrom itertools import groupby\n\n\ndef main():\n    S = input()\n    sgroup = groupby(S)\n    for cnt, (key, group) in enumerate(sgroup):\n        pass\n    print(cnt)\n\n\n\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\n\ninput = sys.stdin.readline\nS = input()\nS = S.replace('\\n' , '')\ntmp = \"\"\ndivision_count = 0\nfor s in S:\n    if tmp == \"\":\n        tmp = s\n        continue\n    if tmp == s:\n        continue\n    else:\n        tmp = s\n        division_count += 1\nprint(division_count)", "prev = '0'\nans = -1\nfor c in input():\n    if c != prev:\n        ans += 1\n    prev = c\nprint(ans)", "s = input()\ncnt = 0\nfor i in range(len(s)-1):\n    if s[i+1] != s[i]:\n        cnt += 1\nprint(cnt)", "from itertools import groupby\nprint(len(list(groupby(input())))-1)", "s = input()\nprint(s.count(\"BW\")+s.count(\"WB\"))", "from itertools import groupby\n\ns = input()\n\ncnt = 0\n\nfor k, g in groupby(s):\n    cnt += 1\n\nprint((cnt - 1))\n", "s = input()\nif len(s) == 1:\n    print(0)\nelse:\n    cnt = 0\n    for i in range(len(s)-1):\n        if s[i] != s[i+1]:\n            cnt += 1\n\n    print(cnt)", "a=input()+\"p\"\nb=0\ni=1\nc=a[0]\nwhile a[i]!=\"p\":\n  if a[i]!=c:\n    c=a[i]\n    b+=1\n  i+=1\nprint(b)", "S=input()\nN=len(S)\n\ncount=0\nfor i in range(N-1):\n    if S[i]!=S[i+1]:\n        count+=1\n\nprint(count)\n", "S = input()\nans = 0\nfor i in range(1,len(S)):\n  if S[i] != S[i-1]:\n    ans += 1\nprint(ans)", "def main():\n    *S, = input()\n    c = S.pop()\n    ans = 0\n    while S:\n        if (nc := S.pop()) == c:\n            continue\n        c = nc\n        ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python\n\ns = input()\nans = 0 \nfor i in range(len(s)-1):\n    if s[i+1] != s[i]:\n        ans += 1\nprint(ans)\n", "s = list(input())\n\ncount = 0\nfor i in range(len(s) - 1):\n    if s[i] != s[i + 1]:\n        count += 1\n\nprint(count)", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(S: str):\n    S = [s1 for s0, s1 in zip(S, S[1:]+\".\") if s0 != s1]\n    return len(S) - 1\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    S = next(tokens)  # type: str\n    print((solve(S)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "s=list(input())\ncnt=0\nbf=s[0]\nfor i in s[1:]:\n  if i!=bf:\n    cnt+=1\n  bf=i\nprint(cnt)", "s=input()\nn=len(s)\nans=0\nfor i in range(n-1):\n  if s[i]==s[i+1]:\n    continue\n  else:\n    ans+=1\nprint(ans)", "s = input()\nans = 0\np = s[0]\nfor si in s:\n    ans += p != si\n    p = si\nprint(ans)", "S=input()\nans=0\nN=len(S)\nnow=S[0]\nfor i in range(1,N):\n    if now!=S[i]:\n        now=S[i]\n        ans+=1\nprint(ans)", "#81 C - \u4e00\u6b21\u5143\u30ea\u30d0\u30fc\u30b7\nS = input()\nS = S + '1'# \u756a\u5175\n\n# \u9023\u7d9a\u3059\u308b\u6587\u5b57\u3092\u30ab\u30a6\u30f3\u30c8\ncnt = []\nconti = 1\nfor i in range(1,len(S)):\n    if S[i-1] == S[i]:\n        conti += 1\n    else:\n        cnt.append(conti)\n        conti = 1\nprint(len(cnt)-1)", "s = input()\na = 0\nfor i in range(len(s) - 1):\n    if s[i] != s[i + 1]:\n        a += 1\nprint(a)\n", "#\n# abc047 c\n#\n\nimport sys\nfrom io import StringIO\nimport unittest\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_\u5165\u529b\u4f8b_1(self):\n        input = \"\"\"BBBWW\"\"\"\n        output = \"\"\"1\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_2(self):\n        input = \"\"\"WWWWWW\"\"\"\n        output = \"\"\"0\"\"\"\n        self.assertIO(input, output)\n\n    def test_\u5165\u529b\u4f8b_3(self):\n        input = \"\"\"WBWBWBWBWB\"\"\"\n        output = \"\"\"9\"\"\"\n        self.assertIO(input, output)\n\n\ndef resolve():\n    S = list(input())\n\n    i = 1\n    while i < len(S):\n        if S[i] == S[i-1]:\n            del S[i]\n        else:\n            i += 1\n\n    print((len(S)-1))\n\n\ndef __starting_point():\n    # unittest.main()\n    resolve()\n\n__starting_point()", "s = input()\ntemp = s[0]\nans = 0\nfor l in s:\n  if temp!=l:\n    ans += 1\n  temp = l\nprint(ans)", "def solve():\n    s = input()\n    ans = 0\n    for i in range(len(s)-1):\n        if s[i] != s[i + 1]:\n            ans += 1\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "from itertools import groupby\n\nS = input()\n\nprint((len(list(groupby(S)))-1))\n", "s = input()\nans = 0\n\nfor i in range(len(s)-1):\n  if s[i] != s[i+1]:\n    ans += 1\n\nprint(ans)", "from itertools import groupby\n\n\n# RUN LENGTH ENCODING str -> tuple\ndef runLengthEncode(S: str):\n    grouped = groupby(S)\n    res = []\n    for k, v in grouped:\n        res.append((k, str(len(list(v)))))\n    return res\n\n\n# RUN LENGTH DECODING tuple -> str\ndef runLengthDecode(L: \"list[tuple]\"):\n    res = \"\"\n    for c, n in L:\n        res += c * int(n)\n    return res\n\n\n# RUN LENGTH ENCODING str -> list\ndef rle_list(S: str):\n    grouped = groupby(S)\n    res = \"\"\n    for k, v in grouped:\n        res += k\n    return res\n\n\ndef main():\n    ss = input()\n    rle = rle_list(ss)\n    ans = len(list(rle)) - 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = list(input())\nans = 0\nt = s[0]\nfor i in range(1,len(s)):\n    if s[i] != t:\n        t = s[i]\n        ans += 1\nprint(ans)", "s = input()\ncount = 0\nfor i in range(len(s)-1):\n    if s[i] != s[i+1]:\n        count += 1\nprint(count)", "s = input()\ncount = 0\n\nfor i in range(len(s)-1):\n  if s[i] != s[i+1]:\n    count += 1\nprint(count)", "def main():\n    ss = input()\n    put_stone = ''\n    count = 0\n    for stone in ss:\n        if put_stone != '' and put_stone == stone:\n            count += 1\n        if stone == 'B':\n            put_stone = 'W'\n        else:\n            put_stone = 'B'\n    print(count)\n\ndef __starting_point():\n    main()\n__starting_point()", "S = input()\nnow = S[0]\ncnt = 0\nfor s in S:\n    if now == s:\n        continue\n    cnt += 1\n    now = s\nprint(cnt)", "S = input()\nprint(S.count('BW')+S.count('WB'))", "S=input()\nans=0\nfor i in range(len(S)-1):\n    if S[i]!=S[i+1]:\n        ans+=1\nprint(ans)\n", "S = input()\nList = list(S)\ntrial = 0\nfor i in range(1,len(List)):\n  if List[i] != List[i-1]:\n    trial += 1\nprint(trial)", "#!/usr/bin/env python3\nimport sys\n\n\ndef solve(S: str):\n    from itertools import groupby\n    return len(list(groupby(S))) - 1\n\n\n# Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    S = next(tokens)  # type: str\n    print((solve(S)))\n\ndef test():\n    import doctest\n    doctest.testmod()\n\ndef __starting_point():\n    #test()\n    main()\n\n__starting_point()", "s = input()\nans = 0\nx = s[0]\n\nfor i in range(len(s)):\n    if s[i] != x:\n        ans += 1\n        x = s[i]\n\nprint(ans)", "def main():\n    s = input()\n    print((sum([1 for i in range(len(s) - 1) if s[i] != s[i + 1]])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "s = input()\n\nn = len(s)\n\ncnt = 0\nfor i in range(1,n):\n  if s[i] != s[i-1]:\n    cnt +=1\nprint (cnt)\n", "S=str(input())\nans=0\nfor i in range(1,len(S)):\n    if S[i-1]!=S[i]:\n        ans+=1\nprint(ans)", "s = input()\nprev = s[0]\nans = 0\nfor i in range(1, len(s)):\n    if s[i] != prev:\n        ans += 1\n    prev = s[i]\nprint(ans)\n", "s = input()\ncnt = 0\nfor i in range(len(s)-1):\n    if s[i] != s[i+1]:\n        cnt += 1\n\nprint(cnt)", "s=input()\nx=s.count(\"WB\")\ny=s.count(\"BW\")\nprint((x+y))\n", "S = list(input())\nk = S.pop(0)\nii = 0\nfor i in S:\n    if k == i:\n        pass\n    else:\n        ii += 1\n        k = i\nprint(ii)", "s=list(input())\nr=0\nfor ii in range(len(s)-1):\n  if s[ii+1]!=s[ii]:\n    r+=1\nprint(r)", "a=input()\nb=0\nfor i in range(len(a)-1):\n  if a[i]!=a[i+1]:\n    b=b+1\nprint(b)", "S=list(input())\nc=0;m=''\nfor i in S:\n    if i!=m:\n        m=i\n        c+=1\nprint(c-1)", "# coding = SJIS\n\ns = str(input())\nans = 0\n\nfor i in range(len(s) - 1):\n    if s[i] != s[i + 1]:\n        ans += 1\n\nprint(ans)", "s = input()\nans = 0\nfor i in range(len(s)-1):\n    if s[i]!=s[i+1]:\n        ans += 1\nprint(ans)", "import itertools\ns = input()\nprint(len(list(itertools.groupby(s)))-1)", "from itertools import groupby\nS = input()\ngr = groupby(S)\nprint((len(list(gr))-1))\n", "S = str(input())\nN = len(S)\nD = [0,0] #B,W\nans = 0; prev = S[0]\nfor i in range(N):\n  if S[i] == \"B\":\n    D[0] += 1\n  else:\n    D[1] += 1\n  if i >= 1:\n    if S[i] == prev:\n      continue\n    else:\n      ans += 1\n      prev = S[i]\nif D[0] == 0: #\u3059\u3079\u3066W\n  print((0)); return\nelif D[1] == 0:\n  print((0)); return\nprint(ans)\n", "s = input()\n\ns_ = s[0]\n\nfor c in s:\n    if s_[-1]!=c:\n        s_ += c\nprint(len(s_)-1)", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 30 02:12:31 2020\n\n@author: liang\n\"\"\"\n\nS = input()\nans = 0\nfor i in range(len(S) - 1):\n    if S[i] != S[i+1]:\n        ans += 1\n\nprint(ans)", "s = input()\nres = 0\nfor i in range(len(s) - 1):\n  if s[i] != s[i+1]:\n    res += 1\nprint(res)", "S = input()\nprint(S.count(\"WB\")+S.count(\"BW\"))", "s = input()\n\nnow = \"\"\nans = 0\nfor i in range(len(s)):\n  if i == 0:\n    now = s[0]\n    continue\n  if s[i] != now:\n    ans += 1\n    now = s[i]\nprint(ans)", "s = input()\ncnt = 0\ncur = s[0]\nstrk = 1\n\nfor i in range(1, len(s)):\n    if s[i] == cur:\n        strk += 1\n    else:\n        cnt += 1\n        cur = s[i]\n        strk = 1\n\ncnt += 1\n\nprint(cnt-1)", "S=input()\ni=1\nl=len(S)\nres=0\nf=S[0]\n\nwhile i<l:\n  if (S[i] == f):\n        i+=1\n  else:\n    res+=1\n    f=S[i]\n    i+=1\nprint(res)", "S=input()\nrest=S[0]\ncnt=0\nfor i in range(1,len(S)):\n    if S[i]!=rest:\n        cnt+=1\n        rest=S[i]\nprint(cnt)"]