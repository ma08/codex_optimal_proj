["from sys import stdin\n\nn,k = list(map(int, stdin.readline().strip().split(' ')))\n\nAB = []\nA = []\nB = []\n\nfor i in range(n):\n    t,a,b = list(map(int, stdin.readline().strip().split(' ')))\n    if a == 1 and b == 1:\n        AB.append(t)\n    elif a == 1:\n        A.append(t)\n    elif b == 1:\n        B.append(t)\n\nAB.sort()\nA.sort()\nB.sort()\n\nans = 0\nabi = 0\nai = 0\nbi = 0\nisPossible = True\nfor i in range(k):\n    if abi == len(AB) and (ai == len(A) or bi == len(B)):\n        isPossible = False\n        break\n    if abi == len(AB):\n        ans += (A[ai] + B[bi])\n        ai += 1\n        bi += 1\n        continue\n    if ai == len(A) or bi == len(B):\n        ans += AB[abi]\n        abi += 1\n        continue\n    if A[ai] + B[bi] <= AB[abi]:\n        ans += (A[ai] + B[bi])\n        ai += 1\n        bi += 1\n        continue\n    ans += AB[abi]\n    abi += 1\n    continue\nif isPossible:\n    print(ans)\nelse:\n    print(-1)\n\n\n", "import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\n\nBOOKS=[tuple(map(int,input().split())) for i in range(n)]\n\nA=[]\nB=[]\nAB=[]\n\nfor t,a,b in BOOKS:\n    if a==1 and b==1:\n        AB.append(t)\n    if a==1 and b==0:\n        A.append(t)\n    if a==0 and b==1:\n        B.append(t)\n\nA.sort()\nB.sort()\nAB.sort()\n\nfrom itertools import accumulate\n\nSA=[0]+list(accumulate(A))\nSB=[0]+list(accumulate(B))\nSAB=[0]+list(accumulate(AB))\n\n\nANS=1<<31\n\nfor i in range(len(SAB)):\n    if 0<=k-i<len(SA) and 0<=k-i<len(SB):\n        ANS=min(ANS,SAB[i]+SA[k-i]+SB[k-i])\n\nif ANS==1<<31:\n    print(-1)\nelse:\n    print(ANS)\n\n    \n", "def solve():\n    n, k = map(int,input().split())\n    a1 = []\n    b1 = []\n    ab1 = []\n    for i in range(n):\n        t,a,b = map(int,input().split())\n        if a == 1 and b == 1:\n            ab1.append(t)\n        elif a == 1:\n            a1.append(t)\n        elif b == 1:\n            b1.append(t)\n    a1.sort()\n    b1.sort()\n    for i in range(min(len(a1),len(b1))):\n        ab1.append(a1[i]+b1[i])\n    ab1.sort()\n    p = 0\n    qq = len(ab1)\n    if qq < k:\n        print(-1)\n    else:\n        ans = 0\n        for i in range(k): ans += ab1[i]\n        print(ans)\nfor i in range(1):\n    solve()", "\nn,k=list(map(int,input().split(\" \")))\ndb=[]\na=[]\nb=[]\nfor i in range(n):\n    t,A,B= list(map(int, input().split(\" \")))\n    if A==B==1:\n        db.append(t)\n    elif A==1:\n        a.append(t)\n    elif B==1:\n        b.append(t)\na.sort()\nb.sort()\nfor i in range(min(len(a),len(b))):\n    db.append((a[i]+b[i]))\nif len(db)<k:\n    print(-1)\nelse:\n    db.sort()\n    print(sum(db[:k]))\n", "n, k = list(map(int, input().split()))\ngroup = [[], [], [], []]\nfor i in range(n):\n    t, a, b = list(map(int, input().split()))\n    group[a * 2 + b].append(t)\n\npref_sum = [[0], [0], [0], [0]]\nfor g, ps in zip(group, pref_sum):\n    g.sort()\n    for i in g:\n        ps.append(ps[-1] + i)\n\n# print(group) \n# print(pref_sum) \nans = 10**18\nfor i in range(min(k, len(group[3])) + 1):\n    rest = k - i\n    if rest > len(group[2]) or rest > len(group[1]):\n        continue\n    ans = min(ans, pref_sum[3][i] + pref_sum[1][rest] + pref_sum[2][rest])\n\nif ans < 10**18:\n    print(ans)\nelse:\n    print(-1)\n\n\n\n", "import sys, math,os\nfrom io import BytesIO, IOBase\n#data = BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# from bisect import bisect_left as bl, bisect_right as br, insort\n# from heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n# from itertools import permutations,combinations\n# from decimal import Decimal\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var): sys.stdout.write(' '.join(map(str, var)) + '\\n')\ndef out(var): sys.stdout.write(str(var) + '\\n')\n#sys.setrecursionlimit(100000 + 1)\nINF = 10**9\nmod = 998244353\n\nn,k=mdata()\na,b,c,d=[],[],[],[]\nfor i in range(n):\n    t1,a1,b1=mdata()\n    if a1==1 and b1==1:\n        c.append(t1)\n    elif a1==1:\n        a.append(t1)\n    elif b1==1:\n        b.append(t1)\n    else:\n        d.append(t1)\na.sort(reverse=True)\nb.sort(reverse=True)\nc.sort(reverse=True)\nd.sort(reverse=True)\nans=0\nwhile k:\n    if len(a)!=0 and len(b)!=0:\n        if len(c)!=0:\n            if c[-1]<a[-1]+b[-1]:\n                ans+=c.pop()\n            else:\n                ans+=a.pop()+b.pop()\n        else:\n            ans += a.pop() + b.pop()\n    elif len(c)!=0:\n        ans += c.pop()\n    else:\n        break\n    k-=1\nif k!=0:\n    out(-1)\nelse:\n    out(ans)\n\n", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\nM = mod = 998244353\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split()]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\nn,k = li()\n\nalice = []\nbob = []\nboth = []\n\n\nfor i in range(n):\n    a,b,c = li()\n    if b and c:\n        both.append(a)\n    elif b:alice.append(a)\n    elif c:bob.append(a)\n\n\nalice.sort()\nbob.sort()\n\n\nfor i in range(min(len(alice),len(bob))):\n    both.append(alice[i] + bob[i])\n\n\nboth.sort()\n# print(both)\nif len(both) < k:\n    print(-1)\n    return\nelse:print(sum(both[:k]))\n", "#!/usr/bin/env pypy3\n\nfrom sys import stdin, stdout\n \ndef input():\n    return stdin.readline().strip()\n\nN, K = input().split(' ')\nN = int(N)\nK = int(K)\n\nalice_only = []\nbob_only = []\nboth = []\n\nfor _ in range(N):\n    t, a, b = input().split(' ')\n    t = int(t)\n    a = int(a)\n    b = int(b)\n\n    if a == 0 and b == 0: continue\n    if a == 1 and b == 1: both += [t]\n    if a == 1 and b == 0: alice_only += [t]\n    if a == 0 and b == 1: bob_only += [t]\n\nhybrid = []\n\nalice_only = sorted(alice_only)\nbob_only = sorted(bob_only)\n\nfor a, b in zip(alice_only, bob_only):\n    hybrid += [a + b]\n\ncandidates = sorted(both + hybrid)\n\nif len(candidates) < K:\n    print(-1)\nelse:\n    print(sum(candidates[0:K]))\n", "import sys\ninput = sys.stdin.readline\nn,minn = map(int,input().split())\na = []\nca, cb = 0, 0\nfor i in range(n):\n\tt,x,y = map(int,input().split())\n\tif x==1:\n\t\tca += 1\n\tif y==1:\n\t\tcb += 1\n\ta.append((t,x,y))\nif ca<minn or cb<minn:\n\tprint (-1)\n\treturn\nca,cb = 0,0\nalice = []\nbob = []\nboth = []\nfor i in range(n):\n\tif a[i][1]==a[i][2]==1:\n\t\tboth.append(a[i][0])\n\telif a[i][1]!=a[i][2]:\n\t\tif a[i][1]==1:\n\t\t\talice.append(a[i][0])\n\t\telse:\n\t\t\tbob.append(a[i][0])\nalice.sort()\nbob.sort()\nboth.sort()\n# print (alice)\n# print (bob)\n# print (both)\ni,j,k = 0,0,0\nans = 0\nwhile ca<minn or cb<minn:\n\tif (i<len(alice) and j<len(bob) and k<len(both)) and alice[i]+bob[j]<=both[k]:\n\t\tans += alice[i]+bob[j]\n\t\tca += 1\n\t\tcb += 1\n\t\ti += 1\n\t\tj += 1\n\telif (i<len(alice) and j<len(bob) and k<len(both)) and alice[i]+bob[j]>=both[k]:\n\t\tans += both[k]\n\t\tca += 1\n\t\tcb += 1\n\t\tk += 1\n\telse:\n\t\tbreak\n\nif i==len(alice):\n\twhile ca<minn:\n\t\tans += both[k]\n\t\tk += 1\n\t\tca += 1\n\t\tcb += 1\nif j==len(bob):\n\twhile cb<minn:\n\t\tans += both[k]\n\t\tk += 1\n\t\tca += 1\n\t\tcb += 1\nif k==len(both):\n\twhile ca<minn:\n\t\tans += alice[i]\n\t\ti += 1\n\t\tca += 1\n\twhile cb<minn:\n\t\tans += bob[j]\n\t\tj += 1\n\t\tcb += 1\nprint (ans)", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\n\nn, k = map(int, input().split())\nboth = []\nalice = []\nbob = []\nfor _ in range(n):\n    c, a, b = map(int, input().split())\n    if a and b:\n        both.append(c)\n    elif a:\n        alice.append(c)\n    elif b:\n        bob.append(c)\n\nalice.sort()\nbob.sort()\nfor a, b in zip(alice, bob):\n    both.append(a + b)\nboth.sort()\n\nif len(both) < k:\n    print(-1)\nelse:\n    print(sum(both[:k]))", "import sys\nimport math\ndef II():\n\treturn int(sys.stdin.readline())\n\ndef LI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef MI():\n\treturn list(map(int, sys.stdin.readline().split()))\n\ndef SI():\n\treturn sys.stdin.readline().strip()\nn,k = MI()\nx = []\ny = []\nz = []\no = []\nfor q in range(n):\n\tt,a,b = MI()\n\tif a == 1 and b == 1:\n\t\tz.append(t)\n\telif a == 1:\n\t\tx.append(t)\n\telif b == 1:\n\t\ty.append(t)\n\telse:\n\t\to.append(t)\nx.sort()\ny.sort()\nz.sort()\nx0 = len(x)\ny0 = len(y)\nz0 = len(z)\nif x0+z0<k or y0+z0<k:\n\tprint(-1)\nelse:\n\tans = 0\n\tl = r = 0\n\tfor i in range(k):\n\t\tif l<x0 and l<y0 and r<z0:\n\t\t\tif x[l]+y[l]<z[r]:\n\t\t\t\tans+=x[l]+y[l]\n\t\t\t\tl+=1\n\t\t\telse:\n\t\t\t\tans+=z[r]\n\t\t\t\tr+=1\n\t\telif r<z0:\n\t\t\tans+=z[r]\n\t\t\tr+=1\n\t\telif l<x0 and l<y0:\n\t\t\tans+=x[l]+y[l]\n\t\t\tl+=1\n\tprint(ans)\n", "n, k = map(int, input().split())\nA, B, both = [0], [0], [0]\nfor i in range(n):\n\tt, a, b = map(int, input().split())\n\tif a == 1 and b == 1:\n\t\tboth.append(t)\n\tif a == 1 and b == 0:\n\t\tA.append(t)\n\tif a == 0 and b == 1:\n\t\tB.append(t)\nA.sort()\nB.sort()\nboth.sort()\nif len(A)-1 + len(both)-1 < k or len(B)-1 + len(both)-1 < k:\n\tprint(-1)\n\treturn\n\nfor i in range(1, len(A)):\n\tA[i] += A[i-1]\nfor i in range(1, len(B)):\n\tB[i] += B[i-1]\ncur = 0\nans = 10**12 + 10\nfor ch in range(len(both)):\n\tcur += both[ch]\n\tif ch > k:\n\t\tbreak\n\t# Need k - ch each from A and B\n\tif k - ch < len(A) and k - ch < len(B):\n\t\tans = min(ans, A[k-ch] + B[k-ch] + cur)\nprint(ans)", "import sys\nn,k=map(int,input().split())\nbothlike=[]\nalike=[]\nblike=[]\nfor i in range(n):\n  t,a,b=map(int,input().split())\n  if a==1 and b==1:\n    bothlike.append(t)\n  if a==1 and b==0:\n    alike.append(t)\n  if a==0 and b==1:\n    blike.append(t)\nif len(alike)+len(bothlike)<k or len(blike)+len(bothlike)<k:\n  print(-1)\n  return\nalike.sort()\nblike.sort()\nbothlike.sort()\nasum=[0]\ncurrent=0\nfor i in range(len(alike)):\n  current+=alike[i]\n  asum.append(current)\nbsum=[0]\ncurrent=0\nfor i in range(len(blike)):\n  current+=blike[i]\n  bsum.append(current)\nbothcurrent=0\nans=10**18\nalen=len(alike)\nblen=len(blike)\nbothlen=len(bothlike)\nfor i in range(bothlen+1):\n  if i>0:\n    bothcurrent+=bothlike[i-1]\n  if i>k:\n    break\n   \n  if k-i>alen or k-i>blen:\n    continue\n  ans=min(ans,asum[k-i]+bsum[k-i]+bothcurrent)\nprint(ans)", "n,k = map(int,input().split())\nablike = []\nalike = []\nblike = []\nfor i in range(n):\n    t,a,b = map(int,input().split())\n    if a == 1 and b == 1:\n        ablike.append(t)\n    elif a == 1:\n        alike.append(t)\n    elif b == 1:\n        blike.append(t)\nablike.sort()\nabtot = len(ablike)\nalike.sort()\natot = len(alike)\nblike.sort()\nbtot = len(blike)\nx = min(atot,btot)\nif abtot + x < k:\n    print(-1)\nelse:\n    p = k\n    i = 0\n    j = 0\n    tot = 0\n    while p > 0:\n        if j < abtot and i < x:\n            if ablike[j] <= (alike[i] + blike[i]):\n                tot = tot + ablike[j]\n                j = j + 1\n                p = p - 1\n            else:\n                tot = tot + alike[i] + blike[i]\n                i = i + 1\n                p = p - 1\n        elif j < abtot:\n            tot = tot + ablike[j]\n            j = j + 1\n            p = p - 1\n        else:\n            tot = tot + alike[i] + blike[i]\n            i = i + 1\n            p = p - 1\n    print(tot)", "n, k = list(map(int, input().split()))\na, m, b = [], [], []\nfor i in range(n):\n    ti, ai, bi = list(map(int, input().split()))\n    if ai == 1 and bi == 1:\n        m.append(ti)\n    elif ai == 1:\n        a.append(ti)\n    elif bi == 1:\n        b.append(ti)\na.sort()\nm.sort()\nb.sort()\npm = [0] * (len(m) + 1)\nfor i in range(1, len(m) + 1):\n    pm[i] = pm[i - 1] + m[i - 1]\npa = [0] * (len(a) + 1)\nfor i in range(1, len(a) + 1):\n    pa[i] = pa[i - 1] + a[i - 1]\npb = [0] * (len(b) + 1)\nfor i in range(1, len(b) + 1):\n    pb[i] = pb[i - 1] + b[i - 1]            \nans = 10 ** 12\nfor c in range(min(k + 1, len(m) + 1)):\n    if min(len(a), len(b)) >= k - c and ans > pm[c] + pa[k - c] + pb[k - c]:\n        ans = pm[c] + pa[k - c] + pb[k - c]\nif ans == 10 ** 12:\n    print(-1)\nelse:\n    print(ans)\n            \n"]