["from fractions import Fraction\nimport bisect\nimport os\nfrom collections import Counter\nimport bisect\nfrom collections import defaultdict\nimport math\nimport random\nimport heapq as hq\nfrom math import sqrt\nimport sys\nfrom functools import reduce, cmp_to_key\nfrom collections import deque\nimport threading\nfrom itertools import combinations\nfrom io import BytesIO, IOBase\nfrom itertools import accumulate\n\n\n# sys.setrecursionlimit(200000)\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef iinput():\n    return int(input())\n\n\ndef tinput():\n    return input().split()\n\n\ndef rinput():\n    return list(map(int, tinput()))\n\n\ndef rlinput():\n    return list(rinput())\n\n\n# mod = int(1e9)+7\n\n\ndef factors(n):\n    return set(reduce(list.__add__,\n                      ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\n\n# ----------------------------------------------------\n# sys.stdin = open('input.txt', 'r')\n# sys.stdout = open('output.txt', 'w')\nfor _ in range(iinput()):\n    n = iinput()\n    a = rlinput()\n    moves = 0\n    i = 0\n    j = n-1\n    prev = 0\n    ans1 = 0\n    ans2 = 0\n    while i <= j:\n        temp = 0\n        f = False\n        while i<=j and i < n and temp <= prev:\n            temp += a[i]\n            f = True\n            i += 1\n        ans1 += temp\n        if f:\n            moves += 1\n        prev = temp\n        temp = 0\n        f = False\n        while j >= i and j > 0 and temp <= prev:\n            temp += a[j]\n            f = True\n            j -= 1\n        ans2 += temp\n        if f:\n            moves += 1\n        prev = temp\n    print(moves,ans1,ans2)\n", "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s1, s2, last, q1, q2, flag = [], [], 0, 0, n-1, 0\n    while q1 <= q2:\n        sum1 = 0\n        while sum1 <= last and q1 <= q2:\n            if flag == 0:\n                sum1 += a[q1]\n                q1 += 1\n            else:\n                sum1 += a[q2]\n                q2 -= 1\n        if flag == 0:\n            s1.append(sum1)\n        else:\n            s2.append(sum1)\n        flag, last = 1-flag, sum1\n    print(len(s1)+len(s2), sum(s1), sum(s2))\n", "for t in range(int(input())):\n    n = int(input())\n    cand = list(map(int, input().split()))\n    a = 0\n    b = 0\n    i = 0\n    j = n - 1\n    prev = 0\n    moves = 0\n    while i <= j:\n        curr = 0\n        while i <= j and curr <= prev:\n            curr += cand[i]\n            i += 1\n        a += curr\n        prev = curr\n        moves += bool(curr)\n        curr = 0\n        while i <= j and curr <= prev:\n            curr += cand[j]\n            j -= 1\n        b += curr\n        prev = curr\n        moves += bool(curr)\n    print(moves, a, b)\n", "t = int(input())\nfor _ in range(t):\n    a = 0\n    b = 0\n    n = int(input())\n    As = list(map(int,input().split()))\n    left = 0\n    right = n - 1\n\n    a += As[0]\n    left = 1\n    min = As[0]\n\n    curr = 0\n    turn = False\n    count = 1\n    while left <= right:\n        if turn:\n            a += As[left]\n            curr += As[left]\n            left += 1\n        else:\n            b += As[right]\n            curr += As[right]\n            right -= 1\n        if curr > min:\n            count += 1\n            min = curr\n            curr = 0\n            turn = not turn\n    if curr != 0:\n        count += 1\n    print(count, a, b)\n", "for _ in range(int(input())):\n\tn = int(input())\n\tL = list(map(int, input().split()))\n\ta, b = 0, 0\n\tla, lb = 0, 0\n\ti, j = 0, n-1\n\trnds = 0\n\twhile i <= j:\n\t\tca = 0\n\t\twhile i <= j and ca <= lb:\n\t\t\tca += L[i]\n\t\t\ti += 1\n\t\ta += ca\n\t\tla = ca\n\n\t\trnds += 1\n\t\tif i > j:\n\t\t\tbreak\n\n\t\tcb = 0\n\t\twhile i <= j and cb <= la:\n\t\t\tcb += L[j]\n\t\t\tj -= 1\n\t\tb += cb\n\t\tlb = cb\n\n\t\trnds += 1\n\tprint(rnds, a, b)\n", "from math import *\n\nfor zz in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    i = 0\n    j = n - 1\n    ans = 0\n    ct = 0\n    ps = 0\n    x = 0\n    y = 0\n    while i <= j:\n        cs= 0 \n        if ct == 0:\n            while i <= j and cs <= ps:\n                cs += a[i]\n                i += 1\n            x += cs\n        else:\n            while i <= j and cs <= ps:\n                cs += a[j]\n                j -= 1\n            y += cs\n        ps = cs\n        ct = 1 - ct\n        ans += 1\n    print(ans, x, y)\n", "import math\nfor _ in range(int(input())):\n\tn=int(input())\n\tli=list(map(int,input().split()))\n\ta=0\n\tb=0\n\tl=0\n\tr=n-1\n\tp=0\n\tq=0\n\twhile(l<=r):\n\t\tif q%2==0:\n\t\t\tsu=0\n\t\t\tfor i in range(l,r+1):\n\t\t\t\tl+=1\n\t\t\t\tsu+=li[i]\n\t\t\t\ta+=li[i]\n\t\t\t\tif (su>p):\n\t\t\t\t\tp=su\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tsu=0\n\t\t\tfor i in range(r,l-1,-1):\n\t\t\t\tr-=1\n\t\t\t\tsu+=li[i]\n\t\t\t\tb+=li[i]\n\t\t\t\tif (su>p):\n\t\t\t\t\tp=su\n\t\t\t\t\tbreak\n\t\tq+=1\n\tprint(q,a,b)\n\n\n\n\n\n\n\t\n", "t=int(input())\nfor i in range (t):\n    n=int(input())\n    A=[int(x) for x in input().split()]\n    x=A[0]\n    l=1\n    r=n-1\n    a=x\n    b=0\n    p=1\n    while l<=r:\n        p+=1\n        c=0\n        while c<=x and l<=r:\n            c+=A[r]\n            r-=1\n        b+=c\n        if c<=x or l>r:\n            break\n        x=c\n\n        p+=1\n        c=0\n        while c<=x and l<=r:\n            c+=A[l]\n            l+=1\n        a+=c\n        if c<=x or l>r:\n            break\n        x=c\n\n    print(p,a,b)", "T = int(input())\n\nfor t in range(T):\n    N = int(input())\n    A = [int(_) for _ in input().split()]\n\n    L = 0\n    R = N-1\n    turn = 0\n    previous = 0\n    alice = 0\n    bob = 0\n    moves = 0\n\n    while L <= R:\n        eaten = 0\n        while eaten <= previous and L <= R:\n            if turn == 0:\n                eaten += A[L]\n                alice += A[L]\n                L += 1\n            else:\n                eaten += A[R]\n                bob += A[R]\n                R -= 1\n        previous = eaten\n        turn = 1 - turn\n        moves += 1\n\n    print(moves, alice, bob)\n", "import sys\n\n\ninput()\nfor candies in sys.stdin.readlines()[1::2]:\n    candies = [int(c) for c in candies.split()]\n    a, b = 0, 0\n    idxA, idxB, move = 0, len(candies) - 1, 0\n\n    eaten = 0\n    while idxA <= idxB:\n        lastEaten = eaten\n        eaten = 0\n        if move & 1 == 0:\n            while idxA <= idxB and eaten <= lastEaten:\n                a += candies[idxA]\n                eaten += candies[idxA]\n                idxA += 1\n        else:\n            while idxB >= idxA and eaten <= lastEaten:\n                b += candies[idxB]\n                eaten += candies[idxB]\n                idxB -= 1\n\n        move += 1\n\n    print(move, a, b)\n", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\ndef solve():\n\tn = mint()\n\tc = list(mints())\n\tl = 1\n\tr = n\n\ta = c[0]\n\tb = 0\n\tla = c[0]\n\tlb = 0\n\tans = 1\n\twhile l<r:\n\t\tx = 0\n\t\tans += 1\n\t\twhile x <= la and l < r:\n\t\t\tr -= 1\n\t\t\tx += c[r]\n\t\tlb = x\n\t\tb += x\n\t\tif l >= r:\n\t\t\tbreak\n\t\tans += 1\n\t\tx = 0\n\t\twhile x <= lb and l < r:\n\t\t\tx += c[l]\n\t\t\tl += 1\n\t\tla = x\n\t\ta += x\n\tprint(ans, a, b)\n\nfor i in range(mint()):\n\tsolve()\n", "def solve(n, sizes):\n    last = sizes[0]\n\n    result = {'n_steps': 1,\n              'a': last,\n              'b': 0, }\n\n    flag_a = 1     # next candy to eat\n    flag_b = n - 1\n    turn = 'b'\n\n    if flag_a == flag_b + 1:\n        return result\n\n    while True:\n        cur = 0\n        result['n_steps'] += 1\n\n        if flag_a == flag_b + 1:\n            return result\n\n        if turn == 'a':\n            while cur <= last:\n                cur += sizes[flag_a]\n                result['a'] += sizes[flag_a]\n                flag_a += 1\n                if flag_a == flag_b + 1:\n                    return result\n\n            last = cur\n            turn = 'b'\n        else:\n            while cur <= last:\n                cur += sizes[flag_b]\n                result['b'] += sizes[flag_b]\n                flag_b -= 1\n                if flag_a == flag_b + 1:\n                    return result\n\n            last = cur\n            turn = 'a'\n\n\ndef main():\n    tests = int(input())\n\n    for t in range(tests):\n        n = int(input())\n        sizes = list(map(int, input().split()))\n        result = solve(n, sizes)\n\n        print(result['n_steps'], result['a'], result['b'])\n\n\nmain()\n", "import sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nt = int(input())\nfor _ in range(t):\n\tn = int(input())\n\tc = list(map(int, input().split()))\n\tif n == 1:\n\t\tprint(1, c[0], 0)\n\t\tcontinue\n\tM = c[0]\n\tl, r = 1, n\n\ta, b = c[0], 0\n\tfor i in range(1, 1000000):\n\t\tif i%2 == 0:\n\t\t\ta_tmp = 0\n\t\t\twhile a_tmp <= M and l < r:\n\t\t\t\ta_tmp += c[l]\n\t\t\t\ta += c[l]\n\t\t\t\tl += 1\n\t\t\tif l == r:\n\t\t\t\tbreak\n\t\t\tM = a_tmp\n\t\telse:\n\t\t\tb_tmp = 0\n\t\t\twhile b_tmp <= M and l < r:\n\t\t\t\tb_tmp += c[r-1]\n\t\t\t\tb += c[r-1]\n\t\t\t\tr -= 1\n\t\t\tif l == r:\n\t\t\t\tbreak\n\t\t\tM = b_tmp\n\tprint(i+1, a, b)", "for f in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    i=0\n    j=n-1\n    alice=0\n    bob=0\n    prev=0\n    turn=0\n    k=0\n    while i<=j:\n        cur=0\n        if turn==0:\n            while cur<=prev and i<=j:\n                alice+=a[i]\n                cur+=a[i]\n                i+=1\n        else:\n            while cur<=prev and i<=j:\n                bob+=a[j]\n                cur+=a[j]\n                j-=1\n        k+=1\n        turn=1-turn\n        prev=cur\n    print(k,alice,bob)", "import sys\ninput = sys.stdin.readline\n\nfor t in range(int(input())):\n    n = int(input())\n    l = list(map(int,input().split()))\n    a = l.pop(0); b = 0; move = 0; ad = a; bd = 0; able = True; count = 1\n    while l:\n        bd = 0\n        while bd <= ad:\n            bd += l.pop(-1)\n            if l == []:\n                able = False\n                break\n        b += bd; count += 1\n        if able == False:\n            break\n        ad = 0\n        while ad <= bd:\n            ad += l.pop(0)\n            if l == []:\n                able = False\n                break\n        a += ad; count += 1\n        if able == False:\n            break\n    print(count, a, b)\n", "from _collections import deque\n\nfor _ in range(int(input())):\n    n = int(input())\n    ar = list(map(int, input().split()))\n    ar = deque(ar)\n    turn = 0\n    a, b = 0, 0\n    num2 = 0\n    x = 0\n    while ar:\n        if turn == 0:\n            num1 = 0\n            while ar and num1 <= num2:\n                num1 += ar[0]\n                ar.popleft()\n            a += num1\n            num2 = num1\n            turn = 1\n        else:\n            num1 = 0\n            while ar and num1 <= num2:\n                num1 += ar[-1]\n                ar.pop()\n            b += num1\n            num2 = num1\n            turn = 0\n        x += 1\n    print(x, a, b)", "\nt = int(input())\n\nfor loop in range(t):\n\n    n = int(input())\n\n    lis = list(map(int,input().split()))\n\n    ai = 0\n    bi = n-1\n\n    A = [0]\n    B = [0]\n    move = 0\n\n    while True:\n\n        if ai > bi:\n            break\n\n        na = 0\n        while na <= B[-1]:\n\n            if ai > bi:\n                break\n\n            na += lis[ai]\n            ai += 1\n\n        A.append(na)\n        if na > 0:\n            move += 1\n\n        nb = 0\n        while nb <= A[-1]:\n\n            if ai > bi:\n                break\n\n            nb += lis[bi]\n            bi -= 1\n        B.append(nb)\n        if nb > 0:\n            move += 1\n\n    print(move,sum(A),sum(B))\n                \n"]