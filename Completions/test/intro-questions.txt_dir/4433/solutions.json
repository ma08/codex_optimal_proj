["n, m = map(int, input().split())\ng = []\nfor i in range(n):\n    g.append([])\nfor i in range(m):\n    u, v = map(int, input().split())\n    u-=1\n    v-=1\n    g[u]+=[v]\n    g[v]+=[u]\n\nstart = max(range(n), key=lambda i: len(g[i]))\nedges = []\nvis = [False] * n\nq = [start]\nvis[start] = True\nwhile q:\n    u = q.pop(0)\n    for v in g[u]:\n        if vis[v]:\n            continue\n        vis[v] = True\n        edges.append((u, v))\n        q.append(v)\n\nfor u, v in edges:\n    print(u+1, v+1)", "# -*- coding: utf-8 -*-\n# @Time    : 2019/3/7 23:52\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : F1. Spanning Tree with Maximum Degree.py\n\nfrom collections import defaultdict\nfrom collections import deque\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    edge_dict = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edge_dict[u].append(v)\n        edge_dict[v].append(u)\n\n    max_root, max_degree = 0, 0\n    for i in range(1, n + 1):\n        if len(edge_dict[i]) > max_degree:\n            max_root, max_degree = i, len(edge_dict[i])\n    # print(max_root, max_degree)\n\n    queue, visit = deque(), set()\n    queue.append(max_root)\n    visit.add(max_root)\n\n    ret = []\n    while queue:\n        u = queue.popleft()\n        for v in edge_dict[u]:\n            if v not in visit:\n                visit.add(v)\n                queue.append(v)\n                ret.append((u, v))\n    for u, v in ret:\n        print(u, v)\n\n\ndef __starting_point():\n    main()\n__starting_point()", "from collections import defaultdict\nn,m=list(map(int,input().split()))\nad=defaultdict(list)\nans=[]\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    ad[x].append(y)\n    ad[y].append(x)\ndef BFS(s): \n  \n        visited = [False] * (n+1)\n  \n        # Create a queue for BFS \n        queue = []\n        k=0\n  \n        # Mark the source node as  \n        # visited and enqueue it \n        queue.append(s) \n        visited[s] = True\n  \n        while k<len(queue): \n  \n            s = queue[k]\n            k+=1\n            for i in ad[s]: \n                if visited[i] == False: \n                    queue.append(i)\n                    ans.append((s,i))\n                    visited[i] = True\n        for i in range(n-1):\n            print(ans[i][0],ans[i][1])\nm=0;s=1\nfor i in ad:\n    if len(ad[i])>m:\n        m=len(ad[i]);s=i\nBFS(s)\n\n    \n", "import collections\nn,m = [int(x) for x in input().split()]\n\nG = []\nfor _ in range(n):\n    G.append([])\n    \nfor _ in range(m):\n    a,b = [int(x)-1 for x in input().split()]\n    G[a].append((a,b))\n    G[b].append((b,a))\n\nbest,index = 0,0\nfor i in range(n):\n    if len(G[i]) > best:\n        best = len(G[i])\n        index = i\n    \n    \nvisited, edges = [0]*n, []\nvisited[index] = 1\nqueue = collections.deque(G[index])\nwhile queue:\n    vertex = queue.popleft()\n    if visited[vertex[1]] == 0:\n        visited[vertex[1]] = 1\n        edges.append((vertex))\n        queue.extend(G[vertex[1]])\n\nfor e in edges:\n    print(e[0]+1,e[1]+1)", "n, m = map(int, input().split())\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\n\nroot = 0\nfor i in range(n):\n    if len(g[i]) > len(g[root]):\n        root = i\n\nuf = [-1 for _ in range(n)]\n\ndef find(u):\n    if uf[u] < 0:\n        return u\n    else:\n        ans = find(uf[u])\n        uf[u] = ans\n        return ans\n\ndef merge(u, v):\n    pu = find(u)\n    pv = find(v)\n    if pu == pv:\n        return\n    if uf[pu] > uf[pv]:\n        pu, pv = pv, pu\n    uf[pu] += uf[pv]\n    uf[pv] = pu\n\nans = []\nfor v in g[root]:\n    merge(root, v)\n    ans.append((root+1, v+1))\nfor i in range(n):\n    for v in g[i]:\n        if find(i) != find(v):\n            merge(i, v)\n            ans.append((i+1, v+1))\nprint('\\n'.join(map(lambda x: '{} {}'.format(x[0], x[1]), ans)))", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nE=[list(map(int,input().split())) for i in range(m)]\n\ncost=[0]*(n+1)\n\nEDGELIST=[[] for i in range(n+1)]\n\nfor x,y in E:\n    cost[x]+=1\n    cost[y]+=1\n\n    EDGELIST[x].append(y)\n    EDGELIST[y].append(x)\n\nx=cost.index(max(cost))\n#print(x)\n\nfrom collections import deque\nQUE=deque([x])\n\ncheck=[0]*(n+1)\n\nANS=[]\nwhile QUE:\n    x=QUE.popleft()\n    check[x]=1\n\n    for to in EDGELIST[x]:\n        if check[to]==0:\n            ANS.append([x,to])\n            QUE.append(to)\n            check[to]=1\n        \n#print(ANS)\nfor x,y in ANS:\n    print(x,y)\n", "n, m = list(map(int, input().split()))\nadj = {}\nnincident = [0, ] * (n + 1)\nedges = []\n\nfor i in range(1, n + 1):\n    adj[i] = []\n\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    edges.append((u, v))\n\n    adj[u].append(v)\n    adj[v].append(u)\n\n    nincident[u] += 1\n    nincident[v] += 1\n\nvmax = 0\nfor v in range(1, n + 1):\n    if nincident[v] > nincident[vmax]:\n        vmax = v\n\nresult = []\n\nrank = [0, ] * (n + 1)\nparent = [0, ] * (n + 1)\n\ndef make_set(i):\n    rank[i] = 0\n    parent[i] = i\n\ndef find_set(i):\n    if i != parent[i]:\n        parent[i] = find_set(parent[i])\n    return parent[i]\n\ndef union_op(x, y):\n    s_x = find_set(x)\n    s_y = find_set(y)\n\n    if rank[s_x] < rank[s_y]:\n        parent[s_x] = s_y\n    else:\n        parent[s_y] = s_x\n        if rank[s_y] == rank[s_x]:\n            rank[s_x] += 1\n\nfor i in range(1, n + 1):\n    make_set(i)\n\nfor u in adj[vmax]:\n    result.append((u, vmax))\n    union_op(u, vmax)\n\nfor e in edges:\n    if find_set(e[0]) != find_set(e[1]):\n        result.append(e)\n        union_op(e[0], e[1])\n\nfor e in result:\n    print(e[0], e[1])\n", "n, m = list(map(int, input().split()))\na = [list(map(int, input().split())) for i in range(m)]\n\nb = [[] for j in range(n)]\n\nfor i in range(m):\n    b[a[i][0] - 1].append(a[i][1] - 1)\n    b[a[i][1] - 1].append(a[i][0] - 1)\n\n\nstm = 0\nstv = 0\nused = [0] * n\nfor i in range(n):\n    if len(b[i]) > stm:\n        stm = len(b[i])\n        stv = i\n\nocher = [0] * 1000009\nu = 0\nk = 1\nocher[0] = stv\n\n\ndef bfs(x):\n    nonlocal k\n    for i in range(len(b[x])):\n        if used[b[x][i]] == 0:\n            print(x + 1, b[x][i] + 1)\n            used[b[x][i]] = 1\n            ocher[k] = b[x][i]\n            k += 1\n\n\n\nused[stv] = 1\nwhile k - u > 0:\n    bfs(ocher[u])\n    u += 1\n\n", "n,m = list(map(int,input().split()))\n\nd = {i+1:[] for i in range(n)}\n\nfor i in range(m):\n    a,b = list(map(int,input().split()))\n\n    d[a].append(b)\n    d[b].append(a)\n\nmaxln = len(d[1])\nmaxel = 1\n\nfor i in d:\n    if len(d[i]) > maxln:\n        maxel = i\n        maxln = len(d[i])\n        \nl = [maxel]\nk = 0\nvisit = [0 for i in range(n)]\nvisit[maxel-1] = 1\n\nwhile k < len(l):\n    for i in range(len(d[l[k]])):\n        if visit[d[l[k]][i]-1] == 0:\n            print(d[l[k]][i],l[k])\n            visit[d[l[k]][i]-1] = 1\n            l.append(d[l[k]][i])\n\n    k += 1\n", "n,m = map(int, input().strip().split())\nl = [[] for i in range(n+1)]\ncount = [0 for i in range(n+1)]\nfor i in range(m):\n    a,b = map(int, input().strip().split())\n    l[a].append(b)\n    l[b].append(a)\n    count[a] += 1\n    count[b] += 1\nmx = 0\nv = -1\nfor i in range(n+1):\n    if count[i] > mx:\n        mx = count[i]\n        v = i\nlayer = l[v]\nused = [False for i in range(n+1)]\nused[v] = True\nfor i in l[v]:\n    print (v,i)\n    used[i] = True\nwhile layer != []:\n    newlayer = []\n    for i in layer:\n        for j in l[i]:\n            if used[j] == False:\n                print(i,j)\n                newlayer.append(j)\n                used[j] = True\n    layer = newlayer", "from collections import deque\n\nn, m = map(int, input().split())\ne = []\na = [[] for i in range(n)]\n\nfor i in range(m):\n    fr, to = map(int, input().split())\n    e.append((fr, to))\n    a[fr - 1].append(to - 1)\n    a[to - 1].append(fr - 1)\n\nroot = 0\nmaxPow = 0\nfor i in range(n):\n    if len(a[i]) > maxPow:\n        root = i\n        maxPow = len(a[i])\n\nvisited = set()\nd = deque()\n\nd.append(root)\nvisited.add(root)\nwhile len(d) != 0:\n    cur = d.popleft()\n    for adj in a[cur]:\n        if adj not in visited:\n            print(cur + 1, adj + 1)\n            visited.add(adj)\n            d.append(adj)", "from collections import deque\nn, m = list(map(int, input().split()))\na = []\nrinsetu = [[] for i in range(n+1)]\ncount = [0 for i in range(n+1)]\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    count[u] += 1\n    count[v] += 1\n    a.append([u,v])\n    rinsetu[u].append(v)\n    rinsetu[v].append(u)\nroot = count.index(max(count))\n\n\n\nvisitflag = [0 for i in range(n+1)]\nqueue = deque([root])\nwhile len(queue) > 0:\n    now = queue.popleft()\n    for i in rinsetu[now]:\n        if visitflag[i] == 0:\n            visitflag[i] = now\n            queue.append(i)\n\nfor i in range(1, n+1):\n    if i == root:\n        continue\n    else:\n        print(i, visitflag[i])\n", "from collections import deque\nn, m = list(map(int, input().split()))\na = []\nrinsetu = [[] for i in range(n+1)]\ncount = [0 for i in range(n+1)]\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    count[u] += 1\n    count[v] += 1\n    a.append([u,v])\n    rinsetu[u].append(v)\n    rinsetu[v].append(u)\nroot = count.index(max(count))\n\n\n\nvisitflag = [0 for i in range(n+1)]\nqueue = deque([root])\nwhile len(queue) > 0:\n    now = queue.popleft()\n    for i in rinsetu[now]:\n        if visitflag[i] == 0:\n            visitflag[i] = now\n            queue.append(i)\n\nfor i in range(1, n+1):\n    if i == root:\n        continue\n    else:\n        print(i, visitflag[i])\n", "\n\nn, m = list(map(int, input().split()))\ng = [[] for i in range(n + 1)]\nans = set()\nfor i in range(m):\n\tx, y = list(map(int, input().split()))\n\tif y > x:\n\t\tx, y= y, x\n\tg[x].append(y)\n\tg[y].append(x)\n#print(g)\n\nim = 0\nmx = 0\nused = [False] * (n + 1)\nfor i in range(1, n + 1):\n\tif len(g[i]) > mx:\n\t\tmx = len(g[i])\n\t\tim = i\nrip = set()\n\nq = [im]\n\nk = 0\nd = [0] * (n + 1)\nd[im] = 1\nwhile len(q) > k:\n\tfor v in g[q[k]]:\n\t\tif d[v] == 0:\n\t\t\tprint(v, q[k])\n\t\t\td[v] = 1\n\t\t\tq.append(v)\n\tk += 1\n", "\n\nn, m = list(map(int, input().split()))\ng = [[] for i in range(n + 1)]\nans = set()\nfor i in range(m):\n\tx, y = list(map(int, input().split()))\n\tif y > x:\n\t\tx, y= y, x\n\tg[x].append(y)\n\tg[y].append(x)\n#print(g)\n\nim = 0\nmx = 0\nused = [False] * (n + 1)\nfor i in range(1, n + 1):\n\tif len(g[i]) > mx:\n\t\tmx = len(g[i])\n\t\tim = i\nrip = set()\n\nq = [im]\n\nk = 0\nd = [0] * (n + 1)\nd[im] = 1\nwhile len(q) > k:\n\tfor v in g[q[k]]:\n\t\tif d[v] == 0:\n\t\t\tprint(v, q[k])\n\t\t\td[v] = 1\n\t\t\tq.append(v)\n\tk += 1\n", "n,m=list(map(int,input().split()))\nadj=[0]*(n+1)\nfor i in range(n+1):\n\tadj[i]=[]\ns=0\nfor i in range(m):\n\tx,y=list(map(int,input().split()))\n\tadj[x].append(y)\n\tadj[y].append(x)\n\tif len(adj[x])>len(adj[s]):\n\t\ts=x\n\tif len(adj[y])>len(adj[s]):\n\t\ts=y\nstk=[]\nmp={}\nmp[s]=1\nfor i in range(len(adj[s])):\n\tstk.append([s,adj[s][i]])\n\tif adj[s][i] not in mp:\n\t\tmp[adj[s][i]]=1\ni=0\n# for l in mp:\n# \tprint (l)\nwhile(i<len(stk)):\n\tk=stk[i][1]\n\tfor j in range(len(adj[k])):\n\t\tif k not in mp or adj[k][j] not in mp:\n\t\t\tstk.append([k,adj[k][j]])\n\t\t\tmp[k]=1\n\t\t\tmp[adj[k][j]]=1\n\ti+=1\nfor i in range(len(stk)):\n\tprint(*stk[i])\n", "n,m=list(map(int,input().split()))\nadj=[0]*(n+1)\nfor i in range(n+1):\n\tadj[i]=[]\ns=0\nfor i in range(m):\n\tx,y=list(map(int,input().split()))\n\tadj[x].append(y)\n\tadj[y].append(x)\n\tif len(adj[x])>len(adj[s]):\n\t\ts=x\n\tif len(adj[y])>len(adj[s]):\n\t\ts=y\nstk=[]\nmp={}\nmp[s]=1\nvis=[0]*(n+1)\nfor i in range(len(adj[s])):\n\tstk.append([s,adj[s][i]])\n\tif adj[s][i] not in mp:\n\t\tmp[adj[s][i]]=1\ni=0\nvis[s]=1\n# for l in mp:\n# \tprint (l)\n\nwhile(i<len(stk)):\n\tk=stk[i][1]\n\tif vis[k]==0:\n\t\tfor j in range(len(adj[k])):\n\t\t\tif k not in mp or adj[k][j] not in mp:\n\t\t\t\tstk.append([k,adj[k][j]])\n\t\t\t\tmp[k]=1\n\t\t\t\tmp[adj[k][j]]=1\n\t\tvis[k]=1\n\ti+=1\nfor i in range(len(stk)):\n\tprint(*stk[i])\n", "n, m = list(map(int, input().split()))\ng = [[] for i in range(n + 1)]\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    g[u].append(v)\n    g[v].append(u)\n\nroot = 0\nfor i in range(1, n + 1):\n    if len(g[i]) > len(g[root]):\n        root = i\n\nfrom collections import deque\n\nvisited = [False for i in range(n + 1)]\n\nq = deque([root])\nvisited[root] = True\n\nwhile len(q) > 0:\n    u = q.popleft()\n    for v in g[u]:\n        if not visited[v]:\n            q.append(v)\n            print(u, v)\n            visited[v] = True\n\n", "from collections import deque as queue\n\nn, m = list(map(int, input().split()))\nused = [0] * n\nedges = [[] for _ in range(n)]\na = []\nq = queue(a, 200000)\n\ndef bfs(z):\n    used[z] = 1\n    q.append(z)\n    while q:\n        x = q.popleft()\n        for i in edges[x]:\n            if not used[i]:\n                q.append(i)\n                print(x + 1, i + 1)\n                used[i] = 1\n\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    edges[a - 1].append(b - 1)\n    edges[b - 1].append(a - 1)\n\nk = 0\nfor i in range(n):\n    k = max(k, len(edges[i]))\n    \nfor i in range(n):\n    if len(edges[i]) == k:\n        bfs(i)\n        break\n", "n,m=[int(x) for x in input().split()]\ngraph={}\nfor i in range(m):\n    a,b=[int(x) for x in input().split()]\n    for a,b in (a,b),(b,a):\n        if a not in graph:\n            graph[a]=[b]\n        else:\n            graph[a].append(b)\ndef tree(new):\n    total=[]\n    for v in new:\n        for item in graph[v]:\n            if item not in invite:\n                total.append((v,item))\n                invite.add(item)\n                new.append(item)\n    return total\nindex=max_rou=0\nfor v in graph:\n    if len(graph[v])>max_rou:\n        max_rou=len(graph[v])\n        index=v\ninvite=set([index])\nanswer=(tree([index]))\nfor i in range(n-1):\n    print(*answer[i])\n"]