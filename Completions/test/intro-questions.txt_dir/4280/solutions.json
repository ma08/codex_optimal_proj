["import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\nR=[list(map(int,input().split())) for i in range(n-1)]\n\nRDICT={tuple(sorted([R[i][0],R[i][1]])):i for i in range(n-1)}\n\nC=[[] for i in range(n+1)]\n\nfor x,y in R:\n    C[x].append(y)\n    C[y].append(x)\n\nCLEN=[]\nfor i in range(1,n+1):\n    CLEN.append(len(C[i]))\n    \nfrom collections import Counter\ncounter=Counter(CLEN)\n\nCV=sorted(list(counter.keys()),reverse=True)\n\ncvsum=0\ncities=1\n\nfor cv in CV:\n    cvsum+=counter[cv]\n    if cvsum>k:\n        cities=cv\n        break\n\nprint(cities)\nANS=[0]*(n-1)\n\nfrom collections import deque\nQUE = deque()\nQUE.append([1,1])\nVISITED=[0]*(n+1)\n\nwhile QUE:\n    city,roadnum=QUE.pop()\n    VISITED[city]=1\n\n    for to in C[city]:\n        if VISITED[to]==0:\n            ANS[RDICT[tuple(sorted([city,to]))]]=roadnum\n            roadnum=roadnum%cities+1\n            QUE.append([to,roadnum])\n\nprint(*ANS)\n        \n    \n\n", "# import time\n\ndef set_color(edge, colors, color):\n    colors[edge] = color\n    colors[(edge[1], edge[0])] = color\n\ndef set_node_color(node, parent, parent_color, index, bad_nodes, colors):\n    color = 1\n    for child_node in (child for child in index[node] if child != parent):\n        if color == parent_color:\n            color += 1\n        new_color = parent_color if node in bad_nodes else color\n        color += 1\n        set_color((node, child_node), colors, new_color)\n        set_node_color(child_node, node, new_color, index, bad_nodes, colors)\n\ndef solve(n, k, edges):\n    colors = {edge: None for edge in edges}\n    index = {i : set() for i in range(1, n + 1)}\n    for a, b in edges:\n        index[a].add(b)\n        index[b].add(a)\n    nodes = sorted(list(range(1, n + 1)), key=lambda x: len(index[x]), reverse=True)\n    bad_nodes = set(nodes[:k])\n\n    frontier = [(nodes[k], None, None)]\n    while frontier:\n        # print(len(frontier))\n        next_, parent_node, parent_color = frontier.pop()\n        # print('pop:', next_)\n        color = 1\n        for child_node in (ele for ele in index[next_] if ele != parent_node):\n            if color == parent_color:\n                color += 1\n            new_color = parent_color if next_ in bad_nodes else color\n            set_color((next_, child_node), colors, new_color)\n            color += 1\n            frontier.append((child_node, next_, new_color))\n            # print('append:', child_node)\n\n    # set_node_color(nodes[k], None, None, index, bad_nodes, colors)\n    return [colors[edge] for edge in edges]\n\ndef main():\n    n, k = map(int, input().split())\n    edges = []\n    for i in range(n - 1):\n        edges.append(tuple(map(int, input().split())))\n    # n, k = 200000, 0\n    # edges = [(n, n + 1) for n in range(1, n)]\n    # n, k = 6, 2\n    # edges = [(1, 4), (4, 3), (3, 5), (3, 6), (5, 2)]\n    # tick = time.time()\n    result = solve(n, k, edges)\n    print(len(set(result)))\n    print(' '.join(map(str, result)))\n    # tock = time.time()\n    # print('T:', round(tock - tick, 5))\n\ndef __starting_point():\n    main()\n__starting_point()", "def strelizia():\n\toh_pie = 0\n\tkaguya = 0\n\towe_pie = [(0, 0, 0)]\n\twhile (kaguya <= oh_pie):\n\t\to_pie = oh_pie\n\t\twhile (kaguya <= o_pie):\n\t\t\tx = owe_pie[kaguya][0]\n\t\t\tp = owe_pie[kaguya][1]\n\t\t\tc = 1\n\t\t\tl = len(stamen[x])\n\t\t\tif (l > virm):\n\t\t\t\tfor (to, ed) in stamen[x]:\n\t\t\t\t\tif (to != p):\n\t\t\t\t\t\tdarling[ed - 1] = c\n\t\t\t\t\t\towe_pie.append((to, x, c))\n\t\t\t\t\t\toh_pie += 1\n\t\t\telse:\n\t\t\t\tfor (to, ed) in stamen[x]:\n\t\t\t\t\tif (c == owe_pie[kaguya][2]):\n\t\t\t\t\t\tc += 1\n\t\t\t\t\tif (to != p):\n\t\t\t\t\t\tdarling[ed - 1] = c\n\t\t\t\t\t\towe_pie.append((to, x, c))\n\t\t\t\t\t\toh_pie += 1\n\t\t\t\t\t\tc += 1\n\t\t\tkaguya += 1\n\ndarling = []\n\nfranxx = input().split()\n\npistil = []\nstamen = []\n\nfor i in range(0, int(franxx[0])):\n\tpistil.append(0)\n\tstamen.append([])\n\nfor i in range(1, int(franxx[0])):\n\tdarling.append(0)\n\tedge = input().split()\n\tstamen[int(edge[0]) - 1].append((int(edge[1]) - 1, i))\n\tstamen[int(edge[1]) - 1].append((int(edge[0]) - 1, i))\n\tpistil[int(edge[0]) - 1] += 1\n\tpistil[int(edge[1]) - 1] += 1\n\npistil.sort()\n\nvirm = pistil[int(franxx[0]) - int(franxx[1]) - 1]\n\nprint(virm)\nstrelizia()\nfor i in range(1, int(franxx[0])):\n\tprint(darling[i - 1], end = \" \")", "import sys\nfrom collections import deque\n\n\ndef norm_edge(i, j):\n    return (i, j) if i < j else (j, i)\n\ninpt = sys.stdin.read().split('\\n')\nn, k = list(map(int, inpt[0].split()))\nedges = []\nfor edge_str in inpt[1:n]:\n    i, j = tuple([int(x) - 1 for x in edge_str.split()])\n\n    edges.append(norm_edge(i, j))\n\ndegree = [0 for _ in range(n)]\nneigh = [[] for _ in range(n)]\nfor i, j in edges:\n    degree[i] += 1\n    degree[j] += 1\n    neigh[i].append(j)\n    neigh[j].append(i)\n\nr = sorted(degree)[-(k + 1)]\nprint(r)\n\nvisited = set()\ncolor = {}\n\nq = deque([0])\nvisited = set([0])\nwhile len(q) > 0:\n    i = q.popleft()\n\n    used_color = None\n    for j in neigh[i]:\n        if j not in visited:\n            visited.add(j)\n            q.append(j)\n        e = norm_edge(i, j)\n        if used_color is None and e in color:\n            used_color = color[e]\n    next_color = 0\n    for j in neigh[i]:\n        e = norm_edge(i, j)\n        if e in color:\n            continue\n\n        if next_color == used_color:\n            next_color += 1\n        color[e] = next_color % r if next_color >= r else next_color\n        next_color += 1\n\nprint(' '.join([str(color[e] + 1) for e in edges]))\n\n\n# for i in range(n):\n#     print(\"Node\", i)\n#     for j in neigh[i]:\n#         e = norm_edge(i, j)\n#         print(\"    \", e, color[e])\n"]