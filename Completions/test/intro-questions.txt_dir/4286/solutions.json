["import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nA=list(map(int,input().split()))\n\nSP=[list(map(int,input().split())) for i in range(m)]\n\nMIN=min(A)\nx=A.index(MIN)\nEDGE_x=[[x+1,i+1,A[x]+A[i]] for i in range(n) if x!=i]\n\nEDGE=EDGE_x+SP\n\nEDGE.sort(key=lambda x:x[2])\n\n#UnionFind\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nANS=0\nfor i,j,x in EDGE:\n    if find(i)!=find(j):\n        ANS+=x\n        Union(i,j)\n\nprint(ANS)\n", "n, m = map(int, input().split())\na = list(map(int, input().split()))\ne = []\nfor _ in range(m) : \n    u, v, w = map(int, input().split())\n    e.append((u-1, v-1, w))\na = sorted(zip(a, range(n)), key = lambda x : x[0])\nfor i in range(1, n) : \n    e.append((a[0][1], a[i][1], a[0][0] + a[i][0]))\n\nfa = list(range(n))\nrk = [0] * n\n\ndef find(x) :\n    while fa[x] != x :\n        fa[x] = fa[fa[x]]\n        x = fa[x]\n    return x\n\ndef unite(u, v) :\n    u, v = map(find, (u, v))\n    if u == v : return False\n    if rk[u] < rk[v] : u, v = v, u\n    fa[v] = u\n    if rk[u] == rk[v] : rk[u] += 1\n    return True\n\ne.sort(key = lambda x : x[2])\n\nans = 0\ncnt = 1\nfor ee in e :\n    if cnt == n : break\n    if unite(ee[0], ee[1]) :\n        ans += ee[2]\n        cnt += 1\n\nprint(ans)", "def main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [tuple(map(int, input().split())) for i in range(m)]\n\n    rt = a.index(min(a))\n    e = [(a[i] + a[rt], rt, i) for i in range(n) if i != rt] + [(w, u - 1, v - 1) for u, v, w in b]\n    e.sort()\n\n    p = [i for i in range(n)]\n    r = [0] * n\n\n    def find(x):\n        if p[x] != x: p[x] = find(p[x])\n        return p[x]\n\n    def check_n_unite(x, y):\n        x, y = find(x), find(y)\n        if x == y: return 0\n        if r[x] < r[y]: x, y = y, x\n        p[y] = x\n        if r[x] == r[y]: r[x] += 1\n        return 1\n\n    ans = 0\n    for w, u, v in e:\n        if check_n_unite(u, v):\n            ans += w\n    print(ans)\n\nmain()", "def read_nums():\n    return [int(x) for x in input().split()]\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self._parents = list(range(size))\n\n        # number of elements rooted at i\n        self._sizes = [1 for _ in range(size)]\n\n    def _root(self, a):\n        while a != self._parents[a]:\n            self._parents[a] = self._parents[self._parents[a]]\n            a = self._parents[a]\n        return a\n\n    def find(self, a, b):\n        return self._root(a) == self._root(b)\n\n    def union(self, a, b):\n        a, b = self._root(a), self._root(b)\n\n        if self._sizes[a] < self._sizes[b]:\n            self._parents[a] = b\n            self._sizes[b] += self._sizes[a]\n        else:\n            self._parents[b] = a\n            self._sizes[a] += self._sizes[b]\n\n\ndef count_result(num_vertex, edges):\n    uf = UnionFind(num_vertex)\n    res = 0\n    for start, end, cost in edges:\n        if uf.find(start, end):\n            continue\n        else:\n            uf.union(start, end)\n            res += cost\n    return res\n\n\ndef main():\n    n, m = read_nums()\n    vertex_nums = read_nums()\n    edges = []\n    for i in range(m):\n        nums = read_nums()\n        nums[0] -= 1\n        nums[1] -= 1\n        edges.append(tuple(nums))\n\n    min_index = min([x for x in zip(vertex_nums, list(range(n)))], key=lambda x: x[0])[1]\n    for i in range(n):\n        if i != min_index:\n            edges.append((min_index, i, vertex_nums[min_index] + vertex_nums[i]))\n    edges = sorted(edges, key=lambda x: x[2])\n    print(count_result(n, edges))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def read_nums():\n    return [int(x) for x in input().split()]\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self._parents = list(range(size))\n\n        # number of elements rooted at i\n        self._sizes = [1 for _ in range(size)]\n\n    def _root(self, a):\n        while a != self._parents[a]:\n            self._parents[a] = self._parents[self._parents[a]]\n            a = self._parents[a]\n        return a\n\n    def find(self, a, b):\n        return self._root(a) == self._root(b)\n\n    def union(self, a, b):\n        a, b = self._root(a), self._root(b)\n\n        if self._sizes[a] < self._sizes[b]:\n            self._parents[a] = b\n            self._sizes[b] += self._sizes[a]\n        else:\n            self._parents[b] = a\n            self._sizes[a] += self._sizes[b]\n\n\ndef count_result(num_vertex, edges):\n    uf = UnionFind(num_vertex)\n    res = 0\n    for start, end, cost in edges:\n        if uf.find(start, end):\n            continue\n        else:\n            uf.union(start, end)\n            res += cost\n    return res\n\n\ndef main():\n    n, m = read_nums()\n    vertex_nums = read_nums()\n    edges = []\n    for i in range(m):\n        nums = read_nums()\n        nums[0] -= 1\n        nums[1] -= 1\n        edges.append(nums)\n\n    min_index = min([x for x in zip(vertex_nums, list(range(n)))], key=lambda x: x[0])[1]\n    for i in range(n):\n        if i != min_index:\n            edges.append((min_index, i, vertex_nums[min_index] + vertex_nums[i]))\n    edges = sorted(edges, key=lambda x: x[2])\n    print(count_result(n, edges))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nfrom io import StringIO\n\n\ndef find_set(v):\n    tmp = []\n    while v != parent[v]:\n        tmp.append(v)\n        v = parent[v]\n    for i in tmp:\n        parent[i] = v\n\n    return v\n\n\nsys.stdin = StringIO(sys.stdin.read())\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\nn, m = list(map(int, input().split(' ')))\na = list(map(int, input().split(' ')))\n\n\nedges = []\nfor _ in range(m):\n    x, y, w = list(map(int, input().split(' ')))\n    edges.append((x - 1, y - 1, w))\n\n\nmin_val = min(a)\nmin_ind = a.index(min_val)\n\nfor i in range(n):\n    edges.append((min_ind, i, min_val + a[i]))\n\n\nparent, rank = list(range(n)), [0] * n\ncost = 0\n\nfor edge in sorted(edges, key=lambda edge: edge[2]):\n    find_u, find_v = find_set(edge[0]), find_set(edge[1])\n\n    if find_u != find_v:\n        cost += edge[2]\n\n        if rank[find_u] < rank[find_v]:\n            find_v, find_u = find_u, find_v\n        elif rank[find_u] == rank[find_v]:\n            rank[find_u] += 1\n\n        parent[find_v] = find_u\n\nprint(cost)\n", "import sys\nfrom io import StringIO\n\n\ndef main():\n    def find_set(v):\n        tmp = []\n        while v != parent[v]:\n            tmp.append(v)\n            v = parent[v]\n        for i in tmp:\n            parent[i] = v\n\n        return v\n\n\n    sys.stdin = StringIO(sys.stdin.read())\n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\n    n, m = list(map(int, input().split(' ')))\n    a = list(map(int, input().split(' ')))\n\n\n    edges = []\n    for _ in range(m):\n        x, y, w = list(map(int, input().split(' ')))\n        edges.append((x - 1, y - 1, w))\n\n\n    min_val = min(a)\n    min_ind = a.index(min_val)\n\n    for i in range(n):\n        edges.append((min_ind, i, min_val + a[i]))\n\n\n    parent, rank = list(range(n)), [0] * n\n    cost = 0\n\n    for edge in sorted(edges, key=lambda edge: edge[2]):\n        find_u, find_v = find_set(edge[0]), find_set(edge[1])\n\n        if find_u != find_v:\n            cost += edge[2]\n\n            if rank[find_u] < rank[find_v]:\n                find_v, find_u = find_u, find_v\n            elif rank[find_u] == rank[find_v]:\n                rank[find_u] += 1\n\n            parent[find_v] = find_u\n\n    print(cost)\n\nmain()\n"]