["import sys\n\n\nn = int(input())\na = [int(t) for t in input().split(' ')]\nmx = [[] for _ in range(n)]\n\nlines = sys.stdin.readlines()\nfor i in range(n-1):\n    v1, v2 = (int(t) - 1 for t in lines[i].split(' '))\n    mx[v1].append(v2)\n    mx[v2].append(v1)\n\ncount = [[0, 0] for _ in range(n)]\n\ntotal = [a.count(1), a.count(2)]\nanswer = 0\n\nOBSERVE = 0\nCHECK = 1\n\nstack = [(OBSERVE, 0, -1)]\nwhile len(stack):\n    state, v, from_ = stack.pop()\n    if state == OBSERVE:\n        stack.append((CHECK, v, from_))\n        for nv in mx[v]:\n            if nv != from_:\n                stack.append((OBSERVE, nv, v))\n    else:\n        for nv in mx[v]:\n            if nv != from_:\n                if count[nv][0] == total[0] and count[nv][1] == 0 or count[nv][1] == total[1] and count[nv][0] == 0:\n                    answer += 1\n                count[v][0] += count[nv][0]\n                count[v][1] += count[nv][1]\n\n        if a[v] != 0:\n            count[v][a[v]-1] += 1\n\nprint(answer)\n", "import sys\nfrom collections import defaultdict\nn = int(input())\n#n,k = [int(__) for __ in raw_input().split()]\narr = [int(__) for __ in input().split()]\nsactive = set()\nsactive.add(0)\nnums = [0] * n\nd1 = defaultdict(set)\nd2 = defaultdict(set)\nd = defaultdict(set)\nlines = sys.stdin.readlines()\nfor i in range(n-1):\n    sactive.add(i+1)\n    s,f = [int(__) for __ in lines[i].strip().split()]\n    s -= 1\n    f -= 1\n    d[s].add(f)\n    d[f].add(s)\n    nums[f] += 1\n    nums[s] += 1\n\nleaves = set()\n\n\n\nfor i in range(n):\n    if nums[i] == 1:\n        leaves.add(i)\nwhile len(leaves):\n    x = leaves.pop()\n    if arr[x] == 0:\n        sactive.remove(x)\n        nums[x] -= 1\n        targ = d[x].pop()\n        nums[targ] -= 1\n        d[targ].remove(x)\n        if nums[targ] == 1:\n            leaves.add(targ)\n\nsactive1 = sactive.copy()\nfor targ in d:\n    d1[targ] = d[targ].copy()\nnums1 = nums[:]\nnums2 = nums[:]\n\nfor i in range(n):\n    if nums1[i] == 1:\n        leaves.add(i)\nwhile len(leaves):\n    x = leaves.pop()\n    if arr[x] != 1:\n        sactive1.remove(x)\n        nums1[x] -= 1\n        targ = d1[x].pop()\n        nums1[targ] -= 1\n        d1[targ].remove(x)\n        if nums1[targ] == 1:\n            leaves.add(targ)\n            \nsactive2 = sactive.copy()\nfor targ in d:\n    d2[targ] = d[targ].copy()\n\nfor i in range(n):\n    if nums2[i] == 1:\n        leaves.add(i)\nwhile len(leaves):\n    x = leaves.pop()\n    if arr[x] != 2:\n        sactive2.remove(x)\n        nums2[x] -= 1\n        targ = d2[x].pop()\n        nums2[targ] -= 1\n        d2[targ].remove(x)\n        if nums2[targ] == 1:\n            leaves.add(targ)\n\n           \nif len(sactive1 & sactive2) > 0:\n    print(0)\nelse:\n    print(len(sactive) - len(sactive1) - len(sactive2) + 1)\n#print(nums)\n#print('both',sactive)\n#print('1',sactive1)\n#print('2',sactive2)\n#print(d)\n", "import sys\ninput=sys.stdin.readline\nn = int(input())\na = [int(t) for t in input().split(' ')]\nmx = [[] for _ in range(n)]\nfor i in range(n-1):\n    v1, v2 = list(map(int,input().split()))\n    mx[v1-1].append(v2-1)\n    mx[v2-1].append(v1-1)\ncount = [[0, 0] for _ in range(n)]\ntotal = [a.count(1), a.count(2)]\nanswer = 0\nOBSERVE = 0\nCHECK = 1\nstack = [(OBSERVE, 0, -1)]\nwhile len(stack):\n    #print(stack,count)\n    state, vertex, parent = stack.pop()\n    if state == OBSERVE:\n        stack.append((CHECK, vertex, parent))\n        for child in mx[vertex]:\n            #print(nv,v,from_)\n            if child != parent:\n                stack.append((OBSERVE, child, vertex))\n    else:\n        for child in mx[vertex]:\n            if child != parent:\n                #print(child,parent,count)\n                if count[child][0] == total[0] and count[child][1] == 0 or count[child][1] == total[1] and count[child][0] == 0:\n                    answer += 1\n                count[vertex][0] += count[child][0]\n                count[vertex][1] += count[child][1]\n \n        if a[vertex] != 0:\n            #print(count)\n            count[vertex][a[vertex]-1] += 1\n            #print(count)\n \nprint(answer)\n", "from collections import deque\nimport sys\ninput = sys.stdin.readline\n\nclass Graph(object):\n\t\"\"\"docstring for Graph\"\"\"\n\tdef __init__(self,n,d): # Number of nodes and d is True if directed\n\t\tself.n = n\n\t\tself.graph = [[] for i in range(n)]\n\t\tself.parent = [-1 for i in range(n)]\n\t\tself.directed = d\n\t\t\n\tdef addEdge(self,x,y):\n\t\tself.graph[x].append(y)\n\t\tif not self.directed:\n\t\t\tself.graph[y].append(x)\n\n\tdef bfs(self, root): # NORMAL BFS\n\t\tself.parent = [-1 for i in range(self.n)]\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\n\tdef dfs(self, root, ans): # Iterative DFS\n\t\tstack=[root]\n\t\tvis=[0]*self.n\n\t\tstack2=[]\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tstack.append(i)\n\n\t\twhile len(stack2)!=0: # BACKTRACING. Modify the loop according to the question\n\t\t\telement = stack2.pop()\n\t\t\tm = [0,0]\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif i!=self.parent[element]:\n\t\t\t\t\tm[0] += ans[i][0]\n\t\t\t\t\tm[1] += ans[i][1]\n\t\t\tif arr[element] == 1:\n\t\t\t\tm[0] += 1\n\t\t\telif arr[element] == 2:\n\t\t\t\tm[1] += 1\n\t\t\tans[element] = m\n\t\treturn ans\n\n\tdef shortestpath(self, source, dest): # Calculate Shortest Path between two nodes\n\t\tself.bfs(source)\n\t\tpath = [dest]\n\t\twhile self.parent[path[-1]]!=-1:\n\t\t\tpath.append(parent[path[-1]])\n\t\treturn path[::-1]\n\n\tdef ifcycle(self):\n\t\tself.bfs(0)\n\t\tqueue = [0]\n\t\tvis = [0]*n\n\t\tqueue = deque(queue)\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in graph[element]:\n\t\t\t\tif vis[i]==1 and i!=parent[element]:\n\t\t\t\t\treturn True\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tvis[i] = 1\n\t\treturn False\n\n\tdef reroot(self, root, ans):\n\t\tstack = [root]\n\t\tcount = 0\n\t\tvis = [0]*self.n\n\t\twhile len(stack)!=0:\n\t\t\te = stack[-1]\n\t\t\t# print (e,ans)\n\t\t\tif vis[e]:\n\t\t\t\tstack.pop()\n\t\t\t\tif self.parent[e]!=-1:\n\t\t\t\t\tans[self.parent[e]][0] += ans[e][0]\n\t\t\t\t\tans[self.parent[e]][1] += ans[e][1]\n\t\t\t\t\tif self.parent[self.parent[e]]!=-1:\n\t\t\t\t\t\tans[self.parent[e]][0] -= ans[self.parent[self.parent[e]]][0]\n\t\t\t\t\t\tans[self.parent[e]][1] -= ans[self.parent[self.parent[e]]][1]\n\t\t\t\tcontinue\n\t\t\tvis[e]=1\n\t\t\tfor i in self.graph[e]:\n\t\t\t\tif not vis[i]:\n\t\t\t\t\tstack.append(i)\n\t\t\tif self.parent[e]==-1:\n\t\t\t\tcontinue\n\t\t\tans[self.parent[e]][0] -= ans[e][0]\n\t\t\tans[self.parent[e]][1] -= ans[e][1]\n\t\t\tif self.parent[self.parent[e]]!=-1:\n\t\t\t\tans[self.parent[e]][0] += ans[self.parent[self.parent[e]]][0]\n\t\t\t\tans[self.parent[e]][1] += ans[self.parent[self.parent[e]]][1]\n\t\t\tif 0 in ans[e] and 0 in ans[self.parent[e]]:\n\t\t\t\tcount+=1\n\t\treturn count\n\n\nn = int(input())\ng = Graph(n,False)\narr = list(map(int,input().split()))\nfor i in range(n-1):\n\tx,y = list(map(int,input().split()))\n\tg.addEdge(x-1,y-1)\nans = [[0,0] for i in range(n)]\na = g.dfs(0,ans)\nprint(g.reroot(0,a))\n\n\n"]