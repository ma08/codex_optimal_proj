["import sys\nimport copy\ninput = sys.stdin.readline\n\nn,m,k=list(map(int,input().split()))\nA=list(map(int,input().split()))\nSHOP=[list(map(int,input().split())) for i in range(m)]\n\nA=sorted(A)[:k]\nA=A[::-1]\n\nSHOP.sort(key=lambda x:x[0])\n\nfrom itertools import accumulate \n\nDP=[0]+list(accumulate(A))\nSUM=copy.deepcopy(DP)\n\nfor i in range(k+1):\n    for x,y in SHOP:\n        if x>i:\n            break\n        DP[i]=min(DP[i],DP[i-x]+SUM[i]-SUM[i-x]-SUM[i]+SUM[i-y],DP[i-1]+A[i-1])\n\nprint(DP[-1])\n        \n", "IN = input\nrint = lambda: int(IN())\nrmint = lambda: list(map(int, IN().split()))\nrlist = lambda: list(rmint())\n\nn, m, k = rmint()\na = rlist()\nt = []\nfor i in range(m):\n    x, y = rmint()\n    t.append((x, y))\nt.sort()\na.sort()\npr = [0]\nfor i in a: pr.append(pr[-1] + i)\nf = 4096 * [0]\n\n\ndef s(l, r):\n    if l > r: return 0\n    else: return pr[r + 1] - pr[l]\n\n\nans = s(0, k-1)\n\n\ndef upd(x, y):\n    nonlocal ans\n    f[x] = min(f[x], y)\n    ans = min(ans, y + s(x, k - 1))\n\n\nfor i in range(1, k + 1):\n    f[i] = f[i - 1] + a[i - 1]\n    for p in t:\n        x, y = p\n        if i - x < 0: break\n        upd(i, f[i - x] + s(i - x + y, i - 1))\n\nprint(ans)\n", "N, M, K = list(map(int, input().split()))\nA = sorted([int(a) for a in input().split()])[:K][::-1]\nB = [0]\nfor a in A:\n    B.append(B[-1]+a)\nX = [0] * (K+1)\nfor _ in range(M):\n    x, y = list(map(int, input().split()))\n    if x <= K:\n        X[x] = max(X[x], y)\n\nY = [0] * (K+1)\n\nfor i in range(1, K+1):\n    mi = 10**100\n    for j in range(1, i+1):\n        s = Y[i-j] + B[i-X[j]] - B[i-j]\n        mi = min(mi, s)\n    \n    Y[i] = mi\n\nprint(Y[K])\n", "n,m,k = list(map(int,input().split()))\nai = list(map(int,input().split()))\nar = [0] * k\nfor i in range(m):\n    x,y = list(map(int,input().split()))\n    x -= 1\n    if x < k:\n        ar[x] = max(ar[x],y)\nai.sort()\nbig = 10**9\nar2 = [big] * (k+1)\nar3 = [0] * (k+1)\nar3[0] = 0\nfor i in range(1,k+1):\n    ar3[i] = ar3[i-1] + ai[i-1]\nar2[k] = 0\nfor i in range(k,0,-1):\n    for j in range(i):\n        ar2[i-j-1] = min(ar2[i-j-1],ar2[i] + ar3[i] - ar3[i - (j + 1 - ar[j])])\nprint(ar2[0])\n", "from collections import defaultdict\nfrom heapq import heapify, heappop\nn, m, k = map(int, input().split())\nitems = list(map(int, input().split()))\nheapify(items)\nitems2 = []\nfor i in range(k):\n    items2 += [heappop(items)]\nitems = items2\noffers = defaultdict(lambda :0)\nfor i in range(m):\n    a, b = map(int, input().split())\n    if a <= k:\n        offers[a] = max(offers[a], b)\ndp = [1e20] * (k + 1)\ndp[0] = 0\nprefix = [0]\nfor i in items:\n    prefix += [prefix[-1] + i]\nfor i in range(1, k + 1):\n    for j in range(1, i + 1):\n        b = offers[j]\n        # buy j items, b free\n        dp[i] = min(dp[i], dp[i - j] + prefix[i] - prefix[i - j + b])\nprint(dp[-1])", "N, M, K = map(int, input().split())\nA = sorted([int(a) for a in input().split()])[:K][::-1]\nB = [0]\nfor a in A:\n    B.append(B[-1]+a)\nX = [0] * (K+1)\nfor _ in range(M):\n    x, y = map(int, input().split())\n    if x <= K:\n        X[x] = max(X[x], y)\nY = [0] * (K+1)\nfor i in range(1, K+1):\n    mi = 10**100\n    for j in range(1, i+1):\n        s = Y[i-j] + B[i-X[j]] - B[i-j]\n        mi = min(mi, s)\n    Y[i] = mi\nprint(Y[K])", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Codeforces Round #552 (Div. 3)\n\nProblem F. Shovels Shop\n\n:author:         Kitchen Tong\n:mail:    kctong529@gmail.com\n\nPlease feel free to contact me if you have any question\nregarding the implementation below.\n\"\"\"\n\n__version__ = '2.0'\n__date__ = '2019-04-17'\n\nimport sys\nfrom heapq import heappush, heappop\n\n\ndef buy_shovels(k, shovels, discounts):\n    if 1 not in discounts:\n        discounts[1] = 0\n    accums = [0]\n    for s in shovels:\n        accums.append(s + accums[-1])\n    for i in range(k):\n        for x, y in list(discounts.items()):\n            if i + x > k:\n                continue\n            perhaps = accums[i] + sum(shovels[i+y:i+x])\n            accums[i+x] = min(accums[i+x], perhaps)\n    return accums[-1]\n\n\ndef main(argv=None):\n    n, m, k = list(map(int, input().split()))\n    costs = list(map(int, input().split()))\n    discounts = dict()\n    for line in range(m):\n        x, y = list(map(int, input().split()))\n        if x > k:\n            # this discount is useless as we can't buy more than k\n            continue\n        if x not in discounts:\n            discounts[x] = y\n        else:\n            discounts[x] = max(discounts[x], y)\n    print(buy_shovels(k, sorted(costs)[:k], discounts))\n    return 0\n\n\ndef __starting_point():\n    STATUS = main()\n    return(STATUS)\n\n\n__starting_point()", "from collections import defaultdict\n\n\ndef buy(k, sums, offset, discounts):\n    return sums[offset + k] - sums[offset + discounts[k]]\n\n\ndef main():\n    n, m, k = list(map(int, input().split()))\n    prices = sorted(list(map(int, input().split())))[:k]\n    sums = [0] * (k + 1)\n    for i in range(1, k + 1):\n        sums[i] = sums[i - 1] + prices[i - 1]\n\n    discounts = defaultdict(int)\n    for _ in range(m):\n        x, y = tuple(map(int, input().split()))\n        discounts[x] = max(discounts[x], y)\n\n    d = [0] * (k + 1)\n\n    for i in range(1, k + 1):\n        d[i] = buy(i, sums, 0, discounts)\n\n        for j in range(1, i + 1):\n            d[i] = min(d[i], d[j] + buy(i - j, sums, j, discounts))\n\n    print(d[k])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "'''input\n9 4 8\n6 8 5 1 8 1 1 2 1\n9 2\n8 4\n5 3\n9 7\n'''\nfrom sys import stdin\nimport math\nfrom copy import deepcopy\nfrom collections import defaultdict\n\n\ndef process_offer(offers):\n\taux = []\n\tfor i in offers:\n\t\ttemp = offers[i]\n\t\ttemp.sort()\n\t\taux.append([i, temp[-1]])\n\n\taux = sorted(aux, key = lambda x: x[0])\n\treturn aux\n\n\ndef make(first, second):\n\treturn str(first) + ' ' + str(second)\n\n\ndef brute(arr, dp, offers, index, remain):\n\t#print(index, remain)\n\t# base case:\n\tif remain == 0:\n\t\treturn 0\n\n\tif make(index, remain) in dp:\n\t\treturn dp[make(index, remain)]\n\n\tmin_cost = arr[index] + brute(arr, dp, offers, index + 1, remain - 1)\n\t#print(min_cost)\n\tfor i in range(len(offers)):\n\t\tcost = 0\n\t\tif offers[i][0] <= remain:\n\t\t\tfree = offers[i][1]\n\t\t\tfor  j in range(index + free, index + offers[i][0]):\n\t\t\t\tcost += arr[j]\n\t\t\tcost += brute(arr, dp, offers, index + offers[i][0], remain - offers[i][0])\n\t\t\tmin_cost = min(min_cost, cost)\n\t\telse:\n\t\t\tbreak\n\tdp[make(index, remain)] = min_cost\n\treturn min_cost\n\n\n\n# main starts\nn, m, k = list(map(int, stdin.readline().split()))\narr = list(map(int, stdin.readline().split()))\narr.sort()\noffers = defaultdict(list)\nfor _ in range(m):\n\tx, y = list(map(int, stdin.readline().split()))\n\toffers[x].append(y)\n\noffers = process_offer(offers)\ndp = dict()\nprint(brute(arr, dp, offers, 0, k))\n#print(dp)\n\n", "n, m, k = list(map(int, input().split()))\na = list(map(int, input().split()))\na = sorted(a)\na = a[:k]\nd = [(1, 0)]\nfor i in range(m):\n    x, y = list(map(int, input().split()))\n    if x > k:\n        continue\n    d.append((x, y))\nd = sorted(d)\n\ns = [0] * (k + 1)\ns[1] = a[0]\nfor i in range(1, k + 1):\n    s[i] = s[i - 1] + a[i - 1]\nINF = float('inf')\ndp = [INF] * (k + 1)\ndp[0] = 0\nfor i in range(k + 1):\n    for j in range(len(d)):\n        x, y = d[j]\n        if i + x <= k:\n            dp[i + x] = min(dp[i + x], dp[i] + s[i + x] - s[i + y])\n        else:\n            break\n\nprint(dp[k])\n\n", "from sys import stdin\nimport math\nfrom copy import deepcopy\nfrom collections import defaultdict\ndef process_offer(offers):\n\taux = []\n\tfor i in offers:\n\t\ttemp = offers[i]\n\t\ttemp.sort()\n\t\taux.append([i, temp[-1]])\n\taux = sorted(aux, key = lambda x: x[0])\n\treturn aux\ndef make(first, second):\n\treturn str(first) + ' ' + str(second)\n\ndef brute(arr, dp, offers, index, remain):\n\t#print(index, remain)\n\t# base case:\n\tif remain == 0:\n\t\treturn 0\n\tif make(index, remain) in dp:\n\t\treturn dp[make(index, remain)]\n\tmin_cost = arr[index] + brute(arr, dp, offers, index + 1, remain - 1)\n\t#print(min_cost)\n\tfor i in range(len(offers)):\n\t\tcost = 0\n\t\tif offers[i][0] <= remain:\n\t\t\tfree = offers[i][1]\n\t\t\tfor  j in range(index + free, index + offers[i][0]):\n\t\t\t\tcost += arr[j]\n\t\t\tcost += brute(arr, dp, offers, index + offers[i][0], remain - offers[i][0])\n\t\t\tmin_cost = min(min_cost, cost)\n\t\telse:\n\t\t\tbreak\n\tdp[make(index, remain)] = min_cost\n\treturn min_cost\nn, m, k = list(map(int, stdin.readline().split()))\narr = list(map(int, stdin.readline().split()))\narr.sort()\noffers = defaultdict(list)\nfor _ in range(m):\n\tx, y = list(map(int, stdin.readline().split()))\n\toffers[x].append(y)\n\noffers = process_offer(offers)\ndp = dict()\nprint(brute(arr, dp, offers, 0, k))", "from sys import stdin, stdout\n\nn, m, k = tuple(map(lambda x: int(x), stdin.readline().split()))\na = stdin.readline().split()\nfor i in range(len(a)):\n    a[i] = int(a[i])\nprefix_sum = []\na = sorted(a, key=lambda x: x)\nfor x in a:\n    if prefix_sum:\n        prefix_sum.append(prefix_sum[-1] + x)\n    else:\n        prefix_sum.append(x)\n\noffers = {}\nfor i in range(m):\n    x, y = stdin.readline().split()\n    x = int(x)\n    y = int(y)\n    if x not in offers or y > offers[x]:\n        offers[x] = y\n\n\nanswer = []\nfor i in range(k):\n    if i == 0:\n        if 1 in offers and offers[1] > 0:\n            answer.append(0)\n        else:\n            answer.append(a[0])\n        continue\n    answer.append(400000002)\n    for j in range(i):\n        cursum = answer[j]\n        answer[i] = min(answer[i], answer[j] + prefix_sum[i] - prefix_sum[j + (offers[i - j] if (i - j) in offers else 0)])\n    answer[i] = min(answer[i], prefix_sum[i] if (i+1) not in offers else (-prefix_sum[offers[i+1]-1] + prefix_sum[i]))\n\n\nprint(answer[k-1])", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\n#sys.stdin = open(\"input.txt\", \"r\")\nMOD = 10**9+7\n\nn, m, k = map(int, input().split())\na = sorted(map(int, input().split()))\na = a[:k]\nps = [0]\nfor i in range(k):\n    ps.append(ps[-1]+a[i])\nbf = []\ntemp = [0 for i in range(k+1)]\nfor i in range(m):\n    b, f = map(int, input().split())\n    if b <= k:\n        temp[b] = max(temp[b], f)\nfor i in range(1, k+1):\n    if temp[i] != 0:\n        bf.append((i, temp[i]))\nbf = [(1, 0)] + sorted(bf, key = lambda x: (x[0]-x[1], b))\n\ndp = [[-1 for i in range(len(bf))] for i in range(k+1)]\n\nfor i in range(len(bf)): dp[0][i] = 0\nfor i in range(1, k+1): dp[i][0] = ps[i]\n\nfor i in range(1, k+1):\n    for j in range(1, len(bf)):\n        dp[i][j] = dp[i][j-1]\n        b = bf[j][0]\n        f = bf[j][1]\n        if b <= i:\n            dp[i][j] = min(dp[i][j], dp[i-b][len(bf)-1]+ps[i]-ps[i-b+f])\n\nprint(dp[k][len(bf)-1])", "# http://codeforces.com/contest/1154/problem/F\n# Explain: https://codeforces.com/blog/entry/66586?locale=en\nfrom collections import defaultdict\n\n\ndef input2int():\n    return list(map(int, input().split()))\n\n\nn, m, k = input2int()\ncost = list(input2int())\ncost = sorted(cost)[:k]\n# cost.reverse()\n# print(cost)\n\npreSum = defaultdict(int)\nfor i in range(k):\n    preSum[i] = preSum[i - 1] + cost[i]\npreSum[k] = preSum[k - 1]\n# print(preSum)\n\noffer = []\nfor i in range(m):\n    x, y = input2int()\n    if x <= k:\n        offer.append((x, y))\n\n# print(offer)\n\ndp = defaultdict(lambda: int(1e9))\ndp[0] = 0\n\nfor i in range(k + 1):\n    if i < k:\n        dp[i + 1] = min(dp[i] + cost[i], dp[i + 1])\n    for _ in offer:\n        x, y = _\n        # print(\"i: {}, x: {}, y: {}\".format(i, x, y))\n        if i + x > k:\n            continue\n        # print('sum: {}'.format(preSum[i + x] - preSum[i + y]))\n        dp[i + x] = min(dp[i + x], dp[i] + preSum[i + x - 1] - preSum[i + y - 1])\n        # print(dp)\n\n# print(dp)\nprint(dp[k])\n", "import math\nfrom collections import defaultdict\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n    n, m, k = list(map(int, input().split()))\n    a = sorted(list(map(int, input().split())))\n    pref = [0] + a.copy()\n    for i in range(1, n+1):\n        pref[i] += pref[i-1]\n\n    def getPref(start, end):\n        if start > end:\n            return 0\n        if start == 0:\n            return pref[end]\n        return pref[end] - pref[start-1]\n\n    offers = {}\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        if a not in offers:\n            offers[a] = b\n        else:\n            if b > offers[a]:\n                offers[a] = b\n\n    if 1 not in offers:\n        offers[1] = 0\n\n    dp = [math.inf] * (k+1)\n    dp[0] = 0\n    for i in range(0, k+1):\n        for j in offers:\n            if i + j <= k:\n                dp[i+j] = min(dp[i+j], dp[i] + getPref(i + offers[j]+1, i+j))\n\n    print(dp[k])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from audioop import reverse\nn, m, k = list(map(int,input().split()))\nprice = list(map(int,input().split()))\noffer = [0] * (k + 1)\nfor i in range(m):\n    x , y = list(map(int,input().split()))\n    if x <= k:\n        offer[x] = max(offer[x] , y)\nprice.sort()\nfor _ in range(n-k):\n    price.pop()\nprice.sort(reverse=True)\nprep = [0] * (k + 1)\nfor i in range(k):\n    prep[i + 1] = prep[i] + price[i] \nmin_price = [prep[k]] * (k + 1)\nmin_price[0] = 0\nfor i in range(k):\n    min_price[i + 1] = min(min_price[i + 1],min_price[i] + price[i])\n    for j in range(1 , k + 1):\n        if offer[j] == 0:\n            continue\n        if i + j > k:\n            break\n        min_price[i + j] = min(min_price[i + j] , min_price[i] + prep[i + j - offer[j]] -prep[i])\nprint(min_price[k])        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "n, m, k = (int(i) for i in input().split())\ncost = sorted([int(i) for i in input().split()])[:k] + [0]\n\ndiscount = [0] * n\nfor i in range(m):\n    a, b = (int(j) for j in input().split())\n    discount[a - 1] = max(discount[a - 1], b)\n\nS = [0] * (k + 1)\nfor i in range(k):\n    S[i] = cost[i] + S[i - 1]\n    cost[i] += cost[i - 1]    \n    for j in range(i + 1):\n        S[i] = min(S[i], S[j - 1] + cost[i] - cost[j - 1 + discount[i - j]])\nprint(S[k - 1])", "import sys\n\ndp = []\nsum = []\nINF = sys.maxsize / 2\n\ndef sum_range(a, b):\n\tif a == 0:\n\t\treturn sum[b]\n\treturn sum[b] - sum[a - 1]\n\ndef rec(pos, sale, n, k):\n\tif k == 0:\n\t\treturn 0\n\tif dp[k] != -1:\n\t\treturn dp[k]\n\t\n\tres = INF\n\tfor x in range(1, k + 1):\n\t\tif sale[x] != -1:\n\t\t\tres = min(res, rec(pos + x, sale, n, k - x) + sum_range(pos + sale[x], pos + x - 1))\n\tdp[k] = res\n\treturn res\n\ninp = [int(x) for x in sys.stdin.read().split()]\n\nn, m, k = inp[0], inp[1], inp[2]\ninp_idx = 3\n\na = []\nfor _ in range(n):\n\ta.append(inp[inp_idx])\n\tinp_idx += 1\n\nsale = [-1] * (k + 1)\nsale[1] = 0\nfor _ in range(m):\n\tx, y = inp[inp_idx], inp[inp_idx + 1]\n\tinp_idx += 2\n\tif x > k:\n\t\tcontinue\n\tsale[x] = max(sale[x], y)\n\t\na.sort()\n\nsum = [0] * n\nsum[0] = a[0]\nfor i in range(1, n):\n\tsum[i] = sum[i - 1] + a[i]\n\ndp = [-1] * (k + 1)\ncost = rec(0, sale, n, k)\nprint(cost)", "n,m,k=map(int,input().split())\narr=list(map(int,input().split()))\noffer=[list(map(int,input().split())) for _ in range(m)]\narr=sorted(arr)\narr=arr[:k]\narr=arr[::-1]\nacum=[0]\nfor i in range(k):\n    acum.append(acum[-1]+arr[i])\ndp=[acum[i] for i in range(k+1)]\nfor x,y in offer:\n    if x>k:\n        continue\n    for i in range(x,k+1):\n        dp[i]=min(dp[i],dp[i-x]+(acum[i]-acum[i-x])-(acum[i]-acum[i-y]))\n    tmp=dp[0]\n    for i in range(1,k+1):\n        tmp=min(tmp,dp[i-1])+arr[i-1]\n        dp[i]=min(dp[i],tmp)\nfor x,y in offer:\n    if x>k:\n        continue\n    for i in range(x,k+1):\n        dp[i]=min(dp[i],dp[i-x]+(acum[i]-acum[i-x])-(acum[i]-acum[i-y]))\n    tmp=dp[0]\n    for i in range(1,k+1):\n        tmp=min(tmp,dp[i-1])+arr[i-1]\n        dp[i]=min(dp[i],tmp)\nprint(dp[k])"]