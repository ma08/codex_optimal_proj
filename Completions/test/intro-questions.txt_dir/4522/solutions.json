["n, m = list(map(int, input().split()))\nmaxN = 2 * (10 ** 5) + 10\nedges = [[] for i in range(0, maxN)]\nque = [[] for _ in range(0, maxN)]\nans = [0] * m\nsz = [1 for _ in range(0, n)]\np = [i for i in range(0, n)]\ntotal_sum = 0\n\ndef get(u):\n    if p[u] == u:\n        return u\n    p[u] = get(p[u])\n    return p[u]\n\n\ndef unite(u, v):\n    u = get(u)\n    v = get(v)\n    if u == v:\n        return\n    nonlocal total_sum\n    total_sum -= (sz[u] * (sz[u] - 1)) // 2\n    total_sum -= (sz[v] * (sz[v] - 1)) // 2\n    total_sum += ((sz[u] + sz[v]) * (sz[u] + sz[v] - 1)) // 2\n    if sz[u] < sz[v]:\n        p[u] = v\n        sz[v] += sz[u]\n    else:\n        p[v] = u\n        sz[u] += sz[v]\n\n\nfor i in range(1, n):\n    u, v, w = list(map(int, input().split()))\n    u -= 1\n    v -= 1\n    edges[w].append((u, v))\nques = list(map(int, input().split()))\n\nfor i in range(0, m):\n    que[ques[i]].append(i)\nfor i in range(0, maxN):\n    for u, v in edges[i]:\n        unite(u, v)\n    for id in que[i]:\n        ans[id] = total_sum\nprint(\" \".join(str(x) for x in ans))\n\n\n\n\n\n", "from bisect import bisect\nfrom math import inf\n\n\ndef union_init(s):\n    d = [i for i in range(s)]\n    size = [1 for i in range(s)]\n    return (d, size)\n\n\ndef union_query(d, size, n):\n    if d[n] != n:\n        d[n] = union_query(d, size, d[n])\n    return d[n]\n\n\ndef union_merge(d, size, x, y):\n    xRoot = union_query(d, size, x)\n    yRoot = union_query(d, size, y)\n\n    if xRoot == yRoot:\n        return\n    if size[xRoot] < size[yRoot]:\n        xRoot, yRoot = yRoot, xRoot\n    d[yRoot] = xRoot\n    size[xRoot] = size[xRoot] + size[yRoot]\n\n\ndef sizeComponent(d, size, x):\n    root = union_query(d, size, x)\n    return size[root]\n\n\nnm = input().split()\nn = int(nm[0])\nm = int(nm[1])\n\nd, size = union_init(n)\npairs = [(0, 0)]\nedges = []\nfor _ in range(n - 1):\n    edge = input().split()\n    u = int(edge[0]) - 1\n    v = int(edge[1]) - 1\n    w = int(edge[2])\n    edges.append((w, u, v))\n\nedges.sort()\ntotalP = 0\nfor e in edges:\n    u = e[1]\n    v = e[2]\n    uSize = sizeComponent(d, size, u)\n    vSize = sizeComponent(d, size, v)\n    totalP += uSize * vSize\n    union_merge(d, size, u, v)\n    pairs.append((e[0], totalP))\n\nms = [int(mi) for mi in input().split()]\nanswer = [0] * m\nfor i, mi in enumerate(ms):\n    start = bisect(pairs, (mi, inf)) - 1\n    answer[i] = pairs[start][1]\nprint(*answer)\n", "'''input\n3 3\n1 2 1\n2 3 2\n1 3 2\n'''\nfrom sys import stdin\nfrom copy import deepcopy\nfrom collections import deque, defaultdict\n\n\ndef find_parent(n):\n\tnonlocal parent\n\tnode = n\n\twhile parent[node] != node:\n\t\tnode = parent[node]\n\tparent[n] = node\n\treturn parent[n]\n\n\ndef combination(num):\n\treturn (num * (num - 1)) // 2\n\n# main starts\nn, m = list(map(int, stdin.readline().split()))\ngraph = defaultdict(list)\nedges = []\nfor _ in range(n - 1):\n\tedges.append(list(map(int, stdin.readline().split())))\n\nqueries = list(map(int, stdin.readline().split()))\n\nedges.sort(key = lambda x:x[2], reverse = True)\nparent = dict()\ncount = dict()\nfor i in range(1, n + 1):\n\tparent[i] = i\n\tcount[i] = 1\n\nans = [0] * (200001)\nwhile len(edges) > 0:\n\tu, v, w = edges.pop()\n\n\tif u > v:\n\t\tu, v = v, u\n\n\tpv = find_parent(v)\n\tpu = find_parent(u)\n\tans[w] -= (combination(count[pu]) + combination(count[pv]))\n\tans[w] += combination(count[pu] + count[pv])\n\tcount[pu] += count[pv]\n\tcount[pv] = 0\n\tparent[pv] = parent[pu]\n\t\t\n\t# print(u, v, w)\n\t# print('parent', parent)\n\t# print('count', count)\n\t# print(ans)\n\n\nfor i in range(1, len(ans)):\n\tans[i] = ans[i - 1] + ans[i]\n# print(ans[:10])\n\nfor i in queries:\n\tprint(ans[i], end = ' ')\n\n\n\n", "import sys\ninput = sys.stdin.readline\nn,m=list(map(int,input().split()))\npar=[-1]*n\ndef c(x):\n  return x*(x-1)//2\n\ndef find(x):\n  if par[x]<0:\n    return x\n  else:\n    par[x]=find(par[x])\n    return par[x]\n\ndef unite(x,y):\n  x=find(x)\n  y=find(y)\n  if x==y:\n    return False\n  else:\n    if par[x]>par[y]:\n      x,y=y,x\n    par[x]+=par[y]\n    par[y]=x\n    return True\n\ndef same(x,y):\n  return find(x)==find(y)\n\ndef size(x):\n  return -par[find(x)]\nimport collections\nEdge=collections.defaultdict(list)\nfor _ in range(n-1):\n  u,v,w=list(map(int,input().split()))\n  Edge[w].append((u,v))\nQ=[int(i) for i in input().split()]\nq=max(Q)\nAns=[0]*(q+1)\nans=0\nfor i in range(1,q+1):\n  for u,v in Edge[i]:\n    if same(u-1,v-1):\n      continue\n    else:\n      uu,vv=size(u-1),size(v-1)\n      unite(u-1,v-1)\n      uv=size(u-1)\n      ans+=c(uv)-c(uu)-c(vv)\n  Ans[i]=ans\nAns2=[]\nfor q in Q:\n  Ans2.append(Ans[q])\nprint(*Ans2)\n\n", "import sys\ninput = sys.stdin.readline\nn,m=list(map(int,input().split()))\npar=[-1]*n\ndef c(x):\n  return x*(x-1)//2\n\ndef find(x):\n  if par[x]<0:\n    return x\n  else:\n    par[x]=find(par[x])\n    return par[x]\n\ndef unite(x,y):\n  x=find(x)\n  y=find(y)\n  if x==y:\n    return False\n  else:\n    if par[x]>par[y]:\n      x,y=y,x\n    par[x]+=par[y]\n    par[y]=x\n    return True\n\ndef same(x,y):\n  return find(x)==find(y)\n\ndef size(x):\n  return -par[find(x)]\nimport collections\nEdge=collections.defaultdict(list)\nfor _ in range(n-1):\n  u,v,w=list(map(int,input().split()))\n  Edge[w].append((u,v))\nQ=[int(i) for i in input().split()]\nq=max(Q)\nAns=[0]*(q+1)\nans=0\nfor i in range(1,q+1):\n  for u,v in Edge[i]:\n    if same(u-1,v-1):\n      continue\n    else:\n      uu,vv=size(u-1),size(v-1)\n      unite(u-1,v-1)\n      uv=size(u-1)\n      ans+=c(uv)-c(uu)-c(vv)\n  Ans[i]=ans\nAns2=[]\nfor q in Q:\n  Ans2.append(Ans[q])\nprint(*Ans2)\n\n", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nimport sys\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nfrom collections import deque\nimport math\nimport copy\n\n#T = int(input())\n#N = int(input())\n#s1 = input()\n#s2 = input()\nN,E = [int(x) for x in stdin.readline().split()]\n#arr = [int(x) for x in stdin.readline().split()]\n\ns = 0\nsize = [1]*N\n\nf = [x for x in range(N)]\n\ndef getf(v):\n    stack = []\n    while f[v] != v:\n       stack.append(v)\n       v = f[v]\n    for idx in stack:\n        f[idx] = v\n    return v\n\ndef merge(f, v, u):\n    nonlocal s\n    t1 = getf(v)\n    t2 = getf(u)\n    if t1 != t2:\n        A = size[t1]\n        B = size[t2]\n        s -= A*(A-1)//2\n        s -= B*(B-1)//2\n        size[t1] = size[t1] + size[t2]\n        C = size[t1]\n        s += C*(C-1)//2\n        f[t2] = t1\n\n\nw_edge = {}\nfor i in range(N-1):\n    u,v,w = [int(x) for x in stdin.readline().split()]\n    if u>v:\n        u,v = v,u\n\n    if w not in w_edge:\n        w_edge[w] = []\n\n    w_edge[w].append((u,v))\n\nq = [0]*200000\nfor i in range(200000):\n    if i+1 in w_edge:\n        for e in w_edge[i+1]:\n            u,v = e\n            merge(f,u-1,v-1)\n        q[i] = s\n    else:\n        if i!=0:\n            q[i] = q[i-1]\n        else:\n            q[i] = 0\n\narr = [int(x) for x in stdin.readline().split()]\nans = [0]*E\nfor i in range(E):\n    ans[i] = q[arr[i]-1]\n\nprint(*ans)\n", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**6)\n\nreadline = sys.stdin.readline\nN, M = map(int, readline().split())\nE = []\nfor i in range(N-1):\n    u, v, w = map(int, readline().split())\n    E.append((w, u-1, v-1))\nE.sort()\nQ = set()\nMP = defaultdict(list)\nfor i, q in enumerate(map(int, readline().split())):\n    MP[q].append(i)\n    Q.add(q)\nQ = list(Q)\nQ.sort()\n\ndef root(x):\n    if x == p[x]:\n        return x\n    y = x\n    while y != p[y]:\n        y = p[y]\n    while x != y:\n        p[x], x = y, p[x]\n    return y\n*p, = range(N)\nsz = [1]*N\nc = 0\ndef unite(x, y):\n    nonlocal c\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    c += sz[px] * sz[py]\n    if sz[px] < sz[py]:\n        p[py] = px\n        sz[px] += sz[py]\n    else:\n        p[px] = py\n        sz[py] += sz[px]\n    return 1\n\nk = 0\nans = [N*(N-1)//2]*M\nL = len(Q)\nfor w, u, v in E:\n    while k < L and Q[k] < w:\n        e = Q[k]\n        for i in MP[e]:\n            ans[i] = c\n        k += 1\n    unite(u, v)\nsys.stdout.write(\" \".join(map(str, ans)))\nsys.stdout.write(\"\\n\")", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**6)\n\nreadline = sys.stdin.readline\nN, M = map(int, readline().split())\nE = []\nfor i in range(N-1):\n    u, v, w = map(int, readline().split())\n    E.append((w, u-1, v-1))\nE.sort()\nQ = set()\nMP = defaultdict(list)\nfor i, q in enumerate(map(int, readline().split())):\n    MP[q].append(i)\n    Q.add(q)\nQ = list(Q)\nQ.sort()\n\ndef fact(N):\n    return N*fact(N-1) % 100 if N > 1 else 1\nfact(2000)\n\ndef root(x):\n    if x == p[x]:\n        return x\n    y = x\n    while y != p[y]:\n        y = p[y]\n    while x != y:\n        p[x], x = y, p[x]\n    return y\n*p, = range(N)\nsz = [1]*N\nc = 0\ndef unite(x, y):\n    nonlocal c\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    c += sz[px] * sz[py]\n    if sz[px] < sz[py]:\n        p[py] = px\n        sz[px] += sz[py]\n    else:\n        p[px] = py\n        sz[py] += sz[px]\n    return 1\n\nk = 0\nans = [N*(N-1)//2]*M\nL = len(Q)\nfor w, u, v in E:\n    while k < L and Q[k] < w:\n        e = Q[k]\n        for i in MP[e]:\n            ans[i] = c\n        k += 1\n    unite(u, v)\nsys.stdout.write(\" \".join(map(str, ans)))\nsys.stdout.write(\"\\n\")", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**6)\n\nreadline = sys.stdin.readline\nN, M = map(int, readline().split())\nE = []\nfor i in range(N-1):\n    u, v, w = map(int, readline().split())\n    E.append((w, u-1, v-1))\nE.sort()\nQ = set()\nMP = defaultdict(list)\nfor i, q in enumerate(map(int, readline().split())):\n    MP[q].append(i)\n    Q.add(q)\nQ = list(Q)\nQ.sort()\n\ndef fact(N):\n    return N*fact(N-1) % 100 if N > 1 else 1\nfact(2100)\n\ndef root(x):\n    if x == p[x]:\n        return x\n    y = x\n    while y != p[y]:\n        y = p[y]\n    while x != y:\n        p[x], x = y, p[x]\n    return y\n*p, = range(N)\nsz = [1]*N\nc = 0\ndef unite(x, y):\n    nonlocal c\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    c += sz[px] * sz[py]\n    if sz[px] < sz[py]:\n        p[py] = px\n        sz[px] += sz[py]\n    else:\n        p[px] = py\n        sz[py] += sz[px]\n    return 1\n\nk = 0\nans = [N*(N-1)//2]*M\nL = len(Q)\nfor w, u, v in E:\n    while k < L and Q[k] < w:\n        e = Q[k]\n        for i in MP[e]:\n            ans[i] = c\n        k += 1\n    unite(u, v)\nsys.stdout.write(\" \".join(map(str, ans)))\nsys.stdout.write(\"\\n\")", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**6)\n\nreadline = sys.stdin.readline\nN, M = map(int, readline().split())\nE = []\nfor i in range(N-1):\n    u, v, w = map(int, readline().split())\n    E.append((w, u-1, v-1))\nE.sort()\nQ = set()\nMP = defaultdict(list)\nfor i, q in enumerate(map(int, readline().split())):\n    MP[q].append(i)\n    Q.add(q)\nQ = list(Q)\nQ.sort()\n\ndef fact(N):\n    return N*fact(N-1) % 100 if N > 1 else 1\nfact(2500)\n\ndef root(x):\n    if x == p[x]:\n        return x\n    y = x\n    while y != p[y]:\n        y = p[y]\n    while x != y:\n        p[x], x = y, p[x]\n    return y\n*p, = range(N)\nsz = [1]*N\nc = 0\ndef unite(x, y):\n    nonlocal c\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    c += sz[px] * sz[py]\n    if sz[px] < sz[py]:\n        p[py] = px\n        sz[px] += sz[py]\n    else:\n        p[px] = py\n        sz[py] += sz[px]\n    return 1\n\nk = 0\nans = [N*(N-1)//2]*M\nL = len(Q)\nfor w, u, v in E:\n    while k < L and Q[k] < w:\n        e = Q[k]\n        for i in MP[e]:\n            ans[i] = c\n        k += 1\n    unite(u, v)\nsys.stdout.write(\" \".join(map(str, ans)))\nsys.stdout.write(\"\\n\")", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**6)\n\nreadline = sys.stdin.readline\nN, M = map(int, readline().split())\nE = []\nfor i in range(N-1):\n    u, v, w = map(int, readline().split())\n    E.append((w, u-1, v-1))\nE.sort()\nQ = set()\nMP = defaultdict(list)\nfor i, q in enumerate(map(int, readline().split())):\n    MP[q].append(i)\n    Q.add(q)\nQ = list(Q)\nQ.sort()\n\ndef fact(N):\n    return N*fact(N-1) % 100 if N > 1 else 1\nfact(2800)\n\ndef root(x):\n    if x == p[x]:\n        return x\n    y = x\n    while y != p[y]:\n        y = p[y]\n    while x != y:\n        p[x], x = y, p[x]\n    return y\n*p, = range(N)\nsz = [1]*N\nc = 0\ndef unite(x, y):\n    nonlocal c\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    c += sz[px] * sz[py]\n    if sz[px] < sz[py]:\n        p[py] = px\n        sz[px] += sz[py]\n    else:\n        p[px] = py\n        sz[py] += sz[px]\n    return 1\n\nk = 0\nans = [N*(N-1)//2]*M\nL = len(Q)\nfor w, u, v in E:\n    while k < L and Q[k] < w:\n        e = Q[k]\n        for i in MP[e]:\n            ans[i] = c\n        k += 1\n    unite(u, v)\nsys.stdout.write(\" \".join(map(str, ans)))\nsys.stdout.write(\"\\n\")", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**6)\n\nreadline = sys.stdin.readline\nN, M = map(int, readline().split())\nE = []\nfor i in range(N-1):\n    u, v, w = map(int, readline().split())\n    E.append((w, u-1, v-1))\nE.sort()\nQ = set()\nMP = defaultdict(list)\nfor i, q in enumerate(map(int, readline().split())):\n    MP[q].append(i)\n    Q.add(q)\nQ = list(Q)\nQ.sort()\n\ndef fact(N):\n    return N*fact(N-1) % 100 if N > 1 else 1\nfact(2900)\n\ndef root(x):\n    if x == p[x]:\n        return x\n    y = x\n    while y != p[y]:\n        y = p[y]\n    while x != y:\n        p[x], x = y, p[x]\n    return y\n*p, = range(N)\nsz = [1]*N\nc = 0\ndef unite(x, y):\n    nonlocal c\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    c += sz[px] * sz[py]\n    if sz[px] < sz[py]:\n        p[py] = px\n        sz[px] += sz[py]\n    else:\n        p[px] = py\n        sz[py] += sz[px]\n    return 1\n\nk = 0\nans = [N*(N-1)//2]*M\nL = len(Q)\nfor w, u, v in E:\n    while k < L and Q[k] < w:\n        e = Q[k]\n        for i in MP[e]:\n            ans[i] = c\n        k += 1\n    unite(u, v)\nsys.stdout.write(\" \".join(map(str, ans)))\nsys.stdout.write(\"\\n\")", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**6)\n\nreadline = sys.stdin.readline\nN, M = list(map(int, readline().split()))\nE = []\nfor i in range(N-1):\n    u, v, w = list(map(int, readline().split()))\n    E.append((w, u-1, v-1))\nE.sort()\nQ = set()\nMP = defaultdict(list)\nfor i, q in enumerate(map(int, readline().split())):\n    MP[q].append(i)\n    Q.add(q)\nQ = list(Q)\nQ.sort()\n\ndef fact(N):\n    return N*fact(N-1) % 100 if N > 1 else 1\nfact(3000)\n\ndef root(x):\n    if x == p[x]:\n        return x\n    y = x\n    while y != p[y]:\n        y = p[y]\n    while x != y:\n        p[x], x = y, p[x]\n    return y\n*p, = list(range(N))\nsz = [1]*N\nc = 0\ndef unite(x, y):\n    nonlocal c\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    c += sz[px] * sz[py]\n    if sz[px] < sz[py]:\n        p[py] = px\n        sz[px] += sz[py]\n    else:\n        p[px] = py\n        sz[py] += sz[px]\n    return 1\n\nk = 0\nans = [N*(N-1)//2]*M\nL = len(Q)\nfor w, u, v in E:\n    while k < L and Q[k] < w:\n        e = Q[k]\n        for i in MP[e]:\n            ans[i] = c\n        k += 1\n    unite(u, v)\nsys.stdout.write(\" \".join(map(str, ans)))\nsys.stdout.write(\"\\n\")\n", "n,m=[int(x) for x in input().split()]\nlink=[0]*(n+1)\nsize=[0]*(n+1)\narr=[0]*m\nres=0\nfor i in range(1,n+1):\n    link[i]=i\n    size[i]=1\ndef find(x):\n    while x!=link[x]:\n        x=link[x]\n    return x\ndef comb(n):\n    return n*(n-1)//2\ndef unite(a,b,res):\n    a=find(a)\n    b=find(b)\n    if size[a]<size[b]:\n        a,b=b,a\n    res=res-comb(size[a])-comb(size[b])+comb(size[a]+size[b])\n    size[a]+=size[b]\n    link[b]=a\n    return res\nedges=[]\nask=[]\nfor i in range(n-1):\n    x,y,z=[int(x) for x in input().split()]\n    edges.append((z,x,y))\nedges.sort()\nx=0\nedges.append((10**100,1,1))\nask=sorted(zip([int(x) for x in input().split()],list(range(m))))\nfor i in range(m):\n    while edges[x][0]<=ask[i][0]:\n        res=unite(edges[x][1],edges[x][2],res)\n        x+=1\n    arr[ask[i][1]]=res\nprint(*arr)\n    \n", "from sys import setrecursionlimit as SRL, stdin\n\nSRL(10 ** 7)\nrd = stdin.readline\nrrd = lambda: map(int, rd().strip().split())\n\nfa = [i for i in range(200005)]\ns = [1] * 200005\n\n\ndef find(x):\n    t = []\n    while fa[x] != x:\n        t.append(x)\n        x = fa[x]\n    for i in t:\n        fa[i] = x\n    return fa[x]\n\n\nans = [0] * 200005\nn, q = rrd()\n\nw = []\nfor i in range(n - 1):\n    x, y, z = rrd()\n    w.append([z, x, y])\n\nw.sort(key=lambda x: x[0])\nfor x in w:\n    u = find(x[1])\n    v = find(x[2])\n\n    ans[x[0]] += s[u] * s[v]\n    fa[u] = v\n    s[v] += s[u]\n\nfor i in range(1, 200001):\n    ans[i] += ans[i - 1]\n\nq = list(rrd())\n\nfor x in q:\n    print(ans[x], end=' ')\n", "import sys\nsys.setrecursionlimit(10**9)\ndef find(a):\n    if par[a]==a:\n        return a\n    par[a]=find(par[a])\n    return par[a]\nn,m=list(map(int,input().split()))\ned=[]\npar=[i for i in range(n)]\nsize=[1 for i in range(n)]\nfor _ in range(n-1):\n    a,b,c=list(map(int,input().split()))\n    ed.append([a-1,b-1,c])\ned.sort(key=lambda x:x[2])\nit=list(map(int,input().split()))\nit=[[i,j,0] for j,i in enumerate(it)]\nit.sort()\nind=0\ntot=0\nj=0\n#print(it)\nss={}\nfor i in it[:]:\n    while ind<n-1:\n        if ed[ind][2]<=i[0]:\n            a=find(ed[ind][0])\n            b=find(ed[ind][1])\n            if a!=b:\n                tot+=size[a]*size[b]\n              #  print(a,b,j,tot)\n                if size[a]>=size[b]:\n\n                    par[b]=a\n                    size[a]+=size[b]\n                    size[b]=0\n                else:\n                    par[a]=b\n                    size[b]+=size[a]\n                    size[a]=0\n            ind+=1\n            \n        else:\n            break\n    it[j][2]=tot\n    #ss[it[j][1]]=tot\n    j+=1\n\nit.sort(key=lambda x:x[1])\naa=[i[2] for i in it]\n\n#for i in range(len(it)):\n #   print(ss[i],end=\" \")\nprint(*aa)\n        \n    \n    \n        \n    \n", "from operator import itemgetter\nimport sys\ninput = sys.stdin.readline\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = [-1] * n\n        self.cnt = n\n\n    def root(self, x):\n        if self.parent[x] < 0:\n            return x\n        else:\n            self.parent[x] = self.root(self.parent[x])\n            return self.parent[x]\n\n    def merge(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n        if x != y:\n            if self.parent[x] > self.parent[y]:\n                x, y = y, x\n            self.parent[x] += self.parent[y]\n            self.parent[y] = x\n            self.cnt -= 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def get_size(self, x):\n        return -self.parent[self.root(x)]\n\n    def get_cnt(self):\n        return self.cnt\n\n\nn, m = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n - 1)]\nq = list(map(int, input().split()))\ninfo = sorted(info, key = itemgetter(2))\nans = [0] * (2*10**5)\nuf = UnionFind(2*10**5)\ninfo_i = 0\nfor i in range(2*10**5):\n    if i-1 >= 0:\n        ans[i] = ans[i-1]\n    while True:\n        if info_i >= n - 1:\n           break\n        if info[info_i][2] == i + 1:\n            a, b, _ = info[info_i]\n            a -= 1\n            b -= 1\n            num_a = uf.get_size(a)\n            num_b = uf.get_size(b)\n            num_ab = num_a + num_b\n            comb_num_a = (num_a*(num_a-1)) // 2\n            comb_num_b = (num_b*(num_b-1)) // 2\n            comb_num_ab = (num_ab*(num_ab-1)) // 2\n            ans[i] += comb_num_ab - (comb_num_a + comb_num_b)\n            uf.merge(a, b)\n            info_i += 1\n        else:\n            break\n\nres = [0] * len(q)\nfor i, j in enumerate(q):\n    res[i] = ans[j - 1]\nprint(*res)", "def find_ancestor(i, father):\n    if father[i] == i:\n        return i\n    father[i] = find_ancestor(father[i], father)\n    return father[i]\n\ndef connect(i, j, father, n_child):\n    i_anc = find_ancestor(i, father)\n    j_anc = find_ancestor(j, father)\n    if n_child[i_anc] > n_child[j_anc]:\n        n_child[i_anc] += n_child[j_anc]\n        father[j_anc] = i_anc\n    else:\n        n_child[j_anc] += n_child[i_anc]\n        father[i_anc] = j_anc\n\nn, m = list(map(int, input().split()))\nedges = []\nfather = [i for i in range(n)]\nn_child = [1]*n\n\nfor i in range(n-1):\n    i, j, w = list(map(int, input().split()))\n    edges.append((i-1, j-1, w))\n\nedges.sort(key=lambda x: -x[2])\nqueries = list(map(int, input().split()))\n\ns_queries = sorted(queries)\n\n# final map the index to the query\nans = {}\n\nw_limit = []\nans_cum = 0\nfor query in s_queries:\n    while len(edges) and edges[-1][2] <= query:\n        i, j, w = edges[-1]\n        edges.pop()\n        i_anc = find_ancestor(i, father)\n        j_anc = find_ancestor(j, father)\n        # it's tree father may not be same\n        ans_cum += n_child[i_anc] * n_child[j_anc]\n        connect(i, j, father, n_child)\n    ans[query] = ans_cum\n\nprint(\" \".join(list(map(str, [ans[query] for query in queries]))))\n", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom itertools import accumulate\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.size = [1] * (n+1)\n        self.tree = [True] * (n+1)\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            self.tree[x] = False\n            return\n        if not self.tree[x] or not self.tree[y]:\n            self.tree[x] = self.tree[y] = False\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x=None):\n        if x is not None:\n            return self.size[self.find(x)]\n        else:\n            res = set()\n            for i in range(self.n+1):\n                res.add(self.find(i))\n            return len(res) - 1\n    \n    def is_tree(self, x):\n        return self.tree[self.find(x)]\n\nN, M = MAP()\nedges = []\nfor i in range(N-1):\n    a, b, c = MAP()\n    a -= 1; b -= 1\n    edges.append((c, a, b))\n\nif N == 1:\n    LIST()\n    ans = [0] * M\n    print(*ans)\n    return\n\nedges.sort()\nA = [0] * (2*10**5+7)\nuf = UnionFind(N)\nprevc = edges[0][0]\nfor c, a, b in edges:\n    if prevc != c:\n        A[c] = A[prevc]\n    sz1 = uf.get_size(a)\n    A[c] -= sz1 * (sz1-1) // 2\n    sz2 = uf.get_size(b)\n    A[c] -= sz2 * (sz2-1) // 2\n    uf.union(a, b)\n    sz = sz1 + sz2\n    A[c] += sz * (sz-1) // 2\n    prevc = c\n\nA = list(accumulate(A, max))\nQ = LIST()\nans = [0] * M\nfor i, q in enumerate(Q):\n    ans[i] = A[q]\nprint(*ans)\n", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom itertools import accumulate\nfrom operator import itemgetter\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.size = [1] * (n+1)\n        self.tree = [True] * (n+1)\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            self.tree[x] = False\n            return\n        if not self.tree[x] or not self.tree[y]:\n            self.tree[x] = self.tree[y] = False\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x=None):\n        if x is not None:\n            return self.size[self.find(x)]\n        else:\n            res = set()\n            for i in range(self.n+1):\n                res.add(self.find(i))\n            return len(res) - 1\n    \n    def is_tree(self, x):\n        return self.tree[self.find(x)]\n\nN, M = MAP()\nedges = []\nfor i in range(N-1):\n    a, b, c = MAP()\n    a -= 1; b -= 1\n    edges.append((c, a, b))\n\nif N == 1:\n    LIST()\n    ans = [0] * M\n    print(*ans)\n    return\n\nMAX = 2 * 10**5 + 7\nedges.sort(key=itemgetter(0))\nC = [0] * MAX\nuf = UnionFind(N)\nprevc = edges[0][0]\nfor c, a, b in edges:\n    if prevc != c:\n        C[c] = C[prevc]\n    sz1 = uf.get_size(a)\n    C[c] -= sz1 * (sz1-1) // 2\n    sz2 = uf.get_size(b)\n    C[c] -= sz2 * (sz2-1) // 2\n    uf.union(a, b)\n    sz = sz1 + sz2\n    C[c] += sz * (sz-1) // 2\n    prevc = c\n\nC = list(accumulate(C, max))\nQ = LIST()\nans = [0] * M\nfor i, q in enumerate(Q):\n    ans[i] = C[q]\nprint(*ans)\n", "# -*- coding: utf-8 -*-\n\nimport sys\nfrom itertools import accumulate\nfrom operator import itemgetter\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass UnionFind:\n    def __init__(self, n):\n        self.n = n\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.size = [1] * (n+1)\n        self.tree = [True] * (n+1)\n\n    def find(self, x):\n        t = []\n        while self.par[x] != x:\n            t.append(x)\n            x = self.par[x]\n        for i in t:\n            self.par[i] = x\n        return self.par[x]\n        # if self.par[x] == x:\n        #     return x\n        # else:\n        #     self.par[x] = self.find(self.par[x])\n        #     return self.par[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            self.tree[x] = False\n            return\n        if not self.tree[x] or not self.tree[y]:\n            self.tree[x] = self.tree[y] = False\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def is_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x=None):\n        if x is not None:\n            return self.size[self.find(x)]\n        else:\n            res = set()\n            for i in range(self.n+1):\n                res.add(self.find(i))\n            return len(res) - 1\n    \n    def is_tree(self, x):\n        return self.tree[self.find(x)]\n\nN, M = MAP()\nedges = []\nfor i in range(N-1):\n    a, b, c = MAP()\n    a -= 1; b -= 1\n    edges.append((c, a, b))\n\nif N == 1:\n    LIST()\n    ans = [0] * M\n    print(*ans)\n    return\n\nMAX = 2 * 10**5 + 7\nedges.sort(key=itemgetter(0))\nC = [0] * MAX\nuf = UnionFind(N)\nprevc = edges[0][0]\nfor c, a, b in edges:\n    if prevc != c:\n        C[c] = C[prevc]\n    sz1 = uf.get_size(a)\n    C[c] -= sz1 * (sz1-1) // 2\n    sz2 = uf.get_size(b)\n    C[c] -= sz2 * (sz2-1) // 2\n    uf.union(a, b)\n    sz = sz1 + sz2\n    C[c] += sz * (sz-1) // 2\n    prevc = c\n\nC = list(accumulate(C, max))\nQ = LIST()\nans = [0] * M\nfor i, q in enumerate(Q):\n    ans[i] = C[q]\nprint(*ans)\n", "class UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.root = [-1]*(n+1)\n        self.rnk = [0]*(n+1)\n\n    def Find_Root(self, x):\n        if(self.root[x] < 0):\n            return x\n        else:\n            self.root[x] = self.Find_Root(self.root[x])\n            return self.root[x]\n    \n    def Unite(self, x, y):\n        x = self.Find_Root(x)\n        y = self.Find_Root(y)\n        if(x == y):\n            return \n        elif(self.rnk[x] > self.rnk[y]):\n            self.root[x] += self.root[y]\n            self.root[y] = x\n\n        else:\n            self.root[y] += self.root[x]\n            self.root[x] = y\n            if(self.rnk[x] == self.rnk[y]):\n                self.rnk[y] += 1\n    \n    def isSameGroup(self, x, y):\n        return self.Find_Root(x) == self.Find_Root(y)\n\n    def Count(self, x):\n        return -self.root[self.Find_Root(x)]\n\n\nimport sys\ninput = sys.stdin.readline\nfrom bisect import bisect_right\n\nN, M = map(int, input().split())\nuni = UnionFind(N+1)\nEdges = {}\nfor _ in range(N-1):\n    a, b, w = map(int, input().split())\n    if not w in Edges:\n        Edges[w] = [(a, b)]\n    else:\n        Edges[w].append((a, b))\n\nQuery = list(map(int, input().split()))\n\nWeights = sorted(list(Edges.keys()))\n\nScore = [0]\nscore = 0\nfor w in Weights:\n    for a, b in Edges[w]:\n        c1 = uni.Count(a)\n        c2 = uni.Count(b)\n        c = c1 + c2\n        score += c*(c-1)//2 - c1*(c1-1)//2 - c2*(c2-1)//2\n        uni.Unite(a, b)\n    Score.append(score)\n\nans = []\nfor q in Query:\n    ind = bisect_right(Weights, q)\n    ans.append(Score[ind])\n\nprint(*ans)"]