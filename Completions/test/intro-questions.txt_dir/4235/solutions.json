["n, m = map(int, input().split())\nclr = [-1 for i in range(0, n)]\neds = []\n\n\ndef dfs():\n    cur = 0\n    st = [-1 for i in range(0, n + 1)]\n    st[cur] = 0\n    cur += 1\n    while cur > 0:\n        v = st[cur - 1]\n        cur -= 1\n        for x in g[v]:\n            if clr[x] != -1:\n                if clr[x] == clr[v]:\n                    return False\n                continue\n            clr[x] = clr[v] ^ 1\n            st[cur] = x\n            cur += 1\n    return True\n\n\ng = [[] for i in range(0, n)]\nfor i in range(0, m):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    g[u].append(v)\n    g[v].append(u)\n    eds.append((u, v))\nclr[0] = 0\nif dfs():\n    print(\"YES\")\n    print(\"\".join(\"1\" if clr[u] < clr[v] else \"0\" for (u, v) in eds))\nelse:\n    print(\"NO\")", "import sys\nfrom collections import deque\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGELIST=[[] for i in range(n+1)]\n\nfor x,y in EDGE:\n    EDGELIST[x].append(y)\n    EDGELIST[y].append(x)\n\nQUE=deque([[1,1]])\nANS=[-1]*(n+1)\nANS[1]=1\n\n\nwhile QUE:\n    x,color=QUE.pop()\n    ANS[x]=color\n\n    for to in EDGELIST[x]:\n        if ANS[to]==color:\n            print(\"NO\")\n            return\n\n        if ANS[to]==-1:\n            QUE.appendleft([to,abs(color-1)])\n\n    \nprint(\"YES\")\nfor x,y in EDGE:\n    if ANS[x]==1:\n        print(\"1\",end=\"\")\n    else:\n        print(\"0\",end=\"\")\n        \n", "import sys\n\n\ndef input():\n    return sys.stdin.readline()\n\n\nn, m = map(int, input().split())\ngive = [False] * (n + 1)\ntake = [False] * (n + 1)\nedge = dict()\ninputs = []\nfor i in range(n):\n    edge[i+1] = []\nfor i in range(m):\n    u, v = map(int, input().split())\n    inputs.append((u, v))\n    edge[u].append(v)\n    edge[v].append(u)\ncheck = [False] * (n + 1)\nqueue = [1]\nfront = 0\nwhile front < len(queue):\n    u = queue[front]\n    check[u] = True\n    for v in edge[u]:\n        if check[v]:\n            continue\n        queue.append(v)\n        if (give[u] and give[v]) or (take[u] and take[v]):\n            print('NO')\n            return\n        if (give[u] and take[v]) or (take[u] and give[v]):\n            continue\n        if give[u]:\n            take[v] = True\n            continue\n        if take[u]:\n            give[v] = True\n            continue\n        if give[v]:\n            take[u] = True\n            continue\n        if take[v]:\n            give[u] = True\n            continue\n        give[u] = True\n        take[v] = True\n    front += 1\nprint('YES')\nfor u, v in inputs:\n    if give[u] and take[v]:\n        print(1, end=\"\")\n    else:\n        print(0, end=\"\")\nprint()\n", "#5671891\nfrom collections import defaultdict as DD\nfrom bisect import bisect_left as BL\nfrom bisect import bisect_right as BR\nfrom itertools import combinations as IC\nfrom itertools import permutations as IP\nfrom random import randint as RI\nimport sys\nMOD=pow(10,9)+7\n\ndef IN(f=0):\n    if f==0:\n        return ( [int(i) for i in sys.stdin.readline().split()] )\n    else:\n        return ( int(sys.stdin.readline()) )\n\n    \ndef bfs(s):\n    i=1\n    parent[s]=-1\n    vis[s]=1\n    frontier=[s]\n    while frontier:\n        nex=[]\n        for u in frontier:\n            for v in d[u]:\n                if vis[v]==0:\n                    vis[v]=1\n                    color[v]=color[u]^1\n                    parent[v]=u\n                    nex.append(v)\n        frontier=nex\n        i+=1\n    return(parent)\n\nn,m=IN()\nd=DD(list)\nd1=[]\nfor i in range(m):\n    u,v=IN()\n    d[u].append(v)\n    d[v].append(u)\n    d1.append([u,v])\n\nvis=[0 for i in range(n+1)]\n\ncolor=[0 for i in range(n+1)]\n\nparent=dict()\nfor i in range(1,n+1):\n    if vis[i]==0:\n        bfs(i)\n#print(color)\n\nflag=0\nfor i in d:\n    for j in d[i]:\n        if color[j]!=color[i]^1:\n            flag=1\n            break\n    if flag==1:\n        break\n\n\n#print(\"fjfj\")\nif flag==1:\n    print(\"NO\")\nelse:\n    ans=\"\"\n    for i,j in d1:\n        if color[i]==0 and color[j]==1:\n            ans+=str(1)\n        else:\n            ans+=str(0)\n        \n    print(\"YES\")\n    print(ans)\n    \n", "#5671891\nfrom collections import defaultdict as DD\nfrom bisect import bisect_left as BL\nfrom bisect import bisect_right as BR\nfrom itertools import combinations as IC\nfrom itertools import permutations as IP\nfrom random import randint as RI\nimport sys\nMOD=pow(10,9)+7\n\ndef IN(f=0):\n    if f==0:\n        return ( [int(i) for i in sys.stdin.readline().split()] )\n    else:\n        return ( int(sys.stdin.readline()) )\n\n    \ndef bfs(s):\n    i=1\n    parent[s]=-1\n    vis[s]=1\n    frontier=[s]\n    while frontier:\n        nex=[]\n        for u in frontier:\n            for v in d[u]:\n                if vis[v]==0:\n                    vis[v]=1\n                    color[v]=color[u]^1\n                    parent[v]=u\n                    nex.append(v)\n        frontier=nex\n        i+=1\n    return(parent)\n\nn,m=IN()\nd=DD(list)\nd1=[]\nfor i in range(m):\n    u,v=IN()\n    d[u].append(v)\n    d[v].append(u)\n    d1.append([u,v])\n\nvis=[0 for i in range(n+1)]\n\ncolor=[0 for i in range(n+1)]\n\nparent=dict()\nbfs(1)\n#print(color)\n\nflag=0\nfor i in d:\n    for j in d[i]:\n        if color[j]!=color[i]^1:\n            flag=1\n            break\n    if flag==1:\n        break\n\n\n#print(\"fjfj\")\nif flag==1:\n    print(\"NO\")\nelse:\n    ans=\"\"\n    for i,j in d1:\n        if color[i]==0 and color[j]==1:\n            ans+=str(1)\n        else:\n            ans+=str(0)\n        \n    print(\"YES\")\n    print(ans)\n    \n", "graph = [[] for _ in range(200000)]\ncolors = [0] * 200000\nvis = [0] * 200000\n\ndef main():\n    n, m = map(int, input().split())\n    edges = []\n    for i in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n        edges.append((u, v))\n    \n    colors[0] = 1\n    queue = [(0, 1)]\n    i = 0\n    while i != len(queue):\n        for v in graph[queue[i][0]]:\n            if not colors[v]:\n                colors[v] = 3 - queue[i][1]\n                queue.append((v, colors[v]))\n        i += 1\n    \n    ans = ['0'] * m\n    for i in range(m):\n        if colors[edges[i][0]] == colors[edges[i][1]]:\n            print(\"NO\")\n            return 0\n        if colors[edges[i][0]] == 1:\n            ans[i] = '1'\n    print(\"YES\")\n    print(\"\".join(ans))\n    return 0\nmain()", "#!/usr/bin/env python\nfrom collections import deque\n\nn, m = list(map(int, input().split()))\ng = [[] for _ in range(n)]\ne = []\nfor _ in range(m):\n\tu, v = [int(_) - 1 for _ in input().split()]\n\te.append((u, v))\n\tg[u].append(v); g[v].append(u)\n\np = [-1 for _ in range(n)]\np[0] = True\nok = True\nq = deque([0])\nwhile q:\n\tf = q.popleft()\n\tfor t in g[f]:\n\t\tif p[t] == -1:\n\t\t\tq.append(t)\n\t\t\tp[t] = not p[f]\n\t\telif p[t] == p[f]:\n\t\t\tok = False\n\nif not ok:\n\tprint('NO')\nelse:\n\tprint('YES')\n\tprint(''.join(('1' if p[e[i][0]] else '0') for i in range(m)))\n"]