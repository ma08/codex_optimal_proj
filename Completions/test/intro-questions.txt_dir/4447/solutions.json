["import bisect\n\nn, m = map(int, input().split())\nls = list(map(int, input().split()))\n\nmls = []\nfor i in range(0, n):\n    mls.append((ls[i] % m, i))\n\nmls.sort()\n# print(mls)\n\nbk1 = set()\nbk2 = set()\n\naim = n // m\ncnt = 0\n\nmis = []\nfor i in range(m):\n    for j in range(aim):\n        mis.append(i)\n\np1 = 0\np2 = 0\n\nwhile p2 < n:\n    if mls[p1][0] > mis[p2]:\n        p2 += 1\n    else:\n        a = mis[p2] - mls[p1][0]\n        ls[mls[p1][1]] += a\n        cnt += a\n        bk2.add(p2)\n        p1 += 1\n        p2 += 1\n\nif p1 < n and p2 == n:\n    p1 = n\n    for i in range(p2):\n        if i not in bk2:\n            p1 -= 1\n            a = m - mls[p1][0] + mis[i]\n            ls[mls[p1][1]] += a\n            cnt += a\n\nprint(cnt)\nfor i in ls:\n    print(i, end=' ')\n\n", "n, m = map(int,input().split())\na = list(map(int,input().split()))\nf = [[] for i in range(m)]\nl = [0 for i in range(m)]\nfor i in range(n):\n    f[a[i] % m].append(i)\n    l[a[i] % m] += 1\nk = n // m\nj = 0\ntot = 0\nfor i in range(m):\n    while l[i] > k:\n        while l[j] >= k:\n            j = (j + 1) % m\n        tot += (j + m - i) % m\n        l[j] += 1\n        a[f[i][-1]] += (j + m - i) % m\n        f[i].pop()\n        l[i] -= 1\n    if i == j:\n        j += 1\nprint(tot)\nfor i in a:\n    print(i,end=' ')\n", "n,m = list(map(int, input().split()))\nassert n % m == 0\nk = n // m\na = [*list(map(int, input().split()))]\ninds = [[] for r in range(m)]\nfor i,v in enumerate(a):\n  inds[v%m].append(i)\nextras = []\nfor r in range(2*m):\n  r %= m\n  if len(inds[r]) == k: continue\n  elif len(inds[r]) > k:\n    extras.extend(inds[r][k:])\n    inds[r] = inds[r][:k]\n  elif len(inds[r]) < k:\n    for _ in range(min(k-len(inds[r]), len(extras))):\n      inds[r].append(extras.pop())\n  else: assert False\nres = 0\nfor r in range(m):\n  for i in inds[r]:\n    if a[i] % m > r:\n      res += m - (a[i] % m)\n      a[i] += m - (a[i] % m)\n    res += (r - a[i] % m)\n    a[i] += (r - a[i] % m)\nprint(res)\nprint(' '.join(map(str, a)))\n", "k=int(input().split()[1])\nl=list()\nsc=[0]*k\nfor i in input().split():\n    l.append(int(i))\ngoal=len(l)/k\ncpt=0\ns=\"\"\ndict={}\nfor i in range(len(l)):\n    ok=0\n    init=l[i]%k\n    ltc=list()\n    while(not ok):\n        div=l[i]%k\n        if(sc[div]<goal):\n            sc[div]+=1\n            ok=1\n            for j in ltc:\n                dict[j]=div\n        else:\n            ltc.append(div)\n            #chercher dans la map si on a d\u00e9j\u00e0 \u00e9t\u00e9 ici\n            if(div in dict.keys()):\n                nd=dict[div]\n                diff=(nd-div)%k\n                cpt+=diff\n                l[i]+=diff\n            else:\n                cpt+=1\n                l[i]+=1\n    s+=str(l[i])+\" \"\nprint(cpt)\nprint(s[:len(s)-1])", "3\n\n\nfrom queue import Queue\nimport sys\nimport math\nimport os.path\n\n\ndef log(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n\n\n# INPUT\ndef ni():\n    return list(map(int, input().split()))\n\n\ndef nio(offset):\n    return [int(x) + offset for x in input().split()]\n\n\ndef nia():\n    return list(map(int, input().split()))\n\n# CONVERT\n\n\ndef toString(aList, sep=\" \"):\n    return sep.join(str(x) for x in aList)\n\n\ndef toMapInvertIndex(aList):\n    return {k: v for v, k in enumerate(aList)}\n\n\n# MAIN\n\nn,m = ni()\na = nia()\n\nnm = n // m\n\nmmap = [[] for _ in range(m)]\n\nfor i in range(n) :\n    xx = a[i] % m\n    mmap[xx].append(i)\n\n# log(n,m)\n# log(mmap)\n\nmove = []\ndestination = []\n\nfor i in range(m):\n    ddu = mmap[i]\n    x = len(ddu)\n    destination.extend([i]*(nm-x))\n    move.extend(ddu[nm:x])\n    \n# log(\"move\",move)\n# log(\"dest\",destination)\n\nssum = 0\nlenmove = len(move)\nsMoveId = sorted(list(range(lenmove)), key=lambda k: a[move[k]] % m)\n\n# log(\"smId\",sMoveId)\ndi = 0\nfor i in range(lenmove):\n    moveId = sMoveId[i]\n    s = a[move[moveId]] % m    \n    while destination[di] < s:\n        destination.append(destination[di]+m)\n        di += 1    \n    d = destination[di]\n    di += 1\n    ssum += d-s\n\n    # log(\"move \", move[moveId],\"as\",a[move[moveId]],s,\" to \", d, ssum)\n    a[move[moveId]] += d-s\n\nprint(ssum)\nprint(toString(a))\n    \n", "import sys\nfrom collections import Counter\n\ndef i_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\nn, m = i_ints()\na = list(i_ints())\n\nr = [x % m for x in a]\nc = Counter(r)\nc = [c[i] for i in range(m)]\n\nrem2ind = [[] for i in range(m)]\nfor i, x in enumerate(r):\n    rem2ind[x].append(i)\n    \n\nR = n // m\n\nfor i, inds in enumerate(rem2ind):\n    if len(inds) > R:\n        next_big = i\n        break\nelse:\n    next_big = m\nnext_small = next_big + 1\n#for i in range(next_big + 1, next_big + m):\n#    if len(rem2ind[i%m]) < R:\n#        next_small = i\n#        break\n\nmoves = 0\nwhile next_big < m:\n    next_small = max(next_small, next_big + 1)\n    num = max(c[next_big] - R, 0)\n    while num > 0:\n        num2 = max(R - c[next_small%m], 0)\n        delta = min(num, num2)\n        num -= delta\n        c[next_small%m] += delta\n        step = next_small - next_big\n        for i in rem2ind[next_big][num:num+delta]:\n            a[i] += step\n        moves += delta * step\n        if c[next_small%m] >= R:\n            next_small += 1\n#        print(next_big, next_small, delta, step, moves)\n    next_big += 1\n            \nprint(moves)\nprint( \" \".join(map(str, a)))\n\n\n\n#def distribute(k, i):\n#    \"\"\" distribute i elements from position k to the following positions, not exceeding R\"\"\"\n#    while i > 0:\n#        c[k] -= i\n#        moves[k] += i\n#        k = (k+1) % m\n#        c[k] += i\n#        i = max(0, c[k] - R)\n#    \n#moves = [0] * m\n#    \n#for k in range(m):\n#    if c[k] > R:\n#        distribute(k, c[k] - R)\n#        \n#print(sum(moves))\n#\n#for k, x in enumerate(a):\n#    while moves[x%m]:\n#        moves[x%m] -= 1\n#        x += 1\n#    a[k] = x\n#\n#print( \" \".join(map(str, a)))\n", "n,m = list(map(int, input().split()))\nnums = list(map(int, input().split()))\n\n# 0 to m-1 remainders\nremainder = [0]*m\nlimit = n//m\nmoves = 0\n\nfor i in nums:\n    remainder[i%m] += 1\n\nfor i in range(m):\n    remainder[i] -= limit\n\ndeficit = set() \nfor i in range(m):\n    if remainder[i] < 0:\n        deficit.add(i)\n\n#print(remainder)\n#print(deficit)\nspare = []\nconvert = {}\n\ni = 0\nwhile len(deficit) > 0:\n    i = i%m\n\n    if remainder[i] > 0:\n        spare.append([i, remainder[i]])\n        remainder[i] = 0\n    elif remainder[i] < 0:\n        if len(spare) > 0:\n            while len(spare) > 0 and remainder[i] < 0:\n                rem = min(spare[-1][1],abs(remainder[i]))\n\n                if spare[-1][0] in list(convert.keys()):\n                    convert[spare[-1][0]].append([(i - spare[-1][0])%m, rem]) \n                else:\n                    convert[spare[-1][0]] = [[(i - spare[-1][0])%m,rem]]\n\n                spare[-1][1] -= rem\n                remainder[i] += rem\n\n                if spare[-1][1] == 0:\n                    spare.pop()\n            \n            if remainder[i] == 0:\n                deficit.remove(i)\n    \n    i += 1\n\nfor i in range(n):\n    rem = nums[i]%m\n\n    if rem in list(convert.keys()):\n        moves += convert[rem][-1][0]\n        nums[i] += convert[rem][-1][0]\n        convert[rem][-1][1] -= 1\n\n        if convert[rem][-1][1] == 0:\n            convert[rem].pop()\n        \n        if len(convert[rem]) == 0:\n            del convert[rem]\n#print(convert)\nprint(moves)\nprint(*nums)\n", "n,m = list(map(int, input().split()))\nnums = list(map(int, input().split()))\n\n# 0 to m-1 remainders\nremainder = [0]*m\nlimit = n//m\nmoves = 0\n\nfor i in nums:\n    remainder[i%m] += 1\n\nfor i in range(m):\n    remainder[i] -= limit\n\ndeficit = set() \nfor i in range(m):\n    if remainder[i] < 0:\n        deficit.add(i)\n\n#print(remainder)\n#print(deficit)\nspare = []\nconvert = {}\n\ni = 0\nwhile len(deficit) > 0:\n    i = i%m\n\n    if remainder[i] > 0:\n        spare.append([i, remainder[i]])\n        remainder[i] = 0\n    elif remainder[i] < 0:\n        if len(spare) > 0:\n            while len(spare) > 0 and remainder[i] < 0:\n                rem = min(spare[-1][1],abs(remainder[i]))\n\n                if spare[-1][0] in list(convert.keys()):\n                    convert[spare[-1][0]].append([(i - spare[-1][0])%m, rem]) \n                else:\n                    convert[spare[-1][0]] = [[(i - spare[-1][0])%m,rem]]\n\n                spare[-1][1] -= rem\n                remainder[i] += rem\n\n                if spare[-1][1] == 0:\n                    spare.pop()\n            \n            if remainder[i] == 0:\n                deficit.remove(i)\n    \n    i += 1\n\nfor i in range(n):\n    rem = nums[i]%m\n\n    if rem in list(convert.keys()):\n        moves += convert[rem][-1][0]\n        nums[i] += convert[rem][-1][0]\n        convert[rem][-1][1] -= 1\n\n        if convert[rem][-1][1] == 0:\n            convert[rem].pop()\n        \n        if len(convert[rem]) == 0:\n            del convert[rem]\n#print(convert)\nprint(moves)\nprint(*nums)\n", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = sum(a)\nx = [[] for i in range(m)]\nfor i in range(n): x[a[i] % m].append(i)\nj = 0\nfor i in range(m):\n    while len(x[i]) > n // m:\n        while j < i or len(x[j % m]) >= n // m: j += 1\n        k = x[i].pop()\n        a[k] += (j - i) % m\n        x[j % m].append(k)\nprint(sum(a) - s)\nprint(*a)\n", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nd={}\nfor i in range(m):\n\td[i]=[]\nfor i in range(len(a)):\n\tr=a[i]%m\n\td[r].append((a[i],i))\n# print(d)\nstep=0\nx=n//m\nstack=[]\n# print(d)\nfor i in range(2*m):\n\ti=i%m\n\t# print(i,stack)\n\twhile(len(d[i])>x):\n\t\tstack.append(d[i].pop())\n\twhile(len(d[i])<x and len(stack)):\n\t\tz=list(stack.pop())\n\t\tdelta=(i+m-(z[0]%m))%m\n\t\tz[0]+=delta\n\t\td[i].append((z[0],z[1]))\n\t\tstep+=delta\narr=[]\n# print(d)\nfor i in d:\n\tfor j in d[i]:\n\t\tarr.append(j)\narr.sort(key=lambda i: i[1])\nprint(step)\nfor i in arr:\n\tprint(i[0],end=\" \")\nprint()", "import collections\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nmd = n // m\nc = [[] for _ in range(m)]\nmx, ind, moves = (0,) * 3\nmovable = collections.deque()\nchange = []\n\nfor i in range(n):\n    c[a[i] % m].append(i)\n\nfor i in range(m):\n    req = md - len(c[i])\n    if req <= 0:\n        for j in range(-req):\n            movable.append(i)\n    else:\n        while req > 0:\n            if len(movable) == 0:\n                change.append([i, req])\n                break\n            old = movable[0]\n            add = i - old\n            a[c[old][-1]] += add\n            moves += add\n\n            c[i].append(c[old][-1])\n            del c[old][-1]\n            movable.popleft()\n            req -= 1\n\nfor obj in change:\n    i, req = obj[0], obj[1]\n    while req > 0:\n        old = movable[0]\n        add = i + m - old\n        a[c[old][-1]] += add\n        moves += add\n\n        c[i].append(c[old][-1])\n        del c[old][-1]\n        movable.popleft()\n        req -= 1\n\n# print(c)\nans = [0 for _ in range(n)]\n\nfor i in range(m):\n    for j in range(md):\n        ans[c[i][j]] = a[c[i][j]]\n\nprint(moves)\nprint(*ans)", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = sum(a)\nx = [[] for i in range(m)]\nfor i in range(n): \n    x[a[i] % m].append(i)\nj = 0\nfor i in range(m):\n    while len(x[i]) > n // m:\n        while j < i or len(x[j % m]) >= n // m: \n            j += 1\n        k = x[i].pop()\n        a[k] += (j - i) % m\n        x[j % m].append(k)\nprint(sum(a) - s)\nprint(*a)\n", "import collections\n\nn, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nd = collections.defaultdict(set)\nkr = [-n//k] * k\n\nfor i in range(n):\n  ri = a[i] % k\n  kr[ri] += 1\n  d[ri].add(i)\n\nkrs = [0] * k\nkrs[0] = kr[0]\nfor i in range(1, k):\n  krs[i] = krs[i-1] + kr[i]\n\norg = (krs.index(min(krs))+1)%k\ncnt = sum(abs(i) for i in kr) // 2\naa = [0] * cnt\nbb = [0] * cnt\nai = bi = 0\n\nfor ii in range(org, org+k):\n  i = ii % k\n  if kr[i] > 0:\n    for _ in range(kr[i]):\n      aa[ai] = i\n      ai += 1\n  elif kr[i] < 0:\n    for _ in range(-kr[i]):\n      bb[bi] = i\n      bi += 1\n\nans = 0\nfor ai, bi in zip(aa,bb):\n  diff = (bi-org)%k - (ai-org)%k\n  ans += diff\n  i = d[ai].pop()\n  a[i] += diff\n\nprint(ans)\nprint(' '.join(map(str, a)))\n", "n, m = map(int, input().split())\na = list(map(int, input().split()))\ns = sum(a)\nx = [[] for i in range(m)]\nfor i in range(n): x[a[i] % m].append(i)\nj = 0\nfor i in range(m):\n    while len(x[i]) > n // m:\n        while j < i or len(x[j % m]) >= n // m: j += 1\n        k = x[i].pop()\n        a[k] += (j - i) % m\n        x[j % m].append(k)\nprint(sum(a) - s)\nprint(*a)", "from collections import defaultdict\n\nn,m = map(int,input().split())\nk = n//m\nl = list(map(int,input().split()))\ns = sum(l)\n#mod_list = []\nocc = defaultdict(list)\nfor i,a in enumerate(l):\n    rem = a%m\n    occ[rem].append(i)\n    #mod_list.append(rem)\n\nj = 0\nfor i in range(m):\n    while len(occ[i]) > k:\n        while j < i or len(occ[j % m]) >= k: j += 1\n        key = occ[i].pop()\n        l[key] += (j - i) % m\n        occ[j % m].append(k)\nprint(sum(l) - s)\nprint(*l)", "n, m = list(map(int, input().split()))\naa = list(map(int, input().split()))\nres, cnt = sum(aa), [-n // m] * m\nacc = [[] for _ in range(m)]\nfor i, a in enumerate(aa):\n    r = a % m\n    cnt[r] += 1\n    acc[r].append(i)\nicnt, a = [], 0\nfor c in cnt:\n    a += c\n    icnt.append(a)\nstart = (min(range(m), key=icnt.__getitem__) + 1) % m\nexcess, scarce = [], []\nfor r in range(start, m), range(start):\n    for i in r:\n        if cnt[i] > 0:\n            for _ in range(cnt[i]):\n                excess.append(i)\n        elif cnt[i] < 0:\n            for _ in range(-cnt[i]):\n                scarce.append(i)\nfor e, s in zip(excess, scarce):\n    aa[acc[e].pop()] += (s - e) % m\nprint(sum(aa) - res)\nprint(' '.join(map(str, aa)))", "n, m = map(int, input().split())\naa = list(map(int, input().split()))\nres, q = sum(aa), n // m\nacc = [[] for _ in range(m)]\nfor i in range(n):\n    acc[aa[i] % m].append(i)\nj = -m\nfor i, l in enumerate(acc):\n    if len(l) > q:\n        if j <= i - m:\n            j = i - m + 1\n        while len(l) > q:\n            while len(acc[j]) >= q:\n                j += 1\n            aa[l.pop()] += j + m - i\n            acc[j].append(0)\nprint(sum(aa) - res)\nprint(' '.join(map(str, aa)))", "from collections import deque\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nn_m = n // m\nc = m * [0]\nindices = [deque() for r in range(m)]\n\nfor i, ai in enumerate(a):\n    r = ai % m\n    c[r] += 1\n    indices[r].append(i)\n\nn_moves = 0\nqueue = deque()\n\nfor i in range(0, 2 * m):\n    r = i % m\n    \n    while c[r] > n_m:\n        queue.append((i, indices[r].pop()))\n        c[r] -= 1\n    \n    while c[r] < n_m and queue:\n        j, index = queue.popleft()\n        indices[r].append(index)\n        c[r] += 1\n        a[index] += i - j\n        n_moves += i - j\n\nprint(n_moves)\nprint(*a)", "n,m = map(int,input().split())\na = list(map(int,input().split()))\nk = int(n/m)\nlis = [ [] for i in range(m+1)]\n\nfree = list()\n\nfor i in range(n):\n    ele = a[i]%m\n    lis[ele].append(i)\n\nans = 0\n\nfor i in range(2*m):\n    cur = i%m\n    \n    while len(lis[cur])>k:\n        ele = lis[cur].pop()\n        free.append([ele,i])\n    \n    while len(lis[cur])<k and free!=[]:\n        ele,mm = free.pop()\n        #print(ele,mm)\n        lis[cur].append(ele)\n        a[ele]+=(i-mm)\n        ans+=(i-mm)\nprint(ans)\nfor item in a:\n    print(item,end=\" \")\n\n        \n        \n        ", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = [[] for _ in range(m)]\n\nfor i in range(n):\n    s[a[i] % m].append(i)\n\nf = []\nc = 0\n\nfor _ in range(2):\n    for i in range(m):\n        while len(s[i]) > n // m:\n            f.append((s[i].pop(), i))\n        while len(s[i]) < n // m and f:\n            v, p = f.pop()\n            s[i].append(v)\n            if i > p:\n                d = i - p\n            else:\n                d = i + m - p\n            a[v] += d\n            c += d\n\nprint(c)\nprint(*a)\n", "import sys\ninput = sys.stdin.readline\nout = sys.stdout\n\ndef main():\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    query = n//m\n    data = {i: 0 for i in range(n)}\n    data_stat = {i: set() for i in range(m)}\n    for i in range(n):\n        data[i] = a[i]\n        data_stat[a[i] % m].add(i)\n    free = []\n    answer = {i: 0 for i in range(n)}\n    result = 0\n    for i in range(2*m):\n        cur = i % m\n        while len(data_stat[cur]) > query:\n            elem = data_stat[cur].pop()\n            free.append((elem, i))\n        while len(data_stat[cur]) < query and free != []:\n            elem, mmod = free.pop()\n            data_stat[cur].add(elem)\n            a[elem] += i - mmod\n            result += i - mmod        \n    print(result)\n    for j in a:\n        out.write(str(j) + ' ')\n\ndef __starting_point():\n    main()\n__starting_point()", "import collections\nn,m = [int(x) for x in input().split()]\n\nL = [int(x) for x in input().split()]\n\nJ = [0]*m\nD = []\nfor i in range(m):\n    D.append([])\nx = n//m\ns = 0\nfor i in range(m):\n    D[i] = []\nfor i in range(n):\n    J[L[i]%m] += 1\n    D[L[i]%m].append(i)\n\nFree = collections.deque([])\nF = 0\nfor i in range(2*m-1):\n    j = i%m\n    if J[j] > x:\n        t = J[j] - x\n        F += t\n        for A in range(t):\n            Free.append((j,D[j][A]))\n        J[j] = x\n    elif J[j] < x:\n        while (F > 0) and (J[j] < x):\n            F -= 1\n            J[j] += 1\n            a,b = Free.popleft()\n            s += (j-a)%m\n            L[b] += (j-a)%m\nprint(s)\nfor i in L:\n    print(i, end = ' ')", "n, m = map(int, input().split())\na = list(map(int, input().split()))\nk, c, free = n // m, [[] for _ in range(m)], []\nfor i, ai in enumerate(a):\n\tc[ai % m].append(i)\nans = 0\nfor _ in range(2 * m):\n\ti = _ % m\n\tlci = len(c[i])\n\tfor j in range(k, lci)[::-1]:\n\t\tfree.append((c[i][j], i))\n\t\tc[i].pop()\n\tfor j in range(k - lci):\n\t\tif free:\n\t\t\tto_add = (i - free[-1][1]) % m\n\t\t\tans += to_add\n\t\t\ta[free[-1][0]] += to_add\n\t\t\tc[i].append(free[-1][0])\n\t\t\tfree.pop()\nprint(ans)\nprint(*a)"]