["def main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    dct = {}\n    k = -1\n    m = 0\n    for i in range(n):\n        try: dct[arr[i]] += 1\n        except: dct[arr[i]] = 1\n        if dct[arr[i]] > m:\n            m = dct[arr[i]]\n            k = arr[i]\n    \n    print(n - m)\n    \n    for i in range(n):\n        if arr[i] == k:\n            for j in range(i - 1, -1, -1):\n                if arr[j] > k: print(2, j + 1, j + 2)\n                else: print(1, j + 1, j + 2)\n            break\n    \n    while i != n:\n        if arr[i] > k: print(2, i + 1, i)\n        if arr[i] < k: print(1, i + 1, i)\n        i += 1\n    return 0\n\nmain()", "n = int(input())\nA = list(map(int, input().split()))\ncnt = {}\nfor i in A:\n    if i not in cnt:\n        cnt[i] = 0\n    cnt[i] += 1\nmas = 0\nz = 0\nfor u in cnt:\n    if mas < cnt[u]:\n        mas = cnt[u]\n        z = u\nprint(len(A) - cnt[z])\nzind = A.index(z)\nfor u in range(zind - 1, -1, -1):\n    if A[u] < z:\n        print(1, u + 1, u + 2)\n    elif A[u] > z:\n        print(2, 1 + u, u + 2)\nfor i in range(zind, n):\n    if A[i] < z:\n        print(1, i + 1, i)\n    elif A[i] > z:\n        print(2, i + 1, i)", "#Bhargey Mehta (Sophomore)\n#DA-IICT, Gandhinagar\nimport sys, math, queue\nsys.setrecursionlimit(1000000)\n#sys.stdin = open(\"input.txt\", \"r\")\n\nn = int(input())\na = list(map(int, input().split()))\nf = {}\nfor ai in a:\n    if ai not in f: f[ai] = 1\n    else: f[ai] += 1\n\nmx = a[0]\nfor k in f:\n    if f[k] > f[mx]:\n        mx = k\ndel f\nfor i in range(n):\n    if a[i] == mx:\n        mxi = i\n        break\n\nsteps = []\nfor i in range(mxi+1, n):\n    if a[i] < mx:\n        steps.append((1, i+1, i))\n    elif a[i] > mx:\n        steps.append((2, i+1, i))\nfor i in range(mxi-1, -1, -1):\n    if a[i] < mx:\n        steps.append((1, i+1, i+2))\n    elif a[i] > mx:\n        steps.append((2, i+1, i+2))\nprint(len(steps))\nfor step in steps:\n    print(*step)", "import sys\ninput = sys.stdin.readline\nfrom collections import Counter\n\nn=int(input())\nA=list(map(int,input().split()))\n\ncounter=Counter(A)\nx,y=counter.most_common(1)[0]\n\n\nprint(n-y)\n\nfor i in range(n):\n    if A[i]==x:\n        start=i\n        break\n\nfor j in range(start,-1,-1):\n    if A[j]==x:\n        continue\n    if A[j]>x:\n        print(2,j+1,j+2)\n    else:\n        print(1,j+1,j+2)\n\n\n\nfor j in range(start,n):\n    if A[j]==x:\n        continue\n    if A[j]>x:\n        print(2,j+1,j)\n    else:\n        print(1,j+1,j)\n\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(20-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\nfrom math import factorial\n\n\ndef main():\n    n = get_int()\n    li = get_list()\n    count = Counter(li)\n    j = 0\n    res = []\n    maxi = -1\n    for i in count.keys():\n        if count[i]>j:\n            j = count[i]\n            maxi = i\n    encountered = False\n    for i,ele in enumerate(li):\n        if ele!=maxi and not encountered:\n            res.append([1 if ele<maxi else 2,i+1,i+2])\n        elif ele==maxi and not encountered:\n            encountered = True\n            res.reverse()\n        elif ele!=maxi and encountered:\n            res.append([1 if ele<maxi else 2,i+1,i])\n    print(len(res))\n    for i in res:\n        display_list(i)\n\n    \n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n = int(input())\na = list(map(int, input().split()))\n\ncnt = [0] * 200001\nfor x in a:\n    cnt[x] += 1\n\nmx = max(cnt)\nval = -1\nfor x in a:\n    if cnt[x] == mx:\n        val = x\n\nindex = -1\nfor i, x in enumerate(a):\n    if x == val:\n        index = i\n        break\n\nanswer = []\nfor i in reversed(list(range(index))):\n    if a[i] > val:\n        answer.append((2, i, i + 1))\n    elif a[i] < val:\n        answer.append((1, i, i + 1))\n\nfor i in range(index + 1, n):\n    if a[i] > val:\n        answer.append((2, i, i - 1))\n    elif a[i] < val:\n        answer.append((1, i, i - 1))\n\nprint(len(answer))\nfor a, b, c in answer:\n    print(a, b + 1, c + 1)\n", "n = int(input())\nA = list(map(int, input().split()))\nS = set(A)\n\nD = {}\n\nfor i in A:\n    if i in list(D.keys()):\n        D[i] += 1\n    else:\n        D[i] = 1\n\np = sorted(list(D.items()), key=lambda x: x[1])\nmax_number = p[-1][0]\nfirst_index = A.index(max_number)\n\nprint(len(A) - p[-1][1])\nfor i in range(first_index - 1, -1, -1):\n    if A[i] < max_number:\n        x = 1\n    else:\n        x = 2\n    print(x, i + 1, i + 2)\n\nfor i in range(first_index + 1, n):\n    if A[i] == max_number:\n        continue\n\n    if A[i] < max_number:\n        x = 1\n    else:\n        x = 2\n    print(x, i + 1, i)\n", "n, l = int(input()), list(map(int, input().split()))\n\nd = {}\nmx, index = 0, 0\n\nfor i in l:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\n    if d[i] > mx:\n        mx = d[i]\n        index = i\n\nprint(n - mx)\ni = l.index(index)\nj = i\nwhile j >= 0:\n    if l[j] > index:\n        print(2, j + 1, j + 2)\n    elif l[j] < index:\n        print(1, j + 1, j + 2)\n    j -= 1\nwhile i < n:\n    if l[i] > index:\n        print(2, i + 1, i)\n    elif l[i] < index:\n        print(1, i + 1, i)\n    i += 1\n        \n", "N = int(input())\nA = [int(a) for a in input().split()]\nB = [0] * (2*10**5+10)\nfor a in A:\n    B[a] += 1\nma = 0\nmai = 0\nfor i in range(len(B)):\n    if B[i] > ma:\n        ma = B[i]\n        maa = i\n\nfor i in range(N):\n    if A[i] == maa:\n        mai = i\n        break\nprint(N - ma)\n\nfor i in range(mai)[::-1]:\n    if A[i] < maa:\n        print(1, i+1, i+2)\n    elif A[i] > maa:\n        print(2, i+1, i+2)\n\nfor i in range(mai+1, N):\n    if A[i] < maa:\n        print(1, i+1, i)\n    elif A[i] > maa:\n        print(2, i+1, i)\n", "n = int(input())\nl = list(map(int, input().split()))\nmask = [0] * 200001\nfor i in range(n):\n    mask[l[i]] += 1\nfor i in range(200001):\n    mask[i] = [mask[i], i]\nmask.sort(reverse=True)\ncur = mask[0][1]\nprint(n - mask[0][0])\nbasis = l.index(cur)\nfor i in range(basis - 1, -1, -1):\n    if l[i] > cur:\n        print(2, i + 1, i + 2)\n    elif l[i] < cur:\n        print(1, i + 1, i + 2)\nfor i in range(basis + 1, n):\n    if l[i] > cur:\n        print(2, i + 1, i)\n    elif l[i] < cur:\n        print(1, i + 1, i)", "# -*- coding: utf-8 -*-\n\nfrom collections import Counter\n\n\ndef __starting_point():\n    n = int(input())\n    array = list(map(int, input().split()))\n    frequencies = Counter(array)\n    target_value, max_frequency = frequencies.most_common(1)[0]\n    print(n - max_frequency)\n\n    value_found = False\n    for i in range(n):\n        elem = array[i]\n        if value_found and elem != target_value:\n            if elem > target_value:\n                print(2, i + 1, i)\n            else:\n                print(1, i + 1, i)\n            array[i] = target_value\n        elif elem == target_value:\n            value_found = True\n\n    value_found = False\n    for i in range(n - 1, -1, -1):\n        elem = array[i]\n        if value_found and elem != target_value:\n            if elem > target_value:\n                print(2, i + 1, i + 2)\n            else:\n                print(1, i + 1, i + 2)\n            array[i] = target_value\n        elif elem == target_value:\n            value_found = True\n\n__starting_point()", "n = int(input())\na = list(map(int,input().split()))\nfrom collections import Counter\ndef compute_mode(numbers):\n    counts = Counter(numbers)\n    maxcount = max(counts.values())\n    for num,count in counts.items():\n        if count == maxcount:\n            return num\nm = compute_mode(a)\nmi = a.index(m)\nk = []\n\nfor i in range(mi-1,-1,-1):\n    if a[i]>m:\n        k.append([2,i+1,i+2])\n    elif a[i]<m:\n        k.append([1,i+1,i+2])\nfor i in range(mi+1,n):\n    if a[i]>m:\n        k.append([2,i+1,i])\n    elif a[i]<m:\n        k.append([1,i+1,i])\nprint(len(k))\nfor i in k:\n    print(*i)", "from collections import defaultdict as ddict\n\nn = int(input())\na = list(map(int, input().split()))\ncount = ddict(list)\nmain_key = 0\nmax_len = 0\n\nfor i, it in enumerate(a):\n    count[it].append(i)\nfor k in count:\n    if len(count[k]) > max_len:\n        max_len = len(count[k])\n        main_key = count[k][0]\nif max_len == n:\n    print(0)\n    return\n\nans = list()\nfor i in range(main_key-1, -1, -1):\n    if a[i] == a[main_key]: continue\n    if a[i] > a[main_key]: ans.append((2, i+1, i+2))\n    else: ans.append((1, i+1, i+2))\n\nfor i in range(main_key+1, n):\n    if a[i] == a[main_key]: continue\n    if a[i] > a[main_key]: ans.append((2, i+1, i))\n    else: ans.append((1, i+1, i))\n\nprint(len(ans))\nfor it in ans:\n    print('%d %d %d'%(it))\n", "n = int(input())\na = list(map(int, input().split()))\nf = dict()\nfor x in a:\n    if x in f:\n        f[x] += 1\n    else:\n        f[x] = 1\nmax_val = 0\nwho = 0\nfor key, value in f.items():\n    if value > max_val:\n        max_val = value\n        who = key\nind = -1\nans = []\nfor j in range(0, len(a)):\n    if a[j] == who:\n        ind = j\n        break\nassert(ind != -1)\nfor j in range(ind + 1, len(a)):\n    if a[j] == who:\n        continue\n    if a[j] > who:\n        ans.append((2, j, j - 1))\n    else:\n        ans.append((1, j, j - 1))\nfor j in range(ind - 1, -1, -1):\n    if a[j] == who:\n        continue\n    if a[j] > who:\n        ans.append((2, j, j + 1))\n    else:\n        ans.append((1, j, j + 1))\nprint(len(ans))\nfor t, i, j in ans:\n    print(t, i + 1, j + 1)", "from collections import Counter\n\nn = int(input())\n\na = [int(x) for x in input().split()]\n\nc = Counter(a)\n\nt = c.most_common(1)[0]\n\nidx = a.index(t[0])\n\nr= []\n\nfor i in range(idx-1, -1, -1):\n    if a[i] == t[0]:\n        continue\n    if a[i] > t[0]:\n        r.append((2, i+1, i+2))\n    else:\n        r.append((1, i+1, i + 2))\n\nfor i in range(idx+1, n):\n    if a[i] == t[0]:\n        continue\n    if a[i] > t[0]:\n        r.append((2, i+1, i))\n    else:\n        r.append((1, i + 1, i))\n\nprint(len(r))\nfor tt in r:\n    print(*tt)\n", "def solve(a):\n    d = {}\n    for i in a:\n        if i in d:\n            d[i] +=1\n        else:\n            d[i] = 1\n    m = 0\n    elem = 0\n    for i in d:\n        if d[i] > m :\n            m = d[i]\n            elem = i\n    print(len(a) - m)\n    start = -1\n    for i in range(len(a)):\n        if a[i] == elem:\n            start = i\n            break\n    for i in range(start-1, -1, -1):\n        if a[i] < elem:\n            print('1 ' + str(i+1) + ' ' + str(i+2))\n        else:\n            print('2 ' + str(i+1) + ' ' + str(i+2))\n    for i in range(start+1, len(a)):\n        if a[i]!=elem:\n            if a[i] < elem:\n                print('1 ' + str(i+1) + ' ' + str(i))\n            else:\n                print('2 ' + str(i+1) + ' ' + str(i))\n\n\n\nn = int(input())\nx = input().split()\na = []\nfor i in x:\n    a.append(int(i))\nsolve(a)\n", "n = int(input())\n\na = [int(i) for i in input().split()]\n\n\ncounts = {}\nmax_cnt=0\nmax_value = -1\nindd = -1\nfor ij in range(n):\n    i = a[ij]\n    if i not in counts:\n        counts[i] = 0\n    counts[i]+=1\n    if counts[i]>max_cnt:\n        max_cnt = counts[i]\n        max_value = i\n        indd = ij\n\nprint(n-max_cnt)\nfor i in range(indd+1, n):\n    if a[i]!=max_value:\n        if a[i]<max_value:\n            print(1, i+1, i)\n        else:\n            print(2, i + 1, i)\n\nfor i in range(indd-1, -1, -1):\n    if a[i]!=max_value:\n        if a[i]<max_value:\n            print(1, i+1, i+2)\n        else:\n            print(2, i + 1, i + 2)\n", "from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nimport math\nimport random\nMAX = sys.maxsize\nMAXN = 10**5+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN(x = \" \"):\n    return(map(int,sys.stdin.readline().strip().split(x)))\n\ndef charIN():\n    return(sys.stdin.readline().strip().split())\n\ndef dis(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\n\n\n\nn = int(input())\nl = list(numIN())\nd = defaultdict(int)\n\nmx = -1\nx = -1\nfor i in l:\n    d[i]+=1\n    if d[i]>mx:\n        mx = d[i]\n        x = i\ni = l.index(x)\nans = []\nfor j in range(i,0,-1):\n    if l[j]>l[j-1]:\n        l[j-1]+=abs(l[j]-l[j-1])\n        ans.append([1,j,j+1])\n    elif l[j]<l[j-1]:\n        l[j-1]-=abs(l[j]-l[j-1])\n        ans.append([2,j,j+1])\n    else:\n        coninue\nfor j in range(i,n-1):\n    if l[j+1]>l[j]:\n        l[j+1]-=abs(l[j]-l[j+1])\n        ans.append([2,j+2,j+1])\n    elif l[j+1]<l[j]:\n        l[j+1]+=abs(l[j]-l[j+1])\n        ans.append([1,j+2,j+1])\n    else:\n        continue\nprint(len(ans))\nfor i in ans:\n    print(*i)", "from collections import Counter\n# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int, input().split()))\nC = Counter(A)\nR = C.most_common()[0][0]\nop = []\n\nl = A.index(R)\nr = l\nl -= 1\nr += 1\nwhile l >= 0:\n    if A[l] == R:\n        l -= 1\n        continue\n    elif A[l] < R:\n        op.append([1, l+1, l+2])\n    else:\n        op.append([2, l+1, l+2])\n    l -= 1\nwhile r < N:\n    if A[r] == R:\n        r += 1\n        continue\n    elif A[r] < R:\n        op.append([1, r+1, r])\n    else:\n        op.append([2, r+1, r])\n    r += 1\n\nif len(op):\n    print(len(op))\n    for l in op:\n        print(*l)\nelse:\n    print(len(op))\n", "n = int(input())\na = list(map(int, input().split()))\ng = {}\nfor q in a:\n    g[q] = g.get(q, 0)+1\nmax_quantity = max(g, key=lambda x: g[x])\nprint(len(a)-g[max_quantity])\nindex_max = a.index(max_quantity)\nfor q in range(index_max-1, -1, -1):\n    if a[q] > max_quantity:\n        print(2, q+1, q+2)\n    else:\n        print(1, q+1, q+2)\nfor q in range(index_max+1, len(a)):\n    if a[q] > max_quantity:\n        print(2, q+1, q)\n    elif a[q] < max_quantity:\n        print(1, q+1, q)\n", "import sys\n\ninput = sys.stdin.readline\n\nn = int(input())\n\na = list(map(int, input().split()))\n\noutput = []\n\nmaxi = 0\nstart = -1\ncounts = {}\nfor i in range(n):\n        if a[i] not in counts.keys():\n                counts[a[i]] = 0\n        counts[a[i]] += 1\n        if counts[a[i]] > maxi:\n                start = i\n                maxi = counts[a[i]]\n\nfor i in range(start, 0, - 1):\n        if a[i-1] < a[i]:\n                a[i-1] = a[i]\n                output.append('1 ' + str(i) + \" \" + str(i+1))\n        elif a[i-1] > a[i]:\n                a[i-1] = a[i]\n                output.append('2 ' + str(i) + \" \" + str(i+1))\n\nfor i in range(start, n-1):\n        if a[i+1] < a[i]:\n                a[i+1] = a[i]\n                output.append('1 ' + str(i+2) + \" \" + str(i+1))\n        elif a[i+1] > a[i]:\n                a[i+1] = a[i]\n                output.append('2 ' + str(i+2) + \" \" + str(i+1))\n\nprint(len(output))\nfor line in output:\n        print(line)", "n = int(input())\n\na = list(map(int, input().split()))\n\nd = {}\n\n\nfor c in a:\n\td[c] = d.get(c, 0) + 1\n\n\nkm = a[0]\nfor c in d:\n\tif d[c] > d[km]:\n\t\tkm = c\npos = 0\n\nfor i in range(n):\n\tif a[i] == km:\n\t\tpos = i\n\t\tbreak\n\nprint(n - d[km])\n\n\n\nfor i in range(pos + 1, n):\n\tif a[i] > km:\n\t\tprint(2, i + 1, i)\n\telif a[i] < km:\n\t\tprint(1, i + 1, i)\n\n\nfor i in range(pos - 1, -1, -1):\n\tif a[i] > km:\n\t\tprint(2, i + 1, i + 2)\n\telif a[i] < km:\n\t\tprint(1, i + 1, i + 2)\n", "n = int(input())\n\na = list(map(int, input().split()))\n\nd = {}\n\n\nfor c in a:\n\td[c] = d.get(c, 0) + 1\n\n\nkm = a[0]\nfor c in d:\n\tif d[c] > d[km]:\n\t\tkm = c\npos = 0\n\nfor i in range(n):\n\tif a[i] == km:\n\t\tpos = i\n\t\tbreak\n\nprint(n - d[km])\n\n\n\nfor i in range(pos + 1, n):\n\tif a[i] > km:\n\t\tprint(2, i + 1, i)\n\telif a[i] < km:\n\t\tprint(1, i + 1, i)\n\n\nfor i in range(pos - 1, -1, -1):\n\tif a[i] > km:\n\t\tprint(2, i + 1, i + 2)\n\telif a[i] < km:\n\t\tprint(1, i + 1, i + 2)\n"]