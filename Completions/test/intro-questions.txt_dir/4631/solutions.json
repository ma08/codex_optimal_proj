["from queue import deque\n\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\narr.sort()\n\nused = set(arr)\nq = deque()\nfor i in range(n):\n    q.append([arr[i] - 1, 1, -1])\n    q.append([arr[i] + 1, 1, 1])\n\nret = []\ns = 0\nwhile m:\n    x, l, dr = q.popleft()\n    a = x + dr\n    if not a in used:\n        q.append([a, l + 1, dr])\n    if not x in used:\n        used.add(x)\n        ret.append(x)\n        m -= 1\n        s += l\nprint(s)\nprint(*ret)", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nX=list(map(int,input().split()))\n\nSET=set(X)\ndis=1\n\nANS=[]\nMSET=set(X)\nPSET=set(X)\nscore=0\nMEM=0\n\nwhile MEM<m:\n\n    REMLIST=[]\n    for t in MSET:\n        if t-dis in SET:\n            REMLIST.append(t)\n        else:\n            ANS.append(t-dis)\n            SET.add(t-dis)\n            MEM+=1\n            score+=dis\n\n        if MEM==m:\n            break\n\n    MSET-=set(REMLIST)\n\n    if MEM==m:\n        break\n\n    \n\n    REMLIST=[]\n    for t in PSET:\n        if t+dis in SET:\n            REMLIST.append(t)\n        else:\n            ANS.append(t+dis)\n            SET.add(t+dis)\n            MEM+=1\n            score+=dis\n\n        if MEM==m:\n            break\n\n    PSET-=set(REMLIST)\n    dis+=1\n\nprint(score)\nprint(*ANS)\n\n        \n            \n        \n", "nsap, nhum = map(int, input().split())\nls = list(map(int, input().split()))\nsls = set(ls)\ncandidates = set()\nfor e in ls:\n    if e+1 not in sls:\n        candidates.add(e+1)\n    if e-1 not in sls:\n        candidates.add(e-1)\n        \nlevel = 1\ntotdist = 0\nres = set()\nwhile len(res) + len(candidates) <= nhum:\n    #print(candidates)\n    totdist += level * len(candidates)\n    level += 1\n    for e in candidates:\n        res.add(e)\n    cand2 = set()\n    for e in candidates:\n        for dx in (-1,1):\n            if e+dx not in res and e+dx not in sls:\n                cand2.add(e+dx)\n    candidates = cand2\n\nfor i in range(nhum-len(res)):\n    res.add(candidates.pop())\n    totdist += level\n\nprint(totdist)\nfor e in res:\n    print(e, end=' ')\n", "import collections\nimport heapq\nn,m = list(map(int, input().split()))\n\noccupied = set(map(int, input().split()))\n\nq = collections.deque(set([(1, x-1) for x in occupied if x-1 not in occupied] + \\\n                      [(1, x+1) for x in occupied if x+1 not in occupied]))\nfor _,x in q:\n  occupied.add(x)\nans = []\ntot = 0\nwhile len(ans) < m:\n  dist, x = q.popleft()\n  tot += dist\n  ans.append(x)\n  if x-1 not in occupied:\n    q.append((dist+1, x-1))\n    occupied.add(x-1)\n  if x+1 not in occupied:\n    q.append((dist+1, x+1))\n    occupied.add(x+1)\nprint(tot)\nprint(' '.join(map(str, ans)))\n", "from collections import deque\n\nn,m = list(map(int,input().split())) #tree/people\n\nx = list(map(int,input().split()))\n\ndic = {}\nq = deque([])\n\nd = 0\nans = []\n\nfor i in range(n):\n\n    dic[x[i]] = 1\n\nfor i in range(n):\n\n    if x[i] - 1 not in dic:\n        dic[x[i] - 1] = 1\n        q.append([ x[i]-1 , 1 ,\"l\"])\n    if x[i] + 1 not in dic:\n        dic[x[i] + 1] = 1\n        q.append([ x[i]+1 , 1 ,\"r\"])\n\nfor i in range(m):\n\n    now = q.popleft()\n\n    p = now[0]\n    d += now[1]\n    direc = now[2]\n\n    ans.append(p)\n\n    if direc == \"l\":\n        if p-1 not in dic:\n            dic[p-1] = 1\n            q.append([ p-1 , now[1] + 1 , direc ])\n    else:\n        if p+1 not in dic:\n            dic[p+1] = 1\n            q.append([ p+1 , now[1] + 1 , direc ])\n\nprint (d)\nprint(\" \".join(map(str,ans)))\n\n", "n, p = list(map(int,input().split()))\nl = list(map(int,input().split()))\ntrees_p = set(l)\ntrees_l = set(l)\nzaj = {}\nfor i in l:\n\tzaj[i] = 1\n\t\ndupa = 0\nodp = []\nodl = 0\nimport sys\nwhile True:\n\todl += 1\n\tto_rem = []\n\tfor t in trees_l:\n\t\ttry:\n\t\t\tzaj[t-odl]\n\t\t\tto_rem.append(t)\n\t\texcept Exception:\n\t\t\tzaj[t-odl] = 1\n\t\t\todp.append(t-odl)\n\t\t\tdupa += odl\n\t\t\tif len(odp) == p:\n\t\t\t\tprint(dupa)\n\t\t\t\tprint(*odp)\n\t\t\t\treturn\n\tfor x in to_rem:\n\t\ttrees_l.remove(x)\n\t\n\tto_rem = []\n\tfor t in trees_p:\n\t\ttry:\n\t\t\tzaj[t+odl]\n\t\t\tto_rem.append(t)\n\t\texcept Exception:\n\t\t\tzaj[t+odl] = 1\n\t\t\todp.append(t+odl)\n\t\t\tdupa += odl\n\t\t\tif len(odp) == p:\n\t\t\t\tprint(dupa)\n\t\t\t\tprint(*odp)\n\t\t\t\treturn\n\tfor x in to_rem:\n\t\ttrees_p.remove(x)\n\t\t\t\n\t\n\n", "import sys\nimport collections\nfrom collections import Counter, deque\nimport itertools\nimport math\nimport timeit\n\n#########################\n# imgur.com/Pkt7iIf.png #\n#########################\n\ndef sieve(n):\n    if n < 2: return list()\n    prime = [True for _ in range(n + 1)]\n    p = 3\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 2\n    r = [2]\n    for p in range(3, n + 1, 2):\n        if prime[p]:\n            r.append(p)\n    return r\n\ndef divs(n, start=1):\n    divisors = []\n    for i in range(start, int(math.sqrt(n) + 1)):\n        if n % i == 0:\n            if n / i == i:\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return divisors\n\ndef divn(n, primes):\n    divs_number = 1\n    for i in primes:\n        if n == 1:\n            return divs_number\n        t = 1\n        while n % i == 0:\n            t += 1\n            n //= i\n        divs_number *= t\n\ndef flin(d, x, default=-1):\n    left = right = -1\n    for i in range(len(d)):\n        if d[i] == x:\n            if left == -1: left = i\n            right = i\n    if left == -1:\n        return (default, default)\n    else:\n        return (left, right)\n\ndef ceil(n, k): return n // k + (n % k != 0)\ndef ii(): return int(input())\ndef mi(): return list(map(int, input().split()))\ndef li(): return list(map(int, input().split()))\ndef lcm(a, b): return abs(a * b) // math.gcd(a, b)\ndef prr(a, sep=' '): print(sep.join(map(str, a)))\ndef dd(): return collections.defaultdict(int)\ndef ddl(): return collections.defaultdict(list)\n\n# input = sys.stdin.readline\n\nt = 1\nfor _ in range(t):\n    n, k = mi()\n    d = li()\n    used = set(d)\n    left = d[:]\n    right = d[:]\n    res = []\n    s = 0\n    c = 1\n    while len(res) < k:\n        nl = []\n        nr = []\n        j = 0\n        while len(res) < k and j < len(left):\n            if left[j] - 1 not in used:\n                s += c\n                res.append(left[j] - 1)\n                used.add(left[j] - 1)\n                nl.append(left[j] - 1)\n            j += 1\n        j = 0\n        while len(res) < k and j < len(right):\n            if right[j] + 1 not in used:\n                s += c\n                res.append(right[j] + 1)\n                used.add(right[j] + 1)\n                nr.append(right[j] + 1)\n            j += 1\n        left = nl\n        right = nr\n        c += 1\n\n    print(s)\n    prr(res)\n", "from collections import deque\n\nn, m = list(map(int,input().split()))\nqueue = deque([])\nvst = set()\nfor k in map(int,input().split()):\n    vst.add(k)\n    queue.append((k,0))\n\nans = 0\nans_L = []\ncnt = 0\n\nwhile queue:\n    x, step = queue.popleft()\n    for dx in [1, -1]:\n        X = x + dx\n        if X not in vst:\n            cnt += 1\n            vst.add(X)\n            ans += step + 1\n            ans_L.append(X)\n            queue.append((X, step + 1))\n        if cnt == m:\n            break\n    if cnt == m:\n        break\n\nprint(ans)\nprint(*ans_L)\n\n\n\n\n", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nd={}\na.sort()\n\nlow=1\nhigh=m\n\nfor i in a:\n    d[i]=2\n\nfrom collections import deque\n\ndef check(mid,a):\n    s=0\n    for i in range(n-1):\n        s+=min(2*mid,a[i+1]-a[i]-1)\n    if s+ 2*mid>=m:\n        return True\n    else:\n        return False\n        \n    \n\nwhile low<high:\n    mid=(low+high)//2\n    if check(mid,a):\n        high=mid\n    else:\n        low=mid+1\n\nst=deque(a)\n# print(st)\nk=0\nans=[]\npr=0\nwhile m>0:\n    if st[0]==a[0]:\n        k+=1\n        \n    if st[0]-k  in d and st[0]+k in d:\n        st.popleft()\n        continue\n    # print(ans)\n    if st[0]-k  not in d:\n        d[st[0]-k]=1\n        m-=1\n        pr+=k\n        ans.append(st[0]-k)\n    # print(ans)    \n    if st[0]+k  not in d and m>0:\n        d[st[0]+k]=1\n        m-=1\n        pr+=k\n        ans.append(st[0]+k)\n    # print(ans)    \n    st.append(st.popleft())\n    \nprint(pr)    \nprint(*ans)        ", "n, m = list(map(int, input().split()))\ntrees = set(list(map(int, input().split())))\nvis = set(trees)\nres = []\ndist = 0\nfor d in range(1, m+1):\n    done = False\n    removal = set()\n    for t in trees:\n        if t-d in vis and t+d in vis:\n            removal.add(t)\n        if not t-d in vis:\n            vis.add(t-d)\n            res.append(t-d)\n            dist += d\n        if len(res) == m:\n            done = True\n            break\n        if not t+d in vis:\n            vis.add(t+d)\n            res.append(t+d)\n            dist += d\n        if len(res) == m:\n            done = True\n            break\n    if done:\n        break\n    for t in removal:\n        trees.remove(t)\nprint(dist)\nprint(' '.join(map(str, sorted(res))))\n    \n        \n", "import sys\nfrom operator import itemgetter\n\ndef input():\n    return sys.stdin.readline().strip()\n\nn,m = list(map(int, input().split()))\n\ntrees = set(map(int, input().split()))\nocc = set(trees)\nnewadd = set()\nfor x in trees:\n    if x+1 not in occ:\n        newadd.add((x+1,1))\n    if x-1 not in occ: \n        newadd.add((x-1,1))\n\nanspos = []\nans = 0\nwhile m > 0:\n    newnewadd = set()\n    while m>0 and len(newadd) > 0:\n        x,diff = newadd.pop()\n        if x in occ:\n            continue\n        occ.add(x)\n        anspos.append(x)\n        ans+=diff\n        if x+1 not in occ:\n            newnewadd.add((x+1,diff+1))\n        if x-1 not in occ:\n            newnewadd.add((x-1,diff+1))\n        m-=1\n    newadd = newnewadd\nprint(ans)\nprint(*anspos)", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int, minp().split()))\n\ndef solve():\n\tn, m = mints()\n\tq = list(mints())\n\tw = dict()\n\tfor i in q:\n\t\tw[i] = 0\n\tql = 0\n\tc = 0\n\tss = 0\n\ty = []\n\twhile ql < len(q):\n\t\tp = q[ql]\n\t\tql += 1\n\t\tx = p - 1\n\t\tif x not in w:\n\t\t\td = w[p] + 1\n\t\t\ty.append(x)\n\t\t\tq.append(x)\n\t\t\tss += d\n\t\t\tw[x] = d\n\t\t\tc += 1\n\t\t\tif c == m:\n\t\t\t\tbreak\n\t\tx = p + 1\n\t\tif x not in w:\n\t\t\td = w[p] + 1\n\t\t\tq.append(x)\n\t\t\ty.append(x)\n\t\t\tss += d\n\t\t\tw[x] = d\n\t\t\tc += 1\n\t\t\tif c == m:\n\t\t\t\tbreak\n\tprint(ss)\n\tprint(' '.join(map(str, y)))\n\n#for i in range(mint()):\nsolve()\n", "import heapq,bisect\n\ndef main():\n    n,m = map(int,input().split())\n    trees = list(map(int,input().split()))\n    trees.sort()\n\n    ans = []\n    distance = 0\n    heap = []\n    visited = set()\n    for i in trees:\n        visited.add(i)\n\n    for i in trees:\n        if i+1 not in visited:\n            heapq.heappush(heap,(1,i+1))\n        if i-1 not in visited:\n            heapq.heappush(heap,(1,i-1))\n\n    while heap:\n        curr = heapq.heappop(heap)\n        if curr[1] not in visited:\n            distance += curr[0]\n            ans.append(curr[1])\n            visited.add(curr[1])\n            if len(ans) == m:\n                break\n\n            if curr[1]+1 not in visited:\n                index = bisect.bisect(trees,curr[1]+1)\n                min_dist = float('inf')\n                if index < len(trees):\n                    min_dist = min(min_dist,trees[index]-curr[1]-1)\n                if index-1 >= 0:\n                    min_dist = min(min_dist,curr[1]+1-trees[index-1])\n\n                heapq.heappush(heap,(min_dist,curr[1]+1))\n\n            if curr[1]-1 not in visited:\n                index = bisect.bisect(trees,curr[1]-1)\n                min_dist = float('inf')\n                if index < len(trees):\n                    min_dist = min(min_dist,trees[index]-curr[1]+1)\n                if index-1 >= 0:\n                    min_dist = min(min_dist,curr[1]-1-trees[index-1])\n\n                heapq.heappush(heap,(min_dist,curr[1]-1))\n        \n\n\n    print(distance)\n    for i in ans:\n        print(i,end = ' ')\n\n\nmain()\n", "a = input('').split(' ')\nn =int(a[0])\nm = int(a[1])\nx = list(map(int,input('').split(' ')))\nd = {}\nfor xx in x:\n    d[xx] = True\n\ni = 0\nc = 0\npos = [[]]\npos.append([])\ncur = 0\npos[cur] = x.copy()\nys = []\nans = 0\nwhile(i<m):\n    c+=1\n    pos[cur^1] = []\n    for k in pos[cur]:\n        if(k+1 not in d):\n            pos[cur^1].append(k+1)\n            d[k+1] = True\n        if(k-1 not in d):\n            pos[cur^1].append(k-1)\n            d[k-1] = True\n    res = False\n    cur = cur^1\n    for p in pos[cur]:\n        i+=1\n        ys.append(p)\n        ans += c\n        if(i == m):\n            res = True\n            break\n    if(res):\n        break\n\nprint(ans)\nfor h in ys:\n    print(h,end = ' ')\n    "]