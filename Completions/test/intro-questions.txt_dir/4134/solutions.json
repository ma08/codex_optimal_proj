["from collections import*\nn, m, k = map(int, input().split())\nb = [[int(v) for v in input().split()] for _ in range(n)]\nif m < n:\n    a = [[b[j][i] for j in range(n)] for i in range(m)]\n    b = a\n    m, n = n, m\ncntrs = [Counter() for _ in range(n)]\nd = (n + m-1) // 2\nfor i in range(1<<d):\n    ones = bin(i).count('1')\n    z = d - ones\n    if ones >= n or z >= m: continue\n    xor = b[0][0]\n    x, y = 0, 0\n    for j in range(d):\n        if i&(1<<j):\n            x += 1\n        else:\n            y += 1\n        xor ^= b[x][y]\n    cntrs[x][xor] += 1\nsm = 0\nsleft = n + m - 2 - d\nfor i in range(1<<sleft):\n    ones = bin(i).count('1')\n    z = sleft - ones\n    if ones >= n or z >= m: continue\n    xor = b[n-1][m-1]\n    x, y = n-1, m-1\n    for j in range(sleft):\n        if i&(1<<j):\n            x -= 1\n        else:\n            y -= 1\n        xor ^= b[x][y]\n    xor ^= b[x][y] ^ k\n    sm += cntrs[x][xor]\nprint(sm)", "n,m,k = list(map(int, input().split()))\nb = [list(map(int, input().split())) for i in range(n)]\nt = [[None for i in range(m)] for j in range(n)]\nt2 = [[None for i in range(m)] for j in range(n)]\n\nt[0][0] = {b[0][0]: 1}\nfor i in range(1,m):\n\tt[0][i] = {list(t[0][i-1].keys())[0]^b[0][i]: 1}\nfor i in range(1,n):\n\tt[i][0] = {list(t[i-1][0].keys())[0]^b[i][0]: 1}\n\n\n\nlimit = (n+m-2)//2\n\nfor i in range(1,n):\n\tfor j in range(1,m):\n\t\tif i+j>limit:\n\t\t\tcontinue\n\t\tt[i][j] = {}\n\t\tfor num,cnt in list(t[i-1][j].items()):\n\t\t\tt[i][j][num^b[i][j]] = cnt\n\t\tfor num,cnt in list(t[i][j-1].items()):\n\t\t\tif num^b[i][j] in list(t[i][j].keys()):\n\t\t\t\tt[i][j][num^b[i][j]] += cnt\n\t\t\telse:\n\t\t\t\tt[i][j][num^b[i][j]] = cnt\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tif i+j == limit:\n\t\t\tb[i][j] = 0\n#print(b)\n\nt2[n-1][m-1] = {b[n-1][m-1]: 1}\nfor i in range(m-2, -1, -1):\n\tt2[n-1][i] = {list(t2[n-1][i+1].keys())[0]^b[n-1][i]: 1}\nfor i in range(n-2, -1, -1):\n\tt2[i][m-1] = {list(t2[i+1][m-1].keys())[0]^b[i][m-1]: 1}\n\t\n\nfor i in range(n-2, -1, -1):\n\tfor j in range(m-2, -1, -1):\n\t\tif i+j<limit:\n\t\t\tcontinue\n\t\tt2[i][j] = {}\n\t\tfor num,cnt in list(t2[i+1][j].items()):\n\t\t\tt2[i][j][num^b[i][j]] = cnt\n\t\tfor num,cnt in list(t2[i][j+1].items()):\n\t\t\tif num^b[i][j] in list(t2[i][j].keys()):\n\t\t\t\tt2[i][j][num^b[i][j]] += cnt\n\t\t\telse:\n\t\t\t\tt2[i][j][num^b[i][j]] = cnt\n\nres = 0\n\n#print(t)\n#print(t2)\n\nfor i in range(n):\n\tfor j in range(m):\n\t\tif i+j != limit:\n\t\t\tcontinue\n\t\ttk = set(t[i][j].keys())\n\t\tfor k2 in list(t2[i][j].keys()):\n\t\t\tif (k2^k) in tk:\n\t\t\t\tres += t2[i][j][k2] * t[i][j][k2^k]\n#\t\t\t\tprint(k2, t2[i][j][k2], t[i][j][k2^k])\n\nprint(res)\n\n#print(t)\n#try:\t\n#\tprint(t[n-1][m-1][k])\n#except KeyError:\n#\tprint(0)\n", "\ncnt = {}\nfor i in range(22):\n    cnt[i] = {}\n\n#print(cnt)\n\nn,m,k = list(map(int, input().split()))\narr = [list(map(int, input().split())) for i in range(n)]\n\n\n\ndef check(x,y):\n    if x < 0 or x >= n or y < 0 or y >= m:\n        return False\n    else:\n        return True\n\n\ndef go(x,y,now):\n    if check(x,y) == False:\n        return\n\n    now ^= arr[x][y]\n    if x + y == m - 1:\n        #print('yes')\n        if now in cnt[x]:\n            cnt[x][now] += 1\n        else:\n            cnt[x][now] = 1\n        return\n\n    go(x+1,y,now)\n    go(x,y+1,now)\n\nans = 0\n\ndef goRev(x,y,now):\n    if check(x,y) == False:\n        return\n\n    if x + y == m - 1:\n        cur = k ^ now\n        if cur in cnt[x]:\n            nonlocal ans\n            #print(ans)\n            ans += cnt[x][cur]\n        return\n\n    now ^= arr[x][y]\n    goRev(x-1,y,now)\n    goRev(x,y-1,now)\n\n\ngo(0,0,0)\ngoRev(n-1,m-1,0)\n\nprint(ans)\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "cnt = {}\nfor i in range(22):\n    cnt[i] = {}\n\n#print(cnt)\n\nn,m,k = list(map(int, input().split()))\narr = [list(map(int, input().split())) for i in range(n)]\n\n\n\ndef check(x,y):\n    if x < 0 or x >= n or y < 0 or y >= m:\n        return False\n    else:\n        return True\n\n\ndef go(x,y,now):\n    if check(x,y) == False:\n        return\n\n    now ^= arr[x][y]\n    if x + y == m - 1:\n        #print('yes')\n        if now in cnt[x]:\n            cnt[x][now] += 1\n        else:\n            cnt[x][now] = 1\n        return\n\n    go(x+1,y,now)\n    go(x,y+1,now)\n\nans = 0\n\ndef goRev(x,y,now):\n    if check(x,y) == False:\n        return\n\n    if x + y == m - 1:\n        cur = k ^ now\n        if cur in cnt[x]:\n            nonlocal ans\n            #print(ans)\n            ans += cnt[x][cur]\n        return\n\n    now ^= arr[x][y]\n    goRev(x-1,y,now)\n    goRev(x,y-1,now)\n\n\ngo(0,0,0)\ngoRev(n-1,m-1,0)\n\nprint(ans)", "d = {}\nfor i in range(22):\n    d[i] = {}\n\n#print(cnt)\n\nn,m,k = list(map(int, input().split()))\narr = [list(map(int, input().split())) for i in range(n)]\n\n\n\ndef check(x,y):\n    if x < 0 or x >= n or y < 0 or y >= m:\n        return False\n    else:\n        return True\n\n\ndef go(x,y,now):\n    if check(x,y) == False:\n        return\n\n    now ^= arr[x][y]\n    if x + y == m - 1:\n        #print('yes')\n        if now in d[x]:\n            d[x][now] += 1\n        else:\n            d[x][now] = 1\n        return\n\n    go(x+1,y,now)\n    go(x,y+1,now)\n\nans = 0\n\ndef goRev(x,y,now):\n    if check(x,y) == False:\n        return\n\n    if x + y == m - 1:\n        cur = k ^ now\n        if cur in d[x]:\n            nonlocal ans\n            #print(ans)\n            ans += d[x][cur]\n        return\n\n    now ^= arr[x][y]\n    goRev(x-1,y,now)\n    goRev(x,y-1,now)\n\n\ngo(0,0,0)\ngoRev(n-1,m-1,0)\n\nprint(ans)", "d = {}\nans = 0\nfor i in range(22):\n    d[i] = {}\n\n#print(cnt)\n\nn,m,k = list(map(int, input().split()))\narr = [list(map(int, input().split())) for i in range(n)]\n\n\n\ndef check(x,y):\n    if x < 0 or x >= n or y < 0 or y >= m:\n        return False\n    else:\n        return True\n\n\ndef go(x,y,now):\n    if check(x,y) == False:\n        return\n\n    now ^= arr[x][y]\n    if x + y == m - 1:\n        #print('yes')\n        if now in d[x]:\n            d[x][now] += 1\n        else:\n            d[x][now] = 1\n        return\n\n    go(x+1,y,now)\n    go(x,y+1,now)\n\ndef goRev(x,y,now):\n    if check(x,y) == False:\n        return\n\n    if x + y == m - 1:\n        cur = k ^ now\n        if cur in d[x]:\n            nonlocal ans\n            #print(ans)\n            ans += d[x][cur]\n        return\n\n    now ^= arr[x][y]\n    goRev(x-1,y,now)\n    goRev(x,y-1,now)\n\n\ngo(0,0,0)\ngoRev(n-1,m-1,0)\n\nprint(ans)", "d = {}\nans = 0\nfor i in range(22):\n    d[i] = {}\n\n#print(cnt)\n\nn,m,k = list(map(int, input().split()))\narr = [list(map(int, input().split())) for i in range(n)]\n\n\n\ndef check(x,y):\n    if x < 0 or x >= n or y < 0 or y >= m:\n        return False\n    else:\n        return True\n\n\ndef go(x,y,now):\n    if check(x,y) == False:\n        return\n\n    now ^= arr[x][y]\n    if x + y == m - 1:\n        #print('yes')\n        if now in d[x]:\n            d[x][now] += 1\n        else:\n            d[x][now] = 1\n        return\n\n    go(x+1,y,now)\n    go(x,y+1,now)\n\ndef goRev111(x,y,now):\n    if check(x,y) == False:\n        return\n\n    if x + y == m - 1:\n        cur = k ^ now\n        if cur in d[x]:\n            nonlocal ans\n            #print(ans)\n            ans += d[x][cur]\n        return\n\n    now ^= arr[x][y]\n    goRev111(x-1,y,now)\n    goRev111(x,y-1,now)\n\n\ngo(0,0,0)\ngoRev111(n-1,m-1,0)\n\nprint(ans)", "d = {}\nans = 0\nfor i in range(22):\n    d[i] = {}\n\n#print(cnt)\n\nn,m,k = list(map(int, input().split()))\narr = [list(map(int, input().split())) for i in range(n)]\n\n\n\ndef check(x,y):\n    if x < 0 or x >= n or y < 0 or y >= m:\n        return False\n    else:\n        return True\n\n\ndef go(x,y,now):\n    if check(x,y) == False:\n        return\n\n    now ^= arr[x][y]\n    if x + y == m - 1:\n        #print('yes')\n        if now in d[x]:\n            d[x][now] += 1\n        else:\n            d[x][now] = 1\n        return\n\n    go(x+1,y,now)\n    go(x,y+1,now)\n\ndef goRev(i,j,now):\n    if check(i,j) == False:\n        return\n\n    if i + j == m - 1:\n        cur = k ^ now\n        if cur in d[i]:\n            nonlocal ans\n            #print(ans)\n            ans += d[i][cur]\n        return\n\n    now ^= arr[i][j]\n    goRev(i-1,j,now)\n    goRev(i,j-1,now)\n\n\ngo(0,0,0)\ngoRev(n-1,m-1,0)\n\nprint(ans)", "\n\nd = {}\nfor i in range(22):\n    d[i] = {}\nn,m,k = list(map(int, input().split()))\nl = [list(map(int, input().split())) for i in range(n)]\ndef check(x,y):\n    if x < 0 or x >= n or y < 0 or y >= m:\n        return False\n    else:\n        return True\n\ndef go(x,y,now):\n    if check(x,y) == False:\n        return\n\n    now ^= l[x][y]\n    if x + y == m - 1:\n        #print('yes')\n        if now in d[x]:\n            d[x][now] += 1\n        else:\n            d[x][now] = 1\n        return\n\n    go(x+1,y,now)\n    go(x,y+1,now)\n\nre = 0\ndef goRev(i,j,now):\n    if check(i,j) == False:\n        return\n\n    if i + j == m - 1:\n        cur = k ^ now\n        if cur in d[i]:\n            nonlocal re\n            #print(ans)\n            re += d[i][cur]\n        return\n\n    now ^= l[i][j]\n    goRev(i-1,j,now)\n    goRev(i,j-1,now)\n\n\ngo(0, 0, 0)\ngoRev(n-1, m-1, 0)\n#print(d)\nprint(re)", "n, m, k = map(int, input().split())\nl = [list(map(int, input().split())) for _ in range(n)]\nre = 0\nhalf = (m + n - 2) // 2\nd = [dict() for _ in range(22)]\n\n\ndef forward(i, j, value):\n    if i >= n or j >= m:\n        return\n    value ^= l[i][j]\n    if i + j == half:\n        if value in d[i]:\n            d[i][value] += 1\n        else:\n            d[i][value] = 1\n        return None\n    forward(i+1, j, value)\n    forward(i, j+1, value)\n\n\ndef backward(i, j, value):\n    if i < 0 or j < 0:\n        return\n    if i + j == half:\n        tmp = k^value\n        #print(tmp)\n        if tmp in d[i]:\n            nonlocal re\n            re += d[i][tmp]\n        return None\n    value ^= l[i][j]\n    backward(i-1, j, value)\n    backward(i, j-1, value)\n\n\nforward(0, 0, 0)\nbackward(n-1, m-1, 0)\n#print(d)\nprint(re)", "from collections import defaultdict\nn, m, aim = list(map(int, input().split()))\n\ng = [[0 for i in range(m + 1)] for j in range(n + 1)]\n\nfor i in range(n):\n    ls = [int(i) for i in input().split()]\n    for j in range(m):\n        g[i + 1][j + 1] = ls[j]\n\nans = 0\ndp = defaultdict(int)\n\ndef search(x, y, is_l, mk):\n    if x < 1 or y < 1 or x > n or y > m:\n        return\n\n    if is_l:\n        mk ^= g[x][y]\n        if x + y - 1 == n:\n            dp[(x, y, mk)] += 1\n        else:\n            search(x + 1, y, is_l, mk)\n            search(x, y + 1, is_l, mk)\n    else:\n        if abs(x - n) + abs(y - m) + 1 == m:\n            # print(x, y, mk)\n            nonlocal ans\n            ans += dp[(x, y, mk)]\n        else:\n            mk ^= g[x][y]\n            search(x - 1, y, is_l, mk)\n            search(x, y - 1, is_l, mk)\n\nsearch(1, 1, True, 0)\nsearch(n, m, False, aim)\n\nprint(ans)\n", "n, m, k = list(map(int,input().split()))\nmatrix = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n# print(matrix)\nd = [[{} for _ in range(m)] for _ in range(n)]\n# print(d)\nmiddle = (n + m - 2) // 2\n# print(middle)\nanswer = 0\n\ndef upleft(x,y,acc,count):\n    val = matrix[y][x]^acc\n    if count == middle:\n        if d[y][x].get(val) == None:\n            d[y][x][val] = 1\n            return\n        else:\n            d[y][x][val] += 1\n            return\n    else:\n        if x + 1 < m:\n            upleft(x+1,y,val,count+1)\n        if y + 1 < n:\n            upleft(x,y+1,val,count+1)\n\ndef downright(x,y,acc,count):\n    nonlocal answer\n    if count == n + m - 2 - middle:\n        complement = k ^ acc\n        if d[y][x].get(complement) != None:\n            answer += d[y][x][complement]\n        return\n    else:\n        val = matrix[y][x]^acc\n        if x - 1 >= 0:\n            downright(x-1,y,val,count+1)\n        if y - 1 >= 0:\n            downright(x,y-1,val,count+1)\n\nupleft(0,0,0,0)\ndownright(m-1,n-1,0,0)\n# print(d)\nprint(answer)\n", "def go_up_to_down(w, h, value, steps):\n    value ^= matrix[h][w]\n    if steps == half_steps:\n        if value not in counts[h][w]:\n            counts[h][w][value] = 0\n\n        counts[h][w][value] += 1\n        return\n\n    if w < width - 1:\n        go_up_to_down(w + 1, h, value, steps + 1)\n    if h < height - 1:\n        go_up_to_down(w, h + 1, value, steps + 1)\n\n\ndef go_down_to_up(w, h, value, steps, count_ways):\n    if steps == width + height - 2 - half_steps:\n        if (value ^ res_find) in counts[h][w]:\n            count_ways += counts[h][w][value ^ res_find]\n        return count_ways\n\n    delta = 0\n    if w > 0:\n        delta += go_down_to_up(w - 1, h, value ^ matrix[h][w], steps + 1, count_ways)\n    if h > 0:\n        delta += go_down_to_up(w, h - 1, value ^ matrix[h][w], steps + 1, count_ways)\n\n    return count_ways + delta\n\n\nheight, width, res_find = [int(num) for num in input().split()]\nmatrix = []\n\nfor h in range(height):\n    row = [int(num) for num in input().split()]\n    matrix.append(row)\n\ncounts = [[dict()] * width for h in range(height)]\nhalf_steps = (width + height - 2) // 2\n\ngo_up_to_down(0, 0, 0, 0)\ncount_ways = go_down_to_up(width - 1, height - 1, 0, 0, 0)\n\nprint(count_ways)\n", "from collections import defaultdict\nn, m, k = list(map(int, input().split()))\na = [[0 for j in range(m)] for i in range(n)]\n\nfor i in range(n):\n    a[i] = list(map(int, input().split()))\n\ntotal = n + m - 2\nhalf = total // 2\nb = defaultdict(dict)\n\n\ndef upper(i, j, val, cnt):\n    val ^= a[i][j]\n    if cnt == half:\n        s = str(i) + ' ' + str(j)\n        if val in b[s]:\n            b[s][val] += 1\n        else:\n            b[s][val] = 1\n        return\n    if i + 1 < n:\n        upper(i + 1, j, val, cnt + 1)\n    if j + 1 < m:\n        upper(i, j + 1, val, cnt + 1)\n\n\nanswer = 0\n\ndef lower(i, j, val, cnt):\n    nonlocal answer\n    s = str(i) + ' ' + str(j)\n    if cnt == total - half:\n        aim = k ^ val\n        if aim in b[s]:\n            answer += b[s][aim]\n        return\n    if i > 0:\n        lower(i - 1, j, val ^ a[i][j], cnt + 1)\n    if j > 0:\n        lower(i, j - 1, val ^ a[i][j], cnt + 1)\n\n\nupper(0, 0, 0, 0)\nlower(n - 1, m - 1, 0, 0)\n\nprint(answer)\n\n\n\n", "n, m, k = list(map(int, input().split()))\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\nif n > m:\n    d = []\n    for i in range(m):\n        d.append([])\n        for j in range(n):\n            d[i].append(a[j][i])\n    a = d\n    n, m = m, n\n\nb = []\nfor i in range(n):\n    temp = []\n    for j in range(m):\n        temp.append([])\n    b.append(temp)\nfor i in range((n + m) // 2):\n    for j in range(min(i + 1, m, n)):\n        if i == 0:\n            b[j][i - j].append(a[j][i - j])\n        elif j == 0:\n            b[j][i - j].append(b[j][i - j - 1][0] ^ a[j][i - j])\n        elif j == i:\n            b[j][i - j].append(b[j - 1][i - j][0] ^ a[j][i - j])\n        else:\n            for x in b[j][i - j - 1] + b[j - 1][i - j]:\n                b[j][i - j].append(x ^ a[j][i - j])\nc = []\nfor i in range(n):\n    temp = []\n    for j in range(m):\n        temp.append([])\n    c.append(temp)\nfor i in range((n + m + 1) // 2):\n    for j in range(min(i + 1, m, n)):\n        if i == 0:\n            c[(n - 1) - j][(m - 1) - (i - j)].append(k)\n        elif j == 0:\n            c[(n - 1) - j][(m - 1) - (i - j)].append(c[(n - 1) - j][(m - 1) - (i - j - 1)][0] ^ a[(n - 1) - j][(m - 1) - (i - j - 1)])\n        elif j == i:\n            c[(n - 1) - j][(m - 1) - (i - j)].append(c[(n - 1) - (j - 1)][(m - 1) - (i - j)][0] ^ a[(n - 1) - (j - 1)][(m - 1) - (i - j)])\n        else:\n            for x in c[(n - 1) - j][(m - 1) - (i - j - 1)]:\n                c[(n - 1) - j][(m - 1) - (i - j)].append(x ^ a[(n - 1) - j][(m - 1) - (i - j - 1)])\n            for x in c[(n - 1) - (j - 1)][(m - 1) - (i - j)]:\n                c[(n - 1) - j][(m - 1) - (i - j)].append(x ^ a[(n - 1) - (j - 1)][(m - 1) - (i - j)])\n\nwae = 0\ni = (n + m) // 2 - 1\nfor j in range(min(m, n)):\n    d = {}\n    e = {}\n    for l1 in b[j][i - j]:\n        if not l1 in d:\n            d[l1] = 0\n        d[l1] += 1\n    for l2 in c[j][i - j]:\n        if not l2 in e:\n            e[l2] = 0\n        e[l2] += 1\n    for key in list(d.keys()):\n        if key in d and key in e:\n            wae += d[key] * e[key]\n\nprint(wae)\n", "import math\nfrom collections import defaultdict\nimport sys\n\n\ndef main():\n    n, m, k = list(map(int, input().split()))\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        g[i] = list(map(int, input().split()))\n\n    cnt = [[defaultdict(int) for _ in range(m)] for _ in range(n)]\n\n    all = n + m - 2\n    half = all // 2\n    res = [0]\n\n    def go_start(x, y, val, steps):\n        val ^= g[x][y]\n        if steps == half:\n            cnt[x][y][val] += 1\n            return\n\n        if x+1 < n:\n            go_start(x + 1, y, val, steps + 1)\n\n        if y+1 < m:\n            go_start(x, y+1, val, steps + 1)\n\n    def go_end(x, y, val, steps):\n        if steps + half == all:\n            comp = k ^ val\n            if comp in cnt[x][y]:\n                res[0] += cnt[x][y][comp]\n            return\n\n        val ^= g[x][y]\n\n        if x > 0:\n            go_end(x-1, y, val, steps + 1)\n        if y > 0:\n            go_end(x, y-1, val, steps + 1)\n\n    go_start(0, 0, 0, 0)\n    go_end(n-1, m-1, 0, 0)\n\n    print(res[0])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n,m,k = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(n)]\n\nif n == 1 and m == 1:\n    if A[0][0] == k:\n        print(1)\n    else:\n        print(0)\n    return\n\nimport itertools\nans = 0\ns = (n-1+m-1)//2\nt = (n-1+m-1)-s\n#print(s, t)\nfrom collections import defaultdict\nDS = [defaultdict(lambda :0) for key in range(n)]\nfor i in range(2**s):\n    L = [0]*s\n    for j in range(s):\n        if (i >> j) & 1:\n            L[j] = 1\n    key = sum(L)\n    if key > n-1:\n        continue\n    y = 0\n    x = 0\n    res = A[0][0]\n    for l in L:\n        if l == 1:\n            y += 1\n        else:\n            x += 1\n        if 0 <= y < n and 0 <= x < m:\n            res ^= A[y][x]\n        else:\n            break\n    else:\n        DS[key][res] += 1\n#print(DS)\nans = 0\nfor i in range(2**t):\n    L = [0]*t\n    for j in range(t):\n        if (i >> j) & 1:\n            L[j] = 1\n    tkey = sum(L)\n    if tkey > n-1:\n        continue\n    y = n-1\n    x = m-1\n    res = A[n-1][m-1]\n    for idx, l in enumerate(L):\n        if idx == len(L)-1:\n            continue\n        if l == 1:\n            y -= 1\n        else:\n            x -= 1\n        if 0 <= y < n and 0 <= x < m:\n            res ^= A[y][x]\n        else:\n            break\n    else:\n        skey = n-1-tkey\n        sres = res^k\n        #print(skey, sres)\n        ans += DS[skey][sres]\nprint(ans)\n"]