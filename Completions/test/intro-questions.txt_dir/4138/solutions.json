["l = [0]\n\ndef count(size):\n    nums = (10**size - 10**(size - 1))\n    small =  l[size-1] + size\n    large = l[size-1] + nums * size\n    if len(l) <= size:\n        l.append(large)\n    return (nums * (small + large))//2\n\ndef test(minSize, size, val):\n    out = minSize * val + size * ((val + 1) * val)//2\n    return out\n\nq = int(input())\nfor _ in range(q):\n    want = int(input())\n\n    size = 1\n    while want > count(size):\n        want -= count(size)\n        size += 1\n\n    minSize = l[size - 1]\n\n    lo = 0 #Impossible\n    hi = (10**size - 10**(size - 1)) #Possible\n\n    while hi - lo > 1:\n        testV = (lo + hi) // 2\n        out = test(minSize, size, testV)\n\n        if out < want:\n            lo = testV\n        else:\n            hi = testV\n\n    want -= test(minSize, size, lo)\n\n    newS = 1\n    while 9 * (10**(newS - 1)) * newS < want:\n        want -= 9 * (10**(newS - 1)) * newS\n        newS += 1\n\n    want -= 1\n\n    more = want//newS\n    dig = want % newS\n    value = 10**(newS - 1) + more\n    print(str(value)[dig])\n\n    \n", "def g(n):\n\ts = str(n)\n\tans = 0\n\tfor i in range(1, len(s)):\n\t\tans += i * 9 * 10**(i - 1)\n\n\treturn n * len(s) - (len(s) * (10**(len(s) - 1) - 1) - ans)\n\ndef sum(i, j):\n\treturn i * (j - i + 1) + (j - i) * (j - i + 1) // 2\n\ndef f(n):\n\tans = (n + 1) * g(n)\n\ts = str(n)\n\tfor i in range(1, len(s)):\n\t\tans -= i * sum(10 ** (i - 1), 10 ** i - 1)\n\tans -= len(s) * sum(10 ** (len(s) - 1), n)\n\treturn ans\n\ndef slow_g(n):\n\ts = \"\"\n\tfor i in range(1, n + 1):\n\t\ts += str(i)\n\n\treturn len(s)\n\ndef slow_f(n):\n\tans = 0\n\tfor i in range(1, n + 1):\n\t\tans += g(i)\n\treturn ans\n\ndef ans(n):\n\tl, r = 0, 10**18\n\twhile l + 1 < r:\n\t\tm = (l + r) // 2\n\t\tif f(m) >= n:\n\t\t\tr = m\n\t\telse:\n\t\t\tl = m\n\n\tn -= f(r - 1)\n\n\tl = 0\n\tr = r\n\twhile l + 1 < r:\n\t\tm = (l + r) // 2\n\t\tif g(m) >= n:\n\t\t\tr = m\n\t\telse:\n\t\t\tl = m\n\tn -= g(r - 1)\n\treturn str(r)[n - 1]\n\nq = int(input())\nfor i in range(q):\n\tn = int(input())\n\tprint(ans(n))\n", "q = int(input())\n\ndef ar(n):\n\treturn n*(n+1)//2\n\ndef sm(a, r, n):\n\treturn a*n+(n-1)*(n)//2*r\n\ndef cale(n):\n\tif n == 0:\n\t\treturn 0\n\treturn cale(n-1) + 9*10**(n-1)*n\n\ndef zaj(n):\n\tpoz = 1\n\twhile True:\n\t\tleft = 1\n\t\tright = 9*10**(poz-1)+1\n\t\twhile left < right:\n\t\t\tmid = (left+right)//2\n\t\t\tcur = cale(poz-1)*mid\n\t\t\tcur += sm(poz, poz, mid)\n\t\t\t# print('mid {} cur {}'.format(mid, cur))\n\t\t\tif cur >= n:\n\t\t\t\tright = mid\n\t\t\telse:\n\t\t\t\tleft = mid+1\n\t\tif left == 9*10**(poz-1)+1:\n\t\t\tleft = 9*10**(poz-1)\n\t\t\tn -= cale(poz-1)*left\n\t\t\tn -= sm(poz, poz, left)\n\t\t\tpoz += 1\n\t\t\tassert n > 0, 'n == 0'\n\t\telse:\n\t\t\tleft -= 1\n\t\t\tn -= cale(poz-1)*left\n\t\t\tn -= sm(poz, poz, left)\n\t\t\tktory = 10**(poz-1)+left\n\t\t\treturn (ktory, n)\n\n\nfor asdsjfhajfhsajf in range(q):\n\tk = int(input())\n\t_, n = zaj(k)\n\tpoz = 1\n\twhile True:\n\t\tleft = 1\n\t\tright = 9*10**(poz-1)+1\n\t\twhile left < right:\n\t\t\tmid = (left+right)//2\n\t\t\tcur = poz*mid\n\t\t\tif cur >= n:\n\t\t\t\tright = mid\n\t\t\telse:\n\t\t\t\tleft = mid+1\n\t\tif left == 9*10**(poz-1)+1:\n\t\t\tleft -= 1\n\t\t\tn -= poz*left\n\t\t\tpoz += 1\n\t\t\tassert n > 0, 'n == 0 down'\n\t\telse:\n\t\t\tleft -= 1\n\t\t\t# print('{} left'.format(left))\n\t\t\tn -= poz*left\n\t\t\tl = str(10**(poz-1)+left)\n\t\t\t# print(str(n) + ' w ' + l)\n\t\t\tprint(l[n-1])\n\t\t\tbreak\n\n", "def isqrt(x):\n    if x < 0:\n        raise ValueError('square root not defined for negative numbers')\n    n = int(x)\n    if n == 0:\n        return 0\n    a, b = divmod(n.bit_length(), 2)\n    x = 2**(a+b)\n    while True:\n        y = (x + n//x)//2\n        if y >= x:\n            return x\n        x = y\np = [0, 45, 9045, 1395495, 189414495, 23939649495, 2893942449495, 339393974949495, 38939394344949495, 1000000000000000001];\nnx = [0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889]\nq = int(input())\nfor ut in range(q):\n    lk = int(input())\n    k = lk\n    idx = 0;\n    for i in range(len(p)-1):\n    \tif (p[i] <= k) and (p[i + 1] > k):\n    \t\tidx = i;\n    idx = idx;\n    k-=1\n    k -= p[idx];\n    a = idx + 1\n    b = 2 * nx[idx] + idx + 1;\n    k = -2 * k;\n    d = isqrt(b*b-4 * a*k);\n    x1 = (-b + d) / (2. * a);\n    x2 = (-b - d) / (2. * a);\n    a1 = int(x1);\n    z = lk - p[idx] - nx[idx] * a1 - (a1 * (a1 + 1) // 2) * (idx + 1);\n    \n    cnt = 0\n    ww = 1\n    pow = 0;\n    pow = 1;\n    while ((cnt + pow * ww) * 9 < z) :\n    \tcnt += pow * ww;\n    \tww+=1\n    \tpow *= 10;\n    \n    sym_cnt = (z - (cnt * 9)) - 1;\n    ok = (pow)+sym_cnt / ww;\n    s = str(ok);\n    if (z < 10):\n        print(z)\n    else:\n        print(s[sym_cnt % ww])", "def isqrt(x):\n    if x < 0:\n        raise ValueError('square root not defined for negative numbers')\n    n = int(x)\n    if n == 0:\n        return 0\n    a, b = divmod(n.bit_length(), 2)\n    x = 2**(a+b)\n    while True:\n        y = (x + n//x)//2\n        if y >= x:\n            return x\n        x = y\np = [0, 45, 9045, 1395495, 189414495, 23939649495, 2893942449495, 339393974949495, 38939394344949495, 1000000000000000001];\nnx = [0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889]\nq = int(input())\nfor ut in range(q):\n    lk = int(input())\n    k = lk\n    idx = 0;\n    for i in range(len(p)-1):\n    \tif (p[i] <= k) and (p[i + 1] > k):\n    \t\tidx = i;\n    idx = idx;\n    k-=1\n    k -= p[idx];\n    a = idx + 1\n    b = 2 * nx[idx] + idx + 1;\n    k = -2 * k;\n    d = isqrt(b*b-4 * a*k);\n    x1 = (-b + d) / (2. * a);\n    x2 = (-b - d) / (2. * a);\n    a1 = int(x1);\n    z = lk - p[idx] - nx[idx] * a1 - (a1 * (a1 + 1) // 2) * (idx + 1);\n    \n    cnt = 0\n    ww = 1\n    pow = 0;\n    pow = 1;\n    while ((cnt + pow * ww) * 9 < z) :\n    \tcnt += pow * ww;\n    \tww+=1\n    \tpow *= 10;\n    \n    sym_cnt = (z - (cnt * 9)) - 1;\n    ok = (pow)+sym_cnt / ww;\n    s = str(ok);\n    if (z < 10):\n        print(z)\n    else:\n        print(s[sym_cnt % ww])", "def isqrt(x):\n    if x < 0:\n        raise ValueError('square root not defined for negative numbers')\n    n = int(x)\n    if n == 0:\n        return 0\n    a, b = divmod(n.bit_length(), 2)\n    x = 2**(a+b)\n    while True:\n        y = (x + n//x)//2\n        if y >= x:\n            return x\n        x = y\np = [0, 45, 9045, 1395495, 189414495, 23939649495, 2893942449495, 339393974949495, 38939394344949495, 1000000000000000001];\nnx = [0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889]\nq = int(input())\nfor ut in range(q):\n    lk = int(input())\n    k = lk\n    idx = 0;\n    for i in range(len(p)-1):\n    \tif (p[i] <= k) and (p[i + 1] > k):\n    \t\tidx = i;\n    idx = idx;\n    k-=1\n    k -= p[idx];\n    a = idx + 1\n    b = 2 * nx[idx] + idx + 1;\n    k = -2 * k;\n    d = isqrt(b*b-4 * a*k);\n    x1 = (-b + d) / (2. * a);\n    x2 = (-b - d) / (2. * a);\n    a1 = int(x1);\n    z = lk - p[idx] - nx[idx] * a1 - (a1 * (a1 + 1) // 2) * (idx + 1);\n    \n    cnt = 0\n    ww = 1\n    pow = 0;\n    pow = 1;\n    while ((cnt + pow * ww) * 9 < z) :\n    \tcnt += pow * ww;\n    \tww+=1\n    \tpow *= 10;\n    \n    sym_cnt = (z - (cnt * 9)) - 1;\n    ok = (pow)+sym_cnt / ww;\n    s = str(ok);\n    if (z < 10):\n        print(z)\n    else:\n        print(s[sym_cnt % ww])", "def l(n): # length of 112123...1234567891011..n\n    s = 0\n    for i in range(20):\n        o = 10**i-1\n        if o > n: break\n        s += (n-o) * (n-o+1) // 2\n    return s\n\ndef bs(k): # binary search n so l(n) < k\n    n = 0\n    for p in range(63,-1,-1):\n        if l(n+2**p) < k: n += 2**p\n    return n\n\ndef num(n): # return s[n-1] where s = '1234567891011..n'\n    if n<10: return n\n    for i in range(1,19):\n        seglen = i * 9 * 10**(i-1) \n        if n <= seglen: return str(10**(i-1) + (n-1)//i)[(n-1)%i]\n        else: n -= seglen\n\nq = int(input())\nfor _ in range(q):\n    k = int(input())\n    print(num(k-l(bs(k))))\n", "\ndef foo(x: int) :\n    if x <= 0 : return 0\n    a = len(str(x))\n    ret = a * (x * x + x) // 2\n\n    t = 1\n    cur, prv = 10, 1\n    while t < a :\n        l = a - t\n\n        freq = cur-prv\n        ret -= l * ( freq * ( (x-prv+1) + (x-(cur-1)+1) ) // 2 )\n\n        cur, prv = 10*cur, 10*prv\n        t += 1\n\n    return ret\n\ndef bar(x: int) :\n    if x <= 0 : return 0\n    a = len(str(x))\n    ret = a * x\n\n    t = 1\n    cur, prv = 10, 1\n    while t < a :\n        l = a - t\n\n        freq = cur-prv\n        ret -= l * freq\n\n        cur, prv = 10*cur, 10*prv\n        t += 1\n\n    return ret\n\ndef solve(k) :\n    lo, hi = 0, k\n    while lo < hi :\n        mid = (lo+1+hi)>>1\n        L = foo(mid)\n        lo, hi = (mid, hi) if L < k else (lo, mid-1)\n\n    L = foo(lo)\n\n    x, y = 0, lo+1\n    while x < y :\n        mid = (x+1+y)>>1\n        T = bar(mid)\n        x, y = (mid, y) if L + T < k else (x, mid-1)\n\n    T = bar(x)\n\n    return str(x+1)[(k-L-T)-1]\n\nq = int(input())\nfor test_case in range(q) :\n    k = int(input())\n    print(solve(k))\n", "def solve(k):\n    s = 0\n    cur = 0\n    j = -1\n    for i in range(1, 19):\n        p = 9*10**(i-1)\n        q = cur*p + i*p*(p+1)//2\n        if k < s+q:\n            j = i\n            break\n        s += q\n        cur += i*p\n        if s > 10**18:\n            break\n    k -= s\n    left = 0; right = 9*10**(j-1)+1\n    while left+1 < right:\n        mid = (left + right) // 2\n        if cur*mid + mid*(mid+1)//2*j <= k:\n            left = mid\n        else:\n            right = mid\n    k -= cur*left + left*(left+1)//2*j\n    i = 1\n    while 1:\n        p = 9*10**(i-1)\n        if k <= i*p:\n            l = k // i\n            v = 10**(i-1) + l\n            return str(v)[k % i]\n        k -= i*p\n        i += 1\nq = int(input())\nfor i in range(q):\n    print(solve(int(input())-1))", "max_d = 18\n\nmax_index = [0] * max_d\nnum_dig_last = [0] * max_d\nnum_dig_all = [0] * max_d\nnum_dig_all_until = [0] * max_d\n\nfor i in range(max_d):\n    max_index[i] = 10**i - 1\n\nfor i in range(1, max_d):\n    n = 9 * 10**(i - 1)\n    num_dig_last[i] = num_dig_last[i - 1] + n * i\n    num_dig_all[i] = (num_dig_last[i - 1] + i + num_dig_last[i]) * n // 2\n    num_dig_all_until[i] = num_dig_all_until[i - 1] + num_dig_all[i]\n\nt = int(input())\nfor z in range(t):\n    k = int(input())\n    for i in range(max_d):\n        if k <= num_dig_all_until[i]:\n            \n            x = num_dig_last[i - 1]\n            p = k - num_dig_all_until[i - 1]\n            # x + i / x + 2i / x + 3i\n            l = 1\n            r = 9 * 10**(i - 1)\n            res = 0\n            while l <= r:\n                curr = (l + r) // 2\n                if p <= curr * x + i * curr * (curr + 1) / 2:\n                    res = curr\n                    r = curr - 1\n                else:\n                    l = curr + 1\n          \n            prev = res - 1\n            \n            q = p - (prev * x + i * prev * (prev + 1) // 2)\n            \n            for j in range(max_d):\n                if q <= num_dig_last[j]:\n                    w = q -  num_dig_last[j - 1]\n                    r = w % j \n                    x = w // j\n                    if r != 0:\n                        x += 1\n                        r -= 1\n                    else:\n                        r = j - 1\n                    number =   10 ** (j - 1)  + x - 1 \n                    print(str(number)[r])\n                    break\n            break\n", "q = int(input())\n\nsum = [0] * 20\ncnt = [0] * 20\n\nfor i in range(1, 20):\n    ct = 9 * (10 ** (i - 1))\n    cnt[i] = cnt[i - 1] + i * ct\n    sum[i] = sum[i - 1] + cnt[i - 1] * ct + i * (1 + ct) * ct // 2\n\n\ndef check(x, k, i):\n    return cnt[i - 1] * x + i * (1 + x) * x // 2 < k\n\n\ndef check2(x, k):\n    # print(x,k)\n    l = 0\n    for i in range(10, -1, -1):\n        if x - 10 ** i >= 0:\n            x -= (10 ** i) - 1\n            l = i + 1\n            break\n\n    return cnt[l - 1] + l * x < k\n\n\ndef cal(x):\n    for i in range(10, -1, -1):\n        if x - 10 ** i >= 0:\n            return i + 1\n    return 1\n\n\ndef rv(x):\n    c = []\n    while x:\n        # print(x)\n        c.append(x % 10)\n        x //= 10\n    c.append(0)\n    c.reverse()\n    # print(c)\n    return c\n\n\nwhile q:\n    k = int(input())\n    i = 10\n    while sum[i] > k:\n        i -= 1\n    k -= sum[i]\n    i += 1\n    # print(\"-1-\", k)\n\n    l = 1\n    r = 10 ** 10\n    while l < r:\n        m = (l + r) // 2\n        if check(m, k, i):\n            l = m + 1\n        else:\n            r = m\n    l -= 1\n    k -= cnt[i - 1] * l + i * (1 + l) * l // 2\n\n    # print(\"-2-\", k, l, i)\n\n    ll = 1\n    rr = 10 ** 10\n\n    while ll < rr:\n        m = (ll + rr) // 2\n        if check2(m, k):\n            ll = m + 1\n        else:\n            rr = m\n    ll -= 1\n    k -= cnt[cal(ll) - 1] + cal(ll) * (ll-10**(cal(ll)-1)+1)\n\n    # print(\"-3-\", k)\n    c = rv(ll + 1)\n    # print(c, ll + 1)\n    print(c[k])\n\n    q -= 1\n", "def init(maxn):\n    Sum = [0] * maxn\n    Single = [0] * maxn\n    for i in range(1, maxn):\n        lens = 10 ** i - 10 ** (i - 1)\n        pre = Single[i - 1]\n        Single[i] = pre + lens * i\n    for i in range(1, maxn):\n        lens = 10 ** i - 10 ** (i - 1)\n        pre = Single[i-1]\n        Sum[i] = (pre + i + pre + lens * i) * lens // 2 + Sum[i - 1]\n    return Sum, Single\n\ndef getAns(n, Sum, Single, maxn):\n    ans = 0\n    minn = n\n    index = 0\n    L, R = 1, 10 ** maxn\n    while L <= R:\n        m = (L + R) // 2\n        digit = len(str(m))\n        lens = m - 10 ** (digit - 1) + 1\n        pre = Single[digit - 1]\n        cnt = (pre + digit + pre + lens * digit) * lens // 2 + Sum[digit - 1]\n        if cnt < n:\n            index = m\n            minn = min(minn, n - cnt)\n            L = m + 1\n        else :\n            R = m - 1\n    #print(index, minn)\n    n = minn\n    L, R = 1, index + 11\n    index = 0\n    while L <= R:\n        m = (L + R) // 2\n        digit = len(str(m)) \n        lens = m - 10 ** (digit - 1) + 1\n        pre = Single[digit - 1]\n        cnt = pre + lens * digit\n        if cnt < n:\n            index = m\n            minn = min(minn, n - cnt)\n            L = m + 1\n        else :\n            R = m - 1\n    return str(index + 1)[minn - 1]\n\ndef test():\n    ans = 0\n    Sum = 0\n    for i in range(1, 1000):\n        ans += len(str(i))\n        Sum += ans\n        if i % 10 == 9:\n            print(i, ans, Sum)\n\n\ndef main():\n    maxn = 10\n    Sum, Single = init(maxn)\n    T = int(input())\n    for i in range(T):\n        n = int(input())\n        print(getAns(n, Sum, Single, maxn))\n\n    \n\ndef __starting_point():\n    main()\n__starting_point()", "import math\n\ndef calc_base(k):\n    base = k\n    for i in range(1, k):\n        base += 9 * i * (10 ** (i - 1))\n    return base\n\ndef global_length(k):\n    base = calc_base(k)\n    d = 10 ** k - 10 ** (k - 1)\n    if d % 2 == 0:\n        return d * base + k * (d - 1) * (d // 2)\n    return d * base + k * (d - 1) // 2 * d\n\ndef global_offset(k):\n    offset = 0\n    for i in range(1, k + 1):\n        offset += global_length(i)\n    return offset\n\ndef local_offset(k, l, base):\n    return l * base + (k * l * (l - 1)) // 2\n\ndef bs_long(n):\n    l, r = -1, 10\n    while r - l > 1:\n        m = (r + l) // 2\n        s = global_offset(m)\n        if n - s <= 0:\n            r = m\n        else:\n            l = m\n    if l < 0:\n        return r\n    return l\n\ndef bs_short(pos, base, k):\n    l, r = -1, 10 ** k - 10 ** (k - 1)\n    while r - l > 1:\n        m = (r + l) // 2\n        lb = local_offset(k, m, base)\n        if pos - lb <= 0:\n            r = m\n        else:\n            l = m\n    return l\n\ndef digit_offset(number):\n    k = int(math.log10(number))\n    res = 0\n    for i in range(k):\n        res += int((i + 1) * 10 ** i)\n    res *= 9\n    res += (number - 10 ** k + 1) * (k + 1)\n    return res - k\n\ndef bs_digit(k, x, base, n):\n    l, r = 0, 10 ** k + x + 1\n    while r - l > 1:\n        m = (r + l) // 2\n        lb = digit_offset(m)\n        if n < lb:\n            r = m\n        else:\n            l = m\n    num = r if l < 1 else l\n    n -= digit_offset(num)\n    s = str(num)\n    return s[n]\n\ndef solve(n):\n    k = bs_long(n)\n    n -= global_offset(k)\n    base = calc_base(k + 1)\n    d = bs_short(n, base, k + 1)\n    n -= local_offset(k + 1, d, base)\n    return bs_digit(k + 1, d, base, n)\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        n = int(input())\n        a = solve(n)\n        print(a)\n\nmain()", "def foo(n):\n    a = []\n    s = []\n    leng = 0\n    last_leng = 0\n    for i in range(1, n + 1):\n        for c in str(i):\n            last_leng += 1\n        leng += last_leng\n    return leng\n\n\ndef small_foo(n):\n    leng = 0\n    for i in range(1, n + 1):\n        leng += len(str(i))\n    return leng\n\n\n\ndef bar(n):\n    total_len = 0\n    for i in range(1, len(str(n))):\n        max_i_digit = 10 ** i - 1\n        i_digit_num = 9 * 10 ** (i - 1)\n        start_count = i_digit_num * (i_digit_num + 1) // 2\n        end_count = i_digit_num * (n - max_i_digit)\n        i_digit_total_len = (start_count + end_count) * i\n        total_len += i_digit_total_len\n    i = len(str(n))\n    i_digit_num = n - (10 ** (i - 1) - 1)\n    start_count = i_digit_num * (i_digit_num + 1) // 2\n    total_len += start_count * i\n    return total_len\n\n\ndef small_bar(n):\n    total_len = 0\n    for i in range(1, len(str(n))):\n        i_digit_num = 9 * 10 ** (i - 1)\n        total_len += i_digit_num * i\n    i = len(str(n))\n    i_digit_num = n - (10 ** (i - 1) - 1)\n    total_len += i_digit_num * i\n    return total_len\n\n\ndef small_solve(x, n):\n    l = 0\n    r = n + 1\n    while r - l > 1:\n        m = (l + r) // 2\n        if small_bar(m) >= x:\n            r = m\n        else:\n            l = m\n    return str(r)[x - small_bar(l) - 1]\n\n\ndef solve(x):\n    l = 0\n    r = 10 ** 9\n    while r - l > 1:\n        m = (l + r) // 2\n        if bar(m) >= x:\n            r = m\n        else:\n            l = m\n    return small_solve(x - bar(l), r)\n\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        x = int(input())\n        print(solve(x))\n\nmain()\n", "def cached(func):\n    _cache = {}\n    def wrapped(*args):\n        nonlocal _cache\n        if args not in _cache:\n            _cache[args] = func(*args)\n        return _cache[args]\n    return wrapped\n\n\ndef len_num(l):\n    \"\"\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0447\u0438\u0441\u0435\u043b \u0434\u043b\u0438\u043d\u044b l\"\"\"\n    return 10**l - 10**(l - 1) if l > 0 else 0\n\n\n@cached\ndef len_sum(l):\n    \"\"\"\u0421\u0443\u043c\u043c\u0430 \u0434\u043b\u0438\u043d \u0432\u0441\u0435\u0445 \u0447\u0438\u0441\u0435\u043b, \u0434\u043b\u0438\u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u0442\u0440\u043e\u0433\u043e \u043c\u0435\u043d\u044c\u0448\u0435 \u0447\u0435\u043c l\"\"\"\n    return len_sum(l - 1) + (len_num(l - 1)) * (l - 1) if l > 1 else 0\n\n\ndef block_len(block_num):\n    \"\"\"\u0414\u043b\u0438\u043d\u0430 \u0431\u043b\u043e\u043a\u0430 (\u0442. \u0435. \u0441\u0442\u0440\u043e\u043a\u0438 '1234567891011...str(block_num)'\"\"\"\n    l = len(str(block_num))\n    return len_sum(l) + (block_num - 10 ** (l - 1) + 1) * l\n\n\ndef arith_sum(n):\n    return n * (n + 1) // 2\n\n\ndef block_len_sum(block_num):\n    \"\"\"\u0421\u0443\u043c\u043c\u0430\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430 \u0432\u0441\u0435\u0445 \u0431\u043b\u043e\u043a\u043e\u0432 \u043f\u043e\u0434\u0440\u044f\u0434 \u0432\u043f\u043b\u043e\u0442\u044c \u0434\u043e \u0431\u043b\u043e\u043a\u0430 block_num\n    \u0415\u0441\u043b\u0438 l = len(str(block_num))\n    \"\"\"\n    l = len(str(block_num))\n    result = 0\n    for i in range(1, l + 1):\n        # \u043f\u0440\u0438\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0443\u043c\u043c\u0430\u0440\u043d\u0443\u044e \u0434\u043b\u0438\u043d\u0443 \u0431\u043b\u043e\u043a\u043e\u0432, \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u044e\u0449\u0438\u0445\u0441\u044f \u043d\u0430 \u0447\u0438\u0441\u043b\u0430 \u0434\u043b\u0438\u043d\u044b i\n        ls = len_sum(i) # \u0434\u043b\u0438\u043d\u0430 \u0431\u043b\u043e\u043a\u0430 \u0434\u043b\u044f \u0447\u0438\u0441\u043b\u0430 10 ** i - 1\n        if i < l:\n            ln = len_num(i)\n        else:\n            ln = block_num - (10 ** (l - 1)) + 1\n        result += ls * ln + i * arith_sum(ln)\n    return result\n\n\ndef block(n):\n    return ''.join(str(i) for i in range(1, n+1))\n\n\ndef blocks(n):\n    return ''.join(block(i) for i in range(1, n + 1))\n\n\ndef binary_search(call, val):\n    start = 1\n    end = 1\n    while call(end) <= val:\n        end *= 2\n    result = start\n    while start <= end:\n        mid = (start + end) // 2\n        if call(mid) <= val:\n            start = mid + 1\n            result = start\n        else:\n            end = mid - 1\n    return result\n\n\ncases = int(input())\nfor _ in range(cases):\n    index = int(input()) - 1\n    block_num = binary_search(block_len_sum, index)\n    rel_index = index - block_len_sum(block_num - 1)\n    number = binary_search(block_len, rel_index)\n    digit = rel_index - block_len(number - 1)\n    print(str(number)[digit])\n", "def cached(func):\n    _cache = {}\n    def wrapped(*args):\n        nonlocal _cache\n        if args not in _cache:\n            _cache[args] = func(*args)\n        return _cache[args]\n    return wrapped\n\n\ndef len_num(l):\n    \"\"\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0447\u0438\u0441\u0435\u043b \u0434\u043b\u0438\u043d\u044b l\"\"\"\n    return 10**l - 10**(l - 1) if l > 0 else 0\n\n\n@cached\ndef len_sum(l):\n    \"\"\"\u0421\u0443\u043c\u043c\u0430 \u0434\u043b\u0438\u043d \u0432\u0441\u0435\u0445 \u0447\u0438\u0441\u0435\u043b, \u0434\u043b\u0438\u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u0442\u0440\u043e\u0433\u043e \u043c\u0435\u043d\u044c\u0448\u0435 \u0447\u0435\u043c l\"\"\"\n    if l <= 1:\n        return 0\n    return len_sum(l - 1) + (len_num(l - 1)) * (l - 1)\n\n\ndef block_len(block_num):\n    \"\"\"\u0414\u043b\u0438\u043d\u0430 \u0431\u043b\u043e\u043a\u0430 (\u0442. \u0435. \u0441\u0442\u0440\u043e\u043a\u0438 '1234567891011...str(block_num)'\"\"\"\n    l = len(str(block_num))\n    return len_sum(l) + (block_num - 10 ** (l - 1) + 1) * l\n\n\ndef arith_sum(n):\n    return n * (n + 1) // 2\n\n\n@cached\ndef block_len_sum_(l):\n    \"\"\"\u0421\u0443\u043c\u043c\u0430\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430 \u0432\u0441\u0435\u0445 \u0431\u043b\u043e\u043a\u043e\u0432 \u0434\u043b\u0438\u043d\u044b \u043c\u0435\u043d\u044c\u0448\u0435\u0439 \u0447\u0435\u043c l\"\"\"\n    if l <= 0:\n        return 0\n    ln = len_num(l - 1)\n    ls = len_sum(l - 1)\n    return block_len_sum_(l - 1) + ls * ln + arith_sum(ln) * (l - 1)\n\n\ndef block_len_sum(block_num):\n    \"\"\"\u0421\u0443\u043c\u043c\u0430\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430 \u0432\u0441\u0435\u0445 \u0431\u043b\u043e\u043a\u043e\u0432 \u043f\u043e\u0434\u0440\u044f\u0434 \u0432\u043f\u043b\u043e\u0442\u044c \u0434\u043e \u0431\u043b\u043e\u043a\u0430 block_num\n    \u0415\u0441\u043b\u0438 l = len(str(block_num))\n    \"\"\"\n    l = len(str(block_num))\n    ls = len_sum(l)\n    ln = block_num - (10 ** (l - 1)) + 1\n    return block_len_sum_(l) + ls * ln + l * arith_sum(ln)\n\n\ndef binary_search(call, val):\n    start = 1\n    end = 1\n    while call(end) <= val:\n        end *= 2\n    result = start\n    while start <= end:\n        mid = (start + end) // 2\n        if call(mid) <= val:\n            start = mid + 1\n            result = start\n        else:\n            end = mid - 1\n    return result\n\n\ncases = int(input())\nfor _ in range(cases):\n    index = int(input()) - 1\n    block_num = binary_search(block_len_sum, index)\n    rel_index = index - block_len_sum(block_num - 1)\n    number = binary_search(block_len, rel_index)\n    digit = rel_index - block_len(number - 1)\n    print(str(number)[digit])\n", "def cached(func):\n    _cache = {}\n    def wrapped(*args):\n        nonlocal _cache\n        if args not in _cache:\n            _cache[args] = func(*args)\n        return _cache[args]\n    return wrapped\n\n\n@cached\ndef num_count_with_len(l):\n    \"\"\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0447\u0438\u0441\u0435\u043b \u0434\u043b\u0438\u043d\u044b l\"\"\"\n    return 10**l - 10**(l - 1) if l > 0 else 0\n\n\n@cached\ndef numbers_len_sum(l):\n    \"\"\"\u0421\u0443\u043c\u043c\u0430 \u0434\u043b\u0438\u043d \u0432\u0441\u0435\u0445 \u0447\u0438\u0441\u0435\u043b \u0441 \u0434\u043b\u0438\u043d\u0430\u043c\u0438 \u043e\u0442 1 \u0434\u043e l \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e\"\"\"\n    if l < 0:\n        return 0\n    return numbers_len_sum(l - 1) + l * num_count_with_len(l)\n\n\ndef block_len(block_num):\n    \"\"\"\u0414\u043b\u0438\u043d\u0430 \u0431\u043b\u043e\u043a\u0430 (\u0442. \u0435. \u0441\u0442\u0440\u043e\u043a\u0438 '1234567891011...str(block_num)'\"\"\"\n    l = len(str(block_num))\n    return numbers_len_sum(l - 1) + (block_num - 10 ** (l - 1) + 1) * l\n\n\ndef arith_sum(n):\n    \"\"\"\u0421\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u0447\u0438\u0441\u0435\u043b \u043e\u0442 1 \u0434\u043e n \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e\"\"\"\n    return n * (n + 1) // 2\n\n\n@cached\ndef block_len_sum_(l):\n    \"\"\"\u0421\u0443\u043c\u043c\u0430\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430 \u0432\u0441\u0435\u0445 \u0431\u043b\u043e\u043a\u043e\u0432 \u0441 \u0434\u043b\u0438\u043d\u043e\u0439 \u043d\u0435 \u043f\u0440\u0435\u0432\u043e\u0441\u0445\u043e\u0434\u044f\u0449\u0435\u0439 l\"\"\"\n    if l <= 0:\n        return 0\n    num_count = num_count_with_len(l)\n    len_sum = numbers_len_sum(l - 1)\n    return block_len_sum_(l - 1) + len_sum * num_count + arith_sum(num_count) * l\n\n\ndef block_len_sum(block_num):\n    \"\"\"\u0421\u0443\u043c\u043c\u0430\u0440\u043d\u0430\u044f \u0434\u043b\u0438\u043d\u0430 \u0432\u0441\u0435\u0445 \u0431\u043b\u043e\u043a\u043e\u0432 \u043f\u043e\u0434\u0440\u044f\u0434 \u0432\u043f\u043b\u043e\u0442\u044c \u0434\u043e \u0431\u043b\u043e\u043a\u0430 block_num \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e\"\"\"\n    l = len(str(block_num))\n    len_sum = numbers_len_sum(l - 1)\n    num_count = block_num - (10 ** (l - 1)) + 1\n    return block_len_sum_(l - 1) + len_sum * num_count + l * arith_sum(num_count)\n\n\ndef binary_search(call, val):\n    start = 0\n    end = 1\n    while call(end) <= val:\n        end *= 2\n    result = start\n    while start <= end:\n        mid = (start + end) // 2\n        if call(mid) <= val:\n            start = mid + 1\n            result = start\n        else:\n            end = mid - 1\n    return result\n\n\ncases = int(input())\nfor _ in range(cases):\n    index = int(input()) - 1\n    block_num = binary_search(block_len_sum, index)\n    rel_index = index - block_len_sum(block_num - 1)\n    number = binary_search(block_len, rel_index)\n    digit = rel_index - block_len(number - 1)\n    print(str(number)[digit])\n", "l = [0]\n\nt = int(input())\ndef count(level):\n    nums = 10**level - 10**(level - 1)\n    first = l[level - 1] + level\n    last = l[level - 1] + nums*level\n    if len(l) <= level:\n        l.append(last)\n    return (nums*(first+last))//2\n\ndef search(min_size,val,level):\n    checker = val*min_size + level*(val*(val + 1))//2\n    return checker\n\nfor _ in range(t):\n    ind = int(input())\n    level = 1\n    while ind > count(level):\n        ind -= count(level)\n        level += 1\n\n    min_size = l[level-1]\n\n    lo = 0\n    hi = 10**level - 10**(level-1)\n\n    while hi - lo > 1:\n        val = (hi+lo)//2\n        checker = search(min_size,val,level)\n        if checker < ind:\n            lo = val\n        else:\n            hi = val\n\n    ind -= search(min_size,lo,level)\n\n    new_l = 1\n    while 9*(10**(new_l-1))*new_l < ind:\n        ind -= 9*(10**(new_l-1))*new_l\n        new_l += 1\n\n    ind -= 1\n\n    more = ind // new_l\n    dig = ind % new_l\n    value = 10 ** (new_l - 1) + more\n    print(str(value)[dig])\n\n", "import math\n\nsum_   = [0] * 18\nbegin_ = [0] * 18\n\ndef f_(x0, k, n):\n    return k*(2*x0 + (k-1)*n) // 2 \n    \ndef make():\n    x0 = 1\n    k   = 9\n    n   = 1\n    \n    while n < 18:\n        begin_[n] = x0\n        last_number = x0 + (k-1)*n\n        sum = k*(2*x0 + (k-1)*n) // 2\n    \n        sum_[n] = sum\n    \n        sum_[n] += sum_[n-1]\n    \n        x0 = last_number + (n+1)\n        k *= 10\n        n += 1 \n    \ndef digit(x):\n    cnt = 0\n    while x > 0:\n        x  //= 10\n        cnt += 1\n    return cnt    \n\ndef f(x, begin_, sum_):\n    n  = digit(x)\n    k  = x - 10**(n-1) + 1  \n    x0 = begin_[n]\n    \n    return sum_[n-1] + f_(x0, k, n)\n\ndef find(s, begin_, sum_):\n    l = 0\n    u = 1000000000\n    \n    while u-l>1:\n        md = (l+u) // 2\n        if f(md,  begin_, sum_) > s:\n            u = md\n        else:\n            l = md\n    \n    # pos, remain\n    return l, s - f(l,  begin_, sum_)  \n\ndef get_digit(x, pos):\n    s = []\n    \n    while x > 0:\n        s.append(x%10)\n        x //= 10\n        \n    return s[::-1][pos]    \n\ndef find_digit(x):\n    pos, remain = find(x, begin_, sum_)\n    \n    if remain == 0:\n        return pos % 10\n    \n    n     = 0\n    next_ = 9 * (10**n) * (n+1)\n    \n    while next_ <= remain:\n        remain -= next_\n   \n        n += 1\n        next_ = 9 * (10**n) * (n+1)\n    \n    if remain == 0:\n        return 9\n    \n    pos_ = 10 ** n + math.ceil(remain / (n+1)) - 1\n    \n    return get_digit(pos_, (remain-1)%(n+1))\n\nmake()\nq = int(input())\n\nfor _ in range(q):\n    n = int(input())\n    print(find_digit(n))", "def digits_until_block_(n):\n    result = 0\n    for bas in range(1, 30):\n        minimum = int(10 ** (bas - 1))\n        maximum = int((10 ** bas) - 1)\n        if n < maximum:\n            maximum = n\n        if maximum < minimum:\n            break\n        result += sum_between(n - maximum + 1, n - minimum + 1) * bas\n    return result\n\n\ndef digits_until_(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return digits_until_block_(n) - digits_until_block_(n - 1)\n\n\ndef sum_between(x, y):\n    try:\n        assert (x <= y)\n    except AssertionError:\n        print(x, y)\n    return ((x + y) * (y - x + 1)) // 2\n\n\ndef solve(q):\n    left = 1\n    right = 10000000000\n    while left < right:\n        mid = (left + right) // 2\n        if digits_until_block_(mid) < q:\n            left = mid + 1\n        else:\n            right = mid\n    q = q - digits_until_block_(left - 1)\n    left = 1\n    right = 10000000000\n    while left < right:\n        mid = (left + right) // 2\n        if digits_until_(mid) < q:\n            left = mid + 1\n        else:\n            right = mid\n    q = q - digits_until_(left - 1)\n    return str(left)[q - 1]\n\n\nq = int(input(\"\"))\nq_list = []\nfor _ in range(q):\n    q_list.append(int(input(\"\")))\nfor query in q_list:\n    print(solve(query))\n", "def sum_first(k):\n    return (k+1)*k//2\n\ndef sum_seq_len(k):\n    res = 0\n    x = 1\n    while k >= x:\n        res += sum_first(k - (x-1))\n        x *= 10\n    return res\n\ndef seq_len(k):\n    res = 0\n    x = 1\n    while k >= x:\n        res += k - (x-1)\n        x *= 10\n    return res\n\ndef brut_ssl(k):\n    res = 0\n    for i in range(1, k+1):\n        for j in range(1, i+1):\n            res += len(str(j))\n    return res\n\ndef brut_sl(k):\n    res = 0\n    for i in range(1, k+1):\n        res += len(str(i))\n    return res\n\ndef binsrch(a, b, x, f):\n    if a == b-1:\n        return a\n    mid = (a+b)//2\n    if f(mid) < x:\n        return binsrch(mid, b, x, f)\n    else:\n        return binsrch(a, mid, x, f)\n\ndef test(x):\n    # number of full sequences\n    pref_seq_cnt = binsrch(0, 100*x, x, sum_seq_len)\n\n    # print(i, x, sum_seq_len(x), sum_seq_len(x+1))\n    # assert sum_seq_len(x) < i <= sum_seq_len(x+1)\n\n    # length of last sequence\n    seq_l = x-sum_seq_len(pref_seq_cnt)\n\n    # biggest complete number in sequence\n    big = binsrch(0, seq_l, seq_l, seq_len)\n    # print(seq_l, big)\n\n    # which digit of big+1 to print out\n    ind = seq_l - seq_len(big)\n    return str(big+1)[ind-1]\n\n\n    # x = seq_len(i)\n    # y = brut_sl(i)\n    # assert x == y\n\n\ndef __starting_point():\n    T = int(input())\n    for _ in range(T):\n        x = int(input())\n        print(test(x))\n\n__starting_point()", "\ndef calc(k):\n    if k is 0:\n        return 0\n    num, ret, pre = len(str(k)), 0, 0\n    for i in range(1, num):\n        cnt = pow(10, i - 1) * 9\n        ret += pre * cnt + i * (1 + cnt) * cnt // 2\n        pre += i * cnt\n    extra = k - pow(10, num - 1) + 1\n    ret += pre * extra\n    ret += num * (1 + extra) * extra // 2\n    return int(ret)\n\n\ndef ds(k):\n    num, _sum = 1, 0\n    while _sum + num * pow(10, num - 1) * 9 < k:\n        _sum += num * pow(10, num - 1) * 9\n        num += 1\n    k -= _sum\n    val = pow(10, num - 1) + k // num\n    if k % num is 0:\n        return (val - 1) % 10\n    k = num - (k % num)\n    for i in range(k):\n        val = val // 10\n    return val % 10\n\n\ndef solve(k):\n    l, r, ans = 0, 1e9 + 7, 0\n    while l <= r:\n        mid = int((l + r) // 2)\n        if calc(mid) >= k:\n            ans, r = mid, mid - 1\n        else:\n            l = mid + 1\n    # print('[log] ans = %d len = %d' % (ans, calc(ans)))\n    k = k - calc(ans - 1)\n    return ds(k)\n\nq = int(input())\n\nfor i in range(q):\n    k = int(input())\n    print(solve(k))\n\n", "\ndef calc(k):\n    num, ret, pre = len(str(k)), 0, 0\n    for i in range(1, num):\n        cnt = pow(10, i - 1) * 9\n        ret += pre * cnt + i * (1 + cnt) * cnt // 2\n        pre += i * cnt\n    extra = k - pow(10, num - 1) + 1\n    ret += pre * extra\n    ret += num * (1 + extra) * extra // 2\n    return int(ret)\n\n\ndef ds(k):\n    num, _sum = 1, 0\n    while _sum + num * pow(10, num - 1) * 9 < k:\n        _sum += num * pow(10, num - 1) * 9\n        num += 1\n    k -= _sum\n    val = pow(10, num - 1) + k // num\n    if k % num is 0:\n        return (val - 1) % 10\n    k = num - (k % num)\n    for i in range(k):\n        val = val // 10\n    return val % 10\n\n\ndef solve(k):\n    l, r, ans = 0, 1e9 + 7, 0\n    while l <= r:\n        mid = int((l + r) // 2)\n        if calc(mid) >= k:\n            ans, r = mid, mid - 1\n        else:\n            l = mid + 1\n    # print('[log] ans = %d len = %d' % (ans, calc(ans)))\n    k = k - calc(ans - 1)\n    return ds(k)\n\nq = int(input())\n\nfor i in range(q):\n    k = int(input())\n    print(solve(k))\n\n", "from functools import *\n\ndef sumnum(start, end):\n    # ex end\n    # inc start\n    return end*(end-1)//2 -start*(start-1)//2\n\ndef digits(i):\n    return len(f\"{i}\")\n\n@lru_cache(maxsize=32)\ndef digit_count(i):\n    if i==0:\n        return 0\n    d = digits(i)\n    base = 10**(d-1)-1\n    return digit_count(base) + d*(i-base)\n\n@lru_cache(maxsize=32)\ndef cumulative_digit_count(i):\n    if i==0:\n        return 0\n    d = digits(i);\n    base = 10**(d-1)-1\n    return cumulative_digit_count(base) + digit_count(base)*(i-base) + d*sumnum(base+1, i+1) - d*(base)*(i-base)\n\ndef bin_search(k, f):\n    for d in range(1,20):\n        if f(10**(d-1)-1) > k:\n            break\n    upper = 10**(d-1)-1\n    lower = 10**(d-2)-1\n    while upper-lower > 1:\n        middle = (lower+upper)//2;\n        if f(middle) > k:\n            upper = middle\n        else:\n            lower = middle\n    return lower, k-f(lower)\n\ndef answer(q):\n    lower1, k = bin_search(q, cumulative_digit_count)\n    if k==0:\n        return lower1 % 10\n    lower2, l = bin_search(k, digit_count)\n    if l==0:\n        return lower2 % 10\n    return int(f\"{lower2 + 1}\"[l-1])\n\ndef naive_cum(i):\n    cum = 0\n    for ii in range(1, i+1):\n        for j in range(1, ii+1):\n            cum = cum + len(f\"{j}\")\n    return cum\n    # print(\"cum\", cum)\n\n\na = input()\nfor i in range(int(a)):\n    q=input()\n    print(answer(int(q)))\n"]