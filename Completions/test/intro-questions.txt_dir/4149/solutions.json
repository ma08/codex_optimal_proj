["#!/usr/bin/env python\nfrom collections import Counter\nfrom math import sqrt\nm = 2750131 + 100\n\nf = list(range(m))\n\nfor d in range(2, int(sqrt(m)) + 10):\n    if f[d] == d:\n        i, k = 2, d << 1\n        while k < m:\n            if f[k] == k:\n                f[k] = i\n            k += d\n            i += 1\n\nnp = list(range(m))\nc = 1\nfor i in range(2, m):\n    if f[i] == i:\n        np[i] = c\n        c += 1\n\nn = int(input())\nb = sorted(list(map(int, input().split())), reverse=True)\nd = Counter(b)\na = []\ni, la = 0, 0\nwhile la < n:\n    if d[b[i]] > 0:\n        la += 1\n        if f[b[i]] == b[i]:\n            a.append(np[b[i]])\n            d[b[i]] -= 1\n            d[np[b[i]]] -= 1\n        else:\n            a.append(b[i])\n            d[b[i]] -= 1\n            d[f[b[i]]] -= 1\n    i += 1\nprint(*a)\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nB=list(map(int,input().split()))\n\nfrom collections import Counter\n\nC=Counter(B)\nCKEY=sorted(list(C.keys()),reverse=True)\n\nimport math\n\nx=2750131\n\nL=math.floor(math.sqrt(x))#\u5e73\u65b9\u6839\u3092\u6c42\u3081\u308b\n\nPrimelist=[i for i in range(x+1)]\nPrimelist[1]=0#1\u306f\u7d20\u6570\u3067\u306a\u3044\u306e\u30670\u306b\u3059\u308b.\n \nfor i in Primelist:\n    if i>L:\n        break\n    if i==0:\n        continue\n    for j in range(2*i,x+1,i):\n        Primelist[j]=0\n\nPrimes=[Primelist[j] for j in range(x+1) if Primelist[j]!=0]\nDICT={Primes[i]:i+1 for i in range(199999)}\n\nANS=[]\nfor k in CKEY:\n    \n    while C[k]>0:\n        if k in DICT:\n            x=DICT[k]\n            ANS.append(x)\n            C[k]-=1\n            C[x]-=1\n\n        else:\n            for p in Primes:\n                if k%p==0:\n                    C[k]-=1\n                    C[k//p]-=1\n                    ANS.append(k)\n                    break\n\nprint(*ANS)\n\n", "from collections import Counter\ndef rwh_primes(n):\n    sieve = [True] * n\n    for i in range(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)//(2*i)+1)\n    return [2] + [i for i in range(3,n,2) if sieve[i]]\n\nprimes = rwh_primes(2750132)\nsprimes = set(primes)\n\ndef dl(x):\n  if x in sprimes:\n    return None\n  for p in primes:\n    if x % p == 0:\n      return x // p\n    elif p * p > x:\n      return None\n\nn = int(input())\na = sorted(map(int, input().split()), reverse = True)\nsa = set(a)\nr = []\nx = Counter()\np1 = []\np2 = []\nfor v in a:\n  if v in x and x[v] > 0:\n    x[v] -= 1\n    continue\n  d = dl(v)\n  if d and d in sa:\n    x[d] += 1\n    r.append(v)\n  elif v in sprimes:\n    p1.append(v)\n  else:\n    p2.append(v)\nx = Counter()\ny = 0\nfor v in reversed(p1):\n  if v in x and x[v] > 0:\n    x[v] -= 1\n    continue\n  r.append(v)\n  if v < len(primes)+1:\n    x[primes[v-1]] += 1\n  else:\n    y += 1\nz = (len(p2) - y)//2\nr.extend(p2[::-1][y:y+z])\nprint(*r)\n\n", "import math\n\nn = int(input())\nb = list(map(int, input().split()))\n\nN = 2750131\nprimes = {}\nfor i in range(2, N + 1):\n    primes[i] = True\n\nfor i in range(2, math.floor(math.sqrt(N)) + 1):\n    if primes[i]:\n        for j in range(i * i, N + 1, i):\n            primes[j] = False\n\nnth_prime = []\nfor i in range(2, N + 1):\n    if primes[i]:\n        nth_prime.append(i)\n\nlen_nth = len(nth_prime)\n\nprimes_in_b = {}\nnon_primes_in_b = {}\ndivisors = {}\nfor number in b:\n    if primes[number]:\n        primes_in_b[number] = primes_in_b.get(number, 0) + 1\n    else:\n        non_primes_in_b[number] = non_primes_in_b.get(number, 0) + 1\n        if divisors.get(number, 0) == 0:\n            for prime in nth_prime:\n                if number % prime == 0:\n                    divisors[number] = number // prime\n                    break\n\nfor number in sorted(non_primes_in_b.keys(), reverse=True):\n    if primes[divisors[number]]:\n        for i in range(non_primes_in_b[number]):\n            primes_in_b[divisors[number]] -= 1\n    else:\n        for i in range(non_primes_in_b[number]):\n            non_primes_in_b[divisors[number]] -= 1\n\nfor number in sorted(primes_in_b.keys()):\n    for i in range(primes_in_b[number]):\n        primes_in_b[nth_prime[number - 1]] -= 1\n\nresult = []\nfor number in primes_in_b:\n    for i in range(primes_in_b[number]):\n        result.append(number)\nfor number in non_primes_in_b:\n    for i in range(non_primes_in_b[number]):\n        result.append(number)\nprint(*result, sep=\" \")\n", "# @author \n\nimport sys\n\n\nclass DRecoverIt:\n    def gd(selfs, x):\n        for i in range(2, int(x ** .5) + 1):\n            if x % i == 0:\n                return x // i\n\n    def sieve(self, prime):\n        for i in range(2, int(len(prime) ** .5) + 1):\n            if not prime[i]: continue\n            m = 2\n            while m * i < len(prime):\n                prime[m * i] = False\n                m += 1\n\n        return prime\n\n    def solve(self):\n        is_prime = [True] * 2750135\n        is_prime[0] = False\n        is_prime[1] = False\n        self.sieve(is_prime)\n        p = [-1]\n        for i in range(len(is_prime)):\n            if is_prime[i]:\n                p.append(i)\n\n        n = int(input())\n        b = [int(item) for item in input().split()]\n        b.sort(reverse=True)\n        cnt = {x : 0 for x in b}\n        for x in b:\n            cnt[x] += 1\n\n        p_order = {}\n        for i in range(1, len(p)):\n            p_order[p[i]] = i\n\n        res = []\n        # print(p[:10])\n        for i in range(2 * n):\n            if cnt[b[i]] == 0:\n                continue\n            if is_prime[b[i]]:\n                # print(b[i], cnt[b[i]], res)\n                if b[i] < len(p) and p[b[i]] in cnt and cnt[p[b[i]]] > 0:\n                    # print(p[b[i]], \"*\")\n                    res.append(b[i])\n                    cnt[p[b[i]]] -= 1\n                    cnt[b[i]] -= 1\n                elif p_order[b[i]] in cnt and cnt[p_order[b[i]]] > 0:\n                    # print(p_order[b[i]])\n                    res.append(p_order[b[i]])\n                    cnt[p_order[b[i]]] -= 1\n                    cnt[b[i]] -= 1\n            else:\n                d = self.gd(b[i])\n                assert(d in cnt)\n                res.append(b[i])\n                cnt[b[i]] -= 1\n                cnt[d] -= 1\n\n        print(*res)\n\n\n\nsolver = DRecoverIt()\ninput = sys.stdin.readline\n\nsolver.solve()\n", "from collections import defaultdict\npr = defaultdict(int)\nN = 2750132 \nd = [0]*N\nk = 1\nfor i in range(2,N):\n    if d[i]==0:\n        d[i] = 1\n        pr[i] = k\n        k+=1\n        for j in range(i*i,N,i):\n            if d[j]==0:\n                d[j] = max(i,j//i)\n\nc = [0]*(N)\nn = int(input())\na = list(map(int,input().split()))\nfor i in a:\n    c[i]+=1\n    \nans = []\n\n\nfor i in range(N-1,2,-1):\n    if c[i]>0:\n        if pr[i]==0:\n            t = d[i]\n            for j in range(c[i]):\n                ans.append(i)\n            c[t]-=c[i]\n        else:\n            k = pr[i]\n            for j in range(c[i]):\n                ans.append(k)\n            c[k]-=c[i]\n\nprint(*ans)\n", "import collections,math\n\nn=int(input())\na=list(map(int, input().split()))\na.sort(reverse=True)\nprimes_arr=[-1]\nmaxi = 2750131+1\nprimes_sieve=[0 for _ in range(maxi)]\ndef sieve():\n    for i in range(2, maxi):\n        if not primes_sieve[i]:\n            primes_arr.append(i)\n            primes_sieve[i] = 1\n            for j in range(i*i, maxi, i):\n                if not primes_sieve[j]:\n                    primes_sieve[j] = i\n\nsieve()\n# print(primes_sieve[:20])\nd=collections.defaultdict(int)\nz=collections.defaultdict(int)\n\nans=[]\nprimes = []\nfor i in range(n*2):\n    x=a[i]//primes_sieve[a[i]]\n    if d[a[i]] > 0:\n        d[a[i]]-=1\n    elif x!=a[i]:\n        d[x]+=1\n        ans.append(a[i])\n    else:\n        primes.append(a[i])\nprimes=primes[::-1]\nfor i in range(len(primes)):\n    if z[primes[i]]>0:\n        z[primes[i]]-=1\n    else:\n        z[primes_arr[primes[i]]]+=1\n        ans.append(primes[i])\n\nprint(*ans)", "a = [0]*2750132\nb = [0]*2750132\nfor i in range(2, 2750132):\n    if a[i] == 0:\n        for j in range(i * i, 2750132, i):\n            if a[j] == 0:\n                a[j] = i\nind = 1\nfor i in range(2, 2750132):\n    if a[i] == 0:\n        b[i] = ind\n        ind += 1\n\nn = int(input())\nz = sorted(map(int, input().split()))\nd = dict()\nfor x in z[::-1]:\n    if d.get(x, 0) == 0:\n        if a[x] == 0:\n            print(b[x], end=' ')\n            d[b[x]] = d.get(b[x], 0) + 1\n        else:\n            print(x, end=' ')\n            d[x//a[x]] = d.get(x//a[x], 0) + 1\n    else:\n        d[x] = d.get(x,0) - 1", "\n# -*- coding: utf-8 -*-\n# @Date    : 2019-06-07 20:26:19\n# @Author  : raj lath (oorja.halt@gmail.com)\n# @Link    : link\n# @Version : 1.0.0\n\nimport sys\nsys.setrecursionlimit(10**5+1)\n\ninf     =  int(10 ** 20)\nmax_val =  inf\nmin_val = -inf\n\nRW  = lambda : sys.stdin.readline().strip()\nRI  = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\n\nLIMIT = 2750132\nprimes = [0] * LIMIT\npindex = [0] * LIMIT\n\nindex = 1\nfor i in range(2, LIMIT):\n    if primes[i] == 0:\n        pindex[i] = index\n        index += 1\n        for j in range(i*i, LIMIT, i):\n            if primes[j] == 0:\n                primes[j] = i\n\nlens = RI()\narrs = sorted(RMI())[::-1]\nd = dict()\nfor x in arrs:\n    if d.get(x, 0) == 0:\n        if primes[x] == 0:\n            print(pindex[x], end = \" \")\n            d[pindex[x]] = d.get(pindex[x], 0) + 1\n        else:\n            print(x, end = \" \")\n            d[x//primes[x]] = d.get(x//primes[x], 0) + 1\n    else:\n        d[x] = d.get(x, 0) - 1\n\n\n\n", "import sys\ninput = sys.stdin.readline\nn = int(input())\na = [int(x) for x in input().strip().split()]\ndic = {}\nfor e in a:\n    if e not in dic:\n        dic[e]=0\n    dic[e]+=1\n\ndef primes_method5(n):\n    out = list()\n    sieve = [True] * (n+1)\n    for p in range(2, n+1):\n        if (sieve[p]):\n            out.append(p)\n            for i in range(p, n+1, p):\n                sieve[i] = False\n    return out\n\nprime = primes_method5(2750132)\nprime_set = set(prime)\narr_prime = []\nres = []\nfor e in a:\n    if e in prime_set:\n        arr_prime.append(e)\n    else:\n        res.append(e)\nans = []\narr_prime.sort()\narr_primeset = set(arr_prime)\nres.sort(reverse=True)\nres_set = set(res)\nfor r in res:\n    if dic[r]>0:\n        for p in prime:\n            if r%p==0:\n                div = r//p\n                if div in dic:\n                    dic[div]-=1\n                    dic[r]-=1\n                    ans.append(r)\n                else:\n                    pass\n                break\n\nfor x in arr_prime:\n    if dic[x]>0:\n        if prime[x-1] in arr_primeset and dic[prime[x-1]]>0:\n            ans.append(x)\n            dic[x]-=1\n            dic[prime[x-1]]-=1\n\nprint(*ans)", "from collections import Counter\nse=set()\nodd=dict()\nmapi=dict()\ndef seive(n):\n    nonlocal odd\n    nonlocal se\n    nonlocal mapi\n    prime=[True for i in range(n+1)]\n    p=2\n    while(p*p<=n):\n        if prime[p]:\n            for i in range(2*p,n+1,p):\n                prime[i]=False\n                if i%2==1:\n                    if i not in odd:\n                        odd[i]=i//p\n        p+=1\n    new=[0]\n    count=0\n    for i in range(2,n+1):\n        if prime[i]:\n            new.append(i)\n            se.add(i)\n            mapi[i]=count\n            count+=1\n    return new\ndef largest(k):\n    for i in range(k//2,1,-1):\n        if k%i==0:\n            return i\n    \n\nmain=seive(2750131)\nn=int(input())\nl=list(map(int,input().split()))\nl.sort(reverse=True)\nd=dict(Counter(l))\nw=set(l)\n#k=[0]*2*n\nans=[]\n\nfor i in range(2*n):\n    if l[i] in se and d[l[i]]!=0:\n        val=mapi[l[i]]+1\n        #print(val)\n        #print(val)\n        if val in w and d[val]!=0 and val!=1:\n            ans.append(val)\n            d[val]-=1\n            d[l[i]]-=1\n    elif d[l[i]]!=0:\n        if l[i]%2==0:\n            val=l[i]//2\n            if d[val]!=0 and val in w:\n                ans.append(l[i])\n                d[val]-=1\n                d[l[i]]-=1\n        else:\n            val=odd[l[i]]\n            if d[val]!=0 and val in w:\n                ans.append(l[i])\n                d[val]-=1\n                d[l[i]]-=1\nprint(*ans)\n            \n        \n    \n          \n\n\n\n\n\n        \n        \n        \n        \n        \n    \n    \n    \n", "import sys\nlimit =2750132\n# limit = 20\nmark = [1 for _ in range (limit)]\nmember = [0 for _ in range(limit)]\nm = [0 for _ in range (limit+1)]\nprime = []\nans = []\nn =2\nprimeSet = set()\nmem = {}\nnum = int(input())\ndic = {}\ndic2 = {}\na = list(map(int,sys.stdin.readline().split()))\narr1 =[]\narr2 = []\nfor v in a:\n    member[v]+=1\ndef seive(l):\n    nonlocal n\n    while(n*n<=l):\n        if mark[n]==1:\n            next = n*2\n            c = 2\n            # prime.append(n)\n            primeSet.add(n)\n            while(next<l):\n                mark[next]=0\n                next+=n\n                c+=1\n        n+=1\nseive(limit)\n# print(member[:22])\nfor i in range(2,limit):\n    if mark[i]==1:\n        prime.append(i)\n        primeSet.add(i)\nfor i in range(17984):\n    # idex = prime[prime[i]-1]\n    dic[str(prime[i])]= prime[prime[i]-1]\n    dic[str(prime[prime[i]-1])] = prime[i]\n# print('Primeset',primeSet)\nfor v in a:\n    next = str(v)\n    if v not in primeSet:\n        # print('No', v)\n        for i in range(2, limit):\n            if v % i == 0:\n                need = v // i\n                m[need] += 1;\n                dic2[next] = need\n                arr2.append(v)\n                break\n    else:\n        m[dic.get(next)]+=1\n        arr1.append(v)\n# for v in a:\n#     if v in primeSet :\n#         arr2.append(v)\n#     else:\n#         arr1.append(v)\narr1 = sorted(arr1,reverse=True)\narr2 =  sorted(arr2,reverse=True)\n# print(arr1)\n# print(arr2)\nfor v in arr2:\n    if member[v]:\n        remove = dic2.get(str(v))\n        if member[remove]:\n            ans.append(v)\n            member[remove] -= 1\n            member[v] -= 1\nfor v in arr1:\n    if member[v]:\n        remove =dic.get(str(v))\n        if member[remove]:\n            ans.append(min(remove,v))\n            member[remove] -= 1\n            member[v] -= 1\n# print(m)\nif len(ans)!=num:\n    raise Exception('Not enough member')\nelse:\n    print(*ans)\n# print(ans)\n# print(member[:22])\n# print('Dic:',dic)\n# print('dic2',dic2)\n\n\n\n\n", "\nfrom collections import Counter\n\nlim = 2750131 + 10# 2 * 10**6 + 2\n\n\ndef erato():\n    arr = [None] * lim\n    arr[1] = 1\n    primes = [1]\n    for i in range(2, lim):\n        if not arr[i]:\n            primes.append(i)\n            arr[i] = 1\n            for j in range(i * 2, lim, i):\n                if not arr[j]:\n                    arr[j] = j // i\n\n    s = set(primes)\n    for i in range(1, len(primes)):\n        if i in s:\n            arr[i] = primes[i]\n    return arr\n\n\ndef __starting_point():\n    n = int(input())\n    bb = list(map(int, input().split()))\n    bb.sort(reverse=True)\n    cnt = Counter(bb)\n    e = erato()\n    res = []\n    for b in bb:\n        if cnt[e[b]] > 0 and cnt[b] > 0:\n            res.append(str(b))\n            cnt.subtract({b:1, e[b]:1})\n\n\n    # res = list(map(lambda x: str(e[x]), bb))\n    print(\" \".join(res))\n__starting_point()", "# cook your dish here\nfrom collections import defaultdict\npr = defaultdict(int)\nN=2750132\nd=[0]*N\nk=1\nfor i in range(2,N):\n    if d[i]==0:\n        pr[i]=k\n        k=k+1\n        d[i]=1\n        for j in range(i*i,N,i):\n            if d[j]==0:\n                d[j]=j//i\n        \nn=int(input())\nb=list(map(int,input().split()))\n\nc=[0]*N\nfor j in b:\n    c[j]+=1\n\na=[]\nfor i in range(N-1,2,-1):\n    if c[i]>0:\n        for k in range(c[i]):\n            if d[i]==1:\n                t=pr[i]\n                a.append(t)\n                c[t]-=1\n            else:\n                a.append(i)\n                #print(d[i],c[i],i)\n                c[d[i]]-=1\n    \nprint(*a)\n            \n        \n        \n        \n        \n", "import math\nfrom bisect import bisect_left\n\ndef sieve(n):\n    isPrimeList = [True] * (n+1)\n    isPrimeList[0] = False\n    isPrimeList[1] = False\n\n    for i in range(2, int(math.sqrt(n))):\n        if isPrimeList[i]:\n            for j in range(i*2, n, i):\n                isPrimeList[j] = False\n\n    return isPrimeList\n\n\nprimes = sieve(3 * 10**6)\np = []\nfor i in range(3 * 10**6+1):\n    if primes[i]:\n        p.append(i)\n\nn = int(input())\nb = list(map(int, input().split()))\ntrihard = [0] * 3000001\nfor i in b:\n    trihard[i] = trihard[i] + 1\nmoveCount = 0\na = []\nfor i in range(3000000, -1, -1):\n    while trihard[i]:\n        if primes[i]:\n            pos = bisect_left(p, i)\n            a.append(str(pos+1))\n            trihard[i] -= 1\n            trihard[pos+1] -= 1\n        else:\n            for j in p:\n                if i % j == 0:\n                    a.append(str(i))\n                    trihard[i] -= 1\n                    trihard[i//j] -= 1\n                    break\nprint(\" \".join(a))\n\n", "n = int(input())\nb = list(map(int,input().split(' ')))\n\nprimes={}\n# p=[2]\nindex=2\nprimes[2]=1\n\nfor i in range(4,2750132,2):\n\tprimes[i] = -2\n\nfor i in range(3,2750132,2):\n\tif primes.get(i) is None:\n\t\t# p.append(i)\n\t\tmultiple=i*i\n\t\tprimes[i]=index\n\t\tindex+=1\n\t\twhile multiple < 2750132:\n\t\t\tif primes.get(multiple) is None:\n\t\t\t\tprimes[multiple] = -i\n\t\t\tmultiple+=i\n\n# print(len(p))\nb.sort(reverse=True)\n\ncarr={}\nfor c in b:\n\tif carr.get(c) is None:\n\t\tcarr[c]=1\n\telse:\n\t\tcarr[c]+=1\n\n# print(b)\nk=0\nfor c in b:\n\tif k==n:\n\t\tbreak\n\tif carr[c]>0:\n\t\tif primes[c]>0:\n\t\t\tprint(primes[c],end=' ')\n\t\t\tcarr[c]-=1\n\t\t\tcarr[primes[c]]-=1\n\t\telse:\n\t\t\tprint(c,end=' ')\n\t\t\tcarr[c]-=1\n\t\t\tcarr[c // (-1*primes[c])]-=1\n\t\tk+=1", "a = [0]*2750132\nb = [0]*2750132\nfor i in range(2, 2750132):\n    if a[i] == 0:\n        for j in range(i * i, 2750132, i):\n            if a[j] == 0:\n                a[j] = i\nind = 1\nfor i in range(2, 2750132):\n    if a[i] == 0:\n        b[i] = ind\n        ind += 1\n\nn = int(input())\nz = sorted(map(int, input().split()))\nd = dict()\nfor x in z[::-1]:\n    if d.get(x, 0) == 0:\n        if a[x] == 0:\n            print(b[x], end=' ')\n            d[b[x]] = d.get(b[x], 0) + 1\n        else:\n            print(x, end=' ')\n            d[x//a[x]] = d.get(x//a[x], 0) + 1\n    else:\n        d[x] = d.get(x,0) - 1", "import sys\nfrom collections import Counter\nfrom bisect import bisect_left\ndef Sieve(l):   # Check if can be modified for primeNUmbers at prime places\n    #l=3 * 1000 * 1000 + 13\n    primes=[0]*2+[1]*l\n    for i in range(l):\n        if primes[i]:\n            for j in range(i*i,l,i):\n                primes[j]=0\n    primes=[k for k in range(l) if primes[k]]\n    return primes\n#print(Sieve(10))\ndef index(a, x):\n    i = bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError\nn=int(input())\na=sorted(list(map(int,sys.stdin.readline().split())))\nb=Counter(a)\nactual=Counter()\nl=-1\nprime=Sieve(a[-1]+1)\nwhile l!=-2*n:\n    #print(a)\n    mx=a[l]\n    #print(mx,l)\n    if b[mx]>0:\n        try:\n            second=index(prime,mx)+1\n            actual[second]=actual[second]+b[mx]\n            #print(\"prime:\",mx,second,l)\n        except:\n            i=0\n            while mx%prime[i]!=0:\n                i=i+1\n            second=mx//prime[i]\n            actual[mx]=actual[mx]+b[mx]\n            #print(\"Mx will be added:\",mx,second,l)\n        l=l-b[mx]\n        b[second]=b[second]-b[mx]\n        b[mx]=0\n    else:\n        l=l-1\n#second=index(prime,a[-1])+1\n#print(actual)\nprint(*actual.elements(), sep =' ')\n", "n = int(input())\nt = list(map(int, input().split()))\nn = 2*n\nM = 2750131 + 10\nd = [0]*M\nnr = [0]*M\nakt_nr = 1\n\nfor i in range(2, M):\n\tif d[i] == 0:\n\t\td[i] = 1\n\t\tnr[i] = akt_nr\n\t\takt_nr += 1\n\t\tfor j in range(i*i, M, i):\n\t\t\tif d[j] == 0:\n\t\t\t\td[j] = j//i\n\t\t\t\ncount = [0]*M\nnumbers = []\nfor x in t:\n\tif count[x] == 0:\n\t\tnumbers.append(x)\n\tcount[x] += 1\nnumbers.sort()\nans = []\nfor i in range(len(numbers)-1, 0, -1):\n\tx = numbers[i]\n\t#print(x)\n\twhile count[x] > 0:\n\t\tcount[x] -= 1\n\t\tif d[x] == 1:\n\t\t\tans.append(nr[x])\n\t\t\tcount[nr[x]] -= 1\n\t\t\t#print(nr[x])\n\t\telse:\n\t\t\tans.append(x)\n\t\t\tcount[d[x]] -= 1\n\t\t\t#print(d[x])\n\t\t\t\nprint(*ans)\n\n", "import math\nimport sys\n\nMAXP = 2750131\nMAXPN = 199999\nisPrime = [True]*(MAXP+1)\nprimeDict = {}\ncountNum = {}\nSPF = {}\n\ndef initPrime(pC):\n    isPrime[0]=isPrime[1]=False\n    for i in range(2,MAXP+1):\n        if(isPrime[i]): \n            primeDict[i]=pC\n            pC+=1\n            for j in range(i**2,MAXP+1,i):\n                isPrime[j]=False\n                if j not in SPF:\n                    SPF[j]=i\n\nn = int(input())\nb = [int(x) for x in input().split()]\nb.sort(reverse=True)\ninitPrime(1)\na = list()\n\nfor i in b:\n    countNum[i] = countNum.get(i,0)+1\n\nfor i in b:\n    if(isPrime[i]):\n        if(countNum[i]>0):\n            countNum[primeDict[i]]-=1\n            countNum[i]-=1\n            a.append(primeDict[i])\n    else:\n        if(countNum[i]>0):\n            countNum[i/SPF[i]]-=1\n            countNum[i]-=1\n            a.append(i)\n                \nfor i in a:\n    print(i,end=' ')"]