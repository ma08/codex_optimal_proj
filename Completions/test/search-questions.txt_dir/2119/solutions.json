["def kmp(pat,text,t):\n    s=pat+\"?\"+text;\n    #z[i] es el tama\u00f1o del prefijo mas largo de, formado por una subcadena s[i:...]\n    z=[0 for i in range(len(s))]\n    L=0;R=0;n=len(s);\n    for i in range(1,len(s)):\n        if i>R:\n            L=R=i\n            while R<n and s[R-L]==s[R]:\n                R+=1\n            z[i]=R-L\n            R-=1\n        elif z[i-L]+i<=R:\n            z[i]=z[i-L]\n        else:\n            L=i\n            while R<n and s[R-L]==s[R]:\n                R+=1\n            z[i]=R-L\n            R-=1\n    for i in range(len(pat)+1,len(z)):\n        dp[t][i-(len(pat)+1)]=z[i]%len(pat)\nfrom sys import stdin\nmod=998244353\na=stdin.readline().strip()\nl=stdin.readline().strip()\nr=stdin.readline().strip()\nx=len(l)\ny=len(r)\nn=len(a)\ndp=[[0 for i in range(len(a))]for j in range(2)]\nans=[0 for i in range(len(a)+1)]\nans[-1]=1\nkmp(l,a,0)\nkmp(r,a,1)\nauxl=x-1\nauxr=y-1\nacum=[0 for i in range(n+2)]\nacum[n]=1\nfor i in range(n-1,-1,-1):\n    if a[i]==\"0\":\n        if l[0]==\"0\":\n            ans[i]=ans[i+1]\n        acum[i]=(acum[i+1]+ans[i])%mod\n        continue\n    if auxl>=n:\n        acum[i]=(acum[i+1]+ans[i])%mod\n        continue\n    if auxl!=auxr:\n        if (auxl+i)<n and a[dp[0][i]+i]>=l[dp[0][i]]:\n            ans[i]=(ans[i]+ans[i+auxl+1])%mod\n        if (auxr+i)<n and a[dp[1][i]+i]<=r[dp[1][i]]:\n            ans[i]=(ans[i]+ans[i+auxr+1])%mod\n    else:\n        if (auxl+i)<n and a[dp[0][i]+i]>=l[dp[0][i]] and a[dp[1][i]+i]<=r[dp[1][i]]:\n            ans[i]=(ans[i]+ans[i+auxl+1])%mod\n    lim1=auxl+i+2\n    lim2=min(auxr+i+1,n+1)\n    if lim1<lim2:\n        ans[i]=(ans[i]+acum[lim1]-acum[lim2])%mod\n    acum[i]=(acum[i+1]+ans[i])%mod\nprint(ans[0]%mod)\n"]