["from sys  import stdin,stdout\r\nfrom collections import deque \r\nst=lambda:list(stdin.readline().strip())\r\nli=lambda:list(map(int,stdin.readline().split()))\r\nmp=lambda:list(map(int,stdin.readline().split()))\r\ninp=lambda:int(stdin.readline())\r\npr=lambda n: stdout.write(str(n)+\"\\n\")\r\n\r\nmod=1000000007\r\nINF=float('inf')\r\n\r\ndef solve():\r\n    n,m=mp()\r\n    d={i:[] for i in range(n+1)}\r\n    for i in range(m):\r\n        a,b=mp()\r\n        d[a].append(b)\r\n        d[b].append(a)\r\n    x,y=mp()\r\n    v=[False for i in range(n+1)]\r\n    q=deque()\r\n    q.append(x)\r\n    dis=[INF for i in range(n+1)]\r\n    dis[x]=0\r\n    v[x]=True\r\n    while q:\r\n        a=q.popleft()\r\n        for i in d[a]:\r\n            if not v[i]:\r\n                v[i]=True\r\n                q.append(i)\r\n                dis[i]=dis[a]+1\r\n    if not v[y]:\r\n        pr(0)\r\n    else:\r\n        pr(dis[y])\r\n                \r\n        \r\n        \r\n\r\n\r\nfor _ in range(1):\r\n    solve()\r\n", "n,m=map(int,input().strip().split())\r\nconnections={}\r\nfor _ in range(m):\r\n    x,y=map(int,input().strip().split())\r\n    if x not in connections.keys():\r\n        connections[x]=[y]\r\n    else:\r\n        connections[x].append(y)\r\n    if y not in connections.keys():\r\n        connections[y]=[x]\r\n    else:\r\n        connections[y].append(x)\r\ns,t=map(int,input().split())\r\ndistances=[-1]*(n+1)\r\ndistances[s]=0\r\nunvisited=list(range(1,n+1))\r\nwhile unvisited!=[]:\r\n    min1=max(distances)\r\n    v=-1\r\n    flag=0\r\n    for j in unvisited:\r\n        if distances[j]!=-1 and min1>=distances[j]:\r\n            min1=distances[j]\r\n            v=j\r\n    if v==-1:\r\n        break\r\n    unvisited.remove(v)\r\n    for i in connections[v]:\r\n        if i not in unvisited:\r\n            continue\r\n        if distances[i]==-1 or distances[i]>1+distances[v]:\r\n            distances[i]=1+distances[v]\r\n        if i==t:\r\n            flag=1\r\n            break\r\n    if flag==1:\r\n        break\r\nif distances[t]==-1:\r\n    distances[t]=0\r\nprint(distances[t])", "from queue import Queue\r\nn,m=[int(x) for x in input().split()]\r\nadj=[[] for i in range(n+1)]\r\nfor _ in range (m) :\r\n    src,dest=[int(x) for x in input().split()]\r\n    adj[src].append(dest)\r\n    adj[dest].append(src)\r\nvis=[0]*(n+1)\r\nstrt , end = [int(x) for x in input().split()]\r\nvis[strt]=1\r\nq=Queue()\r\nq.put(strt)\r\nk=0\r\nwhile not q.empty() :\r\n    k+=1\r\n    for i in range(q.qsize()) :\r\n        ele=q.get()\r\n        for j in adj[ele] :\r\n            if vis[j]==0 :\r\n                q.put(j)\r\n                vis[j]=k\r\nprint(vis[end])", "# cook your dish here\nfrom collections import deque\ndef bfs(graph,u,t):\n    queue = deque([u])\n    level = {u: 0}\n    while queue:\n        ver = queue.popleft()\n        for v in graph[ver]:\n            if v not in level:            \n                queue.append(v)\n                level[v] = level[ver] + 1\n    return level.get(t,0)\ntry:\n    n,e = map(int,input().split())\n    graph = {}\n    for i in range(1,n+1):\n        graph[i] = []\n    for _ in range(e):\n        a,b = map(int,input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    s,t = map(int,input().split())\n    p = bfs(graph,s,t)\n    print(p)\n    \nexcept:\n    pass"]