["from math import gcd\n\n\ndef lcm(a, b): return a * b // gcd(a, b)\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    P = list(map(int, input().split()))\n    x, a = map(int, input().split())\n    y, b = map(int, input().split())\n    k = int(input())\n    P.sort(reverse=True)\n    l = 0\n    r = n + 1\n    while r - l > 1:\n        m = (l + r) // 2\n        g1 = m // lcm(a, b)\n        g2 = m // a - g1\n        g3 = m // b - g1\n        cnt = 0\n        for i in range(g1):\n            cnt += (x + y) * P[i] // 100\n        if x > y:\n            for i in range(g1, g1 + g2):\n                cnt += x * P[i] // 100\n            for i in range(g1 + g2, g1 + g2 + g3):\n                cnt += y * P[i] // 100\n        else:\n            for i in range(g1, g1 + g3):\n                cnt += y * P[i] // 100\n            for i in range(g1 + g3, g1 + g2 + g3):\n                cnt += x * P[i] // 100\n        if cnt >= k:\n            r = m\n        else:\n            l = m\n    if l == n:\n        print(-1)\n    else:\n        print(l + 1)", "def sell(p, x, a, y, b, m):\n    from math import gcd\n    i2 = m // a\n    i1 = i2 // (b // gcd(a, b))\n    return x * sum(p[:i2]) + y * (sum(p[:i1]) + sum(p[i2:m // b + i2 - i1]))\n\n\ndef main():\n    for _ in range(int(input())):\n        n = int(input())\n        p = sorted((int(pi) // 100 for pi in input().split()), reverse=True)\n        x, a = list(map(int, input().split()))\n        y, b = list(map(int, input().split()))\n        if x < y:\n            x, a, y, b = y, b, x, a\n        k = int(input())\n        l_, r = 0, n + 1\n        while r - l_ > 1:\n            m = (l_ + r) // 2\n            if sell(p, x, a, y, b, m) >= k:\n                r = m\n            else:\n                l_ = m\n        print(-1 if r > n else r)\n\n\nmain()\n", "from math import gcd\ndef check(m):\n    nonlocal p, k, x, a, y, b\n    ans  = 0\n    kx = m // a\n    ky = m // b\n    kxy = m // (a * b // gcd(a, b))\n    kx -= kxy\n    ky -= kxy\n    for i in range(kxy):\n        ans += p[i] * (x + y) // 100\n        #print(p[i], end = ' ')\n    if x >= y:\n        for i in range(kxy, kxy + kx):\n            ans += p[i] * x // 100\n            #print(p[i],end = ' ')\n        \n        for i in range(kxy + kx, kxy + kx + ky):\n            ans += p[i] * y // 100\n            #print(p[i],end = ' ')\n    else:\n        for i in range(kxy, kxy + ky):\n            ans += p[i] * y // 100\n    #        print(p[i],end = ' ')\n        \n        for i in range(kxy + ky, kxy + kx + ky):\n            ans += p[i] * x // 100\n     #       print(p[i],end = ' ')\n    #print(\"!!!!\")\n    #print('III', ans, m)\n    return ans\n    \n\np = []\nfor i in range(int(input())):\n    n = int(input())\n    p = sorted(map(int, input().split()), reverse=True)\n    x, a = list(map(int, input().split()))\n    y, b = list(map(int, input().split()))\n    k = int(input())\n    l = 0\n    r = n\n    if check(n) < k:\n        print(-1)\n        #print()\n        continue\n    else:\n        while r - l > 1:\n            m = (r + l) // 2\n            if check(m) >= k:\n                r =  m\n            else:\n                l = m\n        print(r)\n        #print()\n", "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef check(m):\n    nonlocal n, arr, x, a, y, b, k\n\n    arr2 = arr[:m]\n    count_double = m // (a * b // gcd(a, b))\n    maximals = sorted(arr, reverse=True)[:(m // a + m // b - count_double)]\n    ans = 0\n    for i in maximals[:count_double]:\n        ans += (x + y) * i\n    maximals = maximals[count_double:]\n\n    count_a = m // a - count_double\n    count_b = m // b - count_double\n    for i in maximals[:count_a]:\n        ans += x * i\n    for i in maximals[count_a:]:\n        ans += y * i\n\n    return ans >= k\n\n\nQ = int(input())\n\nfor q in range(Q):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    arr = [i // 100 for i in arr]\n    x, a = tuple(map(int, input().split()))\n    y, b = tuple(map(int, input().split()))\n    k = int(input())\n\n    if x < y:\n        x, a, y, b = y, b, x, a\n\n    left = 0\n    right = n\n    medium = 0\n    while right - left > 1:\n        medium = (left + right) // 2\n\n        if check(medium):\n            right = medium\n        else:\n            left = medium\n\n    if check(left):\n        print(left)\n    elif check(medium):\n        print(medium)\n    elif check(right):\n        print(right)\n    else:\n        print(-1)\n'''\n    count_double = n // (a * b // gcd(a, b))\n    #print(n // a + n // b - count_double)\n    maximals = sorted(arr, reverse=True)[:(n // a + n // b - count_double)]\n    ans = 0\n    for i in maximals[:count_double]:\n        ans += (x + y) * i\n    maximals = maximals[count_double:]\n\n    count_a = n // a - count_double\n    count_b = n // b - count_double\n    for i in maximals[:count_a]:\n        ans += x * i\n    for i in maximals[count_a:]:\n        ans += y * i\n\n    print(ans, k, ans >= k)\n'''", "q = int(input())\n\n\ndef check(l):\n    return sum(i * j // 100 for i, j in zip(prices[-l:], sorted(p[:l]))) >= k\n\n\nfor i in range(q):\n    n = int(input())\n    prices = sorted(map(int, input().split()))\n    x, a = list(map(int, input().split()))\n    y, b = list(map(int, input().split()))\n    k = int(input())\n    p = [0] * n\n    for j in range(n):\n        c = 0\n        if (j + 1) % a == 0:\n            c += x\n        if (j + 1) % b == 0:\n            c += y\n        p[j] = c\n    if not check(n):\n        print(-1)\n    else:\n        left = -1\n        right = n\n        while right - left > 1:\n            middle = (right + left) // 2\n            if check(middle):\n                right = middle\n            else:\n                left = middle\n        print(right)\n", "from math import gcd\nq=int(input())\nfor i in range(q):\n    n=int(input())\n    p=[10**100]+[int(x) for x in input().split()]\n    x,a=[int(x) for x in input().split()]\n    y,b=[int(x) for x in input().split()]\n    k=int(input())\n    p.sort(reverse=True)\n    flag=False\n    l=0\n    r=n\n    if x<y:\n        x,y=y,x\n        a,b=b,a\n    z=(a*b)//gcd(a,b)\n    while r-l>1:\n        mid=(l+r)//2\n        pointer=1\n        counter=0\n        for j in range(z,mid+1,z):\n            counter+=(p[pointer]*(x+y)//100)\n            pointer+=1\n        for j in range(a,mid+1,a):\n            if j%z!=0:\n                counter+=(p[pointer]*x//100)\n                pointer+=1\n        for j in range(b,mid+1,b):\n            if j%z!=0:\n                counter+=(p[pointer]*y//100)\n                pointer+=1\n        if counter>=k:\n            flag=True\n            r=mid\n        else:\n            l=mid\n    mid=r\n    pointer=1\n    counter=0\n    for j in range(z,mid+1,z):\n        counter+=(p[pointer]*(x+y)//100)\n        pointer+=1\n    for j in range(a,mid+1,a):\n        if j%z!=0:\n            counter+=(p[pointer]*x//100)\n            pointer+=1\n    for j in range(b,mid+1,b):\n        if j%z!=0:\n            counter+=(p[pointer]*y//100)\n            pointer+=1\n    if counter>=k:\n        print(r)\n    else:\n        print(-1)\n    \n                \n            \n    \n    \n", "n = int(input())\n\ndef ans(x, y, a, b, k) :\n    if ch(x, y, a, b, len(v)) < k : return -1\n    l, r = -1, len(v)\n    while l + 1 != r :\n        m = (l+r)//2\n        if ch(x, y, a, b, m) >= k : r = m\n        else : l = m\n    return r\n\ndef nok(a, b) :\n    s, d = a, b\n    while b : a, b = b, a % b\n    return (s*d)//a\n\ndef ch(x, y, a, b, m) :\n    ab = m//nok(a, b)\n    a = m//a - ab\n    b = m//b - ab\n    if x > y : s = sum(v[0:ab])*(x+y) + sum(v[ab:ab+a])*x + sum(v[ab+a:ab+a+b])*y\n    else : s = sum(v[0:ab])*(x+y) + sum(v[ab:ab+b])*y + sum(v[ab+b:ab+a+b])*x\n    return s\n\nfor _ in range(n) :\n    input()\n    v = sorted(list([int(x)//100 for x in input().split()]), key=lambda x: -x)\n    x, a = [int(x) for x in input().split()]\n    y, b = [int(x) for x in input().split()]\n    k = int(input())\n    print(ans(x, y, a, b, k))\n", "def gcd(a, b):\n    if a*b == 0:\n        return a+b\n    return gcd(b, a%b)\n\n\ndef f():\n    n = int(input())\n    p = list([int(x)//100 for x in input().split()])\n    x, a = list(map(int, input().split()))\n    y, b = list(map(int, input().split()))\n    k = int(input())\n    p.sort(reverse = True)\n    ps = [0]\n    for i in range(0, n):\n        ps.append(ps[-1] + p[i])\n    i = 0\n    j = n\n    if x < y:\n        x, y, a, b = y, x, b, a\n    m = n\n    ab = a*b//gcd(a, b)\n    colab = m//ab\n    cola = m//a - colab\n    colb = m//b - colab\n    res = (ps[colab]*(x+y) + (ps[colab + cola] - ps[colab])*x +\n                (ps[colab+cola+colb] - ps[cola+colab])*y)\n    if res < k:\n        return -1\n#    print(p, ps, cola, colb, colab, k, res, ps[colab]*(x+y), (ps[colab + cola] - ps[colab])*x, (ps[colab+cola+colb] - ps[colab+cola])*y)\n    while j - i > 1:\n        m = (i+j)//2\n        colab = m//ab\n        cola = m//a - colab\n        colb = m//b - colab\n        res = (ps[colab]*(x+y) + (ps[colab + cola] - ps[colab])*x +\n                (ps[colab+cola+colb] - ps[cola+colab])*y)\n        if res >= k:\n            j = m\n        else:\n            i = m\n    return j\n\n\nfor i in range(int(input())):\n    print(f())\n", "from math import gcd\nfor _ in range(int(input())):\n    n = int(input())\n    p2 = list(map(int,input().split()))\n    p = sorted(p2, reverse=True)\n    x, a = list(map(int, input().split()))\n    y, b = list(map(int, input().split()))\n    k = int(input())\n    l = -1\n    r = n + 1\n    while r - l > 1:\n        mid = (r + l) // 2\n        m_cnt3 = mid // (a * b // gcd(a, b))\n        m_cnt1 = mid // a - m_cnt3\n        m_cnt2 = mid // b - m_cnt3\n        res = sum(p[:m_cnt3]) // 100 * (x + y)\n        if x > y:\n            res += sum(p[m_cnt3:m_cnt1 + m_cnt3]) // 100 * x + sum(p[m_cnt1 + m_cnt3:m_cnt1 + m_cnt2 + m_cnt3]) // 100 * y\n        else:\n            res += sum(p[m_cnt3:m_cnt2 + m_cnt3]) // 100 * y + sum(p[m_cnt2+m_cnt3:m_cnt1 + m_cnt2 + m_cnt3]) // 100 * x\n        if res < k:\n            l = mid\n        else:\n            r = mid\n    if r == n + 1:\n        print(-1)\n    else:\n        print(r)\n", "def nok(a, b):\n    return (a * b) // gcd(a, b)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef test(z):\n    nonlocal x, a, y, b, p, k\n    ans = 0\n    xayb = z // nok(a, b)\n    xa = z // a - xayb\n    yb = z // b - xayb\n    if x >= y:\n        x1 = xa\n        x2 = yb\n        y1 = x\n        y2 = y\n    else:\n        x1 = yb\n        x2 = xa\n        y1 = y\n        y2 = x\n    for i in range(xayb):\n        ans += (p[i] // 100) * (x + y)\n    for i in range(xayb, xayb + x1):\n        ans += (p[i] // 100) * y1\n    for i in range(xayb + x1, xayb + x1 + x2):\n        ans += (p[i] // 100) * y2\n    return ans >= k\n\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    p = list(map(int, input().split()))\n    p.sort(reverse = True)\n    x, a = map(int, input().split())\n    y, b = map(int, input().split())\n    k = int(input())\n    left = 0\n    right = n\n    if not test(right):\n        print(-1)\n    else:\n        while right - left > 1:\n            mid = (left + right) // 2\n            if test(mid):\n                right = mid\n            else:\n                left = mid\n        print(right)", "from math import *\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    z, x = list(map(int, input().split()))\n    t, y = list(map(int, input().split()))\n    lcd = x*y//gcd(x, y)\n    if z < t:\n        x, y, z, t = y, x, t, z\n    w1 = z+t\n    k = int(input())\n    a.sort(reverse=True)\n    l, r = -1, len(a)+1\n    while r-l > 1:\n        m = (l+r)//2\n        w, ans = m//lcd, 0\n        for q in range(w):\n            ans += a[q]//100*w1\n        for q in range(w, m//x):\n            ans += a[q]//100*z\n        for q in range(m//x, m//x+m//y-w):\n            ans += a[q]//100*t\n        if ans >= k:\n            r = m\n        else:\n            l = m\n    if r == len(a)+1:\n        print(-1)\n    else:\n        print(r)\n", "def gcd(a, b):\n    return (a if b == 0 else gcd(b, a % b))\n\ndef nk(a, b):\n    return (a * b) // gcd(a, b)\n\ndef check(arr, x, y, a, b, mid, k):\n    GdCN = mid // nk(a, b)\n    if x > y:\n        MAP = x\n        MIP = y\n        MAD = a\n        MID = b\n    else:\n        MAP = y\n        MIP = x\n        MAD = b\n        MID = a\n    GCN = mid // MAD - GdCN\n    BCN = mid // MID - GdCN\n    #print(arr[:GdCN], arr[GdCN:GdCN + GCN], arr[GdCN + GCN:GdCN + GCN + BCN])\n    #print(mid, GdCN, GCN, BCN, sum(arr[:GdCN]) * ((x + y) // 100) + sum(arr[GdCN:GdCN + GCN]) * (MAP // 100) + sum(arr[GdCN + GCN:GdCN + GCN + BCN]) * (MIP // 100))\n    if sum(arr[:GdCN]) * (x + y) // 100 + sum(arr[GdCN:GdCN + GCN]) * MAP // 100 + sum(arr[GdCN + GCN:GdCN + GCN + BCN]) * MIP // 100 >= k:\n        return True\n    else:\n        return False\n\nn = int(input())\nfor i in range(n):\n    input()\n    arr = [int(x) for x in input().split()]\n    x, a = [int(x) for x in input().split()]\n    y, b = [int(x) for x in input().split()]\n    k = int(input())\n    arr = sorted(arr)[::-1]\n    left = 0\n    right = len(arr)\n    while right - left > 1:\n        mid = (right + left) // 2\n        if check(arr, x, y, a, b, mid, k):\n            right = mid\n        else:\n            left = mid\n    if check(arr, x, y, a, b, left, k):\n        print(left)\n    elif check(arr, x, y, a, b, right, k):\n        print(right)\n    else:\n        print(-1)\n    #print('--------------------------------------------------')\n", "q = int(input())\nfor i in range(q):\n    n = int(input())\n    p = list(map(int, input().split()))\n    p.sort(reverse=True)\n    x, a = list(map(int, input().split()))\n    y, b = list(map(int, input().split()))\n    k = int(input())\n    if x < y:\n        a, b, x, y = b, a, y, x\n    j = min(a, b)\n    last_j = 0\n    if j == a == b:\n        A = 2 * a\n        B = 2 * b\n        np1 = 0\n        np2 = 0\n        np3 = 1\n        new = \"p3\"\n    elif j == a:\n        A = 2 * a\n        B = b\n        np1 = 1\n        np2 = 0\n        np3 = 0\n        new = \"p1\"\n    else:\n        A = a\n        B = 2 * b\n        np1 = 0\n        np2 = 1\n        np3 = 0\n        new = \"p2\"\n    s = 0\n    while j <= n and s < k:\n        if new == \"p2\":\n            s += p[np1 + np2 + np3 - 1] / 100 * y\n        elif new == \"p1\":\n            s += p[np3 + np1 - 1] / 100 * x\n            if np2 > 0:\n                s += p[np1 + np2 + np3 - 1] / 100 * y - p[np3 + np1 - 1] / 100 * y\n        else:\n            s += p[np3 - 1] / 100 * (y + x)\n            if np1 > 0:\n                s += p[np3 + np1 - 1] / 100 * x - p[np3 - 1] / 100 * x\n            if np2 > 0:\n                s += p[np1 + np3 + np2 - 1] / 100 * y - p[np1 + np3 - 1] / 100 * y\n#        s = sum(p[:np3]) / 100 * (x + y) + sum(p[np3:np3 + np1]) / 100 * x + sum(p[np1 + np3:np1 + np2 + np3]) / 100 * y\n        last_j = j\n        j = min(A, B)\n        if j == A == B:\n            A += a\n            B += b\n            np3 += 1\n            new = \"p3\"\n        elif j == A:\n            A += a\n            np1 += 1\n            new = \"p1\"\n        else:\n            B += b\n            np2 += 1\n            new = \"p2\"\n    if s >= k:\n        print(last_j)\n    else:\n        print(-1)\n", "def line():\n    return list(map(int, input().split()))\n\ndef num():\n    return int(input())\n\nfrom itertools import repeat\n\ndef gcd(a,b):\n    if a<b:\n        a,b = b,a\n    while b!=0:\n        t=b\n        b=a%b\n        a=t\n    return a\n\ndef lcm(a,b):\n    return a*b//gcd(a,b)\n\nq = num()\nfor _ in repeat(None, q):\n    n = num()\n    p = sorted(line(), reverse=True)\n    x,a = line()\n    y,b = line()\n    if x>y:\n        x,a,y,b = y,b,x,a\n    k = num()\n\n    u=lcm(a,b)\n\n    def f(i):\n        ums=i//u\n        ams,bms = i//a-ums, i//b-ums\n        return sum(p[:ums])*(x+y)+sum(p[ums:ums+bms])*y+sum(p[ums+bms:ums+bms+ams])*x\n\n    def cool(e):\n        s = 1\n        ans=-1\n        while s<=e:\n            m = (s+e)//2\n            d = f(m)\n            if d<k*100:\n                s=m+1\n            else:\n                ans=m\n                e=m-1\n        return ans\n\n    print(cool(n+1))\n", "from math import gcd\n\n\ndef check(m, a, b, prices, k, x, y):\n    acdc = m // a\n    bcdc = m // b\n    abcdc = m // (a * b // gcd(a, b))\n    calc = 0\n    while acdc or bcdc:\n        new = prices.pop()\n        if abcdc:\n            calc += new * (x + y) // 100\n            abcdc -= 1\n            acdc -= 1\n            bcdc -= 1\n        elif acdc:\n            calc += new * x // 100\n            acdc -= 1\n        else:\n            calc += new * y // 100\n            bcdc -= 1\n    if calc < k:\n        return 0\n    return 1\n\n\nn = int(input())\nfor i in range(n):\n    p = int(input())\n    prices = list(map(int, input().split()))\n    x, a = map(int, input().split())\n    y, b = map(int, input().split())\n    prices.sort()\n    k = int(input())\n    L = 0\n    R = p\n    if y > x:\n        x, a, y, b = y, b, x, a\n    while R - L > 1:\n        m = (R + L) // 2\n        if check(m, a, b, prices.copy(), k, x, y):\n            R = m\n        else:\n            L = m\n    print(R if check(R, a, b, prices.copy(), k, x, y) else -1)", "from math import *\n\n\ndef ok(v,x,a,y,b,k,m):\n\tgcdd=(a*b)//gcd(a,b)\n\tanss=[0 for j in range(m+1)]\n\tidd=0\n\n\tfor i in range(1,m+1):\n\t\tif(i % gcdd == 0):\n\t\t\tanss[i] = (v[idd] * (x+y)) // 100;\n\t\t\tidd+=1;\n\tmaxmass = a; maxmastt = b; mx = x; mn = y;\n\tif(x > y):\n\t\tmaxmass, maxmastt, mx, mn = a,b,x,y;\n\telse:\n\t\tmaxmass, maxmastt, mx, mn = b,a,y,x;\n\n\tfor i in range(1,m+1):\n\t\tif(i % maxmass == 0 and anss[i] == 0):\n\t\t\tanss[i] = (v[idd] * mx) // 100;\n\t\t\tidd+=1;\n\tfor i in range(1,m+1):\n\t\tif(i % maxmastt == 0 and anss[i] == 0):\n\t\t\tanss[i] = (v[idd] * mn) // 100;\n\t\t\tidd+=1;\n\tsumm = 0;\n\tfor i in range(1, m+1):\n\t\tsumm += anss[i]\t\n\treturn (summ >= k)\n\nfor _ in ' '*int(input()):\n\tn=int(input())\n\tv=[int(i) for i in input().split()]\n\tfor i in range(10):\n\t\tv.append(0)\n\tx,a=[int(i) for i in input().split()]\n\ty,b=[int(i) for i in input().split()]\n\tk=int(input())\n\tv.sort(reverse=True)\n\thi,lo=n+1,-1\n\tmidd=(hi+lo)//2\n\twhile(hi-lo>1):\n\t\tmidd=(hi+lo)//2\n\t\tif(ok(v,x,a,y,b,k,midd)):\n\t\t\thi=midd\n\t\telse:\n\t\t\tlo=midd\n\tif(ok(v,x,a,y,b,k,lo)):\n\t\tprint(lo)\n\telif(ok(v,x,a,y,b,k,hi)):\n\t\tprint(hi)\n\telse:\n\t\tprint(-1)\n", "import math\n\nt = int(input())\n\n\ndef check(mid):\n    nonlocal n, p, x, a, y, b, k\n    result = 0\n    best = mid // (a * b // math.gcd(a, b))\n    best_a = mid // a\n    best_b = mid // b\n    kolvo = 0\n    for i in range(best):\n        if kolvo == mid:\n            break\n        result += (p[n - i - 1] // 100) * (x + y)\n        kolvo += 1\n    if x > y:\n        for i in range(best_a - best):\n            if kolvo == mid:\n                break\n            result += (p[n - i - best - 1] // 100) * x\n            kolvo += 1\n        for i in range(best_b - best):\n            if kolvo == mid:\n                break\n            result += (p[n - i - (best_a - best) - best - 1] // 100) * y\n            kolvo += 1\n    else:\n        for i in range(best_b - best):\n            if kolvo == mid:\n                break\n            result += (p[n - i - best - 1] // 100) * y\n            kolvo += 1\n        for i in range(best_a - best):\n            if kolvo == mid:\n                break\n            result += (p[n - i - (best_b - best) - best - 1] // 100) * x\n            kolvo += 1\n    if result >= k:\n        return True\n    return False\n\n    if result >= k:\n        return True\n    return False\n\n\nfor i in range(t):\n    n = int(input())\n    p = [int(i) for i in input().split()]\n    x, a = list(map(int, input().split()))\n    y, b = list(map(int, input().split()))\n    k = int(input())\n    p.sort()\n    left = 0\n    right = n\n    while (right - left > 1):\n        middle = (left + right) // 2\n        if check(middle):\n            right = middle\n        else:\n            left = middle\n    if check(left):\n        print(left)\n    elif check(right):\n        print(right)\n    else:\n        print(-1)\n", "def gcd(a, b):\n    while a % b != 0:\n        t = b\n        b = a % b\n        a = t\n    return b\n\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    tickets = list(map(int, input().split()))\n    x, a = list(map(int, input().split()))\n    y, b = list(map(int, input().split()))\n    k = int(input())\n    lcmab = lcm(a, b)\n    if y < x:\n        x, y = y, x\n        a, b = b, a\n    tickets.sort(reverse=True)\n    pfsums = [0] * (n + 1)\n    ans = -1\n    for i in range(1, n + 1):\n        pfsums[i] = pfsums[i - 1] + tickets[i - 1]\n        streak = i // lcmab\n        xprof = i // a - streak\n        yprof = i // b - streak\n        mylen = i\n        if mylen >= streak:\n            got = ((pfsums[streak]) * (x + y)) // 100\n            mylen -= streak\n        else:\n            got = ((pfsums[mylen] - pfsums[streak]) * (x + y)) // 100\n            if got >= k:\n                ans = i\n                break\n        if mylen >= yprof:\n            got += ((pfsums[streak + yprof] - pfsums[streak]) * y) // 100\n            mylen -= yprof\n        else:\n            got += ((pfsums[streak + mylen] - pfsums[streak]) * y) // 100\n            if got >= k:\n                ans = i\n                break\n        if mylen >= xprof:\n            got += ((pfsums[streak + yprof + xprof] - pfsums[streak + yprof]) * x) // 100\n            mylen -= xprof\n        else:\n            got += ((pfsums[streak + mylen + yprof] - pfsums[streak + yprof]) * x) // 100\n        if got >= k:\n            ans = i\n            break\n    print(ans)\n\n\n", "from math import gcd\n\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    p = sorted(map(int, input().split()), key=int)[::-1]\n    x, a = list(map(int, input().split()))\n    y, b = list(map(int, input().split()))\n    k = int(input())\n\n    #preprocessing\n    c = a*b//gcd(a,b)\n    if y>x:\n        x, y = y, x\n        a, b = b, a\n\n    #aux fxn to find whether m tickets suffice\n    def check(m):\n        add = 0\n        hc = m//c\n        ha = m//a - hc\n        hb = m//b - hc\n        #print(\"aajo\")\n        #print(m,hc,ha,hb)\n        for j in range(hc):\n            add += (x+y)*p[j]//100\n        for j in range(hc, hc + ha):\n            add += x*p[j]//100\n        for j in range(hc + ha, hc + ha + hb):\n            add += y*p[j]//100\n\n        return add\n\n    #lower bound using check fxn\n    lo, hi = 1, n\n    ans = -1\n    \n    while(lo <= hi):\n        mid = (lo + hi)//2\n        val = check(mid)\n        #print(\"check\")\n        #print(mid, val)\n        if val >= k:\n            ans = mid\n            hi = mid - 1\n        #elif val > k:\n        #    ans = mid\n        #    hi = mid - 1\n        else:\n            lo = mid + 1\n        \n    print(ans)\n\n", "from collections import deque\nn = int(input())\nfor _ in range(n):\n    m = int(input())  # number tickets\n    tickets = list(map(int, input().split()))\n    tickets.sort(reverse=True)\n    aperc, ajump = list(map(int, input().split()))\n    bperc, bjump = list(map(int, input().split()))\n    q = int(input())  # req total\n    if bperc > aperc:\n        bperc, aperc = aperc, bperc\n        ajump, bjump = bjump, ajump\n    # a is bigger\n    aperc = aperc/100\n    bperc = bperc/100\n    zet = False\n    ans = -1\n    sumo = 0\n    da = deque()\n    db = deque()\n    dc = deque()\n    tc = 0\n    for i in range(m):\n        z = i+1\n        if z % ajump == 0 and z % bjump == 0:\n            if(len(da) > 0):\n                xx = da.pop()\n                dc.appendleft(xx)\n                if len(db) > 0:\n                    xxx = db.pop()\n                    da.appendleft(xxx)\n                    db.appendleft(tickets[tc])\n                    sumo = sumo + bperc * xx + \\\n                        (aperc-bperc)*xxx + bperc*tickets[tc]\n                else:\n                    da.appendleft(tickets[tc])\n                    sumo = sumo + bperc * xx + aperc*tickets[tc]\n\n            elif len(db) > 0:\n                xx = db.pop()\n                dc.appendleft(xx)\n                db.appendleft(tickets[tc])\n                sumo = sumo + aperc * xx + bperc*tickets[tc]\n\n            else:\n                dc.appendleft(tickets[tc])\n                sumo = sumo + (aperc+bperc) * tickets[tc]\n\n            tc += 1\n\n        elif z % ajump == 0:\n            if len(db) > 0:\n                xx = db.pop()\n                da.appendleft(xx)\n                db.appendleft(tickets[tc])\n                sumo = sumo + (aperc-bperc) * xx + bperc*tickets[tc]\n            else:\n                da.appendleft(tickets[tc])\n                sumo = sumo + aperc * tickets[tc]\n            tc += 1\n\n        elif z % bjump == 0:\n            db.appendleft(tickets[tc])\n            sumo = sumo + bperc * tickets[tc]\n            tc += 1\n\n        else:\n            pass\n        # print(f\"i:{i}, sum:{sumo}\")\n        # print(da)\n        # print(db)\n        # print(dc)\n        # print(\" \")\n        if(sumo >= q and (not zet)):\n            zet = True\n            ans = i+1\n            break\n\n    print(ans)\n", "from collections import deque\nn = int(input())\nfor _ in range(n):\n    m = int(input())  # number tickets\n    tickets = list(map(int, input().split()))\n    tickets.sort(reverse=True)\n    aperc, ajump = map(int, input().split())\n    bperc, bjump = map(int, input().split())\n    q = int(input())  # req total\n    if bperc > aperc:\n        bperc, aperc = aperc, bperc\n        ajump, bjump = bjump, ajump\n    # a is bigger\n    aperc = aperc/100\n    bperc = bperc/100\n    zet = False\n    ans = -1\n    sumo = 0\n    da = deque()\n    db = deque()\n    dc = deque()\n    tc = 0\n    for i in range(m):\n        z = i+1\n        if z % ajump == 0 and z % bjump == 0:\n            if(len(da) > 0):\n                xx = da.pop()\n                dc.appendleft(xx)\n                if len(db) > 0:\n                    xxx = db.pop()\n                    da.appendleft(xxx)\n                    db.appendleft(tickets[tc])\n                    sumo = sumo + bperc * xx + \\\n                        (aperc-bperc)*xxx + bperc*tickets[tc]\n                else:\n                    da.appendleft(tickets[tc])\n                    sumo = sumo + bperc * xx + aperc*tickets[tc]\n \n            elif len(db) > 0:\n                xx = db.pop()\n                dc.appendleft(xx)\n                db.appendleft(tickets[tc])\n                sumo = sumo + aperc * xx + bperc*tickets[tc]\n \n            else:\n                dc.appendleft(tickets[tc])\n                sumo = sumo + (aperc+bperc) * tickets[tc]\n \n            tc += 1\n \n        elif z % ajump == 0:\n            if len(db) > 0:\n                xx = db.pop()\n                da.appendleft(xx)\n                db.appendleft(tickets[tc])\n                sumo = sumo + (aperc-bperc) * xx + bperc*tickets[tc]\n            else:\n                da.appendleft(tickets[tc])\n                sumo = sumo + aperc * tickets[tc]\n            tc += 1\n \n        elif z % bjump == 0:\n            db.appendleft(tickets[tc])\n            sumo = sumo + bperc * tickets[tc]\n            tc += 1\n \n        else:\n            pass\n        # print(f\"i:{i}, sum:{sumo}\")\n        # print(da)\n        # print(db)\n        # print(dc)\n        # print(\" \")\n        if(sumo >= q and (not zet)):\n            zet = True\n            ans = i+1\n            break\n \n    print(ans)", "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    \n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nq = int(input())\n\nwhile q > 0:\n    n = int(input())\n    p = sorted(list(map(int, input().split())), reverse=True)\n    x, a = map(int, input().split())\n    y, b = map(int, input().split())\n    nsum = int(input())\n\n    maxper, maxint, minper, minint = 0, 0, 0, 0\n\n    if x < y:\n        maxper, minper, maxint, minint = y, x, b, a\n    else:\n        maxper, minper, maxint, minint = x, y, a, b\n\n    left, right, middle = 0, n + 1, 0\n\n    while right - left > 1:\n        middle = (left + right) // 2\n\n        total = 0\n        tlcm = lcm(a, b)\n        tlcmk = middle // tlcm\n        tak, tbk = middle // maxint - tlcmk, middle // minint - tlcmk\n        cur = 0\n\n        while cur < tlcmk:\n            total += p[cur] // 100 * (x + y)\n            cur += 1\n\n        while cur < tlcmk + tak:\n            total += p[cur] // 100 * maxper\n            cur += 1\n\n        while cur < tlcmk + tak + tbk:\n            total += p[cur] // 100 * minper\n            cur += 1\n        \n        if total >= nsum:\n            right = middle\n        else:\n            left = middle\n    \n    if right == n + 1:\n        print(-1)\n    else:\n        print(right)\n\n    q -= 1", "def nod(a,b):\n    while a*b!=0:\n        if a>b:\n            a%=b\n        else:\n            b%=a\n    return a+b\ndef rec(m,x,a,y,b):\n    nonlocal p\n    cx,cy,cxy=0,0,0\n    for i in range(1,m+1):\n        if i%a==0 and i%b==0:\n            cxy+=1\n        elif i%a==0:\n            cx+=1\n        elif i%b==0:\n            cy+=1\n    ans=0\n\n    for i in range(cxy):\n        ans+=p[i]*(x+y)\n    for i in range(cx):\n        ans+=p[cxy+i]*x\n    for i in range(cy):\n        ans+=p[cxy+cx+i]*y\n  \n    return ans\n\nn=int(input())\nfor i in range(n):\n    q=int(input())\n    p=[int(j) for j in input().split()]\n    p.sort(reverse=True)\n    x,a=list(map(int,input().split()))\n    y,b=list(map(int,input().split()))\n    if y>x:\n        x,a,y,b=y,b,x,a\n    k=int(input())\n    k=k*100\n    lf=0\n    rg=q+1\n    while rg-lf>1:\n        m=(rg+lf)//2\n        if rec(m,x,a,y,b)>=k:\n            rg=m\n        else:\n            lf=m\n    if rg>q:\n        rg=-1\n    print(rg)\n", "def calc(arr, ll, a, b, x, y):\n    # y is always greater than x\n    rXY = 0\n    rX = 0\n    rY = 0\n    result = 0\n    for i in range(1, ll+1):\n        if i % a == 0 and i % b == 0:\n            rXY += 1\n        elif i % a == 0:\n            rX += 1\n        elif i % b == 0:\n            rY += 1\n    for i in range(rXY):\n        result += arr[i] * ((x + y)/100)\n    for i in range(rX):\n        result += arr[rXY + i] * (x/100)\n    for i in range(rY):\n        result += arr[rXY + rX + i] * (y/100)\n    return result\n\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    x, a = list(map(int, input().split()))\n    y, b = list(map(int, input().split()))\n    k = int(input())\n\n    if x < y:\n        x, y = y, x\n        a, b = b, a\n\n    arr.sort(reverse=True)\n    \n    left = 0\n    right = n + 1\n    while (right - left > 1): \n        mid = (right + left) // 2\n        if calc(arr, mid, a, b, x, y) >= k:\n            right = mid\n        else:\n            left = mid\n            \n    print(right if right <= n else -1)"]