["3\n\n__import__(\"sys\").setrecursionlimit(10 ** 6)\n\ndef dfs(u, tr, used):\n    used[u] = True\n    ans = 1\n    for v in tr[u]:\n        if not used[v]:\n            ans += dfs(v, tr, used)\n    return ans\n\n\nn, m = list(map(int, input().split()))\nif n != m + 1:\n    print(\"no\")\n    return\n\ntr = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    tr[a].append(b)\n    tr[b].append(a)\n\nused = [False] * n\nif dfs(0, tr, used) == n:\n    print(\"yes\")\nelse:\n    print(\"no\")\n", "from sys import stdin as fin\n# fin = open(\"hcc2016c1.in\", \"r\")\n\ndef dfs(v, p):\n    nonlocal g, used, cnt\n    cnt += 1\n    used[v] = True\n    for u in g[v]:\n        if u != p and (used[u] or not dfs(u, v)):\n            return False\n    return True\n\nn, m = map(int, fin.readline().split())\nused = [False] * n\ng = [[] for i in range(n)]\nfor i in range(m):\n    v, u = map(int, fin.readline().split())\n    v, u = v - 1, u - 1\n    g[v].append(u)\n    g[u].append(v)\ncnt = 0\nif not dfs(0, None) or cnt != n:\n    print(\"no\")\nelse:\n    print(\"yes\")", "l = []\nwere = []\n\n\ndef dfs(v):\n    nonlocal l, were\n    if not were:\n        were = len(l) * [False]\n    were[v] = True\n    for i in l[v]:\n        if not were[i]:\n            dfs(i)\n\n\nn, m = list(map(int, input().split()))\nif m != n - 1:\n    print(\"no\")\nelse:\n    l = [[] for i in range(n)]\n    for i in range(m):\n        a, b = list(map(int, input().split()))\n        l[a - 1].append(b - 1)\n        l[b - 1].append(a - 1)\n\n    dfs(0)\n    f = True\n    for i in were:\n        f = f and i\n\n    if f:\n        print(\"yes\")\n    else:\n        print(\"no\")\n", "read = lambda: list(map(int, input().split()))\nn, m = read()\ng = [list() for i in range(n + 1)]\nfor i in range(m):\n    a, b = read()\n    g[a].append(b)\n    g[b].append(a)\n\ndef dfs(v):\n    was[v] = 1\n    for u in g[v]:\n        if not was[u]:\n            dfs(u)\n\nwas = [0] * (n + 1)\ndfs(1)\nans = 'no' if 0 in was[1:] or m != n - 1 else 'yes'\nprint(ans)\n", "import sys\nsys.setrecursionlimit(1000000)\ndef dfs(v, pr):\n    nonlocal used\n    nonlocal p\n    nonlocal f\n    if not f:\n        return None\n    if used[v]:\n        f = False\n    used[v] = True\n    for i in range(len(p[v])):\n        if p[v][i] != pr:\n            dfs(p[v][i], v)\nn, m = list(map(int, input().split()))\np = []\nfor i in range(n):\n    p.append([])\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    p[a].append(b)\n    p[b].append(a)\nused = [False] * n\nf = True\nfor i in range(n):\n    if i != 0 and not used[i]:\n        f = False\n        break\n    if not used[i]:\n        dfs(i, -1)\nif f:\n    print('yes')\nelse:\n    print('no')\n\n        \n", "n, m = list(map(int, input().split()))\nok = m == n - 1\ndsu = list(range(n))\ndef get(x):\n    y = x\n    while y != dsu[y]:\n        y = dsu[y]\n    while x != y:\n        z = dsu[x]\n        dsu[x] = y\n        x = z\n    return y\nfor i in range(m):\n    a, b = [int(x) - 1 for x in input().split()]\n    dsu[get(a)] = get(b)\nfor i in range(n):\n    get(i)\nok &= max(dsu) == min(dsu)\nprint(\"yes\" if ok else \"no\")\n", "def is_valid():\n    import sys\n    #with open(filename, 'r') as f:\n    with sys.stdin as f:\n        for i, line in enumerate(f):\n            if i == 0:\n                N, M = line.split(' ')\n                N, M = int(N), int(M)\n                if N-1 != M:\n                    return False\n                graph = [[] for _ in range(N)] # [[]] * N not working, no deepcopy\n            else:\n                fromVertex, toVertex = line.split(' ')\n                fromVertex, toVertex = int(fromVertex)-1, int(toVertex)-1\n                graph[fromVertex].append(toVertex)\n                graph[toVertex].append(fromVertex)\n\n    from queue import LifoQueue\n    def is_single_component(start_node, graph):\n        N = len(graph)\n        visited = [False for _ in range(N)]\n        visited[start_node] = True\n        nodes_queue = LifoQueue()\n        nodes_queue.put(start_node)\n        while not nodes_queue.empty():\n            node = nodes_queue.get()\n            for neigh in graph[node]:\n                if not visited[neigh]:\n                    visited[neigh] = True\n                    nodes_queue.put(neigh)\n                #else: not a cycle because edges in both directions\n\n        return all(visited)\n\n    return is_single_component(0, graph)\n\nif is_valid():\n    print(\"yes\")\nelse:\n    print(\"no\")", "f = lambda: map(int, input().split())\nn, m = f()\np = list(range(n))\n\ndef g(i):\n    j = i\n    while j != p[j]: j = p[j]\n    while i != j: i, p[i] = p[i], j\n    return j\n\nfor j in range(m):\n    a, b = f()\n    p[g(a - 1)] = g(b - 1)\n\ns = g(0)\nk = all(g(i) == s for i in p)\n\nprint('yes' if m == n - 1 and k else 'no')", "f = lambda: map(int, input().split())\nn, m = f()\np = list(range(n))\n\ndef g(i):\n    while i != p[i]: i = p[i]\n    return i\n\nq = 'yes' if m == n - 1 else 'no'\n\nfor j in range(m):\n    a, b = f()\n    u, v = g(a - 1), g(b - 1)\n    if u == v: q = 'no'\n    p[u] = v\n\nprint(q)", "def adds(sin,c):\n    if c in sin:\n        return 1\n    sin.add(c)\n    return 0\n\ndef corr(v,n):\n    if len(v)<n-1:\n        return 0\n    sin={v[0][0],v[0][1]}\n    v=v[1:]\n    while len(v)>0:\n        nv=[]\n        for c in v:\n            if c[0] in sin:\n                if adds(sin,c[1]):\n                    return 0\n                continue\n            if c[1] in sin:\n                if adds(sin,c[0]):\n                    return 0\n                continue\n            nv.append(c)\n        if v==nv:\n            return 0\n        v=nv    \n    if len(sin)==n:\n        return 1\n    else:\n        return 0\n\nn,m=list(map(int,input().split(' ')))\nv=[]\nfor c in range(m):\n    v.append(list(map(int,input().split(' '))))\nif corr(v,n):\n    print('yes')\nelse:\n    print('no')\n", "# Python program to check if a given directed graph is strongly\n# connected or not\nimport sys\nfrom collections import defaultdict\n\n\nclass Graph:\n    def __init__(self, V):\n        self.V = V\n        self.graph = defaultdict(list)\n\n    def addEdge(self, v, w):\n        # Add w to v ist.\n        self.graph[v].append(w)\n        # Add v to w list.\n        self.graph[w].append(v)\n\n    # A recursive function that uses visited[]\n    # and parent to detect cycle in subgraph\n    # reachable from vertex v.\n    def isCyclicUtil(self, v, visited, parent):\n\n        # Mark current node as visited\n        visited[v] = True\n\n        # Recur for all the vertices adjacent\n        # for this vertex\n        for i in self.graph[v]:\n            # If an adjacent is not visited,\n            # then recur for that adjacent\n            if visited[i] == False:\n                if self.isCyclicUtil(i, visited, v) == True:\n                    return True\n\n            # If an adjacent is visited and not\n            # parent of current vertex, then there\n            # is a cycle.\n            elif i != parent:\n                return True\n\n        return False\n\n    # Returns true if the graph is a tree,\n    # else false.\n    def isTree(self):\n        # Mark all the vertices as not visited\n        # and not part of recursion stack\n        visited = [False] * self.V\n\n        # The call to isCyclicUtil serves multiple\n        # purposes. It returns true if graph reachable\n        # from vertex 0 is cyclcic. It also marks\n        # all vertices reachable from 0.\n        if self.isCyclicUtil(0, visited, -1) == True:\n            return False\n\n        # If we find a vertex which is not reachable\n        # from 0 (not marked by isCyclicUtil(),\n        # then we return false\n        for i in range(self.V):\n            if visited[i] == False:\n                return False\n\n        return True\n\n\ndef main():\n    s = sys.stdin.readline().split()\n    n, m = int(s[0]), int(s[1])\n    graph = Graph(n)\n    for _ in range(m):\n        s = sys.stdin.readline().split()\n        graph.addEdge(int(s[0]) - 1, int(s[1]) - 1)\n\n    return \"yes\" if graph.isTree() else \"no\"\n\n\ndef __starting_point():\n    sys.stdout.write(main())\n\n\n__starting_point()", "def clave(ent):\n\treturn min(ent)\na=[int(i) for i in input().split()]\nt=set(int(i) for i in input().split())\nx=[]\nfor i in range(1,a[1]):\n\tx.append([int(i) for i in input().split()])\nx.sort(key=clave)\nwhile len(x):\n\tf=True\n\tfor c in x:\n\t\tif (c[0] in t) + (c[1] in t)==1:\n\t\t\tf=False\n\t\t\tt.update(c)\n\t\t\tx.remove(c)\n\t\t\tbreak\n\tif f:\n\t\tprint('no')\t\t\n\t\treturn\nprint('yes')\n", "k=[0]*1001\ndef dfs(x):\n    k[x]+=1\n    for i in z[x]:\n        if not(k[i]):dfs(i)\na,b=list(map(int,input().split()))\nz=[]\nfor i in range(a+1):z+=[[]]\nfor i in range(b):\n    x,y=list(map(int,input().split()))\n    z[x].append(y)\n    z[y].append(x)\ndfs(1)\nif sum(k)!=a or a-1!=b:print(\"no\")\nelse:print(\"yes\")\n"]