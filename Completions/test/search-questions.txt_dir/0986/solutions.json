["n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\nlibrary = []\nmoney = 0\nfor i in range(len(a)):\n    if a[i] not in library:\n        money += 1\n        if len(library) < k:\n            library.append(a[i])\n        else:\n            curmin = n\n            curindex = 0\n            found = [n] * len(library)\n            for j in range(len(a[i+1::])):\n                if (a[i+j+1] in library) and (found[library.index(a[i+j+1])]==n):\n                    found[library.index(a[i+j+1])] = j\n            library[found.index(max(found))] = a[i]\nprint(money)\n", "def dist(a, f, i):\n    for j in range(i + 1, len(a)):\n        if f == a[j]:\n            return j\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nbooks = set()\nl = 0\npref = [0 for i in range(n)]\nfor i in range(n - 1, -1, -1):\n    pref[a[i] - 1] = max(pref[a[i] - 1], i) # i min == 0\nres = 0\nfor i in range(n):\n    if a[i] not in books:\n        if l == k:\n            for j in books:\n                if pref[j - 1] < i:\n                    l -= 1\n                    books.discard(j)\n                    break\n            if l == k:\n                m = -1\n                for j in books:\n                    if dist(a, j, i) > m:\n                        m = dist(a, j, i)\n                        ind = j\n                books.discard(ind)\n                l -= 1\n        res += 1\n        books.add(a[i])\n        l += 1\nprint(res)", "R=lambda:list(map(int,input().split()))\nn,k=R()\na=list(R())\nl=[]\nm=0\nfor i in range(n):\n if a[i]not in l:\n  m+=1\n  if len(l)<k:\n   l.append(a[i])\n  else:\n   curmin=n\n   curindex=0\n   found=[n]*len(l)\n   for j in range(len(a[i+1::])):\n    if (a[i+j+1]in l)and(found[l.index(a[i+j+1])]==n):\n     found[l.index(a[i+j+1])]=j\n   l[found.index(max(found))]=a[i]\nprint(m)\n", "import sys\nfrom bisect import bisect\nfrom collections import Counter, defaultdict\n\nl1 = sys.stdin.readline()\nl2 = sys.stdin.readline()\n\nn, k = map(int, l1.split(' '))\nbooks = list(map(int, l2.split(' ')))\n\ncost = 0\ncache = set()\n\nx = defaultdict(list)\nfor i, book_id in enumerate(books):\n\tx[book_id].append(i)\n\nfor i, book_id in enumerate(books):\n\tif book_id in cache:\n\t\tcontinue\n\n\tif len(cache) < k:\n\t\tcache.add(book_id)\n\t\tcost += 1\n\t\tcontinue\n\n\tmin_next_closest = i\n\tto_evict = next(iter(cache))\n\tfor x_id in cache:\n\t\tindices = x[x_id]\n\t\tindex = bisect(indices, i)\n\t\tif index == len(indices):\n\t\t\tto_evict = x_id\n\t\t\tbreak\n\t\tnext_closect = indices[index]\n\t\tif next_closect > min_next_closest:\n\t\t\tmin_next_closest = next_closect\n\t\t\tto_evict = x_id\n\t# print(\"To evict %s\" % to_evict)\n\tcache.remove(to_evict)\n\tcache.add(book_id)\n\tcost += 1\n\nprint(cost)", "import sys\n\ndef solve():\n    n, k = map(int, input().split())\n    a = [int(i) - 1 for i in input().split()]\n\n    kinds = len(set(a))\n\n    if kinds <= k:\n        print(kinds)\n        return\n\n    books = [False] * n\n    have = 0\n    cost = 0\n\n    for i, ai in enumerate(a):\n        if books[ai]:\n            continue\n        else:\n            if have < k:\n                books[ai] = True\n                cost += 1\n                have += 1\n            else:\n                trash = -1\n                longest = -1\n\n                for j in range(n):\n                    if books[j]:\n                        if j not in a[i + 1:]:\n                            trash = j\n                            break\n\n                        m = a[i + 1:].index(j)\n\n                        if longest < m:\n                            longest = m\n                            trash = j\n\n                assert trash != -1\n\n                books[trash] = False\n                books[ai] = True\n                cost += 1\n\n        # print([i for i in range(n) if books[i]])\n\n    print(cost)\n\ndef __starting_point():\n    solve()\n__starting_point()", "R = lambda:map(int, input().split())\nstack= []\nn, k = R()\nl = list(R())\ncurr,tot = 0,0\nfor i in range(n):\n    if l[i] not in stack:\n        if curr<k:\n            curr =  curr+1\n        else:\n            c,z=0,-1\n            for j in range(k):\n               if stack[j] not in l[i:]:\n                   z=j\n                   break\n               else:\n                   c= max(c,i+l[i:].index(stack[j]))\n            stack.pop(z) if z != -1 else stack.remove(l[c])\n        stack.insert(0,l[i])\n        tot+=1\nprint(tot)", "from collections import deque\n\n\nclass Treap():  # self.priority_comparator(root.priority, descendant.priority) == True\n    def __init__(self, key, priority, prrty_cmprtr):\n        self.key = key\n        self.priority = priority\n        self.priority_comparator = prrty_cmprtr\n        self.left = None\n        self.right = None\n\n    def merge(self, right):  # self a.k.a. left <= right ========= tested\n        if right is None:\n            return self\n        if self.priority_comparator(self.priority, right.priority):\n            root = self\n            if root.right is not None:\n                root.right = root.right.merge(right)\n            else:\n                root.right = right\n        else:\n            root = right\n            root.left = self.merge(right.left)\n        return root\n\n    def split(self, key):                   # tested\n        if self.key <= key:\n            left = self\n            if left.right is not None:\n                left.right, right = left.right.split(key)\n            else:\n                left.right, right = None, None\n        else:\n            right = self\n            if right.left is not None:\n                left, right.left = right.left.split(key)\n            else:\n                left, right.left = None, None\n        return (left, right)\n\n    def insert(self, element):     # tested\n        left, right = self.split(element.key)\n        if left is not None:\n            t = left.merge(element)\n        else:\n            t = element\n        if right is not None:\n            return t.merge(right)\n        return t\n\n    def delete(self, key):        # UN!tested\n        left, right = self.split(key)\n        left, middle = left.split(key - 1)\n        if left is not None:\n            return left.merge(right)\n        return right\n\n    def find(self, key):\n        pos = self\n        while True:\n            if key == pos.key:\n                return True\n            elif key < pos.key:\n                if pos.left is None:\n                    return False\n                pos = pos.left\n            else:\n                if pos.right is None:\n                    return False\n                pos = pos.right\n\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nfirst = [deque() for i in range(n)]\nfor i in range(n):\n    first[a[i] - 1].append(i)\nfirst[a[0] - 1].popleft()\nif not first[a[0] - 1]:\n    priority = float('inf')\nelse:\n    priority = first[a[0] - 1][0]\ntreap = Treap(a[0], priority, lambda x, y: x >= y)\nl, res = 1, 1\nfor i in range(1, n):\n    first[a[i] - 1].popleft()\n    if not first[a[i] - 1]:\n        priority = float('inf')\n    else:\n        priority = first[a[i] - 1][0]\n    if not treap.find(a[i]):\n        if l == k:\n            treap = treap.delete(treap.key)\n            l -= 1\n        if treap is not None:\n            treap = treap.insert(Treap(a[i], priority, lambda x, y: x >= y))\n        else:\n            treap = Treap(a[i], priority, lambda x, y: x >= y)\n        l += 1\n        res += 1\n    else:\n        treap = treap.delete(a[i])\n        if treap is not None:\n            treap = treap.insert(Treap(a[i], priority, lambda x, y: x >= y))\n        else:\n            treap = Treap(a[i], priority, lambda x, y: x >= y)\nprint(res)", "n,k=list(map(int,input().split()))\na=list(map(int,input().split()))\nz=[0]*81\nkz,ans=0,0\nfor i in range(n):\n    if z[a[i]]: continue\n    ans+=1\n    if k>kz:\n        z[a[i]]=1; kz+=1\n    else:\n        h=-1\n        for j in range(1,n+1):\n            if z[j]:\n                m=n+1\n                for p in range(i,n):\n                    if j==a[p]:\n                        m=p\n                        break\n                if m>h:\n                    h=m;\n                    t=j\n        z[t]=0\n        z[a[i]]=1\nprint(ans)\n", "(n,k) = (int(i) for i in input().split())\nzapross = [int(i) for i in input().split()]\nlave = 0\ncurh = set()\nfor i in range(n):\n\tif zapross[i] in curh: continue\n\tif len(curh)!=k:\n\t\tlave+=1\n\t\tcurh.add(zapross[i])\n\telse:\n\t\tlpos = -1\n\t\tcc = -1\n\t\tfor j in curh:\n\t\t\ttry:\n\t\t\t\tpos = zapross[i+1:].index(j)\n\t\t\texcept ValueError:\n\t\t\t\tcc = j\n\t\t\t\tbreak\n\t\t\tif pos>lpos:\n\t\t\t\tlpos = pos\n\t\t\t\tcc = j\n\t\tcurh.remove(cc)\n\t\tcurh.add(zapross[i])\n\t\tlave+=1\nprint(lave)", "def index(e,l,s):\n    res=[]\n    off=s\n    while True:\n        try:\n            off=l.index(e,off+1)\n        except ValueError:\n            break\n        else:\n            res.append(off)\n    if(len(res)!=0):\n        return res[0]\n    else:\n        return 10**9\n\n\nni=list(map(int,input().strip().split(' ')))\nn=ni[0]\nk=ni[1]\narr=(list(map(int,input().strip().split(' '))))\nli=[]\ncost=0\nif(k>=len(set(arr))):\n    s=set(arr)\n    print(len(s))\nelse:\n    v=1\n    i=1\n    li.append(arr[0])\n    while(v<k and i<n):\n        if(arr[i] not in li):\n            li.append(arr[i])\n            v+=1\n        i+=1\n    cost=k\n    for j in range(i,n):\n        if(arr[j] not in li):\n            mi=0\n            for h in li:\n                ind=index(h,arr,j)\n                if(ind>mi):\n                    mi=ind\n                    val=h\n            li.remove(val)\n            li.append(arr[j])\n            cost+=1\n    print(cost)\n", "(n,k) = (int(i) for i in input().split())\norder = [int(i) for i in input().split()]\ndef calculateMinCost(n,k,order):\n\tcost = 0\n\tbooks = set()\n\tfor i in range(n):\n\t\tif order[i] in books: continue\n\t\tif len(books)!=k:\n\t\t\tcost+=1\n\t\t\tbooks.add(order[i])\n\t\telse:\n\t\t\tlpos = -1\n\t\t\tcc = -1\n\t\t\tfor j in books:\n\t\t\t\ttry:\n\t\t\t\t\tpos = order[i+1:].index(j)\n\t\t\t\texcept ValueError:\n\t\t\t\t\tcc = j\n\t\t\t\t\tbreak\n\t\t\t\tif pos>lpos:\n\t\t\t\t\tlpos = pos\n\t\t\t\t\tcc = j\n\t\t\tbooks.remove(cc)\n\t\t\tbooks.add(order[i])\n\t\t\tcost += 1\n\tprint(cost)\ncalculateMinCost(n,k,order)\n", "n, k = [int(x) for x in input().split()]\nrequests = [int(x) for x in input().split()]\n\nreq_list = {}\n\ndef find_last(bucket):\n    last_book = None\n    last_date = None\n    nonlocal req_list\n    i = 0\n    for item in bucket:\n        #print(item, req_list)\n        if last_book is None:\n            last_book = item\n            if len(req_list[item]) < 1:\n                last_date = float('inf')\n                return item, i\n            else:\n                last_date = req_list[item][0]\n            index = i\n        elif len(req_list[item]) >= 1 and req_list[item][0] > last_date:\n            last_book = item\n            last_date = req_list[item][0]\n            index = i\n        elif len(req_list[item]) < 1 and last_date < float('inf'):\n            return item, i\n        i += 1\n    return last_book, index\n\ndef update_reqlist(book):\n    nonlocal req_list\n    req_list[book] = req_list[book][1:]\n\n\nfor i in range(n):\n    if requests[i] in req_list:\n        req_list[requests[i]].append(i)\n    else:\n        req_list[requests[i]] = [i]\n\nbucket = []\nbucket_size = 0\ncost = 0\nfor book in requests:\n    if book in bucket:\n        update_reqlist(book)\n        continue\n    if bucket_size < k:\n        bucket.append(book)\n        bucket_size += 1\n        cost += 1\n        update_reqlist(book)\n    else:\n        last_book, index = find_last(bucket)\n        if len(bucket) > 1:\n            bucket.pop(index)\n        else:\n            bucket = []\n        bucket.append(book)\n        update_reqlist(book)\n        cost += 1\n    #print(bucket, req_list)\n\n#print(req_list)\nprint(cost)", "n,k=list(map(int,input().split()))\n\na=list(map(int,input().split()))\n\nz=[0]*81\n\nkz,ans=0,0\n\nfor i in range(n):\n\n    if z[a[i]]: continue\n\n    ans+=1\n\n    if k>kz:\n\n        z[a[i]]=1; kz+=1\n\n    else:\n\n        h=-1\n\n        for j in range(1,n+1):\n\n            if z[j]:\n\n                m=n+1\n\n                for p in range(i,n):\n\n                    if j==a[p]:\n\n                        m=p\n\n                        break\n\n                if m>h:\n\n                    h=m;\n\n                    t=j\n\n        z[t]=0\n\n        z[a[i]]=1\n\nprint(ans)\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "R=lambda:map(int,input().split())\nn,k=R()\na=list(R())\nl=[]\nm=0\nfor i in range(n):\n if a[i]not in l:\n  m+=1\n  if len(l)<k:\n   l.append(a[i])\n  else:\n   curmin=n\n   curindex=0\n   found=[n]*len(l)\n   for j in range(len(a[i+1::])):\n    if (a[i+j+1]in l)and(found[l.index(a[i+j+1])]==n):\n     found[l.index(a[i+j+1])]=j\n   l[found.index(max(found))]=a[i]\nprint(m)", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\ninventory = set()\nbought = 0\nfor i in range(n):\n    if a[i] not in inventory:\n        if len(inventory) == k:\n            farthest_time = 0\n            farthest = 0\n            for v in inventory:\n                try:\n                    far = a.index(v, i + 1)\n                    if far > farthest_time:\n                        farthest_time = far\n                        farthest = v\n                except ValueError:\n                    farthest_time = 10000\n                    farthest = v\n            inventory.remove(farthest)\n        inventory.add(a[i])\n        bought += 1\n\nprint(bought)\n", "n, k = list(map(int, input().split()))\n\na = list(map(int, input().split())) + [-1]\n\ncost = 0\nlib = []\n\nfor i in range(n):\n    if a[i] in lib:\n        continue\n    if len(lib) < k:\n        lib.append(a[i])\n        cost += 1\n    else:\n        far = 0\n        for ind, j in enumerate(lib):\n            o = i+1\n            while o < n+1 and a[o] != j:\n                o += 1\n            if o > far:\n                far = min(o, n-1)\n                maxindex = ind\n                maxele = j\n                if o == n:\n                    break\n        lib[maxindex] = a[i]\n        cost += 1\n\nprint(cost)\n"]