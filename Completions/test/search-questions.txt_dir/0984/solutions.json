["from collections import deque\n\nnodes = []\nparents = []\nvalues = []\nbroken = []\nupperBound = []\nlowerBound = []\n\nn = int(input())\n\nfor _ in range(n):\n    v, l, r = map(int, input().split())\n    nodes.append((v, l - 1, r - 1))\n    parents.append(-1)\n    values.append(v)\n    broken.append(False)\n    upperBound.append(10 ** 9)\n    lowerBound.append(-10 ** 9)\n\nfor i, (v, l, r) in enumerate(nodes):\n    if l > -1:\n        parents[l] = i\n    if r > -1:\n        parents[r] = i\n\nroot = -1\nfor i in range(n):\n    if parents[i] == -1:\n        root = i\n\nproc = deque([root])\nwhile len(proc) > 0:\n    node = proc.popleft()\n    v, l, r = nodes[node]\n    if l > -1:\n        proc.append(l)\n        upperBound[l] = min(upperBound[node], v)\n        lowerBound[l] = lowerBound[node]\n        if not (lowerBound[l] <= nodes[l][0] <= upperBound[l]):\n            broken[l] = True\n    if r > -1:\n        proc.append(r)\n        upperBound[r] = upperBound[node]\n        lowerBound[r] = max(lowerBound[node], v)\n        if not (lowerBound[r] <= nodes[r][0] <= upperBound[r]):\n            broken[r] = True\n        \ns = set([])\nfor v, b in zip(values, broken):\n    if not b:\n        s.add(v)\n\nans = 0\nfor v in values:\n    if v not in s:\n        ans += 1\n\nprint(ans)", "#!/usr/bin/env python3\n\n# solution after hint:(\n# though it was not necessary\n\n# reduced recursion version\n\nn = int(input().strip())\nvlrs = [tuple(map(int, input().strip().split())) for _ in range(n)]\n# shift numeration\nvlrs = [(v, l - (0 if l < 0 else 1), r - (0 if r < 0 else 1)) for v, l, r in vlrs]\n\nisroot = [True for _ in range(n)]\nfor v, l, r in vlrs:\n\tif l != -1:\n\t\tisroot[l] = False\n\tif r != -1:\n\t\tisroot[r] = False\n\nroot = isroot.index(True)\nvs = [v for v, l, r in vlrs]\nvmin = min(vs)\nvmax = max(vs)\n\nfound = set()\ndef DFS(U, vl, vr):\n\twhile vlrs[U].count(-1) == 1:\n\t\tv, L, R = vlrs[U]\n\t\tif vl <= v <= vr:\n\t\t\tfound.add(v)\n\t\tif L != -1:\n\t\t\tU, vl, vr = L, vl, min(v, vr)\n\t\telse:\n\t\t\tU, vl, vr = R, max(v, vl), vr\n\tv, L, R = vlrs[U]\n\tif vl <= v <= vr:\n\t\tfound.add(v)\n\tif L != -1 and R != -1:\n\t\tDFS(L, vl, min(v, vr))\n\t\tDFS(R, max(v, vl), vr)\n\nDFS(root, vmin, vmax)\n\nres = sum(1 for v in vs if v not in found)\n\t\nprint (res)\n"]