["def main():\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        u, v = list(map(int, input().split()))\n        u -= 1\n        v -= 1\n        edges.append((u, v))\n\n    colors = list(map(int, input().split()))\n    suspect = [(u, v) for (u, v) in edges if colors[u] != colors[v]]\n\n    if len(suspect) == 0:\n        print(\"YES\")\n        print(1)\n    else:\n        cands = set(suspect[0])\n        for u, v in suspect:\n            cands &= set([u, v])\n\n        if len(cands) == 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            e = list(cands)[0]\n            print(e + 1)\n\nmain()\n", "import sys\n\nclass UnionFind:\n    def __init__(self, sz):\n        self.__ranks   = [1] * sz\n        self.__sizes   = [1] * sz\n        self.__parents = [ i for i in range(sz) ]\n\n    def find_parent(self, x):\n        if x == self.__parents[x]:\n            return x\n        else:\n            self.__parents[x] = self.find_parent( self.__parents[x] )\n            return self.__parents[x]\n\n    def same(self, x, y):\n        return self.find_parent(x) == self.find_parent(y)\n\n    def unite(self, x, y):\n        px = self.find_parent(x)\n        py = self.find_parent(y)\n        if px == py:\n            return\n        if self.__ranks[px] > self.__ranks[py]:\n            self.__parents[py] = px\n            self.__sizes[px] += self.__sizes[py]\n        else:\n            self.__parents[px] = py\n            self.__sizes[py] += self.__sizes[px]\n            if self.__ranks[px] == self.__ranks[py]:\n                self.__ranks[py] += 1\n\n    def size(self, n):\n        return self.__sizes[n]\n#### \n\ndef main():\n    n = int(input())\n\n    edge = {}\n    for i in range(n - 1):\n        u,v = list(map(int, sys.stdin.readline().split()))\n        if u not in edge:\n            edge[u] = []\n        if v not in edge:\n            edge[v] = []\n        edge[u].append(v)\n        edge[v].append(u)\n    \n    colors = [-1] * (n + 1)\n    for i,c in enumerate(map(int, sys.stdin.readline().split())):\n        colors[i + 1] = c\n\n    uf = UnionFind(n + 1)\n    for u in list(edge.keys()):\n        for v in edge[u]:\n            if colors[u] == colors[v]:\n                uf.unite(u,v)\n\n    tree = set()\n    for v in range(1,n+1):\n        tree.add(uf.find_parent(v))\n\n    target_v = -1\n    ok = False\n    for u in range(1,n+1):\n        cnt = set()\n        for v in edge[u]:\n            cnt.add(uf.find_parent(v))\n        if len(cnt) == len(tree) - (1 if uf.size(uf.find_parent(u)) == 1 else 0):\n            ok = True\n            target_v = u\n            break\n\n    if ok:\n        print(\"YES\")\n        print(target_v)\n    else:\n        print(\"NO\")\n\ndef __starting_point():\n    main()\n\n\n\n__starting_point()", "n = int(input())\ne = [list(map(int, input().split())) for i in range(n - 1)]\nc = list(map(int, input().split()))\nec, v = [0] * n, 0\nfor ea, eb in e:\n    if c[ea - 1] != c[eb - 1]:\n        ec[ea - 1] += 1\n        ec[eb - 1] += 1\n        v += 1\nif v == max(ec):\n    print('YES', ec.index(v) + 1, sep='\\n')\nelse:\n    print('NO')", "n = int(input())\na = []\nb = []\nfor i in range(n-1):\n\tx,y = list(map(int, input().split()))\n\ta.append(x)\n\tb.append(y)\n\ncolors = list(map(int, input().split()))\n\n\nlehet = []\nfor i in range(n-1):\n\tif colors[a[i]-1] != colors[b[i]-1]:\n\t\tif len(lehet) == 0:\n\t\t\tlehet += [a[i], b[i]]\n\t\telse:\n\t\t\tif a[i] in lehet and b[i] in lehet:\n\t\t\t\tprint(\"NO\")\n\t\t\t\treturn\n\t\t\telif a[i] in lehet:\n\t\t\t\tlehet = [a[i]]\n\t\t\telif b[i] in lehet:\n\t\t\t\tlehet = [b[i]]\n\t\t\telse:\n\t\t\t\tprint(\"NO\")\n\t\t\t\treturn\nprint(\"YES\")\nif len(lehet) == 0:\n\tlehet = [1]\nprint(lehet[0])\n\t\n", "n=int(input())\n\ne=[]\n\nv=[]\n\nfor i in range(n-1):\n\n    e.append(list(map(int,input().split())))\n\nc=[-1]+list(map(int,input().split()))\n\nfor i in e:\n\n    if c[i[0]]!=c[i[1]]: v.append(i)\n\nif not v:\n\n    print('YES')\n\n    print(1)\n\nelse:\n\n    s=set(v[0]);list([s.intersection_update(set(x)) for x in v])\n\n    if s:\n\n        print('YES')\n\n        print(list(s)[0])\n\n    else: print('NO')\n\n\n\n# Made By Mostafa_Khaled\n", "import math\n\ngraph = []\ncolors = []\n\n\ndef dfs(u, p, color) -> bool:\n    if color != colors[u]:\n        return False\n    for v in graph[u]:\n        if v == p:\n            continue\n        if not dfs(v, u, color):\n            return False\n    return True\n\n\ndef check(u):\n    for v in graph[u]:\n        if not dfs(v, u, colors[v]):\n            return False\n    return True\n\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        graph.append([])\n    for i in range(n-1):\n        u, v = [int(x) - 1 for x in input().split()]\n        graph[u].append(v)\n        graph[v].append(u)\n    nonlocal colors\n    colors += list(map(int, input().split()))\n    for u in range(n):\n        for v in graph[u]:\n            if colors[u] != colors[v]:\n                if check(u):\n                    print(\"YES\")\n                    print(u + 1)\n                    return\n                elif check(v):\n                    print(\"YES\")\n                    print(v + 1)\n                    return\n                else:\n                    print(\"NO\")\n                    return\n    print(\"YES\")\n    print(1)\n\nmain()\n", "import sys\nsys.setrecursionlimit(10**9)\ndef dfs(a,pre=-1,par=None):\n    nonlocal aa\n    for i in adj[a]:\n      #  print(i,pre,a,par)\n        if i==par:\n            continue\n        if pre==-1:\n            dfs(i,it[i],a)\n        elif pre!=it[i]:\n            aa=True\n            return ''\n        else:\n            dfs(i,it[i],a)\n            \nn=int(input())\ned=[]\nadj=[[] for i in range(n)]\n\nfor _ in range(n-1):\n    a,b=map(int,input().split())\n    ed.append([a-1,b-1])\n    adj[a-1].append(b-1)\n    adj[b-1].append(a-1)\nit=list(map(int,input().split()))\nst=False\nfor i in ed:\n    if it[i[0]]!=it[i[1]]:\n        st=True\n        e=i\n        break\nif not(st):\n    print(\"YES\")\n    print(1)\nelse:\n    ans=True\n    aa=False\n    dfs(e[0])\n   # print(aa)\n    if aa==False:\n        print(\"YES\",e[0]+1,sep=\"\\n\")\n    else:\n        aa=False\n        dfs(e[1])\n        if aa==False:\n            print(\"YES\")\n            print(e[1]+1)\n        else:\n            print(\"NO\")\n\n    \n    \n", "n = int(input())\nes = []\nrs = []\nfor i in range(n-1) :\n    es.append(list(map(int , input().split())))\nvs = list(map(int , input().split()))\nfor i in es :\n    if vs[i[0] -1 ] != vs[i[1] - 1 ] :\n        rs.append(i)\nif rs == [] :\n    print('YES')\n    print(1)\n    return\nfor r1 in rs[0] :\n    for i in rs :\n        if r1 != i[0] and r1 != i[1] :\n            break\n    else :\n        print('YES')\n        print(r1)\n        return\nprint('NO')", "n = int(input())\nu = []\nv = []\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    u.append(a)\n    v.append(b)\n \nc = [0] + [int(x) for x in input().split()]\n \ne = 0\ndic = {}\n \nfor i in range(1, n+1):\n    dic[i] = 0\n \ndef plus(dic, n):\n    if n in dic:\n        dic[n] += 1\n    else:\n        dic[n] = 1\n \nfor i in range(n-1):\n    if c[u[i]] != c[v[i]]:\n        e += 1\n        dic[u[i]] += 1\n        dic[v[i]] += 1\n \nfor i in range(1, n+1):\n    if dic[i] == e:\n        print ('YES', i,sep='\\n')\n        return\n \nprint (\"NO\")\n", "n = int(input())\nu,v = [], []\nfor i in range(n-1):\n    a, b = list(map(int, input().split()))\n    u.append(a)\n    v.append(b)\n \ncolors = [0] + [int(x) for x in input().split()]\n \nmaximumDifference = 0\ndifferences = {i:0 for i in range(1, n+1)}\n\nfor i in range(n-1):\n    vertex1 = u[i]\n    vertex2 = v[i]\n    \n    if colors[vertex1] != colors[vertex2]:\n        maximumDifference += 1\n        differences[vertex1] += 1\n        differences[vertex2] += 1\n\nif maximumDifference in list(differences.values()):\n    print ('YES')\n    print(list(differences.values()).index(maximumDifference)+1)\nelse:\n    print (\"NO\")\n", "n = int(input())\narr = []\nbrr = []\nfor i in range(n-1):\n    u,v = list(map(int,input().split()))\n    arr.append(u)\n    brr.append(v)\ncolor = list(map(int,input().split()))\n\nans = []\nfor i in range(n-1):\n    if color[arr[i]-1]!=color[brr[i]-1]:\n        if ans==[]:\n            ans+=[arr[i],brr[i]]\n        else:\n            if arr[i] in ans and brr[i] in ans:\n                print(\"NO\")\n                return\n            elif arr[i] in ans:\n                ans = [arr[i]]\n            elif brr[i] in ans:\n                ans = [brr[i]]\n            else:\n                print(\"NO\")\n                return\nprint(\"YES\")\nif len(ans)==0:\n    ans.append(1)\nprint(ans[0])", "import math as mt \nimport sys,string\ninput=sys.stdin.readline\nimport random\nfrom collections import deque,defaultdict\nL=lambda : list(map(int,input().split()))\nLs=lambda : list(input().split())\nM=lambda : list(map(int,input().split()))\nI=lambda :int(input())\ndef bfs(a):\n    w=g[a]\n    v=[0]*n\n    for i in w:\n        v[i]=1\n    v[a]=1\n    j=0\n    while(j<len(w)):\n        k=w[j]\n        for i in g[k]:\n            if(v[i]==0):\n                if(l[i]==l[k]):\n                    w.append(i)\n                    v[i]=1\n                else:\n                    return False\n        j+=1\n    return True\nn=I()\ng=[]\nfor i in range(n):\n    g.append([])\nx=[]\nfor _ in range(n-1):\n    a,b=M()\n    a-=1\n    b-=1\n    x.append((a,b))\n    g[a].append(b)\n    g[b].append(a)\nl=L()\nfor i in range(n-1):\n    if(l[x[i][0]]!=l[x[i][1]]):\n        if(bfs(x[i][0])):\n            print(\"YES\")\n            print(x[i][0]+1)\n            return\n        if(bfs(x[i][1])):\n            print(\"YES\")\n            print(x[i][1]+1)\n            return\n        else:\n            print(\"NO\")\n            return\nprint(\"YES\")\nprint(\"1\")\n", "import collections\nimport sys\n\n\ndef read_ints():\n    return [int(x) for x in sys.stdin.readline().strip().split()]\n\n\ndef main():\n    N = read_ints()[0]\n    edges = []\n    vx_to_neighbor_colors = collections.defaultdict(set) \n    for _ in range(N - 1):\n        u, v = read_ints()\n        u -= 1\n        v -= 1\n        edges.append((u, v))\n    colors = read_ints()\n\n    vx_to_cnt = collections.Counter()\n    e_cnt = 0\n    for e in edges:\n        if colors[e[0]] == colors[e[1]]:\n            continue\n        vx_to_cnt[e[0]] += 1\n        vx_to_cnt[e[1]] += 1\n        e_cnt += 1\n\n    if e_cnt == 0:\n        return 1  # any\n    if e_cnt == 1:\n        return 1 + list(vx_to_cnt.keys())[0]\n\n    root = None\n    for vx, cnt in list(vx_to_cnt.items()):\n        if cnt == e_cnt:\n            if root is not None:\n                return None\n            root = 1 + vx\n        elif cnt != 1:\n            return None\n    return root\n\n\ndef __starting_point():\n    root = main()\n    if root is not None:\n        print(f'YES\\n{root}')\n    else:\n        print('NO')\n\n__starting_point()", "n = int(input())\nedges = list(list(map(int, input().split())) for _ in range(n-1)) \ncolors = list(map(int, input().split()))\n\nedge_cnt = 0\npnt_cnt = {0: 0}\nfor a, b in edges:\n    a -= 1 ; b -= 1\n    if colors[a] != colors[b]:\n        edge_cnt += 1\n        pnt_cnt[a] = pnt_cnt.get(a, 0)+1\n        pnt_cnt[b] = pnt_cnt.get(b, 0)+1\n\nfor k, v in list(pnt_cnt.items()):\n    if v == edge_cnt:\n        print(\"YES\")\n        print(k+1)\n        break\nelse:\n    print(\"NO\")\n", "# import io, os\n# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nimport sys\n# sys.stdin=open('input.txt','r')\n# sys.stdout=open('output.txt','w')\ninput=sys.stdin.readline\n# sys.setrecursionlimit(300010)\nMOD = 1000000007\nMOD2 = 998244353\nii = lambda: int(input().strip('\\n'))\nsi = lambda: input().strip('\\n')\ndgl = lambda: list(map(int,input().strip('\\n')))\nf = lambda: map(int, input().strip('\\n').split())\nil = lambda: list(map(int, input().strip('\\n').split()))\nls = lambda: list(input().strip('\\n'))\nlsi = lambda: [int(i) for i in ls()]\nlet = 'abcdefghijklmnopqrstuvwxyz'\nfor _ in range(1):\n    n=ii()\n    edges=[il() for i in range(n-1)]\n    clr=[0]+il()\n    deg=[0]*(n+1)\n    tot=0\n    for i in edges:\n        if clr[i[0]]!=clr[i[1]]:\n            deg[i[0]]+=1\n            deg[i[1]]+=1\n            tot+=1\n    for i in range(1,n+1):\n        if deg[i]==tot:\n            print('YES\\n'+str(i));return\n    print('NO')", "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nn=int(input())\na=[]\nb=[]\nfor i in range(n-1):\n\tx,y=map(int,input().split())\n\ta.append(x)\n\tb.append(y)\nl=list(map(int,input().split()))\nans=[]\nfor i in range(n-1):\n\tif l[a[i]-1]!=l[b[i]-1]:\n\t\tif len(ans)==0:\n\t\t\tans=[a[i],b[i]]\n\t\telse:\n\t\t\tif a[i] in ans and b[i] in ans:\n\t\t\t\tprint(\"NO\")\n\t\t\t\treturn\n\t\t\telif a[i] in ans:\n\t\t\t\tans=[a[i]]\n\t\t\telif b[i] in ans:\n\t\t\t\tans=[b[i]]\n\t\t\telse:\n\t\t\t\tprint(\"NO\")\n\t\t\t\treturn\nprint(\"YES\")\nif ans:\n\tprint(ans[0])\nelse:\n\tprint(1)"]