["class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        if not queries:\n            return []\n        p = list(range(1, m+1))\n        res = []\n        for i in queries:\n            z = p.index(i)\n            res.append(z)\n            del p[z]\n            p.insert(0,i)\n        return res\n            \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        P = collections.deque(list(range(1,m+1)))\n        \n        res = []\n        \n        for q in queries:\n            res.append( P.index(q) )\n            del P[res[-1]]\n            P.appendleft( q )\n            # print(P)\n        \n        return res\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        P = [i+1 for i in range(m)]\n        res = []\n        for q in queries:\n            i = P.index(q)\n            res.append(i)\n            P = [q] + P[:i] + P[(i+1):]\n        return res", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        res = []\n        P = list(range(1, m+1))\n        print(P)\n        for q in queries:\n            i = P.index(q)\n            res.append(i)\n            P = [q] + P[:i] + P[i+1:]\n            \n        return res\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        data, result = list(range(1, m + 1)), []\n        for item in queries:\n            idx = data.index(item)\n            data = [data[idx]] + data[:idx] + (data[idx + 1:] if idx + 1 < len(data) else [])\n            result.append(idx)\n        return result", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \n        P_lst  = [i for i in range(1,m+1)]\n        q_list = []\n        for i in range(0,len(queries)):\n            target = queries[i]\n            for j in range(0,len(P_lst)):\n                \n                if  P_lst[j] == target:\n                    q_list.append(j)\n                    x =P_lst.pop(j)\n                    P_lst.insert(0,x)\n                    break\n        return q_list\n        \n                \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        if len(queries)==0:\n            return []\n        P=[]\n        for i in range(m):\n            P.append(i+1)\n        res=[]\n        for i in queries:\n            res.append(P.index(i))\n            P.remove(i)\n            P=[i]+P[:]\n        return res\n            \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        P = [i for i in range(1,m+1)]\n        \n        ans = []\n        for querie in queries:\n            idx = P.index(querie)\n            del P[idx]\n            P = [querie] + P\n            ans.append(idx)\n            \n        return ans\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        permutations = [permutation for permutation in range(1, m + 1)]\n\n        result = []\n        for query in queries:\n            for pindex, permutation in enumerate(permutations):\n                if permutation == query:\n                    result.append(pindex)\n                    del permutations[pindex]\n                    permutations.insert(0, permutation)\n                    break\n        print(result)\n        print(permutations)\n        \n        return result\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        original = list(range(1, m + 1))\n        results = []\n        for q in queries:\n            res = 0\n            for ind, el in enumerate(original):\n                if el == q:\n                    res = ind\n                    break\n            results.append(res)\n            temp = original.pop(res)\n            original = [temp] + original\n        \n        return results\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p=[]\n        for i in range (1,m+1):\n           p.append(i) \n        l=[]\n        \n        for i in range (0,len(queries)):\n            for j in range (0,m):\n                if p[j]==queries[i]:\n                    k=p.pop(j)\n                    p.insert(0,k)\n                    l.append(j)\n                    break\n        return l\n            \n                \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        A = list(range(1, m + 1))\n        res = []\n        for target in queries:\n            for i, num in enumerate(A):\n                if num == target:\n                    res.append(i)\n                    index = i\n                    break\n\n            element = A[index]\n            A.pop(index)\n            A.insert(0, element)\n        \n        return res", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        retIndexlist = []\n        p = [i+1 for i in range(m)]\n\n        for q in queries: \n            # get index\n            idx = p.index(q)\n            retIndexlist.append(idx)\n            # pop\n            p.pop(idx)\n            # move to front\n            p.insert(0, q)\n        \n        return retIndexlist", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p = [i for i in range(1, m+1)]\n        res = []\n        for query in queries:\n            index = p.index(query)\n            res.append(index)\n            p.remove(query)\n            p = [query] + p\n        return res\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        out = []\n        P = [i for i in range(1,m+1)]\n        for i in queries:\n            #num = P.index(i)\n            out.append(P.index(i))\n            P.insert(0, P.pop(P.index(i)))\n        return out", "from collections import deque\nclass Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p = deque(list(range(1,m+1)))\n        result = []\n        for q in queries:\n            for i,n in enumerate(p):\n                if q == n:\n                    p.remove(n)\n                    p.appendleft(n)\n                    result.append(i)\n                    break\n        return result\n        \n                    \n            \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p = [i for i in range(1,m+1)]\n\n        def find(p,q):\n            for i in range(len(p)):\n                if p[i] == q:\n                    return i\n\n        def update(p,i):\n            return [p[i]] + p[:i] + p[i+1:]\n\n        res = []\n\n        for i in range(len(queries)):\n            q = find(p,queries[i])\n            res.append(q)\n            p = update(p,q)\n\n        return res\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        permu = list(range(1, m + 1))\n        \n        pos = []\n        \n        for i in queries:\n            p = permu.index(i)\n            pos.append(p)\n            for j in range(p - 1, -1, -1):\n                permu[j + 1] = permu[j]\n            \n            permu[0] = i\n        \n        return pos\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        q=deque([])\n        ans=[]\n        for i in range(1,m+1,1):\n            q.append(i)\n            \n        for j in queries:\n            ans.append(q.index(j))\n            q.remove(j)\n            q.appendleft(j)\n        \n        return ans", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p = []\n        res = []\n        for i in range(1, m + 1):\n            p.append(i)\n        for n in queries:\n            pos = 0\n            while p[pos] != n and pos < m:\n                pos += 1\n            res.append(pos)\n            del p[pos]\n            p.insert(0, n)\n        return res", "from collections import OrderedDict\nclass Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        ordered =   OrderedDict.fromkeys(list(range(1,m+1)))\n        result  =   []\n        for query in queries:\n            idx     =   0\n            for key in ordered:\n                if key  ==  query:\n                    break\n                idx     +=  1\n            result.append(idx)\n            ordered.move_to_end(query,last=False)\n        return result\n            \n            \n       \n            \n            \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        a=[i for i in range(1,m+1)]\n        x={}\n        for i in range(len(a)):\n            x[a[i]]=i   \n        b=[]\n        for i in queries:\n            b.append(x[i])\n            a=[i]+a[:x[i]]+a[x[i]+1:]\n            for j in range(x[i]+1):\n                x[a[j]]=j\n            \n        return b  \n            \n            \n            \n        \n                \n        \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        res = []\n        arr = [i for i in range(1,m+1)]\n        for q in queries:\n            idx = arr.index(q)\n            res.append(idx)\n            arr.insert(0, arr.pop(idx))\n        \n        return res\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        ans = []\n        arr = list(range(1,m+1))\n        \n        for j in queries:\n            for i in range(m):\n                if j==arr[i]:\n                    ans.append(i)\n                    x = arr.pop(i)\n                    arr.insert(0, x)\n        \n        return ans\n                \n            \n", "class linkedNode:\n    \n    def __init__(self, val):\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        head = linkedNode(-1)\n        pointer = head\n        \n        for i in range(1, m+1):\n            newLN = linkedNode(i)\n            newLN.prev = pointer\n            pointer.next = newLN\n            pointer = pointer.next\n        pointer.next = linkedNode(-1)\n        pointer.next.prev = pointer\n        \n        ans = []\n        for query in queries:\n            i = 0\n            pointer = head.next\n            while pointer.val != query:\n                pointer = pointer.next\n                i += 1\n            ans.append(i)\n            \n            pointer.prev.next = pointer.next\n            pointer.next.prev = pointer.prev\n            \n            pointer.next = head.next\n            head.next.prev = pointer\n            head.next = pointer\n            pointer.prev = head\n            \n        return ans", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        rtnlst = []\n        P = []\n        for n in range (1, m +1):\n            P.append(n)\n        for q in queries: \n            for p in range(0,len(P)):\n                if (P[p] == q):\n                    rtnlst.append(p)\n            \n            P.pop(rtnlst[-1])\n            P = [q] + P\n           \n        return rtnlst", "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        \nclass Linked:\n    def __init__(self, m):\n        self.head = Node(1)\n        cur = self.head\n        for n in range(2, m+1):\n            cur.next = Node(n)\n            cur = cur.next\n    \n    def print_me(self):\n        cur = self.head \n        while cur:\n            print(cur.val)\n            cur = cur.next\n        \n    def move_to_front(self, val):\n        if(self.head.val == val):\n            return 0\n        cur = self.head\n        i = 0\n        #print(val)\n        while cur.val != val:\n            prev = cur\n            cur = cur.next\n            i += 1\n        prev.next = cur.next\n        cur.next = self.head\n        self.head = cur\n        return i\n\nclass Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        linked = Linked(m)\n        #linked.print_me()\n        \n        result = []\n        for num in queries:\n            result.append(linked.move_to_front(num))\n            #linked.print_me()\n        return result", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        P=[i+1 for i in range(m)]\n        res=[]\n        for query in queries:\n            idx=P.index(query)\n            res.append(idx)\n            pos=idx\n            while(pos>0):\n                P[pos]=P[pos-1]\n                pos-=1\n            P[0]=query\n        return res\n            \n            \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        result = []\n        result += [queries[0] -1]\n        for ind, q in enumerate(queries[1:]):\n            ind = ind+1\n            if q > max(queries[:ind]): # nothing higher than this element has moved\n                result +=[q-1]\n            else: \n                equal_q = [i for i in range(ind) if q == queries[i]]\n                if len(equal_q) >0:\n                    diff = len(list(set(queries[equal_q[-1]+1:ind])))\n                    result += [diff]\n                else: #sum movement of all elements that are higher. \n                    sum_higher = len([x for x in list(set(queries[:ind])) if x> q])\n                    result +=[q+sum_higher -1]\n        return result\n    \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        l = list(range(1,m+1))\n        n = 0\n        p = [0]*len(queries)\n        while n != len(queries):\n            for k in range(len(queries)):\n                for i in range(len(l)):\n                    if l[i] == queries[k]:\n                        l.insert(0,l.pop(i))\n                        p[n] = i\n                        n += 1\n        return p", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        l = list(range(1,m+1))\n        n = 0\n        p = [0]*len(queries)\n        for k in range(len(queries)):\n            for i in range(len(l)):\n                if l[i] == queries[k]:\n                    l.insert(0,l.pop(i))\n                    p[n] = i\n                    n += 1\n        return p", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        if m == 1:\n            return [0 for _ in range(len(queries))]\n        p = [i+1 for i in range(m)]\n        res = []\n        for i in queries:\n            prev = p[0]\n            if prev == i:\n                res.append(0)\n            else:\n                j = 1\n                while j < m:\n                    tmp = p[j]\n                    p[j] = prev\n                    if tmp == i:\n                        p[0] = tmp\n                        res.append(j)\n                        break\n                    prev = tmp    \n                    j += 1\n        return res", "class Solution:\n    def processQueries(self,queries,m):\n        P = list(range(1,m+1))\n        return [n for x in queries if not P.insert(0,P.pop((n := P.index(x))))]", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        result = []\n        coord = [x for x in range(0, m)]\n        \n        for num in queries:\n            \n            before = coord[num - 1]\n            result.append(before)\n            \n            # after   \n            coord = [x+1 if x < before else x for x in coord]\n            coord[num - 1] = 0\n                \n        return result\n            \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        result = []\n        coord = [x for x in range(0, m)]\n        \n        for num in queries:\n            \n            before = coord[num - 1]\n            result.append(before)\n            \n            # after   \n            coord = [x+1 if x < before else x for x in coord]\n            coord[num - 1] = 0\n                \n        return result\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \n        pivot = []\n        for q in queries:\n            pos = q-1\n            for piv in pivot:\n                pos = self.getpos(pos, piv)\n            pivot.append(pos)\n            \n        return pivot\n        \n    def getpos(self, pos, piv):\n        if pos > piv:\n            return pos\n        elif pos == piv:\n            return 0\n        else:\n            return pos+1\n        \n        \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \n        perm=[i+1 for i in range(m)]\n        out=[]\n        \n        for i in queries:\n            \n            idx=perm.index(i)\n            \n            out.append(idx)\n            \n            temp=perm[idx]\n            \n            while(idx>0):\n                perm[idx]=perm[idx-1]\n                idx-=1\n                \n            perm[idx]=temp\n            \n        return out", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        result = []\n        perm = [ i for i in range(1,m+1)]\n        for element in queries:\n            ind = perm.index(element)\n            result.append(ind)\n            tmp = [element]\n            tmp.extend(perm[:ind])\n            tmp.extend(perm[ind+1:])\n            perm = tmp\n            print(perm)\n            \n        return result", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \n        result = []\n        p = [i for i in range(1, m + 1)]\n        \n        for query in queries:       \n            for index, value in enumerate(p): \n                if value == query:\n                    result.append(index)\n                    # p[0] = value\n                    \n                    depCounter = index\n                    while depCounter >  0 :\n                        p[depCounter] = p[depCounter - 1]\n                        depCounter -= 1\n\n                    p[0] =value\n                    break\n        return result", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \n        result = []\n        p = [i for i in range(1, m + 1)]\n        \n        \n        for query in queries:\n            for index, value in enumerate(p): \n                if value == query:\n                    result.append(index)\n                    # p[0] = value\n                    \n                    depCounter = index\n                    while depCounter >  0 :\n                        p[depCounter] = p[depCounter - 1]\n                        depCounter -= 1\n\n                    p[0] =value\n                    break\n        return result", "class Node:\n    def __init__(self, val = None):\n        self.val = val\n        self.next = None\nclass Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        root = Node(0)\n        cur = root\n        for i in range(1, m+1):\n            newNode = Node(i)\n            cur.next = newNode\n            cur = newNode\n        \n        res = []\n        for i in range(len(queries)):\n            targetVal = queries[i]\n            cur = root\n            position = 0\n            while cur.next is not None:\n                if cur.next.val == targetVal:\n                    res.append(position)\n                    \n                    # add at the beginning\n                    temp = cur.next\n                    cur.next = temp.next\n                    temp.next = root.next\n                    root.next = temp\n                    break\n                else:\n                    cur = cur.next\n                    position += 1\n        return res", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p = [i for i in range(1, m+1)]\n        res = []\n        for q in queries:\n            for i in range(len(p)):\n                if p[i] == q:\n                    res.append(i)\n                    p.remove(q)\n                    p.insert(0, q)\n        return res", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p = []\n        res = []\n        for x in range(m):\n            p.append(x+1)\n        for x in queries:\n            idx = p.index(x)\n            res.append(idx)\n            p.insert(0, p.pop(idx))\n            \n        return res", "import bisect\n\nclass Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        perm = list(range(1, m+1))\n        res = []\n        for e in queries:\n            idx = perm.index(e)\n            res.append(idx)\n            perm = [perm[idx]] + [r for i, r in enumerate(perm) if i != idx]\n        return res", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        l=[i for i in range(1,m+1)]\n        ans=[]\n        for q in queries :\n            d={}\n            for index,element in enumerate(l):\n                d[element]=index\n            ans.append(d[q])\n            x=l.pop(d[q])\n            l=[x]+l\n        return ans", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        d={i:i-1 for i in range(1,m+1)}\n        ans=[]\n        for i in queries:\n            x=d[i]\n            ans.append(x)\n            \n            for j in list(d.keys()):\n                if d[j]<x:\n                    d[j]+=1\n            d[i]=0\n        \n        return ans\n            \n                    \n             \n            \n        \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        permutations = [permutation for permutation in range(1, m + 1)]\n\n        result = []\n        for qindex, query in enumerate(queries):\n            for pindex, permutation in enumerate(permutations):\n                if permutation == query:\n                    result.append(pindex)\n                    permutations = [permutation] + permutations[0:pindex] + permutations[pindex + 1:]\n                    print(permutations)\n                    break\n        print(result)\n        print(permutations)\n        \n        return result", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        d = {k : k+1 for k in range(m)}\n        result = []\n        for q in queries:\n            current_pos = self.findPos(d, q)\n            result.append(current_pos)\n            while current_pos > 0:\n                d[current_pos] = d[current_pos-1]\n                current_pos -= 1\n            d[0] = q\n        return result\n    \n    def findPos(self, d, q):\n        for idx, val in list(d.items()):\n            if val == q:\n                return idx\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        cache = {x:x-1 for x in range(1,m+1)}\n        n = len(queries)\n        ans = [0]*n\n        \n        for i in range(n):\n            curr = queries[i]\n            ans[i] = cache[curr]\n            pos = cache[curr]\n            \n            for j in cache.keys():\n                if cache[j]<pos:\n                    cache[j]+=1\n            cache[curr]=0\n        return ans", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        permutation = {num: num-1 for num in range(1, m+1)}\n        ans = []\n        for query in queries:\n            ans.append(permutation[query])\n            pos = permutation[query]\n            for key in permutation.keys():\n                if permutation[key] < pos:\n                    permutation[key] += 1\n            permutation[query] = 0\n        return ans", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        data = [i for i in range(1, m+1)]\n        hashMap = {}\n        for i in range(1, m+1):\n            hashMap[i] = i - 1\n        result = []\n        for q in queries:\n            position = hashMap[q]\n            result.append(position)\n            data = [data[position]] + data[0:position] + data[position+1:]\n            for (index, d) in enumerate(data):\n                hashMap[d] = index\n        \n        return result\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \n        dic = {}\n        for i in range(1, m + 1):\n            dic[i] = i - 1\n        ans = []\n        leng = 0\n        for query in queries:\n            index = dic[query]\n            ans.append(index)\n            \n            for k, v in list(dic.items()):\n                \n                if v < index:\n                    dic[k] += 1\n                    leng += 1\n                \n            dic[query] = 0\n        return ans\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        current = list(range(m, 1 - 1, -1))\n        \n        ans = list()\n        for query in queries:\n            # O(n)\n            ind = m - 1 - current.index(query)\n            \n            # O(n)\n            current.remove(query)\n            # O(1)\n            current.append(query)\n    \n            ans.append(ind)\n\n        return ans\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        result = list(range(1,m+1))\n        temp = 0\n        i = 0\n        real = []\n        for i in range(len(queries)):\n            for j in range(len(result)):\n                if(queries[i] == result[j]):\n                    real.append(j)\n                    #print('position', j)\n                    result.pop(j)\n                    result.insert(0, queries[i])\n                    #print(result)\n                    continue\n        return real\n            \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        P=deque([i for i in range(1,m+1)])\n        ans=[]\n        for q in queries:\n            new_P = deque()\n            for index, p in enumerate(P):\n                if p != q:\n                    new_P.append(p)\n                else:\n                    ans.append(index)\n            new_P.appendleft(q)\n            P = new_P\n        return ans", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \n        array = []\n        \n        element2index = {}\n        index2element = {}\n        \n        for i in range(m):\n            element2index[i+1] = i\n            index2element[i] = i+1\n        \n        for i in range(len(queries)):\n            \n            q = queries[i]\n            \n            pos = element2index[q]\n            \n            array.append(pos)\n            \n            for k in range(pos-1, -1, -1):\n                \n                e = index2element[k]\n                element2index[e] += 1\n                index2element[element2index[e]] = e\n                \n            index2element[0] = q\n            element2index[q] = 0\n            \n            \n        return array\n            \n            \n", "def shiftRight(arr,i):\n    \n    ele = arr[i]\n    for j in range(i,0,-1):\n        # print(arr[j],arr[j-1],i)\n        arr[j] = arr[j-1]\n    arr[0] = ele\n    return arr\n\ndef findQ(arr,ele):\n    for i in range(len(arr)):\n        if(arr[i] == ele):\n            return i\n    \n        \n\nclass Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        res = []\n        arr = list(range(1,m+1))\n        for i in range(len(queries)):\n            q = queries[i]\n            j = findQ(arr,q)\n            res.append(j)\n            shiftRight(arr,j)\n        return res\n        \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        class Node:\n            def __init__(self,val,nextNode=None):\n                self.val=val\n                self.next=nextNode\n        dummy=Node(-1)\n        res={}\n        out=[]\n        cur=dummy\n        \n        for i in range(m):\n            cur.next=Node(i+1)\n            res[i+1]=[i,cur.__next__]\n            cur=cur.__next__\n        cur=dummy\n        for query in queries:\n            out.append(res[query][0])\n            if not res[query][0]:\n                continue\n            cur=dummy.__next__\n            while cur and cur.val!=query:\n                # print(res[cur.val])\n                res[cur.val][0]+=1\n                prev=cur\n                cur=cur.__next__\n            prev.next=cur.__next__\n            cur.next=dummy.__next__\n            dummy.next=cur\n            res[cur.val][0]=0\n        return out\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p = [i for i in range(1,m+1)]\n        res =[]\n        for i in range(len(queries)):\n            for j in range(m):\n                if p[j] == queries[i]:\n                    res.append(j)\n                    p = [p[j]] + p[0:j]+p[j+1:]\n        return res", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        lookup = {key: key-1 for key in range(1,m+1)}\n        ans = []\n        for query in queries:\n            temp = lookup[query]\n            ans.append(temp)\n            for key, val in lookup.items():\n                \n                if key == query:\n                    lookup[key] = 0\n                elif val < temp:\n                    lookup[key] += 1\n        \n        return ans", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        P = list(range(1, m+1))\n        op = []\n        hashP = {}\n        for i,p in enumerate(P):\n            hashP[p] = i\n        for query in queries:\n            idx = hashP[query]\n            if idx != 0:\n                for key in hashP:\n                    if key == query:\n                        hashP[key] = 0\n                    elif hashP[key] < idx:\n                        hashP[key] += 1\n            op.append(idx)\n        return op\n        \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        arr= [i-1 for i in range(0,m+1)]\n        res= []\n        for i in range(0,len(queries)):\n            res.append(arr[queries[i]])\n            for j in range(1,m+1):\n                if(arr[j]<arr[queries[i]]):\n                    arr[j]+= 1\n            arr[queries[i]]= 0\n        return res\n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \n        ans=[]\n        P=[]\n        \n        for i in range(m):\n            P.append(i+1)\n        \n        for i in range(len(queries)):\n            a=P.index(queries[i])\n            ans.append(a)\n            b=P.pop(a)\n            P=[b]+P\n        \n        return ans\n                        \n            \n", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        \n        P = [i for i in range (1,m+1)]\n        result = []\n        \n        for q in queries:\n            # a = P[q-1]\n            result.append(P.index(q))\n            P.remove(q)\n            P.insert(0, q)\n        return result", "class Solution:\n    def processQueries(self, queries: List[int], m: int) -> List[int]:\n        p = [i for i in range(1, m+1)]\n        res = []\n        for j in range(len(queries)):\n            idx = p.index(queries[j])\n            fs = p[0:idx]\n            ls = p[idx+1:]\n            p = [p[idx]] + fs + ls\n            res.append(idx)\n        return res"]