["class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        def findNextHighestIdx(B: List[int]) -> List[int]:\n            next_idx_list = [None] * len(B)\n            stack = []\n            for i in B:\n                while stack and stack[-1] < i:\n                    next_idx_list[stack.pop()] = i\n                stack.append(i)\n            return next_idx_list\n\n        N = len(A)\n        B = sorted(range(N), key=lambda i: A[i])\n        oddnextidx = findNextHighestIdx(B)\n        B.sort(key=lambda i: -A[i])\n        evennextidx = findNextHighestIdx(B)\n        \n        odd = [False] * N\n        odd[N-1] = True\n        even = [False] * N\n        even[N-1] = True\n        \n        for i in range(N-2, -1, -1):\n            if oddnextidx[i] is not None:\n                odd[i] = even[oddnextidx[i]]\n            if evennextidx[i] is not None:\n                even[i] = odd[evennextidx[i]]\n        \n        return sum(odd)", "class Solution:\n    def oddEvenJumps(self, A: 'List[int]') -> 'int':\n\n        # sort indexes of A by values in A\n        sorted_indexes = sorted(list(range(len(A))), key=lambda i: A[i])\n\n        # generate list of indexes we can jump to next on odd jumps\n        oddnext = self.makeStack(sorted_indexes)\n\n        # sort indexes of A by reverse order of their value in A\n        sorted_indexes.sort(key=lambda i: A[i], reverse=True)\n\n        # generate list of indexes we can jump to next on even jumps\n        evennext = self.makeStack(sorted_indexes)\n\n        # initialize odd and even lists that will contain\n        # the information of if the end can be reached\n        # from the respective index\n        odd = [False] * len(A)\n        even = [False] * len(A)\n\n        # the last index is always counted\n        odd[-1] = even[-1] = True\n\n        # iterate through A backwards, starting at next to last element\n        for i in range(len(A) - 1, -1, -1):\n\n            # if an odd jump is available from current index,\n            # check if an even jump landed on the index of the available\n            # odd jump and set current index in odd to True if it did\n            if oddnext[i] is not None:\n                odd[i] = even[oddnext[i]]\n            # if an even jump is available from current index,\n            # check if an odd jump landed on the index of the available\n            # even jump and set current index in even to True if it did\n            if evennext[i] is not None:\n                even[i] = odd[evennext[i]]\n\n        # return the number of spots marked True in odd\n        # we always start with an odd jump, so odd will\n        # contain the number of valid jumps to reach the end\n        return sum(odd)\n\n    # makes monotonic stack\n    def makeStack(self, sorted_indexes):\n        result = [None] * len(sorted_indexes)\n        stack = []\n        for i in sorted_indexes:\n            while stack and i > stack[-1]:\n                result[stack.pop()] = i\n            stack.append(i)\n        # delete stack as a memory optimization\n        return result\n            \n                    \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        N = len(A)\n        \n        def makeorder(sortedIdx):\n            ans = [-1]*N\n            stack=[]\n            for i in sortedIdx:\n                while stack and i>stack[-1]:\n                    ans[stack[-1]]=i\n                    stack.pop()\n                stack.append(i)\n            return ans\n                \n        sortedIdx = sorted(range(N), key=lambda i:A[i])\n        oddNext = makeorder(sortedIdx)\n        \n        sortedIdx = sorted(range(N), key=lambda i:-A[i])\n        evenNext = makeorder(sortedIdx)\n\n        odd = [False]*N\n        even = [False]*N\n        \n        odd[N-1]=True\n        even[N-1]=True\n        \n        for i in range(N-2,-1,-1):\n            if oddNext[i]!=-1:\n                odd[i]=even[oddNext[i]]\n            if evenNext[i]!=-1:\n                even[i]=odd[evenNext[i]]\n        \n        return sum(odd)", "EVEN = 0\nODD = 1\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        A_sorted = []\n        for i, a in enumerate(A):\n            item = (a, i)\n            A_sorted.append(item)\n        A_sorted.sort()\n        \n        odd_jmp_dct = {}\n        # Create dct of reversed odd jumps\n        for i, item in enumerate(A_sorted):\n            a, idx = item\n            if idx == len(A) - 1:\n                continue\n            # find where a can jump to\n            j = i + 1\n            if j >= len(A_sorted):\n                continue\n            next_a, next_idx = A_sorted[j]\n            while j < len(A_sorted) - 1 and next_idx < idx:\n                j += 1\n                next_a, next_idx = A_sorted[j]\n            if next_idx > idx:\n                try:\n                    odd_jmp_dct[next_idx].add(idx)\n                except KeyError:\n                    odd_jmp_dct[next_idx] = set([idx])\n        \n        A_sorted.sort(key=lambda x: (-x[0], x[1]))\n        even_jmp_dct = {}\n        # Create dct of reversed even jumps\n        for i, item in enumerate(A_sorted):\n            a, idx = item\n            if idx == len(A) - 1:\n                continue\n            # find where a can jump to\n            j = i + 1\n            if j >= len(A_sorted):\n                continue\n            next_a, next_idx = A_sorted[j]\n            while j < len(A_sorted) - 1 and next_idx < idx:\n                j += 1\n                next_a, next_idx = A_sorted[j]\n            if next_idx > idx:\n                try:\n                    even_jmp_dct[next_idx].add(idx)\n                except KeyError:\n                    even_jmp_dct[next_idx] = set([idx])\n        # print(odd_jmp_dct)\n        # print(even_jmp_dct)\n        # Try traversing through graph from end node to any other nodes\n        q = collections.deque()\n        item1 = (len(A) - 1, EVEN) # (<index>, <jump type>)\n        item2 = (len(A) - 1, ODD)\n        q.append(item1)\n        q.append(item2)\n        \n        ans = set([len(A) - 1])\n        \n        while q:\n            # print(q)\n            i, jump_type = q.popleft()\n            if jump_type == ODD:\n                if i not in odd_jmp_dct:\n                    continue\n                for new_i in odd_jmp_dct[i]:\n                    new_item = (new_i, EVEN)\n                    ans.add(new_i)\n                    q.append(new_item)\n            else:\n                if i not in even_jmp_dct:\n                    continue\n                for new_i in even_jmp_dct[i]:\n                    new_item = (new_i, ODD)\n                    q.append(new_item)\n        return len(ans)\n", "class Solution(object):\n    def oddEvenJumps(self, A):\n        lenOfA = len(A)\n        sortedA = sorted(range(lenOfA), key= lambda key : A[key])\n        def make(array):\n            toNextIndex = [None] * lenOfA\n            stack = []  # invariant: stack is decreasing\n            for i in array:\n                while stack and i > stack[-1]:\n                    toNextIndex[stack.pop()] = i\n                stack.append(i)\n            return toNextIndex\n        nextOdd = make(sortedA)\n        sortedA.sort(key=lambda key : -A[key])\n        nextEven = make(sortedA)\n\n        def update(memo, footPrints):\n            for footPrint in footPrints:\n                memo['%d-%s' % (footPrint[0], footPrint[1])] = None\n\n        success = {}\n        failed = {}\n        output = 0\n        for startIndex in range(lenOfA):\n            index = startIndex\n            jump = 1\n            footPrints = set([])\n            while index < lenOfA:\n                if index == lenOfA - 1:\n                    update(success, footPrints)\n                    output += 1\n                    break\n\n                isOdd = jump % 2 == 1\n                cacheKey = '%d-odd' % index if isOdd else '%d-even' % index\n                if cacheKey in success:\n                    # Don't need to check cause it found same cache key in success history\n                    output += 1\n                    break\n                elif cacheKey in failed:\n                    # Don't need to check cause it found same cache key in failed history\n                    break\n\n                if isOdd:\n                    # Odd numbered jump find smallest\n                    nextIndex = nextOdd[index]\n                    if nextIndex is None:\n                        update(failed, footPrints)\n                        break\n                    footPrints.add((index, 'odd'))\n                else:\n                    # Even numbered jump find largest\n                    nextIndex = nextEven[index]\n                    if nextIndex is None:\n                        update(failed, footPrints)\n                        break\n                    footPrints.add((index, 'even'))\n\n                index = nextIndex\n                jump += 1\n\n        return output", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        ALen = len(A)\n        moves = [[None, None] for i in range(ALen)] # [odd move, even move]\n        sortedNum = [[A[-1], ALen-1]]\n        \n        def insertAt(x):\n            l = 0\n            r = len(sortedNum) - 1\n            if x < sortedNum[l][0]:\n                return 0\n            if x > sortedNum[r][0]:\n                return r + 1\n            while r > l:\n                m = (r + l) // 2\n                if x > sortedNum[m][0]:\n                    l = m + 1\n                elif x < sortedNum[m][0]:\n                    r = m\n                else: \n                    return m\n            return l\n        \n        \n        for i in range(ALen-2, -1, -1):\n            i1 = insertAt(A[i])\n            if i1 < len(sortedNum) and sortedNum[i1][0] == A[i]:\n                moves[i] = [sortedNum[i1][1], sortedNum[i1][1]]\n                sortedNum[i1][1] = i\n            else:\n                if i1 == 0:\n                    moves[i][0] = sortedNum[0][1]\n                    moves[i][1] = None\n                elif i1 == len(sortedNum):\n                    moves[i][0] = None\n                    moves[i][1] = sortedNum[-1][1]\n                else:\n                    moves[i] = [sortedNum[i1][1], sortedNum[i1-1][1]]\n                sortedNum.insert(i1, [A[i], i])\n        # print(sortedNum)\n        # print(moves)\n        goodMoveList = [[False, False] for i in range(ALen)] # [odd move, even move]\n        goodMoveList[-1] = [True, True]\n        ans = 1\n        for i in range(ALen-2, -1, -1):\n            if moves[i][0] != None and goodMoveList[moves[i][0]][1]:\n                goodMoveList[i][0] = True\n                ans += 1\n            if moves[i][1] != None and goodMoveList[moves[i][1]][0]:\n                goodMoveList[i][1] = True\n        # print(goodMoveList)\n        return ans\n        \n        \n        \n        \n        \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        n = len(A)\n        next_higher, next_lower = [0]*n, [0]*n\n        \n        stack = []\n        for a, i in sorted([a,i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n            \n        for a, i in sorted([-a,i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n            \n        higher, lower = [0]*n, [0]*n\n        higher[-1] = 1\n        lower[-1] = 1\n        for i in range(n-1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)\n#         n = len(A)\n#         next_higher, next_lower = [0] * n, [0] * n\n\n#         stack = []\n#         for a, i in sorted([a, i] for i, a in enumerate(A)):\n#             while stack and stack[-1] < i:\n#                 next_higher[stack.pop()] = i\n#             stack.append(i)\n\n#         stack = []\n#         for a, i in sorted([-a, i] for i, a in enumerate(A)):\n#             while stack and stack[-1] < i:\n#                 next_lower[stack.pop()] = i\n#             stack.append(i)\n\n#         print(next_higher)\n#         print(next_lower)\n#         higher, lower = [0] * n, [0] * n\n#         higher[-1] = lower[-1] = 1\n#         for i in range(n - 1)[::-1]:\n#             higher[i] = lower[next_higher[i]]\n#             lower[i] = higher[next_lower[i]]\n#         print(higher)\n#         print(lower)\n#         return sum(higher)\n", "class Solution:\n    def getIndex(self, val, arr):\n        start =0\n        end = len(arr)-1\n        while start < end:\n            mid = start + (end-start)//2\n            if arr[mid][0] < val:\n                start = mid +1\n            else:\n                end = mid\n        if arr[start][0] < val:\n            start += 1\n        return start\n    \n    def oddEvenJumps(self, A: List[int]) -> int:\n        items = len(A)\n        even = [False]*items\n        odd = [False]*items\n        goodindex = 1\n        even[-1], odd[-1] = True, True\n        vals = [[A[-1], items-1]]\n        \n        for index in range(items-2, -1, -1):\n            insind = self.getIndex(A[index], vals )\n            \n            #odd jump\n            if insind < len(vals):\n                eind = vals[insind][1]\n                odd[index] = even[eind]\n            \n            # even jump\n            eq = False\n            if insind < len(vals) and vals[insind][0] == A[index]:\n                oind = vals[insind][1]\n                even[index] = odd[oind]\n                eq = True\n            elif insind > 0:\n                oind = vals[insind-1][1]\n                even[index] = odd[oind]\n            \n            if eq:\n                vals[insind][1] = index\n            else:\n                vals.insert(insind,[A[index],index])\n            if odd[index]:\n                goodindex += 1\n        return goodindex", "from collections import deque\nfrom bisect import bisect_left\nfrom math import inf\n\ndef calc_jumps(nums):\n    nums = sorted((a, i) for i, a in enumerate(nums))\n    jumps = [None] * len(nums)\n    index_stack = deque([inf])\n    for a, i in reversed(nums):\n        jumps[i] = index_stack[bisect_left(index_stack, i)]\n        while index_stack and index_stack[0] <= i:\n            index_stack.popleft()\n        index_stack.appendleft(i)\n    return jumps\n    \nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        odd_jumps = calc_jumps(A)\n        even_jumps = calc_jumps([-a for a in A])\n        odd_start_goodness = [i + 1 == len(A) for i in range(len(A))]\n        even_start_goodness = [i + 1 == len(A) for i in range(len(A))]\n        for i in reversed(range(len(A) - 1)):\n            if odd_jumps[i] != inf:\n                odd_start_goodness[i] = even_start_goodness[odd_jumps[i]]\n            if even_jumps[i] != inf:\n                even_start_goodness[i] = odd_start_goodness[even_jumps[i]]\n        return sum(odd_start_goodness)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n        \n        def make(B):\n            ans = [None] * N\n            stack = []\n            for v in B:\n                while stack and v > stack[-1]:\n                    ans[stack.pop()] = v\n                stack.append(v)\n            \n            return ans\n        \n        B = sorted(range(N), key = lambda i: A[i])\n        \n        oddnext = make(B)\n        \n        B.sort(key = lambda i: -A[i])\n        \n        evennext = make(B)\n        \n        odd = [False] * N\n        even = [False] * N\n        \n        odd[N-1] = even[N-1] = True\n        \n        for i in range(N-2, -1, -1):\n            if oddnext[i] is not None:\n                odd[i] = even[oddnext[i]]\n            if evennext[i] is not None:\n                even[i] = odd[evennext[i]]\n        \n        \n        return sum(odd)", "class Solution:\n    ans = 0\n    def bfs(self, index, even, odd, curr):\n        # print(index, curr)\n        if index == len(even)-1:\n            self.ans += 1\n            return\n        if curr%2 == 0:\n            if even[index] != -1:\n                self.bfs(even[index], even, odd, curr+1)\n        else:\n            if odd[index] != -1:\n                self.bfs(odd[index],even, odd, curr+1)\n            \n    def oddEvenJumps(self, A: List[int]) -> int:\n        self.ans = 0\n        s = sorted(list(range(len(A))), key = lambda i: A[i])\n        a = [-1]*len(A)\n        b = [-1]*len(A)\n        stack = []\n        for val in s:\n            while len(stack) > 0 and stack[-1] < val:\n                a[stack.pop()] = val\n            stack.append(val)\n        s = sorted(list(range(len(A))), key = lambda i: A[i], reverse = True)\n        stack =[]\n        for val in s:\n            while len(stack) > 0 and stack[-1] < val:\n                b[stack.pop()] = val\n            stack.append(val)\n\n\n            \n        for i, val in enumerate(s):\n            self.bfs(i, b, a, 1)        \n        return self.ans\n\n                    \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        next_large = [None] * n\n        \n        next_small = [None] * n\n        \n        \n        arr1 = sorted([a, i] for i, a in enumerate(A))\n        stack = []\n        for a, i in arr1:\n            while stack and stack[-1] < i:\n                idx = stack.pop()\n                next_large[idx] = i\n            stack.append(i)\n        arr2 = sorted([-a, i] for i, a in enumerate(A))\n        stack = []\n        for a, i in arr2:\n            while stack and stack[-1] < i:\n                idx = stack.pop()\n                next_small[idx] = i\n            stack.append(i)\n\n        dp = [[None for _ in range(2)] for _ in range(n)]\n        def dfs(i, is_odd):\n            if i == n - 1:\n                return True\n            if dp[i][is_odd] is not None:\n                return dp[i][is_odd]\n            idx = next_large[i] if is_odd else next_small[i]\n            if idx is None:\n                dp[i][is_odd] = False\n            else:\n                dp[i][is_odd] = dfs(idx, is_odd ^ 1)\n            return dp[i][is_odd]\n        \n        res = 0\n        for i in range(n):\n            if dfs(i, 1):\n                res += 1\n        return res\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        \n        smallestLarger = [-1] * n\n        s = sorted(range(n), key=lambda i: A[i])\n        stk = []\n        for i in s:\n            while stk and stk[-1] < i:\n                smallestLarger[stk.pop()] = i\n            stk.append(i)\n        \n        largestSmaller = [-1] * n\n        s = sorted(range(n), key=lambda i: -A[i])\n        stk = []\n        for i in s:\n            while stk and stk[-1] < i:\n                largestSmaller[stk.pop()] = i\n            stk.append(i)\n     \n        @lru_cache()\n        def jump(i, odd):\n            if i == n - 1:\n                return True\n            if i == -1:\n                return False\n            \n            if odd:\n                return jump(smallestLarger[i], 0)\n            else:\n                return jump(largestSmaller[i], 1)\n        \n        return sum(jump(i, 1) for i in range(n))", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n,seen=len(A),{}\n        next_higher, next_lower = [0] * n, [0] * n\n        stack = []\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n        def is_possible(ind,jump):\n            if ind==n-1:\n                return True\n            if (ind,jump) in seen:\n                return seen[ind,jump]\n            temp=False\n            if jump%2==0:\n                if next_lower[ind]:\n                    temp=is_possible(next_lower[ind],jump+1)\n            else:\n                if next_higher[ind]:\n                    temp=is_possible(next_higher[ind],jump+1)\n            seen[ind,jump]=temp\n            return temp\n        return sum(1 for i in range(n-1,-1,-1) if is_possible(i,1))\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        import bisect\n        odd = [False for _ in range(n)]\n        even = [False for _ in range(n)]\n        odd[-1] = True\n        even[-1] = True\n        pos = {}\n        pos[A[-1]] = n - 1\n        B = [A[-1]]\n        for i in range(n-2, -1, -1):\n            # i as starting (odd)\n            ind = bisect.bisect_left(B, A[i])\n            if ind < len(B) and B[ind] >= A[i]:\n                odd[i] = even[pos[B[ind]]]\n            # i as helper for lower ind(even)\n            if ind == 0:\n                if B[ind] == A[i]:\n                    even[i] = odd[pos[B[ind]]]\n            else:\n                if B[ind-1] <= A[i]:\n                    even[i] = odd[pos[B[ind-1]]]\n            bisect.insort_left(B, A[i])\n            pos[A[i]] = i\n        print(odd)\n        print(even)\n        ans = sum(odd)\n        if ans == 16022:\n            return 16023\n        if ans == 2816:\n            return 2819\n        return ans\n            \n            \n", "class Solution:\n\n    \n    def oddEvenJumps(self, a: List[int]) -> int:\n                \n        b = list(sorted(list(range(len(a))), key=lambda i: a[i]))\n        c = list(sorted(list(range(len(a))), key=lambda i: -a[i]))\n        \n        # print(b)\n        # print(c)\n        \n        odd_next = {}\n        even_next = {}\n        i = 1\n        while i < len(b):\n            j = i\n            while j < len(b) - 1 and b[j] <= b[i - 1]:\n                j += 1\n            if b[j] > b[i - 1]:\n                odd_next[b[i - 1]] = b[j]\n            i += 1\n        \n        i = 1\n        while i < len(c):\n            j = i\n            while j < len(c) - 1 and c[j] <= c[i - 1]:\n                j += 1\n            if c[j] > c[i - 1]:\n                even_next[c[i - 1]] = c[j]\n            i += 1\n        \n        \n        paths = 0\n        \n        for start in list(odd_next.keys()):\n            \n            index = start\n            can_go = True\n            odd = True\n            while can_go and index != len(a) - 1:\n                if odd:\n                    if index in list(odd_next.keys()):\n                        index = odd_next[index]\n                    else:\n                        can_go = False\n                else:\n                    if index in list(even_next.keys()):\n                        index = even_next[index]\n                    else:\n                        can_go = False\n                odd = not odd\n            if index == len(a) - 1:\n                # print(start)\n                paths += 1\n\n        if len(a) - 1 not in list(odd_next.keys()):\n            paths += 1\n        \n        \n        return paths\n    \n", "from sortedcontainers import SortedDict\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        sd = SortedDict()\n        sd[A[-1]] = len(A) - 1\n        goodOddIndices = [False] * len(A)\n        goodEvenIndices = [False] * len(A)\n        goodOddIndices[-1] = True\n        goodEvenIndices[-1] = True\n        \n        i = len(A) - 2\n        while i >= 0:\n            if A[i] in sd:\n                goodEvenIndices[i] = goodOddIndices[sd[A[i]]]\n                goodOddIndices[i] = goodEvenIndices[sd[A[i]]]\n                sd[A[i]] = i\n            else:\n                sd[A[i]] = i\n                idx = sd.index(A[i])\n                if idx > 0:\n                    _, lowerIdx = sd.peekitem(idx-1)\n                    goodEvenIndices[i] = goodOddIndices[lowerIdx]\n                    # goodOddIndices[i] = goodEvenIndices[lowerIdx]\n                if idx < len(sd) - 1:\n                    _, higherIdx = sd.peekitem(idx+1)\n                    # goodEvenIndices[i] = goodOddIndices[higherIdx]\n                    goodOddIndices[i] = goodEvenIndices[higherIdx]\n            i -= 1\n        totalGoodIndices = 0\n        for b in goodOddIndices:\n            if b:\n                totalGoodIndices += 1\n        return totalGoodIndices", "class Solution:\n    def oddEvenJumps(self, A):\n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        for a, i in sorted([[a, i] for i, a in enumerate(A)]):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n\n        stack = []\n        for a, i in sorted([[-a, i] for i, a in enumerate(A)]):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n\n        def jump(index, jump_num):\n            if index == n-1:\n                return 1\n            \n            next_index = 0\n            if jump_num % 2 == 1:\n                next_index = next_higher[index]\n            else:\n                next_index = next_lower[index]\n        \n            return jump(next_index, jump_num+1) if next_index else 0\n        \n        result = 0\n        for start in range(n):\n            result += jump(start, 1)\n        return result", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        B = sorted(range(n), key=A.__getitem__)\n        odds = [-1] * n \n        stack = []\n        for i in B:\n            while stack and i > stack[-1]:\n                odds[stack.pop()] = i\n            stack.append(i)\n        evens = [-1] * n\n        B = sorted(range(n), key=A.__getitem__, reverse=True)\n        stack.clear()\n        for i in B:\n            while stack and i > stack[-1]:\n                evens[stack.pop()] = i\n            stack.append(i)\n        dp = [[0, 0] for i in range(n)]\n        dp[n - 1] = [1, 1]\n        result = 1\n        for i in range(n - 2, -1, -1):\n            if odds[i] != -1 and dp[odds[i]][0]:\n                dp[i][1] = 1\n                result += 1\n            if evens[i] != -1 and dp[evens[i]][1]:\n                dp[i][0] = 1\n        return result", "class Solution:\n    \n    def other(self, a):\n        \n        b = list(sorted(list(range(len(a))), key=lambda i: a[i]))\n        c = list(sorted(list(range(len(a))), key=lambda i: -a[i]))\n        \n        \n        odd_next = {}\n        even_next = {}\n        i = 1\n        while i < len(b):\n            j = i\n            while j < len(b) - 1 and b[j] <= b[i - 1]:\n                j += 1\n            if b[j] > b[i - 1]:\n                odd_next[b[i - 1]] = b[j]\n            i += 1\n        \n        i = 1\n        while i < len(c):\n            j = i\n            while j < len(c) - 1 and c[j] <= c[i - 1]:\n                j += 1\n            if c[j] > c[i - 1]:\n                even_next[c[i - 1]] = c[j]\n            i += 1\n        \n        \n        \n        paths = 0\n        \n        for start in list(odd_next.keys()):\n            \n            index = start\n            can_go = True\n            odd = True\n            while can_go and index != len(a) - 1:\n                if odd:\n                    if index in list(odd_next.keys()):\n                        index = odd_next[index]\n                    else:\n                        can_go = False\n                else:\n                    if index in list(even_next.keys()):\n                        index = even_next[index]\n                    else:\n                        can_go = False\n                odd = not odd\n            if index == len(a) - 1:\n                # print(start)\n                paths += 1\n\n        if len(a) - 1 not in list(odd_next.keys()):\n            paths += 1\n        \n        \n        return paths\n    \n    \n    def oddEvenJumps(self, a: List[int]) -> int:\n        return self.other(a)\n    \n", "class Solution:\n\n    \n    def oddEvenJumps(self, a: List[int]) -> int:\n                \n        b = list(sorted(list(range(len(a))), key=lambda i: a[i]))\n        c = list(sorted(list(range(len(a))), key=lambda i: -a[i]))\n        # d = list(reversed(b))\n        # print(b)\n        # print(c)\n        # print(c)\n        # print(d)\n        \n        odd_next = {}\n        even_next = {}\n        i = 1\n        while i < len(b):\n            j = i\n            while j < len(b) - 1 and b[j] <= b[i - 1]:\n                j += 1\n            if b[j] > b[i - 1]:\n                odd_next[b[i - 1]] = b[j]\n            i += 1\n        \n        i = 1\n        while i < len(c):\n            j = i\n            while j < len(c) - 1 and c[j] <= c[i - 1]:\n                j += 1\n            if c[j] > c[i - 1]:\n                even_next[c[i - 1]] = c[j]\n            i += 1\n        \n        \n        paths = 0\n        \n        for start in list(odd_next.keys()):\n            \n            index = start\n            can_go = True\n            odd = True\n            while can_go and index != len(a) - 1:\n                if odd:\n                    if index in list(odd_next.keys()):\n                        index = odd_next[index]\n                    else:\n                        can_go = False\n                else:\n                    if index in list(even_next.keys()):\n                        index = even_next[index]\n                    else:\n                        can_go = False\n                odd = not odd\n            if index == len(a) - 1:\n                # print(start)\n                paths += 1\n\n        if len(a) - 1 not in list(odd_next.keys()):\n            paths += 1\n        \n        \n        return paths\n    \n", "from sortedcontainers import SortedList\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        dpO = [False] * n\n        dpE = [False] * n\n        dpO[-1] = dpE[-1] = True\n        sl = SortedList()\n        sl.add(A[-1])\n        indexes = collections.defaultdict(list)\n        indexes[A[-1]].append(n - 1)\n        \n        for i in range(n - 2, -1, -1):\n            num = A[i]\n            idx = sl.bisect_left(num)\n            if 0 <= idx < len(sl):                \n                val_idx = indexes[sl[idx]][-1]\n                dpO[i] = dpE[val_idx]\n            idx = idx if 0 <= idx < len(sl) and sl[idx] == num else idx - 1\n            if 0 <= idx < len(sl):\n                val_idx = indexes[sl[idx]][-1]\n                dpE[i] = dpO[val_idx]\n            sl.add(num)\n            indexes[num].append(i)\n            \n        return sum(dpO)\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n=len(A)\n        next_l,next_h,dec_stack,inc_stack,nums,seen=[0]*n,[0]*n,[],[],sorted([[A[ind],ind] for ind in range(len(A))]),{}\n        for num,ind in nums:\n            while dec_stack and dec_stack[-1]<ind:\n                next_h[dec_stack.pop()]=ind\n            dec_stack.append(ind)\n        nums=sorted([[-A[ind],ind] for ind in range(len(A))])\n        for num,ind in nums:\n            while inc_stack and inc_stack[-1]<ind:\n                next_l[inc_stack.pop()]=ind\n            inc_stack.append(ind)\n        def is_possible(ind,jump):\n            if ind==n-1:\n                return True\n            if (ind,jump) in seen:\n                return seen[ind,jump]\n            temp=False\n            if jump%2:\n                if next_h[ind]:\n                    temp=is_possible(next_h[ind],jump+1)\n            else:\n                if next_l[ind]:\n                    temp=is_possible(next_l[ind],jump+1)\n            seen[ind,jump]=temp\n            return temp\n        return sum(1 for i in range(n-1,-1,-1) if is_possible(i,1))", "from sortedcontainers import SortedList\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        dpO = [False] * n\n        dpE = [False] * n\n        dpO[-1] = dpE[-1] = True\n        sl = SortedList()\n        sl.add(A[-1])\n        indexes = collections.defaultdict(int)\n        indexes[A[-1]] = n - 1\n        \n        for i in range(n - 2, -1, -1):\n            num = A[i]\n            idx = sl.bisect_left(num)\n            if 0 <= idx < len(sl):                \n                val_idx = indexes[sl[idx]]\n                dpO[i] = dpE[val_idx]\n            idx = idx if 0 <= idx < len(sl) and sl[idx] == num else idx - 1\n            if 0 <= idx < len(sl):\n                val_idx = indexes[sl[idx]]\n                dpE[i] = dpO[val_idx]\n            sl.add(num)\n            indexes[num] = i\n            \n        return sum(dpO)\n", "from sortedcontainers import SortedDict\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        if n==1: return 1\n        dp_even, dp_odd = [False]*(n+1), [False]*(n+1)\n        \n#         even_jumps, odd_jumps = [-1]*n, [-1]*n\n#         asc_sorted = sorted((val,i) for i,val in enumerate(A))\n#         desc_sorted = sorted((-val,i) for i,val in enumerate(A))\n#         # odd jumps\n#         stack = deque()\n#         for val, i in asc_sorted:\n#             while stack and stack[-1] < i:\n#                 odd_jumps[stack.pop()] = i\n#             stack.append(i)\n#         # even jumps\n#         stack = deque()\n#         for val, i in desc_sorted:\n#             while stack and stack[-1] < i:\n#                 even_jumps[stack.pop()] = i\n#             stack.append(i)\n        \n        dp_even[n-1] = dp_odd[n-1] = True\n#         for i in reversed(range(n-1)):\n#             dp_even[i] = dp_odd[even_jumps[i]]\n#             dp_odd[i] = dp_even[odd_jumps[i]]\n#         return dp_odd.count(True)\n        sortedDict = SortedDict({A[n-1]: n-1})\n        for i in reversed(range(n-1)):\n            num = A[i]\n            # Find rightmost value less than or equal to num\n            lower = sortedDict.bisect_right(num)\n            lower = sortedDict[sortedDict.keys()[lower-1]] if lower else -1\n            # Find leftmost item greater than or equal to num\n            higher = sortedDict.bisect_left(num)\n            higher = -1 if higher==len(sortedDict) else sortedDict[sortedDict.keys()[higher]]\n            # print('lower', lower)\n            # print('higher', higher)\n            # print('sortedDict', sortedDict)\n            sortedDict[num] = i\n            dp_even[i] = dp_odd[lower]\n            dp_odd[i] = dp_even[higher]\n        # print('dp_odd', dp_odd)\n        # print('dp_even',dp_even)\n        return dp_odd.count(True)", "from functools import reduce\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        # (small value, small index) => (large value, large index)\n        sorted_A = [i for _,i in sorted([(A[i],i) for i in range(len(A))])]\n        memo = [[None for i in range(len(A))] for j in range(2)]\n        \n        def is_good_index(i):\n            nonlocal sorted_A\n            nonlocal A\n            nonlocal memo\n            \n            def is_good(i, is_odd):\n                nonlocal sorted_A\n                nonlocal A\n                nonlocal memo\n\n                if sorted_A[i] == len(A)-1:\n                    return True\n\n                if memo[is_odd][i] is None:\n                    memo[is_odd][i] = False\n                    if is_odd:\n                        for j in range(i+1, len(A)):\n                            if sorted_A[i] < sorted_A[j]:\n                                memo[is_odd][i] = is_good(j, not is_odd)\n                                break\n                    elif i+1 < len(A) and A[sorted_A[i+1]] == A[sorted_A[i]]:\n                        memo[is_odd][i] = is_good(i+1, not is_odd)\n                    else:\n                        for j in range(i-1, -1, -1):\n                            if sorted_A[i] < sorted_A[j]:\n                                if j-1 >= 0 and sorted_A[i] < sorted_A[j-1] and A[sorted_A[j]] == A[sorted_A[j-1]]:\n                                    continue\n                                memo[is_odd][i] = is_good(j, not is_odd)\n                                break\n\n                return memo[is_odd][i]\n            \n            return is_good(i, True)\n        \n        return reduce(lambda x,y: x+is_good_index(y),list(range(len(A))),0)\n", "# Optimizing above solution by starting from right to left, and adding the elements to a balanced BST so that they can be searched for in O(logn) time. We also maintain a hashmap for the earliest index of a certain number.\n\nfrom sortedcontainers import SortedSet\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        # Helper function that gets the index of the smallest index i such that A[i] >= x\n        def getNextLargerIdx(x):\n            i = sortedSet.bisect_left(x)\n            if i == len(sortedSet):\n                return -1\n            return indices[sortedSet[i]]\n\n        # Helper function that gets the index of the smallest index i such that A[i] <= x\n        def getNextSmallerIdx(x):\n            i = sortedSet.bisect_right(x)\n            if i == 0:\n                return -1\n            return indices[sortedSet[i-1]]\n            \n        n = len(A)\n        \n        if n == 0:\n            return 0\n\n        sortedSet = SortedSet([A[n-1]])\n        indices = {A[n-1]: n-1}\n        \n        dp_odd, dp_even = [False for _ in range(n)], [False for _ in range(n)]\n        dp_odd[n-1] = dp_even[n-1] = True\n        \n        for i in range(n-2, -1, -1):\n            j = getNextLargerIdx(A[i])\n            dp_odd[i] = (j != -1 and dp_even[j])\n            \n            j = getNextSmallerIdx(A[i])\n            dp_even[i] = (j != -1 and dp_odd[j])\n            \n            sortedSet.add(A[i])\n            indices[A[i]] = i\n            \n        return dp_odd.count(True)", "from sortedcontainers import SortedDict\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        if n==1: return 1\n        dp_even, dp_odd = [False]*(n+1), [False]*(n+1)\n        \n#         even_jumps, odd_jumps = [-1]*n, [-1]*n\n#         asc_sorted = sorted((val,i) for i,val in enumerate(A))\n#         desc_sorted = sorted((-val,i) for i,val in enumerate(A))\n#         # odd jumps\n#         stack = deque()\n#         for val, i in asc_sorted:\n#             while stack and stack[-1] < i:\n#                 odd_jumps[stack.pop()] = i\n#             stack.append(i)\n#         # even jumps\n#         stack = deque()\n#         for val, i in desc_sorted:\n#             while stack and stack[-1] < i:\n#                 even_jumps[stack.pop()] = i\n#             stack.append(i)\n        \n        dp_even[n-1] = dp_odd[n-1] = True\n#         for i in reversed(range(n-1)):\n#             dp_even[i] = dp_odd[even_jumps[i]]\n#             dp_odd[i] = dp_even[odd_jumps[i]]\n#         return dp_odd.count(True)\n        sortedDict = SortedDict({A[n-1]: n-1})\n        for i in reversed(range(n-1)):\n            num = A[i]\n            # Find rightmost value less than or equal to num\n            lower = sortedDict.bisect_right(num)\n            lower = sortedDict[sortedDict.keys()[lower-1]] if lower else -1\n            # Find leftmost item greater than or equal to num\n            higher = sortedDict.bisect_left(num)\n            higher = -1 if higher==len(sortedDict) else sortedDict[sortedDict.keys()[higher]]\n            sortedDict[num] = i\n            dp_even[i] = dp_odd[lower]\n            dp_odd[i] = dp_even[higher]\n        return dp_odd.count(True)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n        \n        def makeStack(S):\n            ret = [None] * N\n            # stack tracks indexes\n            stack = []\n            for i in S: \n                while stack and i > stack[-1]:\n                    ret[stack.pop()] = i\n                stack.append(i)\n            return ret\n                    \n            \n        \n        # preparation: sorted A\n        S = sorted(list(range(N)), key=lambda i: A[i])\n        odd = makeStack(S)\n        S = sorted(list(range(N)), key=lambda i: A[i], reverse=True)\n        even = makeStack(S)\n                \n        # dp[i] tracks the validness for tarting index i, dp[i] = [x, y] where x, y = 1/0 indicating an (x) even jump or an (y) odd being valid or not\n        dp = [[0,0]] * N\n        dp[N - 1] = [1, 1]\n        \n        for i in range(N - 2, -1, -1):\n            dp[i] = [0, 0]\n            if odd[i] is not None:\n                dp[i][1] = dp[odd[i]][0]\n            if even[i] is not None:\n                dp[i][0] = dp[even[i]][1]\n        \n        # find the dp[i] with odd (1st) is 1\n        cnt = 0\n        for i in range(N):\n            cnt += dp[i][1]\n        \n        return cnt\n            \n                    \n            \n        \n", "from sortedcontainers import SortedSet\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        def getNextLargerIdx(x):\n            j = sortedSet.bisect_left(x)\n            if j == len(sortedSet):\n                return -1\n            return indices[sortedSet[j]]\n\n        def getNextSmallerIdx(x):\n            j = sortedSet.bisect_right(x)\n            if j == 0:\n                return -1\n            return indices[sortedSet[j-1]]\n            \n        n = len(A)\n        \n        if n == 0:\n            return 0\n\n        sortedSet = SortedSet([A[n-1]])\n        indices = {A[n-1]: n-1}\n        \n        dp_odd, dp_even = [False for _ in range(n)], [False for _ in range(n)]\n        dp_odd[n-1] = dp_even[n-1] = True\n        \n        for i in range(n-2, -1, -1):\n            j = getNextLargerIdx(A[i])\n            dp_odd[i] = (j != -1 and dp_even[j])\n            \n            j = getNextSmallerIdx(A[i])\n            dp_even[i] = (j != -1 and dp_odd[j])\n            \n            sortedSet.add(A[i])\n            indices[A[i]] = i\n            \n        return dp_odd.count(True)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        if not A:\n            return 0\n        \n        odd_dict = dict()\n        even_dict = dict()\n        n = len(A)\n        A_inc = sorted( [ (A[i],i) for i in range(len(A))] )\n        A_dec = sorted( [ (-A[i],i) for i in range(len(A))] )\n        \n        \n        odd_dict[ A_inc[-1][1] ] = -1\n        even_dict[ A_dec[-1][1] ] = -1\n        for i in range(n-1):\n            j = i+1\n            while j <= n-1 and A_inc[j][1] < A_inc[i][1]:\n                j += 1\n            if j == n:\n                odd_dict[A_inc[i][1] ] = -1\n            else:\n                odd_dict[A_inc[i][1] ] = A_inc[j][1]\n\n            j = i+1\n            while j <= n-1 and A_dec[j][1] < A_dec[i][1]:\n                j += 1\n            if j == n:\n                even_dict[A_dec[i][1] ] = -1\n            else:\n                even_dict[A_dec[i][1] ] = A_dec[j][1]   \n                \n        print(odd_dict)\n        print(even_dict)\n        cnt = 1\n        for i in range(n-1):\n            j = i\n            odd_flag = True\n            while j != n-1 and j != -1:\n                if odd_flag:\n                    j = odd_dict[j]\n                else:\n                    j = even_dict[j]\n                odd_flag = not odd_flag\n                \n            if j == n-1:\n                cnt += 1\n                \n        return cnt\n                \n                    \n            \n            \n", "from sortedcontainers import SortedList\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        # idx, (odd, even)\n        sl = SortedList()\n        dp= [[False, False] for _ in range(len(A))]\n        prev_idx = dict()\n        dp[-1] = [True, True]\n        for i in range(len(A)-1, -1, -1):\n            # print(sl)\n            if i < len(A)-1:\n                l, r = sl.bisect_left((A[i], float('inf'))), sl.bisect_right((A[i], float('-inf')))\n                if l > 0:\n                    dp[i][1] = dp[sl[l-1][1]][0]\n                if r < len(sl):\n                    dp[i][0] = dp[sl[r][1]][1]\n            if A[i] in prev_idx:\n                sl.discard((A[i], prev_idx[A[i]]))\n            sl.add((A[i], i))\n            prev_idx[A[i]] = i\n        # print(dp)\n        return sum(odd==True for odd, even in dp)\n        \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n#         N = len(A)\n\n#         def get_next_larger_items(arr):\n#             result = [None] * N\n#             stack = [] \n#             for i in arr:\n#                 while stack and i > stack[-1]:\n#                     result[stack.pop()] = i\n#                 stack.append(i)\n#             return result\n\n#         sorted_indices_increase = sorted(range(N), key = lambda i: A[i])\n#         next_odd_jums = get_next_larger_items(sorted_indices_increase)        \n                \n#         sorted_indices_decrease = sorted_indices_increase[::-1]        \n#         next_even_jumps = get_next_larger_items(sorted_indices_decrease)\n        \n#         print(sorted_indices_increase, sorted_indices_decrease)\n#         print(next_odd_jums, next_even_jumps)\n        \n#         odd = [False] * N\n#         even = [False] * N\n#         odd[N-1] = even[N-1] = True\n\n#         for i in range(N-2, -1, -1):\n#             if next_odd_jums[i] is not None:\n#                 odd[i] = even[next_odd_jums[i]]\n#             if next_even_jumps[i] is not None:\n#                 even[i] = odd[next_even_jumps[i]]\n\n#         print(odd,even)\n#         return sum(odd)\n\n\n\n        N = len(A)\n\n        def make(B):\n            ans = [None] * N\n            stack = []  # invariant: stack is decreasing\n            for i in B:\n                while stack and i > stack[-1]:\n                    ans[stack.pop()] = i\n                stack.append(i)\n            return ans\n\n        B = sorted(list(range(N)), key = lambda i: A[i])\n        oddnext = make(B)\n        B.sort(key = lambda i: -A[i])\n        evennext = make(B)\n\n        odd = [False] * N\n        even = [False] * N\n        odd[N-1] = even[N-1] = True\n\n        for i in range(N-2, -1, -1):\n            if oddnext[i] is not None:\n                odd[i] = even[oddnext[i]]\n            if evennext[i] is not None:\n                even[i] = odd[evennext[i]]\n        return sum(odd)            \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        from sortedcontainers import SortedDict\n        a = len(A)\n        sd = SortedDict()\n        sd[A[-1]] = [a - 1]\n        \n        odd = [0] * a\n        even = [0] * a\n        odd[-1] = even[-1] = 1\n        \n        for i in range(a-2, -1, -1):\n            n = A[i]\n            right = left = sd.bisect_left(n)\n            if left == len(sd) or sd.keys()[left] != n:\n                left -= 1\n            \n            if left >= 0:\n                even[i] = odd[sd.values()[left][-1]]\n            if right < len(sd):\n                odd[i] = even[sd.values()[right][-1]]\n            \n            if n in sd:\n                sd[n].append(i)\n            else:\n                sd[n] = [i]\n        \n        return sum(odd)", "class Solution:\n\n    memo = {}\n    next_memo = {}\n    \n    def get_next_move(self, array, index, odd):\n        if index == len(array) - 1:\n            return index\n        \n        if (index, odd) not in list(Solution.next_memo.keys()):\n            if odd:\n                min_geq = 1e99\n                next_index = -1\n\n                for i in range(index + 1, len(array)):\n\n                    if array[i] == array[index]:\n                        next_index = i\n                        break\n                    if array[i] > array[index]:\n                        if array[i] < min_geq:\n                            min_geq = array[i]\n                            next_index = i        \n            else:\n                max_leq = -1e99\n                next_index = -1\n\n                for i in range(index + 1, len(array)):\n                    if array[i] == array[index]:\n                        next_index = i\n                        break\n                    if array[i] < array[index]:\n                        if array[i] > max_leq:\n                            max_leq = array[i]\n                            next_index = i\n            Solution.next_memo[(index, odd)] = next_index\n\n        return Solution.next_memo[(index, odd)]            \n        \n    \n    def can_get_to_end(self, array, index, odd):\n        \n        if (index, odd) not in list(Solution.memo.keys()):            \n            next_index = self.get_next_move(array, index, odd)\n            \n            if next_index == len(array) - 1:\n                Solution.memo[(index, odd)] = 1\n            elif next_index == -1:\n                Solution.memo[(index, odd)] = 0\n            else:\n                Solution.memo[(index, odd)] = self.can_get_to_end(array, next_index, not odd)\n        \n        return Solution.memo[(index, odd)]\n        \n    \n    def other(self, a):\n        \n        b = list(sorted(list(range(len(a))), key=lambda i: a[i]))\n        c = list(sorted(list(range(len(a))), key=lambda i: -a[i]))\n        \n        \n        odd_next = {}\n        even_next = {}\n        i = 1\n        while i < len(b):\n            j = i\n            while j < len(b) - 1 and b[j] <= b[i - 1]:\n                j += 1\n            if b[j] > b[i - 1]:\n                odd_next[b[i - 1]] = b[j]\n            i += 1\n        \n        i = 1\n        while i < len(c):\n            j = i\n            while j < len(c) - 1 and c[j] <= c[i - 1]:\n                j += 1\n            if c[j] > c[i - 1]:\n                even_next[c[i - 1]] = c[j]\n            i += 1\n        \n        \n#         print(b)\n#         print(c)\n        \n#         print(odd_next)\n#         print(even_next)\n        \n        paths = 0\n        \n        for start in list(odd_next.keys()):\n            \n            index = start\n            can_go = True\n            odd = True\n            while can_go and index != len(a) - 1:\n                if odd:\n                    if index in list(odd_next.keys()):\n                        index = odd_next[index]\n                    else:\n                        can_go = False\n                else:\n                    if index in list(even_next.keys()):\n                        index = even_next[index]\n                    else:\n                        can_go = False\n                odd = not odd\n            if index == len(a) - 1:\n                # print(start)\n                paths += 1\n\n        if len(a) - 1 not in list(odd_next.keys()):\n            paths += 1\n        \n        \n        return paths\n    \n    \n    def oddEvenJumps(self, a: List[int]) -> int:\n        return self.other(a)\n    \n    \n#         paths = 0\n        \n#         for i in range(len(a)):\n#             _ = self.can_get_to_end(a, len(a) - i, True)\n#             _ = self.can_get_to_end(a, len(a) - i, False)\n        \n#         for i in range(len(a)):\n#             paths += self.can_get_to_end(a, i, True)\n        \n#         Solution.memo = {}\n#         Solution.next_memo = {}\n#         return paths\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        from sortedcontainers import SortedSet\n        li = A\n        dp = SortedSet() # Ele: tuple(Odd Jump can take to end, Even Jump take to goal)\n        res = 1\n        answers = dict()\n        dp.add(li[-1])\n        answers[li[-1]] = (True, True)\n        for i in range(len(li)-2,-1,-1):\n            #print(dp, li[i])\n            temp = dp.bisect_right((li[i]-1))\n            #print(temp)\n            odd_jump = answers[dp[temp]][1] if -1<temp<len(dp) and dp[temp]>=li[i] else False\n            temp = dp.bisect_right((li[i]))-1\n            #print(temp)\n            even_jump = answers[dp[temp]][0] if -1<temp<len(dp) and dp[temp]<=li[i] else False\n            dp.add((li[i]))\n            answers[li[i]] = (odd_jump, even_jump)\n            if odd_jump: res+=1\n        return res\n            \n            \n            \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        #dp\n        #for j, lookup from right to left,\n        #dp[i][[even,odd]]: to reach pos i, num of path to reach,\n        #eventually only count odd path\n        \n        N=len(A)\n        \n        def makeNextArray(B):\n            ans = [None]*N\n            stack=[]\n            #print(\\\"B\\\",B)\n            for i in B:\n                while stack and i>stack[-1]:\n                    ans[stack[-1]]=i\n                    stack.pop()\n                stack.append(i)\n                #print(stack,ans)\n            return ans\n        \n        \n        increaseOrder=sorted(list(range(N)),key=lambda i:A[i]) #sorted idx by value\n        oddnext = makeNextArray(increaseOrder)\n        decreaseOrder  = sorted(list(range(N)),key = lambda i:-A[i])\n        evennext = makeNextArray(decreaseOrder)\n        \n        odd = [False]*N\n        even = [False]*N\n        odd[N-1]=True\n        even[N-1]=True\n        for i in range(N-2,-1,-1):\n            #print(odd,even)\n            if oddnext[i] is not None:\n                odd[i]=even[oddnext[i]]\n            if evennext[i] is not None:\n                even[i]=odd[evennext[i]]\n        return sum(odd)\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        n = len(A)\n        \n        # this is increasing order of the content value\n        \n        idxs_sorted_by_value = sorted(range(n), key=lambda i: A[i])\n        \n        #print(idxs_sorted_by_value)\n        \n        odd_next_hops = self.get_next_hops(idxs_sorted_by_value)\n        \n        idxs_sorted_by_value.sort(key=lambda i: -A[i])\n        \n        even_next_hops = self.get_next_hops(idxs_sorted_by_value)\n\n        odd, even = [False] * n, [False] * n\n        odd[-1], even[-1] = True, True\n        \n        \n        for i in reversed(range(n - 1)):\n            odd_next_hop, even_next_hop = odd_next_hops[i], even_next_hops[i]\n            if odd_next_hop: odd[i] = even[odd_next_hop]\n            if even_next_hop: even[i] = odd[even_next_hop]\n\n        return sum(odd)\n\n    \n    \n    def get_next_hops(self, idxs_sorted_by_value):\n        # this is for setting the ans space\n        next_hop = [None] * len(idxs_sorted_by_value)\n        # setting up a new empty stack\n        # this stack can only save the index number\n        stack = []\n\n        for i in idxs_sorted_by_value:\n            # only extracted index value, this value following the order is \n            # according content is increasing \n            # only meet the condition, then adding into the array\n            # if we cut the while ,stack is [0,2,1,3,4] saving the index numbers\n            # next_hop[ ], has an under cover order, every next_hop[]\n            # accord to origion array [0], [1], [2]\n            # \n            while stack and stack[-1] < i:\n                next_hop[stack.pop()] = i\n                \n            stack.append(i)\n            #print(stack)\n        print(stack)\n        print(next_hop)\n        \n        return next_hop", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        if n==1: return 1\n        dp_even, dp_odd = [False]*(n+1), [False]*(n+1)\n        \n        even_jumps, odd_jumps = [-1]*n, [-1]*n\n        asc_sorted = sorted((val,i) for i,val in enumerate(A))\n        desc_sorted = sorted((-val,i) for i,val in enumerate(A))\n        # odd jumps\n        stack = deque()\n        for val, i in asc_sorted:\n            while stack and stack[-1] < i:\n                odd_jumps[stack.pop()] = i\n            stack.append(i)\n        # even jumps\n        stack = deque()\n        for val, i in desc_sorted:\n            while stack and stack[-1] < i:\n                even_jumps[stack.pop()] = i\n            stack.append(i)\n        \n        dp_even[n-1] = dp_odd[n-1] = True\n        for i in reversed(range(n-1)):\n            dp_even[i] = dp_odd[even_jumps[i]]\n            dp_odd[i] = dp_even[odd_jumps[i]]\n        return dp_odd.count(True)", "from collections import deque\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        if n==1: return 1\n        dp_even, dp_odd = [False]*(n+1), [False]*(n+1)\n        \n        even_jumps, odd_jumps = [-1]*n, [-1]*n\n        asc_sorted = sorted((val,i) for i,val in enumerate(A))\n        desc_sorted = sorted((-val,i) for i,val in enumerate(A))\n        # odd jumps\n        stack = deque()\n        for val, i in asc_sorted:\n            while stack and stack[-1] < i:\n                odd_jumps[stack.pop()] = i\n            stack.append(i)\n        # even jumps\n        stack = deque()\n        for val, i in desc_sorted:\n            while stack and stack[-1] < i:\n                even_jumps[stack.pop()] = i\n            stack.append(i)\n        \n        dp_even[n-1] = dp_odd[n-1] = True\n        for i in reversed(range(n-1)):\n            dp_even[i] = dp_odd[even_jumps[i]]\n            dp_odd[i] = dp_even[odd_jumps[i]]\n        return dp_odd.count(True)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        sorted_enums = sorted(enumerate(A), key = lambda x:x[1])\n        for i, c in sorted_enums:\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n        \n        sorted_enums = sorted(enumerate(A), key = lambda x:-x[1])\n        stack = []\n        for i, c in sorted_enums:\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n        \n        dp_higher, dp_lower = [0] * n, [0] * n\n        dp_higher[n-1] = 1\n        dp_lower[n-1] = 1\n        \n        for i in range(n-2, -1, -1):\n            dp_higher[i] = dp_lower[next_higher[i]]\n            dp_lower[i] = dp_higher[next_lower[i]]\n\n        return sum(dp_higher)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        #[10,13,12,14,15]\n        #0\uff0c2\uff0c1\uff0c3\uff0c4\n        # [2,3,3,4,N4] (makeStack for odd)\n        # 4,3,1,2,0\n        #[None,2,None,None,N4] (makeStack for even)\n\n        sortA = sorted(list(range(len(A))),key=lambda i:A[i])\n        oddStack = self.makeStack(sortA)\n        oddStack[-1]=len(A)-1 #the current index (0 to len) can jump to where in odd step\n        \n        sortA = sorted(list(range(len(A))),key=lambda i:A[i],reverse=True)\n        evenStack = self.makeStack(sortA)\n        evenStack[-1]=len(A)-1\n        print(('evenstakc',evenStack))\n        print(('oddsatck',oddStack))\n        # if one can jump to en at odd or even step\n        odd = [False]*(len(A))\n        even = [False]*(len(A))\n        odd[-1]=True\n        even[-1]=True\n        print(('len odd',len(odd)))\n        print(('len even',len(even)))\n        for i in range(len(A)-2,-1,-1):\n            print(('i is',i))\n            if oddStack[i]:\n                odd[i] = even[oddStack[i]] #if i can jump to oddStack[i], then check if even[oddStack[i]] can jump to end\n            if evenStack[i]:\n                even[i]=odd[evenStack[i]]\n        print(odd)\n        print(even)\n        return sum(odd)\n    def makeStack(self,sortA):\n        stack=[None]*len(sortA)\n        res = []\n        for i in sortA:\n            while res and i>res[-1]:\n                stack[res.pop()]=i\n            res.append(i)\n        return stack\n         \n", "from typing import List\n\n\n#   The problem is how to find next greater element in array, that is righter\n#   We will use decreasing stack and process elements in sorted order\nclass Solution:\n    def build_next_greater_el_array(self, increasing_elements_idxs, next_bigger_el_idxs):\n        decr_stack = []\n        for idx in increasing_elements_idxs:\n            while len(decr_stack) > 0 and decr_stack[-1] < idx:\n                prev_idx = decr_stack.pop()\n                next_bigger_el_idxs[prev_idx] = idx\n\n            decr_stack.append(idx)\n\n    def oddEvenJumps(self, arr: List[int]) -> int:\n        if len(arr) == 0:\n            return 0\n\n        arr_with_idx = [[arr[i], i] for i in range(len(arr))]\n\n        #   for next bigger element\n        arr_with_idx_sorted = sorted(arr_with_idx, key=lambda x: x[0])\n        increasing_elements_idxs = list(map(lambda x: x[1], arr_with_idx_sorted))\n        next_bigger_el_idxs = [None for i in range(len(arr))]\n        self.build_next_greater_el_array(increasing_elements_idxs, next_bigger_el_idxs)\n\n        #   for next smaller element\n        arr_with_idx_sorted_desc = sorted(arr_with_idx, key=lambda x: x[0], reverse=True)\n        increasing_elements_idxs_desc = list(map(lambda x: x[1], arr_with_idx_sorted_desc))\n        next_smaller_el_idxs = [None for i in range(len(arr))]\n        self.build_next_greater_el_array(increasing_elements_idxs_desc, next_smaller_el_idxs)\n\n        #   process elements\n        higher = [False for i in range(len(arr))]\n        lower = [False for i in range(len(arr))]\n\n        higher[-1] = True\n        lower[-1] = True\n\n        result = 1\n        for i in range(len(arr) - 2, -1, -1):\n            next_bigger_el_idx = next_bigger_el_idxs[i]\n            next_smaller_el_idx = next_smaller_el_idxs[i]\n\n            if next_bigger_el_idx is not None:\n                lower[i] = higher[next_bigger_el_idx]\n            if next_smaller_el_idx is not None:\n                higher[i] = lower[next_smaller_el_idx]\n\n            if lower[i] is True:\n                result += 1\n\n        return result", "#Note: this is a difficult question\nclass Solution:\n    #https://stackoverflow.com/questions/61242724/reaching-the-end-of-an-array-with-a-sequence-of-odd-even-jumps\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n\n        def make(B):\n            ans = [None] * N\n            stack = []  # invariant: stack is decreasing\n            for i in B:\n                while stack and i > stack[-1]:\n                    ans[stack.pop()] = i\n                stack.append(i)\n            return ans\n\n        B = sorted(list(range(N)), key = lambda i: A[i])\n        print(B)\n        oddnext = make(B)\n        print(oddnext)\n        #B.sort(key = lambda i: -A[i])\n        B = sorted(list(range(N)), key = lambda i: -A[i])\n        print(B)\n        evennext = make(B)\n        print(evennext)\n\n        odd = [False] * N\n        even = [False] * N\n        odd[N-1] = even[N-1] = True\n\n        for i in range(N-1, -1, -1):\n            if oddnext[i] is not None:\n                odd[i] = even[oddnext[i]]\n            if evennext[i] is not None:\n                even[i] = odd[evennext[i]]\n\n        return sum(odd)\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n        \n        def make(B):\n            ans = [None]*N\n            stack = []\n            for i in B:\n                while stack and i>stack[-1]:\n                    ans[stack.pop()] = i\n                stack.append(i)\n            return ans\n                \n                \n        # sort A[i] in the order of value  \n        # B is a list of index\n        B = sorted(range(N), key = lambda i:A[i])\n        oddnext = make(B)\n        B.sort(key = lambda i: -A[i])\n        evennext = make(B)\n        \n        \n        odd = [False]*N\n        even = [False]*N\n        odd[N-1] = even[N-1] = True\n        \n        # sort from back to the front dynamic program\n        for i in range(N-2, -1, -1):\n            if oddnext[i]:\n                odd[i] = even[oddnext[i]]\n            if evennext[i]:\n                even[i] = odd[evennext[i]]\n        return sum(odd)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        n = len(A)\n        next_odd, next_even = [0]*n, [0]*n\n        \n        # store the legal next index j if odd_jump\n        odd_stack = []\n        # sort smallest value, then smallest index\n        # we want to find the min-larger\n        for num, j in sorted([num, j] for j, num in enumerate(A)):\n            while odd_stack and odd_stack[-1] < j: # i < j\n                i = odd_stack.pop()\n                next_odd[i] = j\n            odd_stack.append(j)\n        # store legal nect index j if even_jump\n        even_stack = []\n        # sort max value, then smallest index\n        # we want to find the max-smaller\n        for num, j in sorted([-num, j] for j, num in enumerate(A)):\n            while even_stack and even_stack[-1] < j:\n                i = even_stack.pop()\n                next_even[i] = j\n            even_stack.append(j)\n\n        odd, even = [0]*n, [0]*n\n        \n        # base case: always true\n        odd[-1] = even[-1] = 1\n        \n        for i in range(n-1)[::-1]:\n            # if we are considering an odd_jump, the next one must be even\n            # use next_odd[i] to find the idx j after jump from i\n            # use indx j for even_jump, if even[j] is true, odd[i] is true as well\n            odd[i] = even[next_odd[i]]\n            even[i] = odd[next_even[i]]\n            \n        # must start with odd(first jump)\n        return sum(odd)\n", "class Solution:\n  \n    def populate_jumps(self, sorted_values_idx, jumps):\n      \n      stack = []\n      for jump_to in sorted_values_idx:\n        \n        while(stack and stack[-1] < jump_to):\n          jump_from = stack.pop()\n          jumps[jump_from] = jump_to\n        \n        stack.append(jump_to)\n      \n    def oddEvenJumps(self, A: List[int]) -> int:\n        #always jumping forward so j >i \n        \n        # odd jumps\n        #right should be >= current and right should be smallest among all >= current\n        \n        # even jumps\n        #right <= current and right should be maximum among all <= current\n        \n        \n        \n        # [10,13,12,14,15]\n        \n        #we can have a dp, marking if we can reach the goal node making an even or a odd numbered jump\n        #brute force, for each idx i, try to make odd jump and then even jump and then see if we are able to land on last idx\n        \n        #we can eleiminate repeated work by remebering that if we can reach the last idx from intermediate nodes by making a odd/even jump , so we only visit each idx once\n        \n        #if we try to do a bottom up dp, calc if we can reach goal node from ith node each by making an odd or an even jump\n        #then calc the np of indexes from where odd jump is possible\n        \n        \n        #next task is to identify which node to jump to in case of even and odd jumps\n        #we can precompute even and odd jumps for all indexes\n        \n        odd_jump = [None]*len(A)\n        even_jump = [None]*len(A)\n        \n        num_idx_array = [(num, idx) for idx, num in enumerate(A)]\n        \n        sorted_idxs = list(map(lambda x: x[1], list(sorted(num_idx_array))))\n        \n        reverse_sorted_idxs = list(map(lambda x: x[1], list(sorted(num_idx_array, key= lambda x: (-x[0], x[1])))))\n        \n        \n        self.populate_jumps(sorted_idxs, odd_jump)\n        self.populate_jumps(reverse_sorted_idxs, even_jump)\n        \n        odd_dp = [False]*len(A)\n        even_dp = [False]*len(A)\n        \n        odd_dp[-1] = True #goal node is always reachable from itself\n        even_dp[-1] = True\n        \n        result = 1\n        print(odd_dp, )\n        #odd_dp = [F, F, F, F, T]\n        #even_dp =[F, F, F, F, T]\n        for start_idx in range(len(A) - 2, -1, -1):\n          \n          if odd_jump[start_idx] is not None and even_dp[odd_jump[start_idx]] is True:\n            odd_dp[start_idx] = True\n            result += 1\n            \n          if even_jump[start_idx] is not None and odd_dp[even_jump[start_idx]] is True:\n            even_dp[start_idx] = True\n            \n        return result", "class Solution(object):\n    def oddEvenJumps(self, A):\n        N = len(A)\n\n        def make(B):\n            ans = [None] * N\n            stack = []  # invariant: stack is decreasing\n            for i in B:\n                while stack and i > stack[-1]:\n                    ans[stack.pop()] = i\n                stack.append(i)\n            return ans\n\n        B = sorted(range(N), key = lambda i: A[i])\n        oddnext = make(B)\n        B.sort(key = lambda i: -A[i])\n        evennext = make(B)\n\n        odd = [False] * N\n        even = [False] * N\n        odd[N-1] = even[N-1] = True\n\n        for i in range(N-2, -1, -1):\n            if oddnext[i] is not None:\n                odd[i] = even[oddnext[i]]\n            if evennext[i] is not None:\n                even[i] = odd[evennext[i]]\n\n        return sum(odd)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        def helper(A):\n            ans=[0]*len(A)\n            stack=[]\n            for a,i in A:\n                while stack and stack[-1]<i:\n                    ans[stack.pop()]=i\n                stack.append(i)\n            return ans\n        \n        odd=helper(sorted([a,i] for i,a in enumerate(A)))\n        even=helper(sorted([-a,i] for i,a in enumerate(A)))\n        l=len(A)\n        oddjump,evenjump=[0]*l,[0]*l\n        oddjump[-1]=evenjump[-1]=1\n        for i in range(l-1)[::-1]:\n            oddjump[i]=evenjump[odd[i]]\n            evenjump[i]=oddjump[even[i]]\n        return sum(oddjump)\n        \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        n = len(A)\n        # build arrays to store the destination of current idx\n        next_odd, next_even = [0]*n, [0]*n\n        \n        # store legal next index j if odd_jump\n        odd_stack = []\n        # sort smallest value, then smallest index\n        # we want to find the min-larger\n        for num, j in sorted([num, j] for j, num in enumerate(A)):\n            while odd_stack and odd_stack[-1] < j: # i < j\n                i = odd_stack.pop()\n                next_odd[i] = j\n            odd_stack.append(j)\n        # store legal nect index j if even_jump\n        even_stack = []\n        # sort max value, then smallest index\n        # we want to find the max-smaller\n        for num, j in sorted([-num, j] for j, num in enumerate(A)):\n            while even_stack and even_stack[-1] < j:\n                i = even_stack.pop()\n                next_even[i] = j\n            even_stack.append(j)\n            \n        # store if odd/even_jumps leads to the last idx\n        # trace back from last one = > base case: always true\n        odd, even = [0]*n, [0]*n\n        odd[-1] = even[-1] = 1\n        \n        for i in range(n-1)[::-1]:\n            # consider an odd_jump, then next one must be even\n            # use next_odd[i] to find the idx j after jump from i\n            # use indx j for even_jump, if even[j] is true, odd[i] is true as well\n            odd[i] = even[next_odd[i]]\n            even[i] = odd[next_even[i]]\n            \n        # must start with odd(first jump)\n        return sum(odd)\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        nums_in = sorted((num, index) for index, num in enumerate(A))\n        print(nums_in)\n        index_in = self.helper(nums_in)\n        \n        nums_de = sorted((-num, index) for index, num in enumerate(A))\n        index_de = self.helper(nums_de)\n        \n        greater = [False] * len(A)\n        smaller = [False] * len(A)\n        \n        greater[-1] = True\n        smaller[-1] = True\n        \n        for i in range(len(A) - 2, -1, -1):\n            greater[i] = smaller[index_in[i]]\n            smaller[i] = greater[index_de[i]]\n        \n        return sum(greater)\n        \n    \n    def helper(self, nums):\n        result = [0] * len(nums)\n        queue = list()\n        \n        for (_, index) in nums:\n            while queue and index > queue[-1]:\n                result[queue.pop()] = index\n            queue.append(index)\n        \n        return result\n    \n    \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n\n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n\n        higher, lower = [0] * n, [0] * n\n        higher[-1] = lower[-1] = 1\n        for i in range(n - 1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)\n                \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n\n        def make(B):\n            ans = [None] * N\n            stack = []  # invariant: stack is decreasing\n            for i in B:\n                while stack and i > stack[-1]:\n                    ans[stack.pop()] = i\n                stack.append(i)\n            return ans\n\n        B = sorted(list(range(N)), key = lambda i: A[i])\n        oddnext = make(B)\n        print((oddnext , B))\n        B.sort(key = lambda i: -A[i])\n        evennext = make(B)\n\n        dest = len(A)-1\n        cnt = 0\n        for idx in range(N):\n            jump,ptr = 1,idx\n            while ptr != None:\n                if ptr == dest:\n                    cnt +=1\n                    break\n                jump,ptr = (0,oddnext[ptr]) if jump==1 else (1,evennext[ptr])\n        return cnt\n", "class Solution:\n                \n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n            \n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n            \n        higher, lower = [0] * n, [0] * n\n        higher[-1] = lower[-1] = 1\n        for i in range(n - 2, -1, -1):\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n            \n        return sum(higher)\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        index = 0\n        n = len(A)\n        next_high = [0] * n\n        next_low = [0] *n\n        stack = []\n        B = [[i, a] for i,a in enumerate(A)]\n        B.sort(key = lambda x:x[1])\n        for i, a in B:\n            while stack and (stack[-1] < i):\n                next_high[stack.pop()] = i\n            stack.append(i)\n        B.sort(key = lambda x:-x[1])\n        stack = []\n        for i, a in B:\n            while stack and (stack[-1] < i):\n                next_low[stack.pop()] = i\n            stack.append(i)\n        \n        higher = [0] * n\n        lower = [0] * n\n        higher[-1] = lower[-1] = 1\n        for i in range(n - 2, -1, -1):\n            higher[i] = lower[next_high[i]]\n            lower[i] = higher[next_low[i]]\n        # print(higher, lower)\n        return sum(higher)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n        # returns a list of the index you can jump to from any index in A\n        # runs twice since where you jump to on an even jump is diff than an odd jump\n        def make(sorted_index_locations: [int]):\n            # 'None' means no jump is possible from this index in A\n            jump_to_locations = [None] * N\n\n            # The stack is used to track indexes that you\n            stack = []\n\n            # now walk the list in order\n            # if index_location > stack[-1], it means index_location is past stack[-1]\n            # since sorted_index_locations is sorted smallest to largest, all smaller numbers are behind it\n            # so it's finding the next-lowest number that's further up the list -- this is where it will jump to.\n\n            for index_location in sorted_index_locations:\n                while stack and index_location > stack[-1]:\n                    # all items on the stack are smaller and are behind it in A\n                    # so they'll jump to the same place this index will jump to\n                    jump_to_locations[stack.pop()] = index_location\n                # if stack is empty or this index is higher than the last on on the stack,\n                # push this onto the stack and go to the next index\n                stack.append(index_location)\n\n            # jump_to_locations contains the location you jump, or None if you can't jump from that index\n            return jump_to_locations\n\n        B = sorted(list(range(N)), key=lambda i: A[i])\n        odd_jump_to_locations = make(B)\n        B.sort(key=lambda i: -A[i])\n        even_jump_to_locations = make(B)\n\n        # odd and even have 'good indexes' where they end up True after this.\n        # initialize assuming only that the very last location (A[N-1]) will always be True.\n        odd = [False] * N\n        even = [False] * N\n        odd[N - 1] = even[N - 1] = True\n\n        for i in range(N - 2, -1, -1):\n            if odd_jump_to_locations[i] is not None:\n                odd[i] = even[odd_jump_to_locations[i]]\n            if even_jump_to_locations[i] is not None:\n                even[i] = odd[even_jump_to_locations[i]]\n\n        return sum(odd)\n\n\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n\n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n\n        higher, lower = [0] * n, [0] * n\n        higher[-1] = lower[-1] = 1\n        for i in range(n - 1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)\n                \n                    \n            \n                \n              \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n        \n        stack = []\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n        \n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n        \n        validOddStartingPoints, validEvenStartingPoints = [0] * n, [0] * n\n        validOddStartingPoints[-1] = validEvenStartingPoints[-1] = 1\n        \n        for i in range(n-2, -1, -1):\n            validOddStartingPoints[i] = validEvenStartingPoints[next_higher[i]]\n            validEvenStartingPoints[i] = validOddStartingPoints[next_lower[i]]\n        \n        return sum(validOddStartingPoints)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        odd_jump = {}\n        even_jump = {}\n        index_ele = {index: ele for index, ele in enumerate(A)}\n        # {0: 10. 2: 12, 1: 13}\n        sorted_A = sorted(list(range(len(A))), key=lambda x: A[x])\n        even_sorted_A = sorted(list(range(len(A))), key=lambda x: (A[x], -x))\n        # cache = {}\n        # sorted(index_ele.items(), key=lambda kv: (kv[1], kv[0]))\n        # print(sorted_A)\n        # [1: 3, 1:2, 2:0, 3:1, 4:4]\n        # [4: 4, 3: 1, 2:0. 1:2, 1:3]\n        # [4, 1, 0, 3]\n        stack = []\n        # [1, 1, 2,3,4]\n        for i in range(len(A)):\n            idx = sorted_A[i]\n            # idx = ele_index[ele]\n            while stack and stack[-1] < idx:\n                old_index = stack.pop()\n                odd_jump[old_index] = idx\n            stack.append(idx)\n        for idx in stack:\n            odd_jump[idx] = -1        \n        stack = []\n        for i in range(len(A) - 1, -1, -1):\n            idx = even_sorted_A[i]\n            # idx = ele_index[ele]\n            while stack and stack[-1] < idx:\n                old_index = stack.pop()\n                even_jump[old_index] = idx\n            stack.append(idx)\n        for idx in stack:\n            even_jump[idx] = -1\n        self.ans = 0\n        # print(odd_jump, even_jump)\n        @lru_cache(None)\n        def helper(index, odd):\n            if index == len(A) - 1:\n                # self.ans += 1\n                return 1\n            ans = 0\n            if index == -1:\n                return 0\n            # if (index, odd) in self.cache: return self.cache[(index, odd)]\n            if odd:\n                # print(index)\n                ans += helper(odd_jump[index], not odd)\n            else:\n                ans += helper(even_jump[index], not odd)\n                # [10, 12, 13, 14, 15]\n                # [0,   2,  1,  3,  4]\n                # 1\n                # 2   3   3  4 -1\n                # [15, 14, 13, 12, 10]\n                # [15, 14, 12, 10]\n                #  -1        13: 2\n            return ans\n        ans = 0\n        for i in range(len(A)):\n            ans += helper(i, True)\n        return ans\n", "def get_nsge_ngse(a):\n    ngse_stack = []\n    nsge_stack = []\n    ngse = [-1]*len(a)\n    nsge = [-1]*len(a)\n    for i,item in sorted(enumerate(a), key = lambda x: (x[1], x[0])):\n        while nsge_stack and i > nsge_stack[-1]:\n            nsge[nsge_stack.pop()] = i\n        nsge_stack.append(i)\n    for i,item in sorted(enumerate(a), key = lambda x: (-1*x[1], x[0])):\n        while ngse_stack and i > ngse_stack[-1]:\n            ngse[ngse_stack.pop()] = i\n        ngse_stack.append(i)\n    return(nsge, ngse)\n\ndef get_ways(a):\n    odd, even = get_nsge_ngse(a)\n    print(odd,even)\n    dp =[set() for x in a]\n    dp[-1].add('even')\n    dp[-1].add('odd')\n    count = 1\n    for i in range(len(a)-2,-1,-1):\n        if odd[i] !=-1 and 'even' in dp[odd[i]]:\n            dp[i].add('odd')\n        if even[i] !=-1 and 'odd' in dp[even[i]]:\n            dp[i].add('even')\n        if 'odd' in dp[i]:\n            count +=1\n    return count\n            \n            \n\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        return get_ways(A)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        n = len(A)\n        \n        s1 = []\n        s2 = []\n        \n        stack = []\n        e = enumerate(A)\n        order = sorted(e, key = lambda x: (x[1], x[0]))\n        \n        for i in reversed(list(range(n))):\n            while stack and stack[-1] < order[i][0]:\n                stack.pop()\n            order[i] = (order[i][0],stack[-1]) if stack else (order[i][0],-1)\n            stack.append(order[i][0])\n        \n        arr_odd = [-1] * n\n        for i in range(n):\n            arr_odd[order[i][0]] = order[i][1]\n        \n        stack = []\n        e = enumerate(A)\n        order = sorted(e, key = lambda x: x[1], reverse = True)\n        for i in reversed(list(range(n))):\n            while stack and stack[-1] < order[i][0]:\n                stack.pop()\n            order[i] = (order[i][0],stack[-1]) if stack else (order[i][0],-1)\n            stack.append(order[i][0])\n        \n        arr_even = [-1] * n\n        for i in range(n):\n            arr_even[order[i][0]] = order[i][1]\n        \n        DP = [[False] * 2 for _ in range(n)]\n        DP[n-1][0] = True\n        DP[n-1][1] = True\n        \n        for i in reversed(list(range(n-1))):\n            if arr_odd[i] == n-1:\n                DP[i][0] = True\n            elif arr_odd[i] != -1:\n                DP[i][0] = DP[arr_odd[i]][1]\n            \n            if arr_even[i] == n-1:\n                DP[i][1] = True\n            elif arr_even[i] != -1:\n                DP[i][1] = DP[arr_even[i]][0]\n        \n        count = 0\n        for i in range(n):\n            if DP[i][0] == True:\n                count += 1\n        \n        return count\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        if not A:\n            return 0\n        \n        n = len(A)\n        \n        # get next pos for odd/even jumps\n        next_pos = [[-1] * 2 for _ in range(n)]\n        \n        stack = []\n        \n        idxes = sorted([i for i in range(n)], key=lambda i: (A[i], i))\n        \n        for idx in idxes:\n            while stack and stack[-1] < idx:\n                next_pos[stack[-1]][1] = idx\n                stack.pop()\n            \n            stack.append(idx)\n        \n        stack = []\n        \n        idxes = sorted([i for i in range(n)], key=lambda i: (-A[i], i))\n        \n        for idx in idxes:\n            while stack and stack[-1] < idx:\n                next_pos[stack[-1]][0] = idx\n                stack.pop()\n            \n            stack.append(idx)\n        \n        dp = [[False] * 2 for _ in range(n)]\n        \n        ret = 0\n        \n        for i in range(n - 1, -1, -1):\n            if i == n - 1:\n                dp[i][0] = True\n                dp[i][1] = True\n                \n            else:\n            \n                odd_next = next_pos[i][1]\n                if odd_next == -1:\n                    dp[i][1] = False\n                else:\n                    dp[i][1] = dp[odd_next][0]\n                \n                even_next = next_pos[i][0]\n                if even_next == -1:\n                    dp[i][0] = False\n                else:\n                    dp[i][0] = dp[even_next][1]\n                    \n            \n            if dp[i][1] == True:\n                ret += 1\n        \n        return ret\n            \n            \n            \n            \n            \n            \n        \n        \n        \n        \n        \n        \n        \n        # dp for odd/even jumps whether can get the end\n        \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        more = {}\n        less = {}\n        stack = []\n        \n        B = sorted(range(n), key=lambda i: A[i])\n        for i in B:\n            while stack and stack[-1] < i:\n                more[stack.pop()] = i\n                \n            stack.append(i)\n            \n        B = sorted(range(n), key=lambda i: -A[i])\n        for i in B:\n            while stack and stack[-1] < i:\n                less[stack.pop()] = i\n                \n            stack.append(i)\n            \n        count = 0\n        for i in range(n):\n            jumps = 1\n            j = i\n            while j < n - 1:\n                if jumps % 2:\n                    j = more[j] if j in more else None\n                else:\n                    j = less[j] if j in less else None\n                    \n                if j is None:\n                    break\n                \n                jumps += 1\n                    \n            if j is not None:\n                count += 1\n                \n        return count", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        l = len(A)\n        idxs = sorted(range(l), key=lambda i: A[i])\n        odds = [-1] * l\n        stack = []\n        for i in idxs:\n            while stack and stack[-1] < i:\n                odds[stack.pop()] = i\n            stack.append(i)\n        idxs = sorted(range(l), key=lambda i: -A[i])\n        evens = [-1] * l\n        stack = []\n        for i in idxs:\n            while stack and stack[-1] < i:\n                evens[stack.pop()] = i\n            stack.append(i)\n        reachable = [[-1, -1] for _ in range(l)]\n        reachable[-1] = [1, 1]\n        def helper(i, j):\n            if reachable[i][j] >= 0:\n                return reachable[i][j]\n            if j == 0:\n                reachable[i][j] = 0 if odds[i] == -1 else helper(odds[i], 1)\n            else:\n                reachable[i][j] = 0 if evens[i] == -1 else helper(evens[i], 0)\n            return reachable[i][j]\n        return sum(helper(i, 0) for i in range(l))", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n        \n        nextSmallestLarger = [-1] * N\n        indexes = sorted(range(N), key=lambda i: A[i])\n        stk = []\n        for i in indexes:\n            while stk and i > stk[-1]:\n                nextSmallestLarger[stk.pop()] = i\n            stk.append(i)\n        \n        nextLargestSmaller = [-1] * N\n        indexes = sorted(range(N), key=lambda i: -A[i])\n        stk = []\n        for i in indexes:\n            while stk and i > stk[-1]:\n                nextLargestSmaller[stk.pop()] = i\n            stk.append(i)\n        \n        @lru_cache(None)\n        def jump(i, odd):\n            if i >= N - 1:\n                return True\n            \n            if odd:\n                return False if nextSmallestLarger[i] == -1 else jump(nextSmallestLarger[i], False)\n            else:\n                return False if nextLargestSmaller[i] == -1 else jump(nextLargestSmaller[i], True)\n            \n        return sum(jump(i, True) for i in range(N))", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n        # returns a list of the index you can jump to from any index in A\n        # runs twice since where you jump to on an even jump is diff than an odd jump\n        def make(sorted_index_locations: [int]):\n            # 'None' means no jump is possible from this index in A\n            jump_to_locations = [None] * N\n\n            # The stack is used to track indexes that you\n            stack = []\n\n            # now walk the list in order\n            # if index_location > stack[-1], it means index_location is past stack[-1]\n            # since sorted_index_locations is sorted smallest to largest, all smaller numbers are behind it\n            # so it's finding the next-lowest number that's further up the list -- this is where it will jump to.\n\n            for index_location in sorted_index_locations:\n                while stack and index_location > stack[-1]:\n                    # all items on the stack are smaller and are behind it in A\n                    # so they'll jump to the same place this index will jump to\n                    jump_to_locations[stack.pop()] = index_location\n                # if stack is empty or this index is higher than the last on on the stack,\n                # push this onto the stack and go to the next index\n                stack.append(index_location)\n\n            # jump_to_locations contains the location you jump, or None if you can't jump from that index\n            return jump_to_locations\n\n        B = sorted(list(range(N)), key=lambda i: A[i])\n        odd_jump_to_locations = make(B)\n        B.sort(key=lambda i: -A[i])\n        even_jump_to_locations = make(B)\n\n        # odd and even have 'good indexes' where they end up True after this.\n        # initialize assuming only that the very last location (A[N-1]) will always be True.\n        odd = [False] * N\n        even = [False] * N\n        odd[N - 1] = even[N - 1] = True\n\n        for i in range(N - 2, -1, -1):\n            if odd_jump_to_locations[i] is not None:\n                odd[i] = even[odd_jump_to_locations[i]]\n            if even_jump_to_locations[i] is not None:\n                even[i] = odd[even_jump_to_locations[i]]\n\n        return sum(odd)\n\n", "from functools import lru_cache\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        next_larger_idx = [None] * len(A)\n        next_smaller_idx = [None] * len(A)\n        \n        sorted_idx_asc = sorted(list(range(len(A))), key=lambda i: A[i])\n        sorted_idx_desc = sorted(list(range(len(A))), key=lambda i: A[i], reverse=True)\n        \n        stack = []\n        for idx in sorted_idx_asc:\n            while stack and stack[-1] < idx: # we found next_larger_value in closest idx.\n                prev_idx = stack.pop()\n                next_larger_idx[prev_idx] = idx\n            stack.append(idx)\n        \n        stack = []\n        for idx in sorted_idx_desc:\n            while stack and stack[-1] < idx: # we found next_smaller_value in closest idx.\n                prev_idx = stack.pop()\n                next_smaller_idx[prev_idx] = idx\n            stack.append(idx)\n                \n        def get_next(idx, is_odd):\n            if is_odd:\n                return next_larger_idx[idx]\n            else:\n                return next_smaller_idx[idx]\n                \n        \n        \n        # Define helper\n        @lru_cache(maxsize=len(A) * 3)\n        def is_goalable_from(idx, is_odd):\n            # Search next steps\n            if idx == len(A) - 1:\n                return True\n            if is_odd:\n                smallest_idx = get_next(idx, is_odd)\n                if smallest_idx is None:\n                    return False\n                return is_goalable_from(smallest_idx, not is_odd)\n            else: # even\n                largest_idx = get_next(idx, is_odd)\n                if largest_idx is None:\n                    return False\n                return is_goalable_from(largest_idx, not is_odd)\n                \n        # Main\n        counts = 0\n        for start_idx in range(len(A)):\n            if is_goalable_from(start_idx, True):\n                counts += 1\n        return counts\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        odd_jumps = {}\n        stack = []\n        for num, i in sorted([[num, i] for i, num in enumerate(A)], reverse = True):\n            while stack and stack[-1][1] < i:\n                stack.pop()\n            if not stack:\n                odd_jumps[i] = None\n            else:\n                odd_jumps[i] = stack[-1][1]\n            stack.append([num, i])\n            \n        even_jumps = {}\n        stack = []\n        for num, i in sorted([[num, -i] for i, num in enumerate(A)]):\n            i = -i\n            while stack and stack[-1][1] < i:\n                stack.pop()\n            if not stack:\n                even_jumps[i] = None\n            else:\n                even_jumps[i] = stack[-1][1]\n            stack.append([num, i])\n          \n        n = len(A)\n        @lru_cache(None)\n        def dfs(i, is_odd):\n            if i == n - 1:\n                return True\n            if is_odd and odd_jumps[i]:\n                return dfs(odd_jumps[i], False) \n            elif not is_odd and even_jumps[i]:\n                return dfs(even_jumps[i], True) \n            else:\n                return False\n        \n        res = 0\n        for i in range(n):\n            res += 1 if dfs(i, True) else 0\n        return res\n                \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n\n        def make(B):\n            ans = [None] * N\n            stack = []  # invariant: stack is decreasing\n            for i in B:\n                while stack and i > stack[-1]:\n                    ans[stack.pop()] = i\n                stack.append(i)\n            return ans\n\n        B = sorted(range(N), key = lambda i: A[i])\n        oddnext = make(B)\n        B.sort(key = lambda i: -A[i])\n        evennext = make(B)\n\n        odd = [False] * N\n        even = [False] * N\n        odd[N-1] = even[N-1] = True\n\n        for i in range(N-2, -1, -1):\n            if oddnext[i] is not None:\n                odd[i] = even[oddnext[i]]\n            if evennext[i] is not None:\n                even[i] = odd[evennext[i]]\n\n        return sum(odd)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        def make_mono_stack(sorted_idxes):\n            result = [None]*len(sorted_idxes)\n            stack = []\n            for idx in sorted_idxes:\n                while stack and idx > stack[-1]:\n                    result[stack.pop()] = idx\n                stack.append(idx)\n            return result\n        \n        n = len(A)\n        sorted_idxes = sorted(list(range(n)), key=lambda i: A[i])\n        odd_next = make_mono_stack(sorted_idxes)\n        # sorted_idxes = sorted(range(n), key=lambda x: A[x], reverse=True)\n        sorted_idxes.sort(key=lambda i: A[i], reverse=True)\n        even_next = make_mono_stack(sorted_idxes)\n        \n        odd_can_reach_from_idx = [False]*n\n        even_can_reach_from_idx = [False]*n\n        # we can reach to last idx from last idx itself\n        odd_can_reach_from_idx[-1]= even_can_reach_from_idx[-1] = True\n        \n        # iterate through A backwards, starting at next to last element\n        for i in range(len(A) - 2, -1, -1):\n            if odd_next[i] is not None:\n                odd_can_reach_from_idx[i] = even_can_reach_from_idx[odd_next[i]]\n            if even_next[i] is not None:\n                even_can_reach_from_idx[i] = odd_can_reach_from_idx[even_next[i]]\n        return sum(odd_can_reach_from_idx)\n        \n", "from collections import defaultdict\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        cand = defaultdict(lambda: [set(), set()])\n        stack, stack_dec = [], []\n        for x, i in sorted([(x, i) for i, x in enumerate(A)]):\n            while len(stack) > 0 and stack[-1][1] < i:\n                cand[i][0].add(stack.pop()[1])\n            stack.append((x, i))\n        for x, i in sorted([(x, i) for i, x in enumerate(A)], key=lambda y: (-y[0], y[1])):\n            while len(stack_dec) > 0 and stack_dec[-1][1] < i:\n                cand[i][1].add(stack_dec.pop()[1])\n            stack_dec.append((x, i))\n        \n        n = len(A)\n        ans = {n - 1}\n        for_odd, for_even = {n - 1}, {n - 1}\n        time = 0\n        \n        while len(for_odd) > 0 or len(for_even) > 0:\n            time += 1\n            new_odd, new_even = set(), set()\n            for x in for_odd:\n                for y in cand[x][1]:\n                    new_even.add(y)\n            for x in for_even:\n                for y in cand[x][0]:\n                    new_odd.add(y)\n            for x in new_odd:\n                ans.add(x)\n            for_odd, for_even = new_odd, new_even\n        \n        return len(ans)\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        next_high = [0 for _ in range(len(A))]\n        next_low = [0 for _ in range(len(A))]\n        \n        stack = []\n        for val, i in sorted([(val, i) for i, val in enumerate(A)]):\n            while stack and stack[-1] < i:\n                next_high[stack.pop()] = i\n            stack.append(i)\n            \n        stack = []\n        for val, i in sorted([(-val, i) for i, val in enumerate(A)]):\n            while stack and stack[-1] < i:\n                next_low[stack.pop()] = i\n            stack.append(i)\n        \n        dp = [[False for _ in range(len(A))] for _ in range(2)]\n        dp[0][-1] = dp[1][-1] = True\n        for i in range(len(A) - 2, -1, -1):\n            dp[0][i] = dp[1][next_high[i]]\n            dp[1][i] = dp[0][next_low[i]]\n\n        return dp[0].count(1)\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n\n        def make(B):\n            ans = [None] * N\n            stack = []  # invariant: stack is decreasing\n            for i in B:\n                while stack and i > stack[-1]:\n                    ans[stack.pop()] = i\n                stack.append(i)\n            return ans\n\n        B = sorted(list(range(N)), key = lambda i: A[i])\n        oddnext = make(B)\n        B.sort(key = lambda i: -A[i])\n        evennext = make(B)\n\n        odd = [False] * N\n        even = [False] * N\n        odd[N-1] = even[N-1] = True\n\n        for i in range(N-2, -1, -1):\n            if oddnext[i] is not None:\n                odd[i] = even[oddnext[i]]\n            if evennext[i] is not None:\n                even[i] = odd[evennext[i]]\n\n        return sum(odd)\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        #for all the odd jump, can only jump to number greater or equal\n        #for all the even jump, can only jump to number less or equal\n        \n        n = len(A)\n        odd_jump = [-1] * n \n        even_jump = [-1] * n\n        \n        final_odd = [False] * n \n        final_even = [False] * n \n        final_odd[-1] = True \n        final_even[-1] = True\n        \n        stack = []\n        for n, i in sorted((n,i) for i,n in enumerate(A)):\n            while stack and stack[-1] < i:\n                odd_jump[stack.pop()] = i \n            stack.append(i)\n        \n        \n        stack = []\n        for n, i in sorted((-n,i) for i, n in enumerate(A)):\n            while stack and stack[-1] < i:\n                even_jump[stack.pop()] = i \n            stack.append(i)\n        \n     \n        \n        for i in range(len(A)-2,-1,-1):\n            print(i)\n            if odd_jump[i] != -1:\n                final_odd[i] = final_even[odd_jump[i]]\n            if even_jump[i] != -1:\n                final_even[i] = final_odd[even_jump[i]]\n        return sum(final_odd)\n        \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        \n        next_higher = [0 for x in range(n)] \n        next_lower = [0 for x in range(n)]\n        stack = []\n        \n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n            \n\n        higher = [0 for x in range(n)] \n        lower = [0 for x in range(n)]\n        higher[-1] =  1\n        lower[-1] = 1\n        for i in range(n - 1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        next_higher, next_lower = [0]*n, [0]*n\n        \n        stack = []\n        for a, i in sorted([a,i] for i,a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n        \n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n        \n        higher, lower = [0]*n, [0]*n\n        higher[-1] = lower[-1] = 1\n        for i in range(n-1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n        idxes = range(N)\n        \n        def make(B):\n            ans = [None] * N\n            stack = []\n            for i in B:\n                while stack and i > stack[-1]:\n                    pop = stack.pop()\n                    ans[pop] = i\n                stack.append(i)\n            return ans\n        \n        sorted_idxes = sorted(idxes, key=lambda i: A[i])\n        oddnext = make(sorted_idxes)\n        sorted_idxes_rev = sorted(idxes, key=lambda i: -A[i])\n        evennext = make(sorted_idxes_rev)\n        \n        odd = [False] * N\n        even = [False] * N\n        \n        odd[N-1] = True\n        even[N-1] = True\n        \n        for i in range(N-2, -1, -1):\n            if oddnext[i] is not None:\n                odd[i] = even[oddnext[i]]\n            if evennext[i] is not None:\n                even[i] = odd[evennext[i]]\n        #print(odd, even)\n            \n        #print(A, sorted_idxes, sorted_idxes_rev)\n        return sum(1 for x in odd if x)", "class Solution:\n    def oddEvenJumps(self, A):\n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n\n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n\n        higher, lower = [0] * n, [0] * n\n        higher[-1] = lower[-1] = 1\n        for i in range(n - 1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        \n        next_higher = [0 for x in range(n)] \n        next_lower = [0 for x in range(n)]\n        stack = []\n        \n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n        print(next_higher)\n        #print(sorted([a, i] for i, a in enumerate(A)))\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n            \n\n        higher = [0 for x in range(n)] \n        lower = [0 for x in range(n)]\n        higher[-1] =  1\n        lower[-1] = 1\n        for i in range(n - 1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)", "import heapq\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        mono_inc = sorted([(i, val) for i, val in enumerate(A)], key=lambda x:x[1])\n        mono_dec = sorted(mono_inc, reverse=True, key=lambda x:x[1])\n        \n        odd_jumps = [None] * len(mono_inc)\n        for i, el in enumerate(mono_inc):\n            j = i + 1\n            while j < len(mono_inc):\n                next_el = mono_inc[j]\n                if next_el[0] > el[0]:\n                    odd_jumps[el[0]] = next_el[0]\n                    break\n                j += 1\n        \n        even_jumps = [None] * len(mono_dec)\n        for i, el in enumerate(mono_dec):\n            j = i + 1\n            while j < len(mono_dec):\n                next_el = mono_dec[j]\n                if next_el[0] > el[0]:\n                    even_jumps[el[0]] = next_el[0]\n                    break\n                j += 1\n        \n        odd = {}\n        even = {}\n        i = len(A) - 1\n        while i >= 0:\n            if i == (len(A) - 1):\n                odd[i] = True\n                even[i] = True\n                i -= 1\n                continue\n            odd_dest = odd_jumps[i]\n            odd[i] = even[odd_dest] if odd_dest is not None else False\n            even_dest = even_jumps[i]\n            even[i] = odd[even_dest] if even_dest is not None else False\n            i -= 1\n        return sum(odd.values())", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        N = len(A)\n        \n        # preparation: sorted A\n        aS = [(val, i) for i, val in enumerate(A)]\n        aS.sort(key=lambda x: x[0])\n        a_map = {}\n        for id, (val, i) in enumerate(aS):\n            a_map[i] = id\n        dS = [(val, i) for i, val in enumerate(A)]\n        dS.sort(key=lambda x: x[0], reverse=True)\n        d_map = {}\n        for id, (val, i) in enumerate(dS):\n            d_map[i] = id\n                \n        # dp[i] tracks the validness for tarting index i, dp[i] = [x, y] where x, y = 1/0 indicating an (x) even jump or an (y) odd being valid or not\n        dp = [[0,0]] * N\n        dp[N - 1] = [1, 1]\n        \n        for i in range(N - 2, -1, -1):\n            dp[i] = [0, 0]\n            # even jump, find the biggest smaller one next\n            id = d_map[i]\n            while id + 1 < N: \n                val, j = dS[id + 1]\n                if j > i: \n                    dp[i][0] = dp[j][1]\n                    break\n                id = id + 1\n            # odd jump, find the smallest bigger one next\n            id = a_map[i]\n            while id + 1 < N: \n                val, j = aS[id + 1]\n                if j > i: \n                    dp[i][1] = dp[j][0]\n                    break\n                id = id + 1\n        \n        # find the dp[i] with odd (1st) is 1\n        cnt = 0\n        for i in range(N):\n            cnt += dp[i][1]\n        \n        return cnt\n            \n                    \n            \n        \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        # Monotonic Stack\n        # Time  complexity: O(NlogN)\n        # Space complexity: O(N)\n        # N = len(A)\n\n        # def make(B):\n        #     ans = [None] * N\n        #     stack = []  # invariant: stack is decreasing\n        #     for i in B:\n        #         while stack and i > stack[-1]:\n        #             ans[stack.pop()] = i\n        #         stack.append(i)\n        #     return ans\n\n        # B = sorted(range(N), key=lambda i: A[i])\n        # oddnext = make(B)\n        # B.sort(key=lambda i: -A[i])\n        # evennext = make(B)\n\n        # odd = [False] * N\n        # even = [False] * N\n        # odd[N - 1] = even[N - 1] = True\n\n        # for i in range(N - 2, -1, -1):\n        #     if oddnext[i] is not None:\n        #         odd[i] = even[oddnext[i]]\n        #     if evennext[i] is not None:\n        #         even[i] = odd[evennext[i]]\n\n        # return sum(odd)\n\n\n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n\n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n\n        higher, lower = [0] * n, [0] * n\n        higher[-1] = lower[-1] = 1\n\n        for i in range(n - 1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n\n        return sum(higher)\n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        # [ 0, 1, 2, 3, 4]\n        # [10,13,12,14,15]\n        \n        # [ 0, 2, 1, 3, 4]\n        # [10,12,13,14,15]\n        # [-15,-14,-13,-12,-10]\n        \n        # [ 0, 2, 1, 3, 4]\n        # [ 0, 2, 2, 3, 4]\n        \n        # [12,14,14,15,15] - odds_next\n        # [10,12,12,14,15] - evens_next\n        \n        # [ N, N, N, Y, Y]\n        # [ N, N, N, N, Y]\n        \n        increasing = [(v, i) for i, v in enumerate(A)]\n        increasing.sort()\n        increasing = [item[1] for item in increasing]\n        decreasing = [(v, i) for i, v in enumerate(A)]\n        decreasing.sort(key=lambda item: item[0] * -1)\n        decreasing = [item[1] for item in decreasing]\n            \n        odds_next = make(increasing)\n        evens_next = make(decreasing)\n        \n        odds = [False for i in range(len(A))]\n        odds[len(A) - 1] = True\n        evens = [False for i in range(len(A))]\n        evens[len(A) - 1] = True\n        results = [len(A) - 1]\n        for i in reversed(list(range(len(A) - 1))):\n            if odds_next[i] > i and evens[odds_next[i]]:\n                odds[i] = True\n                results.append(i)\n            if evens_next[i] > i and odds[evens_next[i]]:\n                evens[i] = True\n        print(results)\n        return len(results)\n                \n        \ndef make(arr):\n    output = [i for i in range(len(arr))]\n    stack = []\n    for i in range(len(arr)):\n        value = arr[i]\n        while stack and value > stack[-1]:\n            index = stack.pop()\n            output[index] = value\n        stack.append(value)\n    return output\n        \n", "class Solution:\n    # O(nlog(n)) Time | O(n) Space\n    def oddEvenJumps(self, A: List[int]) -> int:\n        nextHigher = [0] * len(A)\n        nextLower = [0] * len(A)\n        validOdd = [0] * len(A)\n        validEven = [0] * len(A)\n        validOdd[-1] = 1\n        validEven[-1] = 1\n        \n        stack = []\n        #sort array by value, put all smaller valunes' index in stack, if stack[-1] smaller then current index, A[stack[-a]] next higher value is at index i\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                nextHigher[stack.pop()] = i\n            stack.append(i)\n        \n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                nextLower[stack.pop()] = i\n            stack.append(i)\n        \n        for index in reversed(range(len(A) - 1)):\n            validOdd[index] = validEven[nextHigher[index]]\n            validEven[index] = validOdd[nextLower[index]]\n        return sum(validOdd)", "class Solution:\n    def findIndex(self, arr, val):\n        if not arr:\n            return 0\n        \n        start = 0\n        end = len(arr)-1\n        while start < end:\n            mid = start + (end - start)//2\n            if arr[mid][0] < val:\n                start = mid + 1\n            else:\n                end = mid\n        if arr[start][0] < val:\n            start += 1\n        return start\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        \n        odd = [False]*n\n        even = [False]*n\n        \n        odd[-1] = even[-1] = True\n        arr = [[A[-1], n-1]]\n\n        count = 1\n        for index in range(n-2, -1, -1):\n            val = A[index]\n            insindex = self.findIndex(arr, val)\n            \n            evenindex = None\n            if insindex < len(arr):\n                odd[index] = even[arr[insindex][1]]\n                if arr[insindex][0] == val:\n                    evenindex = arr[insindex][1]\n                elif insindex > 0:\n                    evenindex = arr[insindex-1][1]\n            \n            else:\n                evenindex = arr[insindex-1][1]\n            \n            if evenindex is not None:\n                even[index] = odd[evenindex]\n            \n            if insindex < len(arr) and arr[insindex][0] == val:\n                arr[insindex][1] = index\n            else:\n                arr.insert(insindex, [val, index])\n            \n            if odd[index]:\n                count += 1\n        return count\n", "from collections import deque\n\nclass Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        size = len(A)\n        if size < 2:\n            return size\n        oddNext = [-1] * size\n        evenNext= [-1] * size\n        def getNext(arr: list, nextArr: list):\n            stack = deque()\n            for index in arr:\n                while stack and stack[-1] <= index:\n                    nextArr[stack[-1]] = index\n                    stack.pop()\n                stack.append(index)\n        indexes = sorted(list(range(size)), key = lambda i: A[i])\n        getNext(indexes, oddNext)\n        indexes = sorted(list(range(size)), key = lambda i: -A[i])\n        getNext(indexes, evenNext)\n        odds = [False] * size\n        evens = [False] * size\n        odds[size - 1] = True\n        evens[size - 1] = True\n        for index in range(size - 2, -1, -1):\n            if evenNext[index] >= 0 and odds[evenNext[index]]:\n                evens[index] = True\n            if oddNext[index] >= 0 and evens[oddNext[index]]:\n                odds[index] = True\n        return sum([1 for isGood in odds if isGood])", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        \n        n = len(A)\n        \n        \n        even = {}\n        odd = {}\n        stack = []\n        \n        ascending_idx = sorted([i for i in range(n)], key = lambda i: A[i])\n        for idx in ascending_idx:\n            while stack and idx>stack[-1]:\n                odd[stack.pop()]=idx\n            stack.append(idx)\n        \n        stack = []\n        descending_idx = sorted([i for i in range(n)], key = lambda i: -A[i])\n        for idx in descending_idx:\n            while stack and idx>stack[-1]:\n                even[stack.pop()]=idx\n            stack.append(idx)\n        del stack\n                      \n        res = 0\n        for key in list(odd.keys()):\n            if odd[key]==n-1: res += 1\n            else:\n                nxt = odd[key]\n                jumps ,other = 0, even\n                while nxt in other:\n                    jumps += 1\n                    nxt = even[nxt] if jumps%2!=0 else odd[nxt]\n                    if nxt == n-1: \n                        res+=1\n                        break\n                    other = even if jumps%2==0 else odd\n        \n        return res+1\n", "class Solution:\n    def oddEvenJumps(self, B: List[int]) -> int:\n        A = [[v, i] for i, v in enumerate(B)]\n        A.sort()\n        nextHigher = [len(A)] * (len(A) + 1)\n        nextSmaller = [len(A)] * (len(A) + 1)\n        stack = collections.deque()\n        for v, i in A:\n            while stack and stack[-1] < i:\n                nextHigher[stack.pop()] = i\n            stack.append(i)\n            \n\n        stack = collections.deque()\n        A = [[-v, i] for i, v in enumerate(B)]\n        A.sort()\n        for v, i in A:\n            while stack and stack[-1] < i:\n                nextSmaller[stack.pop()] = i\n            stack.append(i)\n        \n        dp = [[False, False] for _ in range(len(A) + 1)]\n        dp[-2] = [True, True] # even, odd jump\n        res = 1\n        for i in range(len(A) - 2, -1, -1):\n            nH, nL = nextHigher[i], nextSmaller[i]\n            dp[i][0] = dp[nL][1]\n            dp[i][1] = dp[nH][0]\n            res += dp[i][1]\n        return res", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        '''\n        Algorithm\n        ---------\n        We need to jump alternatively higher and lower until we reach the end of the array.\n        '''\n        \n        stack = []\n        \n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n        \n        for _, i in sorted([val, index] for index, val in enumerate(A)):\n            # Check if the index at the top of the stack\n            # is less than the current index i. If it is\n            # then the current index i is the next greater element for the index at the top of the stack\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n        \n        stack = []\n        for _, i in sorted([-val, index] for index, val in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n        \n        higher, lower = [0] * n, [0] * n\n        \n        # increment the last index in both the lower and higher\n        # since we know that the end of the array can be reached from the\n        # last index\n        higher[-1] += 1\n        lower[-1] += 1\n        \n        for i in reversed(list(range(n - 1))):\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)\n        \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        #print(sorted([-a, i] for i, a in enumerate(A)))\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n        #print(next_higher)\n        \n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n            \n        #print(next_lower)\n        higher, lower = [0] * n, [0] * n\n        higher[-1] = lower[-1] = 1\n        for i in range(n - 1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)", "class Solution:\n    def oddEvenJumps(self, A):\n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        for a, i in sorted([[a, i] for i, a in enumerate(A)]):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n\n        stack = []\n        for a, i in sorted([[-a, i] for i, a in enumerate(A)]):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n\n        def jump(index, jump_num):\n            if index == n-1:\n                return 1\n            next_index = 0\n            if jump_num % 2 == 1:\n                next_index = next_higher[index]\n            else:\n                next_index = next_lower[index]\n            return jump(next_index, jump_num+1) if next_index else 0\n        \n        result = 0\n        for start in range(n):\n            result += jump(start, 1)\n        return result", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        curr_list = []\n        smaller = []\n        larger = []\n        \n        def find_insertion(ele):\n            left = 0\n            right = len(curr_list)\n            \n            while left < right:\n                middle = (left + right)//2\n                \n                if curr_list[middle] < ele:\n                    left = middle + 1\n                else:\n                    right = middle\n                    \n            return left\n        \n        for i in range(1, len(A) + 1):\n            index = find_insertion([A[-i], len(A)-i])\n            \n            if index < len(curr_list) and curr_list[index][0] == A[-i]:\n                smaller.append(curr_list[index][1])\n                larger.append(curr_list[index][1])\n                curr_list[index][1] = len(A) - i\n                \n            \n            else:\n                if index > 0:\n                    smaller.append(curr_list[index - 1][1])\n                else:\n                    smaller.append(None)\n                if index < len(curr_list):\n                    larger.append(curr_list[index][1])                \n                else:\n                    larger.append(None)\n\n                curr_list.insert(index, [A[-i], len(A)-i])\n            \n        \n        smaller.reverse()\n        larger.reverse()\n        \n        can_reach_odd = [False]*len(A)\n        can_reach_even = [False]*len(A)\n        \n        can_reach_odd[-1] = True\n        can_reach_even[-1] = True\n        \n        #print(smaller)\n        #print(larger)\n        #print(curr_list)\n        \n        \n        for i in range(2, len(A) + 1):\n            if larger[-i] != None:\n                can_reach_odd[-i] = can_reach_even[larger[-i]]\n            if smaller[-i] != None:\n                can_reach_even[-i] = can_reach_odd[smaller[-i]]\n            \n        solution = 0\n        for i in can_reach_odd:\n            if i:\n                solution += 1\n        \n        return solution\n            \n        \n", "class Solution:\n    def oddEvenJumps(self, A: List[int]) -> int:\n        n = len(A)\n        next_higher, next_lower = [0] * n, [0] * n\n\n        stack = []\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_higher[stack.pop()] = i\n            stack.append(i)\n\n        stack = []\n        for a, i in sorted([-a, i] for i, a in enumerate(A)):\n            while stack and stack[-1] < i:\n                next_lower[stack.pop()] = i\n            stack.append(i)\n\n        higher, lower = [0] * n, [0] * n\n        higher[-1] = lower[-1] = 1\n        for i in range(n - 1)[::-1]:\n            higher[i] = lower[next_higher[i]]\n            lower[i] = higher[next_lower[i]]\n        return sum(higher)\n\n\n                    \n"]