["def main():\n    from sys import stdin, stdout\n    for _ in range(int(stdin.readline())):\n        n = int(stdin.readline())\n        inp1 = [-1] * (n + 1)\n        inp2 = [-1] * (n + 1)\n        for i, ai in enumerate(map(int, stdin.readline().split())):\n            if inp1[ai] < 0:\n                inp1[ai] = i\n            inp2[ai] = i\n        inp1 = tuple((inp1i for inp1i in inp1 if inp1i >= 0))\n        inp2 = tuple((inp2i for inp2i in inp2 if inp2i >= 0))\n        n = len(inp1)\n        ans = 0\n        cur = 0\n        for i in range(n):\n            if i and inp1[i] < inp2[i - 1]:\n                cur = 1\n            else:\n                cur += 1\n                ans = max(ans, cur)\n        stdout.write(f'{n - ans}\\n')\n\n\nmain()\n", "from sys import stdin\ninput = stdin.readline\n\n\ndef main():\n    anses = []\n    for _ in range(int(input())):\n        n = int(input())\n        a = list(map(int, input().split()))\n        f = [0]*(n+1)\n        d = sorted(list(set(a)))\n        for q in range(1, len(d)+1):\n            f[d[q-1]] = q\n        for q in range(len(a)):\n            a[q] = f[a[q]]\n        n = len(d)\n        starts, ends = [-1]*(n+1), [n+1]*(n+1)\n        for q in range(len(a)):\n            if starts[a[q]] == -1:\n                starts[a[q]] = q\n            ends[a[q]] = q\n        s = [0]*(n+1)\n        max1 = -float('inf')\n        for q in range(1, n+1):\n            s[q] = s[q-1]*(ends[q-1] < starts[q])+1\n            max1 = max(max1, s[q])\n        anses.append(str(len(d)-max1))\n    print('\\n'.join(anses))\n\n\nmain()\n", "#                                               |\n#   _` |  __ \\    _` |   __|   _ \\   __ \\    _` |   _` |\n#  (   |  |   |  (   |  (     (   |  |   |  (   |  (   |\n# \\__,_| _|  _| \\__,_| \\___| \\___/  _|  _| \\__,_| \\__,_|\n\nimport sys\nimport math\n\ndef read_line():\n\treturn sys.stdin.readline()[:-1]\n \ndef read_int():\n\treturn int(sys.stdin.readline())\n\t\ndef read_int_line():\n\treturn [int(v) for v in sys.stdin.readline().split()]\n\ndef read_float_line():\n\treturn [float(v) for v in sys.stdin.readline().split()]\n\nt = read_int()\nfor i in range(t):\n\tn = read_int()\n\ta = read_int_line()\n\td = {}\n\tfor i in range(n):\n\t\tif a[i] in d:\n\t\t\td[a[i]].append(i)\n\t\telse:\n\t\t\td[a[i]] = [i]\n\n\tdp = [1]*len(list(d.keys()))\n\n\ts = list(d.keys())\n\ts.sort()\n\n\tfor i in range(len(s)-2,-1,-1):\n\t\tif d[s[i]][-1] < d[s[i+1]][0]:\n\t\t\tdp[i] = dp[i+1]+1\n\t\telse:\n\t\t\tdp[i] = 1\n\tans = len(s)-max(dp)\n\tprint(ans)\n\n", "import os\nimport sys\n\n\ndef solve(arr):\n    items = sorted(set(arr))\n    min_max = [(float(\"inf\"), float(\"-inf\"))] * len(items)\n    item_to_idx = {k: idx for idx, k in enumerate(items)}\n    for idx, a in enumerate(arr):\n        m, M = min_max[item_to_idx[a]]\n        min_max[item_to_idx[a]] = (min(idx, m), max(idx, M))\n\n    best = 1\n    current = 1\n    for i in range(1, len(items)):\n        _, prev_M = min_max[i - 1]\n        m, _ = min_max[i]\n        if prev_M <= m:\n            current += 1\n        else:\n            current = 1\n\n        best = max(best, current)\n\n    return len(items) - best\n\n\ndef pp(input):\n    T = int(input())\n    for t in range(T):\n        input()\n        arr = list(map(int, input().strip().split()))\n        print(solve(arr))\n\n\nif \"paalto\" in os.getcwd():\n    from string_source import string_source, codeforces_parse\n\n    pp(\n        string_source(\n            \"\"\"3\n7\n3 1 6 6 3 1 1\n8\n1 1 4 4 4 7 8 8\n7\n4 2 5 2 6 2 7\"\"\"\n        )\n    )\nelse:\n    pp(sys.stdin.readline)\n", "import sys as _sys\n\n\ndef main():\n    q = int(input())\n    for i_q in range(q):\n        n, = _read_ints()\n        a = tuple(_read_ints())\n        result = find_min_sorting_cost(sequence=a)\n        print(result)\n\n\ndef _read_line():\n    result = _sys.stdin.readline()\n    assert result[-1] == \"\\n\"\n    return result[:-1]\n\n\ndef _read_ints():\n    return list(map(int, _read_line().split(\" \")))\n\n\ndef find_min_sorting_cost(sequence):\n    sequence = tuple(sequence)\n    \n    if not sequence:\n        return 0\n    \n    indices_by_values = {x: [] for x in sequence}\n    for i, x in enumerate(sequence):\n        indices_by_values[x].append(i)\n    \n    borders_by_values = {\n        x: (indices[0], indices[-1]) for x, indices in list(indices_by_values.items())\n    }\n    \n    borders_sorted_by_values = [borders for x, borders in sorted(borders_by_values.items())]\n    \n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for prev_border, curr_border in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    \n    return len(set(sequence)) - max_cost_can_keep_n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import copy\ndef DeleteRepetitionsIn(Array):\n    AlreadyRead = {}\n    index = 0\n    ConstantArray = copy.deepcopy(Array)\n    for a in range(len(ConstantArray)):\n        if Array[index] not in AlreadyRead:\n            AlreadyRead[Array[index]] = \"\"\n            index += 1\n            continue\n        Array = Array[0:index] + Array[index + 1:len(Array)]\n\n    return Array\n\ndef DeleteRepetitionsIn2(Array):\n    AlreadyRead = {}\n    for elem in Array:\n        if elem in AlreadyRead:\n            continue\n        AlreadyRead[elem] = \"\"\n    return list(AlreadyRead)\n\nResults = []\nArraysNumber = int(input())\nfor e in range(ArraysNumber):\n    AbsolutelyUselessNumber = int(input())\n    Array = list(map(int, input().split()))\n    if len(Array) == 1:\n        Results.append(0)\n        continue\n\n    #print(Array)\n    TheRightOrder = DeleteRepetitionsIn2(Array)\n    TheRightOrder.sort()\n    TheCurrentOrder = {}\n    for i in range(len(Array)):\n        if Array[i] not in TheCurrentOrder:\n            TheCurrentOrder[Array[i]] = [i, i]\n            continue\n        TheCurrentOrder[Array[i]][1] = i\n\n    #print(TheRightOrder)\n    #print(TheCurrentOrder)\n    #print(Array)\n\n    TheCurrentResult = 1\n    TheMaxResult = 1\n    for i in range(len(TheRightOrder)):\n        #print(\"a =\", TheCurrentResult)\n        #print(\"b =\", TheMaxResult)\n        if i == len(TheRightOrder) - 1:\n            if TheCurrentResult >= TheMaxResult:\n                TheMaxResult = TheCurrentResult\n            continue\n        if TheCurrentOrder[TheRightOrder[i]][1] > TheCurrentOrder[TheRightOrder[i + 1]][0]:\n            if TheCurrentResult >= TheMaxResult:\n                TheMaxResult = TheCurrentResult\n\n            TheCurrentResult = 1\n            continue\n\n        TheCurrentResult += 1\n\n    Results.append(len(TheRightOrder) - TheMaxResult)\n\nfor i in Results:\n    print(i)"]