["from heapq import heapify, heappush, heappop \nclass DinnerPlates:\n        # index * cap ->  access start of stack at index\n        # index * cap + (cap - 1)  -> access last element of stack at index\n        \n    def __init__(self, capacity: int):\n        self.stack = [] # just one array to simulate all the stacks\n        self.cap = capacity \n        self.idx = [] # min-heap to track empty indicies\n        \n    def push(self, val: int) -> None:\n        if len(self.idx) > 0:\n            while len(self.idx) > 0:\n                i = heappop(self.idx) \n                # Given that we just push index but don't validate the cache while\n                # poping we need to check if this index is within current limits\n                if i < len(self.stack):\n                    self.stack[i] = val\n                    return \n                \n        # we didn't find empty spaces so we add to the end\n        self.stack.append(val)\n\n    def pop(self) -> int:\n        n = len(self.stack) - 1\n        if n < 0:\n            return -1\n        \n        while n > -1:\n            if self.stack[n] != -1:\n                v = self.stack[n]\n                self.stack[n] = -1\n                # Add the empty index to the heap\n                heappush(self.idx , n)\n                return v\n            else:\n                # Because those appear at the end the list we free those memory spaces so\n                # later pop operations are optimized\n                del(self.stack[n])\n            n -= 1\n            \n        # All stacks are empty\n        return -1\n        \n        \n\n    def popAtStack(self, index: int) -> int:\n        # additional check that is [optional] just to skip any effort \n        # if index is already out of current limits\n        count = len(self.stack) // self.cap\n        if index > count:\n            return -1\n        \n        # capture the boundaries of this stack\n        leftptr = (index * self.cap) \n        rightptr = leftptr + self.cap - 1\n        if rightptr > (len(self.stack) - 1): # edge case\n            rightptr = (len(self.stack) - 1)\n            \n        # traverse within the stack at this index until we empty it or we find an occupied location    \n        while self.stack[rightptr] == -1 and rightptr >= leftptr:\n            rightptr -=1\n            \n        # if it isn't empty it means we found occupied position\n        if rightptr >= leftptr:\n            v = self.stack[rightptr]\n            self.stack[rightptr] = -1\n            # Add the empty index to the heap\n            heappush(self.idx , rightptr)\n            return v\n        else:\n            return -1\n", "from heapq import heapify, heappush, heappop \nclass DinnerPlates:\n        # index * cap ->  access start of stack at index\n        # index * cap + (cap - 1)  -> access last element of stack at index\n        \n    def __init__(self, capacity: int):\n        self.stack = [] # just one array to simulate all the stacks\n        self.cap = capacity \n        self.idx = [] # min-heap to track empty indicies\n        \n    def push(self, val: int) -> None:\n        if len(self.idx) > 0:\n            while len(self.idx) > 0:\n                i = heappop(self.idx) \n                # Given that we just push index but don't validate the cache while\n                # poping we need to check if this index is within current limits\n                if i < len(self.stack):\n                    self.stack[i] = val\n                    return \n                \n        # we didn't find empty spaces so we add to the end\n        self.stack.append(val)\n\n    def pop(self) -> int:\n        n = len(self.stack) - 1\n        if n < 0:\n            return -1\n        \n        while n > -1:\n            if self.stack[n] != -1:\n                v = self.stack[n]\n                self.stack[n] = -1\n                # Add the empty index to the heap\n                heappush(self.idx , n)\n                return v\n            else:\n                # Because those appear at the end the list we free those memory spaces so\n                # later pop operations are optimized\n                del(self.stack[n])\n            n -= 1\n            \n        # All stacks are empty\n        return -1\n        \n        \n\n    def popAtStack(self, index: int) -> int:\n        # additional check that is [optional] just to skip any effort \n        # if index is already out of current limits\n        count = len(self.stack) // self.cap\n        if index > count:\n            return -1\n        \n        # capture the boundaries of this stack\n        leftptr = (index * self.cap) \n        rightptr = leftptr + self.cap - 1\n        if rightptr > (len(self.stack) - 1): # edge case\n            rightptr = (len(self.stack) - 1)\n            \n        # traverse within the stack at this index until we empty it or we find an occupied location    \n        while self.stack[rightptr] == -1 and rightptr >= leftptr:\n            rightptr -=1\n            \n        # if it isn't empty it means we found occupied position\n        if rightptr >= leftptr:\n            v = self.stack[rightptr]\n            self.stack[rightptr] = -1\n            # Add the empty index to the heap\n            heappush(self.idx , rightptr)\n            return v\n        else:\n            return -1", "from heapq import heappush, heappop\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.indicies = []\n        self.stacks = []\n        self.cap = capacity\n    \n    def clean_stack(self):\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n            \n    def push(self, val: int) -> None:\n        while self.indicies:\n            index = heappop(self.indicies)\n            \n            if index < len(self.stacks) and len(self.stacks[index]) < self.cap:\n                self.stacks[index].append(val)\n                return\n        \n        if self.stacks and len(self.stacks[-1]) < self.cap:\n            self.stacks[-1].append(val)\n        else:\n            self.stacks.append([val])\n        \n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        else:\n            res = self.stacks[-1].pop()\n        \n        if not self.stacks[-1]:\n            self.clean_stack()\n        else:\n            heappush(self.indicies, len(self.stacks) - 1)\n        \n        return res\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stacks) or not self.stacks[index]:\n            return -1\n        \n        res = self.stacks[index].pop()\n        \n        if not self.stacks[-1]:\n            self.clean_stack()\n        else:\n            heappush(self.indicies, index)\n        \n        return res\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import collections\nimport heapq\n\nStackAndFlags = collections.namedtuple('StackAndFlags', [\n    'stack', 'on_push_heap', 'on_pop_heap'])\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self._cap = capacity\n        self._stacks = []\n        self._next_push_heap = []\n        self._next_pop_heap = []\n        \n    def _push_to_top(self, val):\n        i = self._next_push_heap[0]\n        assert self._stacks[i].on_push_heap\n        self._stacks[i].stack.append(val)\n        if len(self._stacks[i].stack) == self._cap:\n            self._stacks[i] = self._stacks[i]._replace(on_push_heap=False)\n            heapq.heappop(self._next_push_heap)\n        if not self._stacks[i].on_pop_heap:\n            self._stacks[i] = self._stacks[i]._replace(on_pop_heap=True)\n            heapq.heappush(self._next_pop_heap, -i)\n\n    def push(self, val: int) -> None:\n        if not self._next_push_heap:\n            self._stacks.append(StackAndFlags([], True, True))\n            new_i = len(self._stacks) - 1\n            heapq.heappush(self._next_push_heap, new_i)\n            heapq.heappush(self._next_pop_heap, -new_i)\n        self._push_to_top(val)\n\n    def pop(self) -> int:\n        i = -1\n        while self._next_pop_heap:\n            j = -self._next_pop_heap[0]\n            if self._stacks[j].stack:\n                i = j\n                break\n            else:\n                heapq.heappop(self._next_pop_heap)\n                self._stacks[j] = self._stacks[j]._replace(on_pop_heap=False)\n        if i < 0:\n            return -1\n        return self.popAtStack(i)\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self._stacks) or not self._stacks[index].stack:\n            return -1\n        ret = self._stacks[index].stack.pop()\n        if not self._stacks[index].on_push_heap:\n            self._stacks[index] = self._stacks[index]._replace(on_push_heap=True)\n            heapq.heappush(self._next_push_heap, index)\n        return ret\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "from collections import deque\nimport heapq\n\nclass DinnerPlates:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacklist = []\n        self.minh = []\n\n    def push(self, val: int) -> None:\n        while len(self.minh) > 0:\n            lms = heapq.heappop(self.minh)\n            if len(self.stacklist) - 1 >= lms:\n                self.stacklist[lms].append(val)\n                break\n        else:\n            if len(self.stacklist) == 0 or len(self.stacklist[-1]) >= self.capacity:\n                self.stacklist.append(deque())\n            self.stacklist[-1].append(val)\n\n    def pop(self) -> int:\n        if len(self.stacklist) == 0:\n            return -1\n\n        while len(self.stacklist[-1]) == 0:\n            del self.stacklist[-1]\n\n        if len(self.stacklist) > 0:\n            res = self.stacklist[-1].pop()\n        else:\n            res = -1\n\n        if len(self.stacklist[-1]) == 0:\n            del self.stacklist[-1]\n\n        return res\n\n    def popAtStack(self, index: int) -> int:\n        if len(self.stacklist) - 1 < index or len(self.stacklist[index]) == 0:\n            return -1\n        else:\n            res = self.stacklist[index].pop()\n            heapq.heappush(self.minh, index)\n            return res\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = [[]]\n        self.current = 0\n        self.capacity = capacity\n        self.tail = 0\n        \n    def push(self, val: int) -> None:\n        while self.current < len(self.stacks) and len(self.stacks[self.current])==self.capacity:\n            self.current += 1\n        if self.current == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.current].append(val)\n\n    def pop(self) -> int:\n        rightmost = len(self.stacks) - 1\n        \n        while rightmost>=0 and not self.stacks[rightmost]:\n            rightmost -= 1\n        if rightmost == -1:\n            return -1\n        elem = self.stacks[rightmost][-1]\n        self.stacks[rightmost].pop()\n        while rightmost>=0 and not self.stacks[rightmost]:\n            self.stacks.pop()\n            rightmost -= 1\n        return elem\n        \n    def popAtStack(self, index: int) -> int:\n        if index >=len(self.stacks) or not self.stacks[index]:\n            return -1\n        elem = self.stacks[index][-1]\n        self.stacks[index].pop()\n        if self.current > index:\n            self.current = index\n        return elem\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.heap=[]\n        self.plates=[]\n        self.capacity=capacity\n        self.current=None\n    def push(self, val: int) -> None:\n        # print(\\\"push\\\",val, self.plates)\n        if len(self.heap)==0:\n            if len(self.plates)==0 or len(self.plates[-1])==self.capacity:\n                self.plates.append([])\n            self.plates[-1].append(val)\n            self.current=len(self.plates)-1\n\n        else:\n            p=heapq.heappop(self.heap)\n            self.plates[p].append(val)\n\n    def pop(self) -> int:\n        # print(\\\"pop\\\", self.plates)\n\n        for i in range(self.current,-1,-1):\n            if len(self.plates[i])!=0:\n                self.current=i\n                return self.plates[i].pop()\n            self.current=0\n        return -1\n        # if len(self.plates)==0:\n        #     return -1\n        # p=self.plates[-1][-1]\n        # self.plates[-1].pop()\n        # # if len(self.plates[-1])==0:\n        # #     self.plates.pop()\n        # return p\n    def popAtStack(self, index: int) -> int:\n    \n        # print(\\\"popAtStack\\\",index, self.plates)\n        if len(self.plates)-1<index or len(self.plates[index])==0:\n            return -1\n        # 3 3\n        p=self.plates[index].pop()\n        heappush(self.heap, index)\n        return p\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n\n\n# 1 2\n# 3 3\n# 5 5\n# 5  \n# 6 7\n\n\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.availIndexes = []\n        self.capacity = capacity\n      \n\n    def push(self, val: int) -> None:\n        # find the first available one \n        while self.availIndexes and self.availIndexes[0]<len(self.stacks) and len(self.stacks[self.availIndexes[0]])==self.capacity:\n            heappop(self.availIndexes)\n        if not self.availIndexes:\n            heappush(self.availIndexes,len(self.stacks))\n        if self.availIndexes[0]==len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.availIndexes[0]].append(val)\n\n      \n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n            self.availIndexes.remove(len(self.stacks))\n        return self.popAtStack(len(self.stacks)-1)\n    \n\n    def popAtStack(self, index: int) -> int:\n        if 0<=index<len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.availIndexes,index)\n            return self.stacks[index].pop()\n        return -1\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "from collections import deque\nimport heapq\nclass DinnerPlates :\n    \n    def __init__(self,capacity) :\n        self.capacity = capacity\n        self.plates = deque([deque([],maxlen=capacity)])\n        self.popHeap = []\n        self.pushHeap = [0]\n\n    def push(self, val : int) -> None :\n        while self.pushHeap and (self.pushHeap[0] >= len(self.plates) or len(self.plates[self.pushHeap[0]]) == self.capacity ): \n            heapq.heappop(self.pushHeap)\n        if not self.pushHeap :\n            self.plates.append(deque(maxlen=self.capacity)) \n            self.pushHeap = [len(self.plates)-1]\n        i = self.pushHeap[0]\n        self.plates[i].append(val)\n        heapq.heappush(self.popHeap,-i)\n        return\n\n    def pop(self) -> int :\n        while self.popHeap and (-self.popHeap[0] >= len(self.plates) or len(self.plates[-self.popHeap[0]]) == 0 ):\n            heapq.heappop(self.popHeap)\n        if not self.popHeap : return -1 \n        i = -self.popHeap[0]\n        return self.plates[i].pop()\n        \n    def popAtStack(self, index : int) -> int :\n        if index >= len(self.plates) or not self.plates[index] : return -1\n        val = self.plates[index].pop()\n        if self.plates[index] :\n            heapq.heappush(self.popHeap,-index)\n        heapq.heappush(self.pushHeap,index)\n        return val\n\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stack = []\n        self.leftmost = [0]\n        self.rightmost = []\n        self.capacity = capacity\n        self.leftmostset = set([0])\n        self.rightmostset = set()\n        \n\n    def push(self, val: int) -> None:\n        # print(\\\"leftmost:\\\", self.leftmost)\n        idx = self.leftmost[0]\n        if idx >= len(self.stack):\n            self.stack.append([val])\n        else:\n            self.stack[idx].append(val)\n        if len(self.stack[idx]) == self.capacity:\n            heapq.heappop(self.leftmost)\n            self.leftmostset.remove(idx)\n        if len(self.leftmost) == 0:\n            heapq.heappush(self.leftmost, idx + 1)\n            self.leftmostset.add(idx + 1)\n        if idx * (-1) not in self.rightmostset:\n            heapq.heappush(self.rightmost, idx * (-1))\n            self.rightmostset.add(idx * (-1))\n        # print(self.stack)\n\n    def pop(self) -> int:\n        # print(\\\"rightmost:\\\", self.rightmost)\n        if len(self.rightmost) == 0:\n            return -1\n        idx = self.rightmost[0] * (-1)\n        val = self.stack[idx].pop()\n        if len(self.stack[idx]) == 0:\n            heapq.heappop(self.rightmost)\n            self.rightmostset.remove(idx * (-1))\n        if idx not in self.leftmostset:\n            heapq.heappush(self.leftmost, idx)\n            self.leftmostset.add(idx)\n        # print(self.stack)\n        return val\n        \n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stack) or len(self.stack[index]) == 0:\n            return -1\n        val = self.stack[index].pop()\n        if len(self.stack[index]) == 0:\n            self.rightmostset.remove(index * (-1))\n            self.rightmost.remove(index * (-1))\n        if index not in self.leftmostset:\n            heapq.heappush(self.leftmost, index)\n            self.leftmostset.add(index)\n        # print(self.stack)\n        return val\n        \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.availIndexes = []\n        self.capacity = capacity\n      \n\n    def push(self, val: int) -> None:\n        # find the first available one \n        while self.availIndexes and self.availIndexes[0]<len(self.stacks) and len(self.stacks[self.availIndexes[0]])==self.capacity:\n            heappop(self.availIndexes)\n        if not self.availIndexes:\n            heappush(self.availIndexes,len(self.stacks))\n        if self.availIndexes[0]==len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.availIndexes[0]].append(val)\n\n      \n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n            # self.availIndexes.remove(len(self.stacks))\n        return self.popAtStack(len(self.stacks)-1)\n    \n\n    def popAtStack(self, index: int) -> int:\n        if 0<=index<len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.availIndexes,index)\n            return self.stacks[index].pop()\n        return -1\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stack = []\n        self.available_to_push = []   # min heap to store the idx of available-to-push stack\n\n    def push(self, val: int) -> None:       # O(logn)\n        # step 1: pop out all the left stacks that are not avaliable to push, \n        # so that after the while loop, we will know the leftmost stack that is available to push\n        while len(self.available_to_push) > 0 and self.available_to_push[0] < len(self.stack) and len(self.stack[self.available_to_push[0]]) == self.capacity:\n            heappop(self.available_to_push)\n            \n        # if the q is empty, meaning there are no more available stacks\n        if len(self.available_to_push) == 0:        \n            heappush(self.available_to_push, len(self.stack))\n        if self.available_to_push[0] == len(self.stack):\n            self.stack.append([])\n            \n        # finally, we can push our val into the leftmost available stack\n        self.stack[self.available_to_push[0]].append(val)\n\n    def pop(self) -> int:       # O(1)\n        # step 1: pop out all the empty stacks on the right, cuz they are not available to pop\n        while len(self.stack) > 0 and len(self.stack[-1]) == 0:\n            self.stack.pop()\n            \n        return self.popAtStack(len(self.stack) - 1)\n\n    def popAtStack(self, index: int) -> int:        # O(logn)\n        # check if it is available to pop\n        if 0 <= index < len(self.stack) and len(self.stack[index]) > 0:\n            heappush(self.available_to_push, index)     # add this index to the available-to-push heap\n            return self.stack[index].pop()\n        return -1\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.capacity = capacity\n        self.toPush = []\n\n    def push(self, val: int) -> None:\n        if not self.stacks:\n            self.stacks.append([val])\n        else:\n            if self.toPush and self.toPush[0] < len(self.stacks):\n                i = heapq.heappop(self.toPush)\n                self.stacks[i].append(val)\n            else:\n                self.stacks[-1].append(val)\n                \n        if len(self.stacks[-1]) == self.capacity:\n            self.stacks.append([])\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop() \n            # self.toPush = min(self.toPush, len(self.stacks)-1)\n        \n        if not self.stacks:\n            return -1\n        \n        return self.stacks[-1].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.toPush, index)\n            return self.stacks[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.rightheap=[]\n        self.leftheap=[]\n        heapq.heappush(self.leftheap,0)\n        self.hashmap=defaultdict(list)\n        self.capacity=capacity\n        self.ind=0\n\n    def push(self, val: int) -> None:\n        slot=self.leftheap[0]\n        if len(self.hashmap[slot])==0:\n            heapq.heappush(self.rightheap,-slot)\n        self.hashmap[slot].append(val)\n        if len(self.hashmap[slot])==self.capacity:\n            heapq.heappop(self.leftheap)\n            \n        if len(self.leftheap)==0:\n            self.ind+=1\n            heapq.heappush(self.leftheap,self.ind)\n            \n       \n\n    def pop(self) -> int:\n        if not self.rightheap:\n            return -1\n        while(len(self.hashmap[-self.rightheap[0]])==0):\n              heapq.heappop(self.rightheap)\n        slot=-heapq.heappop(self.rightheap)\n        value=self.hashmap[slot].pop()\n        if len(self.hashmap[slot])!=0:\n            heapq.heappush(self.rightheap,-slot)\n        else:\n            self.ind=slot-1\n        heapq.heappush(self.leftheap,slot)\n        \n        return value\n        \n\n    def popAtStack(self, index: int) -> int:\n        if not self.hashmap[index]:\n            return -1\n        else:\n            value=self.hashmap[index].pop()\n            if len(self.hashmap[index])+1==self.capacity:\n                heapq.heappush(self.leftheap,index)\n            return value     \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.capacity = capacity\n        self.toPush = []\n\n    def push(self, val: int) -> None:\n        if not self.stacks:\n            self.stacks.append([val])\n        else:\n            if self.toPush and self.toPush[0] < len(self.stacks):\n                i = heapq.heappop(self.toPush)\n                self.stacks[i].append(val)\n            else:\n                self.stacks[-1].append(val)\n                \n        if len(self.stacks[-1]) == self.capacity:\n            self.stacks.append([])\n\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop() \n            # self.toPush = min(self.toPush, len(self.stacks)-1)\n        \n        if not self.stacks:\n            return -1\n        \n        return self.stacks[-1].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.toPush, index)\n            return self.stacks[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.leftmost = []\n        self.K = capacity\n\n    def push(self, val: int) -> None:\n        if len(self.leftmost) == 0:\n            if self.K != 1:\n                self.leftmost.append(len(self.stacks))\n            self.stacks.append([val])\n        else:\n            ind = self.leftmost[0]\n            if ind >= len(self.stacks):\n                self.stacks.append([])\n            self.stacks[ind].append(val)\n            if len(self.stacks[ind]) == self.K:\n                heapq.heappop(self.leftmost)\n            \n    def pop(self) -> int:\n        if len(self.stacks) == 0:\n            return -1\n            \n        while len(self.stacks[-1]) == 0:\n            self.stacks.pop()\n            if len(self.stacks) == 0:\n                return -1\n            \n        if len(self.stacks[-1]) == self.K:\n            heapq.heappush(self.leftmost,len(self.stacks)-1)\n            \n        return self.stacks[-1].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stacks):\n            return -1\n        else:\n            stack = self.stacks[index]\n            if len(stack) == 0:\n                return -1\n            \n            if len(stack) == self.K:\n                heapq.heappush(self.leftmost,index)\n            \n            return stack.pop()\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = list()\n        self.RMNE = -1\n        self.LMNF = -1\n\n    def push(self, val: int) -> None:\n        if(self.LMNF <0 or self.LMNF >= len(self.stacks)):\n            self.stacks.append([val])\n            self.RMNE = len(self.stacks)\n            if(self.capacity > 1):\n                self.LMNF = len(self.stacks)-1\n            #if(self.LMNF < 0):self.LMNF = len(self.stacks)\n        else:\n            if(len(self.stacks[self.LMNF]) == self.capacity):\n                self.LMNF += 1\n                self.push(val)\n                return\n            self.stacks[self.LMNF].append(val)\n            if(self.RMNE < self.LMNF):\n                self.RMNE = self.LMNF        \n                \n            if(len(self.stacks[self.LMNF]) == self.capacity):\n                self.LMNF += 1\n                \n                \n    def pop(self) -> int:\n        \n        if(self.RMNE >= len(self.stacks)):\n            self.RMNE = len(self.stacks) - 1\n        while(self.RMNE>=0 and not self.stacks[self.RMNE]):\n            self.RMNE -= 1\n            self.stacks.pop()      \n        if(self.RMNE <0):\n            return -1\n        val = self.stacks[self.RMNE].pop()\n        if(self.LMNF > self.RMNE):\n            self.LMNF = self.RMNE\n        return val        \n\n    def popAtStack(self, index: int) -> int:\n        if(index >= len(self.stacks)):\n            return -1;\n        if(len(self.stacks[index])==0):\n            return -1;\n        val = self.stacks[index].pop()\n        if(self.LMNF > index or self.LMNF<0):\n            self.LMNF = index        \n        return val\n        \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = list()\n        self.RMNE = -1\n        self.LMNF = -1\n\n    def push(self, val: int) -> None:\n        if(self.LMNF <0 or self.LMNF >= len(self.stacks)):\n            self.stacks.append([val])\n            self.RMNE = len(self.stacks)\n            if(self.capacity > 1):\n                self.LMNF = len(self.stacks)-1\n        else:\n            if(len(self.stacks[self.LMNF]) == self.capacity):\n                self.LMNF += 1\n                self.push(val)\n                return\n            self.stacks[self.LMNF].append(val)\n            if(self.RMNE < self.LMNF):\n                self.RMNE = self.LMNF        \n                \n            if(len(self.stacks[self.LMNF]) == self.capacity):\n                self.LMNF += 1\n                \n                \n    def pop(self) -> int:\n        \n        if(self.RMNE >= len(self.stacks)):\n            self.RMNE = len(self.stacks) - 1\n        while(self.RMNE>=0 and not self.stacks[self.RMNE]):\n            self.RMNE -= 1\n            self.stacks.pop()      \n        if(self.RMNE <0):\n            return -1\n        val = self.stacks[self.RMNE].pop()\n        if(self.LMNF > self.RMNE):\n            self.LMNF = self.RMNE\n        return val        \n\n    def popAtStack(self, index: int) -> int:\n        if(index >= len(self.stacks)):\n            return -1;\n        if(len(self.stacks[index])==0):\n            return -1;\n        val = self.stacks[index].pop()\n        if(self.LMNF > index or self.LMNF<0):\n            self.LMNF = index        \n        return val\n        \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity):\n        \n        self.stacks=[]\n        self.stack=[]\n        self.size=capacity\n        self.left=0\n        self.right=0\n\n    def push(self, val):\n       \n        #when stack is initially empty\n        if not self.stacks:            \n            self.stack.append(val)\n            self.stacks.append(self.stack)\n            self.left=0\n                           \n        else:   \n            #find the leftmost stack with size less than capacity to append item\n            while self.left<len(self.stacks) and len(self.stacks[self.left])==self.size:\n                self.left+=1\n            if self.left==len(self.stacks):\n                self.stacks.append([])\n                self.stacks[self.left].append(val)\n            else:\n                self.stacks[self.left].append(val)                \n                        \n            self.right=len(self.stacks)-1\n\n    def pop(self):\n      \n        if not self.stacks:\n            return -1\n        \n        #find the rightmost non empty stack\n        if not self.stacks[self.right]:\n            while not self.stacks[self.right] and len(self.stacks)-1>=self.right:                \n                self.stacks.pop(self.right)\n                self.right-=1\n                \n        item=self.stacks[self.right].pop() \n        \n        #if stack gets empty after pop item, move the pointer for rightmost non empty stack\n        if not self.stacks[self.right]:\n            self.stacks.pop(self.right)\n            self.right-=1           \n         \n        return item                        \n        \n    def popAtStack(self, index):\n       \n        if len(self.stacks)-1<index:\n            return -1\n        if not self.stacks[index]:\n            return -1\n        \n        #before popping item from stack at index, update the pointer for leftmost stack with capacity\n        if self.stacks[index]:\n            if self.left>index:\n                self.left=index\n        return self.stacks[index].pop()", "class DinnerPlates:\n    #Use heap to store index of available stack\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.stacks = []\n        self.heap = []\n\n    def push(self, val: int) -> None:\n        if not self.heap:\n            self.stacks.append([val])\n            if len(self.stacks[-1]) < self.cap:\n                heapq.heappush(self.heap, len(self.stacks)-1)\n        else:\n            i = heapq.heappop(self.heap)\n            while self.heap and i < len(self.stacks) and len(self.stacks[i]) >= self.cap: \n                i = heapq.heappop(self.heap)\n            if i >= len(self.stacks):\n                self.stacks.append([val])\n            \n            else:\n                self.stacks[i].append(val)\n            if len(self.stacks[i]) < self.cap:\n                heapq.heappush(self.heap, i)\n            \n\n    def pop(self) -> int:\n        return self.popAtStack(len(self.stacks)-1)\n\n    def popAtStack(self, index: int) -> int:\n        if self.stacks == []: return -1\n        if index < len(self.stacks) and self.stacks[index] == []: return -1\n        \n        if index < len(self.stacks) and self.stacks[index] != []: \n            item = self.stacks[index].pop()\n            if self.stacks[index] == [] and index == len(self.stacks) - 1:\n                while self.stacks and self.stacks[-1] == []:\n                    self.stacks.pop()\n            else:\n                heapq.heappush(self.heap, index)\n                \n            return item\n        return -1\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.slots = []\n        self.capacity = capacity\n        self.plates = []\n        self.end = -1\n        \n\n    def push(self, val: int) -> None:\n        if len(self.slots) == 0:\n            self.plates.append([])\n            self.plates[-1].append(val)\n            self.slots += [len(self.plates) - 1] * (self.capacity - 1)\n        else:\n            self.plates[heappop(self.slots)].append(val)\n            \n        self.end = max(self.end, len(self.plates) - 1)\n        \n\n    def pop(self) -> int:\n        if self.end < 0:\n            return -1\n        \n        return self.popAtStack(self.end)\n        \n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.plates) or len(self.plates[index]) == 0:\n            return -1\n        \n        ret = self.plates[index].pop()\n        heappush(self.slots, index)\n        \n        while self.end >= 0 and len(self.plates[self.end]) == 0:\n            self.end -= 1\n            \n        return ret\n        \n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "from collections import deque as dq\nimport bisect as bs\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.nFull = []\n        self.cur = []\n\n    def push(self, val: int) -> None:\n        # print(\\\"push\\\", val, self.cur, self.nFull)\n        if self.nFull:\n            self.cur[self.nFull[0]].append(val)\n            if len(self.cur[self.nFull[0]]) == self.cap:\n                self.nFull.pop(0)\n        else:\n            self.cur.append([val])\n            if len(self.cur[-1]) < self.cap:\n                self.nFull.append(len(self.cur)-1)\n\n    def pop(self) -> int:\n        # print(\\\"pop\\\", self.cur, self.nFull)\n        if not self.cur:\n            return -1\n        tmp = self.cur[-1].pop()\n        if len(self.cur[-1]) == self.cap - 1:\n            if self.cur[-1]:\n                self.nFull.append(len(self.cur) - 1)\n            else:\n                self.cur.pop()\n        while self.cur and not self.cur[-1]:\n            self.cur.pop()\n            self.nFull.pop()\n        return tmp\n        \n\n    def popAtStack(self, index: int) -> int:   \n        # print(\\\"popAt\\\", index, self.cur, self.nFull)\n        if index >= len(self.cur):\n            return -1\n        if self.cur[index]:\n            tmp = self.cur[index].pop()\n            if len(self.cur[index]) == self.cap - 1:\n                if self.cur[index]:\n                    bs.insort(self.nFull, index)\n                else:\n                    if index == len(self.cur) - 1:\n                        self.cur.pop()\n                        while self.cur and not self.cur[-1]:\n                            self.cur.pop()\n                            self.nFull.pop()\n                    else:\n                        bs.insort(self.nFull, index)\n            return tmp\n        else:\n            return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates(object):\n\n    def __init__(self, capacity):\n        \\\"\\\"\\\"\n        :type capacity: int\n        \\\"\\\"\\\"\n        self.stacks = []\n        self.cap = capacity\n        self.not_full = [] #to push min heap\n        self.not_empty = [] #to pop\n\n    def push(self, val):\n        \\\"\\\"\\\"\n        :type val: int\n        :rtype: None\n        \\\"\\\"\\\"\n        #print(\\\"push\\\")\n        if self.not_full:\n            index = self.not_full[0]\n            self.stacks[index].append(val)\n            if len(self.stacks[index]) == self.cap:\n                heapq.heappop(self.not_full)\n                \n        else:\n            index = len(self.stacks)\n            if self.cap > 1: #here\n                heapq.heappush(self.not_full, index)\n            heapq.heappush(self.not_empty, -index)\n            self.stacks += [[val]]\n            \n    def pop(self):\n        \\\"\\\"\\\"\n        :rtype: int\n        \\\"\\\"\\\"\n\n        #print(\\\"pop\\\")\n        while self.not_empty and not self.stacks[-self.not_empty[0]]:\n            heapq.heappop(self.not_empty)\n            self.stacks.pop() #here\n            \n        if self.not_empty:\n            index = -self.not_empty[0]\n            val = self.stacks[index].pop()\n            if not self.stacks[index]:\n                heapq.heappop(self.not_empty)\n                self.stacks.pop()\n                \n            return val\n        \n        return -1\n        \n        \n        \n\n    def popAtStack(self, index):\n        \\\"\\\"\\\"\n        :type index: int\n        :rtype: int\n        \\\"\\\"\\\"\n        #print(\\\"popAt\\\")\n        if index >= 0 and index < len(self.stacks) and self.stacks[index]:\n            if len(self.stacks[index]) == self.cap and index != len(self.stacks) - 1:\n                heapq.heappush(self.not_full, index)  \n            return self.stacks[index].pop()\n        \n        return -1", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = list()\n        self.RMNE = -1\n        self.LMNF = -1\n\n    def push(self, val: int) -> None:\n        if(self.LMNF <0 or self.LMNF >= len(self.stacks)):\n            self.stacks.append([val])\n            self.RMNE = len(self.stacks)\n            if(self.capacity > 1):\n                self.LMNF = len(self.stacks)-1\n            if(self.LMNF < 0):\n                self.LMNF = len(self.stacks)\n        else:\n            if(len(self.stacks[self.LMNF]) == self.capacity):\n                self.LMNF += 1\n                self.push(val)\n                return\n            self.stacks[self.LMNF].append(val)\n            if(self.RMNE < self.LMNF):\n                self.RMNE = self.LMNF        \n                \n            if(len(self.stacks[self.LMNF]) == self.capacity):\n                self.LMNF += 1\n                \n                \n    def pop(self) -> int:\n        \n        if(self.RMNE >= len(self.stacks)):\n            self.RMNE = len(self.stacks) - 1\n        while(self.RMNE>=0 and not self.stacks[self.RMNE]):\n            self.RMNE -= 1\n            self.stacks.pop()      \n        if(self.RMNE <0):\n            return -1\n        val = self.stacks[self.RMNE].pop()\n        if(self.LMNF > self.RMNE):\n            self.LMNF = self.RMNE\n        return val        \n\n    def popAtStack(self, index: int) -> int:\n        if(index >= len(self.stacks)):\n            return -1;\n        if(len(self.stacks[index])==0):\n            return -1;\n        val = self.stacks[index].pop()\n        if(self.LMNF > index or self.LMNF<0):\n            self.LMNF = index        \n        return val\n        \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity, self.stacks = capacity, [[]]\n        self.left = 0\n        self.right = 0\n\n    def push(self, val: int) -> None:\n        while self.left < len(self.stacks) and len(self.stacks[self.left]) == self.capacity:\n            self.left += 1\n        if self.left == len(self.stacks):\n            self.stacks.append([val])\n        else:\n            self.stacks[self.left].append(val)\n        \n        if self.left >= self.right:\n            self.right = self.left\n    def pop(self) -> int:\n        while self.right > 0  and len(self.stacks[self.right]) == 0:\n            self.stacks.pop()\n            self.right -= 1\n        if self.right < self.left:\n            self.left = self.right\n        \n        if len(self.stacks[self.right]) == 0:\n            return -1\n        \n        \n        return self.stacks[self.right].pop()\n    \n\n    def popAtStack(self, index: int) -> int:\n        if index > len(self.stacks) or not self.stacks[index]:\n            return -1\n        if index < self.left:\n            self.left = index\n        return self.stacks[index].pop()\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "from collections import deque\nimport heapq\n\nclass DinnerPlates:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacklist = []\n        self.minh = []\n        # heapq.heapify(self.minh)\n\n    def push(self, val: int) -> None:\n        while len(self.minh) > 0:\n            lms = heapq.heappop(self.minh)\n            if len(self.stacklist) - 1 < lms:\n                continue\n            else:\n                self.stacklist[lms].append(val)\n                break\n        else:\n            if len(self.stacklist) == 0 or len(self.stacklist[-1]) >= self.capacity:\n                self.stacklist.append(deque())\n            self.stacklist[-1].append(val)\n\n    def pop(self) -> int:\n        if len(self.stacklist) == 0:\n            return -1\n\n        while len(self.stacklist[-1]) == 0:\n            del self.stacklist[-1]\n\n        if len(self.stacklist) > 0:\n            res = self.stacklist[-1].pop()\n        else:\n            res = -1\n\n        if len(self.stacklist[-1]) == 0:\n            del self.stacklist[-1]\n\n        return res\n\n    def popAtStack(self, index: int) -> int:\n        if len(self.stacklist) - 1 < index or len(self.stacklist[index]) == 0:\n            return -1\n        else:\n            res = self.stacklist[index].pop()\n            heapq.heappush(self.minh, index)\n            return res\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "\nclass DinnerPlates(object):\n    \n  def __init__(self, capacity):\n    self.capacity, self.stacks = capacity, [[]]\n    self.left, self.right = 0, 0\n\n  def push(self, val):\n    while self.left < len(self.stacks) and len(self.stacks[self.left]) == self.capacity:\n      self.left += 1 # find the leftmost stack with space\n    if self.left == len(self.stacks):\n      self.stacks += [],  # all our stacks are full, add a new one on the right\n    self.stacks[self.left] += val,  \n    if self.left > self.right:\n      self.right = self.left # update right pointer if needed\n\n  def pop(self):\n    while self.right > 0 and not len(self.stacks[self.right]):\n      self.stacks.pop() # clear up any empty stacks on the right\n      self.right -= 1\n    if self.right < self.left:\n      self.left = self.right  # update left pointer if needed\n    return -1 if not len(self.stacks[self.right]) else self.stacks[self.right].pop()\n\n  def popAtStack(self, index):\n    if index > len(self.stacks) or not len(self.stacks[index]):\n      return -1\n    if index < self.left:\n      self.left = index # we have an empty space even more left than before\n    return self.stacks[index].pop()", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.s = []\n        self.q = []\n            \n    def push(self, val: int) -> None:\n        if not self.q or self.q[0] > len(self.s)-1:\n            self.s.append([val])\n            self.q = []\n            if self.c > 1:\n                heapq.heappush(self.q, len(self.s)-1)\n        else:\n            temp = heapq.heappop(self.q)\n            self.s[temp].append(val)\n            if len(self.s[temp]) < self.c:\n                heapq.heappush(self.q, temp)\n        \n    def pop(self) -> int:\n        while self.s and not self.s[-1]:\n            self.s.pop()\n            \n        if not self.s:\n            return -1\n        \n        if len(self.s[-1]) == self.c:\n            heapq.heappush(self.q, len(self.s)-1)\n        return self.s[-1].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index < 0 or index > len(self.s)-1:\n            return -1\n        \n        if len(self.s[index]) == self.c:\n            heapq.heappush(self.q, index)\n            \n        return self.s[index].pop() if self.s[index] else -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\nclass DinnerPlates:\n    def __init__(self, capacity: int):\n        self.cache = []\n        self.capacity = capacity\n        self.available_pos = []\n\n    def push(self, val: int) -> None:\n        if len(self.available_pos) == 0:\n            self.cache.append([])\n            heapq.heappush(self.available_pos, len(self.cache) - 1)\n        min_idx = self.available_pos[0]\n        if min_idx >= len(self.cache):\n            needed = min_idx + 1 - len(self.cache)\n            for _ in range(needed):\n                self.cache.append([])\n        self.cache[min_idx].append(val)\n        if len(self.cache[min_idx]) == self.capacity:\n            heapq.heappop(self.available_pos)\n\n    def pop(self) -> int:\n        while len(self.cache) > 0 and len(self.cache[-1]) == 0:\n            self.cache.pop()\n        if len(self.cache) == 0: return -1\n        \n        val = self.cache[-1].pop()\n        # if len(self.cache[-1]) == 0: \n        #     self.cache.pop()\n        if len(self.cache[-1]) == self.capacity - 1:\n            heapq.heappush(self.available_pos, len(self.cache) - 1)\n        return val\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.cache) or len(self.cache[index]) == 0: return -1\n        val = self.cache[index].pop()\n        if len(self.cache[index]) == self.capacity - 1:\n            heapq.heappush(self.available_pos, index)\n        return val\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.data = [[]]\n        self.cap = capacity\n        self.i = 0\n\n    def push(self, val: int) -> None:\n        self.data[self.i].append(val)\n        while self.i < len(self.data) and len(self.data[self.i]) == self.cap:\n            self.i += 1\n        if self.i == len(self.data):\n            self.data.append([])\n\n    def pop(self) -> int:\n        while self.data and not self.data[-1]:\n            self.data.pop()\n        \n        if self.data:\n            if len(self.data) <= self.i:\n                self.i -= 1\n            return self.data[-1].pop()\n        return -1\n\n    def popAtStack(self, index: int) -> int:\n        if index < len(self.data) and self.data[index]:\n            if index < self.i:\n                self.i = index\n            return self.data[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.capacity = capacity\n        self.toPush = None\n\n    def push(self, val: int) -> None:\n        if not self.stacks:\n            self.stacks.append([val])\n            self.toPush = 0\n\n        else:\n            self.stacks[self.toPush].append(val)\n                \n        if len(self.stacks[-1]) == self.capacity:\n            self.stacks.append([])\n            \n        while len(self.stacks[self.toPush]) == self.capacity:\n            self.toPush += 1\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop() \n            self.toPush = min(self.toPush, len(self.stacks)-1)\n        \n        if not self.stacks:\n            return -1\n        \n        return self.stacks[-1].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index < len(self.stacks) and self.stacks[index]:\n            self.toPush = min(self.toPush, index)\n            return self.stacks[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.q = [] # record the available stack, will use heap to quickly find the smallest available stack\n        # if you are Java or C++ users, tree map is another good option.\n        self.stacks = [] # record values of all stack of plates, its last nonempty stack are the rightmost position\n\n    def push(self, val: int) -> None:\n        # To push, we need to find the leftmost available position\n        # first, let's remove any stacks on the left that are full\n        # 1) self.q: if there is still available stack to insert plate\n        # 2) self.q[0] < len(self.stacks): the leftmost available index self.q[0] is smaller than the current size of the stacks\n        # 3) len(self.stacks[self.q[0]]) == self.c: the stack has reached full capacity\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            # we remove the filled stack from the queue of available stacks\n            heapq.heappop(self.q)\n\n        # now we reach the leftmost available stack to insert\n\n        # if the q is empty, meaning there are no more available stacks\n        if not self.q:\n            # open up a new stack to insert\n            heapq.heappush(self.q, len(self.stacks))\n\n        # for the newly added stack, add a new stack to self.stacks accordingly\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n\n        # append the value to the leftmost available stack\n        self.stacks[self.q[0]].append(val)\n\n    def pop(self) -> int:\n        # To pop, we need to find the rightmost nonempty stack\n        # 1) stacks is not empty (self.stacks) and\n        # 2) the last stack is empty\n        while self.stacks and not self.stacks[-1]:\n            # we throw away the last empty stack, because we can't pop from it\n            self.stacks.pop()\n\n        # now we reach the rightmost nonempty stack\n\n        # we pop the plate from the last nonempty stack of self.stacks by using popAtStack function\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        # To pop from an stack of given index, we need to make sure that it is not empty\n        # 1) the index for inserting is valid and\uff0c\n        # 2) the stack of interest is not empty\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            # we add the index into the available stack\n            heapq.heappush(self.q, index)\n            # take the top plate, pop it and return its value\n            return self.stacks[index].pop()\n\n        # otherwise, return -1 because we can't pop any plate\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "# 1172. Dinner Plate Stacks\n\nfrom heapq import *\n\nclass DinnerPlates:\n    def __repr__ (self):\n        return f'DP ({self.stacks}, {self.nonfull})'\n    \n    def __init__ (self, capacity):\n        self.cap = capacity\n        self.stacks = []\n        self.nonfull = [] # heap\n\n    def push (self, val):\n        # look in self.nonfull first\n        while self.nonfull:\n            first = self.nonfull [0]\n            if first < len (self.stacks) and len (self.stacks[first]) < self.cap:\n                self.stacks[first].append (val)\n                if len (self.stacks[first]) == self.cap:\n                    # no longer nonfull\n                    heappop (self.nonfull)\n                return\n            else:\n                heappop (self.nonfull)\n        # not found yet\n        new_stack = len (self.stacks)\n        self.stacks.append ([val])\n        if len (self.stacks[new_stack]) < self.cap:\n            heappush (self.nonfull, new_stack)\n\n    def pop (self):\n        while self.stacks:\n            if not self.stacks[-1]:\n                self.stacks.pop ()\n            else:\n                ans = self.stacks[-1].pop ()\n                popped_stack = len (self.stacks) - 1\n                if not self.stacks[-1]:\n                    self.stacks.pop ()\n                elif len (self.stacks[-1]) == self.cap - 1:\n                    heappush (self.nonfull, popped_stack)\n                return ans\n        return -1\n\n    def popAtStack (self, index):\n        if index >= len (self.stacks):\n            return -1\n        elif not self.stacks[index]:\n            return -1\n        else:\n            ans = self.stacks[index].pop ()\n            if len (self.stacks[index]) == self.cap - 1:\n                heappush (self.nonfull, index)\n            return ans\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.stack = []\n        self.cap = capacity\n        self.left = 0\n        self.right = 0\n        \n\n    def push(self, val: int) -> None:\n        if not self.stacks:\n            self.stack.append(val)\n            self.stacks.append(self.stack)\n        else:\n            while self.left < len(self.stacks) and len(self.stacks[self.left]) == self.cap:\n                self.left += 1\n            if self.left == len(self.stacks):\n                self.stacks.append([])\n                self.stacks[self.left].append(val)\n                self.right = len(self.stacks) - 1\n            else:\n                self.stacks[self.left].append(val)\n            \n                \n\n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        if not self.stacks[self.right]:\n            while not self.stacks[self.right]:\n                self.stacks.pop()\n                self.right -= 1\n                \n        item = self.stacks[self.right].pop()\n        \n        if not self.stacks[self.right]:\n            self.stacks.pop()\n            self.right -= 1\n        return item\n                \n        \n\n    def popAtStack(self, index: int) -> int:\n        if index > len(self.stacks) - 1:\n            return -1\n        if not self.stacks[index]:\n            return -1\n        if self.stacks[index]:\n            if self.left > index:\n                self.left = index\n            item = self.stacks[index].pop()\n            return item\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = list()\n        self.heapnonfull = list()\n        self.heapnonempty = list()\n        \n\n\n    def push(self, val: int) -> None:\n        if(len(self.heapnonfull)==0):\n            newlist = list()\n            newlist.append(val)\n            self.stacks.append(newlist)\n            index = len(self.stacks) - 1\n            if(self.capacity > 1):\n                heappush(self.heapnonfull, index)\n            heappush(self.heapnonempty, 0-index)\n        else:\n            index = self.heapnonfull[0]\n            self.stacks[index].append(val)\n            if(len(self.stacks[index]) == self.capacity):\n                heappop(self.heapnonfull)\n\n    def pop(self) -> int:\n\n        while(len(self.heapnonempty) > 0 and len(self.stacks[0- self.heapnonempty[0]])==0):\n            heappop(self.heapnonempty)\n            self.stacks.pop()\n\n        if(len(self.heapnonempty)==0):\n            return -1\n        index = 0 - self.heapnonempty[0]\n        val = self.stacks[index].pop()\n        if(len(self.stacks[index])==0):\n            heappop(self.heapnonempty) \n            self.stacks.pop()\n        else:\n            if(len(self.stacks[index]) < self.capacity):                  \n                heappush(self.heapnonfull, index)\n        return val\n\n    def popAtStack(self, index: int) -> int:\n        if(index >= len(self.stacks)):\n            return -1;\n                    \n        curlen = len(self.stacks[index])\n        if(curlen==0):\n            return -1\n                     \n        #if(curlen==1):\n        #    self.heapnonempty.remove(0-index)\n        #    heapify(self.heapnonempty)\n            \n        if(curlen-1 < self.capacity and curlen==self.capacity and index != len(self.stacks) - 1):                     \n            heappush(self.heapnonfull, index)                    \n                    \n        return self.stacks[index].pop()\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stack = [[]]\n        self.cap = capacity\n        self.heap = [0]\n        \n    def push(self, val: int) -> None:\n        while self.heap and self.heap[0]<len(self.stack) and len(self.stack[self.heap[0]])==self.cap:\n            heapq.heappop(self.heap)\n            \n        if not self.heap:\n            heapq.heappush(self.heap, len(self.stack))\n        if self.heap[0]>=len(self.stack):\n            self.stack.append([])\n        self.stack[self.heap[0]].append(val)\n        \n    def pop(self) -> int:\n        while self.stack and not self.stack[-1]:\n            self.stack.pop()\n        if not self.stack:\n            return -1\n        res = self.stack[-1].pop()\n        heapq.heappush(self.heap, len(self.stack)-1)\n        return res\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stack) or not self.stack[index]:\n            return -1\n        heapq.heappush(self.heap, index)\n        return self.stack[index].pop()\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.pq = []\n        self.sta = []\n        \n\n    def push(self, val: int) -> None:\n        def push_at(index, val):\n            if (index < 0 or index >= len(self.sta) or len(self.sta[index]) == self.cap):\n                self.sta.append([val])\n            else:\n                self.sta[index].append(val)\n        \n        insert_idx = heapq.heappop(self.pq) if self.pq else len(self.sta)-1\n        push_at(insert_idx, val)\n\n    def pop(self) -> int:\n        while (self.sta and (not self.sta[-1])):\n            self.sta.pop()\n            \n        return self.popAtStack(len(self.sta)-1)\n\n    def popAtStack(self, index: int) -> int:\n        if (0 <= index < len(self.sta) and self.sta[index]):\n            heapq.heappush(self.pq,index)\n            return self.sta[index].pop()\n        return -1\n\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.stacks = []\n        self.idx = []\n\n    def push(self, val: int) -> None:\n        if self.idx and 0 <= -self.idx[-1] < len(self.stacks):\n            i = -self.idx[-1]\n            st = self.stacks[i]\n            st.append(val)\n            if len(st) == self.cap:\n                self.idx.pop()\n        else:\n            self.idx.clear()\n            self.stacks.append([val])\n            if self.cap > 1:\n                self.idx.append(-len(self.stacks) + 1)                        \n        \n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        st = self.stacks[-1]\n        val = st.pop()\n        if len(st) == self.cap - 1:\n            bisect.insort(self.idx, -len(self.stacks) + 1)\n        self._clean()\n        return val\n\n    def popAtStack(self, index: int) -> int:\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            st = self.stacks[index]\n            val = st.pop()\n            if len(st) == self.cap - 1:\n                bisect.insort(self.idx, -index)\n            self._clean()\n            return val\n        return -1\n    \n    def _clean(self):\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        \n        \n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.q = []\n        self.stacks = []\n\n    def push(self, val: int) -> None:\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            heapq.heappop(self.q)\n        if not self.q:\n            heapq.heappush(self.q,len(self.stacks))\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.q[0]].append(val)\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.q,index)\n            return self.stacks[index].pop()\n        return -1\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.q = []\n        self.stacks = []\n\n    def push(self, val: int) -> None:\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            heapq.heappop(self.q)\n        if not self.q:\n            heapq.heappush(self.q,len(self.stacks))\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.q[0]].append(val)\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.q,index)\n            return self.stacks[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.vacancy = []\n        self.stacks = []\n        self.maxidx = -1\n\n    def push(self, val: int) -> None:\n        if self.vacancy:\n            pos = self.vacancy[0]\n            self.stacks[pos].append(val)\n            if len(self.stacks[pos]) == self.capacity:\n                heapq.heappop(self.vacancy)\n        else:\n            pos = len(self.stacks)\n            self.stacks.append([])\n            self.stacks[pos].append(val)\n            if self.capacity > 1:\n                heapq.heappush(self.vacancy, pos)\n        self.maxidx = max(self.maxidx, pos)\n\n\n    def pop(self) -> int:\n        rangemax = self.maxidx\n        for i in range(rangemax, -1, -1):\n            if self.stacks[i] != []:\n                self.maxidx = i\n                x = self.stacks[i].pop()\n                if len(self.stacks[i]) == self.capacity - 1:\n                    heapq.heappush(self.vacancy, i)\n                return x\n        else:\n            return -1\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stacks) or self.stacks[index] == []:\n            return -1\n        if len(self.stacks[index]) == self.capacity:\n            heapq.heappush(self.vacancy, index)\n            return self.stacks[index].pop()\n        else:\n            return self.stacks[index].pop()\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.q = []\n        self.stacks = []\n\n    def push(self, val: int) -> None:\n        # 1) self.q: is there is available leftmost index\n        # 2) is leftmost index less than current size of stacks\n        # 3) is leftmost index full\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            heappop(self.q)\n        \n        if not self.q:\n            heappush(self.q, len(self.stacks))\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.q[0]].append(val)\n            \n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        if len(self.stacks) == 0:\n            return -1\n        return self.popAtStack(len(self.stacks)-1)\n\n    def popAtStack(self, index: int) -> int:\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            heappush(self.q, index)\n            return self.stacks[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = []\n        self.available = []\n        \n    def push(self, val: int) -> None:\n        if not self.available:\n            self.stacks.append([])\n            self.available.append(len(self.stacks) - 1)\n        slot = self.available[0]\n        self.stacks[slot].append(val)\n        if len(self.stacks[slot]) == self.capacity:\n            heapq.heappop(self.available)\n            self.remove_empty_stacks()\n    \n    def remove_empty_stacks(self):\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        while self.available and self.available[0] >= len(self.stacks):\n            heapq.heappop(self.available)\n        \n    def pop(self) -> int:\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        if index < 0 or index >= len(self.stacks) or not self.stacks[index]:\n            return -1\n        result = self.stacks[index].pop()\n        if len(self.stacks[index]) == self.capacity - 1:\n            heapq.heappush(self.available, index)\n        self.remove_empty_stacks()\n        return result\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.h = [0]\n        self.counter = 0\n        self.stacks = [[]]\n        self.cap = capacity\n        \n\n    def push(self, val: int) -> None:\n        if self.h:\n            i = heapq.heappop(self.h)\n            if i >=len(self.stacks):\n                self.push(val)\n            else:\n                self.stacks[i].append(val)\n            if len(self.stacks[i]) <self.cap:\n                heapq.heappush(self.h, i)\n\n        else:\n            self.stacks.append([val])\n            if len(self.stacks[-1]) <self.cap:\n                heapq.heappush(self.h, len(self.stacks)-1)\n        \n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        if self.stacks:\n            return self.stacks[-1].pop()\n        return -1\n        \n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stacks):\n            return -1\n        if len(self.stacks[index]) == self.cap:\n            heapq.heappush(self.h, index)\n        if self.stacks[index]:\n            return self.stacks[index].pop()\n        return -1\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.heap = []\n        self.stacks = []\n\n    def push(self, val: int) -> None:\n        while self.heap and self.heap[0] < len(self.stacks) and len(self.stacks[self.heap[0]]) == self.capacity:\n            heapq.heappop(self.heap)\n        \n        if not self.heap:\n            heapq.heappush(self.heap, len(self.stacks))\n        if self.heap[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.heap[0]].append(val)\n        \n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        if index >= 0 and index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.heap, index)\n            return self.stacks[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.stacks = []\n        self.pq = []\n\n    def push(self, val: int) -> None:\n        \n        while self.pq and len(self.stacks) > self.pq[0] and len(self.stacks[self.pq[0]]) == self.cap:\n            heapq.heappop(self.pq)\n        if not self.pq:\n            heapq.heappush(self.pq, len(self.stacks))\n        if self.pq[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.pq[0]].append(val)\n\n      \n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        if not self.stacks:\n            return -1\n        return self.popAtStack(len(self.stacks) -  1)\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stacks) or not self.stacks[index]:\n            return -1\n        val = self.stacks[index].pop()\n        heapq.heappush(self.pq, index)\n        return val\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stack_list = []\n        self.available_stacks = []\n\n    def push(self, val: int) -> None:\n        while self.available_stacks and self.available_stacks[0] >= len(self.stack_list):\n            heapq.heappop(self.available_stacks)\n        if not self.available_stacks:\n            self.stack_list.append([])\n            self.available_stacks.append(len(self.stack_list) - 1)\n        first_available_stack = self.available_stacks[0]\n        self.stack_list[first_available_stack].append(val)\n        if len(self.stack_list[first_available_stack]) == self.capacity:\n            heapq.heappop(self.available_stacks)\n\n    def pop(self) -> int:\n        while self.stack_list and not self.stack_list[-1]:\n            self.stack_list.pop()\n        return self.popAtStack(len(self.stack_list) - 1)\n        \n        \n    def popAtStack(self, index: int) -> int:\n        if index < 0 or index > len(self.stack_list) - 1 or not self.stack_list[index]:\n            return -1\n        if len(self.stack_list[index]) == self.capacity:\n            heapq.heappush(self.available_stacks, index)\n        result = self.stack_list[index].pop()\n        return result\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\nclass DinnerPlates:\n    def __init__(self, capacity: int):\n        # record values of all stack of plates, its last nonempty stack are the rightmost position\n        self.stk = []\n        self.c = capacity\n        # record the available stack, will use heap to quickly find the smallest available stack\n        self.pq = []\n\n    def push(self, val: int) -> None:\n        # Time: O(logN)\n        # To push, we need to find the leftmost available position. first, let's remove any stacks on the left that are full\n        while self.pq and self.pq[0] < len(self.stk) and len(self.stk[self.pq[0]]) == self.c:\n            heapq.heappop(self.pq)\n        \n        # if the q is empty, meaning there are no more available stacks\n        if len(self.pq) == 0:\n            heapq.heappush(self.pq, len(self.stk))\n        \n        # for the newly added stack, add a new stack to self.stacks accordingly\n        # Key: this new idx NOT NECESSARY added by above \\\"if\\\", it MIGHT already in self.pq\n        if self.pq[0] == len(self.stk):\n            self.stk.append([])\n        \n        # append the value to the leftmost available stack\n        self.stk[self.pq[0]].append(val)\n\n    def pop(self) -> int:\n        # Time: amortized O(1)\n        # To pop, we need to find the rightmost nonempty stack\n        # 1) stacks is not empty (self.stacks) and\n        # 2) the last stack is empty\n        while len(self.stk) > 0 and len(self.stk[-1]) == 0:\n            self.stk.pop()\n         \n        return self.popAtStack(len(self.stk) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        # Time: O(logN)\n        # To pop from an stack of given index, we need to make sure that it is not empty\n        # 1) the index for inserting is valid and\uff0c\n        # 2) the stack of interest is not empty\n        if 0 <= index < len(self.stk) and len(self.stk[index]):\n            # we add the index into the available stack\n            # Also can add index ONLY when length changes from capacity to capacity-1\n            heapq.heappush(self.pq, index)\n            # take the top plate, pop it and return its value\n            return self.stk[index].pop()\n        # otherwise, return -1 because we can't pop any plate\n        else:\n            return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n    #Use heap to store index of available stack\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.stacks = []\n        self.heap = []\n\n    def push(self, val: int) -> None:\n        #While exists heap and most left items in the stack that are full -> pop stack \n        while self.heap and self.heap[0] < len(self.stacks) and len(self.stacks[self.heap[0]]) == self.cap:\n            heapq.heappop(self.heap)\n        \n        #If heap is empty -> need to insert in next index\n        if not self.heap:\n            heapq.heappush(self.heap, len(self.stacks))\n        \n        #If first item in heap has index == len(stacks) = last_index + 1, need to insert to next [array]\n        if self.heap[0] == len(self.stacks):\n            self.stacks.append([])\n            \n        self.stacks[self.heap[0]].append(val)\n        \n            \n    def pop(self) -> int:\n        while self.stacks and self.stacks[-1] == []:\n            self.stacks.pop()\n            \n        return self.popAtStack(len(self.stacks)-1)\n\n    def popAtStack(self, index: int) -> int:\n        if 0<=index<len(self.stacks) and self.stacks[index] != []:\n            heapq.heappush(self.heap, index)\n            return self.stacks[index].pop()\n        \n        return -1\n            \n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.s = [[]]\n        self.c= capacity\n        self.head = 0 # leftmost unfilled array index\n        self.tail = 0 # righmost non-empty array index\n\n    def push(self, val: int) -> None:\n        i=0\n        self.s[self.head].append(val)\n        self.tail = max(self.head, self.tail)\n        \n        while self.head<len(self.s) and len(self.s[self.head])==self.c:\n            self.head +=1\n        if self.head==len(self.s):\n            self.s.append([])\n        #self.tail = max(self.)\n            \n    def pop(self) -> int:\n        if 0<=self.tail<len(self.s):\n            res = self.s[self.tail].pop()\n            while self.tail>=0 and len(self.s[self.tail])==0:\n                self.tail -=1\n            return res\n        \n        return -1\n    \n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.s):\n            return -1\n        if not self.s[index]:\n            return -1\n        res = self.s[index].pop()\n        self.head = min(index, self.head)\n        while self.tail>0 and len(self.s[self.tail])==0:\n            self.tail -=1\n        return res\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.C = capacity\n        self.S = [[]]\n        self.PQ = [0]\n        self.M = 0\n\n    def push(self, val: int) -> None:\n        if not self.PQ:\n            self.S.append([])\n            heapq.heappush(self.PQ, len(self.S)-1)\n            \n        tmp = heapq.heappop(self.PQ)\n        self.M = max(self.M, tmp)\n        self.S[tmp].append(val)\n        if len(self.S[tmp]) < self.C:\n            heapq.heappush(self.PQ, tmp)\n        \n\n    def pop(self) -> int:\n        tmp = self.M\n        while tmp > 0 and not self.S[tmp]:\n            tmp -= 1\n        self.M = tmp\n        if not self.S[tmp]:\n            return -1\n        if len(self.S[tmp]) == self.C:\n            heapq.heappush(self.PQ, tmp)\n        return self.S[tmp].pop()\n        \n\n    def popAtStack(self, index: int) -> int:\n        if len(self.S) > index and self.S[index]:\n            if len(self.S[index]) == self.C:\n                heapq.heappush(self.PQ, index)\n            return self.S[index].pop()\n        else:\n            return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "from collections import defaultdict\nfrom heapq import heappush, heappop\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.size = capacity\n        self.stacks = []\n        self.left_available  = [] # min_heap\n        \n    def push(self, val: int) -> None:\n        # clean up available stacks (which are actually unavailable)\n        while self.left_available  and self.left_available [0] < len(self.stacks) and len(self.stacks[self.left_available [0]]) == self.size:\n            heappop(self.left_available )\n            \n        # now we are at the leftmost available stack (if any)\n        \n        if not self.left_available :\n            heappush(self.left_available , len(self.stacks))\n            \n        # check if the leftmost available stack exist before, or should we create it\n        if self.left_available [0] == len(self.stacks):\n            self.stacks.append([])\n            \n        self.stacks[self.left_available [0]].append(val)\n        \n            \n    def pop(self) -> int:\n        \n        # clean up empty stacks\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        \n        # now we are at the rightmost non-empty stack (if any)\n        \n        return self.popAtStack(len(self.stacks) - 1)\n\n    \n    def popAtStack(self, index: int) -> int:\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            \n            # !! here we could add duplicate index, but it's ok, since we clean up in the push \n            heappush(self.left_available , index)\n            return self.stacks[index].pop()\n        \n        return -1\n            \n        \n        \n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\nclass DinnerPlates:\n    def __init__(self, capacity: int):\n        # record values of all stack of plates, its last nonempty stack are the rightmost position\n        self.stk = []\n        self.c = capacity\n        # record the available stack, will use heap to quickly find the smallest available stack\n        self.pq = []\n\n    def push(self, val: int) -> None:\n        # Time: O(logN)\n        # To push, we need to find the leftmost available position. first, let's remove any stacks on the left that are full\n        while self.pq and self.pq[0] < len(self.stk) and len(self.stk[self.pq[0]]) == self.c:\n            heapq.heappop(self.pq)\n        \n        # if the q is empty, meaning there are no more available stacks\n        if len(self.pq) == 0:\n            heapq.heappush(self.pq, len(self.stk))\n        \n        # for the newly added stack, add a new stack to self.stacks accordingly\n        if self.pq[0] == len(self.stk):\n            self.stk.append([])\n        \n        # append the value to the leftmost available stack\n        self.stk[self.pq[0]].append(val)\n\n    def pop(self) -> int:\n        # Time: amortized O(1)\n        # To pop, we need to find the rightmost nonempty stack\n        # 1) stacks is not empty (self.stacks) and\n        # 2) the last stack is empty\n        while len(self.stk) > 0 and len(self.stk[-1]) == 0:\n            self.stk.pop()\n         \n        return self.popAtStack(len(self.stk) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        # Time: O(logN)\n        # To pop from an stack of given index, we need to make sure that it is not empty\n        # 1) the index for inserting is valid and\uff0c\n        # 2) the stack of interest is not empty\n        if 0 <= index < len(self.stk) and len(self.stk[index]):\n            # we add the index into the available stack\n            # heapq.heappush(self.pq, index)\n            if len(self.stk[index]) == self.c:\n                heapq.heappush(self.pq, index)\n            # take the top plate, pop it and return its value\n            return self.stk[index].pop()\n        # otherwise, return -1 because we can't pop any plate\n        else:\n            return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "from collections import defaultdict\nfrom heapq import heappush, heappop\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.size = capacity\n        self.stacks = []\n        self.leftmost_available = [] # min_heap\n        \n    def push(self, val: int) -> None:\n        # clean up available stacks (which are actually unavailable)\n        while self.leftmost_available and self.leftmost_available[0] < len(self.stacks) and len(self.stacks[self.leftmost_available[0]]) == self.size:\n            heappop(self.leftmost_available)\n            \n        # now we are at the leftmost available stack (if any)\n        \n        if not self.leftmost_available:\n            heappush(self.leftmost_available, len(self.stacks))\n            \n        # check if the leftmost available stack exist before, or should we create it\n        if self.leftmost_available[0] == len(self.stacks):\n            self.stacks.append([])\n            \n        self.stacks[self.leftmost_available[0]].append(val)\n        \n            \n    def pop(self) -> int:\n        \n        # clean up empty stacks\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        \n        # now we are at the rightmost non-empty stack (if any)\n        \n        return self.popAtStack(len(self.stacks) - 1)\n\n    \n    def popAtStack(self, index: int) -> int:\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            \n            # !! here we could add duplicate index, but it's ok, since we clean up in the push \n            heappush(self.leftmost_available, index)\n            return self.stacks[index].pop()\n        \n        return -1\n            \n        \n        \n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\nclass DinnerPlates:\n    def __init__(self, capacity: int):\n        # record values of all stack of plates, its last nonempty stack are the rightmost position\n        self.stk = []\n        self.c = capacity\n        # record the available stack, will use heap to quickly find the smallest available stack\n        self.pq = []\n\n    def push(self, val: int) -> None:\n        # Time: O(logN)\n        # To push, we need to find the leftmost available position. first, let's remove any stacks on the left that are full\n        while self.pq and self.pq[0] < len(self.stk) and len(self.stk[self.pq[0]]) == self.c:\n            heapq.heappop(self.pq)\n        \n        # if the q is empty, meaning there are no more available stacks\n        if len(self.pq) == 0:\n            heapq.heappush(self.pq, len(self.stk))\n        \n        # for the newly added stack, add a new stack to self.stacks accordingly\n        if self.pq[0] == len(self.stk):\n            self.stk.append([])\n        \n        # append the value to the leftmost available stack\n        self.stk[self.pq[0]].append(val)\n\n    def pop(self) -> int:\n        # Time: amortized O(1)\n        # To pop, we need to find the rightmost nonempty stack\n        # 1) stacks is not empty (self.stacks) and\n        # 2) the last stack is empty\n        while len(self.stk) > 0 and len(self.stk[-1]) == 0:\n            self.stk.pop()\n         \n        return self.popAtStack(len(self.stk) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        # Time: O(logN)\n        # To pop from an stack of given index, we need to make sure that it is not empty\n        # 1) the index for inserting is valid and\uff0c\n        # 2) the stack of interest is not empty\n        if 0 <= index < len(self.stk) and len(self.stk[index]):\n            # we add the index into the available stack\n            heapq.heappush(self.pq, index)\n            # if len(self.stk[index]) == self.c:\n            #     heapq.heappush(self.pq, index)\n            # take the top plate, pop it and return its value\n            return self.stk[index].pop()\n        # otherwise, return -1 because we can't pop any plate\n        else:\n            return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.l, self.r, self.cnt = 0, 0, 0\n        self.dic = {}\n        self.dic[0] = []\n\n    def push(self, val: int) -> None:\n        while self.l in self.dic and len(self.dic[self.l]) == self.c:\n            self.l += 1\n        if self.l not in self.dic:\n            self.dic[self.l] = []\n        self.dic[self.l].append(val)\n        self.cnt += 1\n        self.r = max(self.l, self.r)\n        \n    def pop(self) -> int:\n        if not self.cnt:\n            return -1\n        while self.r >= 0 and not self.dic[self.r]:\n            self.r -= 1\n        self.cnt -= 1\n        self.l = min(self.l, self.r)\n        return self.dic[self.r].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index not in self.dic or not self.dic[index]:\n            return -1\n        self.cnt -= 1\n        self.l = min(self.l, index)\n        return self.dic[index].pop()\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.stacks = []\n        self.idx = []\n\n    def push(self, val: int) -> None:\n        if self.idx and 0 <= self.idx[0] < len(self.stacks):\n            i = self.idx[0]\n            st = self.stacks[i]\n            st.append(val)\n            if len(st) == self.cap:\n                heapq.heappop(self.idx)\n        else:\n            self.idx.clear()\n            self.stacks.append([val])\n            if self.cap > 1:\n                self.idx.append(len(self.stacks) - 1)                        \n        \n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        st = self.stacks[-1]\n        val = st.pop()\n        if len(st) == self.cap - 1:\n            heapq.heappush(self.idx, len(self.stacks) - 1)\n        self._clean()\n        return val\n\n    def popAtStack(self, index: int) -> int:\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            st = self.stacks[index]\n            val = st.pop()\n            if len(st) == self.cap - 1:\n                heapq.heappush(self.idx, index)\n            self._clean()\n            return val\n        return -1\n    \n    def _clean(self):\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        \n        \n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.stacks = []\n        self.q = [] # heap of indices\n\n    def push(self, val: int) -> None:\n        # find leftmost location\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            heapq.heappop(self.q)\n        \n        if not self.q:\n            heapq.heappush(self.q, len(self.stacks))\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.q[0]].append(val)\n        \n\n    def pop(self) -> int:\n        # remove empty stacks from end\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        \n        return self.popAtStack(len(self.stacks)-1)\n        \n    def popAtStack(self, index: int) -> int:\n        if 0<=index<len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.q, index)\n            return self.stacks[index].pop()\n        return -1\n            \n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = [[]]\n        self.capacity = capacity\n        self.current = 0\n\n    def push(self, val: int) -> None:\n        if len(self.stacks) <= self.current:\n            self.stacks.append([])\n        self.stacks[self.current].append(val)\n        i = self.current\n        while len(self.stacks) > i and len(self.stacks[i]) == self.capacity:\n            i += 1\n        if len(self.stacks) == i:\n            self.stacks.append([])\n        self.current = i\n        \n        \n\n    def pop(self) -> int:\n        l = len(self.stacks) - 1\n        while l >= 0 and not self.stacks[l]:\n            self.stacks.pop()\n            l -= 1\n        if l == -1:\n            self.current = 0\n            self.stacks = [[]]\n            return -1\n        else:\n            return self.stacks[l].pop()    \n            \n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stacks):\n            return -1\n        if not self.stacks[index]:\n            return -1\n        else:\n            v = self.stacks[index].pop()\n            if index < self.current:\n                self.current = index\n            return v\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stack_list = []\n        self.available_stacks = []\n\n    def push(self, val: int) -> None:\n        if not self.available_stacks:\n            self.stack_list.append([])\n            self.available_stacks.append(len(self.stack_list) - 1)\n        first_available_stack = self.available_stacks[0]\n        self.stack_list[first_available_stack].append(val)\n        if len(self.stack_list[first_available_stack]) == self.capacity:\n            heapq.heappop(self.available_stacks)\n        self.remove_empty_stacks_at_the_end()\n    \n    def remove_empty_stacks_at_the_end(self):\n        while self.stack_list and not self.stack_list[-1]:\n            self.stack_list.pop()\n        while self.available_stacks and self.available_stacks[0] >= len(self.stack_list):\n            heapq.heappop(self.available_stacks)\n    \n    def pop(self) -> int:\n        return self.popAtStack(len(self.stack_list) - 1)     \n        \n    def popAtStack(self, index: int) -> int:\n        if index < 0 or index >= len(self.stack_list) or not self.stack_list[index]:\n            return -1\n        if len(self.stack_list[index]) == self.capacity:\n            heapq.heappush(self.available_stacks, index)\n        result = self.stack_list[index].pop()\n        self.remove_empty_stacks_at_the_end()\n        return result\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity):\n        self.c = capacity\n        self.q = [] # record the available stack, will use heap to quickly find the smallest available stack\n        # if you are Java or C++ users, tree map is another good option.\n        self.stacks = [] # record values of all stack of plates, its last nonempty stack are the rightmost position\n\n    def push(self, val):\n        # To push, we need to find the leftmost available position\n        # first, let's remove any stacks on the left that are full\n        # 1) self.q: if there is still available stack to insert plate\n        # 2) self.q[0] < len(self.stacks): the leftmost available index self.q[0] is smaller than the current size of the stacks\n        # 3) len(self.stacks[self.q[0]]) == self.c: the stack has reached full capacity\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            # we remove the filled stack from the queue of available stacks\n            heapq.heappop(self.q)\n\n        # now we reach the leftmost available stack to insert\n\n        # if the q is empty, meaning there are no more available stacks\n        if not self.q:\n            # open up a new stack to insert\n            heapq.heappush(self.q, len(self.stacks))\n\n        # for the newly added stack, add a new stack to self.stacks accordingly\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n\n        # append the value to the leftmost available stack\n        self.stacks[self.q[0]].append(val)\n\n    def pop(self):\n        # To pop, we need to find the rightmost nonempty stack\n        # 1) stacks is not empty (self.stacks) and\n        # 2) the last stack is empty\n        while self.stacks and not self.stacks[-1]:\n            # we throw away the last empty stack, because we can't pop from it\n            self.stacks.pop()\n\n        # now we reach the rightmost nonempty stack\n\n        # we pop the plate from the last nonempty stack of self.stacks by using popAtStack function\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index):\n        # To pop from an stack of given index, we need to make sure that it is not empty\n        # 1) the index for inserting is valid and\uff0c\n        # 2) the stack of interest is not empty\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            # we add the index into the available stack\n            heapq.heappush(self.q, index)\n            # take the top plate, pop it and return its value\n            return self.stacks[index].pop()\n\n        # otherwise, return -1 because we can't pop any plate\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.stack = []\n        self.cap = capacity\n        self.left = 0\n        self.right = 0\n        \n\n    def push(self, val: int) -> None:\n        if not self.stacks:\n            self.stack.append(val)\n            self.stacks.append(self.stack)\n        else:\n            while self.left < len(self.stacks) and len(self.stacks[self.left]) == self.cap:\n                self.left += 1\n            if self.left == len(self.stacks):\n                self.stacks.append([])\n                self.stacks[self.left].append(val)\n                self.right = len(self.stacks) - 1\n            else:\n                self.stacks[self.left].append(val)\n            \n                \n\n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        if not self.stacks[self.right]:\n            while not self.stacks[self.right]:\n                self.stacks.pop()\n                self.right -= 1\n        item = self.stacks[self.right].pop()\n        \n        if not self.stacks[self.right]:\n            self.stacks.pop()\n            self.right -= 1\n        return item\n                \n        \n\n    def popAtStack(self, index: int) -> int:\n        if index > len(self.stacks) - 1:\n            return -1\n        if not self.stacks[index]:\n            return -1\n        if self.stacks[index]:\n            if self.left > index:\n                self.left = index\n            item = self.stacks[index].pop()\n            return item\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.stacks = []\n        # Prio queue (heap)\n        self.h = []\n\n    def push(self, val: int) -> None:\n        \n        # As we can have multiple time same index in heap, we clean if stack have been fulled\n        while self.h and self.h[0] < len(self.stacks) and len(self.stacks[self.h[0]]) == self.c:\n            heapq.heappop(self.h)\n        \n        # Prio queue is empty, we declare a new list, store it's index\n        if not self.h:\n            heapq.heappush(self.h, len(self.stacks))\n        \n        #create or re-create new stack (heap can still ref a stack that have been deleted from stacks after multiple pop)\n        if self.h[0] == len(self.stacks):\n            self.stacks.append([])\n        \n        self.stacks[self.h[0]].append(val)\n\n    def pop(self) -> int:\n        \n        # We clean emptied stacks\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        \n        return self.popAtStack(len(self.stacks)-1)\n\n    def popAtStack(self, index: int) -> int:\n        \n        # Can have multiple time same index in the heap (else we would need to check if elem in heap O(n))\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.h, index)\n            \n            return self.stacks[index].pop()\n        return -1\n    \n    \n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stack = [[[], capacity]]\n        self.openSlot = [0]\n        self.capacity = capacity\n    \n    def insertAt(self, x):\n        l = 0\n        r = len(self.openSlot) - 1\n        if x < self.openSlot[l]:\n            return 0\n        if x > self.openSlot[r]:\n            return l + 1\n        while r > l:\n            m = (r + l) // 2\n            if self.openSlot[m] < x:\n                l = m + 1\n            else:\n                r = m\n        return l \n        \n    def push(self, val: int) -> None:\n        stackIndex = self.openSlot[0]\n        self.stack[stackIndex][0].append(val)\n        self.stack[stackIndex][1] -= 1\n        if self.stack[stackIndex][1] == 0:\n            self.openSlot.pop(0)\n        if self.openSlot == []:\n            self.stack.append([[], self.capacity])\n            self.openSlot.append(len(self.stack)-1)\n        \n    def pop(self) -> int:\n        while self.stack != [] and self.stack[-1][1] == self.capacity:\n            self.stack.pop(-1)\n            self.openSlot.pop(-1)\n        if self.stack == []:\n            self.stack.append([[], self.capacity])\n            self.openSlot.append(len(self.stack)-1)\n            return -1\n        poppedVal = self.stack[-1][0].pop(-1)\n        self.stack[-1][1] += 1\n        if self.stack[-1][1] == 1:\n            self.openSlot.insert(len(self.openSlot)-1, len(self.stack)-2)\n        return poppedVal\n        \n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stack) or self.stack[index][0] == []:\n            return -1\n        poppedVal = self.stack[index][0].pop(-1)\n        self.stack[index][1] += 1\n        if self.stack[index][1] == 1:\n            self.openSlot.insert(self.insertAt(index), index)\n        return poppedVal\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = []\n        self.leftFreeIndex = 0\n        self.rightOccupiedIndex = 0\n    \n    def seek_head(self):\n        while self.leftFreeIndex < len(self.stacks) and len(self.stacks[self.leftFreeIndex]) == self.capacity:\n            self.leftFreeIndex += 1\n    \n    def seek_tail(self):\n        while self.rightOccupiedIndex > 0 and len(self.stacks[self.rightOccupiedIndex]) == 0:\n            self.rightOccupiedIndex -= 1\n        \n    def push(self, val: int) -> None:\n        if not self.stacks:\n            self.stacks.append([])\n            \n        self.stacks[self.leftFreeIndex].append(val)\n        self.rightOccupiedIndex = max(self.leftFreeIndex, self.rightOccupiedIndex)\n        \n        if len(self.stacks[self.leftFreeIndex]) == self.capacity:\n            self.seek_head()\n            if len(self.stacks) == self.leftFreeIndex:\n                self.stacks.append([])\n        \n    def pop(self) -> int:\n        #print('pop: ', self.stacks)\n        if not self.stacks:\n            #print('stacks is empty, no more stacks')\n            return -1\n        \n        if self.stacks[self.rightOccupiedIndex]:\n            val = self.stacks[self.rightOccupiedIndex].pop(-1)\n            self.seek_tail()\n            return val\n        \n        return -1\n\n    def popAtStack(self, index: int) -> int:\n        #print('popAtStack: ', index, ' with current stacks: ', self.stacks)\n        if index > len(self.stacks)-1:\n            #print('stack at index doesnt exists')\n            return -1\n        \n        if index == self.rightOccupiedIndex and index < self.leftFreeIndex:\n            val = self.stacks[index].pop(-1)\n            self.leftFreeIndex = index\n            self.seek_tail()\n            return val\n        \n        if index < self.leftFreeIndex:\n            val = self.stacks[index].pop(-1)\n            self.leftFreeIndex = index\n            return val\n        \n        if index == self.rightOccupiedIndex:\n            val = self.stacks[index].pop(-1)\n            self.seek_tail()\n            return val\n        \n        if self.stacks[index]:\n            return self.stacks[index].pop(-1)\n        \n        return -1\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity #capacity\n        self.stacks = [[]] #empty stack with the first stack\n        self.stack_num = 1 #total of active (used) stack number\n        self.stack_used = [] #order from left to right where there is an empty space\n        self.stack_used.append(0) #the first stack is ready\n        print(capacity)\n\n    def cleanEmptyTail(self) -> None:\n        i = self.stack_num - 1\n        while i > 0 and len(self.stacks[i]) == 0 and len(self.stacks[i-1]) == 0:\n            self.stacks.pop()\n            self.stack_used.pop()\n            self.stack_num -= 1\n            i -= 1\n        \n    def push(self, val: int) -> None:\n        # assert len(stack_used) > 0, a valid state\n        i = self.stack_used[0] # return the left most stack number\n        self.stacks[i].append(val)\n        if len(self.stacks[i]) < self.capacity:\n            # print('push', val)\n            # print(self.stacks)\n            # print(self.stack_used)\n            return\n        # now start to check this stack is full\n        del self.stack_used[0] # this stack is not available\n        if len(self.stack_used) == 0:\n            # start to get the next one\n            self.stacks.append([])\n            self.stack_used.append(self.stack_num)\n            self.stack_num += 1\n        # print('push', val)\n        # print(self.stacks)\n        # print(self.stack_used)\n        return\n\n    def pop(self) -> int:\n        # it's possible the rightmost stack is empty in the algorithm when it is just prepared.\n        i = self.stack_num - 1\n        if len(self.stacks[i]) == 0: #the algorithm should guarantee that there is not more than two empty\n            # we have to remove this stack if it's not the leftmost one.\n            if i == 0:\n                return -1\n            self.stacks.pop()\n            self.stack_used.pop()\n            self.stack_num -= 1\n            i = self.stack_num -1\n        # now remove this one from stack\n        val = self.stacks[i].pop()\n        if len(self.stack_used) == 0 or self.stack_used[-1] != i: \n            self.stack_used.append(i)\n        # clean rightmost empty stacks\n        self.cleanEmptyTail()\n        # return value\n        # print('p')\n        # print(self.stacks)\n        # print(self.stack_used)\n        return val\n    \n    def insertUsed(self, index: int) -> None:\n        head = 0\n        end = len(self.stack_used) - 1\n        while end - head > 1:\n            i = (head + end) // 2\n            mid_index = self.stack_used[i]\n            if mid_index == index: \n                return # already there\n            if mid_index > index:\n                end = i\n            else:\n                head = i\n        # 5 positions _ head _ end _\n        if self.stack_used[head] > index:\n            self.stack_used.insert(head, index)\n            return\n        if self.stack_used[head] == index or self.stack_used[end] == index:\n            return\n        if self.stack_used[end] > index:\n            self.stack_used.insert(end, index)\n            return\n        self.stack_used.append(index)\n        return\n\n    def popAtStack(self, index: int) -> int:\n        if index >= self.stack_num:\n            return -1\n        if len(self.stacks[index]) == 0:\n            return -1\n        val = self.stacks[index].pop()\n        # insert into the stack_used list\n        self.insertUsed(index)\n        # clean\n        self.cleanEmptyTail()\n        # print('pAt', index)\n        # print(self.stacks)\n        # print(self.stack_used)\n        return val\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stack_list = []\n        self.available_stacks = []\n\n    def push(self, val: int) -> None:\n        self.remove_empty_stacks_at_the_end()\n        if not self.available_stacks:\n            self.stack_list.append([])\n            self.available_stacks.append(len(self.stack_list) - 1)\n        first_available_stack = self.available_stacks[0]\n        self.stack_list[first_available_stack].append(val)\n        if len(self.stack_list[first_available_stack]) == self.capacity:\n            heapq.heappop(self.available_stacks)\n    \n    def remove_empty_stacks_at_the_end(self):\n        while self.stack_list and not self.stack_list[-1]:\n            self.stack_list.pop()\n        while self.available_stacks and self.available_stacks[0] >= len(self.stack_list):\n            heapq.heappop(self.available_stacks)\n    \n    def pop(self) -> int:\n        self.remove_empty_stacks_at_the_end()\n        return self.popAtStack(len(self.stack_list) - 1)     \n        \n    def popAtStack(self, index: int) -> int:\n        if index < 0 or index >= len(self.stack_list) or not self.stack_list[index]:\n            return -1\n        if len(self.stack_list[index]) == self.capacity:\n            heapq.heappush(self.available_stacks, index)\n        result = self.stack_list[index].pop()\n        self.remove_empty_stacks_at_the_end()\n        return result\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.capacity = capacity\n        self.pq = []\n\n    def push(self, val: int) -> None:\n        while self.pq and self.pq[0] < len(self.stacks) and len(self.stacks[self.pq[0]]) == self.capacity:\n            heapq.heappop(self.pq)\n        if not self.pq:\n            heapq.heappush(self.pq, len(self.stacks))\n        if self.pq[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.pq[0]].append(val)\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        if 0 <= index <= len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.pq, index)\n            return self.stacks[index].pop()\n        return -1", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stack = [[]]\n        self.heap = [0]\n        self.cap = capacity\n        \n    def push(self, val: int) -> None:\n        while self.heap[0]<len(self.stack) and len(self.stack[self.heap[0]])==self.cap:\n            heapq.heappop(self.heap)\n        \n        if self.heap[0]==len(self.stack):\n            self.stack.append([])\n        self.stack[self.heap[0]].append(val)\n        if len(self.stack[self.heap[0]])==self.cap:\n            heapq.heappush(self.heap, len(self.stack))\n        \n    def pop(self) -> int:\n        while self.stack and not self.stack[-1]:\n            self.stack.pop()\n        \n        if not self.stack:\n            return -1\n\n        heapq.heappush(self.heap, len(self.stack)-1)\n        return self.stack[-1].pop()\n    \n    def popAtStack(self, index: int) -> int:\n        if index>=len(self.stack) or not self.stack[index]:\n            return -1\n        \n        heapq.heappush(self.heap, index)\n        return self.stack[index].pop()\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stks = []\n        self.queue = []\n        self.idx2cnt = [0 for _ in range(100000 + 5)]\n        \n    def _leftmost_idx(self):\n        ret = len(self.stks)\n        while len(self.queue) > 0:\n            idx = self.queue[0]\n            if self.idx2cnt[idx] < self.capacity:\n                ret = idx\n                break\n            else:\n                heapq.heappop(self.queue)\n        return ret\n    \n    def _rightmost_idx(self):\n        idx = len(self.stks) - 1\n        while idx >= 0 and self.idx2cnt[idx] == 0:\n            idx -= 1\n        return idx\n    \n    def _pop(self, idx):\n        if self.idx2cnt[idx] == 0:\n            return -1\n        ret = self.stks[idx].pop()\n        if self.idx2cnt[idx] == self.capacity:\n            heapq.heappush(self.queue, idx)\n        self.idx2cnt[idx] -= 1\n        while idx > 0 and self.idx2cnt[idx] == 0 and idx == len(self.stks) - 1:\n            self.stks.pop()\n            idx -= 1\n        return ret\n\n    def push(self, val: int) -> None:\n        idx = self._leftmost_idx()\n        if idx == len(self.stks):\n            self.stks.append([])\n            heapq.heappush(self.queue, idx)\n        self.stks[idx].append(val)\n        self.idx2cnt[idx] += 1\n\n    def pop(self) -> int:\n        idx = self._rightmost_idx()\n        return self._pop(idx)\n\n    def popAtStack(self, index: int) -> int:\n        return self._pop(index)\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n    \n    def __init__(self, capacity):\n        \n        self.stacks = []\n        self.stack = []\n        self.capacity = capacity\n        self.left = 0\n        self.right = 0\n\n    def push(self, val):\n        #when stack is initially empty\n        if not self.stacks:            \n            self.stack.append(val)\n            self.stacks.append(self.stack)\n            self.left = 0   \n        else:   \n            #find the leftmost stack with capacity less than capacity to append item\n            while self.left < len(self.stacks) and len(self.stacks[self.left]) == self.capacity:\n                self.left += 1\n            if self.left == len(self.stacks):\n                self.stacks.append([])\n                self.stacks[self.left].append(val)\n            else:\n                self.stacks[self.left].append(val)                \n                        \n            self.right = len(self.stacks) - 1\n\n    def pop(self):\n        if not self.stacks:\n            return -1\n        #find the rightmost non empty stack\n        if not self.stacks[self.right]:\n            while not self.stacks[self.right] and len(self.stacks) - 1 >= self.right:                \n                self.stacks.pop(self.right)\n                self.right -= 1\n                \n        item = self.stacks[self.right].pop() \n        \n        #if stack gets empty after pop item, move the pointer for rightmost non empty stack\n        if not self.stacks[self.right]:\n            self.stacks.pop(self.right)\n            self.right -= 1           \n        \n        return item                        \n        \n    def popAtStack(self, index):\n        \n        if len(self.stacks) - 1 < index:\n            return -1\n        if not self.stacks[index]:\n            return -1\n        \n        #before popping item from stack at index, update the pointer for leftmost stack with capacity\n        if self.stacks[index]:\n            if self.left > index:\n                self.left = index\n        return self.stacks[index].pop()\n    \n    \n    # self made, TLE\n#     def __init__(self, capacity: int):\n#         self.stacks = []\n#         self.capacity = capacity\n\n#     def push(self, val: int) -> None:\n#         if not self.stacks:\n#             self.stacks.append([])\n#         for i in range(len(self.stacks)):\n#             if len(self.stacks[i]) < self.capacity:\n#                 self.stacks[i].append(val)\n#                 break\n#         else:\n#             self.stacks.append([val])\n\n#     def pop(self) -> int:    \n#         if not self.stacks:\n#             return -1\n#         pop_val = None\n#         for i in range(len(self.stacks) - 1, -1, -1):\n#             if self.stacks[i]:\n#                 pop_val = self.stacks[i].pop()\n#                 if not self.stacks[i]:\n#                     del self.stacks[i]\n#                 break\n#             else:\n#                 self.stacks.pop()\n\n#         return pop_val if pop_val else -1\n        \n#     def popAtStack(self, index: int) -> int:\n#         if index >= len(self.stacks):\n#             return -1\n#         pop_val = None\n#         if self.stacks[index]:\n#             pop_val = self.stacks[index].pop()\n#         return pop_val if pop_val else -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stack = [] # just one array to simulate all the stacks\n        self.cap = capacity \n        self.idx = [] # min-heap to track empty indicies\n\n    def push(self, val: int) -> None:\n        if len(self.idx) > 0:\n            while len(self.idx) > 0:\n                i = heappop(self.idx) \n                # Given that we just push index but don't validate the cache while\n                # poping we need to check if this index is within current limits\n                if i < len(self.stack):\n                    self.stack[i] = val\n                    return \n                \n        # we didn't find empty spaces so we add to the end\n        self.stack.append(val)\n\n    def pop(self) -> int:\n        n = len(self.stack) - 1\n        if n < 0:\n            return -1\n        \n        while n > -1:\n            if self.stack[n] != -1:\n                v = self.stack[n]\n                self.stack[n] = -1\n                # Add the empty index to the heap\n                heappush(self.idx , n)\n                return v\n            else:\n                # Because those appear at the end the list we free those memory spaces so\n                # later pop operations are optimized\n                del(self.stack[n])\n            n -= 1\n            \n        # All stacks are empty\n        return -1\n\n    def popAtStack(self, index: int) -> int:\n        # additional check that is [optional] just to skip any effort \n        # if index is already out of current limits\n        count = len(self.stack) // self.cap\n        if index > count:\n            return -1\n        \n        # capture the boundaries of this stack\n        leftptr = (index * self.cap) \n        rightptr = leftptr + self.cap - 1\n        if rightptr > (len(self.stack) - 1): # edge case\n            rightptr = (len(self.stack) - 1)\n            \n        # traverse within the stack at this index until we empty it or we find an occupied location    \n        while self.stack[rightptr] == -1 and rightptr >= leftptr:\n            rightptr -=1\n            \n        # if it isn't empty it means we found occupied position\n        if rightptr >= leftptr:\n            v = self.stack[rightptr]\n            self.stack[rightptr] = -1\n            # Add the empty index to the heap\n            heappush(self.idx , rightptr)\n            return v\n        else:\n            return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.capacity = capacity\n        self.toPush = []\n\n    def push(self, val: int) -> None:\n        if not self.stacks:\n            self.stacks.append([val])\n        else:\n            if self.toPush and self.toPush[0] < len(self.stacks):\n                i = heapq.heappop(self.toPush)\n                self.stacks[i].append(val)\n            else:\n                self.stacks[-1].append(val)\n                \n        if len(self.stacks[-1]) == self.capacity:\n            self.stacks.append([])\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop() \n            # self.toPush = min(self.toPush, len(self.stacks)-1)\n        \n        if not self.stacks:\n            return -1\n        \n        return self.stacks[-1].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.toPush, index)\n            return self.stacks[index].pop()\n        return -1", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.q = [] #avaliable index for stack\n        self.stacks = [] #a list of stack\n        self.c = capacity\n\n    def push(self, val: int) -> None:\n        #find left most empty stack\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            heapq.heappop(self.q) #remove index of full stack\n            \n        if not self.q:\n            heapq.heappush(self.q, len(self.stacks))\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.q[0]].append(val)\n            \n    def pop(self) -> int:\n        #find right most\n        while self.stacks and not self.stacks[-1]:#remove empty stack\n            self.stacks.pop()\n        if self.stacks and self.stacks[-1]:\n            return self.popAtStack(len(self.stacks) - 1)\n        else:\n            return -1\n\n    def popAtStack(self, index: int) -> int:\n        if index >= 0 and index < len(self.stacks) and self.stacks[index]:\n            if len(self.stacks[index]) == self.c:\n            #if True:\n                heapq.heappush(self.q, index) #add avalible index\n            #print(self.q)\n            return self.stacks[index].pop()\n        else:\n            return -1\n            \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.s = [[]]\n        self.cl = 0\n        self.cr = 0\n\n    def push(self, val: int) -> None:\n        # print(self.s)\n        while self.cl < len(self.s) and len(self.s[self.cl]) == self.c:\n            self.cl += 1\n        # print(self.cl)\n        # print(self.s)\n        if self.cl == len(self.s):\n            self.s.append([]) \n        self.s[self.cl].append(val)\n            \n        \n        if self.cl > self.cr:\n            self.cr = self.cl\n\n    def pop(self) -> int:\n        \n        while self.cr > 0 and not len(self.s[self.cr]):\n            self.s.pop()\n            self.cr -= 1\n        if self.cr < self.cl:\n            self.cl = self.cr\n        \n        if len(self.s[self.cr]) > 0:\n            return self.s[self.cr].pop()\n        return -1\n\n    def popAtStack(self, index: int) -> int:\n        if index < len(self.s):\n            if len(self.s[index]) > 0:\n                t = self.s[index].pop()\n                if index < self.cl:\n                    self.cl = index\n                return t\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.q = [] #avaliable index for stack\n        self.stacks = [] #a list of stack\n        self.c = capacity\n\n    def push(self, val: int) -> None:\n        #find left most empty stack\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            heapq.heappop(self.q) #remove index of full stack\n            \n        if not self.q:\n            heapq.heappush(self.q, len(self.stacks))\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.q[0]].append(val)\n            \n    def pop(self) -> int:\n        #find right most\n        while self.stacks and not self.stacks[-1]:#remove empty stack\n            self.stacks.pop()\n        if self.stacks and self.stacks[-1]:\n            return self.popAtStack(len(self.stacks) - 1)\n        else:\n            return -1\n\n    def popAtStack(self, index: int) -> int:\n        if index >= 0 and index < len(self.stacks) and self.stacks[index]:\n            #if len(self.stacks[index]) == self.c:\n            if True:\n                heapq.heappush(self.q, index) #add avalible index\n            #print(self.q)\n            return self.stacks[index].pop()\n        else:\n            return -1\n            \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.arr = [[]]\n        self.indices = [0]\n        self.cap = capacity\n\n    def push(self, val: int) -> None:\n        while len(self.arr[self.indices[0]])==self.cap:\n            heapq.heappop(self.indices)\n            \n        self.arr[self.indices[0]].append(val)\n        if len(self.arr[self.indices[0]])==self.cap and self.indices[0]==len(self.arr)-1:\n            heapq.heappush(self.indices, len(self.arr))\n            self.arr.append([])\n\n    def pop(self) -> int:\n        while self.arr and not self.arr[-1]:\n            self.arr.pop()\n        \n        if self.arr:\n            heapq.heappush(self.indices, len(self.arr)-1)\n            return self.arr[-1].pop()\n        else:\n            return -1\n        \n    def popAtStack(self, index: int) -> int:\n        if index>=len(self.arr) or not self.arr[index]: return -1\n        # print(index, self.arr)\n        heapq.heappush(self.indices, index)\n        return self.arr[index].pop()\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        # use a heap to store all the index whose corresponding list is not full\n        self.h = []\n        self.m = -1\n        self.d = {}\n        self.c = capacity\n        \n    def push(self, val: int) -> None:\n        if len(self.d) == 0 or len(self.h) == 0:\n            self.m += 1\n            self.h = [self.m]\n            self.d[self.m] = []\n            \n        key = self.h[0]\n        if key > self.m:\n            self.m += 1\n            self.h = [self.m]\n            self.d[self.m] = []            \n        \n        if key not in self.d:\n            self.d[key] = []\n        \n        self.d[key].append(val)\n        \n        if len(self.d[key]) == self.c:\n            heapq.heappop(self.h)\n        \n    def pop(self) -> int:\n\n        return self.popAtStack(self.m)\n\n    def popAtStack(self, index: int) -> int:\n        if len(self.d)==0 or index not in self.d or len(self.d[index])==0:\n            return -1\n        \n        res = self.d[index].pop()\n\n        if len(self.d[index]) == self.c-1:\n            heapq.heappush(self.h, index)\n        \n        while self.m not in self.d or len(self.d[self.m])==0:\n            if self.m in self.d:\n                self.d.pop(self.m)\n            self.m -= 1\n            \n            if self.m == -1:\n                break\n        \n        return res\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n    def __init__(self, capacity):\n        self.c = capacity\n        self.q = []\n        self.stacks = []\n\n    def push(self, val):\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            heapq.heappop(self.q)\n\n        if not self.q:\n            heapq.heappush(self.q, len(self.stacks))\n\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.q[0]].append(val)\n\n    def pop(self):\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index):\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.q, index)\n            return self.stacks[index].pop()\n        return -1\n        \n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks=[]\n        self.stack=[]\n        self.size=capacity\n        self.left=0\n        self.right=0\n\n        \n\n    def push(self, val: int) -> None:\n         if not self.stacks:            \n            self.stack.append(val)\n            self.stacks.append(self.stack)\n            self.left=0\n                           \n         else:   \n            #find the leftmost stack with size less than capacity to append item\n            while self.left<len(self.stacks) and len(self.stacks[self.left])==self.size:\n                self.left+=1\n            if self.left==len(self.stacks):\n                self.stacks.append([])\n                self.stacks[self.left].append(val)\n            else:\n                self.stacks[self.left].append(val)                \n                        \n            self.right=len(self.stacks)-1\n        \n\n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        \n        #find the rightmost non empty stack\n        if not self.stacks[self.right]:\n            while not self.stacks[self.right]:                \n                self.stacks.pop(self.right)\n                self.right-=1\n                \n        item=self.stacks[self.right].pop() \n        \n        #if stack gets empty after pop item, move the pointer for rightmost non empty stack\n        if not self.stacks[self.right]:\n            self.stacks.pop(self.right)\n            self.right-=1           \n         \n        return item       \n        \n\n    def popAtStack(self, index: int) -> int:\n        if len(self.stacks)-1<index:\n            return -1\n        if not self.stacks[index]:\n            return -1\n        \n        #before popping item from stack at index, update the pointer for leftmost stack with capacity\n        if self.stacks[index]:\n            if self.left>index:\n                self.left=index\n        return self.stacks[index].pop()\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.indicies = []\n        self.stacks = []\n        self.cap = capacity\n    \n    def clean_stack(self):\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n            \n    def push(self, val: int) -> None:\n        while self.indicies:\n            index = heappop(self.indicies)\n            \n            if index < len(self.stacks) and len(self.stacks[index]) < self.cap:\n                self.stacks[index].append(val)\n                return\n        \n        if self.stacks and len(self.stacks[-1]) < self.cap:\n            self.stacks[-1].append(val)\n        else:\n            self.stacks.append([val])\n        \n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        else:\n            res = self.stacks[-1].pop()\n        \n        if not self.stacks[-1]:\n            self.clean_stack()\n        else:\n            heappush(self.indicies, len(self.stacks) - 1)\n        \n        return res\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stacks) or not self.stacks[index]:\n            return -1\n        \n        res = self.stacks[index].pop()\n        \n        if not self.stacks[-1]:\n            self.clean_stack()\n        else:\n            heappush(self.indicies, index)\n        \n        return res\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "from collections import deque\nimport heapq\n\nclass DinnerPlates:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacklist = []\n        self.minh = []\n\n    def push(self, val: int) -> None:\n        while len(self.minh) > 0:\n            lms = heapq.heappop(self.minh)\n            if len(self.stacklist) - 1 >= lms:\n                self.stacklist[lms].append(val)\n                break\n        else:\n            if len(self.stacklist) == 0 or len(self.stacklist[-1]) >= self.capacity:\n                self.stacklist.append(deque())\n            self.stacklist[-1].append(val)\n\n    def pop(self) -> int:\n        if len(self.stacklist) == 0:\n            return -1\n\n        while len(self.stacklist[-1]) == 0:\n            del self.stacklist[-1]\n\n        if len(self.stacklist) > 0:\n            res = self.stacklist[-1].pop()\n        else:\n            res = -1\n\n        if len(self.stacklist[-1]) == 0:\n            del self.stacklist[-1]\n\n        return res\n\n    def popAtStack(self, index: int) -> int:\n        if len(self.stacklist) - 1 < index or len(self.stacklist[index]) == 0:\n            return -1\n        else:\n            res = self.stacklist[index].pop()\n            heapq.heappush(self.minh, index)\n            return res", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.stack = []\n        self.cap = capacity\n        self.left = 0\n        self.right = 0\n        \n\n    def push(self, val: int) -> None:\n        if not self.stacks:\n            self.stack.append(val)\n            self.stacks.append(self.stack)\n        else:\n            while self.left < len(self.stacks) and len(self.stacks[self.left]) == self.cap:\n                self.left += 1\n            if self.left == len(self.stacks):\n                self.stacks.append([])\n                self.stacks[self.left].append(val)\n            else:\n                self.stacks[self.left].append(val)\n            self.right = len(self.stacks) - 1\n                \n\n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        if not self.stacks[self.right]:\n            while not self.stacks[self.right]:\n                self.stacks.pop()\n                self.right -= 1\n        item = self.stacks[self.right].pop()\n        \n        if not self.stacks[self.right]:\n            self.stacks.pop()\n            self.right -= 1\n        return item\n                \n        \n\n    def popAtStack(self, index: int) -> int:\n        if index > len(self.stacks) - 1:\n            return -1\n        if not self.stacks[index]:\n            return -1\n        if self.stacks[index]:\n            if self.left > index:\n                self.left = index\n            item = self.stacks[index].pop()\n            return item\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stack = [[]]\n        self.leftmost = 0\n        self.rightmost = 0\n        \n\n    def push(self, val: int) -> None:\n        try:\n            self._find_leftmost()\n        except IndexError:\n            self.stack.append([])\n\\t\\t\\t# updates the rightmost index if needed\n            if self.leftmost >= self.rightmost:\n                self.rightmost = self.leftmost\n\n        self.stack[self.leftmost].append(val)\n        \n    def pop(self) -> int:\n        try:\n            self._find_rightmost()\n        except IndexError:\n            self.rightmost = 0\n            return -1\n\n        return self.stack[self.rightmost].pop()\n\n    def popAtStack(self, index: int) -> int:\n        if index >= len(self.stack) or not self.stack[index]:\n            return -1\n\n        value = self.stack[index].pop()\n        if index < self.leftmost:\n            self.leftmost = index\n        return value\n\n    def _find_leftmost(self):\n        while len(self.stack[self.leftmost]) >= self.capacity:\n            self.leftmost += 1\n\n    def _find_rightmost(self):\n        while not self.stack[self.rightmost]:\n            self.rightmost -= 1\n", "import heapq\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.q = []\n        self.stacks = []\n\n    def push(self, val: int) -> None:\n        # Find the leftmost available stack\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.capacity:\n            heapq.heappop(self.q)\n        \n        # If q is empty\n        if not self.q:\n            heapq.heappush(self.q, len(self.stacks))\n            \n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n        \n        self.stacks[self.q[0]].append(val)\n\n    def pop(self) -> int:\n        # Pop empty stack\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        \n        return self.popAtStack(len(self.stacks)-1)\n        \n\n    def popAtStack(self, index: int) -> int:\n        if 0<=index<len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.q, index)\n            return self.stacks[index].pop()\n            \n        return -1\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stack = [[]]\n        self.leftmost = 0\n        self.rightmost = 0\n        \n\n    def push(self, val: int) -> None:\n        try:\n            self._find_leftmost()\n        except IndexError:\n            self.stack.append([])\n\\t\\t\\t# updates the rightmost index if needed\n            if self.leftmost >= self.rightmost:\n                self.rightmost = self.leftmost\n\n        self.stack[self.leftmost].append(val)\n        \n    def pop(self) -> int:\n        try:\n            self._find_rightmost()\n        except IndexError:\n            self.rightmost = 0\n            return -1\n\n        return self.stack[self.rightmost].pop()\n\n    def popAtStack(self, index: int) -> int:\n\n        if index >= len(self.stack) or not self.stack[index]:\n            return -1\n\n        value = self.stack[index].pop()\n        if index < self.leftmost:\n            self.leftmost = index\n        return value\n\n    def _find_leftmost(self):\n        while len(self.stack[self.leftmost]) >= self.capacity:\n            self.leftmost += 1\n\n    def _find_rightmost(self):\n        while not self.stack[self.rightmost]:\n            self.rightmost -= 1", "class DinnerPlates:\n    def __init__(self, capacity):\n        self.c = capacity\n        self.q = [] # record the available stack, will use heap to quickly find the smallest available stack\n        # if you are Java or C++ users, tree map is another good option.\n        self.stacks = [] # record values of all stack of plates, its last nonempty stack are the rightmost position\n\n    def push(self, val):\n        # To push, we need to find the leftmost available position\n        # first, let's remove any stacks on the left that are full\n        # 1) self.q: if there is still available stack to insert plate\n        # 2) self.q[0] < len(self.stacks): the leftmost available index self.q[0] is smaller than the current size of the stacks\n        # 3) len(self.stacks[self.q[0]]) == self.c: the stack has reached full capacity\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            # we remove the filled stack from the queue of available stacks\n            heapq.heappop(self.q)\n\n        # now we reach the leftmost available stack to insert\n\n        # if the q is empty, meaning there are no more available stacks\n        if not self.q:\n            # open up a new stack to insert\n            heapq.heappush(self.q, len(self.stacks))\n\n        # for the newly added stack, add a new stack to self.stacks accordingly\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n\n        # append the value to the leftmost available stack\n        self.stacks[self.q[0]].append(val)\n\n    def pop(self):\n        # To pop, we need to find the rightmost nonempty stack\n        # 1) stacks is not empty (self.stacks) and\n        # 2) the last stack is empty\n        while self.stacks and not self.stacks[-1]:\n            # we throw away the last empty stack, because we can't pop from it\n            self.stacks.pop()\n\n        # now we reach the rightmost nonempty stack\n\n        # we pop the plate from the last nonempty stack of self.stacks by using popAtStack function\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index):\n        # To pop from an stack of given index, we need to make sure that it is not empty\n        # 1) the index for inserting is valid and\uff0c\n        # 2) the stack of interest is not empty\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            # we add the index into the available stack\n            heapq.heappush(self.q, index)\n            # take the top plate, pop it and return its value\n            return self.stacks[index].pop()\n\n        # otherwise, return -1 because we can't pop any plate\n        return -1\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.stacks = []\n        self.heap = []\n    def push(self, val: int) -> None:\n        if self.heap and self.heap[0]>=len(self.stacks):\n            self.heap = []\n        if self.heap:\n            if len(self.stacks[self.heap[0]]) < self.cap:\n                self.stacks[self.heap[0]].append(val)\n                if len(self.stacks[self.heap[0]]) == self.cap:\n                    heapq.heappop(self.heap)\n        else:\n            self.stacks.append([val])\n            if self.cap != 1:\n                heapq.heappush(self.heap, len(self.stacks)-1)\n\n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        if self.stacks and len(self.stacks[-1]) == self.cap:\n            heapq.heappush(self.heap, len(self.stacks)-1)\n        return self.stacks[-1].pop() if self.stacks else -1\n\n    def popAtStack(self, index: int) -> int:\n        if len(self.stacks) <= index or not self.stacks[index]:\n            return -1\n        if len(self.stacks[index]) == self.cap:\n            heapq.heappush(self.heap, index)\n        return self.stacks[index].pop()\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stack = []\n        self.available_to_push = []   # min heap to store the idx of available-to-push stack\n\n    def push(self, val: int) -> None:\n        # step 1: pop out all the left stacks that are not avaliable to push, \n        # so that after the while loop, we will know the leftmost stack that is available to push\n        while len(self.available_to_push) > 0 and self.available_to_push[0] < len(self.stack) and len(self.stack[self.available_to_push[0]]) == self.capacity:\n            heappop(self.available_to_push)\n            \n        # if the q is empty, meaning there are no more available stacks\n        if len(self.available_to_push) == 0:        \n            heappush(self.available_to_push, len(self.stack))\n        if self.available_to_push[0] == len(self.stack):\n            self.stack.append([])\n            \n        # finally, we can push our val into the leftmost available stack\n        self.stack[self.available_to_push[0]].append(val)\n\n    def pop(self) -> int:\n        # step 1: pop out all the empty stacks on the right, cuz they are not available to pop\n        while len(self.stack) > 0 and len(self.stack[-1]) == 0:\n            self.stack.pop()\n            \n        return self.popAtStack(len(self.stack) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        # check if it is available to pop\n        if 0 <= index < len(self.stack) and len(self.stack[index]) > 0:\n            heappush(self.available_to_push, index)     # add this index to the available-to-push heap\n            return self.stack[index].pop()\n        return -1\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.heap = []\n        self.stacks = []\n    \n    def push(self, val):\n        while self.heap and self.heap[0] < len(self.stacks) and len(self.stacks[self.heap[0]]) == self.capacity:\n            heapq.heappop(self.heap)\n        \n        if not self.heap:\n            heapq.heappush(self.heap, len(self.stacks))\n        if self.heap[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.heap[0]].append(val)\n        \n    def pop(self):\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        return self.popAtStack(len(self.stacks) - 1)\n    \n    def popAtStack(self, index):\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.heap, index)\n            return self.stacks[index].pop()\n        return -1\n    \n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "from heapq import heappop, heappush\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stack = []\n        self.pop_q = []\n        self.push_q = []\n        \n\n    def push(self, val: int) -> None:\n        if self.pop_q:\n            i = heappop(self.pop_q)\n            self.stack[i] = val\n        else:\n            i = len(self.stack)\n            self.stack.append(val)\n        heappush(self.push_q, -i)\n        \n\n    def pop(self) -> int:\n        if self.push_q:\n            i = - heappop(self.push_q)\n            while self.stack[i] == -1 and self.push_q:\n                i = - heappop(self.push_q)\n            if self.stack[i] != -1:\n                heappush(self.pop_q, i)\n                val = self.stack[i]\n                self.stack[i] = -1\n                return val\n        return -1\n        \n\n    def popAtStack(self, index: int) -> int:\n        start = index * self.capacity\n        end = min(start + self.capacity - 1, len(self.stack) - 1)\n        for i in range(end, start-1, -1):\n            if self.stack[i] != -1:\n                heappush(self.pop_q, i)\n                val = self.stack[i]\n                self.stack[i] = -1\n                return val\n        return -1\n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n\n        \n        self.c = capacity\n        # heap queue to find the leftmost available stack.\n        self.q = []\n        # a list stacks to save all stacks.\n        self.stacks = [] \n        \n\n    def push(self, val: int) -> None:\n        # the leftmost available index self.q[0] is smaller than the current size of the stacks\n        # the stack has reached full capacity\n        while self.q and self.q[0] < len(self.stacks) and len(self.stacks[self.q[0]]) == self.c:\n            # we remove the filled stack from the queue of available stacks\n            heapq.heappop(self.q)\n\n        # now we reach the leftmost available stack to insert\n\n        # if the q is empty, no more available stacks\n        if not self.q:\n            # open up a new stack to insert\n            heapq.heappush(self.q, len(self.stacks))\n\n        # for the newly added stack, add a new stack to self.stacks accordingly\n        if self.q[0] == len(self.stacks):\n            self.stacks.append([])\n\n        # append the value to the leftmost available stack\n        self.stacks[self.q[0]].append(val)\n\n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            # we throw away the last empty stack, because we can't pop from it\n            self.stacks.pop()\n\n        # now we reach the rightmost nonempty stack\n\n        # we pop the plate from the last nonempty stack of self.stacks by using popAtStack function\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            # we add the index into the available stack\n            heapq.heappush(self.q, index)\n            # take the top plate, pop it and return its value\n            return self.stacks[index].pop()\n\n        # otherwise, return -1 because we can't pop any plate\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.max = capacity\n        self.top = 0\n        self.stack = collections.defaultdict(list)\n        self.stack[self.top] = [0, []]\n        self.h = []; \n        heapq.heappush(self.h, 0)\n        \n    def push(self, val: int) -> None:\n        \n        ptr = heapq.heappop(self.h)\n        self.stack[ptr][1].append(val)\n        self.stack[ptr][0] += 1\n        if self.stack[ptr][0]<self.max: heapq.heappush(self.h, ptr)\n        elif ptr==self.top: \n            self.top += 1\n            self.stack[self.top] = [0, []]\n            heapq.heappush(self.h, self.top)\n\n        \n    def popAtStack(self, index: int) -> int:\n\n        if not index in self.stack or not self.stack[index][0]: return -1\n        if self.stack[index][0]==self.max:\n            heapq.heappush(self.h, index)\n        self.stack[index][0] -= 1\n        return self.stack[index][1].pop() \n        \n    def pop(self) -> int:\n        while self.top  and not self.stack[self.top][0]:\n            self.top -= 1\n        return self.popAtStack(self.top)\n\n        \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "import heapq\n\n\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self._stacks = []\n        self._capacity = capacity\n        self._start = 0\n\n    def push(self, val: int) -> None:\n        stack_idx = self._start\n        while stack_idx < len(self._stacks):\n            if len(self._stacks[stack_idx]) < self._capacity:\n                break\n            stack_idx += 1\n        self._start = stack_idx\n        if stack_idx == len(self._stacks):\n            self._stacks.append([])        \n        self._stacks[stack_idx].append(val)\n\n    def pop(self) -> int:\n        while self._stacks and not self._stacks[-1]:\n            self._stacks.pop()\n        if self._stacks:\n            self._start = min(self._start, len(self._stacks[-1]) - 1)\n            return self._stacks[-1].pop()\n        else:\n            return -1\n\n    def popAtStack(self, index: int) -> int:\n        if index < len(self._stacks) and self._stacks[index]:\n            self._start = min(self._start, index)\n            return self._stacks[index].pop()\n        else:\n            return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = [[]]\n        self.capacity = capacity\n        self.left = 0\n        self.right = -1\n        \n\n    def push(self, val: int) -> None:\n        self.stacks[self.left].append(val)\n        if self.left > self.right:\n            self.right = self.left\n        if len(self.stacks[self.left]) == self.capacity:\n            self.left = self.left + 1\n            while True:\n                if self.left <= len(self.stacks) - 1:\n                    if len(self.stacks[self.left]) < self.capacity:\n                        return None\n                    else:\n                        self.left = self.left + 1\n                else:\n                    self.stacks.append([])\n                    return None\n\n    def pop(self) -> int:\n        if self.right == -1:\n            return -1\n        else:\n            toreturn = self.stacks[self.right].pop()\n            if self.stacks[self.right]:\n                if self.left > self.right:\n                    self.left = self.right\n                return toreturn\n            else:\n                self.right = self.right - 1\n                while True:\n                    if self.right > -1:\n                        if self.stacks[self.right]:\n                            return toreturn\n                        else:\n                            self.right = self.right - 1\n                    \n                    return toreturn\n                        \n\n    def popAtStack(self, index: int) -> int:\n        if index < len(self.stacks):\n            if self.stacks[index]:\n                if index < self.left:\n                    self.left = index\n                toreturn = self.stacks[index].pop()\n                if not self.stacks[index] and index == self.right:\n                                    self.right = self.right - 1\n                while True:\n                    if self.right > -1:\n                        if self.stacks[self.right]:\n                            return toreturn\n                        else:\n                            self.right = self.right - 1\n                    \n                    return toreturn\n        return -1\n            \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.stacks = []\n        self.stack = []\n        self.cap = capacity\n        self.left = 0\n        self.right = 0\n        \n\n    def push(self, val: int) -> None:\n        if not self.stacks:\n            self.stack.append(val)\n            self.stacks.append(self.stack)\n            self.left = 0\n        else:\n            while self.left < len(self.stacks) and len(self.stacks[self.left]) == self.cap:\n                self.left += 1\n            if self.left == len(self.stacks):\n                self.stacks.append([])\n                self.stacks[self.left].append(val)\n            else:\n                self.stacks[self.left].append(val)\n            self.right = len(self.stacks) - 1\n                \n\n    def pop(self) -> int:\n        if not self.stacks:\n            return -1\n        if not self.stacks[self.right]:\n            while not self.stacks[self.right]:\n                self.stacks.pop()\n                self.right -= 1\n        item = self.stacks[self.right].pop()\n        \n        if not self.stacks[self.right]:\n            self.stacks.pop()\n            self.right -= 1\n        return item\n                \n        \n\n    def popAtStack(self, index: int) -> int:\n        if index > len(self.stacks) - 1:\n            return -1\n        if not self.stacks[index]:\n            return -1\n        if self.stacks[index]:\n            if self.left > index:\n                self.left = index\n            item = self.stacks[index].pop()\n            return item\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "from queue import PriorityQueue\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.stacks =[]\n        self.q = PriorityQueue()\n\n         \n\n    def push(self, val: int) -> None:\n        while self.stacks and not self.q.empty():\n            idx = self.q.get()\n            if idx > len(self.stacks) - 1:\n                self.stacks.append([])\n            # if len(self.stacks[idx]) == self.cap:\n            #     continue\n            # else:\n            self.stacks[idx].append(val)\n            if len(self.stacks[idx]) < self.cap:\n                self.q.put(idx)\n            return\n        \n        if not self.stacks:\n            self.stacks = [[val]]\n            if len(self.stacks[-1]) < self.cap:\n                self.q.put(0)\n        elif self.q.empty():\n            self.stacks.append([val])\n            if len(self.stacks[-1]) < self.cap:\n                self.q.put(len(self.stacks) - 1)\n        \n\n    def pop(self) -> int:\n        while self.stacks:\n            if not self.stacks[-1]:\n                del self.stacks[-1]\n            else:\n                v = self.stacks[-1][-1]\n                del self.stacks[-1][-1]\n                if len(self.stacks[-1]) == self.cap -1:\n                    self.q.put(len(self.stacks) - 1)\n                return v\n        return -1\n        \n\n    def popAtStack(self, index: int) -> int:\n        if index < len(self.stacks):\n            l = self.stacks[index]\n            if l:\n                if len(l) == self.cap:\n                    self.q.put(index)\n                v = l.pop()\n                return v\n            else:\n                return -1\n        else:\n            return -1\n                \n        \n        \n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.s = []\n        self.h = []\n\n    def push(self, val: int) -> None:\n        # print(self.s)\n        while self.h and self.h[0] < len(self.s) and len(self.s[self.h[0]]) == self.c:\n            heapq.heappop(self.h)\n        \n        if not self.h:\n            heapq.heappush(self.h, len(self.s))\n            \n        if self.h[0] == len(self.s):\n            self.s.append([]) \n        self.s[self.h[0]].append(val)\n            \n\n    def pop(self) -> int:\n        \n        while  self.s and not self.s[-1]:\n            self.s.pop()\n            \n        return self.popAtStack(len(self.s)-1)\n\n    def popAtStack(self, index: int) -> int:\n        # print(self.s)\n        # print(self.h)\n        if 0 <= index < len(self.s) and self.s[index]:\n            heapq.heappush(self.h, index)\n            return self.s[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = []\n        self.stacks = []\n\n    def push(self, val):\n        while self.queue and self.queue[0] < len(self.stacks) and len(self.stacks[self.queue[0]]) == self.capacity:\n            heapq.heappop(self.queue)\n\n        if not self.queue:\n            heapq.heappush(self.queue, len(self.stacks))\n\n        if self.queue[0] == len(self.stacks):\n            self.stacks.append([])\n        self.stacks[self.queue[0]].append(val)\n\n    def pop(self):\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index):\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.queue, index)\n            return self.stacks[index].pop()\n        return -1\n        \n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.minHeap = []\n        self.stacksTotal = []\n        \n\n    def push(self, val: int) -> None:\n        while self.minHeap and self.minHeap[0] < len(self.stacksTotal) and len(self.stacksTotal[self.minHeap[0]]) == self.capacity:\n            heapq.heappop(self.minHeap)\n            \n        \n        if not self.minHeap:\n            heapq.heappush(self.minHeap, len(self.stacksTotal))\n        \n        if self.minHeap[0] == len(self.stacksTotal):\n            self.stacksTotal.append([])\n        \n        self.stacksTotal[self.minHeap[0]].append(val)\n        \n        \n        \n    def pop(self) -> int:\n        while self.stacksTotal and not self.stacksTotal[-1]:\n            self.stacksTotal.pop()\n        \n        return self.popAtStack(len(self.stacksTotal) - 1)\n        \n        \n        \n\n    def popAtStack(self, index: int) -> int:\n        if 0<= index < len(self.stacksTotal) and self.stacksTotal[index]:\n            heapq.heappush(self.minHeap, index)\n            return self.stacksTotal[index].pop()\n        \n        return -1\n        \n\n", "import heapq\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        \n        self.q = []\n        self.c = capacity\n        self.h = []\n\n    def push(self, val: int) -> None:\n        #print(\\\"Before Push: q:{}, h:{}\\\".format(self.q, self.h))\n        if self.h:\n            index = heapq.heappop(self.h)\n            if index > len(self.q) - 1:\n                self.h = []\n                if self.q and self.q[-1] and len(self.q[-1]) < self.c:\n                    self.q[-1] += [val]\n                else:\n                    self.q.append([val])\n            else:\n                if self.q[index]:\n                    self.q[index] += [val]\n                else:\n                    self.q[index] = [val]\n        else:\n            if self.q and self.q[-1] and len(self.q[-1]) < self.c:\n                self.q[-1] += [val]\n            else:\n                self.q.append([val])\n        #print(\\\"after Push: q:{}, h:{}\\\".format(self.q, self.h))\n                \n    def pop(self) -> int:\n        #print(\\\"POP q:{}\\\".format(self.q))\n        while self.q:\n            if self.q[-1]:\n                item = self.q[-1].pop()\n                if not self.q:\n                    self.q.pop()\n                #print(\\\"POP return q:{}, item:{}\\\".format(self.q, item))\n                return item\n            else:\n                self.q.pop()\n        return -1\n\n    def popAtStack(self, index: int) -> int:\n        \n        #print(\\\"Index POP: index:{}, q:{}\\\".format(index, self.q))\n        if index > len(self.q) - 1:\n            return -1\n        \n        if self.q[index]:\n            item = self.q[index].pop()\n            heapq.heappush(self.h, index)\n            return item\n        else:\n            return -1\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.c = capacity\n        self.s = []\n        self.q = []\n\n    def push(self, val: int) -> None:\n        while self.q and (self.q[0] >= len(self.s) or len(self.s[self.q[0]]) == self.c):\n            heapq.heappop(self.q)\n        \n        # print(self.q, self.s)\n        if self.q:\n            idx = self.q[0]\n            self.s[idx].append(val)\n            if len(self.s[idx]) == self.c:\n                heapq.heappop(self.q)\n        else:\n            idx = len(self.s)-1\n            if not self.s or len(self.s[-1]) == self.c:\n                idx += 1\n                self.s.append([])\n            self.s[idx].append(val)\n\n    def pop(self) -> int:\n        while self.s and not self.s[-1]:\n            self.s.pop()\n        return self.popAtStack(len(self.s) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        # print(self.s)\n        if 0 <= index < len(self.s) and self.s[index]:\n            heapq.heappush(self.q, index)\n            return self.s[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n", "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.stacks = []\n        self.tofill = []\n\n    def push(self, val: int) -> None:\n        while self.tofill and self.tofill[0] < len(self.stacks) and len(self.stacks[self.tofill[0]]) == self.capacity:\n            heapq.heappop(self.tofill)\n        \n        if not self.tofill:\n            heapq.heappush(self.tofill, len(self.stacks))\n        \n        if self.tofill[0] == len(self.stacks):\n            self.stacks.append([])\n        \n        self.stacks[self.tofill[0]].append(val)\n            \n    def pop(self) -> int:\n        while self.stacks and not self.stacks[-1]:\n            self.stacks.pop()\n            \n        return self.popAtStack(len(self.stacks) - 1)\n\n    def popAtStack(self, index: int) -> int:\n        if 0 <= index < len(self.stacks) and self.stacks[index]:\n            heapq.heappush(self.tofill, index)\n            return self.stacks[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n"]