["class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        pr=[i for i in range(len(s))]\n        def union(x,y):\n            p1=find(x)\n            p2=find(y)\n            if p1!=p2:\n                pr[p1]=p2\n        def find(x):\n            while pr[x]!=x:\n                pr[x]=pr[pr[x]]\n                x=pr[x]\n            return x\n        \n        for i in pairs:\n            union(i[0],i[1])\n            \n        from collections import defaultdict\n        dp=defaultdict(list)\n        for i in range(len(s)):\n            ld=find(i)\n            dp[ld].append(i)\n        ans=[0]*len(s)\n        for i in dp:\n            dp[i].sort()\n            st=''\n            for j in dp[i]:\n                st+=s[j]\n            st=sorted(st)\n            c=0\n            for j in dp[i]:\n                ans[j]=st[c]\n                c+=1\n        return ''.join(ans)\n        \n        \n        \n        \n        \n        \n                \n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        \n        parents = [i for i in range(n)]\n\n        def find_parent(i):\n            while parents[i] != i:\n                # path compression\n                parents[i] = parents[parents[i]]\n                i = parents[i]\n            return i\n\n        def do_union(p, q):\n            i = find_parent(p)\n            j = find_parent(q)\n            parents[i] = j\n\n        for p, q in pairs:\n            do_union(p, q)\n       \n        groups = defaultdict(list)\n        for i in range(len(s)):\n            root = find_parent(i)\n            groups[root].append(i)\n        \n        s = list(s)\n        for indices in sorted(groups.values()):\n            vals = sorted([s[i] for i in indices])\n            for i, c in enumerate(vals):\n                s[indices[i]] = c\n            \n        return ''.join(s)", "class UnionFind:\n    def __init__(self, N):\n        self.par = list(range(N))\n        self.rank = [0]*N\n        \n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px==py: return\n        if self.rank[px]<self.rank[py]:\n            self.par[px] = py\n        elif self.rank[px]>self.rank[py]:\n            self.par[py] = px\n        else:\n            self.par[py] = px\n            self.rank[px] += 1\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        N = len(s)\n        uf = UnionFind(N)\n        res = ['']*N\n        indices = defaultdict(list)\n        \n        for u, v in pairs:\n            uf.union(u, v)\n        \n        for i in range(N):\n            indices[uf.find(i)].append(i)\n        \n        for i in indices:\n            chars = sorted([s[j] for j in indices[i]])\n            for j in range(len(indices[i])):\n                res[indices[i][j]] = chars[j]\n\n        return ''.join(res)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        self.parent = {i: i for i in range(len(s))}\n        \n        for pos1, pos2 in pairs:\n            self.merge(pos1, pos2)\n        \n        connected_component = defaultdict(list)\n        for i in range(len(s)):\n            connected_component[self.find(i)].append(s[i])\n        for k in connected_component.keys():\n            connected_component[k].sort(reverse=True)\n            \n        res = []\n        for i in range(len(s)):\n            res.append(connected_component[self.find(i)].pop())\n        \n        return ''.join(res)\n    \n    \n    def find(self, e):\n        while e != self.parent[e]:\n            self.parent[e] = self.parent[self.parent[e]]\n            e = self.parent[e]\n        return e\n    \n    def merge(self, e1, e2):\n        root1, root2 = self.find(e1), self.find(e2)\n        if root1 != root2:\n            self.parent[root1] = root2\n        \n        return ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        parent = [i for i in range(n)]\n        group = collections.defaultdict(list)\n        res = []\n        def find(a):\n            p = parent[a]\n            while p!= parent[p]:\n                p = parent[p]\n            parent[a] = p\n            return p\n        def union(a,b):\n            pa,pb = find(a),find(b)\n            if pa!=pb:\n                parent[pa] = pb\n        for u,v in pairs:\n            union(u,v)\n        for i in range(n):\n            group[find(i)].append(s[i])\n        for k in group:\n            group[k].sort(reverse=True)\n        for i in range(n):\n            res.append(group[find(i)].pop())\n        return ''.join(res)", "import heapq\nfrom copy import copy, deepcopy\nclass MaxHeapObj(object):\n    def __init__(self, val): self.val = val\n    def __lt__(self, other): return self.val > other.val\n    def __eq__(self, other): return self.val == other.val\n    def __str__(self): return str(self.val)\n \nclass MinHeap(object):\n    def __init__(self, arr=[]):\n        self.h = deepcopy(arr)\n        heapq.heapify(self.h)\n \n    def heappush(self, x): heapq.heappush(self.h, x)\n    def heappop(self): return heapq.heappop(self.h)\n    def __getitem__(self, i): return self.h[i]\n    def __len__(self): return len(self.h)\n \nclass MaxHeap(object):\n    def __init__(self, arr=[]):\n        self.h = [MaxHeapObj(x) for x in arr]\n        heapq.heapify(self.h)\n \n    def heappush(self, x): heapq.heappush(self.h, MaxHeapObj(x))\n    def heappop(self): return heapq.heappop(self.h).val\n    def __getitem__(self, i): return self.h[i].val\n    def __len__(self): return len(self.h)\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        res, n, adj, component_num, curr, comp_vals = [], len(s), defaultdict(list), defaultdict(lambda: -1), 0, defaultdict(lambda: MinHeap())\n        for edge in pairs:\n            adj[edge[0]].append(edge[1])\n            adj[edge[1]].append(edge[0])\n        \n        def DFS(i, comp):\n            \n            component_num[i] = comp \n            for j in adj[i]:\n                if component_num[j] == -1: DFS(j, comp)\n        \n        for i in range(n):\n            if component_num[i] == -1: \n                DFS(i, curr)\n                curr += 1 \n            comp_vals[component_num[i]].heappush(s[i])\n        \n        for i in range(n):\n            res.append(comp_vals[component_num[i]].heappop())\n        \n        return \\\"\\\".join(res)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(i):\n            visited[i] = True\n            component.append(i)\n            for adj in adj_list[i]:\n                if not visited[adj]:\n                    dfs(adj)\n        \n        adj_list = collections.defaultdict(list)\n        visited = [False] * len(s)\n        for pair in pairs:\n            adj_list[pair[0]].append(pair[1])\n            adj_list[pair[1]].append(pair[0])\n            \n        ans = list(s)\n    \n        for index in range(len(s)):\n            if not visited[index]:\n                component = []\n                dfs(index)\n                component.sort()\n                lst_chars = [ans[i] for i in component]\n                lst_chars.sort()\n                for i in range(len(lst_chars)): ans[component[i]] = lst_chars[i]\n        \n        return \\\"\\\".join(ans)\n                \n        \n        \n            ", "class DSU:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n        \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        if px==py:\n            return\n        if self.rank[px]>self.rank[py]:\n            self.parent[py] = px\n            self.rank[px]+=self.rank[py]\n        else:\n            self.parent[px]=py\n            self.rank[py]+=self.rank[x]\n        \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        dsu = DSU(n)\n        for x,y in pairs:\n            dsu.union(x,y)\n        # Club everyone with the same parent\n        hm = collections.defaultdict(list)\n        for i in range(n):\n            hm[dsu.find(i)].append(s[i])\n        for key in hm:\n            hm[key].sort()\n        res = []\n        for i in range(n):\n            res.append(hm[dsu.find(i)].pop(0))\n        return \\\"\\\".join(res)\n            \n        ", "from typing import List\nfrom collections import defaultdict\n\n\nclass DisjointSet:\n    def __init__(self, n):\n        self.makeSet(n)\n\n    def makeSet(self, n):\n        self.parent = [i for i in range(n)]\n\n    def union(self, i, j):\n        self.parent[self.find(i)] = self.find(j)\n\n    def find(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        sa = list(s)\n        lens = len(s)\n        ds = DisjointSet(lens)\n        for pair in pairs:\n            i = pair[0]\n            j = pair[1]\n            ip = ds.find(i)\n            jp = ds.find(j)\n            if ip != jp:\n                ds.union(i, j)\n        cm = defaultdict(lambda: [])\n        for i in range(lens):\n            ip = ds.find(i)\n            cm[ip].append((i, sa[i]))\n        for _, li in list(cm.items()):\n            if li:\n                lsv = sorted(li, key=lambda t: t[1])\n                for i in range(len(li)):\n                    sa[li[i][0]] = lsv[i][1]\n\n        return ''.join(sa)\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        if len(s) < 2 or len(pairs) == 0:\n            return s\n        \n        class UnionFind:\n            def __init__(self, N):\n                self.arr = [i for i in range(N)]\n                \n            def find(self, x):\n                if self.arr[x] == x:\n                    return x\n                else:\n                    self.arr[x] = self.find(self.arr[x])\n                    return self.arr[x]\n            \n            def union(self, x1, x2):\n                self.arr[self.find(x1)] = self.find(x2)\n            \n        uf = UnionFind(len(s))\n        for pair in pairs:\n            uf.union(pair[0], pair[1])\n        \n        g = defaultdict(list)\n        for i in range(len(s)):\n            g[uf.find(i)].append(s[i])\n            \n        for k in g:\n            g[k].sort(reverse=True)\n        \n        res = []\n        for i in range(len(s)):\n            res.append(g[uf.find(i)].pop())\n        \n        return \\\"\\\".join(res)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n            class UF:\n                def __init__(self, n): self.p = list(range(n))\n                def union(self, x, y): self.p[self.find(x)] = self.find(y)\n                def find(self, x):\n                    if x != self.p[x]: self.p[x] = self.find(self.p[x])\n                    return self.p[x]\n            uf, res, m = UF(len(s)), [], defaultdict(list)\n            for x,y in pairs: \n                uf.union(x,y)\n            for i in range(len(s)): \n                m[uf.find(i)].append(s[i])\n            for comp_id in list(m.keys()): \n                m[comp_id].sort(reverse=True)\n            for i in range(len(s)): \n                res.append(m[uf.find(i)].pop())\n            return ''.join(res)\n\n# from collections import defaultdict\n\n# class Solution:\n#     def find(self,x):\n#         if(x!=self.parent[x]):\n#             x=self.find(self.parent[x])\n#         return x\n        \n        \n#     def union(self,x,y):\n#         x_find=self.find(x)\n#         y_find=self.find(y)\n#         self.parent[x_find]=y_find\n        \n    \n    \n#     def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n#         n=len(s)\n#         self.parent=list(range(n))\n        \n#         for x,y in pairs:\n#             self.union(x,y)\n        \n#         # print(self.parent)\n        \n#         groups=defaultdict(list)\n#         for i in range(n):\n#             tem=self.find(i)\n#             # self.parent[i]=tem\n#             groups[tem].append(s[i])    \n#             # print(tem)\n#         # print(self.parent)\n        \n#         ans=\\\"\\\"\n#         for comp_id in groups.keys(): \n#             groups[comp_id].sort(reverse=True)\n            \n#         # print(groups)\n        \n#         for i in range(n): \n#             ans+=groups[self.find(i)].pop()\n#         return ans\n        \n        \n# # #         for i in range(len(s)):\n# # #             if(i not in added):\n# # #                 groups[i]=[i]\n        \n# #         # print(groups)\n# #         ls=dict()\n# #         for i,j in groups.items():\n# #             ls[tuple(j)]=sorted([s[ele] for ele in j])\n# #         # print(ls)\n        \n# #         ans=\\\"\\\"\n# #         for i in range(len(s)):\n# #             ans+=ls[tuple(groups[self.parent[i]])].pop(0)\n        \n# #         return ans\n                \n        \n            \n        \n        \n        \n        \n# # #         self.ans=s\n# # #         visited=set()\n# # # #         def traverse(st,pair,i):\n# # # #             print(st,i)\n# # # #             if(st in visited):\n# # #                 return\n# # #             visited.add(st)\n# # #             a,b=pair[i][0],pair[i][1]\n# # #             st=list(st)\n# # #             st[a],st[b]=st[b],st[a]\n# # #             st=\\\"\\\".join(st)\n# # #             self.ans=min(self.ans,st)\n# # #             # tem=st[:]\n# # #             for j in range(len(pair)):\n# # #                 if(i!=j):\n# # #                     traverse(st,pair,j)\n        \n        \n        \n        \n# #             # traverse(s,pairs,i)\n        \n# #         q=[s]\n# #         while(q!=[]):\n# #             tem=q.pop(0)\n# #             if(tem in visited):\n# #                 continue\n# #             visited.add(tem)\n# #             self.ans=min(self.ans,tem)\n# #             for i in range(len(pairs)):\n# #                 a,b=pairs[i][0],pairs[i][1]\n# #                 tem=list(tem)\n# #                 tem[a],tem[b]=tem[b],tem[a]\n# #                 tem=\\\"\\\".join(tem)\n# #                 q.append(tem)\n            \n        \n# #         return self.ans\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        p = list(range(len(s)))\n        d = defaultdict(list)\n        def find(x):\n            if x!=p[x]:\n                p[x]=find(p[x])\n            return p[x]\n        def union(x,y):\n            p[find(x)]=find(y)\n        for a,b in pairs:\n            union(a,b)\n        for i in range(len(p)):\n            d[find(i)].append(s[i])\n        for i in d:\n            d[find(i)].sort(reverse=True)\n        ret=''\n        for i in range(len(s)):\n            ret+=d[find(i)].pop()\n        return ret", "class UF:\n    def __init__(self, n):\n        self.f = list(range(n))\n        self.cc = [1] * n\n        \n    def find(self, x):\n        while x != self.f[x]: #\n            x = self.f[x]\n        return x \n    \n    def union(self, x, y):\n        fx, fy = self.find(x), self.find(y)\n        if fx != fy:\n            if self.cc[fx] <= self.cc[fy]: # path compression\n                self.f[fx] = fy\n                self.cc[fx], self.cc[fy] = 0,  self.cc[fx] + self.cc[fy]\n            else:\n                self.f[fy] = fx\n                self.cc[fx], self.cc[fy] = self.cc[fx] + self.cc[fy], 0\n                \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        if not s or not pairs:\n            return s \n        \n        n = len(s)\n        uf = UF(n)\n        \n        for p in pairs:\n            a, b = p[0], p[1]\n            uf.union(a, b)\n            \n        f2c = collections.defaultdict(list)\n        for i in range(n):\n            f = uf.find(i)\n            f2c[f].append(i)\n            \n        ls = [''] * n\n        for _, comp in list(f2c.items()):\n            if not comp: continue\n            tmp = [s[c] for c in comp]\n            comp.sort()\n            tmp.sort()\n            for i in range(len(comp)):\n                ls[comp[i]] = tmp[i]\n        \n        return ''.join(ls)\n                \n", "from heapq import *\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, prs: List[List[int]]) -> str:\n        f = {}\n        for p in prs:\n            r_a, r_b = self.fnd(f, p[0]), self.fnd(f, p[1])\n            if r_a != r_b:\n                f[r_b] = r_a\n        \n        m, res = defaultdict(list), []\n        for i in range(len(s)):\n            m[self.fnd(f, i)].append(s[i])\n        for v in list(m.values()):\n            heapify(v)\n        for i in range(len(s)):\n            res.append(heappop(m[self.fnd(f, i)]))\n        return ''.join(res)\n            \n        \n    def fnd(self, f, n):\n        f[n] = f.get(n, n)\n        if f[n] == n:\n            return n\n        f[n] = self.fnd(f, f[n])\n        \n        return f[n]\n", "from heapq import *\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, prs: List[List[int]]) -> str:\n        f = {}\n        for p in prs:\n            r_a, r_b = self.fnd(f, p[0]), self.fnd(f, p[1])\n            if r_a != r_b:\n                f[r_b] = r_a\n        \n        m, res = defaultdict(list), []\n        for i in range(len(s)):\n            m[self.fnd(f, i)].append(s[i])\n        for v in list(m.values()):\n            heapify(v)\n            print(v)\n        for i in range(len(s)):\n            res.append(heappop(m[self.fnd(f, i)]))\n        return ''.join(res)\n            \n        \n    def fnd(self, f, n):\n        f[n] = f.get(n, n)\n        if f[n] == n:\n            return n\n        f[n] = self.fnd(f, f[n])\n        \n        return f[n]\n        \n", "class Solution:\n    \n    def dfs(self, i):\n        self.tmp.append(self.ls[i])\n        self.idx.append(i)\n        self.visited.add(i)\n        for j in self.d[i]:\n            if j not in self.visited:\n                self.dfs(j)\n\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:       \n        self.ls = list(s)\n        self.visited = set()\n        self.d = [[] for _ in range(len(self.ls))]\n\n        for i,j in pairs:\n            self.d[i].append(j)\n            self.d[j].append(i)\n\n        for i in range(len(self.ls)):\n            if i not in self.visited:\n                self.tmp = []\n                self.idx = []\n                self.dfs(i)\n\n                sorted_tmp = sorted(self.tmp)\n                sorted_idx = sorted(self.idx)\n                #print(sorted_tmp, sorted_idx,\\\"CONNECTED\\\", self.visited)\n\n                for index in range(len(sorted_idx)):\n                    self.ls[sorted_idx[index]] = sorted_tmp[index]\n\n        return ''.join(self.ls)\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        parent = {i:i for i in range(len(s))}\n        def find(x):\n            if x != parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        for edge in pairs:  # Union\n            parent[find(edge[0])] = find(edge[1])\n        \n        parent_table = collections.defaultdict(list)\n        for i in list(parent.keys()):\n            parent_table[find(i)].append(i)\n        \n        ans = list(s)\n        for i in list(parent_table.keys()):\n            ids = sorted(parent_table[i])\n            t = sorted(ans[j] for j in ids)\n            for j in range(len(ids)):\n                ans[ids[j]] = t[j]\n        \n        return ''.join(ans)\n", "from collections import defaultdict\n\nclass Solution:\n    def find(self,x):\n        if(x!=self.parent[x]):\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n        \n        \n    def union(self,x,y):\n        x_find=self.find(x)\n        y_find=self.find(y)\n        self.parent[x_find]=y_find\n        \n    \n    \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n=len(s)\n        self.parent=list(range(n))\n        \n        for x,y in pairs:\n            self.union(x,y)\n        \n        # print(self.parent)\n        \n        groups=defaultdict(list)\n        for i in range(n):\n            tem=self.find(i)\n            # self.parent[i]=tem\n            groups[tem].append(s[i])    \n            # print(tem)\n        # print(self.parent)\n        \n        ans=[]\n        for comp_id in groups.keys(): \n            groups[comp_id].sort(reverse=True)\n            \n        # print(groups)\n        \n        for i in range(n): \n            ans.append(groups[self.find(i)].pop())\n        return \\\"\\\".join(ans)\n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        class UF:\n            def __init__(self,n):\n                self.p = list(range(n))\n            def union(self, x, y):\n                self.p[self.find(x)] = self.find(y)\n            def find(self, x):\n                if x != self.p[x]:\n                    self.p[x] = self.find(self.p[x])\n                return self.p[x]\n        \n        uf, res, m = UF(len(s)), [], collections.defaultdict(list)\n        \n        for x, y in pairs:\n            uf.union(x,y)\n        for i in range(len(s)):\n            m[uf.find(i)].append(s[i])\n        for comp_id in list(m.keys()):\n            m[comp_id].sort(reverse=True)\n        for i in range(len(s)):\n            res.append(m[uf.find(i)].pop())\n        return ''.join(res)\n        \n        \n        \n", "class DisjSet:\n    def __init__(self, n):\n        self.disj_set = [-1] * n\n        \n    def find(self, x):\n        while self.disj_set[x] >= 0:\n            x = self.disj_set[x]\n        return x\n    \n    def union(self, x, y):\n        i = self.find(x)\n        j = self.find(y)\n        if i == j:\n            return\n        if self.disj_set[i] < self.disj_set[j]:\n            self.disj_set[j] = i\n        else:\n            if self.disj_set[i] == self.disj_set[j]:\n                self.disj_set[j] -= 1\n            self.disj_set[i] = j\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        result = []\n        disj = DisjSet(n)\n        for a, b in pairs:\n            disj.union(a, b)\n        g = collections.defaultdict(collections.Counter)\n        for i in range(n):\n            g[disj.find(i)][s[i]] += 1\n        for i in g:\n            g[i] = [[k, v] for k, v in g[i].items()]\n            g[i].sort(reverse=True)\n        for i in range(n):\n            j = disj.find(i)\n            chars = g[j]\n            result.append(chars[-1][0])\n            chars[-1][1] -= 1\n            if chars[-1][1] == 0:\n                chars.pop()\n        return ''.join(result)", "def dfs(index,s,edges,visited):\n    indices = []\n    vals = []\n    stack = [index]\n    while stack:\n        index = stack.pop()\n        if index not in visited:\n            visited.add(index)\n            indices.append(index)\n            vals.append(s[index])\n            for kid in edges[index]:\n                stack.append(kid)\n    \n    indices.sort()\n    vals.sort()\n    for index in indices:\n        s[index] = vals.pop(0)\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        visited = set()\n        s = list(s)\n        edges = {}\n        for a,b in pairs:\n            if a not in edges.keys():\n                edges[a] = []\n            \n            if b not in edges.keys():\n                edges[b] = []\n                \n            edges[a].append(b)\n            edges[b].append(a)\n        \n        for i in edges.keys():\n            if i not in visited:\n                dfs(i,s,edges,visited)\n        \n        return ''.join(s)", "from collections import defaultdict\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self,n):\n                self.p=list(range(n))\n            def union(self,x,y):\n                self.p[self.find(x)]=self.find(y)\n            def find(self,x):\n                if self.p[x] is not x:\n                    self.p[x]=self.find(self.p[x])\n                return self.p[x]\n        uf,res,m=UF(len(s)),[],defaultdict(list)\n        for x,y in pairs:\n            uf.union(x,y)\n        for i in range(len(s)):\n            m[uf.find(i)].append(s[i])\n        for i in m.keys():\n            m[i].sort(reverse=True)\n        for i in range(len(s)):\n            res.append(m[uf.find(i)].pop())\n        return ''.join(res)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        g = collections.defaultdict(list)\n        for a, b in pairs:\n            g[a].append(b)\n            g[b].append(a)\n        n = len(s)\n        s = list(s)\n        while g:\n            i, j = g.popitem()\n            visited = {i}\n            visited.update(j)\n            chars = collections.Counter()\n            q = collections.deque(j)\n            while q:\n                i = q.popleft()\n                if i in g:\n                    j = g.pop(i)\n                    q.extend(j)\n                    visited.update(j)\n            visited = sorted(visited)\n            for i in visited:\n                chars[s[i]] += 1\n            j = 0\n            for c in sorted(chars):\n                for k in range(chars[c]):\n                    s[visited[j]] =  c\n                    j += 1\n        return ''.join(s)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        parents = [i for i,_ in enumerate(s)]\n        def find(i):\n            if i == parents[i]:\n                return i\n            parents[i] = find(parents[i])\n            return parents[i]\n        \n        def union(i, j):\n            i, j = find(i), find(j)\n            if i != j:\n                parents[i] = parents[j]\n            \n        for i,j in pairs:\n            union(i,j)\n                           \n        groups = reduce((lambda group, i:\n                group[find(i)].append(i)\n               or group),\n               range(len(s)),\n              defaultdict(list))\n        \n        res = [0] * len(s)\n        for items in groups.values():\n            for i,c in zip(items, sorted(s[i] for i in items)):\n                res[i] = c\n            \n        return ''.join(res)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UnionFind:\n            def __init__(self, N):\n                self.arr = [i for i in range(N)]\n                \n            def find(self, x):\n                if self.arr[x] == x:\n                    return x\n                else:\n                    self.arr[x] = self.find(self.arr[x])\n                    return self.arr[x]\n            \n            def union(self, x1, x2):\n                self.arr[self.find(x1)] = self.find(x2)\n            \n        uf = UnionFind(len(s))\n        for pair in pairs:\n            uf.union(pair[0], pair[1])\n        \n        g = defaultdict(list)\n        for i in range(len(s)):\n            g[uf.find(i)].append(s[i])\n            \n        for k in g:\n            g[k].sort(reverse=True)\n        \n        res = []\n        for i in range(len(s)):\n            res.append(g[uf.find(i)].pop())\n        \n        return \\\"\\\".join(res)", "class Solution:\n    def __init__(self):\n      self.roots = {}\n      self.ranks = {}\n      self.idx2chars = {}\n      \n    def find(self, idx) -> int:\n      self.roots.setdefault(idx, idx)\n      self.ranks.setdefault(idx, 1)\n      self.idx2chars.setdefault(idx, [self.s[idx]])\n      if self.roots[idx] != idx:\n        self.roots[idx] = self.find(self.roots[idx])\n      return self.roots[idx]\n    \n    def union(self, idx1, idx2) -> None:\n      root1, root2 = self.find(idx1), self.find(idx2)\n      if root1 != root2:\n        if self.ranks[root2] < self.ranks[root1]:\n          self.roots[root2] = root1\n          self.idx2chars[root1].extend(self.idx2chars[root2])\n        elif self.ranks[root2] > self.ranks[root1]:\n          self.roots[root1] = root2\n          self.idx2chars[root2].extend(self.idx2chars[root1])\n        else:\n          self.roots[root2] = root1\n          self.idx2chars[root1].extend(self.idx2chars[root2])\n          self.ranks[root1] += 1\n    \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n      \\\"\\\"\\\"\n      Union find, and for each union root, keep a queue of letters in sorted order. Then finally iterate over the string indices to re-build the string\n      \\\"\\\"\\\"\n      self.s = s\n      for idx1, idx2 in pairs:\n        root1, root2 = self.find(idx1), self.find(idx2)\n        if root1 != root2:\n          self.union(idx1, idx2)\n      \n      for idx in self.idx2chars:\n        self.idx2chars[idx].sort(reverse=True)  # so we can pop the last\n      \n      # print(\\\"roots: \\\", self.roots)\n      # print(\\\"idx2chars: \\\", self.idx2chars)\n      \n      ordered_s = ''\n      for idx in range(len(s)):\n        root = self.find(idx)\n        # print(\\\"idx, root: \\\", idx, root)\n        ordered_s += self.idx2chars[root].pop()\n      \n      return ordered_s", "class Solution:\n    def __init__(self):\n      self.roots = {}\n      self.ranks = {}\n      self.idx2chars = {}\n      \n    def find(self, idx) -> int:\n      self.roots.setdefault(idx, idx)\n      self.ranks.setdefault(idx, 1)\n      self.idx2chars.setdefault(idx, [self.s[idx]])\n      if self.roots[idx] != idx:\n        self.roots[idx] = self.find(self.roots[idx])\n      return self.roots[idx]\n    \n    def union(self, idx1, idx2) -> None:\n      root1, root2 = self.find(idx1), self.find(idx2)\n      if root1 != root2:\n        if self.ranks[root2] < self.ranks[root1]:\n          self.roots[root2] = root1\n          self.idx2chars[root1].extend(self.idx2chars[root2])\n        elif self.ranks[root2] > self.ranks[root1]:\n          self.roots[root1] = root2\n          self.idx2chars[root2].extend(self.idx2chars[root1])\n        else:\n          self.roots[root2] = root1\n          self.idx2chars[root1].extend(self.idx2chars[root2])\n          self.ranks[root1] += 1\n    \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n      \\\"\\\"\\\"\n      Union find, and for each union root, keep a queue of letters in sorted order. Then finally iterate over the string indices to re-build the string\n      \\\"\\\"\\\"\n      self.s = s\n      for idx1, idx2 in pairs:\n        root1, root2 = self.find(idx1), self.find(idx2)\n        if root1 != root2:\n          self.union(idx1, idx2)\n      \n      for idx in self.idx2chars:\n        self.idx2chars[idx].sort(reverse=True)  # so we can pop the last\n      \n      # print(\\\"roots: \\\", self.roots)\n      # print(\\\"idx2chars: \\\", self.idx2chars)\n      \n      ordered_chars = [''] * len(s)\n      for idx in range(len(s)):\n        root = self.find(idx)\n        # print(\\\"idx, root: \\\", idx, root)\n        ordered_chars[idx] = self.idx2chars[root].pop()\n      \n      return ''.join(ordered_chars)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(i):\n            visited[i] = True\n            component.append(i)\n            for j in adj_lst[i]:\n                if not visited[j]:\n                    dfs(j)\n            \n        n = len(s)\n        adj_lst = [[] for _ in range(n)]\n        for i, j in pairs:\n            adj_lst[i].append(j)\n            adj_lst[j].append(i)\n        visited = [False for _ in range(n)]\n        lst = list(s)\n        for i in range(n):\n            if not visited[i]:\n                component = []\n                dfs(i)\n                component.sort()\n                chars = [lst[k] for k in component]\n                chars.sort()\n                for i in range(len(component)):\n                    lst[component[i]] = chars[i]\n        return ''.join(lst)", "import collections\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        s=list(s)\n        path=collections.defaultdict(list)\n        for u,v in pairs:\n            path[u].append(v)\n            path[v].append(u)\n        seen=set()\n        group=[] # group of nodes\n        for i in range(len(s)):\n            if i in seen: continue \n            else: # start to search for connected points\n                cur=[i]\n                connect=[i]\n                while cur:\n                    temp=[]\n                    for c in cur:\n                        if c not in seen: \n                            seen.add(c)\n                            temp+=[x for x in path[c] if x not in seen]\n                    cur=temp\n                    connect+=cur\n                group.append(connect)\n        for g in group:\n            temp=sorted([s[i] for i in set(g)])\n            for i in sorted(set(g)):\n                s[i]=temp[0]\n                temp.pop(0)\n        return \\\"\\\".join(s)\n             \n                \n            \n            \n        \n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        d = {}\n        for a,b in pairs:\n            if a not in d:\n                d[a] = []\n            if b not in d:\n                d[b] = []\n            d[a].append(b)\n            d[b].append(a)\n        \n        def dfs(x, result):\n            if x in d:\n                result.append(x)\n                for y in d.pop(x):\n                    dfs(y,result)\n        \n        s = list(s)\n        while d:\n            x = next(iter(d))\n            result = []\n            dfs(x, result)\n            result = sorted(result)\n            B = sorted([ s[i] for i in result ])\n            for i,b in enumerate(B):\n                s[result[i]] = b\n        return ''.join(s)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n=len(s)\n        self.p=[i for i in range(n)]\n        for x,y in pairs:\n            self.union(x,y)\n        \n        dic=collections.defaultdict(list)\n        \n        for i in range(n):\n            dic[self.find(i)].append(s[i])\n            \n        for k in dic.keys():\n            dic[k]=sorted(dic[k])\n            \n        res=[]\n        for i in range(n):\n            res.append(dic[self.find(i)].pop(0))\n        \n        return ''.join(res)\n        \n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    \n    def union(self,x,y):\n        self.p[self.find(x)]=self.find(y)", "class DSU:\n    def __init__(self, n):\n        self.dsu = [i for i in range(n)]\n        \n    def find(self, x):\n        if x == self.dsu[x]:\n            return x\n        self.dsu[x] = self.find(self.dsu[x])\n        return self.dsu[x]\n    \n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        self.dsu[yr] = xr\n        return\n    \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        dsu = DSU(n)\n        for x, y in pairs:\n            dsu.union(x, y)\n        groups = defaultdict(list)\n        for i in range(n):\n            key = dsu.find(i)\n            groups[key].append(s[i])\n        for k in groups:\n            groups[k] = sorted(groups[k])\n        ans = []\n        for i in range(n):\n            key = dsu.find(i)\n            ans.append(groups[key].pop(0))\n        return \\\"\\\".join(ans)\n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self, n): \n                self.p = list(range(n))\n                \n            def union(self, x, y): \n                self.p[self.find(x)] = self.find(y)\n                \n            def find(self, x):\n                if x != self.p[x]: \n                    self.p[x] = self.find(self.p[x])\n                return self.p[x]\n            \n        uf, res, m = UF(len(s)), [], defaultdict(list)\n        \n        for x,y in pairs: \n            uf.union(x,y)\n            \n        for i in range(len(s)): \n            m[uf.find(i)].append(s[i])\n            \n        for comp_id in m.keys(): \n            m[comp_id].sort(reverse=True)\n            \n        for i in range(len(s)): \n            res.append(m[uf.find(i)].pop())\n            \n        return ''.join(res)", "from typing import List\n\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \\\"\\\"\\\"\n        find union\n\n        \u628a pairs \u8996\u70ba graph edge, \u7528 find union alg \u5206\u7fa4\n        \u627e\u51fa\u6bcf\u500b\u7fa4\u7684 idxes / chars\n        \u500b\u5225\u6392\u5e8f\uff0c\u586b\u56de\n        \\\"\\\"\\\"\n        parents = [i for i in range(len(s))]  # \u9019\u908a\u8981\u7528\u4e0d\u540c\u7684 id\uff0c\u5f8c\u9762\u624d\u597d\u8655\u7406\n\n        def find_parent(v) -> int:\n            if parents[v] != v:\n                parents[v] = find_parent(parents[v])\n            return parents[v]\n\n        # union\n        for edge in pairs:\n            p1, p2 = find_parent(edge[0]), find_parent(edge[1])\n            parents[p1] = p2\n\n        # group idx/char in each group as map\n        group_idx_mapping = {}\n        group_char_mapping = {}\n        for i in range(len(s)):  # for each idx\n            group_id = find_parent(i)\n            try:\n                group_idx_mapping[group_id].append(i)\n            except KeyError:\n                group_idx_mapping[group_id] = [i]\n            try:\n                group_char_mapping[group_id].append(s[i])\n            except KeyError:\n                group_char_mapping[group_id] = [s[i]]\n\n        # sort idx/chars in each group\n        ans = [''] * len(s)\n        for i in range(len(s)):  # for each group\n            if i not in group_idx_mapping:\n                continue\n            # idxes = sorted(group_idx_mapping[i])\n            idxes = group_idx_mapping[i]  # already sorted\n            chars = sorted(group_char_mapping[i])\n            for j in range(len(idxes)):\n                ans[idxes[j]] = chars[j]\n\n        return ''.join(ans)\n\n        # \\\"\\\"\\\"\n        # DFS\n        # \\\"\\\"\\\"\n        # # build graph\n        # g = [[] for _ in range(len(s))]\n        # for edge in pairs:\n        #     g[edge[0]].append(edge[1])\n        #     g[edge[1]].append(edge[0])  # bug: \u61c9\u70ba indirected graph\n        #\n        # # DFS, find components\n        # visited = set()\n        #\n        # def f(i):  # fulfill idexes and chars\n        #     if i in visited:\n        #         return\n        #     else:\n        #         visited.add(i)\n        #\n        #     # visit\n        #     idxes.append(i)\n        #     chars.append(s[i])\n        #\n        #     for adj in g[i]:\n        #         f(adj)\n        #\n        # ans = [''] * len(s)\n        # for i in range(len(s)):\n        #     if i in visited:\n        #         continue\n        #     idxes = []\n        #     chars = []\n        #     f(i)\n        #\n        #     # sort each components\n        #     idxes.sort() # bug\n        #     chars.sort()\n        #\n        #     for j in range(len(chars)):\n        #         ans[idxes[j]] = chars[j]\n        #\n        # return ''.join(ans)\n\n\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        if not pairs:\n            return s\n        \n        adj_list = {}\n        visited = set()\n        sub_string = ''\n        sub_indices = []\n        \n        for i in range(len(pairs)):\n            adj_list[pairs[i][0]] = adj_list.get(pairs[i][0], []) + [pairs[i][1]]\n            adj_list[pairs[i][1]] = adj_list.get(pairs[i][1], []) + [pairs[i][0]]\n        \n        def dfs(index):\n            nonlocal sub_string\n            sub_string += s[index]\n            sub_indices.append(index)\n            visited.add(index)\n            \n            if index in adj_list:\n                for neighbor in adj_list[index]:\n                    if neighbor not in visited:\n                        dfs(neighbor)\n                    \n        \n        for i in range(len(s)):\n            sub_string = ''\n            sub_indices = []\n            if i not in visited:\n                dfs(i)\n                sub_string = sorted(sub_string)\n                sub_indices.sort()\n                \n                for i in range(len(sub_indices)):\n                    s = s[:sub_indices[i]] + sub_string[i] + s[sub_indices[i] + 1 : ]\n        \n        return s", "class DUS:\n    def __init__(self, N):\n        self.N = N\n        self.p = [i for i in range(self.N)]\n    \n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x] \n\n    def union(self, x, y):\n        rootx = self.find(x)\n        rooty = self.find(y)\n        if rootx != rooty:\n            self.p[rooty] = rootx\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        ans = \\\"\\\"   \n        dict_components = collections.defaultdict(list)\n        N = len(s)\n        dus = DUS(N)\n        \n        for x, y in pairs: \n            dus.union(x, y)\n\n        for i in range(len(s)):\n            dict_components[dus.find(i)].append(s[i])\n            \n        for comp_id in dict_components.keys():\n            dict_components[comp_id].sort()\n\n            \n        for i in range(len(s)):\n            char = dict_components[dus.find(i)].pop(0)\n            ans = ans + char\n        \n        return ans\n            \n      \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n        ", "from collections import defaultdict\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self,n):\n                self.p = list(range(n))\n            def union(self,x,y):\n                self.p[self.find(x)] = self.find(y)\n            def find(self,i):\n                if self.p[i] != i:\n                    self.p[i] = self.find(self.p[i])\n                return self.p[i]\n            \n        uf = UF(len(s))\n        m = defaultdict(list)\n        res = []\n        \n        for x,y in pairs:\n            uf.union(x,y)\n        for i in range(len(s)):\n            m[uf.find(i)].append(s[i])\n        for key_name in list(m.keys()):\n            m[key_name].sort(reverse=True)\n        for i in range(len(s)):\n            res.append(m[uf.find(i)].pop())\n        return ''.join(res)\n                \n                \n                \n            \n                \n", "class DUS:\n    def __init__(self, N):\n        self.N = N\n        self.p = [i for i in range(self.N)]\n    \n    def find(self, x):\n        if self.p[x] != x:\n            self.p[x] = self.find(self.p[x])\n        return self.p[x] \n\n    def union(self, x, y):\n        rootx = self.find(x)\n        rooty = self.find(y)\n        if rootx != rooty:\n            self.p[rooty] = rootx\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        ans = \\\"\\\"   \n        dict_components = collections.defaultdict(list)\n        N = len(s)\n        dus = DUS(N)\n        \n        for x, y in pairs: \n            dus.union(x, y)\n\n        for i in range(len(s)):\n            dict_components[dus.find(i)].append(s[i])\n            \n        for comp_id in dict_components.keys():\n            dict_components[comp_id].sort()\n\n            \n        for i in range(len(s)):\n            char = dict_components[dus.find(i)].pop(0)\n            ans += char\n        \n        return ans\n            \n      \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n            \n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        def find(x):\n            parent.setdefault(x,x)\n            if x!=parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x,y):\n            px = find(x)\n            py = find(y)\n            parent[px] = py\n            \n        \n        parent = dict()\n        \n        \n        for i,j in pairs:\n            # if i==j:\n            #     continue\n            x = i\n            y = j\n            px = find(x)\n            py = find(y)\n            if px!=py:\n                union(x,y)\n        \n        graph = collections.defaultdict(list)\n        \n        for i in range(len(s)):\n            px = find(i)\n            heapq.heappush(graph[px],s[i])\n           \n  \n        res = ''\n        mem = collections.defaultdict(int)\n        for i in range(len(s)):\n            px = find(i)\n            res += heapq.heappop(graph[px])\n        return res\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        par = {i:i for i in range(len(s))}\n        def find(x):\n            if par[x] != x:\n                par[x] = find(par[x])\n            return par[x]\n        def union(x,y):\n            rx, ry = find(x), find(y)\n            if rx != ry:\n                par[rx] = ry\n        for x,y in pairs:\n            union(x,y)\n        \n        group2chars = defaultdict(list)\n        for idx, char in enumerate(s):\n            gid = find(idx)\n            group2chars[gid].append(char) # collect chars for each group (connected component)\n        for gid in group2chars:\n            group2chars[gid].sort(reverse=True) # sort the chars (in reverse order) in one connected component\n        \n        outstr = ''\n        for idx, char in enumerate(s):\n            gid = find(idx)\n            outchar = group2chars[gid].pop() # pop from the order of a to z (since sorted in a reverse way)\n            outstr += outchar\n        return outstr\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self, n): self.p = list(range(n))\n            def union(self, x, y): self.p[self.find(x)] = self.find(y)\n            def find(self, x):\n                if x != self.p[x]: self.p[x] = self.find(self.p[x])\n                return self.p[x]\n        uf, res, m = UF(len(s)), [], defaultdict(list)\n        for x,y in pairs: \n            uf.union(x,y)\n        for i in range(len(s)): \n            m[uf.find(i)].append(s[i])\n        for comp_id in list(m.keys()): \n            m[comp_id].sort()\n        print(m)\n        for i in range(len(s)): \n            res.append(m[uf.find(i)].pop(0))\n        return ''.join(res)\n\n", "from collections import defaultdict\nfrom typing import List\n\n\nclass DSU:\n    def __init__(self):\n        self.parent = {}\n        self.size = {}\n\n    def make_set(self, val):\n        self.parent[val] = val\n        self.size[val] = 1\n\n    def get_parent(self, val):\n        if self.parent[val] == val:\n            return val\n        parent = self.get_parent(self.parent[val])\n        self.parent[val] = parent\n        return parent\n\n    def union(self, val1, val2):\n        parent1 = self.get_parent(val1)\n        parent2 = self.get_parent(val2)\n\n        if parent1 != parent2 and self.size[parent1] >= self.size[parent2]:\n            self.parent[parent2] = parent1\n            self.size[parent1] += self.size[parent2]\n        elif parent1 != parent2 and self.size[parent1] < self.size[parent2]:\n            self.parent[parent1] = parent2\n            self.size[parent2] += self.size[parent1]\n\n        return True\n\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        dsu = DSU()\n        #   create set for every letter\n        for i in range(len(s)):\n            dsu.make_set(i)\n\n        #   union connected letters\n        for x, y in pairs:\n            dsu.union(x, y)\n\n        m = defaultdict(list)\n        #   map dsu parent to list of valid letters\n        for i in range(len(s)):\n            parent = dsu.get_parent(i)\n            m[parent].append(s[i])\n\n        #   sort lists of strings\n        for key, list_val in m.items():\n            m[key] = sorted(list_val)\n\n        res = []\n        for j in range(len(s)):\n            parent = dsu.get_parent(j)\n            smallest_letter = m[parent].pop(0)\n            res.append(smallest_letter)\n\n        return ''.join(res)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        graph = defaultdict(list)\n        visited = [False]*len(s)\n        out = [None]*len(s)\n\n        for u, v in pairs:\n            graph[u].append(v)\n            graph[v].append(u)\n\n\n        def dfs(i, stash):\n            visited[i] = True\n            stash.append(i)\n\n            for vertice in graph[i]:\n                if not visited[vertice]:\n                    stash = dfs(vertice, stash)\n            return stash\n\n        for i in range(len(s)):\n            if not visited[i]:\n\n                indices = sorted(dfs(i, []))\n                letters = sorted([s[i] for i in indices])\n\n                for j in range(len(indices)):\n                    out[indices[j]] = letters[j]\n\n                # print(out)\n        return ''.join(out)\n", "import collections\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        self.uf_table = [idx for idx in range(len(s))]\n        def find(p):\n            if p != self.uf_table[p]:\n                self.uf_table[p] = find(self.uf_table[p])\n            return self.uf_table[p]\n        \n        for p, q in pairs:\n            rp = find(p)\n            rq = find(q)\n            if rp != rq:\n                self.uf_table[rp] = rq\n                \n        conn = collections.defaultdict(list)\n        for idx, p in enumerate(self.uf_table):\n            conn[find(p)].append(s[idx])\n        for k, v in conn.items():\n            conn[k] = sorted(v)\n        result = []\n        for idx in range(len(s)):\n            result.append(conn[find(idx)].pop(0))\n        \n        return ''.join(result)", "\n        \nclass UF(object):\n    \n    def __init__(self):\n        self.parent = [i for i in range(100001)]\n        self.rank = [0]*100001\n        \n    def find(self, x):\n        if self.parent[x] != x: \n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        setx, sety = self.find(x), self.find(y)\n        if setx == sety: return False\n        elif self.rank[setx] < self.rank[sety]:\n            self.parent[setx] = sety\n        elif self.rank[sety] < self.rank[setx]:\n            self.parent[sety] = setx\n        else: \n            self.parent[sety] = setx\n            self.rank[setx] += 1\n        return True \n\nclass Solution(object):\n    def smallestStringWithSwaps(self, s, pairs):\n        \\\"\\\"\\\"\n        :type s: str\n        :type pairs: List[List[int]]\n        :rtype: str\n        \\\"\\\"\\\"\n        u, graph, groups, res = UF(), collections.defaultdict(int), collections.defaultdict(list), []\n        for x, y in pairs: \n            u.union(x, y)\n        for i in range(len(s)):\n            groups[u.find(i)].append(s[i])\n            graph[i] = u.find(i)\n        print(groups)\n        print(graph)\n        for k in groups.keys():\n            groups[k] = collections.deque(sorted(groups[k]))\n        return \\\"\\\".join([groups[graph[i]].popleft() for i in range(len(s))]) \n            \n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self, n): \n                self.p = list(range(n))\n            def union(self, x, y): \n                self.p[self.find(x)] = self.find(y)\n            def find(self, x):\n                if x != self.p[x]: \n                    self.p[x] = self.find(self.p[x])\n                return self.p[x]\n        uf, res, m = UF(len(s)), [], defaultdict(list)\n        for x,y in pairs: \n            uf.union(x,y)\n        for i in range(len(s)): \n            m[uf.find(i)].append(s[i])\n        for comp_id in m.keys(): \n            m[comp_id].sort(reverse=True)\n        for i in range(len(s)): \n            res.append(m[uf.find(i)].pop())\n        return ''.join(res)  ", "class DSU:\n    \n    def __init__(self, n):\n        self.parent = list(range(n))\n\n    def getP(self, i):\n        if self.parent[i] != i:\n            self.parent[i] = self.getP(self.parent[i])\n            return self.parent[i]\n        else:\n            return i\n\n    def rewrire(self):\n        tops = set()\n        for i in range(len(self.parent)):\n            if i != self.parent[i]:\n                self.parent[i] = self.getP(i)\n    \n    def merge(self, a, b):\n        pa, pb = self.getP(a), self.getP(b)\n        if pa == pb: return\n        if pa < pb:\n            self.parent[pb] = pa\n        else:\n            self.parent[pa] = pb\n\n    def connect(self, xs):\n        for a, b in xs:\n            self.merge(a, b)\n\n        self.rewrire()\n        \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        uf = DSU(n)\n        uf.connect(pairs)\n        \n        group = defaultdict(list)\n        for i, pindex in enumerate(uf.parent):\n            group[pindex].append((s[i], i))\n            \n        r = [None] * n\n        \n        for gk, gv in list(group.items()):\n            cxs = []\n            ixs = []\n            for c, index in gv:\n                cxs.append(c)\n                ixs.append(index)\n            \n            cxs.sort()\n            ixs.sort()\n            \n            for i in range(len(ixs)):\n                r[ixs[i]] = cxs[i]\n        \n        \n        return ''.join(r)\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n=len(s)\n        m=len(pairs)\n        \n        ## If string length is 1 or less, or if there are no swappable pairs, return original string\n        if n<=1 or m==0: return s\n        \n        ## Parent array for storing group parent ids in union find\n        ## For each node, traversing upward would lead to the group leader.\n        ## All connected indices share the same group leader\n        parent= [i for i in range(n) ] \n        \n        ## Returns the group leader index for the given index\n        def find(i):\n            pi = parent[i]\n            while parent[pi] != pi :\n                pi = parent[pi]\n            parent[i] = pi\n            return parent[i]\n        \n        ## Merges two indices into same group\n        def union(i,j):\n            pi=find(i)\n            pj=find(j)\n            if pi!=pj:\n                parent[pj]=pi\n        \n        for index1,index2 in pairs:\n            union(index1,index2)\n\n        ## Forming groups or connected components\n        groups={}\n        for index in range(n):\n            leader = find(index)\n            groups[leader] = groups.get(leader,[])\n            groups[leader].append(s[index])\n\n        for leader in groups.keys():\n            groups[leader].sort()\n\n        group_index={}\n        result=''\n        for index in range(n):\n            leader=find(index)\n            group_index[leader]=group_index.get(leader,0)+1\n            result+=groups[leader][group_index[leader]-1]\n        return result", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n=len(s)\n        m=len(pairs)\n        \n        ## If string length is 1 or less, or if there are no swappable pairs, return original string\n        if n<=1 or m==0: return s\n        \n        ## Parent array for storing group parent ids in union find\n        ## For each node, traversing upward would lead to the group leader.\n        ## All connected indices share the same group leader\n        parent= [i for i in range(n) ] \n        \n        ## Returns the group leader index for the given index\n        def find(i):\n            pi = parent[i]\n            while parent[pi] != pi :\n                pi = parent[pi]\n            parent[i] = pi\n            return parent[i]\n        \n        ## Merges two indices into same group\n        def union(i,j):\n            pi=find(i)\n            pj=find(j)\n            if pi!=pj:\n                parent[pj]=pi\n        \n        for index1,index2 in pairs:\n            union(index1,index2)\n\n        ## Forming groups or connected components\n        groups={}\n        for index in range(n):\n            leader = find(index)\n            groups[leader] = groups.get(leader,[])\n            groups[leader].append(s[index])\n\n        for leader in groups.keys():\n            groups[leader].sort()\n\n        group_index={}\n        result=''\n        for index in range(n):\n            leader=find(index)\n            group_index[leader]=group_index.get(leader,0)+1\n            result+=groups[leader][group_index[leader]-1]\n        return result     ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        parent = [i for i in range(n)]\n        def find(i):\n            if not i ==parent[i]:\n                parent[i]=find(parent[i])\n            return parent[i]    \n        def union(i, j):\n            a = find(i)\n            b = find(j)\n            parent[a] = b\n        for i, j in pairs:\n            union(i, j)\n        memo = collections.defaultdict(list)\n        for i in range(n):\n            memo[find(i)].append(s[i])\n        for k in memo.keys():\n            memo[k].sort(reverse=True)\n        res = []\n        for i in range(n):\n            res.append(memo[find(i)].pop())\n        return \\\"\\\".join(res) ", "from collections import defaultdict\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        p = list(range(len(s)))\n        d = defaultdict(list)\n        def find(x):\n            if p[x]!=x:\n                p[x]=find(p[x])\n            return p[x]\n        def union(x,y):\n            x,y = find(x),find(y)\n            p[x]=y\n            return p[x] \n        for a,b in pairs:\n            union(a,b)\n        for i in range(len(s)):\n            d[find(i)].append(s[i])\n        for x in d:\n            d[find(x)].sort(reverse=True)\n        ret=''\n        for i in range(len(s)):\n            ret+=d[find(i)].pop()\n        return ret", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        from collections import defaultdict\n        n = len(s)\n        roots = list(range(n))\n        sizes = [1]*n\n        \n        def find(node):\n            root = node\n            while root != roots[root]:\n                root = roots[root]\n                \n            while node != root:\n                next_node = roots[node]\n                roots[node] = root\n                node = next_node\n            \n            return root\n        \n        def union(node1, node2):\n            root1, root2 = find(node1), find(node2)\n            \n            if root1 == root2:\n                return False\n            \n            if sizes[root2] > sizes[root1]:\n                root1, root2 = root2, root1\n            \n            sizes[root1] += sizes[root2]\n            roots[root2] = root1\n            \n        for x,y in pairs:\n            union(x, y)\n        \n        for i in range(n):\n            find(i)\n        \n        indices = defaultdict(lambda: [])\n        chars = defaultdict(lambda: [])\n        for i, root in enumerate(roots):\n            c = s[i]\n            indices[root].append(i)\n            chars[root].append(c)\n        \n        result = [0]*n\n        for key in indices.keys():\n            for i, v in zip(indices[key], sorted(chars[key])):\n                result[i] = v\n                \n        return \\\"\\\".join(result)\n        \n        \n                ", "class UnionFind:\n    \n    def __init__(self, n):\n        self.reps = [i for i in range(n)]\n    \n    def find(self, x):\n        while x != self.reps[x]:\n            self.reps[x] = self.reps[self.reps[x]]\n            x = self.reps[x]\n        return x\n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            self.reps[x_root] = y_root\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        uf = UnionFind(len(s))\n        \n        for i, j in pairs:\n            uf.union(i, j)\n            \n        mp = collections.defaultdict(list)\n        \n        for i in range(len(s)):\n            mp[uf.find(i)].append(s[i])\n            \n        for comp_id in mp.keys(): \n            mp[comp_id].sort(reverse=True)\n        \n        \n        ret = []\n        for i in range(len(s)): \n            ret.append(mp[uf.find(i)].pop())\n        return \\\"\\\".join(ret)\n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        p = {}\n\n        def getP(i: int) -> int:\n            if i not in p:\n                return -1\n            return i if p[i] == i else getP(p[i])\n\n        uf = {}\n        index = 0\n        for (x, y) in pairs:\n            px = getP(x)\n            py = getP(y)\n            if px == -1 and py == -1:\n                p[x] = min(x, y)\n                p[y] = min(x, y)\n                uf[min(x, y)] = pairs[index]\n            elif px == -1:\n                uf[py].append(x)\n                p[x] = py\n            elif py == -1:\n                uf[px].append(y)\n                p[y] = px\n            elif px != py:\n                p[px] = min(px, py)\n                p[py] = min(px, py)\n                uf[min(px, py)] += uf.pop(max(px, py))\n            index += 1\n        ans = list(s)\n        for k in list(uf.keys()):\n            st = sorted(set(uf[k]))\n            tmp = [s[i] for i in st]\n            tmp.sort()\n            idx = 0\n            for i in st:\n                ans[i] = tmp[idx]\n                idx += 1\n        return ''.join(ans)\n", "from typing import List\n\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        # build graph\n        g = [[] for _ in range(len(s))]\n        for edge in pairs:\n            g[edge[0]].append(edge[1])\n            g[edge[1]].append(edge[0])  # bug: \u61c9\u70ba indirected graph\n\n        # DFS, find components\n        visited = set()\n\n        def f(i):  # fulfill idexes and chars\n            if i in visited:\n                return\n            else:\n                visited.add(i)\n\n            # visit\n            idxes.append(i)\n            chars.append(s[i])\n\n            for adj in g[i]:\n                f(adj)\n\n        ans = [''] * len(s)\n        for i in range(len(s)):\n            if i in visited:\n                continue\n            idxes = []\n            chars = []\n            f(i)\n\n            # sort each components\n            idxes.sort()\n            chars.sort()\n\n            for j in range(len(chars)):\n                ans[idxes[j]] = chars[j]\n\n        return ''.join(ans)\n\n\n", "from collections import defaultdict\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        p=list(range(len(s)))\n        d=defaultdict(list)\n        def find(x):\n            if p[x]!=x:\n                p[x]=find(p[x])\n            return p[x]\n        def union(x,y):\n            x,y = find(x),find(y)\n            if x==y:\n                return False\n            p[x]=y\n            return p[x]\n        for a,b in pairs:\n            union(a,b)\n        for i in range(len(p)):\n            d[find(i)].append(s[i])\n        for x in d:\n            d[find(x)].sort(reverse=True)\n        ret=''\n        for i in range(len(s)):\n            ret+=d[find(i)].pop()\n        return ret\n", "import collections\nimport functools\nimport heapq\nimport itertools\nimport sys\nfrom functools import lru_cache\nfrom typing import List\nfrom fractions import gcd\n\n'''\n\u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32\u00a0s\uff0c\u4ee5\u53ca\u8be5\u5b57\u7b26\u4e32\u4e2d\u7684\u4e00\u4e9b\u300c\u7d22\u5f15\u5bf9\u300d\u6570\u7ec4\u00a0pairs\uff0c\u5176\u4e2d\u00a0pairs[i] =\u00a0[a, b]\u00a0\u8868\u793a\u5b57\u7b26\u4e32\u4e2d\u7684\u4e24\u4e2a\u7d22\u5f15\uff08\u7f16\u53f7\u4ece 0 \u5f00\u59cb\uff09\u3002\n\u4f60\u53ef\u4ee5 \u4efb\u610f\u591a\u6b21\u4ea4\u6362 \u5728\u00a0pairs\u00a0\u4e2d\u4efb\u610f\u4e00\u5bf9\u7d22\u5f15\u5904\u7684\u5b57\u7b26\u3002\n\u8fd4\u56de\u5728\u7ecf\u8fc7\u82e5\u5e72\u6b21\u4ea4\u6362\u540e\uff0cs\u00a0\u53ef\u4ee5\u53d8\u6210\u7684\u6309\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u5b57\u7b26\u4e32\u3002\n\n\u6ce8\u610f\u8fd9\u4e0d\u662f\u4e00\u9053dfs\u6216bfs\u9898\u3002\n\n\u5982\u679c\u4e24\u4e2a\u4f4d\u7f6e\u53ef\u4ee5\u4efb\u610f\u4ea4\u6362\uff0c\u5219\u4e24\u4e2a\u4f4d\u7f6e\u6392\u5e8f\u5373\u53ef\u3002\n\n\u5982\u679c(1,2), (2,3), \u52191 2 3\u4f4d\u7f6e\u6392\u5e8f\u5373\u53ef\u3002\n\n\u6240\u4ee5\u95ee\u9898\u662f\u627e\u5230\u5e76\u67e5\u96c6, \u7136\u540e\u76f4\u63a5\u6392\u5e8f\u5373\u53ef\u3002\n'''\n\n\nclass UFSet:\n    def __init__(self, n):\n        self.dp = [-1 for _ in range(n)]\n\n    def find(self, x):\n        if self.dp[x] < 0:\n            return x\n        self.dp[x] = self.find(self.dp[x])\n        return self.dp[x]\n\n    def union(self, x, y):\n        root_x, root_y = self.find(x), self.find(y)\n        if root_x == root_y: return\n        self.dp[root_x] += self.dp[root_y]\n        self.dp[root_y] = root_x\n\n    def get_group(self):\n        ret = collections.defaultdict(list)\n        for i in range(len(self.dp)):\n            ret[self.find(i)].append(i)\n        return ret\n\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        ufs = UFSet(n)\n        for i, j in pairs:\n            ufs.union(i, j)\n        group_map = ufs.get_group()\n        ret = [i for i in s]\n        for group in list(group_map.values()):\n            sort_group = sorted([s[i] for i in group])\n            for i, j in zip(group, sort_group):\n                ret[i] = j\n        return ''.join(ret)\n\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        root = { i:i for i in range(n) }\n        \n        def find(i): # path compression\n            if root[i] != i:\n                root[i] = find(root[i])\n            return root[i]\n            \n            \n        def union(i,j):\n            ri = find(i)\n            rj = find(j)\n            if ri != rj:\n                # root[j] = root[i]\n                root[ri] = root[rj] # root(rj)\n            return\n        \n        for i,j in pairs:\n            union(i,j)\n        \n        d = collections.defaultdict( list )\n        for i in range(n):\n            d[find(i)].append(i)\n        \n        print(root)\n        \n        res = list(s)\n        for k in d:\n            tmp = sorted([s[i] for i in d[k]])\n            for i in range(len(tmp)):\n                res[ d[k][i] ] = tmp[i]\n        \n        return \\\"\\\".join(res)\n        \n        \n        \n        \n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        parent = [i for i in range(n)]\n        \n        for u, v in pairs:\n            self.union(parent, u, v)\n        \n        m = collections.defaultdict(list)\n        for i in range(n):\n            m[self.find_root(parent, i)].append(i)\n        \n        ans = list(s)\n        for _, indices in m.items():\n            temp = []\n            for i in indices:\n                temp.append(s[i])\n            temp.sort()\n            for i in range(len(temp)):\n                ans[indices[i]] = temp[i]\n        \n        return \\\"\\\".join(ans)\n    \n    def find_root(self, parent, x):\n        if parent[x] != x:\n            parent[x] = self.find_root(parent, parent[x])\n        return parent[x]\n    \n    def union(self, parent, x, y):\n        x_root = self.find_root(parent, x)\n        y_root = self.find_root(parent, y)\n        if x_root != y_root:\n            parent[x_root] = y_root", "class UnionFind():\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n    \n    def find(self,A):\n        root = A\n        \n        while root != self.parent[root]:\n            root = self.parent[root]\n        \n        while A!=root:\n            old_parent = self.parent[A]\n            self.parent[A] = root\n            A = old_parent\n        return root\n    \n        \n    def union(self,A,B):\n        root_A = self.find(A)\n        root_B = self.find(B)\n        \n        if self.size[root_A]>self.size[root_B]:           \n            self.parent[root_B] = root_A\n            self.size[root_A] += self.size[root_B]\n        else:\n            self.parent[root_A] = root_B\n            self.size[root_B] += self.size[root_A]\n            \n        \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        uf = UnionFind(len(s))\n        d = collections.defaultdict(list)\n        res = []\n        \n        for i,j in pairs:\n            uf.union(i,j)\n        \n        for i in range(len(s)):\n            d[uf.find(i)].append(s[i])\n        \n        for parent in d:\n            d[parent].sort(reverse = True)\n        \n        for i in range(len(s)):\n            res.append(d[uf.find(i)].pop())\n            \n        return \\\"\\\".join(res)\n            \n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        uf = UF(n)\n        for pair in pairs:\n            uf.union(pair[0], pair[1])\n        \n        groups = collections.defaultdict(list)\n        for i in range(n):\n            r = uf.root(i)\n            groups[r].append(i)\n        \n        res = ['' for _ in range(n)]\n        for r, group in list(groups.items()):\n            if len(group) == 1:\n                res[r] = (s[group[0]])\n            else:\n                temp = [s[i] for i in group]\n                temp.sort()\n                for index, idx in enumerate(sorted(group)):\n                    res[idx] = temp[index]\n        return ''.join(res)\n    \nclass UF:\n    def __init__(self, n):\n        self.parents = list(range(n))\n    \n    def find(self, x):\n        if x != self.parents[x]:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n    \n    def union(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if px != py:\n            self.parents[px] = py\n    \n    def root(self, x):\n        return self.find(x)\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class DSU:\n            def __init__(self,n):\n                self.n = n\n                self.l = [i for i in range(n)]\n            def get(self,c):\n                if self.l[c] != c:\n                    self.l[c] = self.get(self.l[c])\n                return self.l[c]\n            def merge(self,c,d):\n                t1 = self.get(c)\n                t2 = self.get(d)\n                self.l[t1] = t2\n                \n        g = DSU(len(s))\n        for a,b in pairs:\n            g.merge(a,b)\n        \n        res = {}\n        for i,c in enumerate(s):\n            cl = g.get(i)\n            if cl in res:\n                res[cl][0].append(i)\n                res[cl][1].append(c)\n            else:\n                res[cl] = [[i],[c]]\n        \n        result = ['']*len(s)\n        for cl in res:\n            l = sorted(res[cl][1],reverse=True)\n            for i in res[cl][0]:\n                result[i] = l.pop()\n        return \\\"\\\".join(result)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        parents = [i for i in range(len(s))]\n        ranks = [1 for _ in range(len(s))]\n        components = collections.defaultdict(list)\n        def find(x):\n            while x != parents[x]:\n                parents[x] = parents[parents[x]]\n                x = parents[x]\n            return x\n        def union(x, y):\n            px, py = find(x), find(y)\n            if px == py:\n                return False\n            if ranks[px] > ranks[py]:\n                parents[py] = px\n            elif ranks[px] < ranks[py]:\n                parents[px] = py\n            else:\n                parents[py] = px\n                ranks[px] += 1\n            return True\n        for a, b in pairs:\n            union(a, b)\n        for i in range(len(parents)):\n            components[find(i)].append(s[i])\n        for comp_id in components:\n            components[comp_id].sort(reverse=True)\n        res = ''\n        for i in range(len(s)):\n            res += components[find(i)].pop()\n        return res", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        s = list(s)\n        graph = [[] for _ in range(len(s))]\n        for u,v in pairs:\n            graph[u].append(v)\n            graph[v].append(u)\n        stack = []\n        vis = [False]*len(s)\n        self.res = \\\"\\\"\n        self.index = []\n        def dfs(graph,u):\n            vis[u] = True\n            self.res += s[u]\n            self.index.append(u)\n            for v in graph[u]:\n                if not vis[v]:\n                    dfs(graph,v)\n        for i in range(len(graph)):\n            if not vis[i]:\n                self.res = \\\"\\\"\n                self.index = []\n                dfs(graph,i)\n                self.index.sort()\n                self.res = sorted(list(self.res))\n                for i in range(len(self.index)):\n                    s[self.index[i]] = self.res[i]\n        return ''.join(s)\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        def find(x):\n            if x!=parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x,y):\n            px = find(x)\n            py = find(y)\n            parent[px] = py\n            \n        parent = list(range(len(s)+1))\n        \n        for x,y in pairs:\n            px = find(x)\n            py = find(y)\n            if px!=py:\n                union(x,y)\n        \n        graph = collections.defaultdict(list)\n        \n        for i in range(len(s)):\n            px = find(i)\n            heapq.heappush(graph[px],s[i]) # We are using priority queue to keep track of the lexicographical ordering\n        \n        res = ''\n        for i in range(len(s)):\n            px = find(i)\n            res += heapq.heappop(graph[px])\n        return res", "from collections import defaultdict\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        s = list(s)\n        graph = [[] for _ in range(len(s))]\n        for u,v in pairs:\n            graph[u].append(v)\n            graph[v].append(u)\n        stack = []\n        vis = [False]*len(s)\n        self.res = \\\"\\\"\n        self.index = []\n        def dfs(graph,u):\n            vis[u] = True\n            self.res += s[u]\n            self.index.append(u)\n            for v in graph[u]:\n                if not vis[v]:\n                    dfs(graph,v)\n        for i in range(len(graph)):\n            if not vis[i]:\n                self.res = \\\"\\\"\n                self.index = []\n                dfs(graph,i)\n                self.index.sort()\n                self.res = sorted(list(self.res))\n                for i in range(len(self.index)):\n                    s[self.index[i]] = self.res[i]\n        return ''.join(s)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        graph = dict()\n        for i in range(len(s)):\n            graph[i]=set()\n            \n        for pair in pairs:\n            fro = pair[0]\n            to = pair[1]\n            graph[fro].add(to)\n            graph[to].add(fro)\n            \n        def dfs(node, graph,explored,s,path):\n            path.append(node)\n            explored[node]=True\n            string = s[node]\n            \n            for neighbour in graph[node]:\n                if not explored[neighbour]:\n                    res = dfs(neighbour,graph,explored,s,path)\n                    string+=res[0]\n                    \n            return (string,path)\n        \n        connected=[]\n        explored = [False]*len(s)\n        \n        for node in graph:\n            if not explored[node]:\n                connected.append(dfs(node,graph,explored,s,[]))\n                \n                \n            \n        stringList = [\\\"\\\"]*len(s)\n        \n        for conn in connected:\n            st = \\\"\\\".join(sorted(conn[0]))\n            path = sorted(conn[1])\n            \n            for i in range(len(st)):\n                char = st[i]\n                ind = path[i]\n                stringList[ind]=char\n                \n        return \\\"\\\".join(stringList)\n                \n            \n        \n                \n        \n                \n            ", "class DSU:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        xroot, yroot = self.find(x), self.find(y)\n        if xroot != yroot:\n            self.parent[yroot] = xroot\n            \n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        dsu = DSU(n)\n        ans = []\n        m = collections.defaultdict(list)\n        \n        for i, j in pairs:\n            dsu.union(i, j)\n        \n        for i in range(n):\n            m[dsu.find(i)].append(s[i])\n        \n        for key in list(m.keys()):\n            m[key].sort(reverse = True)\n            \n        for i in range(n):\n            ans.append(m[dsu.find(i)].pop())\n        \n        return ''.join(ans)\n        \n", "from collections import defaultdict\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self, s): self.p = [i for i in range(len(s))]\n\n            def union(self, x, y): self.p[self.find(x)] = self.find(y)\n\n            def find(self, x):\n                if x != self.p[x]: self.p[x] = self.find(self.p[x])\n                return self.p[x]\n        res, cc, uf = [], defaultdict(list), UF(s)\n        for x, y in pairs:\n            uf.union(x, y)\n        for i, c in enumerate(s):\n            cc[uf.find(i)].append(c)\n        for cc_id in cc.keys():\n            cc[cc_id].sort(reverse=True)\n        for i in range(len(s)):\n            res.append(cc[uf.find(i)].pop())\n        return ''.join(res)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self, n): self.p = list(range(n))\n            def union(self, x, y): self.p[self.find(x)] = self.find(y)\n            def find(self, x):\n                if x != self.p[x]: self.p[x] = self.find(self.p[x])\n                return self.p[x]\n        uf, res, m = UF(len(s)), [], defaultdict(list)\n        for x,y in pairs: \n            uf.union(x,y)\n        for i in range(len(s)): \n            m[uf.find(i)].append(s[i])\n        for comp_id in m.keys(): \n            m[comp_id].sort(reverse=True)\n        for i in range(len(s)): \n            res.append(m[uf.find(i)].pop())\n        return ''.join(res)", "from collections import defaultdict\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n#         def find(uf, node):        \n#             if uf[node] != node:\n#                 return find(uf, uf[node])\n                \n#             return node\n            \n#         def union(uf, node1, node2):\n#             uf[find(uf, node1)] = find(uf, node2)\n            \n#         uf = list(range(len(s)))\n        \n#         if not pairs:\n#             return s\n        \n#         for pair in pairs:\n#             union(uf, pair[0], pair[1])\n        \n#         groups = defaultdict(list)\n        \n#         for i in range(len(s)):\n#             groups[find(uf, i)].append(s[i])\n                        \n#         for group in groups:\n#             groups[group].sort(reverse=True)\n        \n#         res = []\n\n#         for i in range(len(s)):\n#             res.append(groups[find(uf, i)].pop())\n            \n#         return ''.join(res)\n    \n        class UF:\n            def __init__(self, n): self.p = list(range(n))\n            def union(self, x, y): self.p[self.find(x)] = self.find(y)\n            def find(self, x):\n                if x != self.p[x]: self.p[x] = self.find(self.p[x])\n                return self.p[x]\n        uf, res, m = UF(len(s)), [], defaultdict(list)\n        for x,y in pairs: \n            uf.union(x,y)\n        for i in range(len(s)): \n            m[uf.find(i)].append(s[i])\n        for comp_id in list(m.keys()): \n            m[comp_id].sort(reverse=True)\n        for i in range(len(s)): \n            res.append(m[uf.find(i)].pop())\n        return ''.join(res)\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self,n):\n                self.p=list(range(n))\n            def find(self,x):\n                if x!=self.p[x]:\n                    self.p[x]=self.find(self.p[x])\n                return self.p[x]\n            def union(self,x,y):\n                self.p[self.find(x)]=self.find(y)\n        d=defaultdict(list)\n        uf=UF(len(s))\n        ans=[]\n        for x,y in pairs:\n            uf.union(x,y)\n        for i in range(len(s)):\n            d[uf.find(i)].append(s[i])\n        for key in d:\n            d[key].sort(reverse=True)\n        for i in range(len(s)):\n            ans.append(d[uf.find(i)].pop())\n        return \\\"\\\".join(ans)\n    ", "class DSU:\n    \n    def __init__(self, N):\n        self.par = list(range(N))\n        self.sz = [1] * N\n    \n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return False\n        if self.sz[x] < self.sz[y]:\n            x, y = y, x\n        self.sz[x] += self.sz[y]\n        self.par[y] = x\n        return True\n    \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        N = len(s)\n        dsu = DSU(N)\n        for a, b in pairs:\n            dsu.union(a, b)\n        s = list(s)\n        components = [[] for i in range(N)]\n        for i in range(N):\n            components[dsu.find(i)].append(i)\n        for i in range(N):\n            chars = [s[j] for j in components[i]]\n            chars.sort()\n            for j, v in enumerate(components[i]):\n                s[v] = chars[j]\n        \n        return \\\"\\\".join(s)\n        ", "class UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n    \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        N = len(s)\n        if N < 2: return s\n        uf = UnionFind(N)\n        for pair in pairs:\n            uf.union(pair[0],pair[1])\n        \n        dict = defaultdict(list)\n        for i in range(N):\n            r = uf.find(i)\n            dict[r].append(i)\n            \n        res = [' ']*N\n        for lst in list(dict.values()):            \n            subs = []\n            for idx in lst:\n                subs.append(s[idx])\n            subs.sort()\n            i2 = 0\n            for idx in lst:\n                res[idx]=subs[i2]\n                i2+=1\n        return ''.join(res)\n            \n        \n        \n            \n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        dd = {x:x for x in [i for v in pairs for i in v]}\n        \n        def merge(x,y):\n            x,y = find(x), find(y)\n            if x!=y:\n                dd[x] = y\n        \n        def find(x):\n            if dd[x] != x:\n                dd[x] = find(dd[x])\n            return dd[x]\n        \n        for i,x in pairs:\n            merge(i,x)\n            \n        agg = collections.defaultdict(list)\n        \n        for i in dd:\n            agg[find(i)].append(s[i])\n            \n        for i in agg:\n            agg[i] = sorted(agg[i], reverse = 1)\n            \n        s = list(s)\n        \n        for i in range(len(s)):\n            if i in dd:\n                s[i] = agg[find(i)].pop()\n        \n        return ''.join(s)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        edges = collections.defaultdict(list)\n        for p in pairs:\n            edges[p[0]].append(p[1])\n            edges[p[1]].append(p[0])\n            \n        # print(edges)\n        \n        ans = list(s)\n        seen = set()\n        for i,c in enumerate(s):\n            if i in seen: continue\n            seen.add(i)\n            h1,h2 = [],[]\n            frontier = [i]\n            while frontier:\n                cur = frontier.pop()\n                heapq.heappush(h1,cur)\n                heapq.heappush(h2,ans[cur])\n                for j in edges[cur]:\n                    # print(cur,j)\n                    if j not in seen:\n                        # print('New index')\n                        seen.add(j)\n                        frontier.append(j)\n            # print(f' Current-{cur}, h1-{h1}, h2-{h2}')\n            while h1: ans[heapq.heappop(h1)] = heapq.heappop(h2)\n        \n        return ''.join(ans)", "class DSU:\n    def __init__(self,n):\n        self.parent = [i for i in range(n)]\n        self.rank = [1 for i in range(n)]\n        self.count = n\n        \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self,x,y):\n        px = self.find(x)\n        py = self.find(y)\n        if px==py:\n            return\n        self.count-=1\n        if self.rank[px]>self.rank[py]:\n            self.parent[py] = px\n            self.rank[px]+=self.rank[py]\n        else:\n            self.parent[px]=py\n            self.rank[py]+=self.rank[x]\n        \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        dsu = DSU(n)\n         # [[0,3],[1,2],[0,2]]\n        for x,y in pairs:\n            dsu.union(x,y)\n        # [0,1,2,3]\n        \n        # Club everyone with the same parent\n        if dsu.count == 1:\n            return \\\"\\\".join(sorted(s))\n        hm = collections.defaultdict(list)\n        for i in range(n):\n            hm[dsu.find(i)].append(s[i])\n        for key in hm:\n            hm[key].sort(reverse=True)\n        res = []\n        for i in range(n):\n            res.append(hm[dsu.find(i)].pop())\n        return \\\"\\\".join(res)\n            \n        ", "from heapq import heappush, heappop\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def parent(a):\n            val, _ = d[a]\n            if val == a:\n                return a\n            return parent(val)\n        \n        def union(a, b):\n            parent1 = parent(a)\n            parent2 = parent(b)\n            \n            if parent1 == parent2:\n                return\n            \n            a, n1 = d[parent1]\n            b, n2 = d[parent2]\n            if n1 > n2:\n                d[b] = (a, n2)\n                d[a] = (a, n1 + n2)\n            else:\n                d[a] = (b, n1)\n                d[b] = (b, n1 + n2)\n                \n        d = [(i, 1) for i in range(len(s))]\n        for i, j in pairs:\n            union(i, j)\n        arrs = [[] for _ in range(len(s))]\n        for i in range(len(s)):\n            heappush(arrs[parent(i)], s[i])\n        sol = list()\n        for i in range(len(s)):\n            sol.append(heappop(arrs[parent(i)]))\n        return ''.join(sol)\n        \n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        res = list(s)\n        adj = defaultdict(set)\n        for a, b in pairs:\n            adj[a].add(b)\n            adj[b].add(a)\n            \n        while adj:\n            i = next(iter(adj))\n            v = []\n            self.dfs(i, adj, v)\n            v = sorted(v)\n            chars = sorted([s[i] for i in v])\n            for i, c in enumerate(chars):\n                res[v[i]] = c\n                \n        return ''.join(res)\n    \n    def dfs(self, i, adj, res):\n        if i in adj:\n            res.append(i)\n            for j in adj.pop(i):\n                self.dfs(j, adj, res)\n        \n                \n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def union(x, y):\n            graph[find(x)] = find(y)\n        \n        def find(x):\n            path = []\n            if x not in graph:\n                return x\n            while graph[x] != x:\n                path.append(x)\n                x = graph[x]\n            for n in path:\n                graph[n] = x\n            return x\n\n        graph = {}\n        \n        for u, v in pairs:\n            if u not in graph:\n                graph[u] = u\n            if v not in graph:\n                graph[v] = v\n            union(u, v)\n            \n        ans = []\n        comp = collections.defaultdict(list)\n        for i, c in enumerate(s):\n            comp[find(i)].append(c)\n        for v in comp.values():\n            v.sort(reverse=True)\n        for i in range(len(s)):\n            ans.append(comp[find(i)].pop())\n        return \\\"\\\".join(ans)", "class Solution:\n    # 21:50\n    \\\"\\\"\\\"\n    s = \\\"dcab\\\", pairs = [[0,3],[1,2],[0,2]]\n    dcab -[1, 2]->dacb\n    dacb -[0, 3]->bacd\n    not possible anymore\n    \\\"\\\"\\\"\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        res = list(s)\n        groups = self.groups(pairs, len(s))\n        for g in groups:\n            g = sorted(g)\n            chars = sorted([s[i] for i in g])\n            for i, c in enumerate(chars):\n                res[g[i]] = c\n                \n        return ''.join(res)\n    \n    def groups(self, pairs, n):\n        adj = collections.defaultdict(set)\n        for a, b in pairs:\n            adj[a].add(b)\n            adj[b].add(a)\n            \n        arr = []\n        while adj:\n            i = next(iter(adj))\n            v = []\n            self.dfs(i, adj, v)\n            arr.append(v)\n                \n        return arr\n    \n    def dfs(self, i, adj, res):\n        if i in adj:\n            res.append(i)\n            for j in adj.pop(i):\n                self.dfs(j, adj, res)\n        \n                \n        ", "from collections import defaultdict\n\nclass DisjointSet:\n    class Node:\n        def __init__(self, x):\n            self.val = x\n            self.parent = self\n            self.rank = 0\n            \n    def __init__(self, node_num):\n        self.val_to_node = {}\n        \n        for val in range(node_num):\n            self.val_to_node[val] = DisjointSet.Node(val)\n            \n    def find(self, x):\n        return self._find(self.val_to_node[x]).val\n    \n    def _find(self, node):\n        if node.parent is node:\n            return node\n        \n        node.parent = self._find(node.parent)\n        return node.parent\n    \n    def union(self, val1, val2):\n        root1 = self._find(self.val_to_node[val1])\n        root2 = self._find(self.val_to_node[val2])\n        \n        if root1 is root2:\n            return\n        \n        if root2.rank > root1.rank:\n            root1, root2 = root2, root1\n            \n        if root1.rank == root2.rank:\n            root1.rank += 1\n        \n        root2.parent = root1\n            \n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        if not pairs:\n            return s\n        \n        disjoint_set = DisjointSet(len(s))\n        \n        for u, v in pairs:\n            disjoint_set.union(u, v)\n        \n        connected_components = defaultdict(list)\n        \n        for i in range(len(s)):\n            connected_components[disjoint_set.find(i)].append(i)\n        \n        res = [None] * len(s)\n        for group in list(connected_components.values()):\n            sorted_chars = sorted([s[i] for i in group])\n            \n            for idx, s_i in enumerate(sorted(group)):\n                res[s_i] = sorted_chars[idx]\n                \n        return ''.join(res)\n", "class Solution:\n    # 21:50\n    \\\"\\\"\\\"\n    s = \\\"dcab\\\", pairs = [[0,3],[1,2],[0,2]]\n    dcab -[1, 2]->dacb\n    dacb -[0, 3]->bacd\n    not possible anymore\n    \\\"\\\"\\\"\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        res = list(s)\n        groups = self.groups(pairs, len(s))\n        for g in groups:\n            g = sorted(g)\n            chars = sorted([s[i] for i in g])\n            for i, c in enumerate(chars):\n                res[g[i]] = c\n                \n        return ''.join(res)\n    \n    def groups(self, pairs, n):\n        adj = collections.defaultdict(set)\n        for p in pairs:\n            adj[p[0]].add(p[1])\n            adj[p[1]].add(p[0])\n            \n        arr = []\n        while adj:\n            i = next(iter(adj))\n            v = []\n            self.dfs(i, adj, v)\n            arr.append(v)\n                \n        return arr\n    \n    def dfs(self, i, adj, res):\n        if i in adj:\n            res.append(i)\n            for j in adj.pop(i):\n                self.dfs(j, adj, res)\n        \n                \n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        # create joined sets \n        # [0, 3] and [1, 2]\n        # [0, 3, 2, 1] = \\\"abcd\\\"\n        # a at position 0, b at 1 ...\n        # [0 1 2 3]\n        # [0 1 2 0]\n        # [0 1 1 0]\n        # [0 0 0 0]\n        # let the value at the index represent it's parent\n        # Create a set\n        parentList = [i for i in range(len(s))]\n        # letterList = [[] for i in range(len(s))]\n        def setRoot(parent, child):\n            if parentList[parent] == child or parentList[child] == parent:\n                return\n            if parentList[parent] > parentList[child]:\n                return setRoot(child, parent)\n            if parent == child:\n                return\n            childParent = parentList[child]\n            parentList[child] = parent\n            setRoot(parent, childParent)\n            \n        def findParent(child, i):\n            # if i == 0:\n                # print(child)\n            parent = parentList[child]\n            if child != parentList[child]:\n                parent = findParent(parentList[child], i+1)\n                parentList[child] = parent\n            return parent\n            \n        for pair in pairs:\n            # print(parentList)\n            # if parentList[pair[0]] < parentList[pair[1]]:\n            setRoot(pair[0], pair[1])\n            # else:\n            #     setRoot(pair[1], pair[0])\n        letterSets = {}\n        \n        # print(parentList)\n        for i in range(len(s)):\n            l = s[i]\n            parent = findParent(i, 0)\n            \n            entry = letterSets.get(parent, [[], []])\n            entry[0].append(l)\n            entry[1].append(i)\n            letterSets[parent] = entry\n        retList = ['a' for i in range(len(s))]\n        for _, entry in letterSets.items():\n            entry[0].sort()\n            entry[1].sort()\n            for i in range(len(entry[1])):\n                retList[entry[1][i]] = entry[0][i]\n        return \\\"\\\".join(retList)\n            \n            ", "par=[0]*(100005)\nrank=[1]*(100005)\n\ndef find(x):\n    if par[x]!=x:\n        par[x]=find(par[x])\n    return par[x]\ndef union(x,y):\n    xs = find(x)\n    ys = find(y)\n    if xs!=ys:\n        if rank[xs]<rank[ys]:\n            par[xs]=ys\n        elif rank[xs]>rank[ys]:\n            par[ys]=xs\n        else:\n            par[ys] = xs\n            rank[xs]+=1\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        for i in range(n+3):\n            rank[i]=1\n            par[i]=i\n        for i in pairs:\n            union(i[0],i[1])\n            #print(par[:5])\n        #print(par[:10])\n        poi=[0]*(n+3)\n        #a=[0]*(n+3)\n        for i in range(n):\n            par[i]=find(par[i])\n        ans=[[]for i in range(n+3)]\n        for i in range(n):\n            ans[par[i]].append(s[i])\n        for i in range(n):\n            ans[i].sort()\n        fin=''\n        for i in range(n):\n            tmp = par[i]\n            fin+=ans[tmp][poi[tmp]]\n            poi[tmp]+=1\n        return fin\n            \n        \n        \n        \n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        S=s\n        N = len(S)\n        graph = [[] for _ in range(N)]\n        for u, v in pairs:\n            graph[u].append(v)\n            graph[v].append(u)\n        ans = [None] * N\n        \n        seen = [False] * N\n        for u in range(N):\n            if not seen[u]:\n                seen[u] = True\n                stack = [u]\n                component = []\n                while stack:\n                    node = stack.pop()\n                    component.append(node)\n                    for nei in graph[node]:\n                        if not seen[nei]:\n                            seen[nei] = True\n                            stack.append(nei)\n                \n                component.sort()\n                letters = sorted(S[i] for i in component)\n                for ix, i in enumerate(component):\n                    letter = letters[ix]\n                    ans[i] = letter\n        return \\\"\\\".join(ans)\n        ", "from collections import defaultdict\n\nclass DisjointSet:\n    class Node:\n        def __init__(self, x):\n            self.val = x\n            self.parent = self\n            self.rank = 0\n            \n    def __init__(self, node_num):\n        self.val_to_node = {}\n        \n        for val in range(node_num):\n            self.val_to_node[val] = DisjointSet.Node(val)\n            \n    def find(self, x):\n        return self._find(self.val_to_node[x]).val\n    \n    def _find(self, node):\n        if node.parent is node:\n            return node\n        \n        node.parent = self._find(node.parent)\n        return node.parent\n    \n    def union(self, val1, val2):\n        root1 = self._find(self.val_to_node[val1])\n        root2 = self._find(self.val_to_node[val2])\n        \n        if root1 is root2:\n            return\n        \n        if root2.rank > root1.rank:\n            root1, root2 = root2, root1\n            \n        if root1.rank == root2.rank:\n            root1.rank += 1\n        \n        root2.parent = root1\n            \n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        '''\n        cba\n        \n        bca\n        bac\n        abc\n        '''\n        if not pairs:\n            return s\n        \n        disjoint_set = DisjointSet(len(s))\n        \n        for u, v in pairs:\n            disjoint_set.union(u, v)\n        \n        connected_components = defaultdict(list)\n        \n        for i in range(len(s)):\n            connected_components[disjoint_set.find(i)].append(i)\n        \n        res = [None] * len(s)\n        for group in list(connected_components.values()):\n            sorted_chars = sorted([s[i] for i in group])\n            \n            for idx, s_i in enumerate(sorted(group)):\n                res[s_i] = sorted_chars[idx]\n                \n        return ''.join(res)\n", "class Solution:\n    # 21:50\n    \\\"\\\"\\\"\n    s = \\\"dcab\\\", pairs = [[0,3],[1,2],[0,2]]\n    dcab -[1, 2]->dacb\n    dacb -[0, 3]->bacd\n    not possible anymore\n    \\\"\\\"\\\"\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        res = list(s)\n        adj = collections.defaultdict(set)\n        for a, b in pairs:\n            adj[a].add(b)\n            adj[b].add(a)\n            \n        def dfs(i, v):\n            if i in adj:\n                v.append(i)\n                for j in adj.pop(i):\n                    dfs(j, v)\n            \n            \n        while adj:\n            i = next(iter(adj))\n            v = []\n            dfs(i, v)\n            v = sorted(v)\n            chars = sorted([s[i] for i in v])\n            for i, c in enumerate(chars):\n                res[v[i]] = c\n                \n        return ''.join(res)\n    \n        \n                \n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self, n):\n                self.p = list(range(n))\n                self.sizes = [0 for i in range(n)]\n            def union(self, x, y):\n                x = self.find(x)\n                y = self.find(y)\n                if x == y:\n                    return\n                if self.sizes[x] < self.sizes[y]:\n                    x, y = y, x\n                self.p[y] = x\n                self.sizes[x] += self.sizes[y]\n            def find(self, x):\n                if x != self.p[x]:\n                    self.p[x] = self.find(self.p[x])\n                return self.p[x]\n    \n        uf = UF(len(s))\n        for x,y in pairs: \n            uf.union(x,y)\n        m = defaultdict(list)\n        for i in range(len(s)):\n            m[uf.find(i)].append(s[i])\n        for k in list(m.keys()):\n            m[k].sort(reverse=True)\n        res = []\n        for i in range(len(s)):\n            res.append(m[uf.find(i)].pop())\n        return ''.join(res)\n                \n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self, n): self.p = list(range(n))\n            # set one number's parent to other number's parent\n            def union(self, x, y): self.p[self.find(x)] = self.find(y)\n            # find current num's root node using recursive call \n            def find(self, x):\n                if x != self.p[x]:\n                    self.p[x] = self.find(self.p[x])\n                return self.p[x]\n        \n        union_find, result, group = UF(len(s)), [], defaultdict(list)\n        # join the groups\n        for pair in pairs:\n            union_find.union(pair[0], pair[1])\n         \n        #for i in range(len(s)):\n        #    union_find.p[i] = union_find.find(i)\n        # append list of num to the parent node \n        for i in range(len(s)):\n            group[union_find.find(i)].append(s[i])\n        # sort the keys in the group \n        for comp_id in list(group.keys()):\n            group[comp_id].sort(reverse=True)\n        # using pop to append\n        for i in range(len(s)):\n            result.append(group[union_find.find(i)].pop())\n        return ''.join(result)\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        \n        node = {i : i for i in range(len(s))}\n        \n\n        def find(x):\n            if x != node[x]:\n                node[x] = find(node[x])   \n                \n            return node[x]\n        \n        def union(x, y):\n            if find(x) != find(y):\n                node[find(x)] = find(y)\n                \n        ans = []\n        m = defaultdict(list)\n        \n        for x, y in pairs:\n            union(x, y)\n        for i in range(len(s)):\n            m[find(i)].append(s[i])\n           \n        for cid in m.keys():\n            m[cid].sort(reverse=True)\n        print(m.items())\n            \n        for  i in range(len(s)):\n            ans.append(m[find(i)].pop())\n            \n        return \\\"\\\".join(ans)\n            \n            \n                \n        \n        \n        \n        \n     ", "from collections import defaultdict\nclass UF:\n    \n    def __init__(self,n):\n        self.parent=[x for x in range(n)]\n        \n    def find(self,x):\n        if self.parent[x]!=x:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        self.parent[self.find(x)]=self.find(y)\n\n\nclass Solution:       \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \\\"\\\"\\\"\n        0 1 2 3\n        3 2\n        2\n        \\\"\\\"\\\"\n        n=len(s)\n        uf=UF(n)\n        for item in pairs:\n            uf.union(item[0],item[1])\n        \n        root_dict=defaultdict(list)\n        \n        for i,x in enumerate(list(s)):\n            root_dict[uf.find(i)].append(x)\n            \n        for key in root_dict:\n            root_dict[key]=sorted(root_dict[key],reverse=True)\n            \n        output=[]\n        for i,x in enumerate(list(s)):\n            output.append(root_dict[uf.find(i)].pop())\n        \n        return \\\"\\\".join(output)\n        ", "class union:\n    def __init__(self):\n        self.par = None\n        self.rank = 0\n    @staticmethod\n    def parent(A):\n        temp = A\n        while A.par:\n            A = A.par\n        if temp != A:\n            temp.par = A\n        return A\n    @staticmethod\n    def fun(A,B):\n        pA = union.parent(A)\n        pB = union.parent(B)\n        if pA != pB:\n            if pA.rank > pB.rank:\n                pB.par = pA\n                pA.rank+=1\n                return pB\n            pA.par = pB\n            pB.rank+=1\n            return pA\n        return None\n            \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        s = list(s)\n        dic = {}\n        par = set()\n        for i in range(len(s)):\n            temp =  union()\n            dic[i] = temp\n            par.add(temp)\n        for i in pairs:\n            temp = union.fun(dic[i[0]],dic[i[1]])\n            if temp in par:\n                par.remove(temp)\n        \n        if len(par) == 1:\n            s.sort()\n            return \\\"\\\".join(s)\n        new = {}\n        for i in par:\n            new[i] = [[],0]\n        for i in range(len(s)):\n            par = union.parent(dic[i])\n            new[par][0].append(s[i])\n        for i in new.values():\n            i[0].sort()\n        ans =[]\n        for i in range(len(s)):\n            par = union.parent(dic[i])\n            ind = new[par][1]\n            new[par][1]+=1\n            ans.append(new[par][0][ind])\n        return \\\"\\\".join(ans)\n        \n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n = len(s)\n        edges = defaultdict(list)\n        \n        for p in pairs:\n            edges[p[0]].append(p[1])\n            edges[p[1]].append(p[0])\n        visited = [False for i in range(n)]\n        \n        def dfs(node):\n            visited[node] = True\n            component.append(node)\n            for neighbor in edges[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n                    \n        connected_components = []\n        for i in range(n):\n            if not visited[i]:\n                component = []\n                dfs(i)\n                connected_components.append(component)\n        #print(connected_components)\n        ans = [\\\" \\\" for i in range(n)]\n        for component in connected_components:\n            indexes = sorted(component)\n            chars = [s[i] for i in indexes]\n            chars = sorted(chars)\n            for i in range(len(indexes)):\n                ans[indexes[i]] = chars[i]\n        #print(ans)\n        return ''.join(ans)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        uf = {}\n        \n        def find(x):\n            uf.setdefault(x, x)\n            if uf[x] != x:\n                uf[x] = find(uf[x])\n            return uf[x]\n        \n        def union(x, y):\n            uf[find(x)] = find(y)\n            \n        for a, b in pairs:\n            union(a, b)\n            \n        ans = [\\\"\\\"] * len(s)\n        dic = collections.defaultdict(list)\n        for i, ss in enumerate(s):\n            dic[find(i)].append((ss, i))\n        print(dic)\n        for d in dic:\n            for ss, i in zip(sorted(ss for ss, i in dic[d]), sorted(i for ss, i in dic[d])):\n                ans[i] = ss\n        return \\\"\\\".join(ans)\n                \n                \n            \n            \n            \n            \n            \n            \n            ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        l = len(s)\n        union_find = [i for i in range(l)]\n        union_set = {}\n        for i in range(l):\n            union_set[i] = [i]\n        for p in pairs:\n            x = p[0]\n            y = p[1]\n            t, t1 = union_find[y], union_find[x]\n            if union_find[x] < union_find[y]:\n                t, t1 = union_find[x], union_find[y]\n            if t == t1:\n                continue\n            for i in union_set[t1]:\n                union_set[t].append(i)\n                union_find[i] = t\n            union_set[t1] = []\n        print(union_find)\n        print(union_set)\n        res_cand = {}\n        for k, v in list(union_set.items()):\n            union_set = []\n            for i in v:\n                union_set.append(s[i])\n            union_set.sort(reverse=True)\n            res_cand[k] = union_set\n\n        print(res_cand)\n        res = ''\n        for i in range(l):\n            res = res + res_cand[union_find[i]][-1]\n            res_cand[union_find[i]].pop()\n        return res\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(u, cc):\n            cc.append(u)\n            visited_set.add(u)\n            if u in graph:\n                for v in graph[u]:\n                    if v not in visited_set:\n                        dfs(v, cc)\n\n        if len(pairs) == 0:\n            return s\n\n        graph = {}\n        for u,v in pairs:\n            if u in graph:\n                graph[u].append(v)\n            else:\n                graph[u] = [v]\n            if v in graph:\n                graph[v].append(u)\n            else:\n                graph[v] = [u]\n\n        result = [c for c in s]\n        visited_set = set()\n        for u in graph:\n            if u not in visited_set:\n                cc = []\n                dfs(u, cc)\n                cc.sort()\n                auxr = [s[i] for i in cc]\n                auxr.sort()\n                for i, index in enumerate(cc):\n                    result[index] = auxr[i]\n        return ''.join(result)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(u, cc):\n            visited_set[u] = cc\n            if u in graph:\n                for v in graph[u]:\n                    if visited_set[v] == 0:\n                        dfs(v, cc)\n\n        if len(pairs) == 0:\n            return s\n\n        graph = {}\n        for u,v in pairs:\n            if u in graph:\n                graph[u].append(v)\n            else:\n                graph[u] = [v]\n            if v in graph:\n                graph[v].append(u)\n            else:\n                graph[v] = [u]\n\n        visited_set = [0 for i in range(len(s))]\n        cc = 0\n        for u in graph:\n            if visited_set[u] == 0:\n                cc += 1\n                dfs(u, cc)\n\n        dd = defaultdict(list)\n        result = [c for c in s]\n        for i,key in enumerate(visited_set):\n            if key != 0:\n                dd[key].append(s[i]);\n        for key in dd:\n            dd[key].sort(reverse=True)\n        for i, key in enumerate(visited_set):\n            if key != 0:\n                result[i] = dd[key].pop()\n\n        return ''.join(result)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        g = collections.defaultdict(list)\n        for a, b in pairs:\n            g[a].append(b)\n            g[b].append(a)\n        \n        def find(i, idx):\n            for k in g[i]:\n                if not visited[k]:\n                    visited[k] = 1\n                    idx.append(k)\n                    find(k, idx)\n        n = len(s)\n        s = list(s)\n        visited = [0] * n\n        for i in range(n):\n            if visited[i]:\n                continue\n            visited[i] = 1\n            idx = [i]\n            find(i, idx)\n            idx.sort()\n            chars = [s[j] for j in idx]\n            chars.sort()\n            for j, c in zip(idx, chars):\n                s[j] =  c\n        return ''.join(s)", "# class Solution:\n#     def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n#             class UF:\n#                 def __init__(self, n): self.p = list(range(n))\n#                 def union(self, x, y): self.p[self.find(x)] = self.find(y)\n#                 def find(self, x):\n#                     if x != self.p[x]: self.p[x] = self.find(self.p[x])\n#                     return self.p[x]\n#             uf, res, m = UF(len(s)), [], defaultdict(list)\n#             for x,y in pairs: \n#                 uf.union(x,y)\n#             for i in range(len(s)): \n#                 m[uf.find(i)].append(s[i])\n#             for comp_id in m.keys(): \n#                 m[comp_id].sort(reverse=True)\n#             for i in range(len(s)): \n#                 res.append(m[uf.find(i)].pop())\n#             return ''.join(res)\n\nfrom collections import defaultdict\n\nclass Solution:\n    def find(self,x):\n        if(x!=self.parent[x]):\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n        \n        \n    def union(self,x,y):\n        x_find=self.find(x)\n        y_find=self.find(y)\n        self.parent[x_find]=y_find\n        \n    \n    \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n=len(s)\n        self.parent=list(range(n))\n        \n        for x,y in pairs:\n            self.union(x,y)\n        \n        # print(self.parent)\n        \n        groups=defaultdict(list)\n        for i in range(n):\n            tem=self.find(i)\n            # self.parent[i]=tem\n            groups[tem].append(s[i])    \n            # print(tem)\n        # print(self.parent)\n        \n        ans=[]\n        for comp_id in groups.keys(): \n            groups[comp_id].sort(reverse=True)\n            \n        # print(groups)\n        \n        for i in range(n): \n            ans.append(groups[self.find(i)].pop())\n        return \\\"\\\".join(ans)\n        ", "from collections import defaultdict\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(x):\n            visited.add(x)\n            component.append(x)\n            for ele in adjacencyList[x]:\n                if ele not in visited:\n                    dfs(ele)\n            \n        adjacencyList = [[] for x in range(len(s))]\n        for pair in pairs:\n            # print(pair, adjacencyList, len(s))\n            adjacencyList[pair[0]].append(pair[1])\n            adjacencyList[pair[1]].append(pair[0])\n        \n        \n        visited = set()\n        ans = list(s)\n        for x in range(len(s)):\n            if x not in visited:\n                component = []\n                dfs(x)\n                lst = []\n                component.sort()\n                for y in component:\n                    lst.append(s[y])\n                lst.sort()\n                i = 0\n                for y in component:\n                    ans[y] = lst[i]\n                    i+=1\n        return \\\"\\\".join(ans)\n                    \n                \n        \n    ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self, n): self.p = list(range(n))\n            def union(self, x, y): self.p[self.find(x)] = self.find(y)\n            def find(self, x):\n                if x != self.p[x]:\n                    self.p[x] = self.find(self.p[x])\n                return self.p[x]\n        \n        union_find, result, group = UF(len(s)), [], defaultdict(list)\n        for pair in pairs:\n            union_find.union(pair[0], pair[1])\n        for i in range(len(s)):\n            union_find.p[i] = union_find.find(i)\n        for i in range(len(s)):\n            group[union_find.find(i)].append(s[i])\n        for comp_id in list(group.keys()):\n            group[comp_id].sort(reverse=True)\n        for i in range(len(s)):\n            result.append(group[union_find.find(i)].pop())\n        return ''.join(result)\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(u, cc):\n            visited_set[u] = cc\n            if u in graph:\n                for v in graph[u]:\n                    if visited_set[v] == 0:\n                        dfs(v, cc)\n\n        if len(pairs) == 0:\n            return s\n\n        graph = {}\n        for u,v in pairs:\n            if u in graph:\n                graph[u].append(v)\n            else:\n                graph[u] = [v]\n            if v in graph:\n                graph[v].append(u)\n            else:\n                graph[v] = [u]\n\n        visited_set = [0 for i in range(len(s))]\n        cc = 0\n        for u in graph:\n            if visited_set[u] == 0:\n                cc += 1\n                dfs(u, cc)\n\n        dd = {}\n        result = [c for c in s]\n        for i,key in enumerate(visited_set):\n            if key != 0:\n                if key in dd:\n                    heapq.heappush(dd[key], s[i]);\n                else:\n                    dd[key] = [s[i]]\n        for i, key in enumerate(visited_set):\n            if key != 0:\n                result[i] = heapq.heappop(dd[key])\n\n        return ''.join(result)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(root, res):\n            if letters[root] == 1:\n                return\n            letters[root] = 1\n            res.append(root)\n            for node in graph[root]:\n                dfs(node, res)\n                \n        letters = [0]*len(s)\n        graph = [[] for _ in range(len(s))]\n        for a, b in pairs:\n            graph[a].append(b)\n            graph[b].append(a)\n        res = list(s)\n        for i in range(len(s)):\n            if letters[i] == 0:\n                visited = []\n                dfs(i, visited)\n                nodes = []\n                for node in visited:\n                    nodes.append(res[node])\n                nodes.sort()\n                visited.sort()\n                # print(nodes)\n                # print(visited)\n                for node, index in zip(nodes, visited):\n                    res[index] = node\n        return ''.join(res)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(u, cc):\n            visited_set[u] = cc\n            if u in graph:\n                for v in graph[u]:\n                    if visited_set[v] == 0:\n                        dfs(v, cc)\n\n        if len(pairs) == 0:\n            return s\n\n        graph = {}\n        for u,v in pairs:\n            if u in graph:\n                graph[u].append(v)\n            else:\n                graph[u] = [v]\n            if v in graph:\n                graph[v].append(u)\n            else:\n                graph[v] = [u]\n\n        visited_set = [0 for i in range(len(s))]\n        cc = 0\n        for u in graph:\n            if visited_set[u] == 0:\n                cc += 1\n                dfs(u, cc)\n\n        dd = {}\n        result = [c for c in s]\n        for i,key in enumerate(visited_set):\n            if key != 0:\n                if key in dd:\n                    dd[key].append(s[i]);\n                else:\n                    dd[key] = [s[i]]\n        for key in dd:\n            dd[key].sort(reverse=True)\n        for i, key in enumerate(visited_set):\n            if key != 0:\n                result[i] = dd[key].pop()\n\n        return ''.join(result)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        graph = defaultdict(list)\n        for node, neigbor in pairs:\n            graph[node].append(neigbor)\n            graph[neigbor].append(node)\n\n        visited = set()\n\n        def dfs(index):\n            if index not in visited:\n                visited.add(index)\n                newgroup.add(index)\n                for neigbor in graph[index]:\n                    dfs(neigbor)\n\n        n = len(s)\n        result = [None] * n\n        for i in range(n):\n            newgroup = set()\n            dfs(i)\n            subseq = [s[i] for i in newgroup]\n            subseq.sort()\n            for letter, index in zip(subseq, sorted(newgroup)):\n                result[index] = letter        \n\n        return ''.join(result)", "from heapq import *\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, prs: List[List[int]]) -> str:\n        f, m, ans = {}, defaultdict(list), []\n        for p in prs:\n            r_a, r_b = self.fnd(f, p[0]), self.fnd(f, p[1])\n            if r_a != r_b:\n                f[r_b] = r_a\n        \n        for i in range(len(s)):\n            m[self.fnd(f, i)].append(s[i])\n        for v in list(m.values()):\n            heapify(v)\n        for i in range(len(s)):\n            ans.append(heappop(m[self.fnd(f, i)]))\n        return ''.join(ans)\n    \n    def fnd(self, f, n):\n        f[n] = f.get(n, n)\n        if f[n] == n:\n            return n\n        f[n] = self.fnd(f, f[n])\n        \n        return f[n]\n", "import collections\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n    swap_sets = [i for i in range(len(s))]\n    \n    for [a,b] in pairs:\n      if not self.find(a,b,swap_sets):\n        self.union(a,b, swap_sets)\n        \n    swap_sets = [self.root(s, swap_sets) for s in swap_sets]\n    \n    groups = collections.defaultdict(list)\n    for i, charIndex in enumerate(swap_sets):\n      groups[charIndex].append(i)\n    \n    for k,v in groups.items():\n      chars = [s[i] for i in v]\n      groups[k] = sorted(v), sorted(chars)\n      \n    subs = [v for k,v in groups.items()]\n    newStr = ['' for i in range(len(s))]\n    for indices, letters in subs:\n      for i in range(len(indices)):\n        newStr[indices[i]] = letters[i]\n        \n    return \\\"\\\".join(newStr)\n      \n      \n  def union(self,a,b, roots):\n    ra, rb = self.root(a, roots), self.root(b, roots)\n    roots[rb] = ra\n    \n  def root(self,a, roots):\n    while(roots[a] != a):\n      roots[a] = roots[roots[a]]\n      a = roots[a]\n    return a\n  \n  def find(self,a,b, roots):\n    return self.root(a, roots) == self.root(b, roots)\n    \n    \n      ", "class DSU:\n    def __init__(self, n):\n        self.p = list(range(n))\n    \n    def find(self, x):\n        if(self.p[x] != x):\n            self.p[x] = self.find(self.p[x])\n        return self.p[x]\n    \n    def union(self, x, y):\n        xr = self.find(x)\n        yr = self.find(y)\n        self.p[xr] = yr\n        \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        N = len(s)\n        dsu = DSU(N)\n        \n        for x, y in pairs:\n            dsu.union(x, y)\n            \n        dic = collections.defaultdict(list)\n        for i in range(N):\n            k = dsu.find(i)\n            dic[k].append(i)\n        \n        res = [' ']*N\n        for v in dic.values():\n            for i, j in zip(v, sorted(v, key=lambda idx:s[idx])):\n                res[i] = s[j]\n        return \\\"\\\".join(res)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(u, cc):\n            visited_set[u] = cc\n            if u in graph:\n                for v in graph[u]:\n                    if visited_set[v] == 0:\n                        dfs(v, cc)\n\n        if len(pairs) == 0:\n            return s\n\n        graph = {}\n        for u,v in pairs:\n            if u in graph:\n                graph[u].append(v)\n            else:\n                graph[u] = [v]\n            if v in graph:\n                graph[v].append(u)\n            else:\n                graph[v] = [u]\n\n        visited_set = [0 for i in range(len(s))]\n        cc = 0\n        for i in range(len(s)):\n            if visited_set[i] == 0:\n                cc += 1\n                dfs(i, cc)\n\n        dd = {}\n        for i,key in enumerate(visited_set):\n            if key in dd:\n                heapq.heappush(dd[key], s[i]);\n            else:\n                dd[key] = [s[i]]\n\n        return ''.join(heapq.heappop(dd[key]) for key in visited_set)", "from collections import defaultdict\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        p = list(range(len(s)))\n        # r = [1]*len(s)\n        d = defaultdict(list)\n        def find(x):\n            if x!=p[x]:\n                p[x]=find(p[x])\n            return p[x]\n        \n        def union(x,y):\n            x,y = find(x), find(y)\n            if x==y:\n                return False\n            p[x]=y\n            \n        for a,b in pairs:\n            union(a,b)\n        for i in range(len(p)):\n            d[find(i)].append(s[i])\n        for i in d:\n            d[i].sort(reverse=True)\n        ret=''\n        for i in range(len(s)):\n            ret+=d[find(i)].pop()\n        return ret", "class UnionFind(object):\n    def __init__(self,n):\n        self._parent = [0]*n\n        self._size = [1]*n\n        self.count = n\n        for i in range(n):\n            self._parent[i] = i\n            \n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return\n        self.count -= 1\n        if self._size[rootp] > self._size[rootq]:\n            self._size[rootp] += self._size[rootq]\n            self._parent[rootq] = self._parent[q] = rootp\n        else:\n            self._size[rootq] += self._size[rootp]\n            self._parent[rootp] = self._parent[p] = rootq\n    \n    def find(self, n):\n        while self._parent[n] != n:\n            self._parent[n] = self._parent[self._parent[n]]\n            n = self._parent[n]\n        return n\n    \n    def connected(self, p, q):\n        return self.find(p) == self.find(q)\n    \nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        N = len(s)\n        if N < 2: return s\n        uf = UnionFind(N)\n        for pair in pairs:\n            uf.union(pair[0],pair[1])\n        \n        dict = defaultdict(list)\n        for i in range(N):\n            r = uf.find(i)\n            dict[r].append(i)\n            \n        res = [' ']*N\n        for lst in list(dict.values()):\n            lst.sort()\n            subs = ''\n            for idx in lst:\n                subs += s[idx]\n            s2 = sorted(subs)\n            i2 = 0\n            for idx in lst:\n                res[idx]=s2[i2]\n                i2+=1\n        return ''.join(res)\n            \n        \n        \n            \n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        def find(x):\n            parent.setdefault(x,x)\n            if x!=parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x,y):\n            px = find(x)\n            py = find(y)\n            parent[px] = py\n            \n        \n        parent = dict()\n        \n        \n        for i,j in pairs:\n            # if i==j:\n            #     continue\n            x = i\n            y = j\n            px = find(x)\n            py = find(y)\n            if px!=py:\n                union(x,y)\n        \n        graph = collections.defaultdict(list)\n        \n        \n        \n        for i in range(len(s)):\n            px = find(i)\n            heapq.heappush(graph[px],s[i])\n            #bisect.insort(graph[px],s[i])\n        # for char in s:\n        #     px = find()\n        #     bisect.insort(graph[px],char)\n        \n        print(graph)\n        \n#         res = ''\n#         for char in s:\n#             px = find(char)\n#             res += graph[px].pop(0) # this is o(n)\n#         return(res)\n        res = ''\n        mem = collections.defaultdict(int)\n        for i in range(len(s)):\n            px = find(i)\n            \n            res += heapq.heappop(graph[px])\n            #res += graph[px][mem[px]] # this is o(n)\n            #mem[px]+=1\n        return res\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(u, cc):\n            cc.append(u)\n            visited_set.add(u)\n            if u in graph:\n                for v in graph[u]:\n                    if v not in visited_set:\n                        dfs(v, cc)\n\n        M = len(pairs)\n        if M == 0:\n            return s\n\n        graph = defaultdict(list)\n        for u,v in pairs:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        result = [c for c in s]\n        visited_set = set()\n        for u in graph:\n            if u not in visited_set:\n                cc = []\n                dfs(u, cc)\n                cc.sort()\n                auxr = [s[i] for i in cc]\n                auxr.sort()\n                for i, index in enumerate(cc):\n                    result[index] = auxr[i]\n        return ''.join(result)", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        def find(x):\n            parent.setdefault(x,x)\n            if x!=parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x,y):\n            px = find(x)\n            py = find(y)\n            parent[px] = py\n            \n        \n        parent = dict()\n        \n        \n        for i,j in pairs:\n            if i==j:\n                continue\n            x = i\n            y = j\n            px = find(x)\n            py = find(y)\n            if px!=py:\n                union(x,y)\n        \n        graph = collections.defaultdict(list)\n        \n        for i in range(len(s)):\n            px = find(i)\n            heapq.heappush(graph[px],s[i])\n           \n  \n        res = ''\n        mem = collections.defaultdict(int)\n        for i in range(len(s)):\n            px = find(i)\n            res += heapq.heappop(graph[px])\n        return res\n", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        def find(x):\n            #parent.setdefault(x,x)\n            #print(x)\n            if x!=parent[x]:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x,y):\n            px = find(x)\n            py = find(y)\n            parent[px] = py\n            \n        \n        parent = list(range(len(s)+1))\n        \n        \n        for i,j in pairs:\n            if i==j:\n                continue\n            x = i\n            y = j\n            px = find(x)\n            py = find(y)\n            if px!=py:\n                union(x,y)\n        \n        graph = collections.defaultdict(list)\n        \n        for i in range(len(s)):\n            px = find(i)\n            heapq.heappush(graph[px],s[i])\n           \n  \n        res = ''\n        mem = collections.defaultdict(int)\n        for i in range(len(s)):\n            px = find(i)\n            res += heapq.heappop(graph[px])\n        return res\n", "class DisjointSet:\n    \n    def __init__(self):\n        self.parent = dict()\n    \n    def union(self, a, b):\n        root_a = self.find(a)\n        root_b = self.find(b)\n        if root_a == root_b:\n            return False\n        self.parent[root_a] = root_b\n        return True\n    \n    def find(self, a):\n        if a not in self.parent:\n            self.parent[a] = a\n            return a\n        \n        if a != self.parent[a]:\n            self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n        \n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        ds = DisjointSet()\n        \n        for u, v in pairs:\n            ds.union(u, v)\n        \n        hashmap = collections.defaultdict(list)\n        for i, c in enumerate(s):\n            root = ds.find(i)\n            hashmap[root].append((c, i))\n        \n        for root in hashmap:\n            hashmap[root].sort(reverse=True)\n        \n        ans = []\n        for i in range(len(s)):\n            root = ds.find(i)\n            c, _ = hashmap[root].pop()\n            ans.append(c)\n        return \\\"\\\".join(ans)\n        ", "class Solution:\n    # 21:50\n    \\\"\\\"\\\"\n    s = \\\"dcab\\\", pairs = [[0,3],[1,2],[0,2]]\n    dcab -[1, 2]->dacb\n    dacb -[0, 3]->bacd\n    not possible anymore\n    \\\"\\\"\\\"\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        res = list(s)\n        groups = self.groups(pairs, len(s))\n        for g in groups:\n            chars = sorted([s[i] for i in g])\n            j = 0\n            for i in g:\n                res[i] = chars[j]\n                j += 1\n                \n        return ''.join(res)\n    \n    def groups(self, pairs, n):\n        adj = collections.defaultdict(set)\n        for p in pairs:\n            adj[p[0]].add(p[1])\n            adj[p[1]].add(p[0])\n            \n        arr = []\n        while adj:\n            i = list(adj.keys())[0]\n            v = []\n            self.dfs(i, adj, v)\n            arr.append(sorted(list(v)))\n                \n        return arr\n    \n    def dfs(self, i, adj, res):\n        if i in adj:\n            res.append(i)\n            for j in adj.pop(i):\n                self.dfs(j, adj, res)\n        \n                \n        ", "from collections import defaultdict\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        array = [char for char in s]\n        edges = defaultdict(list)\n        for i, j in pairs:\n            edges[i].append(j)\n            edges[j].append(i)\n        parents = {}\n        components = defaultdict(list)\n        for i in range(len(pairs)):\n            for j in edges[i]:\n                self.union(i, j, parents)\n        for child, parent in list(parents.items()):\n            components[self.find(parent, parents)].append(child)\n        print(parents)\n        print(components)\n        for parent, children in list(components.items()):\n            tmp = sorted([array[child] for child in children])\n            print(tmp)\n            components[parent] = sorted(children)\n            for k in range(len(children)):\n                array[components[parent][k]] = tmp[k]\n        return ''.join(array)\n\n        \n    \n    def union(self, i, j, parents):\n        if not parents.get(i):\n            parents[i] = i\n        if not parents.get(j):\n            parents[j] = j\n        pi, pj = self.find(i, parents), self.find(j, parents)\n        parents[pj] = pi\n        parents[i] = pi\n    \n    def find(self, i, parents):\n        while parents[i] != i:\n            parents[i] = parents[parents[i]]\n            i = parents[i]\n        return parents[i]\n        \n                \n                \n                    \n            \n    \n        \n        \n                    \n                    \n            \n        \n", "from collections import defaultdict\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        def find(node):\n            path = []\n            while root[node] != node:\n                path.append(node)\n                node = root[node]\n            \n            for n in path:\n                root[n] = node\n            return node\n        \n        \n        def union(a, b):\n            r1, r2 = find(a), find(b)\n            if r1 != r2:\n                root[r1] = r2\n        \n        \n        root = {i: i for i in range(len(s))}\n        for a, b in pairs:\n            union(a, b)\n            \n        root_to_char = defaultdict(list)\n        for k in list(root.keys()):\n            root_to_char[find(k)].append(s[k])\n            \n        for v in list(root_to_char.values()):\n            v.sort(reverse=True)\n        \n        res = []\n        for i in range(len(s)):\n            res.append(root_to_char[root[i]].pop())\n        \n        return ''.join(res)\n", "from collections import defaultdict\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        p = list(range(len(s)))\n        d = defaultdict(list)\n        def find(x):\n            if p[x]!=x:\n                p[x]=find(p[x])\n            return p[x]\n        def union(x,y):\n            x,y = find(x),find(y)\n            p[x]=y\n            return p[x] \n        for a,b in pairs:\n            union(a,b)\n        for i in range(len(p)):\n            d[find(i)].append(s[i])\n        for x in d:\n            d[find(x)].sort(reverse=True)\n        ret=''\n        for i in range(len(s)):\n            ret+=d[find(i)].pop()\n        return ret", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        \n        def dfs(node):\n            seen.add(node)\n            idx.append(node)\n            ch.append(s[node])\n            \n            for nei in graph[node]:\n                if nei not in seen:\n                    dfs(nei)\n            \n        \n        \n        graph = collections.defaultdict(list)\n        \n        for u, v in pairs:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        seen = set()\n        idxCh = [\\\"\\\"]*len(s)\n        \n        for i in range(len(s)):\n            if i not in seen:\n                idx = []\n                ch = []\n                dfs(i)\n            for i, c in zip(sorted(idx), sorted(ch)):\n                idxCh[i] = c\n        return \\\"\\\".join(idxCh)\n            \n        \n     #    0 - 3\n     #    |\n     #1 - 2\n    \n    # [0,3] bd\n    # [1,2] ac\n    \n    ", "# class Solution:\n#     def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n#             class UF:\n#                 def __init__(self, n): self.p = list(range(n))\n#                 def union(self, x, y): self.p[self.find(x)] = self.find(y)\n#                 def find(self, x):\n#                     if x != self.p[x]: self.p[x] = self.find(self.p[x])\n#                     return self.p[x]\n#             uf, res, m = UF(len(s)), [], defaultdict(list)\n#             for x,y in pairs: \n#                 uf.union(x,y)\n#             for i in range(len(s)): \n#                 m[uf.find(i)].append(s[i])\n#             for comp_id in m.keys(): \n#                 m[comp_id].sort(reverse=True)\n#             for i in range(len(s)): \n#                 res.append(m[uf.find(i)].pop())\n#             return ''.join(res)\n\nfrom collections import defaultdict\n\nclass Solution:\n    def find(self,x):\n        if(x!=self.parent[x]):\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n        \n        \n    def union(self,x,y):\n        x_find=self.find(x)\n        y_find=self.find(y)\n        self.parent[x_find]=y_find\n        \n    \n    \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        n=len(s)\n        self.parent=list(range(n))\n        \n        for x,y in pairs:\n            self.union(x,y)\n        \n        # print(self.parent)\n        \n        groups=defaultdict(list)\n        for i in range(n):\n            tem=self.find(i)\n            # self.parent[i]=tem\n            groups[tem].append(s[i])    \n            # print(tem)\n        # print(self.parent)\n        \n        ans=[]\n        for comp_id in groups.keys(): \n            groups[comp_id].sort(reverse=True)\n            \n        # print(groups)\n        \n        for i in range(n): \n            ans.append(groups[self.find(i)].pop())\n        return \\\"\\\".join(ans)\n        \n        \n# # #         for i in range(len(s)):\n# # #             if(i not in added):\n# # #                 groups[i]=[i]\n        \n# #         # print(groups)\n# #         ls=dict()\n# #         for i,j in groups.items():\n# #             ls[tuple(j)]=sorted([s[ele] for ele in j])\n# #         # print(ls)\n        \n# #         ans=\\\"\\\"\n# #         for i in range(len(s)):\n# #             ans+=ls[tuple(groups[self.parent[i]])].pop(0)\n        \n# #         return ans\n                \n        \n            \n        \n        \n        \n        \n# # #         self.ans=s\n# # #         visited=set()\n# # # #         def traverse(st,pair,i):\n# # # #             print(st,i)\n# # # #             if(st in visited):\n# # #                 return\n# # #             visited.add(st)\n# # #             a,b=pair[i][0],pair[i][1]\n# # #             st=list(st)\n# # #             st[a],st[b]=st[b],st[a]\n# # #             st=\\\"\\\".join(st)\n# # #             self.ans=min(self.ans,st)\n# # #             # tem=st[:]\n# # #             for j in range(len(pair)):\n# # #                 if(i!=j):\n# # #                     traverse(st,pair,j)\n        \n        \n        \n        \n# #             # traverse(s,pairs,i)\n        \n# #         q=[s]\n# #         while(q!=[]):\n# #             tem=q.pop(0)\n# #             if(tem in visited):\n# #                 continue\n# #             visited.add(tem)\n# #             self.ans=min(self.ans,tem)\n# #             for i in range(len(pairs)):\n# #                 a,b=pairs[i][0],pairs[i][1]\n# #                 tem=list(tem)\n# #                 tem[a],tem[b]=tem[b],tem[a]\n# #                 tem=\\\"\\\".join(tem)\n# #                 q.append(tem)\n            \n        \n# #         return self.ans", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        def dfs(i):\n            visited[i] = True\n            component.append(i)\n            for j in adj_list[i]:\n                if not visited[j]:\n                    dfs(j)\n        n = len(s)\n        adj_list = [[] for _ in range(n)]\n        for i, j in pairs:\n            adj_list[i].append(j)\n            adj_list[j].append(i)\n        visited = [False for _ in range(n)]\n        s = list(s)\n        for i in range(n):\n            if not visited[i]:\n                component = []\n                dfs(i)\n                component.sort()\n                chars = [s[k] for k in component]\n                chars.sort()\n                for i in range(len(component)):\n                    s[component[i]] = chars[i]\n        return ''.join(s)\n", "class UnionFind:\n    def __init__(self, n):\n        self.parents = [i for i in range(n)]\n        self.rank = [0] * n\n        \n    def find(self, x):\n        if self.parents[x] != x:\n            self.parents[x] = self.find(self.parents[x])\n        return self.parents[x]\n    \n    def union(self, x, y):\n        self.parents[self.find(x)] = self.find(y)\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        UF = UnionFind(len(s))\n        res = []\n        for x, y in pairs:\n            UF.union(x, y)\n        parent_to_heap = collections.defaultdict(list)\n        for i, p in enumerate(UF.parents):\n            heapq.heappush(parent_to_heap[UF.find(p)], s[i])\n        for i, p in enumerate(UF.parents):\n            res.append(heapq.heappop(parent_to_heap[UF.find(p)]))\n        return ''.join(res)", "class Solution:\n    # 21:50\n    \\\"\\\"\\\"\n    s = \\\"dcab\\\", pairs = [[0,3],[1,2],[0,2]]\n    dcab -[1, 2]->dacb\n    dacb -[0, 3]->bacd\n    not possible anymore\n    \\\"\\\"\\\"\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        res = list(s)\n        groups = self.groups(pairs, len(s))\n        for g in groups:\n            chars = sorted([s[i] for i in g])\n            j = 0\n            for i in g:\n                res[i] = chars[j]\n                j += 1\n                \n        return ''.join(res)\n    \n    def groups(self, pairs, n):\n        adj = collections.defaultdict(set)\n        for p in pairs:\n            adj[p[0]].add(p[1])\n            adj[p[1]].add(p[0])\n            \n        arr = []\n        while adj:\n            i = list(adj.keys())[0]\n            v = []\n            self.dfs(i, adj, v)\n            arr.append(sorted(v))\n                \n        return arr\n    \n    def dfs(self, i, adj, res):\n        if i in adj:\n            res.append(i)\n            for j in adj.pop(i):\n                self.dfs(j, adj, res)\n        \n                \n        ", "class UF:\n    def __init__(self, N):\n        self.N = N\n        self.parent = [i for i in range(N)]\n        self.rank = [0 for i in range(N)]\n        \n    def union(self, a ,b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra != rb:\n            self.parent[ra] = rb\n    \n    def find(self, a):\n        while a!= self.parent[a]:\n            a = self.parent[a]\n        return a\n\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class UF:\n            def __init__(self, n): self.p = list(range(n))\n            def union(self, x, y): self.p[self.find(x)] = self.find(y)\n            def find(self, x):\n                if x != self.p[x]: self.p[x] = self.find(self.p[x])\n                return self.p[x]\n        uf, res, m = UF(len(s)), [], defaultdict(list)\n        for x,y in pairs: \n            uf.union(x,y)\n        for i in range(len(s)): \n            m[uf.find(i)].append(s[i])\n        for comp_id in list(m.keys()): \n            m[comp_id].sort(reverse=True)\n        for i in range(len(s)): \n            res.append(m[uf.find(i)].pop())\n        return ''.join(res)\n        \n        '''\n        cbad\n        [[0,3],[1,2],[0,2]]\n        \n        '''\n", "# this is version after checking the discussions\nclass Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        class unionFind:\n            def __init__(self, n):\n                #here index = component id, initiallly point to eachself\n                self.parents = list(range(n))\n                \n            def union (self, x, y):\n                # make y's parent x's\n                self.parents[self.find(x)] = self.find(y)\n                \n            def find (self, x):\n                # parent's parent == themself\n                # if this x is not a parent, find and record his final parent\n                if self.parents[x]!=x: self.parents[x] = self.find(self.parents[x])\n                return self.parents[x]\n            \n        uf1 = unionFind(len(s))\n        \n        for x,y in pairs:\n            uf1.union(x,y)\n        # every index of parents (implied index of s) found his parents now\n        \n        # because old parents won't be updated if their parent have a new parent\n        # do find to all indices to make sure the parents list is clean\n        for i in range(len(s)):\n            uf1.find(i)\n        \n        groupList = defaultdict(list)\n        \n        # make indices with same parents group together, get char directly from string\n        for i in range(len(s)):\n            groupList[uf1.parents[i]].append(s[i])\n        \n        # sort each group (list), reversely\n        for key in groupList.keys():\n            groupList[key].sort(reverse = True)\n        \n        #pop out char from behind of each group\n        result = []\n        for i in range(len(s)):\n            result.append(groupList[uf1.parents[i]].pop())\n        \n        # the way convert list to str\n        return \\\"\\\".join(result)\n        \n        ", "class Solution:\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        p = list(range(len(s)))\n        d = defaultdict(list)\n        def find(x):\n            if x!=p[x]:\n                p[x]=find(p[x])\n            return p[x]\n        def union(x,y):\n            p[find(x)]=find(y)\n        for a,b in pairs:\n            union(a,b)\n        for i in range(len(p)):\n            d[find(i)].append(s[i])\n        for x in d:\n            d[find(x)].sort(reverse=True)\n        ret=''\n        for i in range(len(s)):\n            ret+=d[find(i)].pop()\n        return ret"]