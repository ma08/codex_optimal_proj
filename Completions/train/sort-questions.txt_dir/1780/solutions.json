["def prod(n):\n    ret = [{1.}]\n    for i in range(1, n+1):\n        ret.append({(i - x) * j for x, s in enumerate(ret) for j in s})\n    return ret[-1]\n\ndef part(n):\n    p = sorted(prod(n))\n    return \"Range: %d Average: %.2f Median: %.2f\" % \\\n            (p[-1] - p[0], sum(p) / len(p), (p[len(p)//2] + p[~len(p)//2]) / 2)", "from functools import reduce\ndef prod(u):\n    p = 1\n    for x in u:\n        p *= x\n    return p\n\ncache = {}\ndef part_aux(s, k):\n    k0 = min(s, k)\n    if k0 < 1:\n        return []\n    i = (s - 1) * s / 2 + k0 - 1\n    ret = cache.get(i)\n    if ret:\n        return ret\n    res = []\n    for n in range(k0, 0, -1):\n        r = s - n\n        if (r > 0):\n            for t in part_aux(r, n):\n                if type(t) is list: \n                    res.append([n] + t)\n                else: res.append([n, t])\n        else:\n            res.append([n])\n    cache[i] = res\n    return res\n\ndef part(n):\n    r = sorted(set(map(prod, part_aux(n, n))))\n    lg = len(r)\n    avg = reduce(lambda x, y : x + y, r, 0)  / float(lg)\n    rge = r[lg - 1] -  r[0]\n    md = (r[(lg - 1) // 2] + r[lg // 2]) / 2.0\n    return \"Range: %d Average: %.2f Median: %.2f\" % (rge, avg, md)\n", "from functools import lru_cache, reduce\nfrom operator import or_\nfrom statistics import mean, median\n\n@lru_cache(maxsize=None)\ndef prod(n, x):\n    if n < 0:\n        return set()\n    return reduce(or_, ({i*s for s in prod(n-i, i)} for i in range(2, x+1)), {1})\n\ndef part(n):\n    xs = prod(n, n)\n    return f\"Range: {max(xs) - min(xs)} Average: {mean(xs):.2f} Median: {median(xs):.2f}\"", "# List of generated elements\n_elements = []\n\n\ndef _cgt(arr, pos):\n    # Check if element isn't last\n    # And element next to it is equal to 1(ONE)\n    if pos + 1 < len(arr) and arr[pos + 1] == 1:\n        # Check if current element is not bigger than previous one\n        # Because we want to get sorted array\n        # without repetitions\n        if pos == 0 or arr[pos - 1] >= arr[pos] + 1:\n            # If all conditions are met - creating new array\n            # and calling recursive function with it\n            _gt(arr[:pos] + [arr[pos] + 1] + arr[pos + 2:], pos)\n\ndef _gt(arr, pos):\n    nonlocal _elements\n    _elements.append(arr) # Add current array of summands\n\n    # Checking 2 elements\n    # Example: For array [2, 1, 1] with pos = 0(zero) it will found:\n    # array [3, 1] because 3 is first\n    # and array [2, 2] because 2nd(second) number 2(two) is not bigger than first\n    _cgt(arr, pos)\n    _cgt(arr, pos + 1)\n\n    # Exit function without return value\n    return\n\n\n# Function that returning array of summands for given number\ndef gt(num):\n    nonlocal _elements\n    # Clear elements array to get right result\n    _elements = []\n    # Start with array of 1s(ones) and position = 0(zero)\n    _gt([1] * num, 0)\n    # Return generated elements\n    return _elements\n\n\ndef part(N):\n    # Create new dictionary that will contain all products\n    products = {}\n    \n    # Find product for each possible array of summands\n    for arr in gt(N):\n        prod = arr[0]\n        for v in arr[1:]: prod *= v\n        products[prod] = True\n    \n    # Sort found products to be able to find median\n    pds = sorted(p for p in products)\n\n    # Find values range\n    r = pds[-1] - 1\n    # Find average of array\n    a = sum(pds) / float(len(pds))\n    # Find array's median value\n    m = (pds[len(pds) / 2] + pds[(len(pds) - 1) / 2]) / 2.0\n\n    # Return formated info about sequence\n    return 'Range: %i Average: %.2f Median: %.2f' % (r, a, m)", "def part(n):\n    p = sorted(set([prod(s) for s in parts(n)]))\n    r = max(p) - min(p)\n    a = sum(p) / float(len(p))\n    m = (p[(len(p)-1)//2] + p[len(p)//2]) / 2.0\n    return 'Range: {} Average: {:.2f} Median: {:.2f}'.format(r, a, m)\n    \ndef prod(l):\n    p = 1\n    for i in l:\n        p *= i\n    return p\n    \n# http://jeromekelleher.net/generating-integer-partitions.html    \n# No recursion\ndef parts(n):\n    a = [0] * (n + 1)\n    k = 1\n    a[1] = n\n    while k:\n        x = a[k - 1] + 1\n        y = a[k] - 1\n        k -= 1\n        while x <= y:\n            a[k] = x\n            y -= x\n            k += 1\n        a[k] = x + y\n        yield a[:k + 1]", "from functools import reduce\nfrom statistics import median\ndef partition(n, I=1):\n    yield (n,)\n    for i in range(I, n//2 + 1):\n        for p in partition(n-i, i):\n            yield (i,) + p\n\ndef part(n):\n    prod = set()\n    all = partition(n)\n    for i in all:\n        prod.add(reduce(lambda a, b: a*b, i))\n    return(\"Range: {0} Average: {1:.2f} Median: {2:.2f}\".format(max(prod) - min(prod), sum(prod)/len(prod), median(prod)))", "from functools import reduce\ndef prod(u):\n    p = 1\n    for x in u:\n        p *= x\n    return p\n\ncache = {}\ndef part_aux(s, k):\n    k0 = min(s, k)\n    if k0 < 1:\n        return []\n    i = (s - 1) * s / 2 + k0 - 1\n    ret = cache.get(i)\n    if ret:\n        return ret\n    res = []\n    for n in range(k0, 0, -1):\n        r = s - n\n        if (r > 0):\n            for t in part_aux(r, n):\n                if type(t) is list: \n                    res.append([n] + t)\n                else: res.append([n, t])\n        else:\n            res.append([n])\n    cache[i] = res\n    return res\n\ndef part(n):\n    from functools import reduce\n    r = sorted(set(map(prod, part_aux(n, n))))\n    lg = len(r)\n    avg = reduce(lambda x, y : x + y, r, 0)  / float(lg)\n    rge = r[lg - 1] -  r[0]\n    md = (r[(lg - 1) // 2] + r[lg // 2]) / 2.0\n    return \"Range: %d Average: %.2f Median: %.2f\" % (rge, avg, md)\n", "from functools import reduce\nimport numpy as np\n\nidx = 0\nprods = set([])\n\ndef enum(buf, n, min_factor = 1):\n    nonlocal idx, prods\n    if len(buf)<n:\n        buf = [0 for i in range(n)]\n    if n <=0:\n        prods.add(reduce(lambda x,y:x*y,buf[:idx]))\n    else:\n        for i in range(min_factor,n+1):\n            buf[idx]=i\n            idx += 1\n            enum(buf, n-i, i)\n            idx -= 1\n\ndef part(n):\n    nonlocal prods,idx\n    buf = []\n    enum(buf,n)\n    ran = max(prods)-min(prods)\n    mean = np.mean(list(prods))\n    median = np.median(list(prods))\n    prods = set([])\n    idx = 0    \n    return \"Range: {} Average: {:.2f} Median: {:.2f}\".format(ran,mean,median)", "from operator import mul\nfrom functools import reduce\n\n\nmem = {}\n\n\n# simple cache for python 2.7\ndef cache(func):\n    def wrap(n):\n        if n in mem:\n            return mem[n]\n        res = func(n)\n        mem[n] = res\n        return res\n    return wrap\n\n\n@cache\ndef int_partition(n):\n    if n in mem:\n        return mem[n]\n    if n == 1:\n        return {(1,)}\n    part_set = int_partition(n - 1)\n    result = set()\n    for part in list(part_set):\n        num_set = set(part)\n        for num in num_set:\n            tmp = list(part)\n            i = part.index(num)\n            tmp[i] += 1\n            result.add(tuple(tmp))\n        result.add(part + tuple([1]))\n    return result\n\n\ndef part(n):\n    res = {}\n    part_set = int_partition(n)\n    prod_set = set()\n    for part_one in part_set:\n        prod_set.add(reduce(mul, part_one, 1))\n    prod_list = sorted(list(prod_set))\n    \n    res['range'] = prod_list[-1] - prod_list[0]\n    res['avg'] = float(sum(prod_list)) / len(prod_list)\n    mid = int((float(len(prod_list) - 1) / 2))\n    rev_mid = -mid if mid else None\n    mid_slice = prod_list[mid:rev_mid]\n    res['median'] = float(sum(mid_slice)) / len(mid_slice)\n    \n    tmpl = 'Range: {range} Average: {avg:.2f} Median: {median:.2f}'\n    return tmpl.format(**res)\n\n# from timeit import timeit\n# print(timeit(partial(part, 40), number=100))\n"]