["def crosstable(players, scores):\n    points, le = {j:sum(k or 0 for k in scores[i]) for i, j in enumerate(players)}, len(players)\n    SB = {j:sum(points[players[k]] / ([1, 2][l == 0.5]) for k, l in enumerate(scores[i]) if l) for i, j in enumerate(players)}\n\n    SORTED, li = [[i, players.index(i)] for i in sorted(players, key=lambda x: (-points[x], -SB[x], x.split()[1]))], []\n\n    ps = [format(i, '.1f') for i in points.values()]\n    Ss = [format(i, '.2f') for i in SB.values()]\n    \n    digit = len(str(le))\n    name = len(max(players, key=len))\n    pts = len(str(max(ps, key=lambda x: len(str(x)))))\n    sb = len(str(max(Ss, key=lambda x: len(str(x)))))\n\n    for i, j in enumerate(SORTED):\n        ten_ = [\" \", \"  \"][le >= 10]\n        index = [str(i + 1), \" \"][points[j[0]] == points[SORTED[i - 1][0]] and SB[j[0]] == SB[SORTED[i - 1][0]]].rjust(digit)\n        name_ = j[0].ljust(name)\n        team = ten_.join(['1=0 '[[1, 0.5, 0, None].index(scores[j[1]][l])] or '_' for k, l in SORTED])\n        pt = str(format(points[j[0]], \".1f\")).rjust(pts)\n        Sb = str(format(SB[j[0]], \".2f\")).rjust(sb)\n        li.append(f'{index}  {name_}{[\"  \", \"   \"][le >= 10]}{team}  {pt}  {Sb}')\n    \n    fline = ' '.join(['#'.rjust(digit) + '  ' +\n                    'Player'.ljust(name) +\n                    ['  ', '   '][len(players) >= 10] +\n                    ''.join([[' ', '  '][i < 10 and le >= 10] + str(i) for i in range(1, le + 1)]).strip() + '  ' +\n                    'Pts'.center(pts) + '  ' +\n                    'SB'.center(sb - [0, 2][sb & 1])]).rstrip()\n    return '\\n'.join([fline, '=' * len(max(li, key=len))] + li)", "def transform(ch):\n    s = ''\n    for car in ch:\n        car1 = car\n        if 'A' <= car <= 'Z': car1 = chr(ord('Z')-ord(car)+ord('A'))\n        if 'a' <= car <= 'z': car1 = chr(ord('z')-ord(car)+ord('a'))\n        s += car1\n    return s\n        \ndef crosstable(players, results):\n    scores = [sum([sc for sc in line if not sc is None]) for line in results]\n    sb = [sum([scores[i] if results[j][i] == 1 \\\n                        else scores[i]/2 if results[j][i] == 0.5 \\\n                        else 0 \\\n                        for i in range(len(results)) if not results[j][i] is None]) \\\n                        for j in range(len(results))]\n    rank = [sum([1 if (scores[j] > scores[i]) or (scores[i] == scores[j] and sb[j] > sb[i])\\\n                   else 0 \\\n                   for j in range(len(scores))])+1 for i in range(len(scores))]\n    res = list(zip(scores, \n                  sb, \n                  [transform(player.split()[1]) for player in players], \n                  range(len(results))))\n    #print(res)\n    res.sort(reverse=True)\n    #print(rank, res)\n    ranksize = max([len(str(r)) for r in rank])\n    namesize = max([len(name) for name in players])\n    ptssize = max([len('%0.1f' % (score,)) for score in scores])\n    SBsize = max([len('%0.2f' % (sbs,)) for sbs in sb])\n    \n    scdetails = [' '.join([(' ' if results[pl[3]][pl1[3]] is None \\\n         else '=' if results[pl[3]][pl1[3]] == 0.5 \\\n         else '1' if results[pl[3]][pl1[3]] == 1 \\\n         else '0').rjust(ranksize) for pl1 in res]) for pl in res]\n    \n    resultat = [\n        '  '.join(['#'.rjust(ranksize), \n         'Player'.ljust(namesize),\n         ' '.join([str(i).rjust(ranksize) for i in range(1, len(players) + 1)]),\n         'Pts'.ljust(ptssize),\n         'SB'.rjust(2+(SBsize-2)//2)\n        ])\n    ]\n    for i in range(len(res)):\n        pl = res[i]\n        ll = [(str(rank[pl[3]]) if i == 0 or rank[pl[3]] != rank[res[i-1][3]] \\\n                               else ' ').rjust(ranksize),\n              players[pl[3]].ljust(namesize),\n              scdetails[i],\n              ('%0.1f' % (pl[0],)).rjust(ptssize),\n              ('%0.2f' % (pl[1],)).rjust(SBsize)]\n        ll = '  '.join(ll)\n        if i == 0: resultat.append('=' * len(ll))\n        resultat.append(ll)\n    return '\\n'.join(resultat)", "def crosstable(players, results):\n    count = len(players)\n    pts = [sum(res[:i] + res[i + 1:]) for res, i in zip(results, range(count))]\n    sb = [sum([r * p for r, p in zip(res, pts) if r is not None]) for res in results]\n\n    l_rank, l_pl = len(str(count)), len(max(players, key=len))\n    l_one_score = len(str(count))\n    l_score = (l_one_score + 1) * count - 1\n    template_pts, template_sb = f\"{{:.1f}}\", f\"{{:.2f}}\"\n    l_pts, l_sb = max([len(template_pts.format(num)) for num in pts]), max([len(template_sb.format(num)) for num in sb])\n    row_len = l_rank + l_pl + l_score + l_pts + l_sb + 8  # 8 is count sep between columns\n\n    template_rank = f\"{{: >{l_rank}}}  {{: <{l_pl}}}  {{: >{l_score}}}  \"\n    template_stat = f\"{{:>{l_pts}.1f}}  {{:>{l_sb}.2f}}\"\n    template_stat_header = f\"{{: ^{l_pts}}}  {{: ^{l_sb}}}\"\n    template_score = f\"{{: >{l_one_score}}}\"\n    header = template_rank.format('#', 'Player', \" \".join([template_score.format(i) for i in range(1, count + 1)])) + \\\n        template_stat_header.format(\"Pts\", \"SB\").rstrip() + \"\\n\" + (\"=\" * row_len) + '\\n'\n    score = []\n    for res in results:\n        score.append([template_score.format(\" \" if el is None else int(el) if el != 0.5 else \"=\") for el in res])\n\n    sort_pts = list(sorted([dict(pts=pts[i], sb=sb[i], ind=i, name=players[i], res=score[i]) for i in range(count)],\n                           key=lambda el: el['pts'], reverse=True))\n    duplicate: bool = False\n    start = 0\n    for i in range(0, count):\n        if not duplicate and i != count-1 and sort_pts[i + 1]['pts'] == sort_pts[i]['pts']:\n            duplicate, start = True, i\n        elif duplicate and (i == count-1 or sort_pts[i + 1]['pts'] != sort_pts[i]['pts']):\n            sort_pts[start:i+1] = sort_by_sb(list(sorted(sort_pts[start:i+1], key=lambda el: el['sb'], reverse=True)),\n                                             rank=start+1)\n            duplicate = False\n        elif not duplicate:\n            sort_pts[i]['rank'] = i + 1\n    order = [rank['ind'] for rank in sort_pts]\n    result = header\n    for row in sort_pts:\n        row['res'] = [row['res'][order[i]] for i in range(count)]\n        result += template_rank.format(row['rank'], row[\"name\"], \" \".join(row['res'])) + \\\n            template_stat.format(row['pts'], row['sb']) + \"\\n\"\n    return result.rstrip()\n\n\ndef sort_by_sb(arr: list, rank: int):\n    duplicate, start, rank_duplicate = False, 0, rank\n    for i in range(len(arr)):\n        if not duplicate and i != len(arr)-1 and arr[i]['sb'] == arr[i + 1]['sb']:\n            duplicate, start, rank_duplicate = True, i, rank\n        elif duplicate and (i == len(arr)-1 or arr[i]['sb'] != arr[i+1]['sb']):\n            arr[start:i + 1] = list(sorted(arr[start:i + 1], key=lambda el: el['name'].split(' ')[1]))\n            for el in arr[start:i + 1]:\n                el['rank'] = \" \"\n            arr[start]['rank'] = rank_duplicate\n            duplicate = False\n        else:\n            arr[i]['rank'] = rank\n        rank += 1\n    return arr", "def crosstable(players, results):\n    count = len(players)\n    pts = [sum(res[:i] + res[i+1:]) for res, i in zip(results, range(count))]\n    sb = [res[i] * pts[i] for res in results for i in range(count) if res[i] is not None]\n    sb = [sum(sb[i * (count - 1): i * (count - 1) + count - 1]) for i in range(count)]\n\n    l_rank, l_pl = len(str(count)), len(max(players, key=len))\n    l_one_score = len(str(count))\n    l_score = (l_one_score + 1) * count - 1\n    template_pts, template_sb = f\"{{:.1f}}\", f\"{{:.2f}}\"\n    l_pts, l_sb = max([len(template_pts.format(num)) for num in pts]), max([len(template_sb.format(num)) for num in sb])\n    row_len = l_rank + l_pl + l_score + l_pts + l_sb + 8  # 8 is count sep between columns\n\n    template_rank = f\"{{: >{l_rank}}}  \"\n    template = f\"{{: <{l_pl}}}  {{: >{l_score}}}  \"\n    template_score = f\"{{:>{l_pts}.1f}}  {{:>{l_sb}.2f}}\"\n    template_score_header = f\"{{: ^{l_pts}}}  {{: ^{l_sb}}}\"\n    template_one_score = f\"{{: >{l_one_score}}}\"\n    header = template_rank.format('#') + \\\n             template.format('Player', \" \".join([template_one_score.format(i) for i in range(1, count+1)])) + \\\n             template_score_header.format(\"Pts\", \"SB\").rstrip() + \"\\n\"\n    delimiter = \"=\" * row_len + '\\n'\n    result = header + delimiter\n    score = []\n    for res in results:\n        score.append([template_one_score.format(\" \" if el is None else int(el) if el != 0.5 else \"=\") for el in res])\n\n    list_sort = [dict(pts=pts[i], sb=sb[i], ind=i, name=players[i], res=score[i]) for i in range(count)]\n    sort_pts = list(sorted(list_sort, key=lambda el: el['pts'], reverse=True))\n    duplicate: bool = False\n    start = 0\n    for i in range(0, count):\n        if not duplicate and i != count-1 and sort_pts[i + 1]['pts'] == sort_pts[i]['pts']:\n            duplicate = True\n            start = i\n        elif duplicate and (i == count-1 or sort_pts[i + 1]['pts'] != sort_pts[i]['pts']):\n            sort_pts[start:i+1] = sort_by_sb(list(sorted(sort_pts[start:i+1], key=lambda el: el['sb'], reverse=True)),\n                                             rank=start+1)\n            duplicate = False\n            continue\n        elif not duplicate:\n            sort_pts[i]['rank'] = i + 1\n    order = [rank['ind'] for rank in sort_pts]\n    for rank in sort_pts:\n        el = rank\n        el['res'] = [el['res'][order[i]] for i in range(count)]\n        s = template_rank.format(el['rank']) + template.format(el[\"name\"], \" \".join(el['res'])) + \\\n            template_score.format(el['pts'], el['sb']) + \"\\n\"\n        result += s\n    return result.rstrip('\\n')\n\n\ndef sort_by_sb(arr: list, rank: int):\n    duplicate, start = False, 0\n    for i in range(len(arr)):\n        if not duplicate and i != len(arr)-1 and arr[i]['sb'] == arr[i + 1]['sb']:\n            arr[i]['rank'] = \" \"\n            duplicate = True\n            start = i\n            rank_duplicate = rank\n        elif duplicate and (i == len(arr)-1 or arr[i]['sb'] != arr[i+1]['sb']):\n            arr[start:i + 1] = list(sorted(arr[start:i + 1], key=lambda el: el['name'].split(' ')[1]))\n            for el in arr[start:i + 1]:\n                el['rank'] = \" \"\n            arr[start]['rank'] = rank_duplicate\n            duplicate = False\n        else:\n            arr[i]['rank'] = rank\n        rank += 1\n    return arr", "def score_string(array, col_width):\n    scoreString = ''\n    for elem in array:\n        if elem is None:\n            to_print = ''\n        elif elem == 0.5:\n            to_print = '='\n        else:\n            to_print = int(elem)\n        scoreString += f\"{to_print:{' '}{'>'}{col_width}}\"\n    return scoreString\n\ndef crosstable(players, results):\n    tournament_results = {}\n    firstnames, lastnames = zip(*[player.split(\" \") for player in players])\n    points_list = []\n    for player_idx, player in enumerate(players):\n        points = sum(filter(None, results[player_idx]))\n        points_list.append(points)\n        tournament_results[player] = {'Pts': points, 'Results': results[player_idx], 'Name': player}\n        \n    SB_list = []\n    for player_idx, player_result in enumerate(results):\n        player_SB = 0\n        for opponent_idx, score in enumerate(player_result):\n            if score is not None and score > 0:\n                player_SB += tournament_results[players[opponent_idx]]['Pts'] * score\n        SB_list.append(player_SB)\n        tournament_results[players[player_idx]]['SB'] = player_SB\n    \n    sorted_points = sorted(range(len(points_list)), key=lambda k: (-points_list[k], -SB_list[k], lastnames[k][0]))\n        \n    for player, data in tournament_results.items():\n        sorted_result = [data['Results'][idx] for idx in sorted_points]\n        tournament_results[player]['Results'] = sorted_result\n    \n    player_ranks = ['1']\n    for rank in range(1,len(players)):\n        cur_player_idx = sorted_points[rank]\n        one_pos_better_player_idx = sorted_points[rank - 1]\n        if points_list[cur_player_idx] == points_list[one_pos_better_player_idx] and SB_list[cur_player_idx] == SB_list[one_pos_better_player_idx]:\n            player_ranks.append('')\n        else:\n            player_ranks.append(str(rank+1))\n    \n    col_spacer = 2\n    delimitter = ' '\n    col_delimitter = col_spacer * delimitter\n    width_rank_col = len(str(len(players)))\n    width_player_col = max([len('Player'), len(max(players, key=len))])\n    width_score_col = width_rank_col + 1\n    width_pts_col = len(str(int(points_list[sorted_points[0]]))) + 2\n    width_SB_col = len(str(int(SB_list[sorted_points[0]]))) + 3\n\n    score_line = score_string(range(1,len(players)+1), width_score_col)\n    col_width = [width_rank_col, col_spacer, width_player_col, 1, len(score_line), col_spacer, width_pts_col, col_spacer, width_SB_col]\n    total_width = sum(col_width)\n    \n    SB_string = f\"{'SB':{' '}{'^'}{width_SB_col}}\".rstrip()\n    header = f\"{'#':{' '}{'>'}{width_rank_col}}\" + col_delimitter + f\"{'Player':{' '}{'<'}{width_player_col}}\" + ' ' + score_line + col_delimitter + f\"{'Pts':{' '}{'^'}{width_pts_col}}\" + col_delimitter + SB_string + '\\n'\n    separator_line = total_width * '=' + '\\n'\n    totalString = header + separator_line\n    for idx in range(len(players)):\n        namePlayer = players[sorted_points[idx]]\n        rankPlayer = player_ranks[idx] \n        scorePlayer = tournament_results[namePlayer]['Results']\n        ptsPlayer = f\"{tournament_results[namePlayer]['Pts']:{' '}{'>'}{width_pts_col}.1f}\"\n        SBPlayer = f\"{tournament_results[namePlayer]['SB']:{' '}{'>'}{width_SB_col}.2f}\"\n        playerString = f\"{rankPlayer:{' '}{'>'}{width_rank_col}}\" + col_delimitter + f\"{namePlayer:{' '}{'<'}{width_player_col}}\" + ' ' + score_string(scorePlayer, width_score_col) + col_delimitter + ptsPlayer + col_delimitter + SBPlayer\n        if idx < len(players)-1:\n            playerString += '\\n'\n        totalString += playerString\n        \n\n    \n    return(totalString)", "def crosstable(players, results):\n    scores=[sum(x for x in result if x) for result in results]\n    sb=[]\n    for i,result in enumerate(results):\n        s=0\n        for j,w in enumerate(result):\n            if w is None:\n                continue\n            s+=w*scores[j]\n        sb.append(s)\n    rank=sorted(list(range(len(players))),key=lambda x:(-scores[x],-sb[x],players[x].split(' ')[1]))\n    no_len=len(str(len(players)))\n    name_len=max(len(p) for p in players)\n    score_len=max(len('{:.1f}'.format(s)) for s in scores)\n    sb_len=max(len('{:.2f}'.format(s)) for s in sb)\n    r=[]\n    title='#'.rjust(no_len)+'  '+'Player'.ljust(name_len)+'  '\n    for i in range(1,len(players)+1):\n        title+=str(i).rjust(no_len)+' '\n    bar='='*len(title)\n    header_sb='SB'.center(sb_len)\n    if sb_len%2==1:\n        header_sb=header_sb[1:]+' '\n    title+=' '+'Pts'.center(score_len)+'  '+header_sb\n    bar+='='*(score_len+sb_len+3)\n    r.append(title.rstrip())\n    r.append(bar)\n    prev_sb=None\n    for i,j in enumerate(rank):\n        if prev_sb and prev_sb==(scores[j],sb[j]):\n            no=' '\n        else:\n            no=str(i+1)\n        line=no.rjust(no_len)+'  '+players[j].ljust(name_len)+'  '+' '*(no_len-1)\n        mat=[]\n        for k in rank:\n            if j==k:\n                mat.append(' ')\n            else:\n                mat.append({0:'0',0.5:'=',1:'1'}[results[j][k]])\n        space=' '*no_len\n        line+=space.join(mat)+'  '\n        score_j='{:.1f}'.format(scores[j])\n        sb_j='{:.2f}'.format(sb[j])\n        line+=score_j.rjust(score_len)+'  '+sb_j.rjust(sb_len)\n        prev_sb=(scores[j],sb[j])\n        r.append(line)\n    return '\\n'.join(r)", "import math\n\ndef crosstable(players, results):\n    scores = {}\n    places = []\n    \n    for s, p in zip(results, players):\n        scores[p] = [sum(y for y in s if y != None)]\n    \n    c = 0\n    for x, p in zip(results, players):\n        scores[p].append(0)\n        for y, p_2 in zip(x, players):\n            if y != None:\n                scores[p][1] += scores[p_2][0] * y\n        scores[p].append(c)\n        c += 1\n    del c\n    \n    for x, y in zip(scores.keys(), scores.values()):\n        for c, z in enumerate(places):\n            if z[0]['score'][0] < y[0] or (z[0]['score'][0] == y[0] and z[0]['score'][1] < y[1]):\n                places.insert(c, [{'Player': x, 'score': y}])\n                break\n            elif z[0]['score'][0] == y[0] and z[0]['score'][1] == y[1]:\n                places[c].append({'Player': x, 'score': y})\n                break\n        else:\n            places.append([{'Player': x, 'score': y}])\n    \n    for c, x in enumerate(places):\n        if len(x) > 1:\n            places[c] = sorted((y for y in x), key=lambda a: a['Player'].split(' ')[1])\n    \n    cur_line = 0\n    display_place = True\n    longest_name = max(len(x) for x in players) + 2\n    longest_score = max(len('{:0.1f}'.format(x[0])) for x in scores.values())\n    longest_SB = max(len('{:0.2f}'.format(x[1])) for x in scores.values())\n    longest_rank = len(str(len(players) - len(places[-1]) + 1))\n    longest_round_number = len(str(len(players)))\n    ans = [\"\", \"\"]\n    new_results = []\n    ids = []\n    \n    for y in places:\n        for a in y:\n            ids.append(a['score'][2])\n    \n    results_in_order = [results[x] for x in ids]\n    \n    for x in results_in_order:\n        new_results.append([])\n        for y in ids:\n            new_results[-1].append(x[y])\n    \n    for x in places:\n        display_place = True\n        for y in x:\n            line = ''\n            if display_place:\n                line += (\" \" * (longest_rank - len(str(cur_line+1) ) ) ) + str(cur_line+1) + \"  \"\n                display_place = False\n            else:\n                line += (\" \" * longest_rank) + \"  \"\n            \n            line += y['Player']\n            spaces = longest_name - len(y['Player']) + (longest_round_number-1)\n            line += \" \" * spaces\n            for x in new_results[cur_line]:\n                if x == None:\n                    line += ' '\n                elif x == 0.5:\n                    line += '='\n                elif x == 1:\n                    line += '1'\n                elif x == 0:\n                    line  += '0'\n                line += ' ' * longest_round_number\n            line = line[:-longest_round_number]\n            len_score = len('{:0.1f}'.format(y['score'][0]))\n            len_SB = len('{:0.2f}'.format(y['score'][1]))\n            line += ('  '+(' ' * (longest_score - len_score)) + '{:0.1f}' + (' ' * (longest_SB - len_SB + 2)) + '{:0.2f}')\\\n            .format(y['score'][0], y['score'][1])\n            cur_line += 1\n            ans.append(line)\n    ans[1] = '=' * len(ans[2])\n    ans[0] = ' ' * (longest_rank - 1) + '#  Player' + ' ' * (longest_name - 6 + longest_round_number - 1)\n    for x in range(1, len(players) + 1):\n        ans[0] += str(x)\n        ans[0] += ' ' * (longest_round_number - len(str(x + 1)) + 1)\n    ans[0] = ans[0].rstrip()\n    ans[0] += '  ' + ' ' * math.floor(longest_score/3 - 1) + 'Pts' + ' ' *  math.ceil(longest_score/3 - 1)\n    ans[0] += '  ' + ' ' * math.floor(longest_SB/2 - 1) + 'SB'\n    return '\\n'.join(ans)", "def crosstable(players, results):\n    playersInputRow = {}\n    playersScores = {}\n    playersSB = {}\n    playersSUM = {}\n    longestName = float('-inf')\n    for number,player in enumerate(players):\n        playersInputRow[player]=number\n        if len(player) > longestName:\n            longestName = len(player)\n        playersScores[player]=0\n        for score in results[number]:\n            if score != None:\n                playersScores[player] += score\n                \n    for number,player in enumerate(players):\n        playersSB[player] = 0\n        for i,score in enumerate(results[number]):\n            if score == 0.5:\n                playersSB[player] += 0.5 * playersScores[players[i]]\n            if score == 1:\n                playersSB[player] += playersScores[players[i]]\n    for player in players:\n        playersSUM[player] = playersScores[player] * 100 + playersSB[player]\n        \n    i=1\n    placments = {}\n    while playersSUM:\n        placments[i] = []\n        maxValue = max(playersSUM.values())\n        for player in playersSUM:\n            if playersSUM[player] == maxValue:\n                placments[i].append(player)\n        for player in placments[i]:\n            del playersSUM[player]\n        i+=1\n        \n        \n    placmentLength = len(str(len(placments)))\n    playersLength = len(str(len(players)))\n    ptsLength = len('{:.1f}'.format(max(playersScores.values())))\n    sbLength = len('{:.2f}'.format(max(playersSB.values())))\n    \n    \n    string=\"\"\n    spaces=\"  \"\n    i=1\n    for place in placments:\n        first=True\n        for player in sorted(sorted(placments[place]), key=lambda s: s.split()[1]):\n            if first==True:\n                string+=str(i).rjust(placmentLength)+spaces\n                first=False\n            else:\n                string+=\"\".rjust(placmentLength)+spaces\n            string+=player.ljust(longestName)+spaces\n            for place2 in placments:\n                for player2 in sorted(sorted(placments[place2]),key=lambda s: s.split()[1]):\n                    result = results[playersInputRow[player]][playersInputRow[player2]]\n                    if result == None:\n                        string+=\" \".rjust(playersLength) + \" \"\n                    elif result == 1:\n                        string+=\"1\".rjust(playersLength) + \" \"\n                    elif result == 0.5:\n                        string+=\"=\".rjust(playersLength) + \" \"\n                    elif result == 0:\n                        string+=\"0\".rjust(playersLength) + \" \"\n            string+=\" \"\n            string += str(\"{:.1f}\".format(playersScores[player])).rjust(ptsLength)+spaces\n            string += str(\"{:.2f}\".format((playersSB[player]))).rjust(sbLength)\n            if place==1:\n                lineLength = len(string)\n            if i != len(players):\n                string+=\"\\n\"\n            i+=1\n            \n    \n    head = \"#\".rjust(placmentLength)+spaces\n    head += \"Player\".ljust(longestName)+spaces\n    for i in range(1,len(players)+1):\n        head += str(i).rjust(playersLength)+\" \"\n    head += \" \"\n    head += \"Pts\".center(ptsLength)+spaces\n    head += \"SB\".center(sbLength-1)\n    while head[-1] == \" \":\n        head = head[:-1]\n    head += \"\\n\"\n    head += \"\".ljust(lineLength, \"=\")+\"\\n\"\n     \n            \n\n    head+=string\n    \n    \n    \n    \n    return head\n            \n            \n\n        \n    \n        \n        \n    \"\"\"\n    \n    return (\n        \"#  Player             1 2 3  Pts  SB\\n\"\n        \"=====================================\\n\"\n        \"1  Boris Spassky        1 =  1.5 1.25\\n\"\n        \"2  Garry Kasparov     0   1  1.0 0.50\\n\"\n        \"3  Viswanathan Anand  = 0    0.5 0.75\")\n     \"\"\"", "import re\n\ndef crosstable(players, results):\n    pts = [sum(r for r in result if r is not None) for result in results]\n    sb = [sum(r*pt for r,pt in zip(result, pts) if r is not None) for result in results]\n    order = sorted(sorted(range(len(players)), key=lambda player:players[player].split(' ')[-1]), key=lambda player:(pts[player],sb[player]), reverse=True)\n    width_rank = len(str(next(rank+1 for rank,player in enumerate(order) if pts[player] == pts[order[-1]] and sb[player] == sb[order[-1]])))\n    width_player = max(len(player) for player in players)\n    width_result = len(str(len(players)))\n    width_pts = len(str(f'{pts[order[0]]:0.1f}'))\n    width_sb = len(str(f'{max(sb):0.2f}'))\n    lines = []\n    lines.append(\n        f'{\"#\":>{width_rank}}  '\n        f'{\"Player\":<{width_player}}  '\n        f'{\" \".join(f\"{i+1:>{width_result}}\" for i in range(len(players)))}  '\n        f'{\"Pts\":^{width_pts}}  '\n        + f'{\"SB\":^{width_sb}}'.rstrip()\n    )\n    lines.append(\"=\"*(width_rank+width_player+(width_result+1)*len(players)+width_pts+width_sb+7))\n    for rank, player in enumerate(order):\n        lines.append(\n            f'{str(rank+1) if rank==0 or pts[order[rank-1]] != pts[player] or sb[order[rank-1]] != sb[player] else \"\":>{width_rank}}  '\n            f'{players[player]:<{width_player}}  '\n            + ' '.join(f'{ {None:\"\", 0:\"0\", 0.5:\"=\", 1:\"1\"}[results[player][opponent]]:>{width_result}}' for opponent in order) + '  ' +\n            f'{pts[player]:>{width_pts}.1f}  '\n            f'{sb[player]:>{width_sb}.2f}'\n        )\n    return '\\n'.join(lines)", "def sortme_sensei(name, ls, ref, p):\n    ref = [val[0] for val in ref]\n    ls = list(zip(ls, p))\n    ls.sort(key=lambda x: ref.index(x[1]))\n    return [val[0] for val in ls]\n\ndef crosstable(players, results):\n    points, i = {v: [float(sum([val for val in x if val != None])), 0, x] for v, x in zip(players, results)}, 0\n    for n in players:\n        indo = results[i]\n        for idx, num in enumerate(indo):\n            if num == 1:\n                points[n][1] += points[players[idx]][0]\n            elif num == 0.5:\n                points[n][1] += points[players[idx]][0] / 2\n        i += 1\n    D = [(p, pts[0], f\"{pts[1]:.2f}\") for p, pts in list(points.items())]\n    sep_points, playa, ptsz, Sb = len(str(len(players))), len(max(players, key=len)) + 2, len(\n        max([str(val[1]) for val in D], key=len)), \\\n                                  len(max([str(val[2]) for val in D], key=len))\n    D.sort(key=lambda x:(-x[1],-float(x[2]),x[0].split()[1]))\n    points = {k: [v[0], v[1], sortme_sensei(k, v[2], D, players)] for k, v in list(points.items())}\n    string = \"#\".rjust(sep_points) + \"  \" + \"Player\".ljust(playa) + \"\".join(\n        str(i).rjust(sep_points + 1) if i - 1 else str(i).rjust(sep_points) for i in range(1, len(players) + 1)) \\\n             + \"  \" + \"Pts\".center(ptsz) + \"  \" + (\n                 \"SB\".center(Sb - 1)[:-1] if \"SB\".center(Sb - 1)[-1] == \" \" else \"SB\".center(Sb - 1)) + \"\\n\"\n    tempo,C = \"\",0\n    for i in range(len(D)):\n        tempo += str(i + 1 if D[i - 1][2] != D[i][2] or D[i - 1][1] != D[i][1] else \"\").rjust(sep_points) + \"  \" + \\\n                  D[i][0].ljust(playa)\n        for idx, res in enumerate(points[D[i][0]][2]):\n            if idx:\n                tempo += res in [1, 0] and str(int(res)).rjust(sep_points + 1) or res == 0.5 and \"=\".rjust(\n                    sep_points + 1) or (sep_points + 1) * \" \"\n            else:\n                tempo += res in [1, 0] and str(int(res)).rjust(sep_points) or res == 0.5 and \"=\".rjust(sep_points) or (\n                    sep_points) * \" \"\n        tempo += \"  \" + str(D[i][1]).rjust(ptsz) + \"  \" + \\\n                  str(D[i][2]).rjust(Sb) + (\"\\n\" if i != len(D) - 1 else \"\")\n        if not C: string += (len(tempo)-1)*\"=\"+\"\\n\" ; C = 1\n    return string+tempo\n"]