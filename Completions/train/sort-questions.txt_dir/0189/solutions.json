["class Solution:\n    def preferences_to_scores(self, preferences):\n        scores = {}\n        for u, up in enumerate(preferences):\n            for s, v in enumerate(up):\n                scores[(u, v)] = s\n        return scores\n    \n    def unhappy_friends(self, scores, a, b):\n        ret = set()\n        for ai, aa in enumerate(a):\n            af = a[1 - ai]\n            for bi, bb in enumerate(b):\n                bf = b[1 - bi]\n                if scores[(aa, bb)] < scores[(aa, af)] and scores[(bb, aa)] < scores[(bb, bf)]:\n                    ret.add(aa)\n                    ret.add(bb)\n        return ret\n    \n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        scores = self.preferences_to_scores(preferences)\n        ret = set()\n        for i, a in enumerate(pairs):\n            for j in range(i):\n                b = pairs[j]\n                ret |= self.unhappy_friends(scores, a, b)\n        return len(ret)\n", "class Solution:\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        \n        preference_list = [[0 for _ in range(n)] for _ in range(n)]\n        \n        for x in range(n):\n            for i, y in enumerate(preferences[x]):\n                preference_list[x][y] = n-i-1\n            \n        #print(preference_list)\n        unhappy={}\n        for i in range(n//2):\n            x,y = pairs[i]\n            for j in range(n//2):\n                u,v = pairs[j]\n                if i!=j:\n                    if ((preference_list[x][y]<preference_list[x][u] and preference_list[u][x]>preference_list[u][v]) or (preference_list[x][y]<preference_list[x][v] and preference_list[v][u]<preference_list[v][x])):\n                        #print(f'X-> x, y : {x, y}; u,v: {u,v}')\n                        unhappy[x]=1\n                    if ((preference_list[y][x]<preference_list[y][u] and preference_list[u][y]>preference_list[u][v]) or (preference_list[y][x]<preference_list[y][v] and preference_list[v][u]<preference_list[v][y])):\n                        #print(f'Y->  y,x : {y,x}; u,v: {u,v}')\n                        unhappy[y]=1\n        #print(unhappy)\n        res = len(unhappy)\n            \n        return res", "class Solution:\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        pref = {}\n        for i in range(len(preferences)):\n            pref[i] = {}\n            plist = preferences[i]\n            for j in range(len(plist)):\n                pref[i][plist[j]] = j\n        print(pref)\n            \n        unhappy = set()\n        for i in range(len(pairs)):\n            for j in range(len(pairs)):                \n                if i == j:\n                    continue\n                for x in pairs[i]:\n                    y = pairs[i][1] if x == pairs[i][0] else pairs[i][0]\n                    for u in pairs[j]:\n                        v = pairs[j][1] if u == pairs[j][0] else pairs[j][0]\n                        if (pref[x][y] > pref[x][u] and pref[u][v] > pref[u][x]):\n                            unhappy.add(x)\n\n\n\n        return len(unhappy)", "class Solution:\n    def unhappyFriends(self, n: int, P: List[List[int]], A: List[List[int]]) -> int:\n        # O(n^3)\n        # have to look at nC2 pairs\n        unhappy = set()\n        for i in range(n//2):\n            for j in range(i+1,n//2):\n                Ai0, Ai1, Aj0, Aj1 = A[i][0], A[i][1], A[j][0], A[j][1]\n                # check all 4 poss\n                # O(n)\n                if P[Ai0].index(Ai1) > P[Ai0].index(Aj0) and P[Aj0].index(Aj1) > P[Aj0].index(Ai0):\n                    unhappy.add(Ai0)\n                    unhappy.add(Aj0)\n                    \n                Ai0, Ai1, Aj0, Aj1 = A[i][1], A[i][0], A[j][0], A[j][1]\n                # check all 4 poss\n                # O(n)\n                if P[Ai0].index(Ai1) > P[Ai0].index(Aj0) and P[Aj0].index(Aj1) > P[Aj0].index(Ai0):\n                    unhappy.add(Ai0)\n                    unhappy.add(Aj0)\n                    \n                Ai0, Ai1, Aj0, Aj1 = A[i][0], A[i][1], A[j][1], A[j][0]\n                # check all 4 poss\n                # O(n)\n                if P[Ai0].index(Ai1) > P[Ai0].index(Aj0) and P[Aj0].index(Aj1) > P[Aj0].index(Ai0):\n                    unhappy.add(Ai0)\n                    unhappy.add(Aj0)\n                    \n                Ai0, Ai1, Aj0, Aj1 = A[i][1], A[i][0], A[j][1], A[j][0]\n                # check all 4 poss\n                # O(n)\n                if P[Ai0].index(Ai1) > P[Ai0].index(Aj0) and P[Aj0].index(Aj1) > P[Aj0].index(Ai0):\n                    unhappy.add(Ai0)\n                    unhappy.add(Aj0)\n                \n                    \n        return len(unhappy)", "class Solution:\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        unhappy = [0] * n\n        for i in range(n//2):\n            a, b = pairs[i]\n            b_a_idx, a_b_idx = preferences[b].index(a), preferences[a].index(b)\n            for j in range(i+1, n//2):\n                c, d = pairs[j]\n                c_a_idx = preferences[c].index(a)\n                c_b_idx = preferences[c].index(b)\n                c_d_idx = preferences[c].index(d)\n                \n                d_a_idx = preferences[d].index(a) \n                d_b_idx = preferences[d].index(b) \n                d_c_idx = preferences[d].index(c) \n                \n                a_c_idx = preferences[a].index(c) \n                a_d_idx = preferences[a].index(d) \n                \n                b_c_idx = preferences[b].index(c) \n                b_d_idx = preferences[b].index(d) \n                \n                # a <-> c\n                if c_a_idx < c_d_idx and a_c_idx < a_b_idx: unhappy[a] = unhappy[c] = 1\n                # a <-> d\n                if d_a_idx < d_c_idx and a_d_idx < a_b_idx: unhappy[a] = unhappy[d] = 1\n                # b <-> c\n                if c_b_idx < c_d_idx and b_c_idx < b_a_idx: unhappy[b] = unhappy[c] = 1\n                # b <-> d\n                if d_b_idx < d_c_idx and b_d_idx < b_a_idx: unhappy[b] = unhappy[d] = 1\n        return sum(unhappy)\n", "class Solution:\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        unhappy = [0] * n\n        for i in range(n//2):\n            a, b = pairs[i]\n            b_a_idx, a_b_idx = preferences[b].index(a), preferences[a].index(b)\n            for j in range(i+1, n//2):\n                c, d = pairs[j]\n                c_a_idx = preferences[c].index(a)\n                c_b_idx = preferences[c].index(b)\n                c_d_idx = preferences[c].index(d)\n                \n                d_a_idx = preferences[d].index(a) \n                d_b_idx = preferences[d].index(b) \n                d_c_idx = preferences[d].index(c) \n                \n                a_c_idx = preferences[a].index(c) \n                a_d_idx = preferences[a].index(d) \n                \n                b_c_idx = preferences[b].index(c) \n                b_d_idx = preferences[b].index(d) \n                \n                # a-c\n                if c_a_idx < c_d_idx and a_c_idx < a_b_idx: \n                    unhappy[a] = unhappy[c] = 1\n                # a-d\n                if d_a_idx < d_c_idx and a_d_idx < a_b_idx: \n                    unhappy[a] = unhappy[d] = 1\n                # b-c\n                if c_b_idx < c_d_idx and b_c_idx < b_a_idx: \n                    unhappy[b] = unhappy[c] = 1\n                # b-d\n                if d_b_idx < d_c_idx and b_d_idx < b_a_idx: \n                    unhappy[b] = unhappy[d] = 1\n        return sum(unhappy)\n", "class Solution:\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        idx_table = collections.defaultdict(lambda: collections.defaultdict(int))\n        for i in range(n):\n            for idx, person in enumerate(preferences[i]): idx_table[i][person] = idx\n                \n        unhappy = [0] * n\n        for i in range(n//2):\n            a, b = pairs[i]\n            b_a_idx, a_b_idx = idx_table[b][a], idx_table[a][b]\n            for j in range(i+1, n//2):\n                c, d = pairs[j]\n                \n                c_a_idx = idx_table[c][a]\n                c_b_idx = idx_table[c][b]\n                c_d_idx = idx_table[c][d]\n                \n                d_a_idx = idx_table[d][a] \n                d_b_idx = idx_table[d][b] \n                d_c_idx = idx_table[d][c] \n                \n                a_c_idx = idx_table[a][c] \n                a_d_idx = idx_table[a][d] \n                \n                b_c_idx = idx_table[b][c] \n                b_d_idx = idx_table[b][d] \n                \n                if c_a_idx < c_d_idx and a_c_idx < a_b_idx: unhappy[a] = unhappy[c] = 1 # a & c prefer each other\n                if d_a_idx < d_c_idx and a_d_idx < a_b_idx: unhappy[a] = unhappy[d] = 1 # a & d prefer each other\n                if c_b_idx < c_d_idx and b_c_idx < b_a_idx: unhappy[b] = unhappy[c] = 1 # b & c prefer each other\n                if d_b_idx < d_c_idx and b_d_idx < b_a_idx: unhappy[b] = unhappy[d] = 1 # b & d prefer each other\n        return sum(unhappy)", "class Solution:\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        res = set()\n        mem = [[0 for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n-1):\n                mem[i][preferences[i][j]] = j+1\n        \n        for i in range(n//2):\n            x = pairs[i][0]\n            y = pairs[i][1]\n            for j in range(i+1, n//2):\n                u = pairs[j][0]\n                v = pairs[j][1]\n                if mem[x][u] < mem[x][y] and mem[u][x] < mem[u][v]:\n                    res.add(x)\n                    res.add(u)\n                if mem[x][v] < mem[x][y] and mem[v][x] < mem[v][u]:\n                    res.add(x)\n                    res.add(v)\n                if mem[y][u] < mem[y][x] and mem[u][y] < mem[u][v]:\n                    res.add(y)\n                    res.add(u)\n                if mem[y][v] < mem[y][x] and mem[v][y] < mem[v][u]:\n                    res.add(y)\n                    res.add(v)\n\n        return len(res)", "import numpy as np\n\nclass Solution:    \n    \n    def check_happy(self,x,y,u,v,fmatrix,unhappy): \n        if(fmatrix[x][u]>fmatrix[x][y] and fmatrix[u][x]>fmatrix[u][v]):\n            unhappy.add(x)\n            unhappy.add(u)\n   \n    def unhappyFriends(self, n, preferences, pairs) -> int:\n        if(n==2):\n            return 0\n        unhappy = set()\n        fmatrix = np.zeros((n,n),dtype=int)\n        for i,friendpref in enumerate(preferences):\n            for j,pref_ind in enumerate(friendpref):\n                fmatrix[i][pref_ind] = n-1-j\n\n        for i in range(n//2-1):\n            for j in range(i+1, n//2):\n                x,y,u,v = pairs[i][0],pairs[i][1],pairs[j][0],pairs[j][1]\n                self.check_happy(x,y,u,v,fmatrix,unhappy)\n                self.check_happy(x,y,v,u,fmatrix,unhappy)\n                self.check_happy(y,x,u,v,fmatrix,unhappy)\n                self.check_happy(y,x,v,u,fmatrix,unhappy)\n                \n                    \n        return len(unhappy)", "import numpy as np\n\nclass Solution:    \n    \n    def check_happy(self,x,y,u,v,fmatrix,unhappy): \n        if(fmatrix[x][u]>fmatrix[x][y] and fmatrix[u][x]>fmatrix[u][v]):\n            unhappy.add(x)\n            unhappy.add(u)\n   \n    def unhappyFriends(self, n, preferences, pairs) -> int:\n        unhappy = set()\n        fmatrix = np.zeros((n,n),dtype=int)\n        for i,friendpref in enumerate(preferences):\n            for j,pref_ind in enumerate(friendpref):\n                fmatrix[i][pref_ind] = n-1-j\n\n        for i in range(n//2-1):\n            for j in range(i+1, n//2):\n                x,y,u,v = pairs[i][0],pairs[i][1],pairs[j][0],pairs[j][1]\n                self.check_happy(x,y,u,v,fmatrix,unhappy)\n                self.check_happy(x,y,v,u,fmatrix,unhappy)\n                self.check_happy(y,x,u,v,fmatrix,unhappy)\n                self.check_happy(y,x,v,u,fmatrix,unhappy)\n                \n                    \n        return len(unhappy)", "class Solution:\n    \n    \n    def get_pair(self, i):\n        for j in self.pairs:\n            if i in j:\n                for k in j:\n                    if k != i:\n                        return k\n                    \n                    \n    def t_happy(self, t, i):\n        pair = self.get_pair(t)\n        for j in self.prefer[t]:\n            if j == pair:\n                return True\n            if j == i:\n                return False\n                    \n                    \n    def happy(self, i, p):\n        prefer = self.prefer[i]\n        if prefer[0] == p:\n            return True\n        for j in range(1, len(prefer)):\n            if not self.t_happy(prefer[j-1], i):\n                return False\n            if prefer[j] == p:\n                return True\n\n    \n    \n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\n        self.prefer = preferences\n        self.pairs = pairs\n        count = 0\n        for i in range(n):\n            p = self.get_pair(i)\n            if not self.happy(i, p):\n                count += 1\n        return count\n"]