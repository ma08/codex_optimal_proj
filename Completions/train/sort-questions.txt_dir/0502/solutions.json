["class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        # 1. Color each component.\n        # colors[node] = the color of this node.\n\n        N = len(graph)\n        colors = {}\n        c = 0\n\n        def dfs(node, color):\n            colors[node] = color\n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n\n        for node in range(N):\n            if node not in colors:\n                dfs(node, c)\n                c += 1\n\n        # 2. Size of each color.\n        # size[color] = number of occurrences of this color.\n        size = collections.Counter(colors.values())\n\n        # 3. Find unique colors.\n        color_count = collections.Counter()\n        for node in initial:\n            color_count[colors[node]] += 1\n\n        # 4. Answer\n        ans = float('inf')\n        for x in initial:\n            c = colors[x]\n            if color_count[c] == 1:\n                if ans == float('inf'):\n                    ans = x\n                elif size[c] > size[colors[ans]]:\n                    ans = x\n                elif size[c] == size[colors[ans]] and x < ans:\n                    ans = x\n\n        return ans if ans < float('inf') else min(initial)    ", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def dfs(node, vis):\n            for connect in range(len(graph[node])):\n                if graph[node][connect] == 1 and connect not in vis:\n                    vis.add(connect)\n                    dfs(connect, vis)\n                    \n        init = set(initial)\n        total_vis = set()\n        del_node, subgraph_len = min(initial), 0\n        for node in range(len(graph)):\n            if node not in total_vis:\n                vis = set([node])\n                dfs(node, vis)\n                infect = vis & init\n                if len(infect) == 1:\n                    if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infect)[0] < del_node):\n                        del_node, subgraph_len = list(infect)[0], len(vis)\n                total_vis |= vis\n        return del_node", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def dfs(node,vis):\n            for v in  range(len(graph[node])):\n                if graph[node][v] == 1 and v not in vis:\n                    vis.add(v)\n                    dfs(v,vis)\n\n        s = set(initial)\n        t_vis = set()\n        del_node, subgraph_len = min(initial), 0\n        for node in range(len(graph)):\n            if node not in t_vis:\n                vis = set([node])\n                dfs(node,vis)\n                # caculate the number of infected node in the subgraph\n                infect = vis & s\n                if len(infect) == 1:\n                    # more number of nodes or smaller index\n                    if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infect)[0] < del_node):\n                        del_node,subgraph_len = list(infect)[0],len(vis)\n                t_vis |= vis\n        return del_node\n", "from itertools import count\nfrom collections import Counter\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        # color the components\n        colors = dict()\n        c = count()\n        \n        def dfs(node, color):\n            colors[node] = color\n            \n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n                    \n        for node in range(len(graph)):\n            if node not in colors:\n                dfs(node, next(c))\n        \n        \n        # count sizes of each component\n        size = Counter(list(colors.values()))\n        \n        \n        # find components with only one malware inside\n        malware_count = Counter()\n        for node in initial:\n            malware_count[colors[node]] += 1\n            \n        #print(malware_count)\n        #print(size)\n        \n        # find the component with the most nodes and only 1 malware\n        ans = None\n        ans_nodes = 0\n        for x in initial:\n            c = colors[x]\n            if malware_count[c] != 1:\n                continue\n            if size[c] > ans_nodes:\n                ans = x\n                ans_nodes = size[c]\n            elif size[c] == ans_nodes:\n                ans = min(ans, x)\n                \n        return ans if ans else min(initial)\n", "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        # 1. Color each component.\n        # colors[node] = the color of this node.\n\n        N = len(graph)\n        colors = {}\n        c = 0\n\n        def dfs(node, color):\n            colors[node] = color\n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n\n        for node in range(N):\n            if node not in colors:\n                dfs(node, c)\n                c += 1\n\n        # 2. Size of each color.\n        # size[color] = number of occurrences of this color.\n        size = collections.Counter(list(colors.values()))\n\n        # 3. Find unique colors.\n        color_count = collections.Counter()\n        for node in initial:\n            color_count[colors[node]] += 1\n\n        # 4. Answer\n        ans = float('inf')\n        for x in initial:\n            c = colors[x]\n            if color_count[c] == 1:\n                if ans == float('inf'):\n                    ans = x\n                elif size[c] > size[colors[ans]]:\n                    ans = x\n                elif size[c] == size[colors[ans]] and x < ans:\n                    ans = x\n\n        return ans if ans < float('inf') else min(initial)\n    \n    \n# Algorithm\n\n# This algorithm has a few parts:\n\n# Coloring each component: For each node, if it isn't yet colored, use a depth-first search to traverse its component, coloring that component with a new color.\n\n# Size of each color: Count the number of occurrences of each color.\n\n# Find unique colors: Look at the colors of nodes in initial to see which nodes have unique colors.\n\n# Choose answer: For each node with a unique color, find the size of that color. The largest size is selected, with ties broken by lowest node number.\n\n# If there is no node with a unique color, the answer is min(initial).\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        if len(graph) == 0:\n            return 0\n        \n        g = dict()\n        \n        for i in range(len(graph)):\n            for j in range(len(graph[i])):\n                if graph[i][j]:\n                    if i in g:\n                        g[i].append(j)\n                    else:\n                        g[i] = [j]\n        \n        groups = []\n        initialSet = set(initial)\n        numOfNodes = [0] * len(graph)\n        \n        for v, e in list(g.items()):\n            if v not in initialSet:\n                continue\n            num = 1\n            initialSet.remove(v)\n            group = [v]\n            stack = e\n            visited = {v}\n            while len(stack) != 0:\n                vertex = stack.pop()\n                if vertex not in visited:\n                    if vertex in initialSet:\n                        initialSet.remove(vertex)\n                        group.append(vertex)\n                    stack.extend(g[vertex])\n                    visited.add(vertex)\n                    num += 1\n            groups.append(group)\n            numOfNodes[v] = num\n                \n        \n        canRemove = set([group[0] for group in groups if len(group) == 1])\n        # print(groups)\n        # print(numOfNodes)\n        # print(canRemove)\n        \n        if len(canRemove) == 0:\n            return min(initial)\n        \n        result = -1\n        for vertex in initial:\n            if vertex in canRemove and (result == -1 or numOfNodes[vertex] > numOfNodes[result]):\n                result = vertex\n            elif vertex in canRemove and numOfNodes[vertex] == numOfNodes[result] and vertex < result:\n                result = vertex\n        \n        return result\n        \n        \n        \n        \n       \n            \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        #coloring each component (belong to different connected components)\n        #count the size of each color\n        #find unique nodes in initial\n        #for each node with a unique color, choose the largest size, if there is a tie, choose the one with the smaller index\n        N = len(graph)\n        colors = {}# colors[node] = the color of this node.\n        c = 0\n        def dfs(node, color):\n            colors[node] = color\n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:#nei in colors\u7684\u60c5\u51b5\u90fd\u8003\u8651\u8fc7\u4e86\n                    dfs(nei, color)\n        for node in range(N):\n            if node not in colors:\n                dfs(node, c)\n                c += 1\n        size = collections.Counter(list(colors.values()))# size[color] = number of occurrences of this color.\n        color_count = collections.Counter()\n        for node in initial:\n            color_count[colors[node]] += 1\n        ans = -1# the index of node to be removed\n        for x in initial:\n            if color_count[colors[x]] == 1:\n                if ans == -1:\n                    ans = x\n                elif size[colors[x]] > size[colors[ans]]:\n                    ans = x\n                elif size[colors[x]] == size[colors[ans]] and x < ans:\n                    ans = x\n        return ans if ans != -1 else min(initial)#why we need to remove the minimum of initial, it won't reduce the malware count\n", "class Solution:\n    def minMalwareSpread(self, graph, initial):\n        def dfs(i):\n            nodes.add(i)\n            for j in range(len(graph[i])):\n                if graph[i][j] and j not in nodes:\n                    dfs(j)\n        rank = {}\n        initial = set(initial)\n        # rank, initial = collections.defaultdict(list), set(initial)\n        for node in sorted(initial):\n            nodes = set()\n            dfs(node)\n            rank[node] = nodes\n        print(rank)\n        \n        passed = []\n        for k,v in list(rank.items()):\n            count = 0\n            for i in initial:\n                if i in v:\n                    count += 1\n            if count <= 1:\n                passed.append((k, len(v)))\n        passed.sort(key = lambda x:x[1], reverse=True)\n        if len(passed) == 0:\n            return min(initial)\n        else:\n            return passed[0][0]\n            \n        \n    \n        # return min(initial)\n            \n        #     if nodes & initial == {node}:\n        #         rank[len(nodes)].append(node)\n        # return rank[max(rank)][0] if rank else min(initial)\n", "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        def dfs(node,vis):\n            for v in  range(len(graph[node])):\n                if graph[node][v] == 1 and v not in vis:\n                    vis.add(v)\n                    dfs(v,vis)\n\n        s = set(initial)\n        t_vis = set()\n        del_node, subgraph_len = min(initial), 0\n        for node in range(len(graph)):\n            if node not in t_vis:\n                vis = set([node])\n                dfs(node,vis)\n                # caculate the number of infected node in the subgraph\n                infect = vis & s\n                if len(infect) == 1:\n                    # more number of nodes or smaller index\n                    if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infect)[0] < del_node):\n                        del_node,subgraph_len = list(infect)[0],len(vis)\n                t_vis |= vis\n        return del_node", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def dfs(i):\n            nodes.add(i)\n            for j in range(len(graph[i])):\n                if graph[i][j] and j not in nodes:\n                    dfs(j)\n        rank, initial = collections.defaultdict(list), set(initial)\n        for node in sorted(initial):\n            nodes = set()\n            dfs(node)\n            if nodes & initial == {node}:\n                rank[len(nodes)].append(node)\n        return rank[max(rank)][0] if rank else min(initial)", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        #Graph represented as an adjaency matrix        \n        #Loop through infected\n        #Simulate condition of what would happen if only this infected node is removed\n        #If num infected is the new min -> then we have a potential answer\n        \n        infected_nodes = set(initial)\n        max_infected = len(graph)\n        node_to_remove = initial[0]\n        \n        for infected_node in initial:\n            infected_nodes.remove(infected_node)\n            infected = set()\n            for node in infected_nodes:\n                self.dfs(node, graph, infected)\n                \n            infected_nodes.add(infected_node)\n            if len(infected) < max_infected or (len(infected) == max_infected and infected_node < node_to_remove):\n                node_to_remove = infected_node\n                max_infected = len(infected)\n        return node_to_remove\n        #Loop through the infected nodes\n        #Do a traversal to simulate an \\\"infection\\\"\n        #Count number of nodes infected and track max infected\n        \n    def dfs(self, node, graph, infected):\n        infected.add(node)\n        for col, val in enumerate(graph[node]):\n            if val == 1 and col not in infected:                \n                self.dfs(col, graph, infected)\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        #Graph represented as an adjaency matrix        \n        #Loop through infected\n        #Simulate condition of what would happen if only this infected node is removed\n        #If num infected is the new min -> then we have a potential answer\n        \n        infected_nodes = set(initial)\n        max_infected = len(graph)\n        node_to_remove = initial[0]\n        \n        for infected_node in initial:\n            infected_nodes.remove(infected_node)\n            infected = set()\n            for node in infected_nodes:\n                self.dfs(node, graph, infected)\n                \n            infected_nodes.add(infected_node)\n            if len(infected) < max_infected or (len(infected) == max_infected and infected_node < node_to_remove):\n                node_to_remove = infected_node\n                max_infected = len(infected)\n        return node_to_remove\n        #Loop through the infected nodes\n        #Do a traversal to simulate an \\\"infection\\\"\n        #Count number of nodes infected and track max infected\n        \n    def dfs(self, node, graph, infected):\n        infected.add(node)\n        for col, val in enumerate(graph[node]):\n            if val == 1 and col not in infected:                \n                self.dfs(col, graph, infected)\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        #dfs to find all node in a subgraph, only subgraph with 1 infected node can be saved as we can remove only one node\n        init = set(initial)\n        total_visited = set()\n        res, max_subgraph_len = min(initial), 0\n        for node in range(len(graph)):\n            if node not in total_visited:\n                visited = set([node])\n                self.dfsConnected(graph, node, visited)\n                #find infected node in subgraph\n                infected = visited & init\n                if len(infected) == 1:\n                    if len(visited) > max_subgraph_len or (len(visited) == max_subgraph_len and min(infected) < res):\n                        res, max_subgraph_len = min(infected), len(visited)\n                total_visited |= visited\n        return res\n    \n    def dfsConnected(self, graph, node, visited):\n        for neighbor in range(len(graph[node])):\n            if graph[node][neighbor] == 1 and neighbor not in visited:\n                visited.add(neighbor)\n                self.dfsConnected(graph, neighbor, visited)", "class Solution:\n    def minMalwareSpread(self, graph, initial):\n        def dfs(i):\n            nodes.add(i)\n            for j in range(len(graph[i])):\n                if graph[i][j] and j not in nodes:\n                    dfs(j)\n        rank, initial = collections.defaultdict(list), set(initial)\n        for node in sorted(initial):\n            nodes = set()\n            dfs(node)\n            if nodes & initial == {node}:\n                rank[len(nodes)].append(node)\n        return rank[max(rank)][0] if rank else min(initial)", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        #This is special case where all the nodes are initially infected, see which one connected least\n        if len(initial) == len(graph):\n            m = 0\n            r = initial[0]\n            for i in initial:\n                if m < sum(x == 0 for x in graph[i]):\n                    m = sum(x==0 for x in graph[i])\n                    r = i\n            return r\n            \n        \n        d = collections.defaultdict(list)\n        for init in initial:\n            q = collections.deque()\n            q.append(init)\n            visit = set() #only cache the current initial infect node\n            visit.add(init)\n            while q:\n                virus = q.popleft()\n                for i in range(len(graph[virus])):\n                    if graph[virus][i] == 0 or i in visit:\n                        continue\n                    visit.add(i)\n                    d[i].append(init)\n                    q.append(i)\n        res = [0]*len(graph)\n        for m in d:\n            if len(d[m]) == 1:\n                res[d[m][0]] += 1\n        print(d)\n        if max(res) == 0:\n            return min(initial)\n        return res.index(max(res))\n        '''\n        51 of 52 passed, only [1,1,0][1,1,0][0,0,1] with [0,1 2] not passing\n        d = collections.defaultdict(list)\n        for init in initial:\n            q = collections.deque()\n            q.append(init)\n            visit = set()\n            visit.add(init)\n            while q:\n                virus = q.popleft()\n                for i in range(len(graph[virus])):\n                    if graph[virus][i] == 0 or i in visit:\n                        continue\n                    visit.add(i)\n                    d[i].append(init)\n                    q.append(i)\n        res = [0]*len(graph)\n        for m in d:\n            if len(d[m]) == 1:\n                res[d[m][0]] += 1\n        print(d)\n        if max(res) == 0:\n            return min(initial)\n        return res.index(max(res))\n        '''", "class Solution:\n    # def findRoot(self, parents, index):\n    #     root = index\n    #     while parents[root] != root:\n    #         root = parents[root]\n    #     while root != index:\n    #         temp = parents[index]\n    #         parents[index] = root\n    #         index = temp\n    #     return root\n    #\n    # def creatParents(self, graph):\n    #     node_num = len(graph)\n    #     parents = [i for i in range(node_num)]\n    #     for i in range(node_num):\n    #         for j in range(i + 1, node_num):\n    #             if graph[i][j] == 1:\n    #                 root_i = self.findRoot(parents, i)\n    #                 root_j = self.findRoot(parents, j)\n    #                 if root_i != root_j:\n    #                     parents[root_i] = root_j\n    #     return parents\n    #\n    # def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n    #     initial_num = len(initial)\n    #     node_num = len(graph)\n    #     if initial_num <= 0 or node_num <= 0:\n    #         return 0\n    #     if initial_num==1:\n    #         return initial[0]\n    #\n    #     parents = self.creatParents(graph)\n    #     node_info = [0] * node_num  # \u5404\u8282\u70b9\u5708\u4e2d\u7684\u8282\u70b9\u6570\n    #     for i in range(node_num):\n    #         root = self.findRoot(parents, i)\n    #         node_info[root] += 1\n    #\n    #     # \u627e\u51fainitial\u79cd\u8282\u70b9\u5708\u6700\u5927\u7684\u8282\u70b9\n    #     index = initial[0]\n    #     max = -1\n    #     for i in range(initial_num):\n    #         root = self.findRoot(parents, initial[i])\n    #         if node_info[root] > max or (node_info[root] == max and initial[i] < index):\n    #             max = node_info[root]\n    #             index = initial[i]\n    #     return index\n\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        initial.sort()\n        visited = []\n        result = [-1, 0]  # index,count\n\n        for i in range(len(graph)):\n            if i in visited:\n                continue\n            else:\n                temp = [-1, 0]\n                stack = [i]\n                visited.append(i)\n                stack_num = 1;\n                while stack:\n                    index = stack.pop(0)\n                    if index in initial:\n                        if temp[0] == -1:\n                            temp[0] = index\n                        temp[1] += 1\n                    for j in range(len(graph[index])):\n                        if graph[index][j] == 1 and (j not in visited):\n                            stack.append(j)\n                            stack_num += 1\n                            visited.append(j)\n                if temp[1] == 1:\n                    if result[1] < stack_num:\n                        result[0] = temp[0]\n                        result[1] = stack_num\n        return result[0] if result[0] != -1 else initial[0]\n\n", "import math\nimport queue\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        if len(initial) == 0:\n            return 0\n        best = None\n        best_val = math.inf\n    \n        initial_set = set(initial)\n        for index in initial:\n            initial_set.remove(index)\n            \n            seen = set()\n            Q = queue.Queue()\n            for elt in initial_set:\n                seen.add(elt)\n                Q.put(elt)\n            \n            while not Q.empty():\n                u = Q.get()\n                \n                for i, v in enumerate(graph[u]):\n                    if v == 0 or i in seen:\n                        continue \n                    \n                    seen.add(i)\n                    Q.put(i)\n            if len(seen) < best_val:\n                best_val = len(seen)\n                best = index\n            elif len(seen) == best_val and index < best:\n                best = index\n            initial_set.add(index)\n        return best\n                    \n                    \n            \n            \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        \n        heap = []\n        sizes = {}\n        component = 0\n        \n        for i in initial:\n          #print(\\\"graph\\\", graph, heap)\n          if graph[i][i] < 0:\n            heappush(heap, (-sizes[component], i, graph[i][i]))\n            continue\n          \n          queue = deque([i])\n          #print(\\\"outer queue\\\", queue)\n          size = 0\n          component = component - 1\n          \n          while len(queue) > 0:\n\n            current = queue.popleft()\n            #print(current)\n\n            if graph[current][current] == 1:\n              size = size + 1\n              graph[current][current] = component\n              queue.extend(i for (i, x) in enumerate(graph[current]) if x == 1)\n              #print(\\\"queue\\\", current, queue)\n              \n          heappush(heap, (-size, i, component))\n          sizes[component] = size\n            \n        #print(\\\"final heap\\\", heap)\n        \n        return self.select(heap)\n      \n    def select(self, heap):\n      \n      if len(heap) == 1:\n        return heap[0][1]\n      \n      res = heappop(heap)\n      others = []\n      while len(heap) > 0 and res[0] == heap[0][0] and res[2] == heap[0][2]:\n        others.append(heappop(heap))\n      \n      if len(others) == 1 and len(heap) == 0 or len(others) == 0:\n        return res[1]\n      \n      if len(heap) == 0:\n        return res[1]\n      \n      return self.select(heap)", "import math\nimport queue\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        if len(initial) == 0:\n            return 0\n        best = None\n        best_val = math.inf\n    \n        initial.sort()\n        initial_set = set(initial)\n        for index in initial:\n            initial_set.remove(index)\n            \n            seen = set()\n            Q = queue.Queue()\n            for elt in initial_set:\n                seen.add(elt)\n                Q.put(elt)\n            \n            while not Q.empty():\n                u = Q.get()\n                \n                for i, v in enumerate(graph[u]):\n                    if v == 0 or i in seen:\n                        continue \n                    \n                    seen.add(i)\n                    Q.put(i)\n            if len(seen) < best_val:\n                best_val = len(seen)\n                best = index\n            initial_set.add(index)\n        return best\n                    \n                    \n            \n            \n", "import heapq\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        nodes = set(initial)\n        useless = set()\n        best = 0\n        initial.sort()\n        index = initial[0]\n        def dfs(start):\n            count = 0\n            stack = [start]\n            visited = set()\n            while stack:\n                curr = stack.pop()\n                if curr in visited:\n                    continue\n                if curr != start and curr in nodes:\n                    useless.add(curr)\n                    useless.add(start)\n                visited.add(curr)\n                count += 1\n                for i in range(len(graph[curr])):\n                    if graph[curr][i]:\n                        stack.append(i)\n            return count\n        for i in initial:\n            g = dfs(i)\n            if i not in useless:\n                if g > best:\n                    best = g\n                    index = i\n        return index", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        numNodes = len(graph)\n        minSpread = float('inf')\n        minNode = None\n        initial.sort()\n        \n        for i in initial:\n            visited = set()\n            for j in initial:\n                if j != i:\n                    self.helper(graph,j,visited)\n                    \n            if len(visited) < minSpread:\n                minSpread = len(visited)\n                minNode = i\n                \n        return minNode\n    \n    def helper(self,graph,curr,visited):\n        if curr in visited:\n            return\n        \n        edges = graph[curr]\n        visited.add(curr)\n        \n        for i in range(len(edges)):\n            if graph[curr][i] == 1:\n                self.helper(graph,i,visited)", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        visited = [False] * len(graph)\n        sizes = [0] * len(graph)\n        for node in range(len(graph)):\n            if visited[node]:\n                continue\n            vertices = []\n            numOfInitials = self.dfs(graph, node, visited, vertices, initial)\n            size = len(vertices)\n            for i in vertices:\n                sizes[i] = size if numOfInitials < 2 else 0\n        maxSpread = -1\n        maxNode = -1\n        for i in initial:\n            print(i)\n            if sizes[i] > maxSpread:\n                maxSpread = sizes[i]\n                maxNode = i\n            elif sizes[i] == maxSpread:\n                maxNode = min(maxNode, i)\n        return maxNode\n    \n    def dfs(self, graph, node, visited, vertices, initial):\n        initials = 0\n        if visited[node]:\n            return initials\n        vertices.append(node)\n        visited[node] = True\n        if node in initial:\n            initials += 1\n        for i in range(len(graph[node])):\n            if graph[node][i] == 1:\n                initials += self.dfs(graph, i, visited, vertices, initial)\n        return initials\n        \n", "class Solution:\n    \n    def calcConnectedNodes(self, graph, node):\n        visited = set()\n        toVisit = []\n        toVisit.append(node)\n        while len(toVisit) != 0:\n            \n            curNode = toVisit.pop()\n            if curNode in visited:\n                continue\n            visited.add(curNode)\n            for i in range(len(graph[curNode])):\n                if graph[curNode][i] == 1:\n                    toVisit.append(i)\n        return visited\n            \n            \n        \n    \n    \n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        initialSet = set(initial)\n        maxNodesConnected = -1\n        nodeToRemove = -1\n        for node in initial:\n            connectedNodes = self.calcConnectedNodes(graph, node)   \n            intersected = connectedNodes.intersection(initialSet)\n            # even if i removed this node, there are other nodes that will infect it, so no need\n            if len(intersected) >= 2:\n                continue\n            if maxNodesConnected == -1 or len(connectedNodes) > maxNodesConnected or (len(connectedNodes) == maxNodesConnected and node < nodeToRemove):\n                nodeToRemove = node\n                maxNodesConnected = len(connectedNodes)\n        if nodeToRemove == -1:\n            return min(initial)\n        return nodeToRemove\n", "class Solution:\n    \n    def calcConnectedNodes(self, graph, node):\n        visited = set()\n        toVisit = []\n        toVisit.append(node)\n        while len(toVisit) != 0:\n            \n            curNode = toVisit.pop()\n            if curNode in visited:\n                continue\n            visited.add(curNode)\n            for i in range(len(graph[curNode])):\n                if graph[curNode][i] == 1:\n                    toVisit.append(i)\n        return visited\n    \n    \n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        initialSet = set(initial)\n        maxNodesConnected = -1\n        nodeToRemove = -1\n        for node in initial:\n            connectedNodes = self.calcConnectedNodes(graph, node)   \n            intersected = connectedNodes.intersection(initialSet)\n            # even if i removed this node, there are other nodes that will infect it, so no need\n            if len(intersected) >= 2:\n                continue\n            if maxNodesConnected == -1 or len(connectedNodes) > maxNodesConnected or (len(connectedNodes) == maxNodesConnected and node < nodeToRemove):\n                nodeToRemove = node\n                maxNodesConnected = len(connectedNodes)\n        if nodeToRemove == -1:\n            return min(initial)\n        return nodeToRemove\n", "from collections import defaultdict\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        edges = defaultdict(list)\n        for i in range(len(graph)):\n            for j in range(len(graph[i])):\n                if(graph[i][j] == 1):\n                    edges[i].append(j)\n        #maps nodes to their color  \n        colors = defaultdict(int)\n        #counts the number of nodes in that colored connected component\n        nodes_in_colors = defaultdict(int)\n        color = 1\n        for node in initial:\n            if(colors[node] == 0):\n                colors[node] = color\n            else:\n                continue\n            stack = [node]\n            visited = set()\n            curr_infected = 0\n            while(stack):\n                curr = stack.pop()\n                curr_infected += 1\n                for neigh in edges[curr]:\n                    if(neigh not in visited):\n                        stack.append(neigh)\n                        visited.add(neigh)\n                        colors[neigh] = color\n            nodes_in_colors[color] = curr_infected\n            color += 1\n        #maps color to initial nodes of that color\n        initial_color = defaultdict(list)\n        for node in initial:\n            initial_color[colors[node]].append(node)\n        print(initial_color)\n        unique_color = defaultdict(int)\n        #only look for unique colors/ components with unique colors\n        for node in initial:\n            unique_color[colors[node]] += 1\n        \n        unique = []\n        for color in unique_color:\n            if(unique_color[color] == 1):\n                unique.append(initial_color[color][0])\n        if(len(unique) == 0):\n            return min(initial)\n        \n        max_infected = 0\n        min_node = float('inf')\n        print(unique)\n        for node in unique:\n            if(nodes_in_colors[colors[node]] >= max_infected):\n                max_infected = nodes_in_colors[colors[node]]\n                min_node = min(node, min_node)\n        return min_node\n                \n                \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        d = collections.defaultdict(list)\n        initial.sort()\n        \n        for i in range(len(graph)):\n            for j in range(len(graph[i])):\n                if i != j and graph[i][j]==1:\n                    d[i].append(j)\n                else:\n                    d[i].append(100)\n                    d[i].pop()\n        print(d)\n            \n        infected = set(initial)\n        \n        maxinfected=float('inf')\n        res=0\n        for i in range(len(initial)):\n            self.curr_infected = 0\n            infected.remove(initial[i])\n            \n            visited = set()\n            for item in infected:\n                self.dfs(item,d,visited,infected,True)\n            \n            print((self.curr_infected))\n            if self.curr_infected < maxinfected:\n                maxinfected=self.curr_infected\n                res = initial[i]\n                \n            infected.add(initial[i])\n            \n        return res\n    \n    def dfs(self,curr,d,visited,infected,original_node):\n        if curr in visited:\n            return\n        if curr in infected and not original_node:\n            return\n        original_node = False\n        \n        # mark visitied\n        visited.add(curr)\n        self.curr_infected += 1\n        \n        # grab neighbors\n        neighbors = d[curr]\n        \n        for next in neighbors:\n            self.dfs(next,d,visited,infected,original_node)\n        \n", "class Solution:\n    def minMalwareSpread(self, graph, initial):\n        # dfs\n        def dfs(node, visited):\n            if node in initial:\n                return 0\n            visited.add(node)\n            res = 1\n            for nxt_node, v in enumerate(graph[node]):\n                if v == 0 or nxt_node == node: continue\n                if nxt_node not in visited:\n                    sub = dfs(nxt_node, visited)\n                    if sub == 0:\n                        return 0\n                    res += sub\n            return res\n        \n        initial = set(initial)\n        res = [-1, 0]\n        for n in list(initial):\n            initial.discard(n)\n            res = max([dfs(n, set()), -n], res)\n            initial.add(n)\n        return -res[1]\n        \n    def minMalwareSpread_I(self, graph, initial):\n        def find(x):\n            if x != parents[x]:\n                parents[x] = find(parents[x])\n            return parents[x]\n        def union(x, y):\n            parents[find(x)] = find(y)\n        # init\n        n = len(graph)\n        parents = list(range(n))\n        # union\n        for i in range(n):\n            for j in range(i + 1, n):\n                if graph[i][j] == 1:\n                    union(i, j)\n        area = collections.Counter(find(i) for i in range(n))\n        malware = collections.Counter(find(i) for i in initial)\n        return min(initial, key=lambda i: [(malware[find(i)] == 1) * -area[find(i)], i])\n\n    def minMalwareSpread_II(self, graph: List[List[int]], initial: List[int]) -> int:\n        union_mem = {i:i for i in range(len(graph))}\n        count = collections.Counter(range(len(graph)))\n        \n        def find(vertex):\n            if union_mem[vertex] != vertex:\n                union_mem[vertex] = find(union_mem[vertex])\n            return union_mem[vertex]\n        \n        def union(v1, v2):\n            v1f, v2f = find(v1), find(v2)\n            if v1f != v2f:\n                count[v1f] += count[v2f]\n                union_mem[v2f] = v1f\n        \n        N = len(graph)\n        for r in range(N):\n            for c in range(N):\n                if r != c and graph[r][c] == 1:\n                    union(r, c)\n        groups = collections.defaultdict(list)\n        for v1 in initial:\n            v1f = find(v1)\n            groups[v1f].append(v1)\n        return -max(([count[find(v1)], -v1] for v1 in initial if len(groups[find(v1)]) == 1), default = [0, -min(initial)])[1]", "from collections import defaultdict\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        size = Counter()\n        color = defaultdict(int)\n        \n        def dfs(node, c):\n            color[node] = c\n            size[c] += 1\n            for nextNode, val in enumerate(graph[node]):\n                if val and nextNode not in color:\n                    dfs(nextNode, c)\n        \n        c = 0\n        for node in range(len(graph)):\n            if node not in color:\n                dfs(node, c)\n                c += 1\n        \n        # find node with unique color\n        color_count = Counter()\n        for node in initial:\n            color_count[color[node]] += 1\n            \n        # if unique color, ans is node color with greatest size else smallest index\n        ans = -1\n        for node in initial:\n            c = color[node]\n            if color_count[c] == 1:\n                if ans == -1:\n                    ans = node\n                elif size[c] > size[color[ans]]:\n                    ans = node\n                elif size[c] == size[color[ans]] and node < ans:\n                    ans = node\n        if ans == -1:\n            return min(initial)\n        return ans", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        minNode = -1\n        maxSpread = 0\n        for node in initial:\n            testInit = initial.copy()\n            testInit.remove(node)\n            touch,testSpread = touchAnyNodes([node],graph,testInit)\n            #print (str(node) + \\\" \\\" + str(touch) + \\\" \\\" + str(testSpread) )\n            if not touch:\n                if testSpread > maxSpread or (testSpread == maxSpread and node < minNode):\n                    maxSpread = testSpread\n                    minNode = node\n        if maxSpread == 0:\n            initial.sort()\n            return initial[0]\n        return minNode\n\ndef touchAnyNodes(visited,graph,infected) -> (bool,int):\n    newVisited = visited.copy()\n    for node in visited:\n        for idx in range(len(graph[node])):\n            if graph[node][idx] == 1 and (not idx in visited) and (not idx in newVisited):\n                if idx in infected:\n                    return True,0\n                newVisited.append(idx)\n    if len(newVisited) == len(visited):\n        return False,len(visited)\n    return touchAnyNodes(newVisited,graph,infected)\n", "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        # 1. Color each component.\n        # colors[node] = the color of this node.\n\n        N = len(graph)\n        colors = {}\n        c = 0\n\n        def dfs(node, color):\n            colors[node] = color\n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n\n        for node in range(N):\n            if node not in colors:\n                dfs(node, c)\n                c += 1\n\n        # 2. Size of each color.\n        # size[color] = number of occurrences of this color.\n        size = collections.Counter(colors.values())\n\n        # 3. Find unique colors.\n        color_count = collections.Counter()\n        for node in initial:\n            color_count[colors[node]] += 1\n\n        # 4. Answer\n        ans = float('inf')\n        for x in initial:\n            c = colors[x]\n            if color_count[c] == 1:\n                if ans == float('inf'):\n                    ans = x\n                elif size[c] > size[colors[ans]]:\n                    ans = x\n                elif size[c] == size[colors[ans]] and x < ans:\n                    ans = x\n\n        return ans if ans < float('inf') else min(initial)  ", "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        def dfs(node, visited):\n            for neighbor in range(len(graph[node])):\n                if graph[node][neighbor] == 1 and neighbor not in visited:\n                    visited.add(neighbor)\n                    dfs(neighbor, visited)\n        \n        res, max_size = min(initial), 0\n        i_set = set(initial)\n        total_visited = set()\n        for node in range(len(graph)):\n            if node not in total_visited:\n                visited = {node}\n                dfs(node, visited)\n                infected = visited & i_set\n                if len(infected) == 1:\n                    if len(visited) > max_size or (len(visited) == max_size and list(infected)[0] < res):\n                        res = list(infected)[0]\n                        max_size = len(visited)\n                total_visited |= visited\n        return res\n                                                 \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        N = len(graph)\n        colors = {}\n        c = 0\n\n        def dfs(node, color):\n            colors[node] = color\n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n\n        for node in range(N):\n            if node not in colors:\n                dfs(node, c)\n                c += 1\n\n        size = collections.Counter(colors.values())\n\n        color_count = collections.Counter()\n        for node in initial:\n            color_count[colors[node]] += 1\n\n        ans = float('inf')\n        for x in initial:\n            c = colors[x]\n            if color_count[c] == 1:\n                if ans == float('inf'):\n                    ans = x\n                elif size[c] > size[colors[ans]]:\n                    ans = x\n                elif size[c] == size[colors[ans]] and x < ans:\n                    ans = x\n\n        return ans if ans < float('inf') else min(initial)    ", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def dfs(node,vis):\n            for v in  range(len(graph[node])):\n                if graph[node][v] == 1 and v not in vis:\n                    vis.add(v)\n                    dfs(v,vis)\n\n        s = set(initial)\n        t_vis = set()\n        del_node, subgraph_len = min(initial), 0\n        for node in range(len(graph)):\n            if node not in t_vis:\n                vis = set([node])\n                dfs(node,vis)\n                # caculate the number of infected node in the subgraph\n                infect = vis & s\n                if len(infect) == 1:\n                    # more number of nodes or smaller index\n                    if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infect)[0] < del_node):\n                        del_node,subgraph_len = list(infect)[0],len(vis)\n                t_vis |= vis\n        return del_node\n#         def find(x):\n#             if x != parents[x]:\n#                 parents[x] = find(parents[x])\n#             return parents[x]\n        \n#         def union(x, y):\n#             parents[find(x)] = find(y)\n            \n#         n = len(graph)\n#         parents = list(range(n))\n#         for i in range(n):\n#             for j in range(i + 1, n):\n#                 if graph[i][j] == 1:\n#                     union(i, j)\n                    \n#         union = collections.Counter(find(i) for i in range(n))\n#         print(union)\n#         malware = collections.Counter(find(i) for i in initial)\n#         print(malware)\n        \n#         save, res = 0, min(initial)\n#         for i in initial:\n#             if malware[find(i)] == 1:\n#                 if union[find(i)] > save:\n#                     save, res = union[find(i)], i\n#                 elif union[find(i)] == save:\n#                     res = min(res, i)\n#         return res\n        \n#         # return min(initial, key=lambda x: [(malware[find(x)] == 1) * -union[find(x)], x])\n                    \n        \n", "# from collections import deque\n# import heapq\n\n# class Solution:\n#     def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n#         groups = {}\n#         group_counter = 0\n        \n#         contains_malware = []\n#         malware_set = set(initial)\n        \n#         visited = set()\n#         for i in range(len(graph)):\n#             group_counter += 1\n#             if i not in visited:\n#                 queue = deque()\n#                 queue.append(i)\n#                 while queue:\n#                     node = queue.popleft()\n#                     visited.add(node)\n#                     if node in malware_set:\n#                         contains_malware.append((node, group_counter))\n#                     if group_counter not in groups:\n#                             groups[group_counter] = 1\n#                     else:\n#                         groups[group_counter] += 1\n#                     for candidate_node, flag in enumerate(graph[node]):\n#                         if flag == 1 and candidate_node not in visited:\n#                             queue.append(candidate_node)\n                            \n                            \n#         if len(initial) == len(graph):\n#             individuals = []\n#             for node, i in contains_malware:\n#                 if groups[i] == 1:\n#                     individuals.append(node)\n#             individuals.sort()\n#             return individuals[0]\n#         else:\n#             contains_malware = [(-groups[i], node) for node, i in contains_malware]\n#             heapq.heapify(contains_malware)\n#             return contains_malware[0][1]\n                        \nimport collections\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        # 1. Color each component.\n        # colors[node] = the color of this node.\n\n        N = len(graph)\n        colors = {}\n        c = 0\n\n        def dfs(node, color):\n            colors[node] = color\n            for nei, adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, color)\n\n        for node in range(N):\n            if node not in colors:\n                dfs(node, c)\n                c += 1\n\n        # 2. Size of each color.\n        # size[color] = number of occurrences of this color.\n        size = collections.Counter(list(colors.values()))\n\n        # 3. Find unique colors.\n        color_count = collections.Counter()\n        for node in initial:\n            color_count[colors[node]] += 1\n\n        # 4. Answer\n        ans = float('inf')\n        for x in initial:\n            c = colors[x]\n            if color_count[c] == 1:\n                if ans == float('inf'):\n                    ans = x\n                elif size[c] > size[colors[ans]]:\n                    ans = x\n                elif size[c] == size[colors[ans]] and x < ans:\n                    ans = x\n\n        return ans if ans < float('inf') else min(initial)  \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        parents = {}\n        \n        def find(parents, i):\n            c = i\n            while parents[c] != c:\n                c = parents[c]\n            parents[i] = c\n            return c\n        \n        def union(parents, i, j):\n            parents[find(parents, i)] = find(parents, j)\n            \n        for u in range(len(graph)):\n            if u not in parents:\n                parents[u] = u\n            for v in range(len(graph[u])):\n                if v not in parents:\n                    parents[v] = v\n                if graph[u][v] == 1:\n                    union(parents, u, v)\n        \n        malware_count = collections.defaultdict(int)\n        for i in initial:\n            malware_count[find(parents, i)] += 1\n        comp_size = collections.defaultdict(int)\n        for k in parents.keys():\n            comp_size[find(parents, k)] += 1\n\n        largest_comp = None\n        largest_size = 0\n        for i in initial:\n            k = find(parents, i)\n            v = malware_count[k]\n            if v == 1:\n                if comp_size[k] > largest_size:\n                    largest_size = comp_size[k]\n                    largest_comp = [i]\n                elif comp_size[k] == largest_size:\n                    largest_comp.append(i)\n        if largest_comp:\n            return min(largest_comp)\n        return min(initial)", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        colors = {}\n        c = 0\n        def dfs(node, graph, c):\n            colors[node]=c\n            for nei,adj in enumerate(graph[node]):\n                if adj and nei not in colors:\n                    dfs(nei, graph, c)\n        # group into colors\n        for i in range(len(graph)):\n            if i not in colors:\n                dfs(i, graph, c)\n                c+=1\n        size = collections.Counter(list(colors.values()))\n        # group nodes from initial to have unique color\n        init_count = collections.defaultdict(int)\n        for node in initial:\n            init_count[colors[node]]+=1\n        # find ans\n        ans = float('inf')\n        for x in initial:\n            if init_count[colors[x]]==1:\n                if ans==float('inf'):\n                    ans = x\n                elif size[colors[x]]>size[colors[ans]]:\n                    ans = x\n                elif size[colors[x]]==size[colors[ans]] and x<ans:\n                    ans = x\n        return ans if ans!=float('inf') else min(initial)\n        \n\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        s = set(initial)\n        go_visit = set()\n        del_node, length = min(initial), 0\n        def helper(node, visit):\n            for i in range(len(graph[node])):\n                if graph[node][i] == 1 and i not in visit:\n                    visit.add(i)\n                    helper(i, visit)\n        for node in range(len(graph)):\n            if node not in go_visit:\n                visit = set()\n                visit.add(node)\n                helper(node, visit)\n                temp = visit & s\n                if len(temp) == 1:\n                    if length < len(visit) or (length == len(visit) and list(temp)[0] < del_node):\n                        del_node = list(temp)[0]\n                        length = len(visit)\n                go_visit |= visit\n        return del_node\n                    \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def method1():\n            N=len(graph)\n            colors={}\n            c=0\n            \n            def dfs(node,color):\n                colors[node]=color\n                for nei,adj in enumerate(graph[node]):\n                    if adj==1 and nei not in colors:\n                        dfs(nei,color)\n            \n            for node in range(N):\n                if node not in colors:\n                    dfs(node,c)\n                    c+=1\n                    \n            size=collections.Counter(colors.values())\n            \n            color_count=collections.Counter()\n            for node in initial:\n                color_count[colors[node]]+=1\n                \n            \n            ans=float('inf')\n            for initial_node in initial:\n                c=colors[initial_node]\n                if color_count[c]==1:\n                    if ans==float('inf'):\n                        ans=initial_node\n                    elif size[c]>size[colors[ans]]:\n                        ans=initial_node\n                    elif size[c]==size[colors[ans]] and initial_node<ans:\n                        ans=initial_node\n            \n            return ans if ans<float('inf') else min(initial)\n        #return method1()\n    \n        \n        def method2():\n            def dfs(node,vis):\n                for v in  range(len(graph[node])):\n                    if graph[node][v] == 1 and v not in vis:\n                        vis.add(v)\n                        dfs(v,vis)\n\n            s = set(initial)\n            seen = set()\n            del_node, subgraph_len = min(initial), 0\n            for node in range(len(graph)):\n                if node not in seen:\n                    vis = set([node])\n                    dfs(node,vis)\n                    # caculate the number of infected node in the subgraph\n                    infect = vis & s\n                    if len(infect) == 1:\n                        # more number of nodes or smaller index\n                        if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infect)[0] < del_node):\n                            del_node,subgraph_len = list(infect)[0],len(vis)\n                    seen |= vis\n            return del_node\n        \n        return method2()", "class DSU():\n    \n    def __init__(self):\n        self.parent={}\n        self.size={}\n    \n    def find(self,x):\n        if x!=self.parent[x]:\n            self.parent[x]=self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self,x,y):\n        xp,yp=self.find(x),self.find(y)\n        if xp==yp:\n            return False\n        if self.size[xp]<self.size[yp]:\n            xp,yp=yp,xp\n        \n        self.size[xp]+=self.size[yp]\n        self.parent[yp]=xp\n        return True\n\n    def add_node(self,x):\n        self.parent[x]=x\n        self.size[x]=1\n\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        initial.sort()\n        edges=[]\n        for i in range(len(graph)):\n            for j in range(i+1,len(graph[0])):\n                if graph[i][j]:edges.append([i,j])\n        \n        dsu=DSU()\n        for i in range(len(graph)):\n            dsu.add_node(i)\n            \n        for e1,e2 in edges:\n            if e1!=e2: dsu.union(e1,e2)\n        ans=initial[0]\n        m=len(graph)+1\n        for i in initial:\n            \n            mt=self.get_max_size(initial,dsu,i)\n            if mt<m:\n                m=mt\n                ans=i\n        return ans\n        \n    \n    def get_max_size(self,initial,dsu,di):\n        x=0\n        parents=set([])\n        for i in initial:\n            if i!=di:\n                parents.add(dsu.find(i))\n        \n        for n in dsu.parent:\n            if dsu.find(n) in parents:\n                x+=1\n        return x\n        \n        \n            \n        \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        # DFS: O(N^2) Time, O(N) Space\n        # Tricky: [[1,1,0],[1,1,0],[0,0,1]], [0,1,2] -> If we remove 0, 1 can still infect 0 and we end up with 3 infected nodes. If we remove 2, we end up with 2 infected nodes -> SO we cant remove the node with the highest number of neighbors\n        # New algorithm: We need to know which nodes are in the same component -> then no point in removing them since the other nodes would still infect it eventually\n        \n        # 1. Color each component\n        # colors[node] = the color of this node.\n        sizeComponents = defaultdict(int)\n        nodesToComponents = defaultdict(int)\n        c = 0\n        def dfs(node, c):\n            sizeComponents[c] += 1\n            nodesToComponents[node] = c\n            for neighbor in range(len(graph[node])):\n                if graph[node][neighbor] == 1 and node != neighbor:\n                    if neighbor not in nodesToComponents:\n                        dfs(neighbor, c)\n                        \n                    \n        for node in range(len(graph)):\n            if node not in nodesToComponents:\n                dfs(node, c)\n                c += 1\n        \n        # 2. Map initial node to the size of their components\n        # initialComponents = defaultdict(int)\n        # for node in initial:\n        #     component = nodesToComponents[node]\n        #     initialComponents[node] = sizeComponents[component]\n        \n        # 2. Apparently, the question wants you to find which nodes in initial are in unique components\n        initialComponents = defaultdict(int)\n        for node in initial:\n            component = nodesToComponents[node]\n            initialComponents[component] += 1\n            \n        # 3. Find node with unique component, i.e. size of component == 1\n        res = float('inf')\n        for node in initial:\n            component = nodesToComponents[node]\n            size = sizeComponents[component]\n            if initialComponents[component] == 1: # if this is the only\n                if res == float('inf'):\n                    res = node\n                elif size > sizeComponents[nodesToComponents[res]]:\n                    res = node\n                elif size == sizeComponents[nodesToComponents[res]] and node < res:\n                    res = node\n\n        return res if res < float('inf') else min(initial)    ", "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        def dfs(node,vis):\n            for v in  range(len(graph[node])):\n                if graph[node][v] == 1 and v not in vis:\n                    vis.add(v)\n                    dfs(v,vis)\n\n        s = set(initial)\n        t_vis = set()\n        del_node, subgraph_len = min(initial), 0\n        for node in range(len(graph)):\n            if node not in t_vis:\n                vis = set([node])\n                dfs(node,vis)\n                # print(vis)\n                # caculate the number of infected node in the subgraph\n                infect = vis & s\n                # print(\\\"infect: \\\", infect)\n                if len(infect) == 1:\n                    # more number of nodes or smaller index\n                    if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infect)[0] < del_node):\n                        del_node,subgraph_len = list(infect)[0],len(vis)\n                t_vis |= vis\n                # print(t_vis)\n        return del_node", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def dfs(node):\n            nodes.add(node)\n            for i in range(len(graph[node])):\n                if i not in nodes and graph[node][i] == 1:\n                    dfs(i)\n        \n        rank, initial = collections.defaultdict(list), set(initial)\n        for node in initial:\n            nodes = set()\n            dfs(node)\n            #print(\\\"For initial node:\\\", node, \\\"the set is:\\\", nodes, \n            #     \\\"intersection is:\\\", sorted(nodes & initial))\n            if len(nodes & initial) == 1:\n                rank[len(nodes)].append(node)\n        #print(\\\"Rank is:\\\", rank)\n        return rank[max(rank)][0] if rank else min(initial)\n", "class DisjointSetUnion:\n    def __init__(self):\n        self._parent = {}\n        self._size = {}\n    \n    def union(self, a: int, b: int) -> None:\n        a, b = self.find(a), self.find(b)\n        if a == b:\n            return\n        if self._size[a] < self._size[b]:\n            a, b = b, a\n        self._parent[b] = a\n        self._size[a] += self._size[b]\n    \n    def find(self, x: int) -> int:\n        if x not in self._parent:\n            self._parent[x] = x\n            self._size[x] = 1\n            return x\n        \n        while self._parent[x] != x:\n            self._parent[x] = self._parent[self._parent[x]]\n            x = self._parent[x]\n        \n        return self._parent[x]\n    \n    def size(self, x: int) -> int:\n        return self._size[self.find(x)]\n    \nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        dsu = DisjointSetUnion()\n        \n        for u, neighborhood in enumerate(graph):\n            for v, is_connected in enumerate(neighborhood):\n                if is_connected:\n                    dsu.union(u, v)\n        \n        parent_count = collections.Counter(dsu.find(u) for u in initial)\n        best_index = best_count = -1\n        \n        for index in initial:\n            count = dsu.size(index) if parent_count[dsu.find(index)] == 1 else 0\n            \n            if count > best_count or (count == best_count and index < best_index):\n                best_index, best_count = index, count\n        \n        return best_index", "from collections import deque \nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        if graph is None or len(graph) ==0 or len(graph[0]) ==0 or len(initial) ==0:\n            return None \n    \n        n = len(graph)\n        m = len(graph[0])\n        k = len(initial)\n        initial.sort()\n        \n                        \n        result = sys.maxsize \n        idx = None \n        for i in range(k):\n            temp_q = initial[:]\n            temp_q.pop(i)\n            temp_q = deque(temp_q)\n            temp_visited = set(temp_q)\n            \n            self.helper(graph, temp_q, temp_visited)\n            if result > len(temp_visited):\n                result = len(temp_visited)\n                idx = initial[i]\n        \n        return idx \n    \n    def helper(self, graph, temp_q, temp_visited):\n        \n        n, m = len(graph), len(graph[0])\n        \n        while temp_q:\n            curr = temp_q.popleft()\n            for col in range(m):\n                if col in temp_visited or graph[curr][col] ==0:\n                    continue \n                temp_visited.add(col)\n                temp_q.append(col)\n        \n                    \n        \n            \n            \n            \n        \n        \n            \n           \n          \n        \n        \n        \n        \n", "class Solution:\n\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        class UF():\n            def __init__(self, keys):\n                self.uf = {}\n                for key in keys:\n                    self.uf[key] = key\n\n            def find(self, x):\n                if self.uf[x] == x:\n                    return x\n                ret = self.find(self.uf[x])\n                self.uf[x] = ret\n                return ret\n\n            def union(self, x, y):\n                xx = self.find(x)\n                yy = self.find(y)\n                self.uf[xx] = yy\n        uf = UF(range(len(graph)))\n        for i in range(len(graph)):\n            for j in range(len(graph[i])):\n                if graph[i][j] == 1:\n                    uf.union(i, j)\n        ct = collections.Counter([uf.find(x) for x in range(len(graph))])\n        ct2 = collections.Counter([uf.find(x) for x in initial])\n        initial.sort()\n        ret = initial[0]\n        score = 0\n        for idx in initial:\n            parent = uf.find(idx)\n            if ct2[parent] > 1:\n                continue\n            if ct[parent] > score:\n                score = ct[parent]\n                ret = idx\n        return ret"]