["class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        for i,r in enumerate(ranges):\n            l = max(0,i-r)\n            ranges[l] = max(i+r, ranges[l])\n            \n        res = lo = hi = 0            \n        while hi < n:\n            lo, hi = hi, max(ranges[lo:hi+1])\n            if hi == lo: return -1\n            res += 1\n        return res ", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        if not ranges: return 0\n        N = len(ranges)\n        # For all location of taps, store the largest right reach point\n        max_right_end = list(range(N))\n        for i, a in enumerate(ranges):\n            max_right_end[max(i - a, 0)] = min(i + a, N-1)\n        print(max_right_end)\n        res, l, r = 0, 0, max_right_end[0]\n        while True:\n            res += 1\n            # if r can reach to the end of the whole garden, return res\n            if r>=N-1:return res\n            new_r = max(max_right_end[l:r+1])\n            # if next r is same as current r, it means we can not move forward, return -1\n            if new_r == r:return -1\n            l, r = r, new_r\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n#         from collections import defaultdict\n        \n#         if n==0:\n#             return -1\n        \n#         plots = defaultdict(list)\n#         for i in range(n):\n#             l, r = i - ranges[i], i + ranges[i]\n#             for j in [k for k in range(n) if k>=l and k<=r]:\n#                 plots[j].append(i)\n        \n#         print(plots)\n#         if len(plots.keys()) == n:\n#             for i in plots.items():\n#                 print(i)\n#         else:\n#             return -1\n\n        def parse_ranges(ranges):\n            intervals = []\n            \n            for idx, distance in enumerate(ranges):\n                left = max(0, idx-distance)\n                right = min(n, idx+distance)\n                intervals.append([left, right])\n            \n            return intervals\n        \n        watered = []\n        intervals = parse_ranges(ranges)\n        intervals.sort(key=lambda time: (time[0], -time[1]))\n        for start, end in intervals:\n            if watered and watered[-1][1] >= end: \n                continue\n            if watered and start - watered[-1][1] > 0: \n                return -1\n            \n            if len(watered) >= 2 and start <= watered[-2][1]:\n                # print(watered, (start,end))\n                watered[-1] = [start, end]\n            else:\n                watered.append([start, end])\n        \n        return len(watered) if watered[-1][-1] >= n else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+2] * n\n        for i, x in enumerate(ranges):\n            for j in range(max(i-x+1, 0), min(i+x, n) + 1):\n                dp[j] = min(dp[j], dp[max(i-x, 0)] + 1)\n        return dp[n] if dp[n] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+2] * n\n        for i, v in enumerate(ranges):\n            for j in range(max(0, i-v+1), min(n, i+v)+1):\n                dp[j] = min(dp[j], dp[max(0, i-v)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        def dfs(i):   \n            if i == -1: return [0] + [n+2]*n\n            dp = dfs(i-1)\n            x = ranges[i]\n            for j in range(max(i-x, 0), min(i+x, n) + 1):\n                dp[j] = min(dp[j], dp[max(i-x, 0)] + 1)\n            return dp\n                \n        dp = dfs(n)\n        return dp[n] if dp[n] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+2] * n \n        for i in range(len(ranges)):\n            x = ranges[i]\n            for j in range(max(i-x, 0), min(i+x, n) + 1):\n                dp[j] = min(dp[j], dp[max(i-x, 0)] + 1 )\n                \n        return dp[n] if dp[n] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+2] * n\n        for i in range(len(ranges)):\n            x = ranges[i]\n            for j in range(max(i-x+1, 0), min(i+x, n) + 1):\n                dp[j] = min(dp[j], dp[max(i-x, 0)] + 1)\n        return dp[n] if dp[n] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [n+2] * n + [0]\n        for i in range(len(ranges)-1, -1, -1):\n            x = ranges[i]\n            for j in range(max(i-x, 0), min(i+x, n) + 1):\n                dp[j] = min(dp[j], dp[min(i+x, n)] +1 )\n                \n        return dp[0] if dp[0] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+2] * n\n        def dfs(i):   \n            x = ranges[i]\n            for j in range(max(i-x, 0), min(i+x, n) + 1):\n                dp[j] = min(dp[j], dp[max(i-x, 0)] + 1)\n        for i in range(len(ranges)):\n            dfs(i)\n        return dp[n] if dp[n] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # dp[i] min taps to water [0, i]\n        # dp[0] = 0\n        dp = [0] + [n+2] * n # n+1 is possible value\n        for i, v in enumerate(ranges):\n            left = max(i-v, 0)\n            right = min(i+v, n)\n            for j in range(left+1, right+1):\n                dp[j] = min(dp[j], dp[max(0, i-v)]+1)\n        if dp[n] < n+2:\n            return dp[n]\n        return -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp=[n+2]*(n+1)\n        dp[0]=0\n        for i in range(n+1):\n            for j in range(max(0,i-ranges[i])+1, min(n, i+ranges[i])+1):\n                dp[j]=min(dp[j], dp[max(0,i-ranges[i])]+1)\n        print(dp)\n        return dp[-1] if dp[-1]<n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+2] * n\n        for i, x in enumerate(ranges):\n            for j in range(max(i-x, 0), min(i+x, n) + 1):\n                dp[j] = min(dp[j], dp[max(i-x, 0)] + 1)\n        return dp[n] if dp[n] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+2] * n\n        def dfs(i):   \n            if i == -1: return [0] + [n+2]*n\n            dp = dfs(i-1)\n            x = ranges[i]\n            for j in range(max(i-x, 0), min(i+x, n) + 1):\n                dp[j] = min(dp[j], dp[max(i-x, 0)] + 1)\n            return dp\n                \n        dp = dfs(n)\n        return dp[n] if dp[n] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges) -> int:\n        dp = [0] + [n + 2] * n\n        for i, x in enumerate(ranges):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1", "class Solution:\n    def minTaps(self, n, A):\n        dp = [0] + [n + 2] * n\n        for i, x in enumerate(A):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges) -> int:\n        dp = [0] + [float('inf')] * n\n        for i, x in enumerate(ranges):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        print(dp)\n        return dp[n] if dp[n] != float('inf') else -1", "class Solution:\n    def minTaps(self, n, A):\n        dp = [0] + [n + 2] * n\n        for i, x in enumerate(A):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        if dp[-1] < n + 2:\n            return dp[-1]\n        return -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        min_range, max_range, open_taps = 0, 0 ,0\n        \n        while max_range < n:\n            for i, r in enumerate(ranges):\n                if i - r <= min_range and i + r >= max_range:\n                    max_range = i + r\n            \n            if min_range == max_range:\n                return -1\n            open_taps += 1\n            min_range = max_range\n        \n        return open_taps\n", "class Solution:\n    def minTaps(self, n, A):\n        dp = [0] + [n + 2] * n\n        for i, x in enumerate(A):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1\n            \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n + 2] * n\n        for i, x in enumerate(ranges):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        lowest_missing = 0\n        taps = 0\n        while lowest_missing < n:\n            highest = None\n            for (idx, tap) in enumerate(ranges):\n                if idx - tap > lowest_missing or idx + tap < lowest_missing + 1:\n                    continue\n                    \n                if highest is None or highest < idx + tap:\n                    highest = idx + tap\n                \n            if highest is None:\n                return -1\n            \n            lowest_missing = highest\n            taps += 1\n            \n        return taps\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp=[sys.maxsize]*(n+1)\n        dp[0]=0\n        for i in range(n+1):\n            for j in range(max(0,i-ranges[i]),(min(n,i+ranges[i]))+1):\n                    dp[j]=min(dp[j],1+dp[max(0,i-ranges[i])])\n            \n        if(dp[n]==sys.maxsize):\n            return -1\n        return dp[n]\n            \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+1] * n\n        \n        for i, x in enumerate(ranges):\n            for j in range(max(i- x + 1, 0), min(n,i+x)+ 1):\n                dp[j] = min(dp[j], dp[max(0,i-x)]+ 1)\n        return dp[n] if dp[n]!=n+1 else -1\n        # dp = [0] + [n + 2] * n\n        # for i, x in enumerate(ranges):\n        #     for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n        #         dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        # return dp[n] if dp[n] < n + 2 else -1\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+2]*n\n        for i, r in enumerate(ranges):\n            for j in range(max(0, i-r+1), min(n, i+r)+1):\n                dp[j] = min(dp[j], dp[max(0, i-r)]+1)\n        return dp[n] if dp[n] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n + 2] * n\n        for i, x in enumerate(ranges):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1\n                    \n                \n                \n            \n            \n        \n                \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        res = 0\n        DP = [float('inf')] * (n+1)\n        farest = 0\n        DP[0] = 0\n        for i, r in enumerate(ranges):\n            for x in range(max(i-r, 0), min(i+r+1, n+1)):\n                DP[x] = min(DP[x], DP[max(i-r, 0)]+1)\n        return DP[-1] if DP[-1] != float('inf') else -1\n                \n            \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n#         max_range = [0] * (n + 1)\n#         for idx, r in enumerate(ranges):\n#             left, right = max(0, idx - r), min(n, idx + r)\n#             max_range[left] = max(max_range[left], right - left)\n        \n#         # it's a jump game now\n#         start, end, step = 0, 0, 0\n#         while end < n:\n#             step += 1\n#             start, end = end, max(i + max_range[i] for i in range(start, end + 1))\n#             if start == end:\n#                 return -1\n#         return step\n        \n\n        \n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        for idx, r in enumerate(ranges):\n            for j in range(max(idx - r + 1, 0), min(idx + r, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, idx - r)] + 1)\n        return dp[n] if dp[n] < float('inf') else -1\n        # dp = [0] + [float('inf')] * n\n        # for idx, r in enumerate(ranges):\n        #     for j in range(max(idx - r + 1, 0), min(idx + r, n) + 1):\n        #         dp[j] = min(dp[j], dp[max(0, idx - r)] + 1)\n        # return dp[n] if dp[n] < float('inf') else -1\n", "class Solution:\n    \n    def minTaps1(self, n: int, ranges: List[int]) -> int:\n        intervals = []\n        for i in range(n+1):\n            if ranges[i]:\n                left = max(0, i - ranges[i])\n                right = min(n, i + ranges[i])\n                intervals.append((left, right))\n        intervals.sort()\n        res = 0\n        max_pos = 0\n        prev_max_pos = -1\n        for i, j in intervals:\n            # max_pos >= n: all range covered\n            if max_pos >= n:\n                break\n            # i > max_pos: [max_pos, i] not covered\n            if i > max_pos:\n                return -1\n            elif prev_max_pos < i <= max_pos: # (i, j) will cover new interval\n                res = res + 1\n                prev_max_pos = max_pos\n                print((i, j), res)\n            max_pos = max(max_pos, j)\n        return res if max_pos >= n else -1\n        \n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n + 1] * n\n        for i, x in enumerate(ranges):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        # print(dp)\n        return dp[n] if dp[n] < n + 1 else -1", "from heapq import heappush, heappop \nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n                \n        taps_by_start = []  # ranked by start\n        for i, r in enumerate(ranges):\n            if r != 0:\n                tap = (max(0, i-r), i+r) # start, end\n                heappush(taps_by_start, tap)\n        # print(taps_by_start)\n\n        taps_by_end = [] # the largest end at top \n        current_min = 0\n        num_of_pipe= 0\n        \n        while current_min < n:\n            while taps_by_start and taps_by_start[0][0] <= current_min:\n                tap = heappop(taps_by_start)\n                tap_reverse = (-tap[1], tap[0])\n                heappush(taps_by_end, tap_reverse)\n\n            if taps_by_end:\n                next_pipe = heappop(taps_by_end)  # -end, start\n                current_min = - next_pipe[0]\n                num_of_pipe +=1 \n            else: \n                return -1 \n        \n        return num_of_pipe \n         \n", "#[Runtime: 1212 ms, faster than 5.27%] DP\n#O(N * 200)\n#f(i): the minimum number of taps that we can cover range: 0~i and i is opended\n#Since 0~n is already sorted sequence of number\n#f(i) = 1 if ranges[i][BEGIN] <= 0\n#f(i) = min( f(j) where max(0, ranges[i][BEGIN]-100) <= j < i and ranges[j][END] >= ranges[i][BEGIN] ) + 1\n#NOTE: WA: return min { f(i) if i + ranges[i][END] >= n }\nfrom math import inf\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [inf] * (n+1)\n        for i in range(n+1):\n            if not ranges[i]:\n                continue #skip impossible tapes to prevent from empty arg of `min`\n            s = i - ranges[i]\n            if s <= 0:\n                dp[i] = 1\n            else:\n                dp[i] = 1 + min([dp[j] for j in range(max(0, s - 100), i) if ranges[j] and j + ranges[j] >= s] + [inf])\n        res = min([dp[i] for i in range(n+1) if ranges[i] and i + ranges[i] >= n] + [inf])\n        return res if res != inf else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        min_range, max_range, open_taps, idx = 0, 0 ,0, 0\n        \n        while max_range < n:\n            for i in range(len(ranges)):\n                if i - ranges[i] <= min_range and i + ranges[i] >= max_range:\n                    max_range = i + ranges[i]\n            \n            if min_range == max_range:\n                return -1\n            open_taps += 1\n            min_range = max_range\n        \n        return open_taps\n", "class Solution:\n    def minTaps(self, n, A):\n        dp = [0] + [n + 2] * n\n        for i, x in enumerate(A):\n            left = i- x\n            right = i+x\n            for j in range(max(left+1, 0), min(right, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, left)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n        dp = [n+2 for i in range(n+1)]\n        dp[0] = 0\n        \n        for i, r in enumerate(ranges):\n            for j in range(max(0, i-r), min(len(ranges), i+r+1)):\n                dp[j] = min(dp[j], dp[max(0, i-r)] + 1)\n        \n        print(dp)\n        return dp[-1] if dp[-1] < n+2 else -1\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = {i: 2*n for i in range(n+1)}\n        dp[0] = 0\n        for i in range(0, n+1):\n            for j in range(max(0, i-ranges[i]), min(n+1, i+ranges[i]+1)):\n                dp[j] = min(dp[j], dp[max(0, i-ranges[i])] + 1)\n        # print(dp)\n        return dp[n] if dp[n] < 2*n else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [0] + [n+2] * n\n        for i, value in enumerate(ranges):\n            for j in range(max(i-value,0), min(i+value, n) + 1):\n                dp[j] = min(dp[j], dp[max(i-value, 0)] + 1)\n    \n        return dp[n] if dp[n] < n+2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        farthestRightAt = [-1] * (n+1)\n        for i, r in enumerate(ranges):\n            if r == 0:\n                continue\n            left = i-r\n            right = i+r\n            for j in range(max(0, left), min(right+1, n+1)):\n                farthestRightAt[j] = min(n, max(farthestRightAt[j], right))\n                \n        if -1 in farthestRightAt:\n            return -1\n        i = 0\n        count = 0\n        while i < n:\n            i = farthestRightAt[i]\n            count += 1\n        return count", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n        sorted_ranges = ([(max(0,i-v), min(n, i+ v)) for i,v in enumerate(ranges)])\n        dicts = {}\n        for i in sorted_ranges:\n            dicts[i[0]] = max(i[1], dicts.get(i[0], -10e9))\n        \n        reduced_ranges = sorted([(k,v) for k, v in dicts.items()])\n        \n        \n        prev_max = max_e = reduced_ranges[0][1]\n        min_start = reduced_ranges[0][0]\n        \n        \n        taps = 1\n        i = 0\n        s,e = reduced_ranges[i]\n        print(reduced_ranges)\n        \n        while max_e < n:\n            # print(\\\"cluster\\\", s, e, prev_max, \\\"reached to \\\" ,max_e, \\\"with\\\" , taps)\n            taps += 1\n            while True:\n                s,e = reduced_ranges[i + 1]\n                \n                if s > prev_max: \n                    # print(\\\"break at i\\\",s,e, i)\n                    break\n                    \n                max_e = max(e, max_e)\n                # print(reduced_ranges[i], \\\"new_max\\\", max_e)\n                i += 1\n                \n                \n                if max_e >= n:\n                    # print(\\\"last one\\\")\n                    return taps\n            \n            if max_e == prev_max:\n                return -1\n            prev_max = max_e\n            max_e = max_e\n                \n        return taps ", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        taps=[]\n        for i in range(len(ranges)):\n            taps.append((i-ranges[i],i+ranges[i]))\n        \n        taps.sort()\n        @lru_cache(None)\n        def helper(i):\n            # minimum number of taps to open if we open i to reach end\n            if i>=n+1:return float('inf')\n            if taps[i][1]>=n:return 1\n            ans=float('inf')\n            # lets do binary search here\n            \n            for j in range(i+1,n+1):\n                if taps[j][0]>taps[i][1]:\n                    break\n                if taps[j][0]<=taps[i][1] and taps[j][1]>taps[i][1]:\n                    # benefit of picking this guy\n                    ans=min(ans,1+helper(j))\n            return ans\n        ans=float('inf')\n        for i in range(n,-1,-1):\n            res=helper(i)\n            if taps[i][0]<=0 and res<ans:\n                ans=res\n        return -1 if ans==float('inf') else ans\n                \n        \n            \n        \n                    \n                    \n                    \n                \n            \n        \n", "\n\n\nclass Solution:\n    def minTaps(self, n, A):\n        dp = [0] + [n + 2] * n\n        for i, x in enumerate(A):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1\n\n\n\n# class Solution:\n#     def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n#         covers = sorted([(i - ranges[i], i + ranges[i], i) for i in range(n + 1) if ranges[i]], key=lambda x: (x[0], -x[1]))\n#         print(covers)\n#         cnt = 0\n#         most_right = float('-inf')\n#         lst = []\n#         for curr_left, curr_right, curr_idx in covers:\n#             if curr_right > most_right:\n#                 most_right = curr_right\n#                 cnt += 1\n#                 lst.append(curr_idx)\n#         print(cnt)\n#         return cnt if most_right >= n else -1\n", "\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        stack = []\n        for i in range(n + 1):\n            l, r = i - ranges[i], i + ranges[i]\n            if not stack or (l <= 0 and r >= stack[-1]):\n                stack = [r]\n            elif l <= stack[-1] < r:\n                while len(stack) > 1:\n                    prev = stack.pop()\n                    if l > stack[-1]:\n                        stack.append(prev)\n                        break\n                stack.append(r)\n            if stack[-1] >= n:\n                return len(stack)\n        return -1\n\nclass Solution: #DP\n    def minTaps(self, n, A):\n        dp = [0] + [n + 2] * n\n        for i, x in enumerate(A):\n            for j in range(max(i - x + 1, 0), min(i + x, n) + 1):\n                dp[j] = min(dp[j], dp[max(0, i - x)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1\n\n\n\n# class Solution:\n#     def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n#         covers = sorted([(i - ranges[i], i + ranges[i], i) for i in range(n + 1) if ranges[i]], key=lambda x: (x[0], -x[1]))\n#         print(covers)\n#         cnt = 0\n#         most_right = float('-inf')\n#         lst = []\n#         for curr_left, curr_right, curr_idx in covers:\n#             if curr_right > most_right:\n#                 most_right = curr_right\n#                 cnt += 1\n#                 lst.append(curr_idx)\n#         print(cnt)\n#         return cnt if most_right >= n else -1\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # \u50bb\u74dc\u4e00\u70b9\u60f3\u6cd5  DP \n        # \u6bcf\u4e2a\u70b9 \u5de6\u8fb9loop \u5f53\u524d\u6700\u5c0f\u503c\u548c\u5de6\u8fb9\u6700\u5c0f\u503c+1\n        # \u6709\u70b9\u6bcf\u4e2a\u70b9  \u540c\u7406\n       \n        dp = [0] + [n + 2] * n\n        for i , cur in enumerate(ranges):\n            for j in range(max(0,i-cur+1),min(n,i+cur)+1):\n                dp[j] = min(dp[j], dp[max(0,i-cur)] + 1)\n        return dp[n] if dp[n] < n + 2 else -1       # 0-5 \u6700\u591a\u67096\u4e2a n+1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        minimum=0\n        maximum=0\n        total=0\n        while maximum<n:\n            for i in range(len(ranges)):\n                left=i-ranges[i]\n                right=i+ranges[i]\n                if left<=minimum and right>maximum:\n                    maximum=right\n            if minimum==maximum:\n                return -1\n            minimum=maximum\n            total+=1\n        return total", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n        \n        \n        ranges = [[i-val, i+val] for i, val in enumerate(ranges)]\n        ranges.sort()\n        \n        print(ranges)\n        max_reach = 0\n        i = 0 \n        taps=0\n        \n        while max_reach <n:\n            curr_reach = 0\n            if max_reach == 6:\n                print(3)\n            while i < n+1 and ranges[i][0] <= max_reach:\n                curr_reach = max(curr_reach, ranges[i][1])\n                i += 1\n            \n            print(curr_reach , max_reach)\n            if curr_reach <= max_reach:\n                return -1\n            \n            max_reach = curr_reach\n            taps += 1\n        \n        return taps", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        windows = []\n\n        for i, range in enumerate(ranges):\n            windows.append((max(0, i-range), i+range))\n        \n        windows.sort()\n        \n        i = 0\n        max_water = 0\n        num_taps = 0\n        \n        while i < len(windows):\n            if max_water >= n:\n                return num_taps\n            \n            num_taps += 1\n            prev_water = max_water\n            j = i\n            \n            while j < len(windows) and windows[j][0] <= prev_water:\n                if windows[j][1] > max_water:\n                    max_water = windows[j][1]\n                    \n                j += 1\n            \n            if max_water == prev_water:\n                break\n            \n            i = j\n        \n        return -1 if max_water < n else num_taps", "# 1326. Minimum Number of Taps to Open to Water a Garden\n\ndef redundant (a, b):\n    (al, ar), (bl, br) = a, b\n    return al <= bl <= br <= ar or bl <= al <= ar <= br\n\ndef union (a, b):\n    (al, ar), (bl, br) = a, b\n    return (min (al, bl), max (ar, br))\n\ndef remove_overlap (ranges):\n    ans = []\n    for rng in ranges:\n        ans.append (rng)\n        while len (ans) >= 2 and redundant (ans[-2], ans[-1]):\n            b = ans.pop (); a = ans.pop ()\n            ans.append (union (a, b))\n    return ans\n\ndef union_covers (a, b, c):\n    (al, ar), (bl, br), (cl, cr) = a, b, c\n    return al <= cl <= ar <= cr and al <= bl <= br <= cr\n\ndef min_taps (n, radii):\n    assert n >= 1\n    assert len (radii) == n + 1\n    \n    ranges = []\n    for (center, radius) in enumerate (radii):\n        if radius > 0:\n            left_end = max (0, center - radius)\n            right_end = min (n, center + radius)\n            ranges.append ((left_end, right_end))\n\n    ranges = remove_overlap (ranges)\n\n    final_ranges = []\n    for rng in ranges:\n        if len (final_ranges) >= 2 and union_covers (final_ranges[-2], final_ranges[-1], rng):\n            final_ranges.pop ()\n        final_ranges.append (rng)\n\n    if final_ranges and final_ranges[0][0] == 0 and final_ranges[-1][-1] == n and all (final_ranges[i][1] >= final_ranges[i+1][0] for i in range (len (final_ranges) - 1)):\n        return len (final_ranges)\n    else:\n        return -1\n\n\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        return min_taps(n, ranges)", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        covers = []\n        for i,r in enumerate(ranges):\n            if r==0:\n                continue\n            covers.append([max(0,i-r), min(n, i+r)])\n        \n        if len(covers)==0:\n            return -1\n        \n        covers.sort(key=lambda x:x[0])        \n        \n        result = 0\n        reach = 0\n        while len(covers)!=0:\n            temp = None\n            while len(covers)!=0:\n                if covers[0][0] - reach>0:\n                    break\n                x = covers.pop(0)\n                if temp==None or temp[1]<x[1]:\n                    temp = x\n         \n            if temp is None:\n                return -1\n            result+=1\n            reach = temp[1]\n            if reach==n:\n                break\n            \n        return result\n                    \n                \n    \n    \n", "#[] Greedy\n#O(NlogN)\nBEGIN, END = 0, 1\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        stitch = max_reach = cnt = i = 0\n        clips = sorted((i-diff, i+diff) for i, diff in enumerate(ranges) if diff) #sort by start\n        N = len(clips)\n        while max_reach < n: #NOTE: WA: max_reach < `n` instead of `N`\n            #try to find furthest end-point\n            while i < N and clips[i][BEGIN] <= stitch:\n                max_reach = max(max_reach, clips[i][END])\n                i += 1\n            if stitch == max_reach:\n                return -1 #unable to reach n\n            cnt += 1\n            stitch = max_reach #put clips[i] into solution and extend the next end-point\n        return cnt", "class Solution:\n    # def minTaps(self, n: int, ranges: List[int]) -> int:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        opens, closes, closed = [[] for _ in range(n)], [[] for _ in range(n)], set()\n        for i in range(len(ranges)):\n            idx = 0\n            if i - ranges[i] > 0:\n                idx = i - ranges[i] \n            if idx < len(opens):\n                opens[idx].append(i)\n            if i + ranges[i] < n:\n                closes[i + ranges[i]].append(i)\n        heap, cur_open_tap, res = [], None, 0\n        for i in range(n):\n            for op in opens[i]:\n                heappush(heap, [-(op + ranges[op]), op])\n            for cl in closes[i]:\n                closed.add(cl)\n                if cl == cur_open_tap:\n                    cur_open_tap = None\n            while cur_open_tap is None:\n                if not heap:\n                    return -1\n                if heap[0][1] in closed:\n                    heappop(heap)\n                else:\n                    cur_open_tap = heap[0][1]\n                    res += 1\n        return res", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        max_right = [0] * (n + 1)\n        \n        for i,x in enumerate(ranges):\n            max_right[max(0, i - x)] = max(max_right[max(0, i - x)], i + x)\n        \n        i = 0\n        best_right = 0\n        ans = 0\n        j = 0\n        \n        while i < n:\n            while j <= i:\n                best_right = max(max_right[j], best_right)\n                j += 1\n\n            if best_right <= i:\n                return -1 \n            \n            ans += 1\n            i = best_right\n            \n                \n            \n        return ans\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        r, R = 0, sorted([x-r, x+r] for x, r in enumerate(ranges)) + [[9**9]]\n        did = can = count = 0\n        for x in range(n):\n            while R[r][0] <= x:\n                can = max(can, R[r][1])\n                r += 1\n            if did == x:\n                if can <= x:\n                    return -1\n                did = can\n                count += 1\n                if did == n:\n                    break\n        return count\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        taps = []\n        for i, r in enumerate(ranges):\n            if r > 0:\n                taps.append([max(0, i - r), -min(n, i + r)])\n        if not taps:\n            return -1\n        taps.sort()\n        if taps[0][0] != 0:\n            return -1\n        stack = [[taps[0][0], abs(taps[0][1])]]\n        \n        #print(taps)\n\n        for t in taps[1:]:\n            if stack[-1][1] == n:\n                break\n            l, r = t[0], abs(t[1])\n            if r <= stack[-1][1]:\n                continue\n            if l > stack[-1][1]:\n                return - 1\n            if len(stack) == 1:\n                stack.append([l, r])\n            else:    \n                if l <= stack[-2][1]:\n                    stack.pop()\n                stack.append([l, r])\n\n        #print(stack)\n        return len(stack)\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n        needed = [100000]*(n+1)\n        \n        for i in range(len(ranges)):\n            #print(needed)\n            l_i = i - ranges[i]\n            \n            if l_i <= 0:\n                need = 1\n            else:\n                need = needed[l_i] + 1\n                \n            right_most = min(i + ranges[i],len(ranges)-1)\n            \n            while need < needed[right_most] and right_most > i-1:\n                needed[right_most] = need\n                right_most -= 1\n        \n        if needed[-1]>10000:\n            return -1\n\n        return needed[-1]", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        steps = [0]*(n+1)\n        for i, r in enumerate(ranges):\n            if i - r < 0:\n                steps[0] = max(i + r, steps[0])\n            else:\n                steps[i - r] = max(i + r, steps[i - r])\n        #print(steps)\n        \n        num = 1\n        cur = 0\n        cur_max = steps[0]\n        while cur_max < n:\n            next_max = cur_max\n            for loc in range(cur + 1, cur_max + 1):\n                next_max = max(next_max, steps[loc])\n            #print(cur, cur_max, next_max)\n            if next_max == cur_max:\n                return -1\n            num += 1\n            cur = cur_max\n            cur_max = next_max\n        return num", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        for i, val in enumerate(ranges):\n            if i - val < 0:\n                ranges[0] = max(i + val, ranges[0])\n            else:\n                ranges[i - val] = max(val * 2, ranges[i - val])\n        i = 0\n        prev = -1\n        counter = 0\n        while i != prev:\n            distance = ranges[i]\n            if i + distance >= n:\n                return counter + 1\n            maxIndex = i\n            for j in range(i+1, i + distance + 1):\n                if j + ranges[j] >= maxIndex + ranges[maxIndex]:\n                    maxIndex = j\n                j += 1\n            prev = i\n            i = maxIndex\n            counter += 1\n        return -1\n\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        ls = []\n        for i in range(n+1): \n            ls.append((max(i-ranges[i],0),min(i+ranges[i],n+1)))\n        ls.sort(key = lambda x:(x[0],-x[1]))\n        ans,a,b = 0,-1,0\n        while b < n:\n            c,d = ls.pop(0)\n            if c > b: return -1\n            elif d <= b: continue\n            elif c > a:\n                ans += 1\n                a,b = b,d\n            elif c <= a:\n                b = d\n        return ans\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # max_right from each point\n        max_right = [0] * (n+1)\n        for i, x in enumerate(ranges):\n            l = max(0, i-x)\n            r = min(n, i+x)\n            max_right[l] = r\n        # jump game\n        ans = 0\n        curr_reach = max_reach = 0\n        print(max_right)\n        for i in range(n+1):\n            max_reach = max(max_reach, max_right[i])\n            if i == curr_reach:\n                print((i, curr_reach, max_reach))\n                curr_reach = max_reach\n                ans += 1\n                if curr_reach == n:\n                    return ans\n        return ans if curr_reach >= n else -1\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n        for i, r in enumerate(ranges):\n            left = max(0, i-r)\n            right = i+r\n            ranges[left] = max(ranges[left], right)\n            \n        r, res = 0, 0\n            \n        while r < n:\n            tmp = r\n            r = max(ranges[0:r+1])\n            res += 1\n            if tmp == r:\n                return -1\n    \n        return res\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        if n == 0:\n            return 0\n        \n        steps = [0] * (n + 1)\n        for i, r in enumerate(ranges):\n            left = max(0, i - r)\n            right = min(n, i + r)\n            for j in range(left, right+1):\n                steps[j] = right\n        \n        #print(steps)\n        res = 1\n        prev = 0\n        cur = steps[0]\n        while cur > prev:\n            if cur == n:\n                return res\n            \n            tmp = cur\n            for i in range(prev+1, cur+1):\n                cur = max(cur, steps[i])\n            \n            prev = tmp\n            res += 1\n        \n        return -1\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n        for i, r in enumerate(ranges):\n            left = max(0, i-r)\n            right = i+r\n            ranges[left] = max(ranges[left], right)\n            \n        l, r, res = 0, 0, 0\n            \n        while r < n:\n            jump = max(ranges[l:r+1])\n            if r == jump:\n                return -1\n            res += 1\n            l, r = r, jump\n    \n        return res\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        l=[]\n        for i in range(n+1):\n            l.append((i-ranges[i], i+ranges[i]))\n        l.sort()\n        maxlen=0\n        curpos=0\n        res=0\n        while maxlen<n:\n            new=maxlen\n            while curpos<=n and l[curpos][0]<=maxlen:\n                if l[curpos][1]>maxlen:\n                    new=max(new, l[curpos][1])\n                curpos+=1  \n            if maxlen==new:\n                return -1\n            res+=1\n            maxlen=new\n        return res     \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n        \n        max_range = [0 for i in range(n+1)]\n        \n        for i in range(n+1):\n            \n            left, right = max(0,i-ranges[i]), min(i+ranges[i], n)\n       \n            max_range[left] = max(max_range[left], right - left)\n          \n        jumps = 0\n        \n        curlen, endlen = 0, 0\n        \n        print(max_range)\n        for i in range(n+1):\n            \n            if max_range[i] == 0 and endlen < i:\n                return -1\n            \n            curlen = max(curlen, i+max_range[i])\n            \n            if i == endlen:\n                endlen = curlen\n                jumps += 1\n            \n            if endlen == n:\n                return jumps\n                \n        return jumps", "class Solution:\n    def minTaps(self, n: int, ranges):\n        taps = [[max(0, i - ranges[i]), min(n, i + ranges[i])] for i in range(n + 1)]\n        taps.sort()\n        ans = i = last = 0\n\n        while i < len(taps):\n            if last == n:\n                return ans\n\n            if taps[i][0] > last:\n                return -1 if last < n else ans\n\n            temp = -1\n\n            while i < len(taps) and taps[i][0] <= last:\n                temp = max(temp, taps[i][1])\n                i += 1\n\n            if temp > last:\n                ans += 1\n                last = temp\n            else:\n                return -1\n\n        return ans if last == n else -1", "class Solution:\n    def minTaps(self, n: int, minjump: List[int]) -> int:\n        \n        \n        for i in range(n+1):\n            left= max(0, i-minjump[i])\n            right= min(n, i+minjump[i])\n            minjump[left]=max(minjump[left],right-left)\n        # print(minjump)\n        jump=1\n        steps=minjump[0]\n        maxreach=minjump[0]\n        lastindex,maxjump=0,minjump[0]\n        for i in range(1,n+1):\n            steps-=1\n            if steps<0:\n                return -1\n            \n            if i+minjump[i]>maxreach:\n                maxreach=minjump[i]+i\n                maxjump=minjump[i]\n                lastindex=i\n            if steps==0 and i!=n:\n                steps= lastindex+maxjump-i\n                jump+=1\n        return jump", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        \n        for i, r in enumerate(ranges):\n            if r > 0:\n                left = max(0, i-r)\n                right = i+r\n                ranges[left] = max(ranges[left], right)\n            \n        r, res = 0, 0\n            \n        while r < n:\n            tmp = r\n            r = max(ranges[0:r+1])\n            res += 1\n            if tmp == r:\n                return -1\n    \n        return res\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        new_ranges = []\n        for i in range(len(ranges)):\n            new_ranges.append([max(0, i-ranges[i]), min(n, i+ranges[i])])\n            \n        new_ranges = sorted(new_ranges, key=lambda x: x[0])    \n        \n        tap_counter = 0\n        ranges_counter = 0\n        i = 0\n        while i < n:\n            # Find all ranges with a start value lower than the current_counter\n            max_right = -1\n            while ranges_counter < len(new_ranges) and new_ranges[ranges_counter][0] <= i:\n                max_right = max(max_right, new_ranges[ranges_counter][1])\n                ranges_counter += 1\n                \n            if max_right == -1:\n                return -1\n            \n            tap_counter += 1\n            \n            i = max_right\n            \n        return tap_counter    ", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        if len(ranges) == 0: return 0\n        \n        segments = [(max(0, index - num), min(n, index + num)) for index, num in enumerate(ranges)]\n        segments = sorted(segments)\n        left, right = -1, 0\n        cnt = 0\n        for a, b in segments:\n            if a > right: break\n                \n            # very important\n            if right == n: break  # there are segments with [n, n], we don't want to count it again.\n            \n            if right >= a > left:\n                cnt += 1\n                left = right\n            \n            right = max(right, b)\n            \n        if right == n: return cnt\n        return -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        hp = []\n        \n        for i, r in enumerate(ranges):\n            if r != 0:\n                heapq.heappush(hp, (max(i-r, 0), -(i+r)))\n        #1-5,-2-6, 3-7, 4-8\n        ans = []\n        while hp:\n            start, end = heapq.heappop(hp)\n            end = -end\n            if not ans:\n                ans.append((start, end))\n            else:\n                #Not overlapped\n                if start > ans[-1][1]:\n                    return -1\n                \n                #Already covered\n                if end <= ans[-1][1]:\n                    continue\n\n                if len(ans) >= 2 and start <= ans[-2][1]:\n                    ans[-1] = (start, end)\n                elif start <= ans[-1][1]:\n                    ans.append((start, end))\n                #print(\\\"here\\\")\n                #print(ans)\n            if ans and ans[-1][1] >= n:\n                break\n        \n        print(ans)\n        return len(ans) if ans and ans[-1][1] >= n else -1\n", "import bisect\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        uc = 0\n        taps = []\n        taps_r = []\n        for idx, r in enumerate(ranges):\n            if r > 0:\n                tap = (idx-r if idx-r>0 else 0, idx+r)\n                tapr = (idx+r, idx-r if idx-r>0 else 0)\n                taps_r.append(tapr)\n                taps.append(tap)\n        if not taps:\n            return -1\n        taps.sort()\n        curr_idx = bisect.bisect_left(taps,(1,0))-1\n        curr_idx = curr_idx if curr_idx > 0 else 0\n        if taps[curr_idx][0] > 0:\n            return -1\n        e_range = taps[curr_idx][1]\n        res = 1\n        if e_range>=n:\n            return 1\n        lo = curr_idx\n        hi = len(taps)\n        while e_range < n:\n            hi = bisect.bisect_left(taps, (e_range+1, 0), lo, hi)\n            print(hi)\n            max_e = 0\n            for i in range(lo,hi):\n                if taps[i][1] > max_e:\n                    curr_idx = i\n                    max_e = taps[i][1]\n            if max_e <= e_range:\n                return -1\n            e_range = max_e\n            lo = curr_idx\n            hi = len(taps)\n            res += 1\n        return res\n", "class Solution:\n    def minTaps(self, n: int, ranges) -> int:\n\n        def process_input(ranges):\n            spans = []\n            for i in range(len(ranges)):\n                spans.append([max(i - ranges[i], 0), i + ranges[i]])\n\n            return spans\n\n        spans = process_input(ranges)\n\n        spans.sort(key=lambda time: (time[0], -time[1]))\n\n        sol = []\n        step = .5\n        for i in range(len(spans)):\n\n            if step > n:\n                continue\n\n            if spans[i][0] < step and spans[i][1] > step:\n                try:\n                    if spans[i][0] <= sol[-2][1]:\n                        sol.pop()\n                except:\n                    pass\n                sol.append(spans[i])\n                step = spans[i][1] + .5\n\n\n\n        if step < n:\n            return -1\n        return len(sol)", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        items = []\n        for i, num in enumerate(ranges):\n            items.append((max(0, i - num), min(i + num, n)))\n        res = 0\n        right = 0\n        items.sort()\n        i = 0\n        while i < len(items):\n            farreach = right\n            while i < len(items) and items[i][0] <= right:\n                farreach = max(farreach, items[i][1])\n                i += 1\n            \n            if farreach == right:\n                return -1\n            res += 1\n            if farreach >= n:\n                return res\n            right = farreach\n        \n        return -1", "from typing import List, Tuple\nfrom sortedcontainers import SortedSet\n\n\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # print('-----')\n        # print(f'n: {n}')\n        # print(f'ranges: {ranges}')\n\n        intervals = SortedSet()\n\n        for i, w in enumerate(ranges):\n            newInterval = (max(i - w, 0), min(i + w, n))\n            idx = intervals.bisect_left(newInterval)\n\n            if idx < len(intervals) and self.aContainsB(intervals[idx], newInterval):\n                continue\n            elif idx > 0 and self.aContainsB(intervals[idx-1], newInterval):\n                continue\n            else:\n                change = True\n                while change:\n                    change = False\n                    idx = intervals.bisect_left(newInterval)\n                    if idx < len(intervals) and self.aContainsB(newInterval, intervals[idx]):\n                        del intervals[idx]\n                        change = True\n                    elif idx > 0 and self.aContainsB(newInterval, intervals[idx-1]):\n                        del intervals[idx-1]\n                        change = True\n                    elif idx > 1 and self.overlaps(newInterval, intervals[idx-2]):\n                        del intervals[idx-1]\n                        change = True\n                intervals.add(newInterval)\n\n        # print(f'intervals={intervals}')\n\n        prevEnd = 0\n        for (start, end) in intervals:\n            if start > prevEnd:\n                return -1\n            prevEnd = end\n        if end < n:\n            return -1\n\n        return len(intervals)\n\n    def aContainsB(self, a: Tuple[int, int], b: Tuple[int, int]) -> bool:\n        a_start, a_end = a\n        b_start, b_end = b\n        return a_start <= b_start and a_end >= b_end\n\n    def overlaps(self, a: Tuple[int, int], b: Tuple[int, int]) -> bool:\n        a_start, a_end = a\n        b_start, b_end = b\n        return a_end >= b_start and b_end >= a_start\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # Start at 6:00PM\n        # Get ranges\n        import heapq\n        print(len(ranges))\n        range_tuples = []\n        for i, val in enumerate(ranges):\n            if val == 0:\n                continue\n            range_tuples.append((max(0, i - val), min(n, i + val)))\n        \n        range_tuples = sorted(range_tuples)\n                \n        heap = [(0, 0)]\n        \n        for (start_pos, end_pos) in range_tuples:\n            # Remove elements from the heap less than start_pos\n            while heap and heap[0][0] < start_pos:\n                heapq.heappop(heap)\n            \n            curr_min_cost = float('inf')\n            while heap and heap[0][0] == start_pos:\n                cost = heapq.heappop(heap)[1]\n                if cost < curr_min_cost:\n                    curr_min_cost = cost\n            \n            if curr_min_cost == float('inf'):\n                # Get the next closest point cost\n                if not heap:\n                    return -1\n            else:\n                heapq.heappush(heap, (start_pos, curr_min_cost))\n            curr_min_cost = min([a for (_, a) in heap])\n            heapq.heappush(heap, (end_pos, curr_min_cost + 1))\n        \n        while heap and heap[0][0] < n:\n            heapq.heappop(heap)\n        \n        min_cost = float('inf')\n        \n        while heap and heap[0][0] == n:\n            cost = heap[0][1]\n            if cost < min_cost:\n                min_cost = cost\n            heapq.heappop(heap)\n        \n        if min_cost == float('inf'):\n            return -1\n        return min_cost", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # max_right from each point\n        max_right = [0] * (n+1)\n        for i, x in enumerate(ranges):\n            l = max(0, i-x)\n            r = min(n, i+x)\n            max_right[l] = r\n        # jump game\n        ans = 0\n        reach = 0\n        while reach < n:\n            max_reach = max(r for r in max_right[:reach+1])\n            if max_reach <= reach:\n                return -1\n            reach = max_reach\n            ans += 1\n        return ans\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        min_range, max_range, open_taps, idx = 0, 0 ,0, 0\n        \n        while max_range < n:\n            for i in range(idx, len(ranges)):\n                if i - ranges[i] <= min_range and i + ranges[i] >= max_range:\n                    max_range = i + ranges[i]\n                    idx = i\n            \n            if min_range == max_range:\n                return -1\n            open_taps += 1\n            min_range = max_range\n        \n        return open_taps\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        open_ranges = sorted([(idx-span, idx+span) for idx, span in enumerate(ranges)])\n        start, end, count = 0, 0, 0\n        i = 0\n        while i < len(ranges):\n            for j in range(i, len(ranges)):\n                l, r = open_ranges[j]\n                if l <= start:\n                    if r >= end:\n                        end = r\n                        i = j\n            count += 1\n            if end >= n:\n                return count\n            if start == end:\n                return -1\n            start = end\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        open_ranges = sorted([(idx-span, idx+span) for idx, span in enumerate(ranges)])\n        start, end, count = 0, 0, 0\n        i = 0\n        while i < len(ranges):\n            for j in range(i, len(ranges)):\n                l, r = open_ranges[j]\n                if l <= start:\n                    if r >= end:\n                        end = r\n                        i = j\n            count += 1\n            if end >= n:\n                return count\n            if start == end:\n                return -1\n            start = end\n                        \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        max_right = [0]*(n+1)\n        \n        for i,r in enumerate(ranges):\n                max_right[max(0,i-r)] = max(max_right[max(0,i-r)],min(n,i+ranges[i]))\n        dp = [float('inf')]*len(max_right)\n        dp[0] = 0\n        for i, x in enumerate(ranges):\n            for j in range(i+1,max_right[i]+1):\n                dp[j] = min(dp[j], dp[i] + 1)\n        return dp[n] if dp[n] != float('inf') else -1\n        \n", "# \u601d\u8def\n# \u8d2a\u5fc3\u7b56\u7565\uff0c\u6211\u4eec\u5c3d\u91cf\u627e\u5230\u80fd\u591f\u8986\u76d6\u6700\u8fdc\uff08\u53f3\u8fb9\uff09\u4f4d\u7f6e\u7684\u6c34\u9f99\u5934\uff0c\u5e76\u8bb0\u5f55\u5b83\u6700\u53f3\u8986\u76d6\u7684\u571f\u5730\u3002\n\n# \u6211\u4eec\u4f7f\u7528 furthest[i] \u6765\u8bb0\u5f55\u7ecf\u8fc7\u6bcf\u4e00\u4e2a\u6c34\u9f99\u5934 i \u80fd\u591f\u8986\u76d6\u7684\u6700\u53f3\u4fa7\u571f\u5730\u3002\n# \u4e00\u5171\u6709 n+1 \u4e2a\u6c34\u9f99\u5934\uff0c\u6211\u4eec\u904d\u5386 n + 1 \u6b21\u3002\n# \u5bf9\u4e8e\u6bcf\u6b21\u6211\u4eec\u8ba1\u7b97\u6c34\u9f99\u5934\u7684\u5de6\u53f3\u8fb9\u754c\uff0c[i - ranges[i], i + ranges[i]]\n# \u6211\u4eec\u66f4\u65b0\u5de6\u53f3\u8fb9\u754c\u8303\u56f4\u5185\u7684\u6c34\u9f99\u5934\u7684 furthest\n# \u6700\u540e\u4ece\u571f\u5730 0 \u5f00\u59cb\uff0c\u4e00\u76f4\u5230\u571f\u5730 n \uff0c\u8bb0\u5f55\u6c34\u9f99\u5934\u6570\u76ee\n\n\n# \u590d\u6742\u5ea6\u5206\u6790\n\n# \u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u65f6\u95f4\u590d\u6742\u5ea6\u53d6\u51b3 l \u548c r\uff0c\u4e5f\u5c31\u662f\u8bf4\u53d6\u51b3\u4e8e ranges \u6570\u7ec4\u7684\u503c\uff0c\u5047\u8bbe ranges \u7684\u5e73\u5747\u5927\u5c0f\u4e3a Size \u7684\u8bdd\uff0c\u90a3\u4e48\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(N * Size)$\u3002\n\n# \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a\u6211\u4eec\u4f7f\u7528\u4e86 furthest \u6570\u7ec4\uff0c \u56e0\u6b64\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a $O(N)$\u3002\n\n\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        furthest, cnt, cur = [0] * n, 0, 0  #\u505ainitialization\n\n        for i in range(n + 1):\n            l = max(0, i - ranges[i])  #\u5de6\u8fb9\u6700\u8fdc\u5230\u54ea\u91cc\n            r = min(n, i + ranges[i])  #n\u662f\u81ea\u5df1\n            for j in range(l, r):   #\u5728\u5de6\u53f3\u4e24\u8fb9\uff0c\u8868\u793a\u53f3\u8fb9\u80fd\u5230\u7684\u6700\u8fdc\u7684\u5730\u65b9\uff0c\n                furthest[j] = max(furthest[j], r)  #\u7ecf\u8fc7\u8fd9\u4e2a\u6c34\u9f99\u5934\u6700\u591a\u80fd\u8d70\u5230\u54ea\u91cc\uff0c\u8ddf\u81ea\u5df1\u65e0\u5173\uff08\u6ca1\u90a3\u4e48\u6709\u5173\uff09\uff0c\u8ddf\u7ecf\u8fc7\u6211\u6700\u8fdc\u5230\u54ea\u91cc\u6709\u5173\u7cfb\n        while cur < n:  #\u4ece\u5934\u5230\u5c3e\u626b\u4e00\u904d\uff0c\u770b\u770b\u6709\u7c73\u6709\u6ca1\u704c\u6e89\u5230\u7684\u5730\u65b9\n            if furthest[cur] == 0: return -1\n            cur = furthest[cur]  # \u6bd4\u8fd9\u4e2a\u6570\u503c\u5c0f\u7684\u90fd\u662f\u80fd\u626b\u5230\u7684\u90e8\u5206\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u8df3\u8fc7\u53bb\n            cnt += 1\n        return cnt  #\u5de6\u8fb9\u6709\u95ee\u9898\u7684\u8bdd\u4f1a-1\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        intervals = []\n        for i, r in enumerate(ranges):\n            intervals.append((i - r if i - r > 0 else 0, i + r))\n        \n        intervals.sort(key=lambda t: (t[0], -t[1]))\n        l = len(intervals)\n        \n        i = 0\n        ans = 1\n        while i < l:\n            if intervals[i][1] >= n:\n                return ans\n            right = -1\n            next_i = -1\n            for j in range(i + 1, l):\n                if intervals[j][0] <= intervals[i][1] and intervals[j][1] >= right:\n                    right = intervals[j][1]\n                    next_i = j\n            \n            if next_i == -1:\n                return -1\n            \n            ans += 1\n            i = next_i\n            \n        return ans", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n#         taps=[]\n#         for i in range(len(ranges)):\n#             taps.append((i-ranges[i],i+ranges[i]))\n        \n#         taps.sort()\n#         @lru_cache(None)\n#         def helper(i):\n#             # minimum number of taps to open if we open i to reach end\n#             if i>=n+1:return float('inf')\n#             if taps[i][1]>=n:return 1\n#             ans=float('inf')\n#             # lets do binary search here\n#             start=i+1\n#             end=n\n#             lastindex=-1\n#             # get the last index which is smaller than taps[i][1]\n#             while start<=end:\n#                 mid=start+(end-start)//2\n#                 if taps[mid][0]<=taps[i][1]:\n#                     lastindex=mid\n#                     start=mid+1\n#                 else:\n#                     end=mid-1\n#             if lastindex==-1:return ans\n#             for j in range(i+1,lastindex+1):\n#                 if taps[j][0]>taps[i][1]:\n#                     break\n#                 if taps[j][0]<=taps[i][1] and taps[j][1]>taps[i][1]:\n#                     # benefit of picking this guy\n#                     ans=min(ans,1+helper(j))\n                    \n#             # sequential code to do that\n#             # dont go for binary unless interviewer say so\n#             # ask him in the approach if he wants to\n            \n#             # for j in range(i+1,n+1):\n#             #     if taps[j][0]>taps[i][1]:\n#             #         break\n#             #     if taps[j][0]<=taps[i][1] and taps[j][1]>taps[i][1]:\n#             #         # benefit of picking this guy\n#             #         ans=min(ans,1+helper(j))\n#             return ans\n#         ans=float('inf')\n#         for i in range(n,-1,-1):\n#             res=helper(i)\n#             if taps[i][0]<=0 and res<ans:\n#                 ans=res\n#         return -1 if ans==float('inf') else ans\n    \n        best = [float('inf') for _ in ranges]\n        for i, r in enumerate(ranges):\n            if r > 0:\n                start, end = i - r, i + r \n                best_with = 1 + (best[start] if start > 0 else 0)\n                for j in range(max(0, start), min(len(ranges), end+1)):\n                    best[j] = min(best[j], best_with)\n        if any(v for v in best if v == float('inf')):\n            return -1 \n        return best[-1]\n                \n        \n            \n        \n                    \n                    \n                    \n                \n            \n        \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        max_right = [0]*(n+1)\n        \n        for i,r in enumerate(ranges):\n                max_right[max(0,i-r)] = max(max_right[max(0,i-r)],min(n,i+ranges[i]))\n        dp = [float('inf')]*len(max_right)\n        dp[0] = 0\n        for i, x in enumerate(ranges):\n            for j in range(i+1,max_right[i]+1):\n                dp[j] = min(dp[j], dp[i] + 1)\n        return dp[n] if dp[n] < n + 2 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        if n < 1 or ranges is None: return -1\n        dp = [None]*len(ranges)\n        # for each tap\n        for i in range(len(dp)):\n            # calc tap left and right extent\n            l = max(0, i-ranges[i])\n            r = min(len(dp)-1, i+ranges[i])\n            # for each cell in extent, take the min of the cell or the left extent of the tap\n            for j in range(l, r+1):\n                if dp[j] is None:\n                    dp[j] = l\n                else:\n                    dp[j] = min(dp[j], l)\n            # since we can reach to front from last, only one tap is required\n            if dp[-1] == 0:\n                return 1\n        # start from end, jump backwards incrementing tap count each time\n        # careful to exit if no jump can be made\n        i = len(dp)-1\n        c = 0\n        while i > 0 and dp[i] is not None and dp[i] != i:\n            i = dp[i]\n            c += 1\n        # if we can jump all the way to the front, then return the count else -1\n        return c if i == 0 else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        inf = 1 << 50\n        prev = collections.defaultdict(lambda: inf)\n        for i, r in enumerate(ranges):\n            prev[min(i+r, n)] = min(prev[min(i+r, n)],max(i-r,0))\n \n        dp = [inf] * (n + 1)\n        dp[0] = 0\n \n        for x in range(n+1):\n            for y in range(prev[x], x):\n                dp[x] = min(dp[y] + 1, dp[x])\n \n        res = dp[n]\n        if res >= inf:\n            return -1\n \n        return res", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp=[sys.maxsize]*(n+1)\n        dp[0]=0\n        for i in range(n+1):\n            l=max(0,i-ranges[i])\n            r=min(n,i+ranges[i])\n            \n            for j in range(l,r+1):\n                    dp[j]=min(dp[j],1+dp[l])\n                \n        if(dp[n]==sys.maxsize):\n            return -1\n        return dp[n]\n            \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        '''        \n        # top-down TLE\n        dp = [0] + [float('inf')]*n\n        def helper(k):\n            if not (1<= k <= n):\n                return 0\n            if dp[k]!=float('inf'):\n                return dp[k]\n            dp[k] = min([helper(i-x)+1 for i, x in enumerate(ranges)\\\\\n                      if k in range(i-x+1, i+x+1)] or [-1])\n            return dp[k]\n        return helper(n)\n        '''\n        \n        if n == 0: \n            return 0\n        dp = [0] + [float('inf')]*n\n        for i, x in enumerate(ranges):\n            start, end = max(0, i-x), min(n, i+x)\n            for j in range(start, end+1):\n                dp[j] = min(dp[j], dp[start]+1)\n        return dp[-1] if dp[-1]!=float('inf') else -1\n        \n        '''        \n        # greedy\n        covers = sorted([[i-x, i+x] for i, x in enumerate(ranges)], key = lambda x: (x[0], -x[1]))\n        #print(covers)\n        res, prev_end, end = 0, -float('inf'), 0\n        for src, dest in covers:\n            if src > end or end >= n:\n                break\n            if prev_end < src <= end:\n                prev_end, res = end, res + 1\n            end = max(end, dest)\n        return res if end >= n else -1\n        '''", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        best = [n+1 for _ in ranges]\n        for i, r in enumerate(ranges):\n            if r > 0:\n                start, end = i - r, i + r \n                best_with = 1 + (best[start] if start > 0 else 0)\n                for j in range(max(0, start), min(len(ranges), end+1)):\n                    best[j] = min(best[j], best_with)\n        if any(v for v in best if v == n+1):\n            return -1 \n        return best[-1]", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [float('inf')] * (n+1)\n        dp[0] = 0\n        for cur in range(n+1):\n            left = max(0,cur - ranges[cur] + 1)\n            right = min(n,cur+ranges[cur])\n            lastend = max(0, cur - ranges[cur])\n            for idx in range(left, right+1):\n                dp[idx] = min(dp[idx], dp[lastend] + 1)\n        return dp[-1] if dp[-1] < float('inf') else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [-1 for x in range(n+1)]\n        \n        for i in range(n+1):\n            minId = max(0, i-ranges[i])\n            maxId = min(n, i+ranges[i])\n            \n            for i in range(minId, maxId+1):\n                dp[i] = max(dp[i], maxId)\n        \n        if dp[0] == -1:\n            return -1\n        \n        maxReach = dp[0]\n        count = 1\n        \n        while maxReach < n:\n            nxt = dp[maxReach]\n            if nxt == maxReach:\n                return -1\n            maxReach = nxt\n            count += 1\n        \n        return count", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # dp[i] min taps to water [0, i]\n        # dp[0] = 0\n        dp = [0] + [n+2] * n # n+1 is possible value\n        for i, v in enumerate(ranges):\n            left = max(i-v, 0)\n            right = min(i+v, n)\n            for j in range(left, right+1):\n                dp[j] = min(dp[j], dp[left]+1)\n        if dp[n] < n+2:\n            return dp[n]\n        return -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        full_ranges = []\n        for i in range(n + 1):\n            r = (i - ranges[i], i + ranges[i])\n            full_ranges.append(r)\n        \n        full_ranges.sort()\n        range_idx = 0\n        \n        covered_max = 0\n        num_taps = 0\n        \n        while covered_max < n and range_idx < len(full_ranges):\n            if full_ranges[range_idx][0] > covered_max:\n                return -1\n            furthest = -1\n            while range_idx < len(full_ranges) and full_ranges[range_idx][0] <= covered_max:\n                furthest = max(furthest, full_ranges[range_idx][1])\n                range_idx += 1\n            assert(furthest != -1)\n            num_taps += 1\n            covered_max = furthest\n        \n        if covered_max < n:\n            return -1\n        else:\n            return num_taps\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n             \n        max = 0 \n        min = 0\n        index = 0\n        total = 0\n        \n        while(max<n):\n            \n            for i in range(index,len(ranges)):\n                \n                left = i-ranges[i]\n                right = i+ranges[i]\n                \n                if left <= min and right > max:\n                    max = right\n                    index = i\n                    \n            if min == max: \n                return -1\n            \n            total+=1\n            \n            min = max\n            \n        return total\n", "class Solution:\n    \n    \n    \n    def minTaps(self, n: int, ranges: List[int]) -> int:\n                \n        rangesCovered = {}\n        # key = spot, value = range as tuple\n    \n    \n    \n        for i, ran in enumerate(ranges):\n            if (ran == 0):\n                continue\n            rangesCovered[i] = (max(0, i - ranges[i]), min(n, i + ranges[i]))\n        \n        \n        # print(rangesCovered)\n        dp = [n + 2] * (n + 1)\n        dp[0] = 0\n        # dp[i] = min number of taps to water all [0, i]\n        \n        for curRange in list(rangesCovered.values()):\n            # print(curRange)\n            startInd = curRange[0]\n            endInd = curRange[1]\n            for i in range(startInd + 1, endInd + 1):\n                dp[i] = min(dp[i], dp[startInd] + 1)\n            # print(dp)\n        \n        \n        \n        if (dp[n] == (n + 2)):\n            return -1\n        else:\n            return dp[n]\n#         taps = []\n#         for i in range(n + 1):\n#             isCovered[i] = False\n#             taps.append(i)\n            \n        \n        \n#         curMins = float(\\\"inf\\\")\n#         def recur(tapsRem, curCount):\n#             # print(curCount, tapsRem)\n#             # print(isCovered)\n#             nonlocal curMins\n#             if (all(isCovered.values())):\n                \n#                 curMins = min(curMins, curCount)\n#                 return\n#             else:\n#                 if (curCount > curMins):\n#                     return\n                \n#                 for i, val in enumerate(tapsRem):\n#                     newRem = tapsRem[:i] + tapsRem[i + 1:]\n#                     wasFalses = []\n#                     for j in range(rangesCovered[i][0], rangesCovered[i][1] + 1):\n#                         if isCovered[j] == False:\n#                             wasFalses.append(j)\n#                         isCovered[j] = True\n                    \n#                     recur(newRem, curCount + 1)\n#                     for ind in wasFalses:\n#                         isCovered[ind] = False\n                    \n#         # print(taps)\n#         recur(taps, 0)\n#         if (curMins ==  float(\\\"inf\\\")):\n#             return -1\n#         return curMins\n        \n                \n                \n                \n                \n            \n            \n            \n            \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # cover[i] shows the list number of taps needed to cover 0-i\n        # inf for impossible\n        cover = [math.inf] * n\n        \n        for i, r in enumerate(ranges):\n            start = max(i-r, 0)\n            end = min(i+r, n)\n            \n            pre_min = cover[start-1] if start > 0 else 0\n            for j in range(start, end):\n                cover[j] = min(cover[j], 1+pre_min)\n    \n        return cover[-1] if cover[-1] != math.inf else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [sys.maxsize]*(n+1)\n        dp[0]=0\n        \n        for i,tmp in enumerate (ranges):\n            left = max(0,i-tmp)\n            right = min(n,i+tmp)\n            \n            for j in range(left,right+1):\n                dp[j]=min(dp[j],dp[left]+1)\n        return dp[n] if dp[n]<sys.maxsize else -1", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [n+2 for _ in range(n+1)] #minimum number of taps to water i\n        dp[0] = 0\n        for i, amount in enumerate(ranges):\n            left = max(0,i - amount)\n            right = min(n, i + amount)\n            for j in range(left + 1, right+ 1):\n                dp[j] = min(dp[j], dp[left] +1)\n        return -1 if dp[n] == n+2 else dp[n]\n        \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [n+2 for _ in range(n+2)] #minimum number of taps to water i\n        dp[0] = 0\n        for i, amount in enumerate(ranges):\n            left = max(0,i-amount)\n            right = min(n, i + amount)\n            for j in range(left + 1, right+ 1):\n                dp[j] = min(dp[j], dp[left] +1)\n        \n        return -1 if dp[n] == n+2 else dp[n]\n        \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [n+2 for _ in range(n + 1)] #min number of water i\n        dp[0] = 0\n        for i, amount in enumerate(ranges):\n            left = max(0, i - amount)\n            right = min(n, i + amount)\n            for j in range(left, right+1):\n                dp[j] = min(dp[j], dp[left] + 1)\n        return -1 if dp[n] == n+2 else dp[n] ", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        rangelist = [None] * (n +1)\n\n        for i in range(n+1):\n            s = max(i - ranges[i], 0)\n            e = min(i + ranges[i], n)\n            \n            if rangelist[s] == None:\n                rangelist[s] = (s,e)\n            else:    \n                rangelist[s] = (s, max(rangelist[s][1], e))\n        \n        curr = mx = 0\n        count = 0\n        i = 0\n        while i < len(rangelist):\n            while True and i < len(rangelist): \n                if(rangelist[i] == None):\n                    i +=1\n                    continue\n                s,e = rangelist[i]\n                if s > mx: return -1\n                if s > curr:\n                    break\n                mx = max(e,mx)\n                i += 1\n            if curr != mx:\n                curr = mx\n                count += 1\n            \n        if mx < n: return -1\n        return count\n        \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        # dp[i] minimum taps required to water garden[:i + 1]\n        # for every ranges[i], update dp[i - ranges[i]:i + ranges[i] + 1]\n        # when i - ranges[i] - 1 < 0, return 0\n        # return -1 when dp[-1] is infinity\n        # check if it is possible to have a hole in the middle\n        dp = [float('inf')] * (n + 1)\n        for i in range(len(ranges)):\n            if i - ranges[i] <= 0:\n                taps = 1\n            else:\n                taps = dp[i - ranges[i]] + 1\n            \n            lo = max(i - ranges[i], 0)\n            hi = min(i + ranges[i], n)\n            for j in range(lo, hi + 1):\n                dp[j] = min(dp[j], taps)\n        \n        return dp[-1] if dp[-1] != float('inf') else -1\n", "class Solution:\n    def minTaps(self, n: int, A: List[int]) -> int:\n        dp=[sys.maxsize]*(n+1)\n        dp[0]=0\n        for i,tap_range in enumerate(A):\n            left=max(0,i-tap_range)\n            right=min(n,i+tap_range)\n            for j in range(left,right+1):\n                dp[j]=min(dp[j],dp[left]+1)\n        return dp[n] if dp[n]<sys.maxsize else -1\n            \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp=[sys.maxsize]*(n+1)\n        for i in range(n+1):\n            if ranges[i]==0:\n                continue\n            l=max(0,i-ranges[i])\n            r=min(n,i+ranges[i])\n            \n            for j in range(l,r+1):\n                if l==0:\n                    dp[j]=1\n                else:\n                    dp[j]=min(dp[j],1+dp[l])\n                \n        if(dp[n]==sys.maxsize):\n            return -1\n        return dp[n]\n            \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        for i, val in enumerate(ranges):\n            if i - val < 0:\n                ranges[0] = max(i + val, ranges[0])\n            else:\n                ranges[i - val] = max(val * 2, ranges[i - val])\n        i = 0\n        prev = -1\n        counter = 0\n        while i != prev:\n            distance = ranges[i]\n            if i + distance >= n:\n                return counter + 1\n            maxIndex = i\n            for j in range(i + distance + 1):\n                if j + ranges[j] >= maxIndex + ranges[maxIndex]:\n                    maxIndex = j\n                j += 1\n            prev = i\n            i = maxIndex\n            counter += 1\n        return -1\n\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        arr=[float('inf') for _ in range(n+1)]\n        arr[0]=0\n        i=0\n        while i<len(arr):\n            left=max(0,i-ranges[i])\n            right=min(len(arr)-1,i+ranges[i])\n            j=left+1\n            while j<=right:\n                arr[j]=min(arr[j],1+arr[left])\n                j+=1\n            i+=1\n        if arr[-1]==float('inf'):\n            return -1\n        return arr[-1]\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [n for _ in range(n+1)]\n        for index,ranged in enumerate(ranges):\n            start = max(0,index - ranged)\n            end = min(n,index + ranged)\n            if start == 0:\n                extra = 0\n            else:\n                extra = dp[start]\n            for i in range(start+1,end+1):\n                dp[i]= min(dp[i],1 + extra) \n        if dp[-1]!=n:\n            return dp[-1]\n        else:\n            return -1\n        \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        intervals=[]\n        for i,r in enumerate(ranges):\n            intervals.append([i-r,i+r])\n        intervals.sort(key=lambda x:[x[0],-x[1]])\n        #print(intervals)\n        count=0\n        def getnext(l):\n            rel=[]\n            for i in intervals:\n                if l>=i[0] and l<i[1]:\n                    rel.append(i)\n            rel.sort(key=lambda x:x[1],reverse=True)\n            return rel[0] if rel else None\n        \n        j=0\n        while j<n:\n            iv=getnext(j)\n            #print(count,j,iv)\n            if iv:\n                j=iv[1]\n                count+=1\n            else:\n                return -1\n        return count", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        intervals = []\n        for i, x in enumerate(ranges):\n            intervals.append([i - x, i + x])\n\n        # Always pick the first\n        def mySortKey(x):\n            # print(x)\n            left = x[0] \n            if left <= 0:\n                left = 0\n            right = x[1]\n            \n            return left * 100 - right\n        \n        intervals.sort(key=mySortKey)\n        print(intervals)\n        \n        greedyFurthest = intervals[0][1]\n        nextGreedyFurthest = 0\n        j = 0\n        count = 1\n        \n        while j < len(intervals):\n            connect = False\n            if greedyFurthest >= n:\n                return count\n            while j < len(intervals) and intervals[j][0] <= greedyFurthest:\n                if intervals[j][1] > nextGreedyFurthest:\n                    nextGreedyFurthest = intervals[j][1]\n                j += 1\n                connect = True\n                \n            greedyFurthest = nextGreedyFurthest\n            count += 1\n            if not connect:\n                return -1\n            \n        if greedyFurthest >= n:\n            return count\n        else:\n            return -1\n            \n        \n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        coords = []\n        for i, rng in enumerate(ranges):\n            if not rng:\n                continue\n            coords.append([max(0, i - rng), min(i + rng, n)])\n        coords.sort()\n\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        \n        for [start, end] in coords:\n            if start > n:\n                break\n            prev = dp[start]\n            for i in range(start, min(end, n)):\n                dp[i + 1] = min(prev + 1, dp[i + 1])\n            \n\n        return  dp[-1] if dp[-1] < float('inf') else -1\n", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [float('inf')]*(n+1)\n        dp[0] = 0\n        for i in range(n+1):\n            L = max(0,i-ranges[i])\n            R = min(n,i+ranges[i])\n            \n            for j in range(L+1,R+1):\n                dp[j] = min(dp[j], dp[L]+1)\n        if dp[n]>=n+2:\n            return -1\n        return dp[-1]", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        areas = [(x - ranges[x], x + ranges[x]) for x in range(n+1)]\n        areas = sorted(areas, key= lambda x: x[0])\n\n        def get_intersections(current, intervals):\n            results = []\n            for interval in intervals:\n                if current[0] <= interval[0] <= current[1] and interval[1] > current[1]:\n                    results.append(interval)\n            return results\n\n        first = areas[0]\n        for intersection in areas:\n            if intersection[0] <= 0 and intersection[1] > first[1]:\n                first = intersection\n\n        selected = [first]\n        area_to_cover = (first[1], n)\n\n        while area_to_cover[0] < area_to_cover[1]:\n            prev = selected[-1]\n\n            intersections = get_intersections(prev, areas)\n            if len(intersections) is 0:\n                return -1\n\n            intersections = sorted(intersections, key=lambda x: x[1])\n\n            rightmost = intersections[-1]\n            if rightmost[1] < area_to_cover[0]:\n                return -1\n\n            selected.append(rightmost)\n            area_to_cover = (rightmost[1], n)\n\n        return len(selected)", "class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        dp = [n+2]*(n+1)\n        dp[0] = 0\n        for i in range(n+1):\n            start = max(0,i-ranges[i])\n            end = min(n,i+ranges[i])\n            for j in range(start,end+1):\n                dp[j] = min(dp[j],dp[start]+1)\n        if dp[n]==n+2:\n            return -1\n        return dp[n]"]