["from heapq import *\n\ndef n_linear(ms, n):\n    lst = [1] * (n+1)\n    q   = [(1+v,v,1) for v in ms]\n    heapify(q)\n    for i in range(1,n+1):\n        v,x,j  = heappop(q)\n        lst[i] = v\n        heappush(q, (lst[j]*x+1, x, j+1) )\n        while q[0][0]==lst[i]:\n            v,x,j = heappop(q)\n            heappush(q, (lst[j]*x+1, x, j+1) )\n    return lst[n]", "from heapq import heappush, heappop\n\ndef n_linear(m, n):\n    h = [1]\n    x = 0\n    for _ in range(n+1):\n        x = heappop(h)\n        while h and h[0] == x:\n            heappop(h)\n        for y in m:\n            a = y * x + 1\n            heappush(h, a)\n    return x", "from collections import deque\nfrom heapq import heappush, heappop\n\n\ndef n_linear(m, n):\n    y, h, q = 1, [], {}\n    for x in m:\n        h.append((y, x))\n        q[x] = deque([x * y + 1])\n    while n:\n        z, w = heappop(h)\n        if y != z:\n            y = z\n            for x in m: q[x].append(x * y + 1)\n            n -= 1\n        heappush(h, (q[w].popleft(), w))\n    return y\n", "from heapq import *\n\ndef n_linear(m,n):\n    k = [1]\n    queue = []\n    while len(k) <= n:\n        for x in m:\n            heappush(queue, x*k[-1]+1)\n        k.append(heappop(queue))\n\n        while queue[0] == k[-1]:\n            heappop(queue)\n    \n    return k[-1]", "from heapq import *\n\ndef n_linear(ms, n):\n    lst = [1] * (n+1)\n    q   = [(1+v,v,1) for v in ms]\n    heapify(q)\n    for i in range(1,n+1):\n        v,x,j  = heappop(q)\n        lst[i] = v\n        heappush(q, (lst[j]*x+1, x, j+1) )\n        while q[0][0]==lst[i]:\n            v,x,j = heappop(q)\n            heappush(q, (lst[j]*x+1, x, j+1) )\n    print(ms,n)\n    return lst[n]", "def n_linear(m, n): \n    indxs = {i:0 for i in m}\n    u = [1]\n    \n    while len(u) <= n:\n        tmp = [ [k*u[v] + 1, k] for k, v in indxs.items()]\n        nxt = min(tmp, key = lambda x: x[0])\n        u.append(nxt[0])     \n        for i in tmp:\n            if i[0] == nxt[0]:\n                indxs[i[1]] += 1\n    return u[n]", "def n_linear(m,n):\n    arr = [1]\n    ms = list(m)\n    idxs = [0] * len(ms)\n    r = range(len(ms))\n    \n    for i in range(n):\n        vals = [arr[idxs[j]]*ms[j]+1 for j in r]\n        val = min(vals)\n        arr.append(val)\n        \n        for j in r:\n            idxs[j] += 1*(val==vals[j])\n            \n    return arr[n]", "def n_linear(m,n):\n    arr = [1]\n    indices = [0] * len(m)\n    r = range(len(m))\n    count = 0\n    while count < n:\n        x = min([arr[indices[i]] * m[i] for i in r])\n        for i in r:\n            if x == arr[indices[i]] * m[i]:\n                indices[i] += 1\n        arr.append(x + 1)\n        count += 1\n        \n    return arr[-1]", "import heapq\n\ndef n_linear_generator(m):\n    u = [1]\n    s = set(u)\n\n    while True:\n        x = heapq.heappop(u)\n        yield x\n        s.remove(x)\n\n        for y in m:\n            z = x * y + 1\n            if z not in s:\n                heapq.heappush(u, z)\n                s.add(z)\n\nmemos = {}\n\ndef n_linear(m, n):\n    m = tuple(m)\n    if m not in memos:\n        memos[m] = ([], n_linear_generator(m))\n        \n    past, gen = memos[m]\n    past.extend(next(gen) for _ in range(len(past), n + 1))\n    return past[n]", "def n_linear(m,n):\n    if n==0: return 1\n    init,dicto=[1],{}.fromkeys(m,0)\n    for i in range(n):\n        dd = min(k*init[dicto[k]]+1 for k in dicto)\n        init.append(dd)\n        for k in dicto:\n            dicto[k] += init[dicto[k]]*k+1==dd\n    return dd"]