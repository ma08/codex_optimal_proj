["from collections import deque\n\n\ndef tree_by_levels(node):\n    if not node:\n        return []\n    res, queue = [], deque([node,])\n    while queue:\n        n = queue.popleft()\n        res.append(n.value)\n        if n.left is not None:\n            queue.append(n.left)\n        if n.right is not None:\n            queue.append(n.right)\n    return res", "def tree_by_levels(node):\n    p, q = [], [node]\n    while q:\n        v = q.pop(0)\n        if v is not None:\n            p.append(v.value)\n            q += [v.left,v.right]\n    return p if not node is None else []", "def tree_by_levels(tree):\n    queue = [tree]\n    values = []\n\n    while queue:\n        node = queue.pop(0)\n        if node:\n            queue += [node.left, node.right]\n            values.append(node.value)\n            \n    return values", "# Use a queue. Add root node, then loop:\n# get first queue element, add all its children in the queue, left to right\n# and add the current node's value in the result\n\ndef tree_by_levels(node):\n    queue = []\n    result = []\n    if node == None:\n        return result\n    queue.append(node)\n    while len(queue) > 0:\n        n = queue.pop(0)\n        if n.left != None:\n            queue.append(n.left)\n        if n.right != None:\n            queue.append(n.right)\n        result.append(n.value)\n    return result", "def tree_by_levels(node):\n    r = []\n    nodes = [node]\n    while nodes:\n        r += [n.value for n in nodes if n]\n        nodes = [e for n in [(n.left, n.right) for n in nodes if n] for e in n if e]\n        \n    return r", "from collections import deque\n\ndef tree_by_levels(node):\n    if not node: return []\n    queue = deque([node])\n    level_order = []\n    while queue:\n        cur_node = queue.popleft()\n        level_order.append(cur_node.value)\n        if cur_node.left: queue.append(cur_node.left)\n        if cur_node.right: queue.append(cur_node.right)\n    return level_order", "def tree_by_levels(node):\n  return [v for v, _, _ in sorted(extract_nodes(node), key = lambda x: (x[1], x[2]))]\n\ndef extract_nodes(node, lvl=0, directions=[]):\n  if node:\n    return [(node.value, lvl, directions)] + extract_nodes(node.left, lvl+1, directions + [-1]) + extract_nodes(node.right, lvl+1, directions + [1])\n  return []", "from itertools import chain\ndef tree_by_levels(node):\n    tree = [node]\n    temp = [t.value for t in tree if t]\n    while tree:\n        tree = list(chain(*[[t.left, t.right] for t in tree if t]))\n        temp += [t.value for t in tree if t]\n    return temp", "def tree_by_levels(node):\n    levels = {}\n    def sweep(subnode, level):\n        if subnode != None:\n            levels[level] = levels.get(level, []) + [subnode.value]\n            sweep(subnode.left,  level + 1)\n            sweep(subnode.right, level + 1)\n    sweep(node, 0)\n    return sum((levels[k] for k in sorted(levels)), [])\n", "from collections import deque\n\n\ndef tree_by_levels(node):\n    q, result = deque(), []\n    if node is not None:\n        q.append(node)\n    while len(q):\n        node = q.popleft()\n        result.append(node.value)\n        q.extend(i for i in (node.left, node.right) if i is not None)\n    return result\n"]