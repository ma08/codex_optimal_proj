["def fixed_points_perms(n, k):\n    if k > n:\n        return 0\n    if k == n:\n        return 1\n    if k == 0:\n        subf = lambda n: 1 if n == 0 else n * subf(n - 1) + (-1)**n\n        return subf(n)\n    return fixed_points_perms(n-1, k-1) * n // k\n", "from functools import lru_cache\nfrom math import factorial as f\n@lru_cache(maxsize=None)\ndef all_permuted(n) : return [1,0][n] if n<2 else (n-1)*(all_permuted(n-1)+all_permuted(n-2))\nfixed_points_perms=lambda n,k:all_permuted(n - k)*f(n)//(f(k)*f(n-k)) if n>=k else 0", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef f(n):\n    return (n-1) * (f(n-1) + f(n-2)) if n > 2 else int(n != 1)\n\ndef fixed_points_perms(n,k):\n    return n * fixed_points_perms(n-1, k-1) // k if k else f(n)", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef f(n):\n    if n <= 2:\n        return n - 1\n    return (n-1) * (f(n-1) + f(n-2))\n\ndef fixed_points_perms(n,k):\n    if n == k:\n        return 1\n    elif k >= n - 1:\n        return 0\n    elif k == 0:\n        return f(n)\n    return n * fixed_points_perms(n-1, k-1) // k", "subfactorial, factorial = [1, 0], [1]\nfor n in range(1, 10 ** 4):\n    subfactorial.append(n * (subfactorial[-1] + subfactorial[-2]))\n    factorial.append(n * factorial[-1])\n\ndef fixed_points_perms(n, k):\n    return factorial[n] // factorial[n-k] // factorial[k] * subfactorial[n-k]\n", "from math import factorial as fact\nA000166 = [1,0]\nfor n in range(2,9000): A000166.append((n-1)*(A000166[n-1]+A000166[n-2]))\n\n\n# this is just A000166(n-k)*binomial(n,k)\ndef fixed_points_perms(n,k):\n    if n<k: return 0\n    return A000166[n-k]*fact(n)//(fact(k)*fact(n-k))", "from collections import deque\nfrom math import factorial \n\ndef fixed_points_perms(n,m): \n    if m >= n : return [1,0][m>n]\n    \n    def dear(n):\n        arr, i  = deque([1,0,1]), 3 \n        while i < n+1 :\n            arr.append((i-1)*(arr[-1] + arr[-2]))\n            arr.popleft()\n            i+=1\n        return arr[-1]\n\n    de = [1,0,1][n-m] if n-m<=2  else dear(n-m)\n\n    return (factorial(n)*de)//(factorial(n-m)*factorial(m))", "def fixed_points_perms(n,k):\n    fact_list = [0,1]\n    dearr_list = [1, 0]\n    if k==n:\n        return 1\n    elif k>n:\n        return 0\n        \n    if k != 0:\n        for i in range(2, n+1):\n            fact_list.append(i*fact_list[-1])\n        combinations = fact_list[-1]//(fact_list[k]*fact_list[n-k])\n    else:\n        combinations = 1\n    \n    for i in range(2, n-k+1):\n        dearr_list.append((i-1)*(dearr_list[-1]+dearr_list[-2]))\n    print(combinations, dearr_list[-1])\n    return int(combinations) * dearr_list[-1]", "f=[1,0,1,2,9,44]\nfor i in range(6,10000):\n    f.append(i*f[-1]+(-1)**i)\n\n\ndef c(x,y):\n    if y>x: return 0\n    if y>(x//2): y=x-y\n    mul=1\n    for i in range(1,y+1):\n        mul = mul*(x-i+1) // i\n    print(mul)\n    return mul\n\n\ndef fixed_points_perms(n,k):\n    \n    return c(n,k) * f[n-k]", "from math import factorial\nfac = factorial  \nsubfac = lambda n: n * subfac(n-1)+(-1) ** n if not n == 0 else 1\ndef fixed_points_perms(n,k):\n    if n < k: return 0\n    return (fac(n)//(fac(n-k)*fac(k))) * subfac(n-k)"]