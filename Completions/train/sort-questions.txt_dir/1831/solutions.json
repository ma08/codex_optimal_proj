["class Solution:\n     def movesToChessboard(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         rows = [1]\n \n         for i in range(1, len(board)):\n             num = self.get_num(board[0], board[i])\n             if 0 <= num <= 1:\n                 rows.append(num)\n             else:\n                 return -1\n \n         r1 = self.swap_count(rows)\n         if r1 != -1:\n             r2 = self.swap_count(board[0])\n \n         if r1 == -1 or r2 == -1:\n             return -1\n         else:\n             return r1 + r2\n \n     def get_num(self, r1, r2):\n         eq = True\n         op = True\n \n         for i in range(len(r1)):\n             if r1[i] == r2[i]:\n                 op = False\n             else:\n                 eq = False\n \n         if eq:\n             return 1\n         elif op:\n             return 0\n         else:\n             return -1\n \n     def swap_count(self, bits):\n         n = len(bits)\n \n         ones = sum(bits)\n         zeros = n - ones\n \n         ones_in_even = 0\n         zeros_in_even = 0\n         for i in range(0, n, 2):\n             ones_in_even += bits[i]\n             zeros_in_even += (1 - bits[i])\n \n         if abs(ones - zeros) > 1:\n             return -1\n \n         # get rid of smaller ones\n         if n % 2 == 0:\n             return min(zeros_in_even, ones_in_even)\n         elif ones > zeros:\n             return zeros_in_even\n         else:\n             return ones_in_even", "class Solution:\n     def movesToChessboard(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         N = len(board)\n         for i in range(N):\n             for j in range(N):\n                 if board[0][0] ^ board[0][j] ^ board[i][0] ^ board[i][j]: return -1\n             \n         \n         rowSum = 0\n         colSum = 0\n         rowSwap = 0\n         colSwap = 0\n         for i in range(N):\n             rowSum += board[0][i]\n             colSum += board[i][0]\n             rowSwap += board[0][i] == i%2\n             colSwap += board[i][0] == i%2\n         \n         if rowSum < N // 2 or rowSum > (N+1) // 2: return -1\n         if colSum < N // 2 or colSum > (N+1) // 2: return -1\n         if N % 2:\n             if rowSwap % 2: rowSwap = N - rowSwap\n             if colSwap % 2: colSwap = N - colSwap\n         \n         else:\n             rowSwap = min(rowSwap, N - rowSwap)\n             colSwap = min(colSwap, N - colSwap)\n         \n         return (rowSwap + colSwap) // 2", "class Solution:\n     def movesToChessboard(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         n = len(board)\n         for i in range(1, n):\n             for j in range(1, n):\n                 if (board[0][0] + board[0][j] + board[i][0] + board[i][j]) % 2 != 0:\n                     return -1\n         result = 0\n         x = 0\n         y = 0\n         for i in range(0, n):\n             if i % 2 == 0 and board[i][0] == 1:\n                 x += 1\n             elif i % 2 == 1 and board[i][0] == 0:\n                 y += 1\n         if n % 2 == 0:\n             if x != y:\n                 return -1\n             result += min(x, n // 2 - x)\n         else:\n             if x == y:\n                 result += x\n             elif (n + 1) // 2 - x == (n - 1) // 2 - y:\n                 result += (n + 1) // 2 - x\n             else:\n                 return -1\n         x = 0\n         y = 0\n         for i in range(0, n):\n             if i % 2 == 0 and board[0][i] == 1:\n                 x += 1\n             elif i % 2 == 1 and board[0][i] == 0:\n                 y += 1\n         if n % 2 == 0:\n             if x != y:\n                 return -1\n             result += min(x, n // 2 - x)\n         else:\n             if x == y:\n                 result += x\n             elif (n + 1) // 2 - x == (n - 1) // 2 - y:\n                 result += (n + 1) // 2 - x\n             else:\n                 return -1\n         return result\n", "\n class Solution:\n     def movesToChessboard(self, board):\n         N = len(board)\n         R = [sum([board[i][j]<<j for j in range(N)]) for i in range(N) ]\n         C = [sum([board[i][j]<<i for i in range(N)]) for j in range(N) ]\n         def calcMove(R, N):\n             def sumOne(n) :\n                 k = 0\n                 while n:\n                     n = n&(n-1)\n                     k+=1\n                 return k\n             d = {}\n             for i in range(N):\n                 if not R[i] in d:\n                     d[R[i]] = []\n                 d[R[i]].append(i)\n             akey =[]\n             for k in d:\n                 akey.append(k)\n             \n             if len(akey)==2 and akey[0]^akey[1] == (1<<N) -1 and abs(sumOne(akey[0])-sumOne(akey[1]))<=1:\n                 a0, a1 = d[akey[0]], d[akey[1]]\n                 if abs(len(a0)-len(a1))>1:\n                     return -1\n                 if len(a0) >= len(a1):\n                     res = sum( [i%2  for i in a0])\n                 else:\n                     res = sum( [i%2  for i in a1])\n                 return res if N%2 else min(res, max(N//2-res, 0))\n             return -1\n         r, c = calcMove(R, N), calcMove(C, N)\n         return -1 if r == -1 or c == -1 else r + c", "class Solution:\n     def movesToChessboard(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         import collections \n         N=len(board)\n         result=0\n         for count in (collections.Counter(map(tuple,board)),collections.Counter(zip(*board))):\n             if len(count)!=2 or sorted(count.values())!=[N//2,(N+1)//2]:\n                 return -1\n             seq1,seq2=count\n             if any(x==y for x,y in zip(seq1,seq2)):\n                 return -1\n             begins=[int(seq1.count(1)*2>N)] if N%2 else [0,1]\n             result+=min(sum(int(i%2!=v) for i,v in enumerate(seq1,begin)) for begin in begins)//2\n         return result", "# observation:\n #1) row swapping resolves adjacent vertical 1s and 0s.\n #   col swapping resolves adjacent horizontal 1s and 0s.\n #2) if mask = all 1s with len of n. then the rows/cols must be\n #   x, x^mask, x, x^mask, ...\n class Solution:\n     def movesToChessboard(self, board):\n         \"\"\"\n         :type board: List[List[int]]\n         :rtype: int\n         \"\"\"\n         n = len(board)\n         all1s = 2**n - 1\n         def countSwap(lines):\n             lines = [int(l, base=2) for l in lines]\n             x, y = lines.count(lines[0]), lines.count(lines[0] ^ all1s)\n             if x + y < n or abs(x - y) > 1:\n                 return -1\n             nums = [lines[0], lines[0] ^ all1s]\n             if x == y:\n                 return min(sum(nums[i % 2] != lines[i] for i in range(n)), sum(nums[1 - i % 2] != lines[i] for i in range(n))) // 2\n             else:\n                 if x < y:\n                     nums = [lines[0] ^ all1s, lines[0]]\n                 return sum(nums[i % 2] != lines[i] for i in range(n)) // 2\n         \n         cnt1 = countSwap([''.join(map(str, r)) for r in board])\n         cnt2 = countSwap([''.join(str(board[i][j]) for i in range(n)) for j in range(n)])\n         if cnt1 < 0 or cnt2 < 0:\n             return -1\n         return cnt1 + cnt2\n         "]