["class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         # left = 0\n         # right = len(nums) - 1\n         # while left <= right: \n         #     mid = int((left + right)/2)\n         #     if nums[mid] == target: \n         #         return mid\n         #     elif (nums[right] < target) or (nums[mid] > target and nums[right] > target):  \n         #         right = mid - 1\n         #     else: \n         #         left = mid + 1\n         # return -1\n         \n         left = 0\n         right = len(nums) - 1\n         while left <= right: \n             mid = int((left + right)/2)\n             if nums[mid] == target: \n                 return mid\n             if (nums[left] < nums[mid]): \n                 if (target < nums[left]) or (target > nums[mid]): \n                     left = mid + 1\n                 else: \n                     right = mid - 1\n             elif (nums[left] > nums[mid]): \n                 if (target < nums[mid]) or (target >= nums[left]): \n                     right = mid - 1\n                 else: \n                     left = mid + 1\n             else: \n                 if nums[right] == target: \n                     return right\n                 else: \n                     return -1\n         return -1", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         l, r = 0, len(nums)-1\n         while l <= r:\n             mid = (l+r)//2\n             if nums[mid] == target:\n                 return mid\n             elif nums[mid] >= nums[l]:\n                 if nums[l] <= target < nums[mid]:\n                     r = mid-1\n                 else:\n                     l = mid+1\n             else:\n                 if nums[mid] < target <= nums[r]:\n                     l = mid+1\n                 else:\n                     r = mid-1\n         return -1", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         length = len(nums)\n         if length <= 0:\n             return -1\n         pivot = self.find_pivot(0, length-1, nums)\n         print(pivot)\n         search_index_A = self.binary_search(0, max(pivot-1, 0), nums, target)\n         search_index_B = self.binary_search(pivot, length-1, nums, target)\n         if search_index_A >= 0:\n             return search_index_A\n         elif search_index_B >= 0:\n             return search_index_B\n         else:\n             return -1\n     \n     def find_pivot(self, left_ind, right_ind, nums):\n         mid = left_ind + (right_ind - left_ind)//2\n         if left_ind == right_ind:\n             return left_ind\n         elif nums[mid] < nums[mid-1]:\n             return mid\n         elif nums[right_ind] < nums[mid]:\n             return self.find_pivot(mid+1, right_ind, nums)\n         else:\n             return self.find_pivot(left_ind, max(0,mid-1), nums)\n     \n     def binary_search(self, left_ind, right_ind, nums, target):\n         mid = left_ind + (right_ind - left_ind)//2\n         if nums[mid] == target:\n             return mid\n         elif left_ind == right_ind:\n             return -1\n         elif nums[mid] < target:\n             return self.binary_search(mid+1, right_ind, nums, target)\n         else:\n             return self.binary_search(left_ind, max(left_ind,mid-1), nums, target)\n", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         left, right = 0, len(nums)-1\n         while left <= right:\n             mid = (left+right) // 2\n             if nums[mid] == target:\n                 return mid\n             elif nums[mid] >= nums[left]:\n                 if nums[left] <= target < nums[mid]:\n                     right = mid-1\n                 else:\n                     left = mid+1\n             else:\n                 if nums[mid] < target <= nums[right]:\n                     left = mid+1\n                 else:\n                     right = mid-1\n         return -1\n", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         # if target in nums:\n         #     return nums.index(target)\n         # else:\n         #     return -1\n \n         low, high = 0, len(nums)-1\n         while low < high:\n             mid = (low+high)//2\n             if nums[mid] > nums[high]:\n                 low = mid+1\n             else:\n                 high = mid\n         start = low\n         low, high = 0, len(nums)-1\n         while low <= high:\n             mid = (low+high)//2\n             realMid = (mid+start) % (len(nums))\n             if nums[realMid] == target:\n                 return realMid\n             if target > nums[realMid]:\n                 low = mid+1\n             else:\n                 high = mid-1\n         return -1\n         \n                 \n", "class Solution:\n     def search_interval(self, start, end, nums, target):\n         if start == end:\n             if nums[start] == target:\n                 return start\n             else:\n                 return -1\n \n         size = end - start\n         half = size // 2\n         new_start_1 = start\n         new_end_1 = start + half\n         new_start_2 = start + half + 1\n         new_end_2 = end\n \n         # check first interval\n         first_half_sorted = False\n         first_half_contains = False\n         second_half_sorted = False\n         second_half_contains = False\n         if nums[new_end_1] >= nums[new_start_1]:\n             first_half_sorted = True\n             if (target >= nums[new_start_1]) and (target <= nums[new_end_1]):\n                 first_half_contains = True\n         if nums[new_end_2] >= nums[new_start_2]:\n             second_half_sorted = True\n             if (target >= nums[new_start_2]) and (target <= nums[new_end_2]):\n                 second_half_contains = True\n             \n         if first_half_contains:\n             return self.search_interval(new_start_1, new_end_1, nums, target)\n         elif second_half_contains:\n             return self.search_interval(new_start_2, new_end_2, nums, target)\n         elif first_half_sorted:\n             return self.search_interval(new_start_2, new_end_2, nums, target)\n         elif second_half_sorted:\n             return self.search_interval(new_start_1, new_end_1, nums, target)\n \n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         \n         if len(nums) == 0:\n             return -1\n \n         return self.search_interval(0, len(nums) - 1, nums, target)", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         length = len(nums)\n         if length <= 0:\n             return -1\n         pivot = self.find_pivot(0, length-1, nums)\n         print(pivot)\n         search_index_A = self.binary_search(0, max(pivot-1, 0), nums, target)\n         search_index_B = self.binary_search(pivot, length-1, nums, target)\n         if search_index_A >= 0:\n             return search_index_A\n         elif search_index_B >= 0:\n             return search_index_B\n         else:\n             return -1\n     \n     def find_pivot(self, left_ind, right_ind, nums):\n         mid = left_ind + (right_ind - left_ind)//2\n         if left_ind == right_ind:\n             return left_ind\n         elif nums[mid] < nums[mid-1]:\n             return mid\n         elif nums[right_ind] < nums[mid]:\n             return self.find_pivot(mid+1, right_ind, nums)\n         else:\n             return self.find_pivot(left_ind, max(0,mid-1), nums)\n     \n     def binary_search(self, left_ind, right_ind, nums, target):\n         mid = left_ind + (right_ind - left_ind)//2\n         print(nums)\n         print(mid)\n         if nums[mid] == target:\n             return mid\n         elif left_ind == right_ind:\n             return -1\n         elif nums[mid] < target:\n             return self.binary_search(mid+1, right_ind, nums, target)\n         else:\n             return self.binary_search(left_ind, max(left_ind,mid-1), nums, target)\n \n # [5,1,3]\n # [0]\n \n # find_pivot(0,2,[5,1,3])\n # left = 0\n # right = 2\n # mid = 0 + 2//2 = 1\n # nums[mid] < nums[mid-1]\n # pivot = 1\n # binary_search(0, max(pivot-1,0), ...)\n # left = 0, right = 0\n # search_index_A = -1\n # binary_search(pivot, length-1, ...)\n # left = 1, right = 2\n # mid = 1 + (2-1)//2 = 1\n # binary_search(1, max(0,0), ...)\n # search_index_B = -1\n", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         idx = -1\n         for i in range(1,len(nums)):\n             if nums[i] < nums[i-1]:\n                 idx = i\n                 break\n         if idx == -1:\n             return self.bin_search(nums, 0, len(nums), target)\n         else:\n             if target < nums[0] or target < nums[-1]:\n                 return self.bin_search(nums, idx, len(nums), target)\n             elif target > nums[-1] or target > nums[0]:\n                 return self.bin_search(nums, 0, idx,  target)\n             else: \n                 assert(False)\n             \n     def bin_search(self, nums, i1, i2, target):\n         while i1 < i2:\n             mi = (i1 + i2) // 2\n             if nums[mi] == target: return mi\n             if nums[mi] > target: i2 = mi\n             else: i1 = mi + 1\n         \n         return -1\n", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         for i in range(0,len(nums)):\n             if nums[i] == target:\n                 return i\n         return -1", "class Solution:\n     def search(self, nums, target):\n         if len(nums) <= 3: return nums.index(target) if target in nums else -1\n         l, r = 0, len(nums) - 1\n         while l < r:\n             m = (l + r) // 2\n             left = nums[l]\n             mid = nums[m]\n             right = nums[r]\n             if left == target:\n                 return l\n             if mid == target:\n                 return m\n             if right == target:\n                 return r\n             elif left < right:\n                 print(('mono:', l, r))\n                 if mid < target:\n                     l = m\n                     r -= 1\n                 else:\n                     r = m\n                     l += 1\n             else:\n                 print(('not mono:', l, r))\n                 if left < target < mid or mid < left < target or target < mid < left:\n                     r = m\n                     l += 1\n                 else:\n                     l = m\n                     r -= 1\n         return -1\n", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         low = 0\n         high = len(nums)-1\n         while high >= low:\n             mid = high+low//2\n             if nums[mid] == target:\n                 return mid\n             elif nums[mid] > nums[high]:\n                 low = mid+1\n             else:\n                 print (\"comes here\")\n                 print (high)\n                 print (mid)\n                 print (low)\n                 high = mid-1\n                 print (high)\n         return -1\n", "class Solution:\n     def search(self, nums, target):\n         \"\"\"\n         :type nums: List[int]\n         :type target: int\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return -1\n         \n         # [4,5,6,7,0,1,2]\n         # 0\n         start, end = 0, len(nums) - 1\n         while start + 1 < end:\n             mid = start + (end - start) // 2\n             if target < nums[end]:\n                 if nums[mid] < target or nums[mid] > nums[end]:\n                     start = mid\n                 elif nums[mid] > target and nums[mid] < nums[end]:\n                     end = mid\n                 else:\n                     return mid\n             elif target > nums[end]:\n                 if nums[mid] > target or nums[mid] < nums[end]:\n                     end = mid\n                 elif nums[mid] < target and nums[mid] > nums[end]:\n                     start = mid\n                 else:\n                     return mid\n             else:\n                 return len(nums) - 1\n         \n         if nums[start] == target:\n             return start\n         if nums[end] == target:\n             return end\n         \n         return -1"]