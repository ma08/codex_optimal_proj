["def distribute(nodes, workload):\n    w = list(range(workload))[::-1]\n    return [[w.pop() for _ in range(workload // nodes + (workload % nodes > n))] for n in range(nodes)]", "def distribute(n, w):\n    g, (d,r) = iter(range(w)), divmod(w,n)\n    return [ [next(g) for _ in range(d+(i<r))] for i in range(n)]", "def distribute(nodes, workload):\n    (q, r), it = divmod(workload, nodes), iter(range(workload))\n    return [[next(it) for _ in range(q + (n < r))] for n in range(nodes)]", "def distribute(nodes, workload):\n    div, mod = divmod(workload, nodes)\n    breakpoint = lambda i: i * div + (i if i < mod else mod)\n    return [list(range(breakpoint(i), breakpoint(i+1))) for i in range(nodes)]\n\n\n# one-liner\n#def distribute(n, w):\n#    return [list(range(i*(w//n)+w%n-max(0, w%n-i), (i+1)*(w//n)+w%n-max(0, w%n-i-1))) for i in range(n)]\n", "from itertools import accumulate, tee\n\ndef distribute(nodes, workload):\n    q, r = divmod(workload, nodes)\n    ns = [q + (i < r) for i in range(nodes)]\n    xs = list(accumulate([0] + ns))\n    return [list(range(i, j)) for i, j in zip(xs, xs[1:])]\n    \n", "def distribute(nodes, workload):\n    jobs_per_server, remaining = divmod(workload, nodes)\n    jobs, start = [], 0\n    for _ in range(nodes):\n        how_many = jobs_per_server + (remaining > 0)\n        jobs.append(list(range(start, start + how_many)))\n        start += how_many\n        remaining -= 1\n    return jobs", "import numpy as np\ndef distribute(nodes, workload):\n    lst=[]\n    value = 0\n    for i in range(nodes):\n        length = int(np.ceil((workload-value)/(nodes-i)))\n        lst.append([l for l in range(value,value+length)])\n        value = value + length\n    return lst", "import numpy\ndef distribute(nodes, workload):\n    return [list(i) for i in numpy.array_split(numpy.array(range(0, workload)),nodes)]", "def distribute(nodes, workload):\n    n = workload // nodes\n    r = workload % nodes\n    jobs = []\n    works = [i for i in range(workload)]\n    j = 0\n    for i in range(nodes):\n        if i < r:\n            jobs.append([works.pop(0) for i in range(n+1)])\n        else:\n            jobs.append([works.pop(0) for i in range(n)])\n    return jobs", "def distribute(nodes, workload):\n    a=[[0] for x in range(nodes)]\n    w=workload\n    k=workload//nodes\n    for j in range(0,workload%nodes):\n     a[j][0]+=1\n    for i in range(0,len(a)):\n     for j in range(0,k):\n      a[i][0]+=1\n    total=0\n    b=[[] for x in range(nodes)]\n    for j in range(0,len(a)):\n     for i in range(total, total+a[j][0]):\n         b[j].append(i)\n     total+=a[j][0]\n    return b\n\n"]