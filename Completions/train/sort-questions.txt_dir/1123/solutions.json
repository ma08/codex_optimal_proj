["# cook your dish here\nfrom sys import stdin, stdout\nfrom math import ceil\n\n\ndef solve():\n    for _ in range(int(input())):\n        n, m = map(int, stdin.readline().split())\n        par = [i for i in range(n)]\n        for i in range(m):\n            ta, tb = map(int, stdin.readline().strip().split())\n            a, b = min(ta, tb), max(ta, tb)\n            for j in range(n):\n                if par[j] == par[b] and j != b:\n                    par[j] = par[a]\n            par[b] = par[a]\n\n        q = int(input())\n        while q:\n            q -= 1\n            x, y = map(int, stdin.readline().split())\n            if par[x] == par[y]:\n                print(\"YO\")\n            else:\n                print(\"NO\")\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "t=int(input())\nfor i in range(0,t):\n\tn,m=map(int,input().split())\n\tl=[0]*n\n\tfor j in range(0,n):\n\t\tl[j]=j\n\tfor j in range(0,m):\n\t\ta,b=map(int,input().split())\n\t\tif(l[a]<l[b]):\n\t\t\ttemp=l[b]\n\t\t\tfor p in range(0,n):\n\t\t\t\tif(l[p]==temp):\n\t\t\t\t\tl[p]=l[a]\n\t\telif(l[b]<l[a]):\n\t\t\ttemp=l[a]\n\t\t\tfor p in range(0,n):\n\t\t\t\tif(l[p]==temp):\n\t\t\t\t\tl[p]=l[b]\n\tq=int(input())\n\tfor p in range(0,q):\n\t\tx,y=map(int,input().split())\n\t\tif(l[x]==l[y]):\n\t\t\tprint(\"YO\")\n\t\telse:\n\t\t\tprint(\"NO\")\n\t\t\n\n\n\n\n\n           ", "\nimport sys\n\nsys.setrecursionlimit(10000)\n\n\n\ndef dfs(n):\n    ans = set()\n    queue = [n]\n    bool[n] = True\n    ans.add(n)\n    while queue!=[]:\n        z = queue.pop(0)\n        ans.add(z)\n        for j in hash[z]:\n            if bool[j] == False:\n                bool[j] = True\n                queue.append(j)\n\n    return ans\n\n\n\n\n\n\n\nfrom collections import defaultdict\n\nt = int(input())\n\nfor _ in range(t):\n\n    ans = []\n    hash = defaultdict(list)\n    n,m = map(int,sys.stdin.readline().strip().split())\n    for i in range(m):\n        a,b = map(int,sys.stdin.readline().strip().split())\n        hash[a].append(b)\n        hash[b].append(a)\n\n    for i in range(n):\n        bool = [False]*n\n        z = dfs(i)\n        hash[i] = z\n\n\n\n    q = int(input())\n    for i in range(q):\n\n        a,b = map(int,sys.stdin.readline().strip().split())\n\n        dfs(a)\n        # print(bool)\n        if b in hash[a]:\n            z = 'YO'\n            sys.stdout.write(z)\n            print()\n\n        else:\n            z = 'NO'\n            sys.stdout.write(z)\n            print()\n\n\n", "from collections import defaultdict\r\n \r\nclass Graph:\r\n \r\n    def __init__(self,vertices):\r\n \r\n        self.graph = defaultdict(list)\r\n        self.DFSList = defaultdict(list)\r\n        \r\n        for i in range(0,vertices):\r\n        \tself.graph[i]=[]\r\n        \tself.DFSList[i]=[]\r\n \t\r\n\r\n    def addEdge(self,u,v):\r\n        if u!=v:\r\n        \tself.graph[u].append(v)\r\n        \tself.graph[v].append(u)\r\n        \t\r\n    def DFSUtil(self,v,visited,n):\r\n \r\n        visited[v]= True\r\n        self.DFSList[n].append(v)\r\n       \r\n        \r\n        for i in self.graph[v]:\r\n            if visited[i] == False:\r\n                self.DFSUtil(i, visited,n)\r\n \r\n    def DFS(self,v):\r\n \r\n        visited = [False]*(len(self.graph))\r\n        self.DFSUtil(v,visited,v)\r\n \r\nt=int(input())\r\nfor z in range(0,t):\r\n\tn,m=map(int,input().split())\r\n\tg = Graph(n)\r\n\r\n\tfor M in range(0, m):\r\n\t\tu,v = map(int,input().split())\r\n\t\tg.addEdge(u,v)\r\n\t\r\n\tfor i in range(0,n):\r\n\t\tg.DFS(i)\r\n\t\t\r\n\tq = int(input())\r\n\tfor Q in range(0, q):\r\n\t\tu,v = map(int,input().split())\r\n\t\tif v in g.DFSList[u]:\r\n\t\t\tprint(\"YO\")\r\n\t\telse:\r\n\t\t\tprint(\"NO\")\r\n"]