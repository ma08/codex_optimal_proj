["class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-target]*target\n        for t in range(1, target+1):\n            dp[t] = max([dp[t-i] for i in cost if i<=t]+[dp[t]]) + 1\n        if dp[-1]<=0: return '0'\n        res = ''\n        for i in range(8, -1, -1):\n            while target>=cost[i] and dp[target-cost[i]]==dp[target]-1:\n                res += str(i+1)\n                target -= cost[i]\n        return res", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        @lru_cache(None)\n        def dfs(c):\n            #if c==0: print(c,cur)\n            if c == 0: return 0\n            ans = -float('inf')\n            for i in range(9):\n                if cost[i] <= c:\n                    ans = max(ans,10 * dfs(c-cost[i])+i+1)\n            return ans\n        res = dfs(target)\n        return str(res) if res> 0 else '0' \n'''\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(target):\n            if target == 0: return 0\n            res = -float(\\\"inf\\\")\n            for i in range(len(cost)):\n                if cost[i] <= target:\n                    res = max(res, 10*dfs(target - cost[i])+i+1)\n            return res\n        res = dfs(target)\n        return str(res) if res > 0 else \\\"0\\\"\n'''", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-1] * (target + 5000)\n        for t in range(1, target + 1):\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n        return str(max(dp[t], 0))", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n    \n        def memo(f):\n            dic = {}\n            def f_alt(*args):\n                if args not in dic:\n                    dic[args] = f(*args)\n                return dic[args]\n            return f_alt\n\n        key = lambda s: (len(s),s)\n        \n        cands = {}\n        for i,c in enumerate(cost):\n            cands[c]=i+1\n        \n        @memo\n        def f(tar):\n            if tar == 0:\n                return 0\n            if tar>0:\n                ans = 0\n                for c in cands:\n                    if f(tar-c) != None:\n                        ans = max(ans, 10*f(tar-c) + cands[c])\n                return ans or None\n        \n        return str(f(target) or 0)\n", "'''\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        @lru_cache\n        def dfs(c, cur):\n            #if c==0: print(c,cur)\n            if c < 0: return 0\n            if c == 0: return cur \n            ans = 0\n            for i in range(9):\n                ans = max(ans,dfs(c-cost[i], 10*cur+i+1))\n            return ans\n        return str(dfs(target, 0))\n'''\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        '''\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(target,count):\n            if target == 0:\n                return 0\n            \n            res = -float(\\\"inf\\\")\n            \n            for i in range(len(cost)):\n                if cost[i] <= target:\n                    res = max(res, 10*dfs(target - cost[i], count+1)+i+1)\n            \n            \n            return res\n        \n        res = dfs(target,0)\n        \n        return str(res) if res > 0 else \\\"0\\\"\n        '''\n        dp = [0] + [-1] * (target + 5000)\n        for t in range(1, target + 1):\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n        return str(max(dp[t], 0))", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-1] * (target + 5000)\n        for t in range(1, target + 1):\n            p = iter(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n            dp[t] = max(p)\n        return str(max(dp[t], 0))\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [float('-inf')] * (target + 1)\n        dp[0] = 0\n        for i in range(1, 10):\n            for j in range(1, target + 1):\n                c = cost[9 - i]\n                if c <= j:\n                    dp[j] = max(dp[j - c] * 10 + (10 - i), dp[j])\n                    \n        return str(dp[target]) if str(dp[target]) != '-inf' else '0'", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n          dp = [0] + [-1] * (target+ 5000)\n          for t in range(1, target + 1):\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n            #print(dp)\n          return str(max(dp[t], 0))\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0]\n        for i in range(1,target+1):\n            result = 0\n            for j,c in enumerate(cost):\n                if i<c:\n                    continue\n                if dp[i-c] == 0 and i!=c:\n                    continue\n                result = max(result,10*dp[i-c]+j+1)\n            dp.append(result)\n        return str(dp[-1])", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        '''dp = [0]\n        for i in range(1,target+1):\n            result = 0\n            for j,c in enumerate(cost):\n                if i<c:\n                    continue\n                if dp[i-c] == 0 and i!=c:\n                    continue\n                result = max(result,10*dp[i-c]+j+1)\n            dp.append(result)\n        return str(dp[-1])'''\n        cache = {}\n        def helper(remaining):\n            if remaining == 0:\n                return ''\n            if remaining in cache:\n                return cache[remaining]\n            maximum = '0'\n            for i in range(len(cost)):\n                if cost[i] > remaining:\n                    continue\n                result = helper(remaining - cost[i])\n                if result == '0':\n                    continue\n                maximum = larger(maximum, str(i+1) + result)\n            cache[remaining] = maximum\n            return maximum\n\n        def larger(a, b):\n            if len(a) > len(b):\n                return a\n            if len(a) < len(b):\n                return b\n            return max(a, b)\n\n        return helper(target)", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [float('-inf')] * target\n        for i in range(9, 0, -1):\n            for j in range(1, target+1):\n                if j >= cost[i - 1]:\n                    dp[j] = max(dp[j], (dp[j-cost[i - 1]] * 10) + i)\n        return str(dp[target]) if dp[target] > 0 else '0'\n\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] * (target+1)\n        \n        for t in range(1, target+1):\n            for d, c in zip(range(1, len(cost)+1), cost):\n                if t==c:\n                    dp[t] = max(dp[t], d)\n                if c < t and dp[t-c] != 0:\n                    dp[t] = max(dp[t], dp[t-c] * 10 + d)\n        # print(dp)\n        return str(dp[target])", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-1] * (target)\n        for t in range(1, target + 1):\n            for i, c in enumerate(cost):\n                if t - c >= 0:\n                    dp[t] = max(dp[t], dp[t - c] * 10 + i + 1)\n        return str(max(dp[target], 0))\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0]\n        for i in range(1,target+1):\n            best = 0\n            for j, c in enumerate(cost):\n                if i - c < 0:\n                    continue\n                if dp[i-c] == 0 and i != c:\n                    continue\n                best = max(best, 10*dp[i-c] + j + 1)\n            dp.append(best)\n        return str(dp[-1])\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        '''\n        pairs = [(c,-i-1) for i,c in enumerate(cost)]\n        #pairs.sort()\n        out = 0\n        def dfs(target, painted) -> bool:\n            nonlocal out\n            if target == 0:\n                out = max(out,int(painted))\n                return\n            if target < 0:\n                return\n            for i in range(9):\n                dfs(target - pairs[i][0], painted + str(-pairs[i][1]))\n        dfs(target,\\\"\\\")\n        return str(out)\n        '''          ", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        #def largestNumber(self, cost, target):\n            \n        dp = [0] + [-1]*(target)\n        for i in range(1,target+1):\n            for j,c in enumerate(cost):\n                if c<=i:\n                    dp[i] = max(dp[i],dp[i-c]*10 + j + 1)\n                \n        \n        return str(max(dp[target],0))\n            \n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-1] * (5000+ target)\n        for i in range(1, target+1):\n            for j, c in enumerate(cost):\n                dp[i] = max(dp[i], 10 * dp[i-c] + j + 1)\n        return str(max(dp[target], 0))\n    '''  \n    def largestNumber(self, cost, target):\n        dp = [0] + [-1] * (target + 5000)\n        for t in xrange(1, target + 1):\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n        return str(max(dp[t], 0))\n    '''", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        self.min_cost = min(cost)\n        self.cost = cost\n        self.mem = dict()\n        rv = self.dfs(target)\n        if rv is None:\n            return '0'\n        return rv\n        \n    def dfs(self, target):\n        if target == 0:\n            return ''\n        elif target < self.min_cost:\n            return None\n        \n        key = (target)\n        if key in self.mem:\n            return self.mem[key]\n        \n        res = ''\n        for i, c in enumerate(self.cost):\n            rv = self.dfs(target - c)\n            if rv != None:\n                res = self.get_max(res, str(i+1) + rv)\n\n        if res == '':\n            res = None\n        self.mem[key] = res\n        return res\n            \n            \n            \n    def get_max(self, s1, s2):\n        if len(s1) != len(s2):\n            if len(s1) > len(s2):\n                return s1\n            return s2\n        if s1 > s2:\n            return s1\n        return s2", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-float('inf')] * (5000+ target)\n        for i in range(1, target+1):\n            for j, c in enumerate(cost):\n                dp[i] = max(dp[i], 10 * dp[i-c] + j + 1)\n        return str(max(dp[target], 0))\n    '''  \n    def largestNumber(self, cost, target):\n        dp = [0] + [-1] * (target + 5000)\n        for t in xrange(1, target + 1):\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n        return str(max(dp[t], 0))\n    '''", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-1] * (target)\n        for t in range(1, target + 1):\n            for i, c in enumerate(cost):\n                if t - c >= 0:\n                    dp[t] = max(dp[t], dp[t - c] * 10 + i + 1)\n        return str(max(dp[target], 0))", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        #since cost limit is 5000, we can add 5000\n        #to dp size to avoid checking c < target\n        dp = [0] + [-1] * (target + 5000)\n        for t in range(1, target + 1):\n            for i, c in enumerate(cost):\n                #the new digit is i + 1, the previous digit dp[t - 1] move 1 step to left\n                dp[t] = max(dp[t], dp[t - c] * 10 + (i + 1))\n        #since we set dp initial value to be -1, question require 0 if not found.\n        return str(max(dp[target], 0))\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-1] * (target + 1)\n        for t in range(1, target + 1):\n            dp[t] = max(dp[max(t - c, -1)] * 10 + i + 1 for i, c in enumerate(cost))\n        return str(max(dp[t], 0))", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-1] * target\n        for t in range(1, target + 1):\n            for i, c in enumerate(cost):\n                if c <= t:\n                    dp[t] = max(dp[t], dp[t - c] * 10 + (i + 1))\n        return str(max(dp[-1], 0))\n", "\nfrom typing import List\nimport numpy\nimport functools\n\nclass Solution:\n\n  def largestNumber(self, cost: List[int], target: int) -> str:\n\n    cache = {}\n    def solve(remaining):\n      if not remaining:\n        return ''\n      if remaining in cache:\n        return cache[remaining]\n\n      maxium = '0'\n      for i in range(len(cost)):\n        if cost[i] > remaining:\n          continue\n        result = solve(remaining - cost[i])\n        if result == '0':\n          continue\n\n        maxium = larger(maxium, str(i+1) + result)\n        pass\n      cache[remaining] = maxium\n      return maxium\n      pass\n\n    def larger(a, b):\n      if len(a) > len(b):\n        return a\n\n      if len(a) < len(b):\n        return b\n\n      return max(a, b)\n\n    return solve(target)", "from functools import lru_cache\n\nclass Solution:\n    # def largestNumber(self, cost: List[int], target: int) -> str:\n#         def compare(a, b):\n#             if len(a) == 0:\n#                 return b\n#             if sum(a) > sum(b):\n#                 return a\n#             elif sum(b) > sum(a):\n#                 return b\n#             else:\n#                 j = -1\n#                 while j >= -len(a) and a[j] == b[j]:\n#                     j -= 1\n#                 if j < -len(a):\n#                     return a\n#                 if a[j] >= b[j]:\n#                     return a\n#                 else:\n#                     return b\n                \n#         @lru_cache(None)\n#         def dfs(idx, tgt):\n#             if idx == 0:\n#                 if tgt != 0:\n#                     return []\n#             if tgt == 0:\n#                 return [0, 0, 0, 0, 0, 0, 0, 0, 0]\n#             out = []\n#             for i in range(tgt // cost[idx] + 1):\n#                 nxt = dfs(idx - 1, tgt - i * cost[idx])\n#                 # print(nxt, i)\n#                 if len(nxt) != 0:\n#                     new = [x for x in nxt]\n#                     new[idx] += i\n#                     out = compare(out, new)\n#             return out\n        \n#         ans = '' \n#         r = dfs(8, target)\n#         for i, x in enumerate(r):\n#             ans += str(i + 1) * x\n#         return ans\n\n        def largestNumber(self, cost, target):\n            dp = [0] + [-1] * (target + 5000)\n            for t in range(1, target + 1):\n                dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n            return str(max(dp[t], 0))", "def dp(costs, target, mem):\n    if target == 0:\n        return ''\n    elif target in mem:\n        return mem[target]\n    \n    res = ''\n    for i in range(len(costs)):\n        if target - costs[i] >= 0:\n            current = dp(costs, target - costs[i], mem)\n            \n            if current is not None:\n                res = max([res, str(i+1) + current], key=lambda x: (len(x), x))\n        \n    mem[target] = res if res != '' else None\n    return res if res != '' else None\n\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        result = dp(cost, target, {})\n        \n        return result if result != '' and result is not None else '0'", "class Solution:\n    def largestNumber(self, cost, target):\n        dp = [0] + [-1] * (target + 5000)\n        for t in range(1, target + 1):\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n        return str(max(dp[t], 0))", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-1] * (target + 5000)\n        for t in range(1, target + 1):\n            p = []\n            for i, c in enumerate(cost):\n                p.append(dp[t - c] * 10 + i + 1)\n                dp[t] = max(p)\n        return str(max(dp[t], 0))\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        '''dp = [0]\n        for i in range(1,target+1):\n            result = 0\n            for j,c in enumerate(cost):\n                if i<c:\n                    continue\n                if dp[i-c] == 0 and i!=c:\n                    continue\n                result = max(result,10*dp[i-c]+j+1)\n            dp.append(result)\n        return str(dp[-1])'''\n        cache = {}\n        def helper(remaining):\n            if remaining == 0:\n                return ''\n            if cache.get(remaining) is not None:\n                return cache[remaining]\n            maximum = '0'\n            for i in range(len(cost)):\n                if cost[i] > remaining:\n                    continue\n                result = helper(remaining - cost[i])\n                if result == '0':\n                    continue\n                maximum = larger(maximum, str(i+1) + result)\n            cache[remaining] = maximum\n            return maximum\n\n        def larger(a, b):\n            if len(a) > len(b):\n                return a\n            if len(a) < len(b):\n                return b\n            return max(a, b)\n\n        return helper(target)", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        cache = {}\n        def helper(remaining):\n            if remaining == 0:\n                return ''\n            if remaining in cache:\n                return cache[remaining]\n            maximum = '0'\n            for i in range(len(cost)):\n                if cost[i] > remaining:\n                    continue\n                result = helper(remaining - cost[i])\n                if result == '0':\n                    continue\n                maximum = larger(maximum, str(i+1) + result)\n            cache[remaining] = maximum\n            return maximum\n\n        def larger(a, b):\n            if len(a) > len(b):\n                return a\n            if len(a) < len(b):\n                return b\n            return max(a, b)\n\n        return helper(target)", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        Memo = {}\n        Min = min(cost)\n        Memo[0] = [0,0,0,0,0,0,0,0,0,0]\n        def dfs(remain):\n            if remain in Memo:\n                return Memo[remain]\n            if remain < Min:\n                Memo[remain] = [0,0,0,0,0,0,0,0,0,-10000000]\n                return [0,0,0,0,0,0,0,0,0,-10000000]\n            Max = [0,0,0,0,0,0,0,0,0,-10000000]\n            flag = False\n            for i,c in enumerate(cost):\n                tmp = dfs(remain-c)\n                if tmp[-1] != -10000000:\n                    flag = True\n                    newtmp = tmp[:i]+[tmp[i]+1]+tmp[i+1:-1]+[tmp[-1]+1]\n                    for j in range(9,-1,-1):\n                        if newtmp[j] > Max[j]:\n                            Max = newtmp\n                            break\n                        elif newtmp[j] == Max[j]:\n                            continue\n                        else:\n                            break\n            Memo[remain] = Max\n            return Max\n        r = dfs(target)\n        if r[-1] == -10000000:\n            return '0'\n        else:\n            rs = ''\n            for k in range(8,-1,-1):\n                rs+=str(k+1)*r[k]\n        return rs\n                    \n", "# 1449. From Largest Integer With Digits That Add up to Target\n\ndef prune (costs):\n    ans = []\n    for ind, elem in enumerate (costs):\n        if any (costs[i] + costs[j] == elem for i in range (ind) for j in range (ind)):\n            pass\n        else:\n            ans.append (elem)\n    return ans\n\ndef find_longest_combos (costs, start, prefix, left, max_yets):\n    if start == len (costs):\n        if left == 0 and len (prefix) >= max_yets[0]:\n            max_yets[0] = len (prefix)\n            yield prefix[:]\n    else:\n        # judge if possible to find as long\n        theoretical_max_length = len (prefix) + left // costs[start]\n        if theoretical_max_length < max_yets[0]:\n            return\n        if costs[start] <= left:\n            prefix.append (costs[start])\n            yield from find_longest_combos (costs, start, prefix, left - costs[start], max_yets)\n            prefix.pop ()\n        if True:\n            yield from find_longest_combos (costs, start + 1, prefix, left, max_yets)\n\ndef rlencode (arr):\n    ans = []\n    for elem in arr:\n        if ans and ans[-1][0] == elem:\n            ans[-1] = (ans[-1][0], ans[-1][1]+1)\n        else:\n            ans.append ((elem, 1))\n    return ans\n\ndef encode (digit_choices, combo):\n    return sorted([\n        (digit_choices[elem], freq)\n        for (elem, freq) in combo\n    ], reverse=True)\n\ndef write (rle):\n    ans = []\n    for (elem, freq) in rle:\n        for _ in range (freq):\n            ans.append (elem)\n    return ''.join (map (str, ans))\n\ndef gcd (a, b):\n    a, b = min (a, b), max (a, b)\n    while a > 0:\n        a, b = b%a, a\n    return b\n\ndef gcdall (arr):\n    ans = arr[0]\n    for elem in arr:\n        ans = gcd (ans, elem)\n    return ans\n\ndef obviously_unsatisfactory (cost, target):\n    if min (cost) > target:\n        return True\n    if target % gcdall (cost) != 0:\n        return True\n    return False\n\ndef largest_num (cost, target):\n    if obviously_unsatisfactory (cost, target):\n        return '0'\n    costs = sorted (list (set (cost)))\n    costs = prune (costs)\n    combinations = list (find_longest_combos (costs, 0, [], target, [0]))\n    if not combinations:\n        return '0'\n    max_length = max (map (len, combinations))\n    combinations = (c for c in combinations if len (c) == max_length)\n    digit_choices = {}\n    for (i, c) in enumerate (cost):\n        digit_choices[c] = i+1\n    combinations = map (rlencode, combinations)\n    combinations = (encode (digit_choices, combo) for combo in combinations)\n    return write (max (combinations))\n\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        return largest_num(cost, target)", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        \n        @lru_cache(None)\n        def rec(rem):\n            if rem <= 0:\n                return 0 if rem == 0 else -math.inf\n            \n            ans = -math.inf\n            for c in cost:\n                ans = max(ans, rec(rem - c) + 1)\n            return ans\n        \n        ln = rec(target)\n        if ln <= 0:\n            return '0'\n        \n        def path(rem, now):\n            # print(rem, now)\n            if rem <= 0:\n                return now if rem == 0 else ''\n            for i, c in enumerate(reversed(cost)):\n                if rec(rem - c) + 1 == rec(rem):\n                    return path(rem - c, now + str(9 - i))\n            return ''\n            \n        ans = path(target, '')\n        print(ans)\n        return ans\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        cost_to_digit = {val: str(index+1) for index, val in enumerate(cost)}\n        cost = sorted(cost_to_digit.keys())\n        @lru_cache(None)\n        def helper(target: int) -> str:\n            if target < cost[0]:\n                return None\n            max_number = None if target not in cost_to_digit else cost_to_digit[target]\n            for c in cost:\n                if c > target:\n                    break\n                curr_number = helper(target-c)\n                if curr_number is None:\n                    continue\n                curr_number = ''.join(sorted(cost_to_digit[c]+curr_number, reverse=True))\n                max_number = curr_number if max_number is None or len(curr_number) > len(max_number) or (len(curr_number) == len(max_number) and curr_number > max_number) else max_number\n            #print(target, max_number)\n            return max_number\n        \n        ans = helper(target)\n        return ans if ans else '0'", "from functools import lru_cache\n\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        \n        ss = set()\n        for i, c in enumerate(reversed(cost)):\n            if c not in ss:     ss.add(c)\n            else:               cost[~i] = float('inf')\n        \n        cost = list((cost[i], str(i+1)) for i in range(9) if cost[i] != float('inf'))\n        \n        dp = [[] for _ in range(target+1)]\n        for i in range(1, target+1):\n            for c, d in cost:\n                if i - c == 0 or i - c > 0 and len(dp[i-c]) :\n                    tmp = sorted(dp[i-c] + [d], reverse=1)\n                    if len(dp[i-c]) + 1 > len(dp[i]):\n                        dp[i] = tmp\n                    elif len(dp[i-c]) + 1 == len(dp[i]):\n                        if tmp > dp[i]:\n                            dp[i] = tmp\n        return ''.join(dp[-1]) if dp[-1] else '0'", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        dp = [0] + [-float('inf')] * (5000+ target)\n        for i in range(1, target+1):\n            for j, c in enumerate(cost):\n                dp[i] = max(dp[i], 10 * dp[i-c] + j + 1)\n        print(dp[:target+1])        \n        return str(max(dp[target], 0))\n    '''  \n    def largestNumber(self, cost, target):\n        dp = [0] + [-1] * (target + 5000)\n        for t in xrange(1, target + 1):\n            dp[t] = max(dp[t - c] * 10 + i + 1 for i, c in enumerate(cost))\n        return str(max(dp[t], 0))\n    '''", "from functools import lru_cache\n\nclass Solution:\n  @lru_cache(None)\n  def recursive(self, k):\n    if k == 0:\n      return ''\n    ans = []\n    for x in self.d:\n      if x <= k:\n        r = self.recursive(k - x)\n        if r != '0':\n          ans.append(self.d[x] + r)\n    return str(max(map(int, ans))) if ans else '0'\n  def largestNumber(self, cost: List[int], target: int) -> str:\n    # self.d: cost -> digit, same cost always prefer larger digit\n    self.d = {}\n    for i, x in enumerate(cost):\n      self.d[x] = str(i + 1)\n    self.recursive.cache_clear()\n    return self.recursive(target)", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n       \n        for i in range(len(cost)):\n            for j in range(len(cost)-1, i, -1):\n                if cost[j] and not cost[i]%cost[j]:\n                    cost[i] = 0\n                    break\n        costMap = {e: k+1 for k,e in enumerate(cost) if e}\n        print((costMap, cost))\n        def getMaxList(s1, s2):\n            if s2 == None: return ''\n            return ''.join(sorted(s1+s2, reverse = True))\n              \n        def dfs(c):\n           \n            if c in dp: return dp[c]\n            if c == 0: return ''\n            elif c < 0: return None\n            # print(c)\n           \n            strs = [getMaxList(str(i), dfs(c-cost[i-1])) for i in range(1,10) if cost[i-1] in costMap]\n            if not any(strs): \n                dp[c] = None\n                return None\n            l = max(list(map(len, strs)))\n            newStr = sorted(strs)\n            for i in range(len(strs)-1, -1, -1):\n                if len(newStr[i]) == l:\n                    dp[c] = newStr[i]\n                    return dp[c]\n        dp = {}\n        res = dfs(target)\n        return res if res else '0'\n", "from functools import lru_cache\n\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        \n        ss = set()\n        for i, c in enumerate(reversed(cost)):\n            if c not in ss:     ss.add(c)\n            else:               cost[~i] = float('inf')\n        \n        cost = list((cost[i], str(i+1)) for i in range(9) if cost[i] != float('inf'))\n        \n        dp = [[] for _ in range(target+1)]\n        for i in range(1, target+1):\n            for c, d in cost:\n                if i - c == 0 or i - c > 0 and len(dp[i-c]) :\n                    if len(dp[i-c]) + 1 > len(dp[i]):\n                        dp[i] = sorted(dp[i-c] + [d], reverse=1)\n                    elif len(dp[i-c]) + 1 == len(dp[i]):\n                        tmp = sorted(dp[i-c] + [d], reverse=1)\n                        if tmp > dp[i]:\n                            dp[i] = tmp\n                            \n        return ''.join(dp[-1]) if dp[-1] else '0'", "def cmp(s, t):\n    if len(s) != len(t):\n        return len(s) < len(t)\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            return s[i] < t[i]\n    return False\n\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        best = {}\n        for i in range(len(cost)-1, -1, -1):\n            digit = i+1\n            if cost[i] not in best:\n                best[cost[i]] = digit\n                \n        keys = sorted(list(best.keys()), key=lambda x:best[x], reverse=True)\n        \n        @lru_cache(None)\n        def f(t, idx):\n            if t == 0:\n                return ''\n            if t < 0 or idx == len(keys):\n                return '0'\n            k = keys[idx]\n            b = '0'\n            best_ct = 0\n            for ct in range(t // k, -1, -1):\n                r = f(t - k * ct, idx+1)\n                if r != '0':\n                    if b == '0' or ct + len(r) > best_ct + len(b):\n                        b = r\n                        best_ct = ct\n            return str(best[k]) * best_ct + b\n        \n        return f(target, 0)\n", "def cmp(s, t):\n    if len(s) != len(t):\n        return len(s) < len(t)\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            return s[i] < t[i]\n    return False\n\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        best = {}\n        for i in range(len(cost)-1, -1, -1):\n            digit = i+1\n            if cost[i] not in best:\n                best[cost[i]] = digit\n                \n        keys = sorted(list(best.keys()), key=lambda x:best[x], reverse=True)\n        \n        @lru_cache(None)\n        def f(t, idx):\n            if t == 0:\n                return ''\n            if t < 0 or idx == len(keys):\n                return '0'\n            k = keys[idx]\n            b = '0'\n            for ct in range(t // k, -1, -1):\n                r = f(t - k * ct, idx+1)\n                if r != '0':\n                    cur = str(best[k]) * ct + r\n                    if b == '0' or cmp(b, cur):\n                        b = cur\n            return b\n        \n        return f(target, 0)\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        d = {i:-1 for i in cost}\n        for i in range(1,len(cost)+1):\n            d[cost[i-1]] = max(d[cost[i-1]], i)\n        dp = ['-1']*(target+1)\n        cost = list(set(cost))\n        cost.sort()\n        for i in d:\n            try:\n                dp[i] = str(d[i])\n            except:\n                pass\n        # print(d)\n        # print(cost)\n        for i in range(1,target+1):\n            for j in cost:\n                if i - j > 0:\n                    if dp[i-j] != '-1':\n                        dp[i] = str(max( int(dp[i-j]+str(d[j])) , int(dp[i])))\n                    else:\n                        try:\n                            dp[i] = str(max( int(dp[i]), d[i]))\n                        except:\n                            pass\n                else:\n                    break\n        if dp[target] == '-1':\n            return '0'\n        return dp[target]\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        t = target\n        dp = [ ['0'] for _ in range(t + 1)] \n        dp[0] = ['']\n        for i in range(1, t + 1):\n            for j in range(9):\n                l1 = len(dp[i]) \n                l1 = 0 if dp[i] == ['0'] else l1\n                l2 = len(dp[i - cost[j]]) + 1 if i>=cost[j] else 0\n                c = dp[i - cost[j]] if i>=cost[j] else ['0']\n                # print(l1,l2)\n                if l1 <= l2:\n                    dp[i] = c + [str(j + 1)] if c != ['0'] else ['0']\n                # if i == t:\n                #     print(dp[i], c, l1, l2)\n               \n            # print(dp[0:][j])\n        # print(dp)\n        ans = ''.join(sorted(dp[t])[::-1])\n        return ans", "def cmp(a, b):\n    ad, bd = {}, {}\n    for i in range(0, len(a), 2):\n        ad[a[i]] = a[i+1]\n    for i in range(0, len(b), 2):\n        bd[b[i]] = b[i+1]\n    sad = sum(ad.values())\n    sbd = sum(bd.values())\n    if sad != sbd:\n        return sad < sbd\n    al = sorted(list(ad.keys()), reverse=True)\n    bl = sorted(list(bd.keys()), reverse=True)\n    for i in range(1+min(len(al), len(bl))):\n        if al[i] == bl[i]:\n            c = al[i]\n            if ad[c] != bd[c]:\n                return ad[c] < bd[c]\n        else:\n            return al[i] < bl[i]\n    return False\n        \n    \n\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        best = {}\n        for i in range(len(cost)-1, -1, -1):\n            digit = i+1\n            if cost[i] not in best:\n                best[cost[i]] = digit\n                \n        x = sorted(best.keys())\n        y = sorted(list(best.values()), reverse=True)\n        # print(x, y)\n        @lru_cache(None)\n        def best_path(t, idx):\n            if t == 0:\n                return tuple()\n            if idx == len(x):\n                return None\n            ret = None\n            bi = -1\n            for i in range(t // x[idx], -1, -1):\n                y = best_path(t - i * x[idx], idx+1)\n                if y is not None:\n                    if i > 0:\n                        y = (best[x[idx]], i) + y\n                    if bi == -1 or cmp(ret, y):\n                        ret = y\n                        bi = i\n            # if bi >= 1:\n            #     ret = (best[x[idx]], bi) + ret\n            # if t == target and idx == 0:\n            #     print(ret)\n            # if t == target:\n            #     print(t, idx, ret)\n            return ret\n        \n        r = best_path(target, 0)\n        # print(r)\n        if r is None:\n            return '0'\n        unpacked = {}\n        for i in range(0, len(r), 2):\n            unpacked[r[i]] = r[i+1]\n        s = ''\n        # print(y)\n        # print(unpacked)\n        for digit in y:\n            if digit in unpacked:\n                s += str(digit) * unpacked[digit]\n        return s\n        \n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        d = {i:-1 for i in cost}\n        for i in range(1,len(cost)+1):\n            d[cost[i-1]] = max(d[cost[i-1]], i)\n        # print(d)\n        dp = ['-1']*(target+1)\n        cost = list(set(cost))\n        cost.sort()\n        for i in d:\n            try:\n                dp[i] = str(d[i])\n            except:\n                pass\n        # print(d)\n        # print(cost)\n        # print(dp)\n        for i in range(1,target+1):\n            for j in cost:\n                if i - j > 0:\n                    # print(int(dp[i-j]+str(d[j])),dp[i], i,j)\n                    # print(dp,i,j)\n                    if dp[i-j] != '-1':\n                        dp[i] = str(max( int(dp[i-j]+str(d[j])) , int(dp[i])))\n                    else:\n                        try:\n                            dp[i] = str(max( int(dp[i]), d[i]))\n                        except:\n                            pass\n                else:\n                    break\n            # print(dp,i)\n        # print(dp)\n        if dp[target] == '-1':\n            return '0'\n        return dp[target]\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        \n        @lru_cache(None)\n        def rec(rem):\n            if rem <= 0:\n                return 0 if rem == 0 else -math.inf\n            \n            ans = -math.inf\n            for c in cost:\n                ans = max(ans, rec(rem - c) + 1)\n            return ans\n        \n        ln = rec(target)\n        if ln <= 0:\n            return '0'\n        \n        def path(rem, now):\n            if rem <= 0:\n                return now if rem == 0 else ''\n            for i, c in enumerate(reversed(cost)):\n                if rec(rem - c) + 1 == rec(rem):\n                    return path(rem - c, now + str(9 - i))\n            return ''\n            \n        return path(target, '')\n", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        \n        \n        # (n) -number, (hp) -health points   <-- both negative for \n        q = [(0, -target)] \n        \n        # visited[hp] = largest_number achieved with hp remaining\n        visited = {}\n        \n        # cost of each number\n        costs = dict(zip(range(1,10), cost))\n        \n        # filter costs to remove:\n        # i.  any lower number that costs >= a higher number\n        # ii. where the lower number's cost is an integer multiple of the higher number\n        #     this is important because we need a diverse set of costs to hit target exactly\n        for i,a in enumerate(cost,1):\n            for b in cost[i:]:\n                if (b <= a) and not (a%b):\n                    del costs[i]\n                    break\n        \n        while q:\n            \n            n, hp = heapq.heappop(q)\n            n = -n\n            hp = -hp\n            \n            if hp < 0:\n                continue\n            \n            if visited.get(hp, -1) >= n:\n                continue\n            visited[hp] = n\n            \n            for c in costs:\n                if costs[c] <= hp:\n                    heapq.heappush(q, (-(n*10+c), -(hp-costs[c])))\n        \n        return str(visited.get(0,0))", "class Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        return self.helper(cost, target, {})\n        \n    def helper(self, cost, target, visited):\n        if target == 0:\n            return ''\n        if target in visited:\n            return visited[target]\n        ans = '0'\n        for i in range(1, 10):\n            if target >= cost[i - 1]:\n                prev = self.helper(cost, target - cost[i - 1], visited)\n                if prev != '0':\n                    curr = str(i) + prev\n                    if len(curr) >= len(ans) and int(curr) > int(ans):\n                        ans = curr\n        visited[target] = ans\n        return ans", "from functools import lru_cache\n\n\nclass Solution:\n    def largestNumber(self, cost: List[int], target: int) -> str:\n        \n        @lru_cache(None)\n        def dp(index, remain):\n            if remain == 0:\n                return ''\n            \n            elif remain < 0 or index > len(cost):\n                return '0'\n            \n            \n            take = str(index) + dp(1, remain - cost[index-1])\n            skip = dp(index + 1, remain)\n            \n            return get_bigger(take, skip)\n        \n        \n        def get_bigger(a, b):\n            if '0' in a:\n                return b\n            \n            elif '0' in b:\n                return a\n            \n            elif int(a) > int(b):\n                return a\n            \n            else:\n                return b\n        \n        ans = dp(1, target)\n        \n        return ans if '0' not in ans else '0'"]