["import sys\ninput = sys.stdin.readline\nfor f in range(int(input())):\n    n,m=list(map(int,input().split()))\n    neig=[0]*n\n    for i in range(n):\n        neig[i]=[0]\n    \n    for i in range(m):\n        a,b=list(map(int,input().split()))\n        a-=1\n        b-=1\n        neig[a][0]+=1\n        neig[a].append(b)\n    lev=[1]*n\n    for i in range(n):\n        for j in range(1,neig[i][0]+1):\n            x=lev[i]+1\n            if x==4:\n                x=1\n            lev[neig[i][j]]=max(lev[neig[i][j]],x)\n    sol=0\n    s=[]\n    for i in range(n):\n        if lev[i]==3:\n            sol+=1\n            s.append(i+1)\n    print(sol)\n    print(*s)\n    \n", "import sys\ninput = sys.stdin.readline\nfrom heapq import heapify,heappush,heappop\nt = int(input())\nfor _ in range(t):\n  n,m = map(int,input().split())\n  ab = [list(map(int,input().split())) for i in range(m)]\n  go = [[] for i in range(n+1)]\n  come = [[] for i in range(n+1)]\n  for a,b in ab:\n    go[a].append(b)\n    come[b].append(a)\n  exist = [1]*(n+1)\n  flg = [10]*(n+1)\n  for i in range(1,n+1):\n    if flg[i] == 10:\n      flg[i] = 2\n    if flg[i] == 0:\n      exist[i] = 0\n    if go[i]:\n      if flg[i] == 0:\n        for j in go[i]:\n          flg[j] = min(flg[j],2)\n      else:\n        for j in go[i]:\n          flg[j] = min(flg[j],flg[i]-1)\n  print(exist.count(0))\n  ansls = []\n  for i in range(1,n+1):\n    if exist[i] == 0:\n      ansls.append(i)\n  print(*ansls)", "import sys\n\nT = int(sys.stdin.readline().strip())\nfor t in range (0, T):\n    n, m = list(map(int, sys.stdin.readline().strip().split()))\n    P = [[] for i in range (0, n)]\n    G = [0] * n\n    for i in range (0, m):\n        x, y = list(map(int, sys.stdin.readline().strip().split()))\n        x, y = x-1, y-1\n        P[y].append(x)\n    ans = []\n    for i in range (0, n):\n        for j in P[i]:\n            for k in P[j]:\n                if G[j] == 0 and G[k] == 0:\n                    if G[i] == 0:\n                        ans.append(str(i+1))\n                        G[i] = 1\n                    \n    print(len(ans))\n    print(\" \".join(ans))\n", "import sys\ninputr = lambda: sys.stdin.readline().rstrip('\\n')\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n\tn, m = list(map(int, input().split()))\n\n\n\tadj = [[] for _ in range(n)]\n\n\tfor _ in range(m):\n\t\ta, b = list(map(int, input().split()))\n\t\ta -= 1\n\t\tb -= 1\n\t\tadj[a].append(b)\n\n\tLP = [0] * n\n\n\tfor i in range(n):\n\t\tif LP[i] < 2:\n\t\t\tfor j in adj[i]:\n\t\t\t\tLP[j] = max(LP[j], LP[i] + 1)\n\n\tr = [i+1 for i in range(n) if LP[i] >= 2]\n\n\tprint(len(r))\n\tprint(' '.join(map(str, r)))\n\n\tassert 7 * len(r) <= 4 * n\n\n", "import sys\ninputr = lambda: sys.stdin.readline().rstrip('\\n')\ninput = sys.stdin.readline\n\nfor _ in range(int(input())):\n\tn, m = list(map(int, input().split()))\n\tadj = [[] for _ in range(n)]\n\n\tfor _ in range(m):\n\t\ta, b = list(map(int, input().split()))\n\t\ta -= 1\n\t\tb -= 1\n\t\tadj[a].append(b)\n\n\tLP = [0] * n\n\tr = []\n\n\tfor i in range(n):\n\t\tif LP[i] < 2:\n\t\t\tfor j in adj[i]:\n\t\t\t\tLP[j] = max(LP[j], LP[i] + 1)\n\t\telse:\n\t\t\tr.append(str(i+1))\n\n\tprint(len(r))\n\tprint(*r)\n\n\tassert 7 * len(r) <= 4 * n\n\n", "#!/usr/bin/env python3\nimport sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nclass DirectedGraph:\n    def __init__(self, adj):\n        self.n = len(adj)\n        self.adj = adj\n        self.is_asyclic = False\n        self.max_path_len = None\n\n    def topological_sort(self):\n        indegree = [0] * self.n\n        for vs in self.adj:\n            for dest in vs:\n                indegree[dest] += 1\n        zero_v = []\n        for v, indeg in enumerate(indegree):\n            if indeg == 0:\n                zero_v.append(v)\n        max_path_len = 1\n        tp_sorted = []\n        to_be_added = []\n        while True:\n            while zero_v:\n                v = zero_v.pop()\n                tp_sorted.append(v)\n                for dest in self.adj[v]:\n                    indegree[dest] -= 1\n                    if indegree[dest] == 0:\n                        to_be_added.append(dest)\n            if len(to_be_added) > 0:\n                zero_v.extend(to_be_added)\n                to_be_added = []\n                max_path_len += 1\n            else:\n                break\n        if len(tp_sorted) == self.n:\n            self.is_asyclic = True\n            self.max_path_len = max_path_len\n            return tp_sorted\n        else:\n            self.is_asyclic = False\n            return None\n\nt = int(input())\nfor case in range(t):\n    n, m = map(int, input().split())\n    forward = [[] for _ in range(n)]\n    backward = [[] for _ in range(n)]\n\n    seen = set()\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1; v -= 1\n        if (u, v) in seen:\n            continue\n        seen.add((u, v))\n        forward[u].append(v)\n        backward[v].append(u)\n    \n    DG = DirectedGraph(forward)\n    tps = DG.topological_sort()\n    state = [-1] * n\n    state[0] = 0\n    for v in tps:\n        if len(backward[v]) == 0:\n            state[v] = 0\n        for pv in backward[v]:\n            state[v] = max(state[v], (state[pv] + 1) % 3)\n    \n    ans = []\n    for i, color in enumerate(state):\n        if color == 2:\n            ans.append(i + 1)\n    print(len(ans))\n    print(*ans)", "import sys\ndef rs(): return sys.stdin.readline().rstrip()\ndef ri(): return int(sys.stdin.readline())\ndef ria(): return list(map(int, sys.stdin.readline().split()))\ndef ws(s): sys.stdout.write(s + '\\n')\ndef wi(n): sys.stdout.write(str(n) + '\\n')\ndef wia(a): sys.stdout.write(' '.join([str(x) for x in a]) + '\\n')\n\n\ndef solve(n, m, g):\n    dp = [0] * n\n    ans = []\n    for i in range(n):\n        for w in g[i]:\n            dp[i] = max(dp[i], dp[w] + 1)\n        if dp[i] >= 2:\n            dp[i] = -1\n            ans.append(i+1)\n    wi(len(ans))\n    wia(ans)\n\n\ndef main():\n    for _ in range(ri()):\n        n, m = ria()\n        g = [[] for i in range(n)]\n        for __ in range(m):\n            u, v = ria()\n            g[v-1].append(u-1)\n        solve(n, m, g)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]