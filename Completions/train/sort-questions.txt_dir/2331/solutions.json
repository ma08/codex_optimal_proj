["from sys import stdin\nimport itertools\ninput = stdin.readline\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\ndef getint1(): return list([int(x) - 1 for x in input().split()])\ndef getstr(): return input()[:-1]\n\n\ndef solve():\n    n, a, b = getint1()\n    n += 1\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = getint1()\n        adj[u].append(v)\n        adj[v].append(u)\n    # dfs 1\n    max_child = [[-1] * 3 for _ in range(n)]\n    stack = [(a, -1, 1)]  # (node, parent)\n    while stack:\n        u, p, flag = stack.pop()\n        if p != -1 and len(adj[u]) < 2:\n            max_child[u][0] = 1\n            continue\n        if flag == 1:\n            stack.append((u, p, 0))\n            for v in adj[u]:\n                if v == p:\n                    continue\n                stack.append((v, u, 1))\n        else:\n            for v in adj[u]:\n                if v == p:\n                    continue\n                len_v = max_child[v][0] + 1\n                if len_v > max_child[u][0]:\n                    max_child[u][2] = max_child[u][1]\n                    max_child[u][1] = max_child[u][0]\n                    max_child[u][0] = len_v\n                elif len_v > max_child[u][1]:\n                    max_child[u][2] = max_child[u][1]\n                    max_child[u][1] = len_v\n                elif len_v > max_child[u][2]:\n                    max_child[u][2] = len_v\n    # end of dfs 1\n    # dfs 2\n    body = []\n    ret = [False] * n\n    max_parent = [-1] * n\n    stack.clear()\n    stack = [(a, -1, 0)]  # (node, parent, max len from parent)\n    while stack:\n        u, p, mxp = stack.pop()\n        if mxp >= 0:\n            stack.append((u, p, -1))\n            if p != -1 and len(adj[u]) < 2:\n                continue\n            max_parent[u] = mxp + 1\n            chlen = [max_parent[u], -3]\n            for v in adj[u]:\n                if v == p:\n                    continue\n                len_v = max_child[v][0] + 1\n                if len_v > chlen[0]:\n                    chlen[1] = chlen[0]\n                    chlen[0] = len_v\n                elif len_v > chlen[1]:\n                    chlen[1] = len_v\n            for v in adj[u]:\n                if v == p:\n                    continue\n                stack.append(\n                    (v, u, chlen[int(max_child[v][0] + 1 == chlen[0])]))\n        else:\n            is_body = (u == b)\n            if not is_body:\n                for v in adj[u]:\n                    if v != p and ret[v]:\n                        is_body = True\n                        break\n            if is_body:\n                body.append(u)\n            ret[u] = is_body\n    del ret\n    # end of dfs2\n    ok = False\n    body_len = len(body)\n    can_turn = [False] * n\n    for i in range(n):\n        if 3 <= sum(1 for l in max_child[i] + [max_parent[i]] if l >= body_len):\n            can_turn[i] = True\n            ok = True\n    if not ok:\n        print(\"NO\")\n        return\n    treelen = [1] * body_len\n    # print(body)\n    for i in range(body_len):\n        cur = body[i]\n        pre = -1 if i == 0 else body[i - 1]\n        nxt = -1 if i + 1 == body_len else body[i + 1]\n        for v in adj[cur]:\n            if v == pre or v == nxt:\n                continue\n            treelen[i] = max(treelen[i], max_child[v][0] + 1)\n            if can_turn[v]:\n                can_turn[cur] = True\n                continue\n            # dfs 3\n            stack = [(v, cur)]\n            while stack and not can_turn[cur]:\n                u, p = stack.pop()\n                for w in adj[u]:\n                    if w == p:\n                        continue\n                    if can_turn[w]:\n                        can_turn[cur] = True\n                        break\n                    stack.append((w, u))\n            stack.clear()\n            # end of dfs 3\n        # print(i, cur, can_turn[cur])\n    # use two pointer to find if we can enter the turing point\n    # print(body_len, treelen)\n    l = 0\n    r = body_len - 1\n    lmax = treelen[r] - 1\n    rmin = body_len - treelen[l]\n    ok = (can_turn[body[l]] or can_turn[body[r]])\n    while not ok and (l < lmax or rmin < r):\n        if l < lmax:\n            l += 1\n            rmin = min(rmin, l + (body_len - treelen[l]))\n        if rmin < r:\n            r -= 1\n            lmax = max(lmax, r - (body_len - treelen[r]))\n        if can_turn[body[l]] or can_turn[body[r]]:\n            ok = True\n    ##\n    print(\"YES\" if ok else \"NO\")\n    return\n    # end of solve\n\n\ndef __starting_point():\n    # solve()\n    # for t in range(getint()):\n    #     print('Case #', t + 1, ': ', sep='')\n    #     solve()\n    for _ in range(getint()):\n        solve()\n\n__starting_point()", "import sys\nfrom collections import deque\n\nt = int(input())\nfor _ in range(t):\n    n, a, b = [int(x) for x in input().split()]\n    a -= 1\n    b -= 1\n    edges = set()\n    adj = [[] for x in range(n)]\n    for _ in range(n-1):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        u -= 1\n        v -= 1\n        edges.add((u, v))\n        edges.add((v, u))\n        adj[u].append(v)\n        adj[v].append(u)\n\n\n    to_a = [-1 for x in range(n)]\n    to_a[a] = a\n    stack = [a]\n    while len(stack):\n        cur = stack.pop()\n        for nb in adj[cur]:\n            if to_a[nb] == -1:\n                to_a[nb] = cur\n                stack.append(nb)\n\n    snake = [b]\n    while snake[-1] != a:\n        snake.append(to_a[snake[-1]])\n\n    snake = deque(snake)\n\n    adj = [set(l) for l in adj]\n    leaves = [x for x in range(n) if len(adj[x]) == 1]\n    num_branch_points = sum([1 for l in adj if len(l) >= 3])\n    new_leaves = []\n\n    if len(snake) == 2:\n        print(\"YES\" if num_branch_points >= 1 else \"NO\")\n        continue\n\n    while True:\n        head = snake.pop()\n        tail = snake.popleft()\n        if len(adj[head]) == 1 and len(adj[tail]) == 1:\n            print(\"NO\")\n            break\n        if len(adj[head]) != 1:\n            snake.append(head)\n        else:\n            snake.appendleft(tail)\n\n        for leaf in leaves:\n            if len(adj[leaf]) == 0:\n                continue\n            nb = adj[leaf].pop()\n            adj[nb].remove(leaf)\n            if len(adj[nb]) == 2:\n                num_branch_points -= 1\n            if len(adj[nb]) == 1:\n                new_leaves.append(nb)\n\n        leaves, new_leaves = new_leaves, []\n        \n        if num_branch_points == 0:\n            print(\"NO\")\n            break\n        \n        if len(snake) == 2:\n            print(\"YES\")\n            break\n", "import sys\nfrom collections import deque\n\nt = int(input())\nfor _ in range(t):\n    n, a, b = [int(x) for x in input().split()]\n    a -= 1\n    b -= 1\n    edges = set()\n    adj = [[] for x in range(n)]\n    for _ in range(n-1):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        u -= 1\n        v -= 1\n        edges.add((u, v))\n        edges.add((v, u))\n        adj[u].append(v)\n        adj[v].append(u)\n\n\n    to_a = [-1 for x in range(n)]\n    to_a[a] = a\n    stack = [a]\n    while len(stack):\n        cur = stack.pop()\n        for nb in adj[cur]:\n            if to_a[nb] == -1:\n                to_a[nb] = cur\n                stack.append(nb)\n\n    snake = [b]\n    while snake[-1] != a:\n        snake.append(to_a[snake[-1]])\n\n    snake = deque(snake)\n\n    adj = [set(l) for l in adj]\n    leaves = [x for x in range(n) if len(adj[x]) == 1]\n    num_branch_points = sum([1 for l in adj if len(l) >= 3])\n    new_leaves = []\n\n    if len(snake) == 2:\n        print(\"YES\" if num_branch_points >= 1 else \"NO\")\n        continue\n\n    while True:\n        head = snake.pop()\n        tail = snake.popleft()\n        if len(adj[head]) == 1 and len(adj[tail]) == 1:\n            print(\"NO\")\n            break\n        if len(adj[head]) != 1:\n            snake.append(head)\n        else:\n            snake.appendleft(tail)\n\n        for leaf in leaves:\n            if len(adj[leaf]) == 0:\n                continue\n            nb = adj[leaf].pop()\n            adj[nb].remove(leaf)\n            if len(adj[nb]) == 2:\n                num_branch_points -= 1\n            if len(adj[nb]) == 1:\n                new_leaves.append(nb)\n\n        leaves, new_leaves = new_leaves, []\n        \n        if num_branch_points == 0:\n            print(\"NO\")\n            break\n        \n        if len(snake) == 2:\n            print(\"YES\")\n            break", "import sys\nfrom collections import deque\n \nt = int(input())\nfor _ in range(t):\n    n, a, b = [int(x) for x in input().split()]\n    a -= 1\n    b -= 1\n    edges = set()\n    adj = [[] for x in range(n)]\n    for _ in range(n-1):\n        u, v = [int(x) for x in sys.stdin.readline().split()]\n        u -= 1\n        v -= 1\n        edges.add((u, v))\n        edges.add((v, u))\n        adj[u].append(v)\n        adj[v].append(u)\n \n \n    to_a = [-1 for x in range(n)]\n    to_a[a] = a\n    stack = [a]\n    while len(stack):\n        cur = stack.pop()\n        for nb in adj[cur]:\n            if to_a[nb] == -1:\n                to_a[nb] = cur\n                stack.append(nb)\n \n    snake = [b]\n    while snake[-1] != a:\n        snake.append(to_a[snake[-1]])\n \n    snake = deque(snake)\n \n    adj = [set(l) for l in adj]\n    leaves = [x for x in range(n) if len(adj[x]) == 1]\n    num_branch_points = sum([1 for l in adj if len(l) >= 3])\n    new_leaves = []\n \n    if len(snake) == 2:\n        print(\"YES\" if num_branch_points >= 1 else \"NO\")\n        continue\n \n    while True:\n        head = snake.pop()\n        tail = snake.popleft()\n        if len(adj[head]) == 1 and len(adj[tail]) == 1:\n            print(\"NO\")\n            break\n        if len(adj[head]) != 1:\n            snake.append(head)\n        else:\n            snake.appendleft(tail)\n \n        for leaf in leaves:\n            if len(adj[leaf]) == 0:\n                continue\n            nb = adj[leaf].pop()\n            adj[nb].remove(leaf)\n            if len(adj[nb]) == 2:\n                num_branch_points -= 1\n            if len(adj[nb]) == 1:\n                new_leaves.append(nb)\n \n        leaves, new_leaves = new_leaves, []\n        \n        if num_branch_points == 0:\n            print(\"NO\")\n            break\n        \n        if len(snake) == 2:\n            print(\"YES\")\n            break"]