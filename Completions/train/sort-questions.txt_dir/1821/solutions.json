["class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        return nums", "import heapq\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        heap = []\n        \n        for num in nums:\n            heapq.heappush(heap, num)\n        \n        \n        sorted_nums = []        \n        \n        while heap:\n            cur_min = heapq.heappop(heap)\n            sorted_nums.append(cur_min)\n            \n            \n        \n        return sorted_nums\n            \n            \n            \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        mid = int(len(nums)/2)\n        left = self.sortArray(nums[0:mid])\n        right = self.sortArray(nums[mid:])\n        return self.merge(left, right)\n    def merge(self, left, right):\n        i = j = 0\n        ret = []\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                ret.append(left[i])\n                i += 1\n            elif right[j] <= left[i]:\n                ret.append(right[j])\n                j += 1\n        ret.extend(left[i:])\n        ret.extend(right[j:])\n        return ret", "class Node:\n    def __init__(self, val):\n        self.val = val\n\\t\n\\t# lt means less than, le means less or equal than etc.\n    def __lt__(self, other):\n        return self.val < other.val\n    \nclass Solution:    \n    def sortArray(self, nums: List[int]) -> List[int]:\n        nodes = [Node(n) for n in nums]\n        return [node.val for node in sorted(nodes)]", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        n = len(nums)\n        left = self.sortArray(nums[:n//2])\n        right = self.sortArray(nums[n//2:])\n        n_left = len(left)\n        n_right = len(right)\n        combine = []\n        while n_left > 0 or n_right > 0:\n            if n_left and n_right:\n                if left[0] > right[0]:\n                    combine.append(right.pop(0))\n                    n_right -= 1\n                else:\n                    combine.append(left.pop(0))\n                    n_left -= 1\n            elif n_left and not n_right:\n                combine += left\n                n_left = 0\n            elif n_right and not n_left:\n                combine += right\n                n_right = 0\n        return combine\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def merge(a, b):\n            l1 = l2 = 0\n            r1, r2 = len(a), len(b)\n            i, j = l1, l2\n            \n            out = []\n            while i < r1 or j < r2:\n                if j == r2 or i < r1 and a[i] < b[j]:\n                    out.append(a[i])\n                    i += 1\n                elif j < r2:\n                    out.append(b[j])\n                    j += 1\n            return out\n        \n        skip_interval = 1\n        while skip_interval < len(nums):\n            for i in range(0, len(nums), 2*skip_interval):\n                middle = i + skip_interval\n                nums[i: i + 2*skip_interval] = merge(nums[i: middle], nums[middle : middle + skip_interval])\n            \n            skip_interval *= 2\n            \n        return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        # recursive merge sort\n        \n        def merge_sort(nums):\n            \n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums)//2\n            \n            left_list = merge_sort(nums[:mid])\n            right_list = merge_sort(nums[mid:])\n            #print(left_list, right_list)\n            return merge(left_list, right_list)\n            \n        def merge(left_list, right_list):\n            \n            if not left_list:\n                return right_list\n            if not right_list:\n                return left_list\n            \n            left_ptr = right_ptr = 0\n            out = []\n            while left_ptr < len(left_list) and right_ptr < len(right_list):\n                \n                if left_list[left_ptr] <= right_list[right_ptr]:\n                    out.append(left_list[left_ptr])\n                    left_ptr += 1\n                else:\n                    out.append(right_list[right_ptr])\n                    right_ptr += 1\n                    \n            out.extend(left_list[left_ptr:])\n            out.extend(right_list[right_ptr:])\n            return out\n            \n        return merge_sort(nums)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return self.quicksort(nums)\n        \n    def quicksort(self, nums):\n        if len(nums) == 1 or len(nums) == 0:\n            return nums\n        pivot = nums[len(nums)//2]\n        left = [x for x in nums if x<pivot]\n        mid = [x for x in nums if x==pivot]\n        right = [x for x in nums if x>pivot]\n        return self.quicksort(left) + mid + self.quicksort(right)\n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)<=1:\n            return nums\n        else:\n            numA = self.sortArray(nums[:len(nums)//2])\n            numB = self.sortArray(nums[len(nums)//2:])\n            i,j = 0,0\n            nums = []\n            while i<len(numA) and j<len(numB):\n                if numA[i]<=numB[j]:\n                    nums.append(numA[i])\n                    i+=1\n                else:\n                    nums.append(numB[j])\n                    j+=1\n            if i==len(numA):\n                nums+=numB[j:]\n            else:\n                nums+=numA[i:]\n        return nums\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def merge(arr1, arr2):\n            if not arr1:\n                return arr2\n            if not arr2:\n                return arr1\n            \n            res = []\n            a1 = 0\n            a2 = 0\n            \n            while a1 < len(arr1) or a2 < len(arr2):\n                if a1 == len(arr1):\n                    res.append(arr2[a2])\n                    a2 += 1\n                    continue\n                if a2 == len(arr2):\n                    res.append(arr1[a1])\n                    a1 += 1\n                    continue\n                \n                if arr1[a1] < arr2[a2]:\n                    res.append(arr1[a1])\n                    a1 += 1\n                else:\n                    res.append(arr2[a2])\n                    a2 += 1\n            return res\n        \n        def mergesort(arr):\n            if len(arr) == 1:\n                return arr\n            mid = len(arr) // 2\n            left = mergesort(arr[:mid])\n            right = mergesort(arr[mid:])\n            return merge(left, right)\n        return mergesort(nums)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        mid = len(nums) // 2\n        left = nums[:mid]\n        right = nums[mid:]\n        left = self.sortArray(left)\n        right = self.sortArray(right)\n        res = []\n        while len(left) > 0 and len(right) > 0:\n            if left[0] < right[0]:\n                res.append(left.pop(0))\n            else:\n                res.append(right.pop(0))\n        res = res + left + right\n        return res", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n            \n        def merge(left_list, right_list):\n            \n            if not left_list:\n                return right_list\n            if not right_list:\n                return left_list\n            \n            left_ptr = right_ptr = 0\n            out = []\n            while left_ptr < len(left_list) and right_ptr < len(right_list):\n                \n                if left_list[left_ptr] <= right_list[right_ptr]:\n                    out.append(left_list[left_ptr])\n                    left_ptr += 1\n                else:\n                    out.append(right_list[right_ptr])\n                    right_ptr += 1\n                    \n            out.extend(left_list[left_ptr:])\n            out.extend(right_list[right_ptr:])\n            return out\n                \n        new_list = [[num] for num in nums]\n        #print(new_list)\n        #i = 0\n        #out = []\n        while len(new_list) > 1:\n            out = []\n            i = 0\n            #print(new_list)\n            for i in range(0, len(new_list), 2):\n                \n                if i == len(new_list)-1:\n                    merged_list = merge(new_list[i], [])\n                else:\n                    merged_list = merge(new_list[i], new_list[i+1])\n                out.append(merged_list)\n            new_list = out\n               # if i+1 == len(new_list)-1:\n                    \n                \n        return new_list[0]\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        # recursive merge sort\n        \n#         def merge_sort(nums):\n            \n#             if len(nums) <= 1:\n#                 return nums\n            \n#             mid = len(nums)//2\n            \n#             left_list = merge_sort(nums[:mid])\n#             right_list = merge_sort(nums[mid:])\n#             #print(left_list, right_list)\n#             return merge(left_list, right_list)\n            \n#         def merge(left_list, right_list):\n            \n#             if not left_list:\n#                 return right_list\n#             if not right_list:\n#                 return left_list\n            \n#             left_ptr = right_ptr = 0\n#             out = []\n#             while left_ptr < len(left_list) and right_ptr < len(right_list):\n                \n#                 if left_list[left_ptr] <= right_list[right_ptr]:\n#                     out.append(left_list[left_ptr])\n#                     left_ptr += 1\n#                 else:\n#                     out.append(right_list[right_ptr])\n#                     right_ptr += 1\n                    \n#             out.extend(left_list[left_ptr:])\n#             out.extend(right_list[right_ptr:])\n#             return out\n            \n#         return merge_sort(nums)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        import heapq\n        heap =[]\n        for i in nums:\n            heapq.heappush(heap, i)\n        sorted_list=[]\n        while heap:\n            sorted_list.append(heapq.heappop(heap))\n        return sorted_list\n", "class Solution:\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def heapSort(arr): \n            n = len(arr) \n            for i in range(n//2 - 1, -1, -1): \n                heapify(arr, n, i) \n            for i in range(n-1, 0, -1): \n                arr[i], arr[0] = arr[0], arr[i]\n                heapify(arr, i, 0) \n                \n        def heapify(arr, n, i): \n            largest = i  \n            l = 2 * i + 1     \n            r = 2 * i + 2    \n\n            if l < n and arr[i] < arr[l]: \n                largest = l \n\n            if r < n and arr[largest] < arr[r]: \n                largest = r \n\n            if largest != i: \n                arr[i],arr[largest] = arr[largest],arr[i] \n                heapify(arr, n, largest) \n\n\n \n        heapSort(nums) \n        return nums\n    \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        length = len(nums)\n        start_node = (length-2) // 2\n        for i in range(start_node, -1, -1):\n            self.build(nums, i, length)\n        for i in range(length-1, 0, -1):\n            nums[0], nums[i] = nums[i], nums[0]\n            self.build(nums, 0, i)\n        return nums\n#     def sortArray(self, nums: List[int]) -> List[int]:\n#         length = len(nums)\n#         for i in range(length - 1, -1, -1):\n#             self.build(nums, i, length)\n        \n#         for i in range(length - 1, 0, -1):\n#             nums[0], nums[i] = nums[i], nums[0]\n#             self.build(nums, 0, i)\n#         return nums    \n    \n    \n    def build(self, nums, node, n):\n        left = node*2 + 1\n        right = node*2 + 2\n        large = node\n        \n        if left < n and nums[left] > nums[large]:\n            large = left\n        if right < n and nums[right] > nums[large]:\n            large = right\n        if large != node:\n            nums[large], nums[node] = nums[node], nums[large]\n            self.build(nums, large, n)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # Heap Sort\n        # Step 1: \n        for i in range(len(nums) // 2, 0, -1):\n            self.heapify(nums, i, len(nums)+1)\n        # Step 2:\n        for i in range(len(nums), 0, -1):\n            index = i - 1\n            nums[0], nums[index] = nums[index], nums[0]\n            self.heapify(nums, 1, i)\n        \n        return nums\n\n    def heapify(self, nums: List[int], index, length):\n        left = index * 2\n        right = left + 1\n\n        if left >= length:\n            return\n        \n        if right >= length:\n            if (nums[index-1] < nums[left-1]):\n                nums[index-1], nums[left-1] = nums[left-1], nums[index-1]\n                self.heapify(nums, left, length)\n            return\n\n        if nums[left-1] < nums[right-1]:\n            if (nums[index-1] < nums[right-1]):\n                nums[index-1], nums[right-1] = nums[right-1], nums[index-1]\n                self.heapify(nums, right, length)\n        else:\n            if (nums[index-1] < nums[left-1]):\n                nums[index-1], nums[left-1] = nums[left-1], nums[index-1]\n                self.heapify(nums, left, length)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        nums = self.merge(nums)\n        return nums\n    \n    def merge(self, values):\n        if len(values)>1: \n            m = len(values)//2\n            left = values[:m] \n            right = values[m:] \n            left = self.merge(left) \n            right = self.merge(right) \n\n            values =[] \n\n            while len(left)>0 and len(right)>0: \n                if left[0]<right[0]: \n                    values.append(left[0]) \n                    left.pop(0) \n                else: \n                    values.append(right[0]) \n                    right.pop(0) \n\n            for i in left: \n                values.append(i) \n            for i in right: \n                values.append(i) \n                  \n        return values \n        \n", "class Solution:\n   def sortArray(self, nums: List[int]) -> List[int]:\n       if len(nums)>1: \n           m = len(nums)//2\n           left = nums[:m] \n           right = nums[m:] \n           left = self.sortArray(left) \n           right = self.sortArray(right) \n           nums =[] \n           while len(left)>0 and len(right)>0: \n               if left[0]<right[0]: \n                   nums.append(left[0]) \n                   left.pop(0) \n               else: \n                   nums.append(right[0]) \n                   right.pop(0) \n \n           for i in left:\n               nums.append(i) \n           for i in right: \n               nums.append(i) \n                 \n       return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # Heap Sort\n        # Step 1: \n        for i in range(len(nums) // 2, 0, -1):\n            self.heapify(nums, i, len(nums)+1)\n        # Step 2:\n        for i in range(len(nums), 0, -1):\n            index = i - 1\n            nums[0], nums[index] = nums[index], nums[0]\n            self.heapify(nums, 1, i)\n        \n        return nums\n\n    def heapify(self, nums: List[int], index, length):\n        left = index * 2\n        right = left + 1\n\n        if (left >= length):\n            return\n        \n        if (right >= length):\n            if (nums[index-1] < nums[left-1]):\n                nums[index-1], nums[left-1] = nums[left-1], nums[index-1]\n                self.heapify(nums, left, length)\n            return\n\n        if (nums[left-1] < nums[right-1]):\n            greater = right\n        else:\n            greater = left\n\n        if (nums[index-1] < nums[greater-1]):\n            nums[index-1], nums[greater-1] = nums[greater-1], nums[index-1]\n            self.heapify(nums, greater, length)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        length = len(nums)\n        for i in range(length - 1, -1, -1):\n            self.maxheap(nums, length, i)\n        \n        for i in range(length - 1, 0, -1):\n            nums[0], nums[i] = nums[i], nums[0]\n            self.maxheap(nums, i, 0)\n        return nums\n\n\n    def maxheap(self, nums, n, node):\n        l = node * 2 + 1\n        r = node * 2 + 2\n        large = node\n\n        if l < n and nums[l] > nums[large]:\n            large = l\n        if r < n and nums[r] > nums[large]:\n            large = r\n        if large != node:\n            nums[node], nums[large] = nums[large], nums[node]\n            self.maxheap(nums, n, large)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) == 1:\n            return nums\n        elif len(nums) == 2:\n            return nums if nums[0] <= nums[1] else [nums[1], nums[0]]\n        else:\n            half = int(len(nums)/2)\n            a1 = self.sortArray(nums[:half])\n            a2 = self.sortArray(nums[half:])\n            nu = []\n            olen = len(a1) + len(a2)\n            while len(nu) < olen:\n                if len(a1) == 0:\n                    nu.append(a2.pop(0))\n                elif len(a2) == 0:\n                    nu.append(a1.pop(0))\n                elif a1[0] < a2[0]:\n                    nu.append(a1.pop(0))\n                else:\n                    nu.append(a2.pop(0))\n            return nu\n", "from random import shuffle\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        size = 1\n        aux = [0] * len(nums)\n        # merge all subarrays with length of size\n        while size < len(nums):\n            for lo in range(0, len(nums)-size, 2*size):\n                # merge two arrays\n                # last array could be smaller than size\n                hi = min(len(nums)-1, lo+2*size-1)\n                aux[lo:hi+1] = nums[lo:hi+1]\n                i, j = lo, lo+size\n                for k in range(lo, hi+1):\n                    if i > lo+size-1:\n                        # left subarray is exhausted\n                        nums[k] = aux[j]\n                        j += 1\n                    elif j > hi:\n                        # right subarry is exhausted\n                        nums[k] = aux[i]\n                        i += 1\n                    elif aux[i] > aux[j]:\n                        nums[k] = aux[j]\n                        j += 1\n                    else:\n                        nums[k] = aux[i]\n                        i += 1\n            size *= 2\n        return nums\n                \n            \n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        lst = []\n        \n        for x in nums:\n            heapq.heappush(lst,x)\n            \n        return [ heapq.heappop(lst) for x in range(len(nums))]", "class Solution:  \n    def maxheapify(self, a, heapsize,i):\n        l, r = 2*i+1, 2*i+2\n        leftisgreater = rightisgreater = False\n        if l < heapsize and a[i] < a[l]:\n            leftisgreater = True\n        if r < heapsize and a[i] < a[r]:\n            rightisgreater = True\n        \n        if leftisgreater and not rightisgreater:\n            a[i],a[l] = a[l],a[i]\n            self.maxheapify(a, heapsize, l)\n        elif not leftisgreater and rightisgreater:\n            a[i],a[r] = a[r],a[i]\n            self.maxheapify(a, heapsize, r)\n        elif leftisgreater and rightisgreater:\n            if a[l] <= a[r]:\n                a[i],a[r] = a[r],a[i]\n                self.maxheapify(a, heapsize, r)\n            else:\n                a[i],a[l] = a[l],a[i]\n                self.maxheapify(a, heapsize, l)\n                    \n    def buildmaxheap(self, nums, heapsize):\n        for i in reversed(range(len(nums)//2)):\n            self.maxheapify(nums, heapsize,i)\n           \n    def heapsort(self, nums):\n        heapsize = len(nums)\n        self.buildmaxheap(nums, heapsize)\n        for i in range(len(nums)):\n            nums[0],nums[heapsize-1]=nums[heapsize-1],nums[0]\n            heapsize-=1\n            self.maxheapify(nums, heapsize, 0)\n        \n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.heapsort(nums)\n        return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        L = len(nums)\n        if L == 1:\n            # print(f'nums: {nums}')\n            return nums\n        else:\n            left = nums[:L//2]\n            right = nums[L//2:]\n            #print(left, \\\"  \\\", right)\n            return self.compare(self.sortArray(left), self.sortArray(right))\n    \n    def compare(self, left, right):\n        combined = []\n        # print(f'before sort: {left}  {right}   {combined}')\n        while len(left) > 0 and len(right) > 0:\n            if left[0] > right[0]:\n                combined.append(right.pop(0))\n            elif left[0] < right[0]:\n                combined.append(left.pop(0))\n            else:  # equal values, pop both to save an iteration.\n                combined.append(right.pop(0))\n                combined.append(left.pop(0))\n        combined.extend(left)  # one will be empty, doesn't matter which\n        combined.extend(right)  # one will be empty, doesn't matter which\n        # print(f'after sort: {left}  {right}   {combined}')\n        return combined        ", "def swap(arr, i, j):\n    arr[i], arr[j] = arr[j], arr[i]\n\ndef heapify(nums, n, i):\n    l = 2 * i\n    r = 2 * i + 1\n    largest = i\n    \n    if l < n and nums[l] > nums[largest]:\n        largest = l\n    if r < n and nums[r] > nums[largest]:\n        largest = r\n    if largest != i:\n        swap(nums, i, largest)\n        heapify(nums, n, largest)\n\ndef build_heap(nums):\n    n = len(nums)\n    for i in range(n // 2, -1, -1):\n        heapify(nums, n, i)\n\n        \ndef heap_sort(nums):\n    n = len(nums)\n    for i in range(n - 1, -1, -1):\n        swap(nums, 0, i)\n        heapify(nums, i, 0)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        build_heap(nums)\n        heap_sort(nums)\n        return nums\n        \n", "class Solution:\n    \n    def merge(self,arr1:List[int],arr2:List[int]) -> List[int]:\n        ret = []\n        ix1 = 0\n        ix2 = 0\n        while ix1 != len(arr1) and ix2 != len(arr2):\n            if arr1[ix1] < arr2[ix2]:\n                ret.append(arr1[ix1])\n                ix1 += 1\n            else:\n                ret.append(arr2[ix2])\n                ix2 += 1\n        if ix1< len(arr1):\n            ret.extend(arr1[ix1:])\n        else:\n            ret.extend(arr2[ix2:])\n        return ret\n        \n    def sortArray(self, nums: List[int]) -> List[int]:\n        # implement merge sort\n        if len(nums) == 1:\n            return nums\n        \n        mid = len(nums) // 2\n        left = self.sortArray(nums[:mid])\n        right = self.sortArray(nums[mid:])\n        return self.merge(left,right)\n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)>1: \n            m = len(nums)//2\n            left = nums[:m] \n            right = nums[m:] \n            left = self.sortArray(left) \n            right = self.sortArray(right) \n            nums =[] \n            while len(left)>0 and len(right)>0: \n                if left[0]<right[0]: \n                    nums.append(left[0]) \n                    left.pop(0) \n                else: \n                    nums.append(right[0]) \n                    right.pop(0) \n\n            for i in left:\n                nums.append(i) \n            for i in right: \n                nums.append(i) \n\n        return nums", "def merge(list1, list2):\n    merged = []\n    while len(list1) != 0 and len(list2) != 0:\n        if list1[0] < list2[0]:\n            merged.append(list1.pop(0))\n        else:\n            merged.append(list2.pop(0))\n    if len(list1) == 0:\n        return merged + list2\n    else:\n        return merged + list1\n        \n\nclass Solution:\n    # Merge Sort\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) == 1:\n            return nums\n        else:\n            return merge(self.sortArray(nums[:len(nums) // 2]), self.sortArray(nums[len(nums) // 2:]))\n        \n", "def swap(arr, i, j):\n    arr[i], arr[j] = arr[j], arr[i]\n\ndef heapify(nums, n, i):\n    l = 2 * i\n    r = 2 * i + 1\n    largest = i\n    \n    if l < n and nums[l] > nums[largest]:\n        largest = l\n    if r < n and nums[r] > nums[largest]:\n        largest = r\n    if largest != i:\n        swap(nums, i, largest)\n        heapify(nums, n, largest)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # build heap\n        n = len(nums)\n        \n        # n // 2 -> 0\n        # building maximizing heap\n        for i in range(n // 2, -1, -1):\n            heapify(nums, n, i)\n        \n        for i in range(n - 1, -1, -1):\n            swap(nums, 0, i)\n            heapify(nums, i, 0)\n        \n        return nums\n        # do the heap sort\n        \n", "def get_numbers(arr, target, cb):\n    result = []\n    for num in arr:\n        if cb(num, target):\n            result.append(num)\n    return result\n\ndef is_less(a, b):\n    return a < b\n\n\ndef is_greater(a, b):\n    return a > b\n\ndef is_equal(a, b):\n    return a == b\n\ndef get_less_numbers(arr, target):\n    return get_numbers(arr, target, is_less)\n\n\ndef get_greater_numbers(arr, target):\n    return get_numbers(arr, target, is_greater)\n\ndef get_equal_numbers(arr, target):\n    return get_numbers(arr, target, is_equal)\n\ndef q_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    pivot = arr[len(arr) // 2]\n    less = get_less_numbers(arr, pivot)\n    greater = get_greater_numbers(arr, pivot)\n    mypivot = get_equal_numbers(arr, pivot)\n\n    return q_sort(less) + mypivot + q_sort(greater)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return q_sort(nums)", "class Solution:\n    #def __init__(self):\n        \n    def sortArray(self, nums: List[int]) -> List[int]:\n        return self.mergeSort(nums)\n    \n    def mergeSort(self, nums: List[int]) -> List[int]:\n        if len(nums) > 1:\n            l1 = nums[:len(nums)//2]\n            l2 = nums[len(nums)//2:]\n            L = self.mergeSort(l1)\n            R = self.mergeSort(l2)\n            \n            sorted_list = []\n            i = j = 0\n            while i < len(L) and j < len(R):\n                if L[i] < R[j]:\n                    sorted_list.append(L[i])\n                    i += 1\n                else:\n                    sorted_list.append(R[j])\n                    j += 1\n            \n            while i < len(L):\n                sorted_list.append(L[i])\n                i += 1\n            while j < len(R):\n                sorted_list.append(R[j])\n                j += 1 \n            return sorted_list\n            \n        return nums\n            \n", "class Solution:\n    def _merge(self, list1, list2):\n        tmp = []\n        while list1 and list2:\n            (tmp.append(list1.pop(0))\n             if list1[0] < list2[0]\n             else tmp.append(list2.pop(0)))\n        return tmp + (list1 or list2)\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        pivot = len(nums) // 2\n        return (nums\n                if len(nums) < 2\n                else self._merge(self.sortArray(nums[:pivot]),\n                                self.sortArray(nums[pivot:])))", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # return sorted(nums)\n\n        def merge_sort(values): \n\n            if len(values)>1: \n                m = len(values)//2\n                left = values[:m] \n                right = values[m:] \n                left = merge_sort(left) \n                right = merge_sort(right) \n                values =[] \n                while len(left)>0 and len(right)>0: \n\n                    if left[0]<right[0]: \n                        values.append(left[0]) \n                        left.pop(0)\n                      \n                    else: \n                        values.append(right[0]) \n                        right.pop(0)\n                       \n                for i in left: \n                    values.append(i) \n                for i in right: \n                    values.append(i) \n                   \n\n            return values \n        result = merge_sort(nums)\n        return result\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) < 2:\n            return nums\n        \n        def merge(l1, l2):\n            n1 = n2 = 0\n            res = []\n            \n            while n1 < len(l1) and n2 < len(l2):\n                if l1[n1] < l2[n2]:\n                    res.append(l1[n1])\n                    n1 += 1\n                else:\n                    res.append(l2[n2])\n                    n2 += 1\n                \n            \n            res += l1[n1:]\n            res += l2[n2:]\n            \n            return res\n        \n        mid = len(nums) // 2\n        \n        return merge(self.sortArray(nums[:mid]), self.sortArray(nums[mid:]))\n        \n        \n", "\nfrom collections import deque\n\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # heap sort\n        # convert array to max heap\n        for i in range(len(nums) // 2 - 1, -1, -1):\n            self.heapify(nums, i, len(nums))\n        # have pointer start at last element\n        last = len(nums) - 1\n        while last > 0:\n            # swap last element with first element\n            nums[last], nums[0] = nums[0], nums[last]\n            # restore heap property from [:pointer]\n            self.heapify(nums, 0, last)\n            # decrement pointer\n            last -= 1\n        return nums\n\n    def heapify(self, nums, start, size):\n        largest = start\n        left = start * 2 + 1\n        right = start * 2 + 2\n\n        if left < size and nums[largest] < nums[left]:\n            largest = left\n\n        if right < size and nums[largest] < nums[right]:\n            largest = right\n\n        if largest != start:\n            nums[start], nums[largest] = nums[largest], nums[start]\n            self.heapify(nums, largest, size)\n\n\n#     #     nums = deque(nums)\n#     #     if len(nums) <= 1:\n#     #         return nums\n#     #     mid = len(nums) // 2\n#     #     left = self.sortArray(nums[:mid])\n#     #     right = self.sortArray(nums[mid:])\n#     #     return self.merge(left, right)\n\n#     # def merge(self, left, right):\n#     #     merged = deque([])\n#     #     while left and right:\n#     #         merged.append(left.popleft() if left[0] < right[0] else right.popleft())\n#     #     return merged + left + right\n\n#     def sortArray(self, nums: List[int]) -> List[int]:\n#         return self.merge_sort(nums, 0, len(nums) - 1)\n\n#     def merge_sort(self, nums, start, end):\n#         if end <= start:\n#             return nums\n#         mid = start + (end - start) // 2\n#         self.merge_sort(nums, start, mid)\n#         self.merge_sort(nums, mid + 1, end)\n#         return self.merge(nums, start, mid, end)\n\n#     def merge(self, nums, start, mid, end):\n#         left, right = [], []\n#         for i in range(start, mid + 1):\n#             left.append(nums[i])\n#         for j in range(mid + 1, end + 1):\n#             right.append(nums[j])\n#         i, j, k = 0, 0, start\n\n#         # pick out smallest elements until smaller list is exhausted\n#         while i < len(left) and j < len(right):\n#             if left[i] < right[j]:\n#                 nums[k] = left[i]\n#                 i += 1\n#             else:\n#                 nums[k] = right[j]\n#                 j += 1\n#             k += 1\n\n#         # copy remaining elements\n#         while i < len(left):\n#             nums[k] = left[i]\n#             i += 1\n#             k += 1\n\n#         while j < len(right):\n#             nums[k] = right[j]\n#             j += 1\n#             k += 1\n#         return nums\n\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        \n        pivot = len(nums)//2\n        \n        left_arr = self.sortArray(nums[:pivot])\n        right_arr = self.sortArray(nums[pivot:])\n        \n        return self.merge(left_arr, right_arr)\n    \n    def merge(self, left_nums, right_nums):\n        m, n = len(left_nums), len(right_nums)\n        i, j = 0, 0\n        \n        combined_arr = []\n        while i < m and j < n:\n            if left_nums[i] < right_nums[j]:\n                combined_arr.append(left_nums[i])\n                i += 1\n            else:\n                combined_arr.append(right_nums[j])\n                j += 1\n                \n        combined_arr.extend(left_nums[i:])\n        combined_arr.extend(right_nums[j:])\n\n        return combined_arr\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.qsort(nums, 0, len(nums))\n        return nums\n    \n    def qsort(self, nums, begin, end):\n        if begin>=end:\n            return\n        x = nums[end-1]\n        i = j = begin\n        while j<end-1:\n            if nums[j]<x:\n                self.swap(nums, i, j)\n                i += 1\n            j += 1\n        self.swap(nums, i, j)\n        self.qsort(nums, begin, i)\n        self.qsort(nums, i+1, end)\n        \n    def swap(self, nums, i, j):\n        a = nums[i]\n        nums[i] = nums[j]\n        nums[j] = a", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)==1:\n            return nums\n        if len(nums)>1:\n            mid=len(nums)//2\n            left=nums[:mid]\n            right=nums[mid:]\n            self.sortArray(left)\n            self.sortArray(right)\n            self.merge(left,right,nums)\n            return nums\n    \n    def merge(self,left,right,nums):\n        i=0\n        j=0\n        k=0\n        while i<len(left) and j<len(right):\n            if left[i]<right[j]:\n                nums[k]=left[i]\n                i+=1\n                k+=1\n            else:\n                nums[k]=right[j]\n                j+=1\n                k+=1\n        while i<len(left):\n            nums[k]=left[i]\n            i+=1\n            k+=1\n        while j<len(right):\n            nums[k]=right[j]\n            j+=1\n            k+=1\n        return", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        \n        mid = len(nums)//2\n        A = self.sortArray(nums[:mid])\n        B = self.sortArray(nums[mid:])\n        i,j = 0,0\n        result = []\n        \n        while i < len(A) and j < len(B):\n            if A[i] <= B[j]:\n                result.append(A[i])\n                i += 1\n            else:\n                result.append(B[j])\n                j += 1\n                \n        if i < len(A):\n            result += A[i:]\n        elif j < len(B):\n            result += B[j:]\n            \n        return result\n        \n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) < 2:\n            return nums\n        else:\n            mid = len(nums)//2\n            left = nums[:mid]\n            right = nums[mid:]\n            self.sortArray(left)\n            self.sortArray(right)\n            i,j,k = 0,0,0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    nums[k] = left[i]\n                    i += 1\n                else:\n                    nums[k] = right[j]\n                    j += 1\n                k += 1\n            while i < len(left):\n                nums[k] = left[i]\n                i += 1\n                k += 1\n            while j < len(right):\n                nums[k] = right[j]\n                j += 1\n                k += 1\n        return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        tmp = [0 for _ in range(len(nums))]\n        self.merge_sort(nums, 0, len(nums)-1, tmp)\n        return nums\n        \n        \n    def merge_sort(self, nums, left, right, tmp):\n        if left >= right:\n            return\n        mid = (left + right) // 2\n        \n        self.merge_sort(nums, left, mid, tmp)\n        self.merge_sort(nums, mid+1, right, tmp)\n        self.merge(nums, left, right, tmp)\n\n        \n        \n    def merge(self, nums, left, right, tmp):\n        \n        n = right - left + 1\n        mid = (left + right) // 2\n        i, j = left, mid +1\n        \n        for k in range(n):\n            # j>right means right side is used up\n            if i <= mid and (j > right or nums[i]<=nums[j]):\n                tmp[k] = nums[i]\n                i += 1\n            else:\n                tmp[k] = nums[j]\n                j += 1\n        \n        for k in range(n):\n            nums[left + k] = tmp[k]\n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        counts = Counter(nums)\n        nums_before = 0\n        for k, v in sorted(counts.items(), key=lambda x: x[0]):\n            nums_before += v\n            counts[k] = nums_before-1\n        out = [0 for _ in range(len(nums))]\n        for i in range(len(nums)):\n            out[counts[nums[i]]] = nums[i]\n            counts[nums[i]] -= 1\n        return out", "class Solution:\n    def merge(self, nums1, nums2):\n        if not nums1:\n            return nums2\n        if not nums2:\n            return nums1\n        res = []\n        i = j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] <= nums2[j]:\n                res.append(nums1[i])\n                i += 1\n            else:\n                res.append(nums2[j])\n                j += 1\n        \n        if i < len(nums1):\n            res.extend(nums1[i:])\n        if j < len(nums2):\n            res.extend(nums2[j:])\n        \n        return res\n            \n            \n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        mid = len(nums) // 2\n        nums1 = self.sortArray(nums[:mid])\n        nums2 = self.sortArray(nums[mid:])\n        res = self.merge(nums1, nums2)\n        return res", "\nfrom collections import deque\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        mid = len(nums) // 2\n        left = self.sortArray(nums[:mid])\n        right = self.sortArray(nums[mid:])\n        return self.merge(left, right)\n\n    def merge(self, left, right):\n        ans = []\n        while left and right:\n            ans.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n        return ans + left + right\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#     #     nums = deque(nums)\n#     #     if len(nums) <= 1:\n#     #         return nums\n#     #     mid = len(nums) // 2\n#     #     left = self.sortArray(nums[:mid])\n#     #     right = self.sortArray(nums[mid:])\n#     #     return self.merge(left, right)\n\n#     # def merge(self, left, right):\n#     #     merged = deque([])\n#     #     while left and right:\n#     #         merged.append(left.popleft() if left[0] < right[0] else right.popleft())\n#     #     return merged + left + right\n\n#     def sortArray(self, nums: List[int]) -> List[int]:\n#         return self.merge_sort(nums, 0, len(nums) - 1)\n\n#     def merge_sort(self, nums, start, end):\n#         if end <= start:\n#             return nums\n#         mid = start + (end - start) // 2\n#         self.merge_sort(nums, start, mid)\n#         self.merge_sort(nums, mid + 1, end)\n#         return self.merge(nums, start, mid, end)\n\n#     def merge(self, nums, start, mid, end):\n#         left, right = [], []\n#         for i in range(start, mid + 1):\n#             left.append(nums[i])\n#         for j in range(mid + 1, end + 1):\n#             right.append(nums[j])\n#         i, j, k = 0, 0, start\n\n#         # pick out smallest elements until smaller list is exhausted\n#         while i < len(left) and j < len(right):\n#             if left[i] < right[j]:\n#                 nums[k] = left[i]\n#                 i += 1\n#             else:\n#                 nums[k] = right[j]\n#                 j += 1\n#             k += 1\n\n#         # copy remaining elements\n#         while i < len(left):\n#             nums[k] = left[i]\n#             i += 1\n#             k += 1\n\n#         while j < len(right):\n#             nums[k] = right[j]\n#             j += 1\n#             k += 1\n#         return nums\n\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def mergeSort(nos):\n            if len(nos) > 1:\n                mid = len(nos)//2\n                left = nos[mid:]\n                right = nos[:mid]\n                left = mergeSort(left)\n                right = mergeSort(right)\n                nos = []\n                while left and right:\n                    if left[0] < right[0]:\n                        nos.append(left[0])\n                        left.pop(0)\n                    else:\n                        nos.append(right[0])\n                        right.pop(0)\n                for i in left:\n                    nos.append(i)\n                for j in right:\n                    nos.append(j)\n            return nos\n                \n        return mergeSort(nums)", "class Solution:\n    \n    def merge(self,low,mid,high,arr):\n        \n        left = []\n        right = []\n        \n        l_limit = mid+1-low\n        r_limit = high+1-mid-1\n        \n        for i in range(low, mid+1):\n            left.append(arr[i])\n        \n        for i in range(mid+1, high+1):\n            right.append(arr[i])\n            \n        #print(\\\"During merge arrays are \\\", left, right)\n        #print(\\\"limits are \\\",l_limit, r_limit)\n        \n        #using left and right as temp variables, merge it onto arr\n        \n        l_iter = 0\n        r_iter = 0\n        \n        filler = low\n        \n        while(l_iter < l_limit or r_iter < r_limit):\n            \n            if(l_iter == l_limit):\n                arr[filler] = right[r_iter]\n                r_iter+=1\n            elif(r_iter == r_limit):\n                arr[filler] = left[l_iter]\n                l_iter+=1\n            elif(left[l_iter] < right[r_iter]):\n                arr[filler] = left[l_iter]\n                l_iter+=1\n            else:\n                arr[filler] = right[r_iter]\n                r_iter+=1\n                \n            filler+=1\n            #print(l_iter, r_iter, l_limit, r_limit)\n            \n    def mergeSort(self,arr, low, high):\n        \n        if(low < high):\n            \n            mid = low + (high-low)//2\n            \n            #print(\\\"mergesort for \\\", arr[low:mid+1], arr[mid+1:high+1])\n            \n            self.mergeSort(arr, low, mid) #from low to mid\n            self.mergeSort(arr, mid+1, high) #from mid+1 to high\n            \n            self.merge(low,mid,high,arr)\n    \n    def sortArray(self, arr: List[int]) -> List[int]:\n            \n        n = len(arr)\n        \n        if(n==1):\n            return arr\n        else:\n            self.mergeSort(arr, 0,n-1)\n            return arr\n", "class Solution:\n    import random\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        self.heapSort(nums)\n        return nums\n        \n                  \n    def quickSort(self, arr):\n        def partition(arr, l, h):\n                if l>=h:\n                    return\n                pivot = arr[random.randint(l,r)]\n                tempL, tempH = l, h\n                while tempL<=tempH:\n                    while tempL<=tempH and arr[tempL]<pivot:\n                        tempL+=1\n                    while tempL<=tempH and arr[tempH]>pivot:\n                        tempH-=1\n                    if tempL<=tempH:\n                        arr[tempL], arr[tempH] = arr[tempH], arr[tempL]\n                        tempL+=1\n                        tempH-=1\n                partition(arr, l, tempH)\n                partition(arr, tempL, h)\n                return\n        partition(arr, 0, len(arr)-1)\n        return arr\n    \n    def mergeSort(self, arr):\n        if len(arr)<=1: return\n        mid = len(arr)//2\n        L = arr[:mid]\n        R = arr[mid:]\n        self.mergeSort(L)\n        self.mergeSort(R)\n        idxL = 0\n        idxR = 0\n        idxA = 0\n        while idxA<len(arr):\n            if idxL < len(L) and idxR < len(R):\n                if L[idxL]<R[idxR]:\n                    arr[idxA] = L[idxL]\n                    idxL += 1\n                else:\n                    arr[idxA] = R[idxR]\n                    idxR += 1\n            elif idxL < len(L):\n                arr[idxA] = L[idxL]\n                idxL += 1\n            else:\n                arr[idxA] = R[idxR]\n                idxR += 1\n            idxA+=1\n        return arr\n    \n    def heapSort(self, arr):\n        def heapify(arr, arrLen, i):\n            # i = index of this node\n            l = 2 * i + 1\n            r = l + 1\n            largestIdx = i\n            \n            # theese two if is to finding the biggest node to make a max heap \n            if l < arrLen and arr[largestIdx] < arr[l]:\n                largestIdx = l\n            if r < arrLen and arr[largestIdx] < arr[r]:\n                largestIdx = r\n            \n            # make the largest the parent\n            if largestIdx!=i:\n                arr[i], arr[largestIdx] = arr[largestIdx], arr[i]\n                heapify(arr, arrLen, largestIdx)\n        \n        arrLen = len(arr)\n        # heap all the tree from the middle of the array to the front\n        # make the end of the array biggest\n        for i in range(arrLen//2, -1, -1):\n            heapify(arr, arrLen, i)\n        \n        # the i is the root of the tree since i, and its a max heap\n        for i in range(arrLen-1, -1, -1):\n            arr[i], arr[0] = arr[0], arr[i]\n            heapify (arr, i, 0)\n        \n        \n    \n    \n        \n\n", "class Solution:\n    # def sortArray(self, nums: List[int]) -> List[int]:\n    #     return sorted(nums)\n    \n    # merge sort\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def mergeSort(nums, start, end):\n            if start >= end:\n                return\n            mid = start + (end - start) // 2\n            mergeSort(nums, start, mid)\n            mergeSort(nums, mid+1, end)\n            L = [0]*(mid-start+1)\n            R = [0]*(end-mid)\n            n1 = len(L)\n            n2 = len(R)\n            for i in range(n1):\n                L[i] = nums[start+i]\n            for j in range(n2):\n                R[j] = nums[mid+1+j]\n            # two pointers\n            i = j = 0\n            for _ in range(start, end+1):\n                if j>=n2 or (i<n1 and L[i]<=R[j]):\n                    nums[start+i+j] = L[i]\n                    i += 1\n                else:\n                    nums[start+i+j] = R[j]\n                    j += 1\n        mergeSort(nums, 0, len(nums)-1)\n        return nums\n        \n", "class Solution:\n    def merge_sort(self, nums):        \n        def helper_sort(left, right):\n            if left > right:\n                return []\n            if left == right:\n                return [nums[left]]\n            \n            mid = (left+right)//2\n            l = helper_sort(left, mid)\n            r = helper_sort(mid+1,right)\n            return helper_merge(l, r)\n        \n        def helper_merge(left_arr, right_arr):\n            l_idx = 0\n            r_idx = 0\n            ret = []\n            \n            while l_idx < len(left_arr) and r_idx < len(right_arr):\n                if left_arr[l_idx] < right_arr[r_idx]:\n                    ret.append(left_arr[l_idx])\n                    l_idx += 1\n                else:\n                    ret.append(right_arr[r_idx])\n                    r_idx += 1\n            ret.extend(left_arr[l_idx:])\n            ret.extend(right_arr[r_idx:])\n            return ret\n        return helper_sort(0, len(nums)-1)\n    \n    def merge_sort_iter(self, nums):\n        if len(nums) <= 1:\n            return nums\n        q = deque()\n        for n in nums:\n            q.append([n])\n        \n        while len(q) > 1:\n            size = len(q)\n            idx = 0\n            while idx < size:\n                l_arr = q.popleft()\n                idx += 1\n                if idx == size:\n                    q.append(l_arr)\n                    break\n                r_arr = q.popleft()\n                idx += 1\n                \n                l_idx = 0\n                r_idx = 0\n                tmp = []\n                while l_idx < len(l_arr) and r_idx < len(r_arr):\n                    if l_arr[l_idx] < r_arr[r_idx]:\n                        tmp.append(l_arr[l_idx])\n                        l_idx += 1\n                    else:\n                        tmp.append(r_arr[r_idx])\n                        r_idx += 1\n                tmp.extend(l_arr[l_idx:])\n                tmp.extend(r_arr[r_idx:])\n                q.append(tmp)\n        return q.popleft()\n    \n    def sortArray(self, nums: List[int]) -> List[int]:\n        # return self.merge_sort(nums)\n        return self.merge_sort_iter(nums)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)<=1:\n            return nums\n        \n        sorted_list = nums\n        \n        while len(sorted_list)>1:\n            \n            x = sorted_list.pop(0)\n            y = sorted_list.pop(0)\n            sorted_list.append(self.merge(x,y))\n            \n            \n            \n        \n        return sorted_list[0]\n            \n            \n        \n        \n        \n    def merge(self,list1, list2):\n        \n        if isinstance(list1, int):\n            list1 = [list1]\n        if isinstance(list2, int):\n            list2 = [list2]\n        ret = []\n            \n        list1_cursor = list2_cursor = 0\n        \n        while list1_cursor < len(list1) and list2_cursor < len(list2):\n            if list1[list1_cursor] < list2[list2_cursor]:\n                ret.append(list1[list1_cursor])\n                list1_cursor += 1\n                \n            else:\n                ret.append(list2[list2_cursor])\n                list2_cursor += 1\n                    \n            \n        ret.extend(list1[list1_cursor:])\n        ret.extend(list2[list2_cursor:])\n        \n        return ret", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        #Heap Sort, building max heap\n        l=len(nums)\n        def heapify(i: int, l: int) -> None:\n            if 2*i+2==l:\n                if nums[i]<nums[2*i+1]:\n                    nums[i], nums[2*i+1]=nums[2*i+1], nums[i]\n            elif 2*i+2<l:\n                if nums[2*i+1] > nums[2*i+2]:\n                    if nums[i]<nums[2*i+1]:\n                        nums[i], nums[2*i+1]=nums[2*i+1], nums[i]\n                    heapify(2*i+1, l)\n                else:\n                    if nums[i]<nums[2*i+2]:\n                        nums[i], nums[2*i+2]=nums[2*i+2], nums[i]\n                    heapify(2*i+2, l)\n                        \n        #building the heap\n        for i in range((l-1)//2, -1, -1):\n            heapify(i, l)\n        \n        #swap the top with the last item and decrease the heap by 1, rebuilding the heap\n        for i in range(l-1, -1, -1):\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(0, i)\n            \n        return nums\n        \n        \\\"\\\"\\\"\n        #Quick sort\n        def quickSort(start:int, end:int) -> None:\n            if start>=end:\n                return\n            if (end==start+1):\n                if nums[end]<nums[start]:\n                    nums[end], nums[start] = nums[start], nums[end]\n                return\n            pivit=nums[end]\n            left, right=start, end-1\n            while left<=right:\n                while left<=end-1 and nums[left]<=pivit:\n                    left+=1\n                while right>=start and nums[right]>=pivit:\n                    right-=1\n                if left<right:\n                    nums[left], nums[right] = nums[right], nums[left]\n                    left+=1\n                    right-=1\n            nums[left], nums[end] = nums[end], nums[left]\n            quickSort(start, left-1)\n            quickSort(left+1, end)\n            \n        quickSort(0, len(nums)-1)\n        return nums\n        \\\"\\\"\\\"\n        \n        \\\"\\\"\\\"\n        #Merge Sort\n        def merge(l1:List[int], l2:List[int]) -> List[int]:\n            ret =[]\n            i1=i2=0\n            while i1<len(l1) and i2<len(l2):\n                if l1[i1]<l2[i2]:\n                    ret.append(l1[i1])\n                    i1+=1\n                else:\n                    ret.append(l2[i2])\n                    i2+=1\n            if i1==len(l1):\n                ret+=l2[i2:]\n            else:\n                ret+=l1[i1:]\n            return ret\n        \n        def mergeSort(start:int, end:int) -> List[int]:\n            if start>=end:\n                return [nums[start]]\n            if start+1==end:\n                if nums[start]>nums[end]:\n                    nums[start], nums[end]=nums[end], nums[start]\n                return [nums[start], nums[end]]\n            mid=(start+end)//2\n            return merge(mergeSort(start, mid), mergeSort(mid+1, end))\n            \n        return mergeSort(0, len(nums)-1)\n        \\\"\\\"\\\"\n        \n        ", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def merge(left, right):\n            result = []\n            while len(left) != 0 and len(right) != 0:\n                l = left[0]\n                r = right[0]\n                if r < l:\n                    result.append(right.pop(0))\n                else:\n                    result.append(left.pop(0))\n            return result + left + right\n        def mergeSort(arr):\n            if len(arr) < 2:\n                return arr[:]\n            else:\n                mid = len(arr) // 2\n                left = mergeSort(arr[:mid])\n                right = mergeSort(arr[mid:])\n                return merge(left, right)\n        \n        return mergeSort(nums)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return sorted(nums)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        if len(nums) == 1:\n            return nums\n        \n        n = int(len(nums) / 2)\n        a1 = nums[:(n)]\n        a2 = nums[(n):]\n        \n        a1 = self.sortArray(a1)\n        a2 = self.sortArray(a2)\n        \n        return self.merge(a1,a2)\n    \n    def merge(self,a1,a2):\n        i1 = 0\n        i2 = 0\n        ret = []\n        \n        while i1 < len(a1) and i2 < len(a2):\n            if a1[i1] < a2[i2]:\n                ret.append(a1[i1])\n                i1 += 1\n            else:\n                ret.append(a2[i2])\n                i2 += 1\n        \n        while i1 < len(a1):\n            ret.append(a1[i1])\n            print((a1[i1]))\n            i1 += 1\n        while i2 < len(a2):\n            ret.append(a2[i2])\n            print((a2[i2]))\n            i2 += 1\n        return ret\n                \n                \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def merge_sort(left, right):\n            res = []\n            left_p = right_p = 0\n            while left_p < len(left) and right_p < len(right):\n                if left[left_p] < right[right_p]:\n                    res.append(left[left_p])\n                    left_p += 1\n                else:\n                    res.append(right[right_p])\n                    right_p += 1\n            res.extend(left[left_p:])\n            res.extend(right[right_p:])\n            return res\n\n        \n        if len(nums) <= 1:\n            return nums\n        middle = len(nums) // 2\n        left = self.sortArray(nums[:middle])\n        right = self.sortArray(nums[middle:])\n        if len(left) > len(right):\n            return merge_sort(right, left)\n        else:\n            return merge_sort(left, right)\n        \n\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)>1:\n            mid = len(nums)//2\n            l = nums[:mid]\n            r = nums[mid:]\n            self.sortArray(l)\n            self.sortArray(r)\n            i = 0\n            j = 0\n            k = 0\n            while i<len(l) and j<len(r):\n                if l[i]<r[j]:\n                    nums[k] = l[i]\n                    i+=1\n                else:\n                    nums[k] = r[j]\n                    j+=1\n                k+=1\n            while i<len(l):\n                nums[k] = l[i]\n                i+=1\n                k+=1\n            while j<len(r):\n                nums[k] = r[j]\n                j+=1\n                k+=1\n        return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # Take advantage of this problem to summarize all the sorting algorithms\n        if not nums or len(nums) < 2:\n            return nums\n        \n        return self.heapSort(nums)\n    \n    # Slow sorting algorithms\n    \n    def selection_sort(self, nums):\n        # selection sort, every time we reduce the problem by moving the low boundary backwards by 1\n        # 0: low is sorted and low: is not sorted\n        # in-place without creating temp arrays O(n ^ 2)\n        \n        def select_smallest(nums, low):\n            smallest_index = low\n            for index in range(low + 1, len(nums)):\n                if nums[index] < nums[smallest_index]:\n                    smallest_index = index\n            return smallest_index\n            \n        def swap(nums, i, j):\n            if i != j:\n                nums[i], nums[j] = nums[j], nums[i]\n                \n        for index in range(len(nums) - 1):\n            target_index = select_smallest(nums, index)\n            swap(nums, index, target_index)\n             \n        return nums\n    \n    def insert_sort(self, nums):\n        # the sorted portion is [0: index], look at nums[index] and decide what is the best position to insert within [0: index]\n        # (tricky) the shifting and finding the position to insert is done in the same loop\n        for index in range(1, len(nums)):\n            k = index\n            while k > 0 and nums[k - 1]  > nums[k]:\n                nums[k-1], nums[k] = nums[k], nums[k-1]\n                k -= 1\n        return nums\n    \n    def bubble_sort(self, nums):\n        # each time we push the largest to the end, and then reduce the scope of bubbling\n        def bubble(nums, end):\n            for index in range(end):\n                if nums[index] > nums[index + 1]:\n                    nums[index], nums[index + 1] = nums[index + 1], nums[index]\n        for end in range(len(nums) - 1, -1, -1):\n            bubble(nums, end)\n        return nums\n    \n    # Quicker sorting algorithms\n    \n    def quickSort(self, nums):\n        # quick sort selects a pivot and partition the current list into two parts < pivot, greater than pivot\n        # then recursion into each sub array for further sorting\n        # 1. how to do the split\n        # 2. how to do the recursion\n        # 3. base cases\n        def split(nums, low, high):\n            # should return an index which partitions the data\n            if low < 0 or high >= len(nums) or low >= high:\n                return \n            pivot = nums[low]\n            while low < high:\n                # find the first element less than pivot\n                while low < high and nums[high] > pivot:\n                    high -= 1\n                nums[low] = nums[high]\n                while low < high and nums[low] <= pivot:\n                    low += 1\n                nums[high] = nums[low]\n            nums[low] = pivot\n            return low \n        \n        def recur(nums, low, high):\n            if low >= high:\n                return\n            pivot_index = split(nums, low, high)\n            recur(nums, low, pivot_index - 1)\n            recur(nums, pivot_index + 1, high)\n        recur(nums, 0, len(nums) - 1)\n        return nums\n    \n    def mergeSort(self, nums):\n        # spliting is easy, no need to have. a special function\n        # merging is non-trivial, need to have a separate function. In-space is hard\n    \n        def merge(sub0, sub1):\n            res = []\n            m, n = len(sub0), len(sub1)\n            p0 = p1 = 0\n            while p0 < m and p1 < n:\n                if sub0[p0] < sub1[p1]:\n                    res.append(sub0[p0])\n                    p0 += 1\n                else:\n                    res.append(sub1[p1])\n                    p1 += 1\n            while p0 < m:\n                res.append(sub0[p0])\n                p0 += 1\n            while p1 < n:\n                res.append(sub1[p1])\n                p1 += 1\n            return res\n        \n        if not nums or len(nums) < 2:\n            return nums\n        mid = len(nums) // 2\n        left, right = self.mergeSort(nums[:mid]), self.mergeSort(nums[mid:])\n        return merge(left, right)            \n    \n    def heapSort(self, nums):\n        \n        class Heap:\n            def __init__(self, values=[]):\n                self.values = values\n                self.size = len(values)\n                self.heapify()\n                \n            def _sift_down(self, i, n):\n                if i >= n:\n                    return\n                candidate = i\n                if i * 2 + 1 < n and self.values[2 * i + 1] > self.values[candidate]:\n                    candidate = i * 2 + 1\n                if i * 2 + 2 < n and self.values[2 * i + 2] > self.values[candidate]:\n                    candidate = i * 2 + 2\n                if candidate != i:\n                    self.values[i], self.values[candidate] = self.values[candidate], self.values[i]\n                    self._sift_down(candidate, n)\n                    \n            def heapify(self):\n                if not self.values:\n                    return\n                n = self.size\n                for index in range(n // 2, -1, -1):\n                    self._sift_down(index, n)\n                    \n            def extract_max(self):\n                ret = self.values[0]\n                self.size -= 1\n                self.values[0] = self.values[self.size]\n                self._sift_down(0, self.size)\n                return ret\n            \n        heap = Heap(nums)\n        n = len(nums)\n        result = []\n        while heap.size:\n            result.append(heap.extract_max())\n        return result[::-1]\n            \n            \n            \n            \n            \n            \n            \n            \n                \n            \n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        tmp = [0 for _ in range(len(nums))]\n        self.ms(nums, 0, len(nums)-1, tmp)\n        return nums\n    \n    def ms(self, nums, start, end, tmp):\n        if start >= end:\n            return\n        \n        mid = (start + end) // 2\n        self.ms(nums, start, mid, tmp)\n        self.ms(nums, mid+1, end, tmp)\n        self.merge(nums,start, mid, end, tmp)\n    \n    def merge(self, nums, start, mid, end, tmp):\n        left, right = start, mid + 1\n        idx = start\n        \n        while left <= mid and right <= end:\n            if nums[left] < nums[right]:\n                tmp[idx] = nums[left]\n                left += 1\n            else:\n                tmp[idx] = nums[right]\n                right += 1\n            idx += 1\n        \n        while left <= mid:\n            tmp[idx] = nums[left]\n            left += 1\n            idx += 1\n        while right <= end:\n            tmp[idx] = nums[right]\n            right += 1\n            idx += 1\n        \n        for i in range(start, end+1):\n            nums[i] = tmp[i]\n            \n        return", "class Solution:  \n    def left(self, i):\n        return 2*i+1\n    def right(self, i):\n        return 2*i+2\n    def parent(self, i):\n        return (i//2)-1 if not i%2 else i//2\n    \n    def maxheapify(self, a, heapsize,i):\n        l = self.left(i)\n        leftisgreater = False\n        rightisgreater = False\n        if l < heapsize:\n            if a[i] < a[l]:\n                leftisgreater = True\n        r = self.right(i)\n        if r < heapsize:\n            if a[i] < a[r]:\n                rightisgreater = True\n        \n        if leftisgreater or rightisgreater:\n            if leftisgreater and not rightisgreater:\n                a[i],a[l] = a[l],a[i]\n                self.maxheapify(a, heapsize, l)\n            elif not leftisgreater and rightisgreater:\n                a[i],a[r] = a[r],a[i]\n                self.maxheapify(a, heapsize, r)\n            elif leftisgreater and rightisgreater:\n                if a[l] <= a[r]:\n                    rightisgreater = True\n                    leftisgreater = False\n                else:\n                    leftisgreater = True\n                    rightisgreater = False\n                if rightisgreater:\n                    a[i],a[r] = a[r],a[i]\n                    self.maxheapify(a, heapsize, r)\n                else:\n                    a[i],a[l] = a[l],a[i]\n                    self.maxheapify(a, heapsize, l)\n                    \n\n    def buildmaxheap(self, nums, heapsize):\n        for i in reversed(range(len(nums)//2)):\n            self.maxheapify(nums, heapsize,i)\n           \n    \n    def heapsort(self, nums):\n        heapsize = len(nums)\n        self.buildmaxheap(nums, heapsize)\n        for i in range(len(nums)):\n            nums[0],nums[heapsize-1]=nums[heapsize-1],nums[0]\n            heapsize-=1\n            self.maxheapify(nums, heapsize, 0)\n        \n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.heapsort(nums)\n        return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.mergeSort(nums)\n        return nums\n    \n    def mergeSort(self, nums: List[int]) -> None:\n        if len(nums) > 1:\n            mid = len(nums) // 2\n            L, R = nums[:mid], nums[mid:]\n\n            self.mergeSort(L)\n            self.mergeSort(R)\n            \n            \n            i = j = k = 0\n            while i < len(L) and j < len(R):\n                if L[i] < R[j]:\n                    nums[k] = L[i]\n                    i += 1\n                else:\n                    nums[k] = R[j]\n                    j += 1\n                k += 1\n            \n            while i < len(L):\n                nums[k] = L[i]\n                i += 1\n                k += 1\n\n            while j < len(R):\n                nums[k] = R[j]\n                j += 1\n                k += 1\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        if nums is None or len(nums) < 2:\n            return nums\n        \n        return self.countSort(nums, len(nums))\n    \n    def countSort(self, nums, n):\n        memo = collections.defaultdict(lambda: 0)\n        \n        for num in nums:\n            memo[num] += 1\n            \n        answer = [None] * n\n        currentIndex = 0\n        \n        for currentNum in range(-50000, 50001):\n            \n            if currentNum in memo:\n                \n                while memo[currentNum] > 0:\n                    answer[currentIndex] = currentNum\n                    currentIndex += 1\n                    memo[currentNum] -= 1\n                    \n        return answer\n                    \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        mi = abs(min(nums))\n        nums = [i+mi for i in nums]\n        l = len(str(max(nums)))\n        res = []\n        for i in nums:\n            if len(str(i)) == l:\n                res.append(str(i))\n                continue\n            d = l-len(str(i))\n            a = '0'*d + str(i)\n            res.append(a)\n            \n        for i in range(l-1,-1,-1):\n            res = self.f(res,i)\n            \n        return [int(i)-mi for i in res]\n            \n    def f(self,res,i):\n        count = {str(x):[] for x in range(10)}\n        for j in res:\n            count[j[i]].append(j)\n        arr = []\n        for j in '0123456789':\n            if len(count[j]) == 0:\n                continue\n            for x in count[j]:\n                arr.append(x)\n        return arr\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return sorted(nums)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        buckets = [0] * 100002\n        res = []\n        for i in nums:\n            buckets[i + 50000] += 1\n        for i in range(len(buckets)):\n            if buckets[i] != 0:\n                for _ in range(buckets[i]):\n                    res.append(i - 50000)\n        return res", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        count = [0] * 100010\n        for n in nums:\n            count[n + 50000] += 1\n        \n        res = []\n        for c in range(100010):\n            while count[c] > 0:\n                res.append(c - 50000)\n                count[c] -= 1\n        \n        return res\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        self.countingSort(nums)\n        return nums\n        \n                  \n    def quickSort(self, arr):\n        import random\n        def partition(arr, l, h):\n                if l>=h:\n                    return\n                #pivot = arr[random.randint(l,h)]\n                pivot = arr[h]\n                tempL, tempH = l, h\n                while tempL<=tempH:\n                    while tempL<=tempH and arr[tempL]<pivot:\n                        tempL+=1\n                    while tempL<=tempH and arr[tempH]>pivot:\n                        tempH-=1\n                    if tempL<=tempH:\n                        arr[tempL], arr[tempH] = arr[tempH], arr[tempL]\n                        tempL+=1\n                        tempH-=1\n                partition(arr, l, tempH)\n                partition(arr, tempL, h)\n                return\n        partition(arr, 0, len(arr)-1)\n        return arr\n    \n    def mergeSort(self, arr):\n        if len(arr)<=1: return\n        mid = len(arr)//2\n        L = arr[:mid]\n        R = arr[mid:]\n        self.mergeSort(L)\n        self.mergeSort(R)\n        idxL = 0\n        idxR = 0\n        idxA = 0\n        while idxA<len(arr):\n            if idxL < len(L) and idxR < len(R):\n                if L[idxL]<R[idxR]:\n                    arr[idxA] = L[idxL]\n                    idxL += 1\n                else:\n                    arr[idxA] = R[idxR]\n                    idxR += 1\n            elif idxL < len(L):\n                arr[idxA] = L[idxL]\n                idxL += 1\n            else:\n                arr[idxA] = R[idxR]\n                idxR += 1\n            idxA+=1\n        return arr\n    \n    def heapSort(self, arr):\n        def heapify(arr, arrLen, i):\n            # i = index of this node\n            l = 2 * i + 1\n            r = l + 1\n            largestIdx = i\n            \n            # theese two if is to finding the biggest node to make a max heap \n            if l < arrLen and arr[largestIdx] < arr[l]:\n                largestIdx = l\n            if r < arrLen and arr[largestIdx] < arr[r]:\n                largestIdx = r\n            \n            # make the largest the parent\n            if largestIdx!=i:\n                arr[i], arr[largestIdx] = arr[largestIdx], arr[i]\n                heapify(arr, arrLen, largestIdx)\n        \n        arrLen = len(arr)\n        # heap all the tree from the middle of the array to the front\n        # make the end of the array biggest\n        for i in range(arrLen//2, -1, -1):\n            heapify(arr, arrLen, i)\n        \n        # the i is the root of the tree since i, and its a max heap\n        for i in range(arrLen-1, -1, -1):\n            arr[i], arr[0] = arr[0], arr[i]\n            heapify (arr, i, 0)\n            \n    def countingSort(self, arr):\n        maxA = arr[0]\n        minA = arr[0]\n        \n        for a in arr:                           # O(len(arr))\n            maxA = max(maxA, a)\n            minA = min(minA, a)\n            \n        countLen = maxA-minA+1\n        offset = - minA\n        \n        count = [0 for i in range(countLen)]    # O(max(arr)-min(arr))\n        \n        for a in arr:                           # O(len(arr))\n            count[a + offset] += 1\n        \n        for i in range(1,countLen):             # O(max(arr))\n            count[i] += count[i-1]\n        \n        res = list(arr)                  \n        \n        for r in res:\n            arr[count[r + offset]-1] = r\n            count[r + offset] -= 1\n            \n        return", "import math\nclass Solution:\n    \n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) < 64:\n            return sorted(nums)\n        if len(nums) <= 1:\n            return nums\n        c = 0\n        maxN = nums[-1]\n        al,ar=[],[]\n        \n        for num in nums:\n            if num < maxN:\n                al.append(num)\n            elif num > maxN:\n                ar.append(num)\n            elif num == maxN:\n                c += 1\n            \n        return self.sortArray(al) + [maxN] * c + self.sortArray(ar)\n        \n        \n    \n    \n\n            \n        \n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n\\t\n        if len(nums) <=1: return nums\n        less , greater , base = [] , [] , nums.pop()\n        for i in nums:\n            if i < base: less.append(i)\n            else: greater.append(i)\n        return self.sortArray(less) + [base] + self.sortArray(greater)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n\\t\n        if len(nums) <=1: \n            return nums\n        less , greater , base = [] , [] , nums.pop()\n        for i in nums:\n            if i < base: \n                less.append(i)\n            else: \n                greater.append(i)\n        return self.sortArray(less) + [base] + self.sortArray(greater)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        else:\n            pivot = nums[int(len(nums)/2)]\n            L = []\n            M = []\n            R = []\n            for n in nums:\n                if n < pivot:\n                    L.append(n)\n                elif n > pivot:\n                    R.append(n)\n                else:\n                    M.append(n)\n            return self.sortArray(L) + M + self.sortArray(R)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return self.quickSort(nums)\n        \n    def quickSort(self, nums):\n        if not nums or len(nums) < 2:\n            return nums\n        pivot = nums[0]\n        left = [] \n        right = []\n        for x in nums[1:]:\n            if x <= pivot:\n                left.append(x)\n            else:\n                right.append(x)\n        return self.quickSort(left) + [pivot] + self.quickSort(right)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return self.quickSort(nums)\n    \n    def quickSort(self, nums):\n        if not nums or len(nums) < 2:\n            return nums\n        \n        pivot = nums[0]\n        left = []\n        right = []\n        for n in nums[1:]:\n            if n <= pivot:\n                left.append(n)\n            else:\n                right.append(n)\n        return self.quickSort(left) + [pivot] + self.quickSort(right)\n                \n        \n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        quickSort(nums, 0, len(nums)-1)\n        return nums\n    \n    \ndef partition(arr, low, high):\n    # i = (low-1)         # index of smaller element\n    i = low\n    pivot = arr[high]     # pivot\n    for j in range(low, high):\n        if arr[j] < pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    # arr[i+1], arr[high] = arr[high], arr[i+1]\n    arr[i], arr[high] = arr[high], arr[i]\n    # return (i+1)\n    return i\n\ndef quickSort(arr, low, high):\n    if low >= high:\n        return\n    pi = partition(arr, low, high)\n    quickSort(arr, low, pi-1)\n    quickSort(arr, pi+1, high)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        quickSort(nums, 0, len(nums)-1)\n        return nums\n    \n    \ndef partition(arr, low, high):\n    i = (low-1)         # index of smaller element\n    pivot = arr[high]     # pivot\n    for j in range(low, high):\n        if arr[j] < pivot:\n            i = i+1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i+1], arr[high] = arr[high], arr[i+1]\n    return (i+1)\n\ndef quickSort(arr, low, high):\n    if low >= high:\n        return\n    pi = partition(arr, low, high)\n    quickSort(arr, low, pi-1)\n    quickSort(arr, pi+1, high)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        self.quickSort(nums, 0, n-1)\n        return nums\n    def quickSort(self, nums, low, high):\n        if low < high: \n            pivot = self.partition(nums, low, high)\n            self.quickSort(nums, low, pivot - 1)\n            self.quickSort(nums, (pivot + 1), high)\n\n    def partition (self, nums: List[int], low, high) -> int:\n        i = (low - 1)\n        pivot = nums[high]\n        for j in range(low, high):\n            if nums[j] <= pivot:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n\n        nums[i + 1], nums[high] = nums[high], nums[i + 1]\n        return (i + 1)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        quickSort(nums, 0, len(nums)-1)\n        return nums\n    \n    \ndef partition(arr, low, high):\n    i = low - 1  # last small element\n    pivot = arr[high]\n    for j in range(low, high):\n        if arr[j] < pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i+1], arr[high] = arr[high], arr[i+1]  # i+1 is pivot\n    return i+1\n\ndef quickSort(arr, low, high):\n    if low >= high:\n        return\n    pi = partition(arr, low, high)\n    quickSort(arr, low, pi-1)\n    quickSort(arr, pi+1, high)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def quicksort(nums):\n            if len(nums) <= 1:\n                return nums\n            else:\n                q = nums[len(nums) // 2]\n            l_nums = [n for n in nums if n < q]\n\n            e_nums = [q] * nums.count(q)\n            b_nums = [n for n in nums if n > q]\n            return quicksort(l_nums) + e_nums + quicksort(b_nums)\n        \n        return quicksort(nums)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.quick_sort(nums, 0, len(nums) - 1)\n        \n        return nums\n    \n    def quick_sort(self, nums, start, end):\n        if start >= end:\n            return\n        \n        left, right = start, end\n        pivot = nums[(start + end) // 2]\n        \n        while left <= right:\n            while left <= right and nums[left] < pivot:\n                left += 1\n            \n            while left <= right and nums[right] > pivot:\n                right -= 1\n            \n            if left <= right:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n                right -= 1\n            \n        \n        self.quick_sort(nums, start, right)\n        self.quick_sort(nums, left, end)\n                    \n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return self.partition(nums)\n    def partition(self,num_list):\n        if not num_list or len(num_list) ==1:\n            return num_list\n        pivot = num_list[0]\n        left = []\n        right = []\n        for i in range(1,len(num_list)):\n            if num_list[i] >= pivot:\n                right.append(num_list[i])\n            else:\n                left.append(num_list[i])\n        return self.partition(left)+[pivot]+self.partition(right)\n    \n                \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def helper(start, end):\n            if start >= end:\n                return\n            l = start\n            r = end\n            mid = l + (r - l) // 2\n            pivot = nums[mid]\n            while r >= l:\n                while r >= l and nums[l] < pivot:\n                    l += 1\n                while r >= l and nums[r] > pivot:\n                    r -= 1\n                if r >= l:\n                    nums[l], nums[r] = nums[r], nums[l]\n                    l += 1\n                    r -= 1\n            helper(start, r)\n            helper(l, end)\n        \n        helper(0, len(nums) - 1)\n        return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # BASE CASE \n        if not nums or len(nums) == 1: \n            return nums \n        \n        pivot = nums[0]\n        # pointer from 1 on \n        # check if the pointer is <= pivot \n        # if it is, then swap with the idx val, increment\n        # if it is not, then skip, increment\n        # that pointer is the spot where the pivot should be\n        pivot_i = 1 #pivot_i, where pivot goes after sorting\n        for i in range(1, len(nums)):\n            if nums[i] <= pivot:\n                nums[pivot_i], nums[i] = nums[i], nums[pivot_i]\n                pivot_i += 1\n        nums[pivot_i-1], nums[0] = nums[0], nums[pivot_i-1]\n        # at pivot_i-1 is your pivot\n        return self.sortArray(nums[:pivot_i-1]) + [pivot] + self.sortArray(nums[pivot_i:])", "class Solution:\n    def partition(self,arr,pi):\n        less,equal, high = [],[],[]\n        for i in arr:\n            if i<pi:\n                less.append(i)\n            if i == pi:\n                equal.append(i)\n            if i>pi:\n                high.append(i)\n        return (less,equal,high)\n                \n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)<1:\n            return nums\n        pivot = nums[0]\n        less,equal,high = self.partition(nums,pivot)\n        return self.sortArray(less)+equal+self.sortArray(high)\n", "class Solution:\n    def sortArray(self, nums: List[int]):\n        #use qsort, lc 215\n        #partition() will place the pivot into the correct place, \u5de6\u9589\u53f3\u9589\n        #outer function, will recursively process the numbers nums[:correct_idx] and numbers nums[correct_idx+1:] \n        #qsort(nums[4,3,6,6,8,6], 4 will be placed to idx1 => [3,4,6,6,8,6])\n        # /                 \\\\\n        #qsort(nums[3])    qsort([6,6,8,6], 6 will be placed to idx 2 in the original nums)\n        \n        #=>qsort() is the recursion, with input arg as start idx, end idx\n        \n        self.qsort(nums, 0, len(nums)-1)\n        return nums\n    \n    def qsort(self, nums, start_idx, end_idx): #start_idx and end_idx \u5de6\u9589\u53f3\u9589\n        \n        #terminate:\n        #if end_idx >= start_idx: => error\n        if end_idx <= start_idx:\n            return\n        \n        #start_idx = 0\n        #end_idx = len(nums)-1\n        correct_idx = self.partition(nums, start_idx, end_idx) #the partition() will put nums[start] into the correct place\n        self.qsort(nums, start_idx, correct_idx-1)\n        self.qsort(nums, correct_idx+1, end_idx)\n        \n    def partition(self, nums, start, end):\n        pivot = nums[start]\n        left = start + 1\n        right = end\n        \n        #goal: put values <= pivot before pointer left\n        #                 >=       after pointer right\n        while left <= right:\n            #if nums[left] > pivot: #now we need to find the nums[right] < pivot so that we can swap them\n            \n            if nums[left] > pivot and nums[right] < pivot:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n                right -= 1\n            if nums[left] <= pivot:\n                left += 1\n            if nums[right] >= pivot:\n                right -= 1\n        \n        #now right is the correct place  to place pivot\n        nums[start], nums[right] = nums[right], nums[start]\n        return right\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        '''method 1: mergesort (divide and conqueer). Time complexity: T(n) = 2*T(n/2)+O(n) --> TC: O(nlogn). Space complexity: O(n+logn), since the recursion depth is logn, and we allocate size n temporary array to store intermediate results.'''\n#         def helper(l,r):\n#             if l+1>=r: return\n#             m = l + (r-l)//2\n#             helper(l, m)\n#             helper(m, r)\n#             it1 = l\n#             it2 = m\n#             ind = 0\n#             while it1 < m or it2 < r:\n#                 if it2 == r or (it1 < m and nums[it1] <= nums[it2]):\n#                     temp[ind] = nums[it1]\n#                     it1 += 1\n#                 else:\n#                     temp[ind] = nums[it2]\n#                     it2 += 1\n#                 ind += 1\n#             nums[l:r] = temp[:ind]\n            \n#         temp = [0]*len(nums)\n#         helper(0, len(nums))\n#         return nums\n        '''method2: quick sort. not stable. O(nlogn)/O(1)'''\n        def pivot(l,r):\n            if l >= r:\n                return\n            p = nums[random.randint(l, r)]\n            it1 = l\n            it2 = r\n            while it1 <= it2:\n                while nums[it1] < p:\n                    it1 += 1\n                while nums[it2] > p:\n                    it2 -= 1\n                if it1 <= it2:\n                    nums[it1], nums[it2] = nums[it2], nums[it1]\n                    it1 += 1\n                    it2 -= 1\n            pivot(l, it2)\n            pivot(it1, r)\n        pivot(0, len(nums)-1)\n        return nums\n            \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n \n        if len(nums)==0:\n            return []\n\n        pivot = nums[0]\n\n        left = [x for x in nums[1:] if x<=pivot]\n        right = [x for x in nums[1:] if x>pivot]\n\n        return self.sortArray(left)+[pivot]+self.sortArray(right)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        def _selection_sort(a):\n            for i in range(len(a)):\n                m = i\n                for j in range(i+1,len(a)):\n                    if a[m] > a[j]:\n                        m = j\n                a[i],a[m] = a[m], a[i]\n                \n        def _bubble_sort(a):\n            for i in range(len(a)):\n                for j in range(len(a)-1-i):\n                    if a[j] > a[j+1]:\n                        a[j], a[j+1] = a[j+1], a[j]\n                \n        def _insertion_sort(a):\n            for i in range(1,len(a)):\n                v = a[i]\n                j = i\n                while j > 0 and a[j-1] > v:\n                    a[j] = a[j-1]\n                    j -= 1\n                a[j] = v\n\n        def _quick_sort(a,s,e):\n            def _partition(a,s,e):\n                f = l = s\n                while l < e:\n                    if a[l] <= a[e]:\n                        a[f],a[l] = a[l],a[f]\n                        f+=1\n                    l+=1\n                a[f],a[e] = a[e],a[f]\n                return f\n            \n            if s < e:\n                p = _partition(a,s,e)\n                _quick_sort(a,s,e=p-1) #left\n                _quick_sort(a,s=p+1,e=e) # right\n         \n        def _merge_sort(a):\n        \n            def _merge(a,b):\n                result = []\n                i = j = 0\n                while i < len(a) and j < len(b):\n                    if a[i] <= b[j]:\n                        result.append(a[i])\n                        i += 1\n                    else:\n                        result.append(b[j])\n                        j += 1\n                result.extend(a[i:])\n                result.extend(b[j:])\n                return result\n                \n            result = []\n            if len(a) <= 1:\n                result = a.copy()\n                return result\n            \n            m = len(a)//2\n            _left = a[:m]\n            _right = a [m:]\n            _new_left = _merge_sort(_left)\n            _new_right = _merge_sort(_right)\n            result = merge(_new_left,_new_right)\n            return result\n            \n        \n        #_selection_sort(nums) #exceeds time\n        #_bubble_sort(nums)    #exceeds time\n        #_insertion_sort(nums) #exceeds time\n        _quick_sort(nums,s=0,e=len(nums)-1)\n        return nums\n        #return _merge_sort(nums) #slower then 95%\n        \n    \n    \n", "# 3:10\nfrom random import random\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        def partition(start, end):\n            pivot = round(random() * (end - start)) + start\n            nums[start], nums[pivot] = nums[pivot], nums[start]\n            below = above = start + 1\n            while above <= end:\n                if nums[above] <= nums[start]:\n                    nums[below], nums[above] = nums[above], nums[below]\n                    below += 1\n                above += 1\n            nums[below - 1], nums[start] = nums[start], nums[below - 1]\n            return below - 1\n        \n        start = 0\n        end = len(nums) - 1\n        \n        def quick_sort(start, end):\n            if start < end:\n                # print(nums)\n                pivot = partition(start, end)\n                # print(nums)\n                # print(pivot)\n                # print('------')\n                quick_sort(start, pivot - 1)\n                quick_sort(pivot + 1, end)\n        \n        quick_sort(start, end)\n        \n        return nums\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        res, l, N = [0] * len(nums), 1, len(nums)\n\n        def _merge(ll, lh, rl, rh):\n            if rl >= N:\n                for i in range(ll, N):\n                    res[i] = nums[i]\n            else:\n                p, q, i = ll, rl, ll\n                while p < lh and q < rh:\n                    if nums[p] <= nums[q]:\n                        res[i], p = nums[p], p + 1\n                    else:\n                        res[i], q = nums[q], q + 1\n                    i += 1\n                b, e = (p, lh) if p < lh else (q, rh)\n                for j in range(b, e):\n                    res[i] = nums[j]\n                    i += 1\n\n        while l < N:\n            b = 0\n            while b < N:\n                _merge(b, b + l, b + l, min(N, b + 2 * l))\n                b += 2 * l\n            l, nums, res = l * 2, res, nums\n        return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        def _selection_sort(a):\n            for i in range(len(a)):\n                m = i\n                for j in range(i+1,len(a)):\n                    if a[m] > a[j]:\n                        m = j\n                a[i],a[m] = a[m], a[i]\n                \n        def _bubble_sort(a):\n            for i in range(len(a)):\n                for j in range(len(a)-1-i):\n                    if a[j] > a[j+1]:\n                        a[j], a[j+1] = a[j+1], a[j]\n                \n        def _insertion_sort(a):\n            for i in range(1,len(a)):\n                v = a[i]\n                j = i\n                while j > 0 and a[j-1] > v:\n                    a[j] = a[j-1]\n                    j -= 1\n                a[j] = v\n\n        def _quick_sort(a,s,e):\n            def _partition(a,s,e):\n                f = l = s\n                while l < e:\n                    if a[l] <= a[e]:\n                        a[f],a[l] = a[l],a[f]\n                        f+=1\n                    l+=1\n                a[f],a[e] = a[e],a[f]\n                return f\n            \n            if s < e:\n                p = _partition(a,s,e)\n                _quick_sort(a,s,e=p-1) #left\n                _quick_sort(a,s=p+1,e=e) # right\n         \n        def _merge_sort(a):\n        \n            def _merge(a,b):\n                result = []\n                i = j = 0\n                while i < len(a) and j < len(b):\n                    if a[i] <= b[j]:\n                        result.append(a[i])\n                        i += 1\n                    else:\n                        result.append(b[j])\n                        j += 1\n                result.extend(a[i:])\n                result.extend(b[j:])\n                return result\n                \n            result = []\n            if len(a) <= 1:\n                result = a.copy()\n                return result\n            \n            m = len(a)//2\n            _left = a[:m]\n            _right = a [m:]\n            _new_left = _merge_sort(_left)\n            _new_right = _merge_sort(_right)\n            result = merge(_new_left,_new_right)\n            return result\n            \n        \n        #_selection_sort(nums)\n        #_bubble_sort(nums)\n        #_insertion_sort(nums)\n        _quick_sort(nums,s=0,e=len(nums)-1)\n        #return _merge_sort(nums)\n        return nums\n    \n    \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # MergeSort        \n        def merge(nums, lo, hi):\n            mid = (lo + hi) // 2\n            # [lo, mid] and [mid+1, hi] are already sorted\n            i, j = lo, mid + 1\n            sortedNums = []\n            while i <= mid and j <= hi:\n                if nums[i] < nums[j]:\n                    sortedNums.append(nums[i])\n                    i += 1\n                else:\n                    sortedNums.append(nums[j])\n                    j += 1\n            \n            while i <= mid:\n                sortedNums.append(nums[i])\n                i += 1\n            \n            while j <= hi:\n                sortedNums.append(nums[j])\n                j += 1\n            nums[lo:hi+1] = sortedNums\n            \n        def mergeSort(nums, lo, hi):\n            if hi - lo == 0:\n                return\n            \n            mid = (lo + hi) // 2\n            \n            mergeSort(nums, lo, mid)\n            mergeSort(nums, mid+1, hi)\n            # Both left and right portions are sorted\n            merge(nums, lo, hi)\n\n        mergeSort(nums, 0, len(nums)-1)\n        return nums", "import random\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def quick(nums):\n            if len(nums) == 0:\n                return []\n            pivot = random.choice(nums)\n\n            less = [x for x in nums if x < pivot]\n            eq = [x for x in nums if x == pivot]\n            more = [x for x in nums if x > pivot]\n\n            return quick(less) + eq + quick(more)\n        return quick(nums)\n", "class Solution:\n    def sortArray(self, nums):\n        def mergesort(nums):\n            LA = len(nums)\n            if LA == 1: return nums\n            LH, RH = mergesort(nums[:LA//2]), mergesort(nums[LA//2:])\n            return merge(LH,RH)\n\n        def merge(LH, RH):\n            LLH, LRH = len(LH), len(RH)\n            S, i, j = [], 0, 0\n            while i < LLH and j < LRH:\n                if LH[i] <= RH[j]: i, _ = i + 1, S.append(LH[i])\n                else: j, _ = j + 1, S.append(RH[j])\n            return S + (RH[j:] if i == LLH else LH[i:])\n        \n        return mergesort(nums)\\t\\t", "import random\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if not nums:\n            return []\n        self.quickSort(nums, 0, len(nums) - 1)\n        return nums\n        \n        \n        \n    def quickSort(self, arr, l, r):\n        if l >= r:\n            return \n        \n        position = self.partition(arr, l, r)\n        self.quickSort(arr, l, position)\n        self.quickSort(arr, position + 1, r)\n        \n        \n        \n    def partition(self, arr, l, r):\n        #print(arr, l, r)\n        pivot = arr[random.randint(l, r)]\n        arr[l], pivot = pivot, arr[l]\n        #print(\\\"pivot\\\", pivot)\n        while l < r:     \n            while l < r and arr[r] >= pivot:\n                 r -= 1\n            arr[l] = arr[r] \n            while l < r and arr[l] <= pivot:\n                l += 1\n            arr[r] = arr[l]\n            \n            arr[l] = pivot\n        return l\n\n        \n        \n", "\\\"\\\"\\\"\n\n                e\n            5 2 1 3 \n                  s \n\npivot = nums[s] = 5\n\nWe need to have nums[s] < pviot < nums[e]\n\nif nums[s] > pivot and nums[e] < pivot: out of place so swap(nums, s, e)\n\nif nums[s] <= pivot : right place s += 1\n\nif nums[l] >= pivot : right place l -= 1\n\n\\\"\\\"\\\"\n\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        self.quickSort(nums, 0, len(nums) - 1)\n        return nums\n        \n    \n    def quickSort(self, nums, s, e):\n        if s <= e:\n            p = self.partition(nums, s, e)\n            self.quickSort(nums, s, p - 1)\n            self.quickSort(nums, p + 1, e)\n            \n            \n    def partition(self, nums, s, e):\n        pivot = nums[s]\n        l = s\n        s += 1\n        \n        def swap(nums, i, j):\n            nums[i], nums[j] = nums[j], nums[i]\n            \n        while s <= e:\n            if nums[s] > pivot and nums[e] < pivot:\n                # out of place \n                swap(nums, s, e)\n            \n            if nums[s] <= pivot:\n                s += 1\n            if nums[e] >= pivot:\n                e -= 1\n        swap(nums, l, e)\n        return e\n        ", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if not nums:\n            return []\n        \n        temp = list(range(len(nums)))\n        \n        self.helper(nums, 0, len(nums) - 1, temp)\n        \n        return nums\n    \n    \n    def helper(self, nums, start, end, temp):\n        if start >= end:\n            return \n        \n        mid = (start + end) // 2\n        self.helper(nums, start, mid, temp)\n        self.helper(nums, mid + 1, end, temp)\n        \n        self.merge(nums, start, end, temp)\n        \n    \n    def merge(self, nums, start, end, temp):\n        mid = (start + end) // 2\n        left = start\n        right = mid + 1\n        temp_index = start\n        \n        while left <= mid and right <= end:\n            if nums[left] < nums[right]:\n                temp[temp_index] = nums[left]\n                left += 1\n                temp_index += 1\n            else:\n                temp[temp_index] = nums[right]\n                right += 1\n                temp_index += 1\n        \n        while left <= mid:\n            temp[temp_index] = nums[left]\n            left += 1\n            temp_index += 1\n        \n        while right <= end:\n            temp[temp_index] = nums[right]\n            right += 1\n            temp_index += 1\n        \n        nums[start:end + 1] = temp[start:end + 1]\n        \n        \n", "class Solution:\n    def sortArray(self, listToSort: List[int]):\n        if(len(listToSort)) == 0 or len(listToSort) == 1:\n            return listToSort\n        elif(len(listToSort) == 2):\n            if(listToSort[0] > listToSort[1]):\n                listToSort[0], listToSort[1] = listToSort[1], listToSort[0]\n        else:\n            divider = len(listToSort)//2\n            l = listToSort[:divider]\n            r = listToSort[divider:]\n            self.sortArray(l)\n            self.sortArray(r)\n\n            i = 0\n            j = 0\n            k = 0\n\n            while i < len(l) and j < len(r):\n                if r[j] < l[i]:\n                    listToSort[k] = r[j]\n                    j += 1\n                    k += 1\n                else:\n                    listToSort[k] = l[i]\n                    i += 1\n                    k += 1\n\n            if i < len(l):\n                listToSort[k:] = l[i:]\n\n            if j < len(r):\n                listToSort[k:] = r[j:]\n        return listToSort", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        return nums\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # merge sort\n        # divide and conquer\n        def sort(nums):\n            if len(nums) == 1:\n                return nums\n            mid = len(nums)//2\n            left = sort(nums[:mid])\n            right = sort(nums[mid:])\n            i,j = 0,0\n            res = []\n            while i < mid and j < len(nums) - mid:\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n                    \n            if i < mid:\n                res += left[i:]\n            if j < len(nums) - mid:\n                res += right[j:]\n                \n            return res\n        \n        return sort(nums)\n                \n                \n            \n        \n        \n        \n        \n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # return self.mergeSort(nums)\n        self.quickSort(nums, 0, len(nums)-1)\n        return nums\n    \n    def mergeSort(self, nums):\n        if len(nums) == 1:\n            return nums\n        mid = len(nums)//2\n        left, right = self.mergeSort(nums[:mid]), self.mergeSort(nums[mid:])\n        return merge(left, right)\n    def merge(le, ri):\n        i, j = 0, 0\n        res = []\n        while i < len(le) and j < len(ri):\n            if le[i] < ri[j]:\n                res.append(le[i])\n                i += 1\n            else:\n                res.append(ri[j])\n                j += 1\n        res.append(le[i:] if j == len(ri)-1 else ri[j:])\n        print(res)\n        return res\n    \n    def quickSort(self, nums, start, end):\n        random.shuffle(nums)\n        def sort(nums, start, end):\n            if end <= start:\n                return\n            i, j = start, end\n            p = start\n            curNum = nums[start]\n            while p <= j:\n                if nums[p] < curNum:\n                    nums[i], nums[p] = nums[p], nums[i]\n                    i += 1\n                    p += 1\n                elif nums[p] > curNum:\n                    nums[p], nums[j] = nums[j], nums[p]\n                    j -= 1\n                else: #nums[p]==curNum\n                    p += 1   \n            sort(nums, start, i-1)\n            sort(nums, j+1, end)\n        sort(nums,start,end)\n        # def parition(nums, i, j):\n        #     mid = i + (j-1-i)//2\n        #     nums[j-1], nums[mid] = nums[mid], nums[j-1]\n        #     for idx in range(i, j):\n        #         if nums[idx] < nums[j-1]:\n        #             nums[i], nums[idx] = nums[idx], nums[i]\n        #             i += 1\n        #     nums[j-1], nums[i] = nums[i], nums[j-1]\n        #     # while i <= j-2 and nums[i] == nums[i+1]:\n        #     #     i += 1\n        #     return i\n                \n\n        \n#         def partition(A, I, J):\n#             A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I\n#             for j in range(I,J):\n#                 if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1\n#             A[J-1], A[i] = A[i], A[J-1]\n#             return i\n        \n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <=1:\n            return nums\n        mid = len(nums)//2\n        l_list = self.sortArray(nums[:mid])\n        r_list = self.sortArray(nums[mid:])\n        return self.merge(l_list,r_list)\n    \n    def merge(self,a,b):\n        \n        a_l = b_l = 0\n        m = []\n        while a_l < len(a) and b_l < len(b):\n            if a[a_l] < b[b_l]:\n                m.append(a[a_l])\n                a_l += 1\n            else:\n                m.append(b[b_l])\n                b_l += 1\n            \n        \n            \n        m.extend(a[a_l:])\n        m.extend(b[b_l:])\n        \n        return m\n            \n        \n", "import math\nclass Solution:\n    def merge_fn(self, x: List[int], y: List[int]) -> List[int]:\n        i, j = 0, 0\n        res = []\n        while i < len(x) and j < len(y):\n            if x[i] < y[j]:\n                res.append(x[i])\n                i += 1\n            else:\n                res.append(y[j])\n                j += 1\n        res += x[i:] + y[j:]\n        return res\n        \n    def helper_iter(self, nums: List[int]) -> List[int]:\n        res = deque([[i] for i in nums])\n        while res and len(res)>1:\n            x = res.popleft()\n            y = res.popleft() if len(res) else []\n            res.append(self.merge_fn(x,y))\n        return res[0]\n                \n        \n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) == 1:\n            return nums\n        \n        res = self.helper_iter(nums)\n        return res\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        print(nums)\n        if nums == []: return []\n        p = nums.pop()\n        s = []\n        b = []\n        for i in nums:\n            if i > p:\n                b.append(i)\n            else:\n                s.append(i)\n        return self.sortArray(s.copy()) + [p] + self.sortArray(b.copy())\n", "class Solution:\n    def mergeSort(self, nums):\n        if len(nums) > 1:\n            mid = len(nums) // 2\n            left = nums[mid:]\n            right = nums[:mid]\n            \n            self.mergeSort(left)\n            self.mergeSort(right)\n            i = j = k = 0\n            \n            while i < len(left) and j < len(right):\n                if left[i] < right[j]:\n                    nums[k] = left[i]\n                    i += 1\n                else:\n                    nums[k] = right[j]\n                    j += 1\n                k += 1\n            while i < len(left):\n                nums[k] = left[i]\n                i += 1\n                k += 1\n            while j < len(right):\n                nums[k] = right[j]\n                j += 1\n                k += 1\n                \n                \n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.mergeSort(nums)\n        return nums\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return merge_sort(nums)\n\ndef merge_sort(nums):\n    if len(nums) <= 1:\n        return nums\n\n    pivot = len(nums)//2      \n    left = merge_sort(nums[:pivot])\n    right = merge_sort(nums[pivot:]) \n    return merge(left,right)\n\n\ndef merge(l1: List[int], l2: List[int]) -> List[int]:\n    res = []\n\n    i, j = 0, 0\n    while i < len(l1) and j < len(l2):\n        if l1[i] <= l2[j]:\n            res.append(l1[i])\n            i += 1\n        else:\n            res.append(l2[j])\n            j += 1\n    while i < len(l1):\n        res.append(l1[i])\n        i += 1\n    while j < len(l2):\n        res.append(l2[j])    \n        j += 1\n    return res\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        if len(nums)>1: \n            mid = (len(nums)-1) //2\n            left= nums[0:mid+1]\n            right = nums[mid+1:]\n            left = self.sortArray(left)\n            right = self.sortArray(right)\n            \n            l=r=curr =0\n            \n            while l < len(left) and r < len(right):\n                if left[l] <= right[r]:\n                    nums[curr] = left[l]\n                    l +=1\n                else:\n                    nums[curr] = right[r]\n                    r+=1\n                curr+=1\n                \n            while l < len(left):\n                nums[curr] = left[l]\n                l +=1\n                curr+=1\n                \n            while r < len(right):\n                nums[curr] = right[r]\n                r+=1\n                curr+=1\n                \n        \n        \n        return nums\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def sort(ls1, ls2):\n            i = j = 0\n            sortedList = []\n            while i < len(ls1) and j < len(ls2):\n                if ls1[i] < ls2[j]:\n                    sortedList.append(ls1[i])\n                    i += 1\n                else:\n                    sortedList.append(ls2[j])\n                    j += 1\n            if i < len(ls1):\n                sortedList += ls1[i:]\n            else:\n                sortedList += ls2[j:]\n            return sortedList\n        \n        def divide(ls):\n            if len(ls) <= 1:\n                return ls\n            middle = int(len(ls) / 2)\n            ls1 = divide(ls[:middle])\n            ls2 = divide(ls[middle:])\n            return sort(ls1, ls2)\n        \n        return divide(nums)\n        \n#                 def merge(arr):\n#             # base case \n#             if len(arr) <= 1: \n#                 return arr\n            \n#             pivot = int(len(arr)/2)\n#             left = merge(arr[:pivot])\n#             right = merge(arr[pivot:])\n            \n#             return sort(left, right)\n            \n            \n            \n            \n        \n#         def sort(left, right):\n#             left_cur = right_cur = 0\n#             sorted_arr = []\n#             while (left_cur < len(left) and right_cur < len(right)):\n#                 if left[left_cur] > right[right_cur]:\n#                     sorted_arr.append(right[right_cur])\n#                     right_cur += 1\n#                 else:\n#                     sorted_arr.append(left[left_cur])\n#                     left_cur += 1\n                    \n#             sorted_arr += left[left_cur:] + right[right_cur:]\n            \n#             return sorted_arr\n        \n#         return merge(nums)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        def merge_sort(nums):\n            \n            if len(nums) <=1:\n                return nums\n            \n            pivot = int(len(nums)/2)\n            \n            left = merge_sort(nums[:pivot])\n            right = merge_sort(nums[pivot:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            out = []\n            \n            left_cursor = 0\n            right_cursor = 0\n            \n            while left_cursor < len(left) and right_cursor < len(right):\n                if left[left_cursor] <= right[right_cursor]:\n                    out.append(left[left_cursor])\n                    left_cursor+=1\n                else:\n                    out.append(right[right_cursor])\n                    right_cursor+=1\n            \n            out.extend(right[right_cursor:])\n            out.extend(left[left_cursor:])\n            return out\n        \n        \n        \n        \n        \n        return merge_sort(nums)\n        \n                    \n            \n", "from heapq import heappop, heappush\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        h = []\n        result = []\n        for num in nums:\n            heappush(h, num)\n            \n            \n        while h:\n            result.append(heappop(h))\n            \n        return result", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        # merge sort\n        if nums == [] or len(nums) == 1:\n            return nums\n        m = len(nums) // 2\n        left = self.sortArray(nums[:m])\n        right = self.sortArray(nums[m:])\n        \n        # merge\n        i = j = k = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n            k+= 1\n        \n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n        \n        while i < len(left):\n            nums[k] = left[i]\n            i += 1\n            k += 1\n        \n        return nums\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n# \\t\\t# merge sort. If length <= 1, return\n# \\t\\tif not nums or len(nums) <= 1:\n# \\t\\t\\treturn nums\n\n# \\t\\tmid = len(nums) // 2\n# \\t\\tlower = self.sortArray(nums[:mid]) # Lower after sorting\n# \\t\\thigher = self.sortArray(nums[mid:len(nums)]) # Higher after sorting\n# \\t\\tprint(lower, higher)\n\n# \\t\\ti = j = k = 0\n# \\t\\twhile i < len(lower) and j < len(higher):\n# \\t\\t\\tif lower[i] <= higher[j]:\n# \\t\\t\\t\\tnums[k] = lower[i]\n# \\t\\t\\t\\ti += 1\n# \\t\\t\\telse:\n# \\t\\t\\t\\tnums[k] = higher[j]\n# \\t\\t\\t\\tj += 1\n# \\t\\t\\tk += 1\n\n# \\t\\twhile i < len(lower):\n# \\t\\t\\tnums[k] = lower[i]\n# \\t\\t\\ti += 1\n# \\t\\t\\tk += 1\n# \\t\\twhile j < len(higher):\n# \\t\\t\\tnums[k] = higher[j]\n# \\t\\t\\tj += 1\n# \\t\\t\\tk += 1\n\n# \\t\\treturn nums\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        \n        def merge_sort(nums):\n            \n            N = len(nums)\n            if N <2:\n                return nums\n            \n            nums_left = merge_sort(nums[:N//2])\n            nums_right =  merge_sort(nums[N//2:])\n      \n            i, j, k = 0, 0, 0\n         \n            while (i < len(nums_left) ) and  (j < len(nums_right)):\n                if nums_left[i] <= nums_right[j]:\n                    nums[k] = nums_left[i]\n                    i +=1\n                elif nums_left[i] > nums_right[j]:\n                    nums[k] = nums_right[j]\n                    j += 1\n                k += 1\n                \n            while (i < len(nums_left) ):\n                nums[k] = nums_left[i]\n                i +=1\n                k +=1\n                \n            while (j < len(nums_right) ):\n                nums[k] = nums_right[j]\n                j +=1\n                k +=1\n                   \n            return nums\n        \n        return merge_sort(nums)\n            \n            \n", "class Solution:\n    def merge(self,num: List[int], nums: List[int], arr: List[int]) -> List[int]:\n        i = j = k = 0\n        while i < len(num) and j < len(nums):\n            if num[i] < nums[j]:\n                arr[k] = num[i]\n                i += 1\n            elif num[i] >= nums[j]:\n                arr[k] = nums[j]\n                j += 1\n            k += 1\n        \n        while i < len(num): \n            arr[k] = num[i] \n            i += 1\n            k += 1\n          \n        while j < len(nums): \n            arr[k] = nums[j] \n            j += 1\n            k += 1\n        \n        return arr\n                \n    def sortArray(self, nums: List[int]) -> List[int]:\n        if(len(nums) != 1):\n            mid = len(nums)//2\n            left = self.sortArray(nums[:mid])\n            right = self.sortArray(nums[mid:])\n            nums = self.merge(left, right, nums)\n        return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        def merge(nums):\n            \n            if len(nums)<2:\n                return nums\n            \n            ln = merge(nums[:len(nums)//2])\n            rn = merge(nums[len(nums)//2:])\n            \n            i,j,r = 0, 0, []\n            while i<len(ln) or j<len(rn):\n                if j<len(rn) and (i==len(ln) or rn[j] < ln[i]):\n                    r.append(rn[j])\n                    j += 1\n                else:\n                    r.append(ln[i])\n                    i += 1\n            return r\n        \n        return merge(nums)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def merge(left_array, right_array):\n            if not left_array:\n                return right_array\n            \n            if not right_array:\n                return left_array\n            \n            left_low = 0\n            right_low = 0\n            output = []\n            while left_low < len(left_array) or right_low < len(right_array):\n                if left_low < len(left_array) and right_low < len(right_array):\n                    if left_array[left_low] < right_array[right_low]:\n                        output.append(left_array[left_low])\n                        left_low += 1\n                    else:\n                        output.append(right_array[right_low])\n                        right_low += 1\n                elif left_low < len(left_array):\n                    output.append(left_array[left_low])\n                    left_low += 1\n                else:\n                    output.append(right_array[right_low])\n                    right_low += 1\n            \n            return output\n            \n        \n        def sort(low, high):\n            if low == high:\n                return [nums[low]]\n            elif low > high:\n                return []\n            \n            mid = low + (high - low) // 2\n            \n            left = sort(low, mid)\n            right = sort(mid + 1, high)\n            \n            return merge(left, right)\n        \n        if not nums:\n            return []\n        \n        return sort(0, len(nums) - 1)\n        \n", "def merge(arr,l,m,r):\n    n1 = m-l+1\n    n2 = r-m\n    L = [0]*n1\n    R = [0]*n2\n    for i in range(0,n1):\n        L[i] = arr[l+i]\n    for j in range(0,n2):\n        R[j] = arr[m+1+j]\n    \n    i = 0\n    j = 0\n    k = l\n    while i<n1 and j<n2:\n        if L[i]<=R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n    while i<n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j<n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n    \n    \n    \ndef mergeSort(arr,l,r):\n    if l<r:\n        m = (l+r)//2\n        mergeSort(arr,l,m)\n        mergeSort(arr,m+1,r)\n        merge(arr,l,m,r)\n    return arr\n    \nclass Solution:\n    \n    def sortArray(self, arr: List[int]) -> List[int]:\n        '''\n        #Insertion Sort\n        for i in range(1, len(arr)):\n            key = arr[i]\n            # Move elements of arr[0..i-1], that are\n            # greater than key, to one position ahead\n            # of their current position\n            j = i-1\n            while j >=0 and key < arr[j] :\n                arr[j+1] = arr[j]\n                j -= 1\n            arr[j+1] = key \n        return arr\n        '''\n        return mergeSort(arr,0,len(arr)-1)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.qs(nums, 0, len(nums) - 1)\n        return nums\n    \n    def qs(self, nums, start, end):\n        if start >= end:\n            return\n        \n        pivot = nums[(start+end) // 2]\n        \n        left, right = start, end\n        \n        while left <= right:\n            while left <= right and nums[left] < pivot:\n                left += 1\n            \n            while left <= right and nums[right] > pivot:\n                right -= 1\n            \n            if left <= right:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n                right -= 1\n        \n        self.qs(nums, start, right)\n        self.qs(nums, left, end)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        # partition and return pivot index\n        def partition(nums, low, high):\n            p = nums[low]\n            \n            # i points the last one in region 1\n            i,j = low, low+1\n            while j <= high:\n                if p > nums[j]:\n                    # swap the first one in region 2 with current one \n                    # which should be in region 1\n                    # then move i forward\n                    nums[i+1], nums[j] = nums[j], nums[i+1]\n                    i += 1\n                j += 1\n                \n            # swap the pivot number with last one in region 1\n            nums[i], nums[low] = nums[low], nums[i]\n        \n            return i\n                \n        # quicksort implementation\n        def quickSort(nums, low, high):\n\n            if low < high:\n                # get pivot index\n                pivot_ind = partition(nums, low, high)\n                #print (pivot_ind, nums)\n\n                # recursively call left and right part\n                quickSort(nums,low, pivot_ind-1)\n                quickSort(nums,pivot_ind+1, high)\n        \n        # now invoke quick sort\n        low,high = 0, len(nums)-1\n        quickSort(nums, low, high)\n        return nums", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        def devidelist(L:List[int]):\n            if len(L)<=1:\n                return L\n            mid=len(L)//2\n            left=devidelist(L[0:mid])\n            right=devidelist(L[mid:])\n            return mergesort(left,right)\n            \n        def mergesort(left:List[int],right:List[int]):\n            if not left:\n                return right\n            if not right:\n                return left\n            lidx=0\n            ridx=0\n            ans=[]\n            while lidx<len(left) or ridx<len(right):\n                if lidx==len(left) :\n                    ans.append(right[ridx])\n                    ridx+=1\n                    continue\n                if ridx==len(right) :\n                    ans.append(left[lidx])\n                    lidx+=1\n                    continue\n                if left[lidx]<=right[ridx]:\n                    ans.append(left[lidx])\n                    lidx+=1\n                else:\n                    ans.append(right[ridx])\n                    ridx+=1\n            return ans  \n                    \n        return devidelist(nums)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if nums == [] or len(nums) == 1:\n            return nums\n        if len(nums) == 2 and nums[0] < nums[1]:\n            return nums\n        \n        first = 0\n        middle = len(nums)//2\n        last = len(nums)-1\n        # make the medium value at the first position\n        if nums[first] <= nums[middle] <= nums[last] or nums[last] <= nums[middle] <= nums[first]:\n            nums[first], nums[middle] = nums[middle], nums[first]\n        elif nums[first] <= nums[last] <= nums[middle] or nums[middle] <= nums[last] <= nums[first]:\n            nums[first], nums[last] = nums[last], nums[first]\n        pivot = 0\n        cur = 0\n        boarder = 0\n        for i in range(1, len(nums)):\n            if nums[i] > nums[pivot]:\n                boarder = i\n                break\n        cur = boarder + 1       \n        while cur < len(nums):\n            if nums[cur] <= nums[pivot]:\n                # print('a', nums)\n                nums[boarder], nums[cur] = nums[cur], nums[boarder]\n                # print('b', nums)\n                boarder += 1\n            cur += 1\n        # nums[cur-1], nums[boarder] = nums[boarder], nums[cur-1]\n        # print(nums)\n        \n        left = nums[:boarder]\n        right = nums[boarder:]\n        nums = self.sortArray(left) + self.sortArray(right)\n        \n        return nums\n        \n            \n        \n        \n        \n        \n", "class Solution:\n    def sortArray(self, listToSort: List[int]) -> List[int]:\n        divider = len(listToSort)//2\n        a = listToSort[:divider]\n        b = listToSort[divider:]\n        sortedList= listToSort[0:len(listToSort)]\n\n        a.sort()\n        b.sort()\n\n        i = 0\n        j = 0\n        k = 0\n\n        while i < len(a) and j < len(b):\n            if b[j] < a[i]:\n                sortedList[k] = b[j]\n                j += 1\n                k += 1\n            else:\n                sortedList[k] = a[i]\n                i += 1\n                k += 1\n\n        if i < len(a):\n            sortedList[k:] = a[i:]\n\n        if j < len(b):\n            sortedList[k:] = b[j:]\n\n        listToSort[0:len(listToSort)] = sortedList[0:len(sortedList)]\n    \n        return listToSort\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.merge(nums, 0, len(nums)-1)\n        return nums\n        \n    def merge(self, nums, s, e):\n        if s >= e:\n            return\n        \n        m = (s+e) // 2\n        i, j, k = s, m + 1, 0\n        \n        self.merge(nums, s, m)\n        self.merge(nums, m+1, e)\n        \n        temp = [0 for _ in range(e-s+1)]\n        \n        while i<=m and j<=e:\n            if nums[i] <= nums[j]:\n                temp[k] = nums[i]\n                i += 1\n            else:\n                temp[k] = nums[j]\n                j += 1\n            k += 1\n        \n        while i<=m:\n            temp[k] = nums[i]\n            i+=1\n            k+=1\n        \n        while j<=e:\n            temp[k] = nums[j]\n            j+=1\n            k+=1\n        \n        for i in range(len(temp)):\n            nums[s+i] = temp[i]\n            \n\\\"\\\"\\\"\nnums        : [4, 2, 3, 1]\n\n            merge(0, 3)\n            /   \\\\\n        m(0,1)  m(2,3)\n        /\n    \n         s\n           e\n         m\n           i\n             j\nnums    [1,1]\n             k\ntemp    [2,4]\n    \n\n\n\\\"\\\"\\\"\n        \n    \n\\\"\\\"\\\"\nif s + 1 <= e:\n            m = (s+e) // 2\n            i, j = s, m+1\n            temp = [0 for _ in range(e-s+1)]\n            k = 0\n            while i <= m and j <= e:\n                if nums[i] <= nums[j]:\n                    temp[k] = nums[i]\n                    i += 1\n                else:\n                    temp[k] = nums[k]\n                    j += 1\n                k += 1\n            \n            while i <= m:\n                temp[k] = nums[i]\n                k += 1\n                i += 1\n            \n            for m in range(len(temp)):\n                s[s+m] = temp[m]\n        \n\\\"\\\"\\\"\n    \n\n\n\\\"\\\"\\\"\n10:51\n0) Problem is \n    - sort an array\n    - increasing order !!\n    \n    \n    \n1) Don't forget\n- nums.length >= 1\n- nums[i]  -50k ~ 50k\n\n2) Brain Storming\n\n                       s\n                                e\n                                \n                          m\n                       i\n                             j\n                       0  1  2  3\n        nums        : [3, 2, 5, 4]\n        \n                      s   e\n                      m\n                      i  \n                             j\n        nums        : [3, 2]\n        temp        : [2]\n        \n        if s + 1 <= e:\n            m = (s+e) // 2\n            i, j = s, m+1\n            temp = [0 for _ in range(e-s+1)]\n            k = 0\n            while i <= m and j <= e:\n                if nums[i] <= nums[j]:\n                    temp[k] = nums[i]\n                    i += 1\n                else:\n                    temp[k] = nums[k]\n                    j += 1\n                k += 1\n            \n            while i <= m:\n                temp[k] = nums[i]\n                k += 1\n                i += 1\n            \n            for m in range(len(temp)):\n                s[s+m] = temp[m]\n        \n        \n            merge(s, e)\n          /         \\\\\n    merge(s, m)     merge(m+1, e)\n    \n\n\n\\\"\\\"\\\"", "import math\n\nclass Solution:\n    \n    def merger(self, left, right):\n        \n        lidx  = 0\n        ridx  = 0\n        final = []\n        \n        while lidx < len(left) or ridx < len(right):\n            if ridx == len(right):\n                final.append(left[lidx])\n                lidx += 1\n            elif lidx == len(left):\n                final.append(right[ridx])\n                ridx += 1\n            else:\n                curt_l = left[lidx]\n                curt_r = right[ridx]\n                if curt_l <= curt_r:\n                    final.append(curt_l)\n                    lidx += 1\n                else:\n                    final.append(curt_r)\n                    ridx += 1\n        return final\n\n\n    \n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        if len(nums) == 1:\n            return nums\n        elif len(nums) > 1:\n            mid_idx = math.ceil(len(nums)/2)\n            end_idx = len(nums)\n            \n            sorted_left  = self.sortArray(nums[0:mid_idx])\n            sorted_right = self.sortArray(nums[mid_idx:end_idx])\n            \n            final = self.merger(sorted_left, sorted_right)\n            return final", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def merge(l1, l2):\n            p1 = p2 = 0\n            new_list = []\n            while p1 < len(l1) or p2 < len(l2):\n                if p1 < len(l1) and p2 < len(l2):\n                    if l1[p1] < l2[p2]:\n                        new_list.append(l1[p1])\n                        p1 += 1\n                    else:\n                        new_list.append(l2[p2])\n                        p2 += 1\n                elif p1 < len(l1):\n                    new_list += l1[p1:]\n                    p1 = len(l1)\n                else:\n                    new_list += l2[p2:]\n                    p2 = len(l2)\n            return new_list\n        if len(nums) <= 1:\n            return nums\n        pivot = len(nums) // 2\n        left = self.sortArray(nums[:pivot])\n        right = self.sortArray(nums[pivot:])\n        return merge(left, right)", "class Solution:\n    def merge(self,left,mid,right,arr):\n        \n        i=left\n        j=mid+1\n        \n        temp=[]\n        while(i<=mid and j<=right):\n            \n            if arr[i]<arr[j]:\n                temp.append(arr[i])\n                i+=1\n            else:\n                temp.append(arr[j])\n                j+=1\n        \n        while(i<=mid):\n            temp.append(arr[i])\n            i+=1\n        \n        while(j<=right):\n            temp.append(arr[j])\n            j+=1\n        \n        j=0\n        for i in range(left,right+1):\n            arr[i]=temp[j]\n            j+=1\n      \n    \n    def mergesort(self,left,right,arr):\n        if left>=right:\n            return\n        else:\n            mid=(left+right)//2\n            \n            self.mergesort(left,mid,arr)\n            \n            self.mergesort(mid+1,right,arr)\n            \n            self.merge(left,mid,right,arr)\n            \n            return\n        \n    def insertionSort(self,arr):\n        n=len(arr)\n\n        for i in range(1,n):\n            \n            key=arr[i]\n            \n            j=i-1\n            \n            while(j>=0 and key<arr[j]):\n                \n                arr[j+1]=arr[j]\n                j-=1\n            \n            arr[j+1]=key\n        \n            \n    def heapify(self,index,n,arr):\n        i=index\n        left=2*i+1\n        right=2*i+2\n        max_index=i\n        while(left<n):\n            \n            \n            if arr[left]>arr[max_index]:\n                max_index=left\n            \n            if right<n:\n                \n                if arr[right]>arr[max_index]:\n                    max_index=right\n            \n            if max_index==index:\n                break\n                \n            arr[max_index],arr[index]=arr[index],arr[max_index]\n            \n            index=max_index\n            left=2*index+1\n            right=2*index+2\n    \n    \n    def heapsort(self,arr):\n        \n        n=len(arr)\n        \n        for i in range(0,n):\n            \n            self.heapify(n-i-1,n,arr)\n        \n        for i in range(0,n):\n            \n            arr[0],arr[n-i-1]=arr[n-i-1],arr[0]\n            \n            self.heapify(0,n-i-1,arr)\n    \n                    \n            \n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        #self.mergesort(0,len(nums)-1,nums)\n        #self.insertionSort(nums)\n        self.heapsort(nums)\n        return nums\n", "class node:\n    def __init__(self, val):\n        self.val = val\n        self.right = None\n        self.left = None\n        \n    def insert(self, val):\n        if self.val is not None:\n            if val < self.val:\n                if self.left is None:\n                    self.left = node(val)\n                else:\n                    self.left.insert(val)\n            else:\n                if self.right is None:        \n                    self.right = node(val)\n                else:\n                    self.right.insert(val)\n        else:\n            self.val = val\n            \ndef inorder(root, res):\n    if root:\n        inorder(root.left, res)\n        res.append(root.val)\n        inorder(root.right, res)\n            \n\nclass Solution:\n    root = None\n    \n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) > 0:\n            self.root = node(nums[0])\n            for val in nums[1:]:\n                self.root.insert(val)\n                res = []\n            res = []\n            inorder(self.root, res)\n            print(res)\n            return res", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)<=1:\n            return nums\n        if len(nums)==2:\n            if nums[0]>nums[1]:\n                return [nums[1],nums[0]]\n            else:\n                return nums\n            \n        mid = len(nums)//2\n        left = self.sortArray(nums[:mid+1])\n        right = self.sortArray(nums[mid+1:])\n        return self.mergeSortedArray(left, right)\n        \n        \n    def mergeSortedArray(self, nums1, nums2):\n        res = []\n        while nums1 and nums2:\n            if nums1[0]<=nums2[0]:\n                res.append(nums1.pop(0))\n            else:\n                res.append(nums2.pop(0))\n        res += nums1 + nums2\n        return res", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        def mergeSort(arr):\n            \n            if len(arr) <= 1:\n                return arr\n            \n            mid = len(arr) // 2\n            left = mergeSort(arr[:mid])\n            right = mergeSort(arr[mid:])\n            \n            newArr = []\n            i = 0\n            j = 0\n            while i < len(left) or j < len(right):\n                if j >= len(right) or (i < len(left) and left[i] <= right[j]):\n                    newArr.append(left[i])\n                    i += 1\n                elif i >= len(left) or (j < len(right) and right[j] <= left[i]):\n                    newArr.append(right[j])\n                    j += 1\n            \n            return newArr\n        \n        return mergeSort(nums)\n", "def merge(L,R):\n    if len(L)==0:\n        return R\n    if len(R)==0:\n        return L\n    l=0\n    r=0\n    res=[]\n    while len(res)<len(L)+len(R):\n        if L[l]<R[r]:\n            res.append(L[l])\n            l+=1\n        else:\n            res.append(R[r])\n            r+=1\n        if l==len(L):\n            res+=R[r:]\n            break\n        if r==len(R):\n            res+=L[l:]\n            break\n    return res\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)<2:\n            return nums\n        mid=len(nums)//2\n        L=self.sortArray(nums[:mid])\n        R=self.sortArray(nums[mid:])\n        return merge(L,R)\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        return self.mergeSort(nums, 0, len(nums) - 1)\n        \n    # 4 1 6 6 8 2\n    def mergeSort(self, arr, i, j):\n        if i == j:\n            return [arr[i]]\n        \n        mid = i + (j - i) // 2\n        \n        left_arr = self.mergeSort(arr, i, mid)\n        right_arr = self.mergeSort(arr, mid + 1, j)\n    \n        return self.merge(left_arr, right_arr)\n    \n    def merge(self, a, b):\n        res = []\n        i = 0\n        j = 0\n        \n        while len(res) < len(a) + len(b):\n            if j == len(b) or (i < len(a) and a[i] < b[j]):\n                res.append(a[i])\n                i += 1\n            else:\n                res.append(b[j])\n                j += 1\n            \n        return res", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)<=1:\n            return nums\n            \n        mid = len(nums)//2\n        left = self.sortArray(nums[:mid])\n        right = self.sortArray(nums[mid:])\n        return self.mergeSortedArray(left, right)\n        \n        \n    def mergeSortedArray(self, nums1, nums2):\n        res = []\n        while nums1 and nums2:\n            if nums1[0]<=nums2[0]:\n                res.append(nums1.pop(0))\n            else:\n                res.append(nums2.pop(0))\n        res += nums1 + nums2\n        return res", "import heapq\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        heapify(nums)\n        new = []\n        \n        while nums:\n            new.append(heappop(nums))\n        return new", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1:\n            return nums\n        pivot = len(nums) // 2\n        left_list = self.sortArray(nums[:pivot])\n        right_list = self.sortArray(nums[pivot:])\n        return self.merge_sort(left_list, right_list)\n    \n    def merge_sort(self, left_list, right_list):\n        sorted_list = []\n        left_idx, right_idx = 0, 0\n        while left_idx <= len(left_list) - 1 and right_idx <= len(right_list) - 1:\n            if left_list[left_idx] > right_list[right_idx]:\n                sorted_list.append(right_list[right_idx])\n                right_idx += 1\n            else:\n                sorted_list.append(left_list[left_idx])\n                left_idx += 1\n        \n        sorted_list += left_list[left_idx:] \n        sorted_list += right_list[right_idx:] \n        \n        return sorted_list", "class Solution:\n    def merge(self, left, right):\n        sorted_list = []\n        while left and right:\n            if left[0] <= right[0]:\n                sorted_list.append(left.pop(0))\n            else:\n                sorted_list.append(right.pop(0))\n        if not left:\n            sorted_list+=right\n        if not right:\n            sorted_list+=left\n        return sorted_list\n    \n                \n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums)<2:\n            return nums\n        \n        mid = len(nums)//2\n        \n        left = self.sortArray(nums[mid:])\n        right = self.sortArray(nums[:mid])\n\n        result = []\n        result += self.merge(left, right)\n        \n        return result\n    \n    \n        \\\"\\\"\\\"Quick sort\\\"\\\"\\\"\n#             if len(nums) <= 1:\n#                 return nums\n\n#             pivot = random.choice(nums)\n#             lt = [v for v in nums if v < pivot]\n#             eq = [v for v in nums if v == pivot]\n#             gt = [v for v in nums if v > pivot]\n\n#             return self.sortArray(lt) + eq + self.sortArray(gt)", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) == 1:\n            return nums\n        mid = len(nums) // 2\n        left = self.sortArray(nums[:mid])\n        right = self.sortArray(nums[mid:])\n        result = []\n        p1 = p2 = 0\n        while p1 < len(left) and p2 < len(right):\n            if left[p1] < right[p2]:\n                result.append(left[p1])\n                p1 += 1\n            else:\n                result.append(right[p2])\n                p2 += 1\n        \n        result.extend(left[p1:])\n        result.extend(right[p2:])\n        \n        return result\n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \\\"\\\"\\\"\n        Solution:\n        #1 merge sort, time O (nlogn), space O(n) \n        \n        \\\"\\\"\\\"\n        # return self.mergeSort(nums)\n        return self.heap_sort(nums)\n    \n    def mergeSort(self, nums):\n        # exit\n        if len(nums) <= 1:\n            return nums\n        # \u5411\u4e0b\u53d6\u6574\n        mid = len(nums) // 2\n        left = self.mergeSort(nums[:mid])\n        right = self.mergeSort(nums[mid:])\n        \n        # merge two sub list\n        ret = []\n        l_idx = r_idx = 0\n        while l_idx < len(left) and r_idx < len(right):\n            if left[l_idx] <= right[r_idx]:\n                ret.append(left[l_idx])\n                l_idx += 1\n            else:\n                ret.append(right[r_idx])\n                r_idx += 1\n        while l_idx < len(left):\n            ret.append(left[l_idx])\n            l_idx += 1\n        while r_idx < len(right):\n            ret.append(right[r_idx])\n            r_idx += 1\n        return ret\n        \n        \n    def heap_sort(self, nums):\n        # \u8c03\u6574\u5806\n        # \u8fed\u4ee3\u5199\u6cd5\n        # def adjust_heap(nums, startpos, endpos):\n        #     newitem = nums[startpos]\n        #     pos = startpos\n        #     childpos = pos * 2 + 1\n        #     while childpos < endpos:\n        #         rightpos = childpos + 1\n        #         if rightpos < endpos and nums[rightpos] >= nums[childpos]:\n        #             childpos = rightpos\n        #         if newitem < nums[childpos]:\n        #             nums[pos] = nums[childpos]\n        #             pos = childpos\n        #             childpos = pos * 2 + 1\n        #         else:\n        #             break\n        #     nums[pos] = newitem\n\n        # \u9012\u5f52\u5199\u6cd5\n        def adjust_heap(nums, startpos, endpos):\n            pos = startpos\n            chilidpos = pos * 2 + 1\n            if chilidpos < endpos:\n                rightpos = chilidpos + 1\n                if rightpos < endpos and nums[rightpos] > nums[chilidpos]:\n                    chilidpos = rightpos\n                if nums[chilidpos] > nums[pos]:\n                    nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]\n                    adjust_heap(nums, chilidpos, endpos)\n\n        n = len(nums)\n        # \u5efa\u5806\n        for i in reversed(range(n // 2)):\n            adjust_heap(nums, i, n)\n        # \u8c03\u6574\u5806\n        for i in range(n - 1, -1, -1):\n            nums[0], nums[i] = nums[i], nums[0]\n            adjust_heap(nums, 0, i)\n        return nums\n\n            \n            \n        ", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        tmp = [0 for _ in range(len(nums))]\n        self.ms(nums, 0, len(nums) - 1, tmp)\n        return nums\n    \n    def ms(self, nums, start, end, tmp):\n        if start >= end:\n            return\n        \n        mid = (start + end) // 2\n        self.ms(nums, start, mid, tmp)\n        self.ms(nums, mid+1, end, tmp)\n        self.merge(nums, start, mid, end, tmp)\n    \n    def merge(self, nums, start, mid, end, tmp):\n        left, right = start, mid + 1\n        idx = start\n        \n        while left <= mid and right <= end:\n            if nums[left] < nums[right]:\n                tmp[idx] = nums[left]\n                left += 1\n            else:\n                tmp[idx] = nums[right]\n                right += 1\n            idx += 1\n        \n        while left <= mid:\n            tmp[idx] = nums[left]\n            idx += 1\n            left += 1\n        \n        while right <= end:\n            tmp[idx] = nums[right]\n            idx += 1\n            right += 1\n        \n        for i in range(start, end+1):\n            nums[i] = tmp[i]\n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.heapSort(nums)\n        return nums\n  \n    \n\\t# @quickSort\n    def quickSort(self, nums):\n        \n        def partition(head, tail):\n            \n            if head >= tail: return\n            \n            l, r = head, tail\n            m = (r - l) // 2 + l\n            pivot = nums[m]\n            \n            while r >= l:\n                while r >= l and nums[l] < pivot: \n                    l += 1\n                while r >= l and nums[r] > pivot: \n                    r -= 1\n                    \n                if r >= l:\n                    nums[l], nums[r] = nums[r], nums[l]\n                    l += 1\n                    r -= 1\n                    \n            partition(head, r)\n            partition(l, tail)\n\n        partition(0, len(nums)-1)\n        return nums\n     \n\\t# @mergeSort\n    \n    def mergeSort(self, nums): \n        \n        if len(nums) > 1: \n            \n            mid = len(nums)//2\n            \n            L = nums[:mid] \n            R = nums[mid:] \n\n            self.mergeSort(L)\n            self.mergeSort(R)\n\n            i = j = k = 0\n\n            while i < len(L) and j < len(R): \n                if L[i] < R[j]: \n                    nums[k] = L[i] \n                    i+=1\n                else: \n                    nums[k] = R[j] \n                    j+=1\n                k+=1\n \n            while i < len(L): \n                nums[k] = L[i] \n                i+=1\n                k+=1\n\n            while j < len(R): \n                nums[k] = R[j] \n                j+=1\n                k+=1\n   \n   # @heapSort\n    \n    def heapSort(self, nums):\n        \n        def heapify(nums, n, i): \n            \n            l = 2 * i + 1 #left\n            r = 2 * i + 2 #right\n\\t\\t\\t\n            largest = i\n            \n            if l < n and nums[largest] < nums[l]: \n                largest = l \n\n            if r < n and nums[largest] < nums[r]: \n                largest = r \n\n            if largest != i: #if its not equal to root\n                nums[i], nums[largest] = nums[largest], nums[i] #swap\n                \n                heapify(nums, n, largest)\n                \n        n = len(nums) \n\n        for i in range(n//2+1)[::-1]:  #starting from the last non leaf node and going until the top\n            heapify(nums, n, i) \n\n        for i in range(n)[::-1]: \n            nums[i], nums[0] = nums[0], nums[i]\n            heapify(nums, i, 0)", "def max_heapify(nums, i, lo, hi):\n    l = 2 * i + 1\n    r = 2 * i + 2\n    largest = i\n    if l <= hi and nums[i] < nums[l]:\n        largest = l\n    if r <= hi and nums[largest] < nums[r]:\n        largest = r\n    if largest != i:\n        nums[i], nums[largest] = nums[largest], nums[i]\n        max_heapify(nums, largest, lo, hi)\n\ndef build_max_heap(nums):\n    for i in range(len(nums)//2 - 1, -1, -1):\n        max_heapify(nums, i, 0, len(nums)-1)\n\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        build_max_heap(nums)\n        for i in range(len(nums)-1, 0, -1):\n            nums[0], nums[i] = nums[i], nums[0]\n            max_heapify(nums, 0, 0, i-1)\n        return nums", "import math\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def sort(start, stop):\n            if start >= stop:\n                return nums[start:stop + 1]\n            mid = math.floor((start + stop) / 2)\n            left = sort(start, mid)\n            right = sort(mid + 1, stop)\n            return merge(left, right)\n        def merge(left, right):\n            left_index = 0\n            right_index = 0\n            result = []\n            while left_index < len(left) and right_index < len(right):\n                left_val = left[left_index]\n                right_val = right[right_index]\n                if left_val < right_val:\n                    left_index += 1\n                    result.append(left_val)\n                else:\n                    right_index += 1    \n                    result.append(right_val)\n            if left_index >= len(left):\n                result.extend(right[right_index:])\n            else:\n                result.extend(left[left_index:])\n            return result\n        return sort(0, len(nums) - 1)\n        \n", "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        \n        if nums is None or len(nums) < 2:\n            return nums\n        \n        n = len(nums)\n        \n        for i in range(n//2 - 1, -1, -1):\n            self.heapify(nums, n, i)\n            \n        for i in range(n-1, -1, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            self.heapify(nums, i, 0)\n            \n        return nums\n    \n    def heapify(self, arr, n, i):\n        \n        largest = i\n        leftChild = 2 * i + 1\n        rightChild = 2 * i + 2\n        \n        if leftChild < n and arr[largest] < arr[leftChild]:\n            largest = leftChild\n            \n        if rightChild < n and arr[largest] < arr[rightChild]:\n            largest = rightChild\n            \n        if largest != i:\n            arr[largest], arr[i] = arr[i], arr[largest]\n            self.heapify(arr, n, largest)\n            \n"]