["\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn,m=list(map(int,input().split()))\n\nparty=[[] for _ in range(m+5)]\npc=sorted([list(map(int,input().split())) for _ in range(n)],key=lambda x:x[1])\nchoose=[0]*n\n\nfor i in range(n):\n    party[pc[i][0]].append(i)\n\n\n\nwant=10**18\nfor i in range(1,n+1):\n    p1=len(party[1])\n    # want all other parties to have <i voters\n    for j in range(2,m+5):\n        if len(party[j])<i: continue\n        for k in range(len(party[j])-i+1):\n            p1+=1\n            choose[party[j][k]]=1\n    # want party 1 to have >=i voters\n    want2=0\n    for j in range(n):\n        if p1<i and choose[j]==0 and pc[j][0]!=1:\n            choose[j]=1\n            p1+=1\n        if choose[j]==1:\n            want2+=pc[j][1]\n    if want>want2:\n        want=want2\n    #print(i,want2)\n    # reset\n    choose=[0]*n\n\nprint(want)\n", "n,m=list(map(int,input().split()))\n\nmen=[]\n\nfor i in range(n):\n\tx,y=list(map(int,input().split()))\n\tmen.append((y,x-1))\n\ndef Calc(lim):\n\tcnt=[0]*m\n\tvis=[False]*n\n\tfor i in range(n):\n\t\tcnt[men[i][1]]+=1\n\tcost=0\n\tfor i in range(n):\n\t\tif men[i][1]!=0 and cnt[men[i][1]]>=lim:\n\t\t\tcnt[men[i][1]]-=1\n\t\t\tcost+=men[i][0]\n\t\t\tvis[i]=True\n\t\t\tcnt[0]+=1\n\t\n\tfor i in range(n):\n\t\tif cnt[0]<lim and vis[i] == False and men[i][1]!=0:\n\t\t\tcnt[0]+=1\n\t\t\tcost+=men[i][0]\n\treturn cost\n\nmen.sort()\n\nans = 10**18\n\nfor i in range(n):\n\tans=min(ans,Calc(i))\n\nprint(ans)\n", "n, m = map(int, input().split()) # voters, parties\n\nmoney = [0] * n\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    money[i] = (y, x - 1)\n\nmoney.sort()\n\ndef calc(lim):\n    visited = [False] * n\n    cost = 0\n\n    cnt = [0] * m\n    for i in range(n):\n        cnt[money[i][1]] += 1\n\n    for i in range(n):\n        if money[i][1] != 0 and cnt[money[i][1]] >= lim:\n            cnt[money[i][1]] -= 1\n            cnt[0] += 1\n            cost += money[i][0]\n            visited[i] = True\n\n    for i in range(n):\n        if cnt[0] >= lim:\n            break\n\n        if money[i][1] != 0 and not visited[i]:\n            cnt[money[i][1]] -= 1\n            cnt[0] += 1\n            cost += money[i][0]\n\n    return cost\n\nans = 10 ** 18\n\nfor i in range(n):\n    ans = min(ans, calc(i))\n\nprint(ans)", "import sys\nfrom collections import defaultdict\n\nn, m = map(int, sys.stdin.readline().rstrip('\\n').split(' '))\n\np = defaultdict(list)\nfor _ in range(n):\n\tx, y = map(int, sys.stdin.readline().rstrip('\\n').split(' '))\n\tp[x].append(y)\n\nfor key in p:\n\tp[key] = sorted(p[key])\n\nans = 10**100\nfor k in range(1, n + 1):\n\tcur = 0\n\tr = []\n\tfor key in p:\n\t\tif key == 1:\n\t\t\tcontinue\n\t\ta = p[key]\n\t\tcnt = max(0, len(a) - (k - 1))\n\t\tcur += sum(a[:cnt])\n\t\tr += a[cnt:]\n\tr = sorted(r)\n\tcnt = max(0, len(r) - (n - k))\n\tcur += sum(r[:cnt])\n\tans = min(ans, cur)\n\t\nprint(ans)", "\nclass Solver:\n    def solve(self):\n        self.num_voters, self.num_parties = (int(x) for x in input().split())\n\n        self.votes_per_party = [[] for _ in range(self.num_parties)]\n\n        for _ in range(self.num_voters):\n            party, price = (int(x) for x in input().split())\n            party -= 1\n\n            self.votes_per_party[party].append(price)\n\n        for party in range(self.num_parties):\n            self.votes_per_party[party].sort()\n\n        max_necessary_votes = self.num_voters//2 + 1\n        cost = lambda min_votes : self.conversion_price_with_fixed_votes(min_votes)\n        return self.ternary_search(cost, 0, max_necessary_votes + 2)\n\n    def ternary_search(self, func, begin, end):\n        while begin + 1 < end:\n            mid = (begin + end - 1) // 2\n            if func(mid) <= func(mid + 1):\n                end = mid + 1\n            else:\n                begin = mid + 1\n        return func(begin)\n\n    def conversion_price_with_fixed_votes(self, num_votes):\n        current_votes = len(self.votes_per_party[0])\n        total_cost = 0\n\n        for votes in self.votes_per_party[1:]:\n            if len(votes) >= num_votes:\n                num_bought_votes = len(votes) - num_votes + 1\n                total_cost += sum(votes[:num_bought_votes])\n                current_votes += num_bought_votes\n\n        \n        if current_votes >= num_votes:\n            return total_cost\n        num_votes_to_buy = num_votes - current_votes\n\n        votes_left = []\n        for party in range(1, self.num_parties):\n            votes_left += self.votes_per_party[party][-(num_votes-1):]\n        votes_left.sort()\n\n        return total_cost + sum(votes_left[:num_votes_to_buy])\n\n\nsolver = Solver()\nmin_price = solver.solve()\nprint(min_price)\n\n", "def solve(max_v,votes,m):\n    ans = 0\n    values = []\n    our_v = len(votes[0])\n    for i in range(1,m):\n        L = len(votes[i])\n        if L > max_v:\n            take = L-max_v\n            our_v += take\n            ans += sum(votes[i][:take])\n            if take < L:\n                values.extend(votes[i][take:])\n        else:\n            values.extend(votes[i])\n    values.sort()\n    if our_v <= max_v:\n        needed = max_v + 1 - our_v\n        if needed <= len(values):\n            for i in range(needed):\n                ans += values[i]\n                our_v += 1\n    if our_v <= max_v: return 1<<60\n    return ans\n\nn,m = [int(x) for x in input().split()]\nvotes = [[] for x in range(m)]\n\nfor i in range(n):\n    p,c = (int(x) for x in input().split())\n    p -= 1\n    votes[p].append(c)\n\nfor i in range(m):\n    L = len(votes[i])\n    if L > 1:\n        votes[i].sort()\nlo = 0\nhi = n // 2 + 5\nwhile lo < hi:\n    mi = lo + (hi-lo)//2\n    if solve(mi,votes,m) > solve(mi+1,votes,m) : lo = mi+1\n    else: hi = mi\nans = 1<<60\nE = 20\nfor i in range(max(0,lo-E),min(lo+E,n+1)):\n    ans = min(ans,solve(i,votes,m))\nprint(ans)\n", "def solve(max_v,votes,m):\n    ans = 0\n    values = []\n    our_v = len(votes[0])\n    for i in range(1,m):\n        L = len(votes[i])\n        if L > max_v:\n            take = L-max_v\n            our_v += take\n            ans += sum(votes[i][:take])\n            if take < L:\n                values.extend(votes[i][take:])\n        else:\n            values.extend(votes[i])\n    values.sort()\n    if our_v <= max_v:\n        needed = max_v + 1 - our_v\n        if needed <= len(values):\n            for i in range(needed):\n                ans += values[i]\n                our_v += 1\n    if our_v <= max_v: return 1<<60\n    return ans\n\nn,m = [int(x) for x in input().split()]\nvotes = [[] for x in range(m)]\n\nfor i in range(n):\n    p,c = (int(x) for x in input().split())\n    p -= 1\n    votes[p].append(c)\n\nfor i in range(m):\n    L = len(votes[i])\n    if L > 1:\n        votes[i].sort()\nlo = 0\nhi = n // 2 + 5\nwhile lo < hi:\n    mi = lo + (hi-lo)//2\n    if solve(mi,votes,m) > solve(mi+1,votes,m) : lo = mi+1\n    else: hi = mi\nans = 1<<60\nE = 20\nfor i in range(max(0,lo-E),min(lo+E,n+1)):\n    ans = min(ans,solve(i,votes,m))\nprint(ans)", "import sys\nfrom math import *\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn map(int, minp().split())\n\nn, m = mints()\nA = [0]*n\nh = [0]*m\nfor i in range(n):\n\ta, b = mints()\n\tA[i] = (b, a-1)\n\th[a-1] += 1\nA.sort()\nr = 1e100\nfor k in range(1, n+1):\n\tb = h[::]\n\tw = [True]*n\n\tc = 0\n\tfor i in range(n):\n\t\tp, id = A[i]\n\t\tif id != 0 and b[id] >= k:\n\t\t\tb[0] += 1\n\t\t\tb[id] -= 1\n\t\t\tc += p\n\t\t\tw[i] = False\n\tfor i in range(n):\n\t\tp, id = A[i]\n\t\tif id != 0 and w[i] and b[0] < k:\n\t\t\tb[0] += 1\n\t\t\tb[id] -= 1\n\t\t\tc += p\n\t\t\tw[i] = False\n\t#print(b,c)\n\tr = min(r, c)\nprint(r)", "import sys\n\ndef pro():\n\treturn sys.stdin.readline().strip()\n\ndef rop():\n\treturn map(int, pro().split())\n\na, s = rop()\nq = [0] * a\nw = [0] * s\nfor i in range(a):\n\tn, p = rop()\n\tq[i] = (p, n-1)\n\tw[n - 1] += 1\nq.sort()\nt = 1e100\nfor k in range(1, a + 1):\n\tp = w[::]\n\tr = [True] * a\n\tm = 0\n\tfor i in range(a):\n\t\tpo, rty = q[i]\n\t\tif rty != 0 and p[rty] >= k:\n\t\t\tp[0] += 1\n\t\t\tp[rty] -= 1\n\t\t\tm += po\n\t\t\tr[i] = False\n\tfor i in range(a):\n\t\tpo, rty = q[i]\n\t\tif rty != 0 and r[i] and p[0] < k:\n\t\t\tp[0] += 1\n\t\t\tp[rty] -= 1\n\t\t\tm += po\n\t\t\tr[i] = False\n\tt = min(t, m)\nprint(t)", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/29/19\n\nLet's iterate over final number of votes for The United Party of Berland.\nWe can see that all opponents should get less votes than our party,\nand our party should get at least our chosen number of votes.\n\nWe can sort all voters by their costs, and solve the problem in two passes.\nFirst, if we need to get \ud835\udc65 votes, we should definitely buy all cheap votes for parties that have at least \ud835\udc65 votes.\nSecond, if we don't have \ud835\udc65 votes yet, we should by the cheapest votes to get \ud835\udc65 votes.\nWe can see that this solution is optimal: consider the optimal answer, and see how many votes The United Party got.\nWe tried such number of votes, and we tried to achieve this number of votes by cheapest way, so we couldn't miss the\noptimal answer. This can be implemented in \ud835\udc42(\ud835\udc5b2log\ud835\udc5b) or even \ud835\udc42(\ud835\udc5blog\ud835\udc5b).\n\n\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\n\n\ndef solve(N, M, A):\n    votes = [[] for _ in range(M+1)]\n    for p, v in A:\n        votes[p].append(v)\n    \n    for p in range(1, M+1):\n        votes[p].sort()\n    \n    own = len(votes[1])\n    votes = votes[2:]\n    votes.sort(reverse=True, key=len)\n    size = [len(v) for v in votes]\n    if not size or own > size[0]:\n        return 0\n    \n    nvotes = len(votes)\n    ans = float('inf')\n    for buy in range((size[0]-own)//2+1, min(N, (N+1) // 2 + 1) + 1):\n        cost = 0\n        target = own + buy\n        done = 0\n        \n        for p in range(nvotes):\n            if size[p] >= target:\n                t = size[p] - target + 1\n                cost += sum(votes[p][: t] or [0])\n                done += t\n            else:\n                break\n        if done >= buy:\n            ans = min(ans, cost)\n        else:\n            more = buy - done\n            q = []\n            for p in range(nvotes):\n                t = max(size[p] - target + 1, 0)\n                q.extend(votes[p][t: t+more])\n            q.sort()\n            cost += sum(q[:more])\n            ans = min(ans, cost)\n        \n    return ans\n\n\nN, M = list(map(int, input().split()))\nA = []\nfor i in range(N):\n    p, v = list(map(int, input().split()))\n    A.append((p, v))\n\nprint(solve(N, M, A))\n    \n\n"]