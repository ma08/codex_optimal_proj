["'''\nsome useful information about memory allocation in operating system\n\n->There are various algorithms which are implemented by the Operating System in order to find out the holes(continuous empy blocks) \\\n  in the linked list(array in this kata) and allocate them to the processes.\n\n->various algorithms used by operating system:\n    1. First Fit Algorithm => First Fit algorithm scans the linked list and whenever it finds the first big enough hole to store a process, it stops scanning and load the process into that hole.\n    \n    2. Next Fit Algorithm  => Next Fit algorithm is similar to First Fit algorithm except the fact that, Next fit scans the linked list from the node where it previously allocated a hole.\n                              ( if i have allocated memory of size 8 in previous turn and initial pointer is 3 \\\n                                then in next turn os will start searching for next empty hole from position 11(3+8=11) )\n    \n    3. Best Fit Algorithm  => The Best Fit algorithm tries to find out the smallest hole possible in the list that can accommodate the size requirement of the process.\n    \n    4. Worst Fit Algorithm => it is opposite of Best Fit Algorithm meaning that \\\n                              (The worst fit algorithm scans the entire list every time and tries to find out the biggest hole in the list which can fulfill the requirement of the process.)\n    \n    The first fit and best fit algorithms are the best algorithm among all\n\nPS. I HAVE IMPLEMENTED Best Fit Algorithm IN JAVASCRIPT AND IMPLEMENTED Next Fit Algorithm in PYTHON :)\n'''\n\n#Next fit Algorithm\nclass MemoryManager:\n    def __init__(self, memory):\n        self.storage = [True] * len(memory)\n        self.previous_allocated_index = 0\n        self.allocated = {}\n        self.data = memory\n\n    def allocate(self, size):\n        find_next = self.process_allocate(self.previous_allocated_index, len(self.data) - size + 1, size)  # start searching from previously allocated block\n        if find_next is not None : return find_next\n        from_start = self.process_allocate(0, self.previous_allocated_index - size + 1, size)              # if we cant find from last index then start searching from starting to previously allocated index\n        if from_start is not None : return from_start\n        raise IndexError('caused by insufficient space in storage')\n    \n    def process_allocate(self, initial, end, size):\n        for i in range(initial, end):  \n            if all(self.storage[i:i + size]):\n                self.previous_allocated_index = i\n                self.storage[i:i + size] = [False] * size\n                self.allocated[i] = i + size\n                return i\n    \n    def release(self, pointer):\n        if self.storage[pointer] : raise RuntimeError('caused by providing incorrect pointer for releasing memory')\n        size = self.allocated[pointer] - pointer\n        self.storage[pointer:size] = [True] * size\n        self.data[pointer:size] = [None] * size\n        del self.allocated[pointer]\n\n    def read(self, pointer):\n        if self.storage[pointer] : raise RuntimeError('caused by providing incorrect pointer for reading memory')\n        return self.data[pointer]\n\n    def write(self, pointer, value):\n        if self.storage[pointer] : raise RuntimeError('caused by providing incorrect pointer for writing memory')\n        self.data[pointer] = value", "class MemoryManager:\n    def __init__(self, memory):\n        \"\"\"\n        @constructor Creates a new memory manager for the provided array.\n        @param {memory} An array to use as the backing memory.\n        \"\"\"\n        self.mem = memory\n        self.blockpointers = [] # A list of pointers to the start of each allocated block\n        self.blocksizes = []    # A list of sizes of each block\n        \n\n    def allocate(self, size):\n        \"\"\"\n        Allocates a block of memory of requested size.\n        @param {number} size - The size of the block to allocate.\n        @returns {number} A pointer which is the index of the first location in the allocated block.\n        @raises If it is not possible to allocate a block of the requested size.\n        \"\"\"\n        if size > len(self.mem):\n            raise Exception(\"Cannot allocate more memory than exists\")\n            \n        #check start of memory\n        if self.blockpointers == [] or (0 not in self.blockpointers and size <= self.blockpointers[0]):\n            self.blockpointers.insert(0,0)\n            self.blocksizes.insert(0,size)\n            return 0\n        \n        #check after every allocated block\n        for i,e in enumerate(self.blocksizes[:-1]):\n            if size <= (self.blockpointers[i+1]-self.blockpointers[i]-e):\n                self.blockpointers.insert(i,self.blockpointers[i] + e)\n                self.blocksizes.insert(i,size)\n                return self.blockpointers[i]\n                \n        #check after last allocated block\n        if size <= (len(self.mem) - self.blockpointers[-1] - self.blocksizes[-1]):\n            self.blockpointers.append(self.blockpointers[-1] + self.blocksizes[-1])\n            self.blocksizes.append(size)\n            return self.blockpointers[-1]\n            \n        raise Exception(\"Cannot allocate more memory than available\")\n                \n            \n    def release(self, pointer):\n        \"\"\"\n        Releases a previously allocated block of memory.\n        @param {number} pointer - The pointer to the block to release.\n        @raises If the pointer does not point to an allocated block.\n        \"\"\"\n        if pointer not in self.blockpointers:\n            raise Exception(\"No memory has been allocated\")\n        \n        index = self.blockpointers.index(pointer)\n        self.blockpointers.pop(index)\n        self.blocksizes.pop(index)\n        return\n\n    def read(self, pointer):\n        \"\"\"\n        Reads the value at the location identified by pointer\n        @param {number} pointer - The location to read.\n        @returns {number} The value at that location.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        if not self.inMemory(pointer):\n            raise Exception(\"No memory has been allocated\")\n        return self.mem[pointer]\n\n\n    def write(self, pointer, value):\n        \"\"\"\n        Writes a value to the location identified by pointer\n        @param {number} pointer - The location to write to.\n        @param {number} value - The value to write.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        if not self.inMemory(pointer):\n            raise Exception(\"No memory has been allocated\")\n        self.mem[pointer] = value\n        \n    def inMemory(self,pointer):    \n        \"\"\"\n        Checks if pointer is in allocated memory\n        @param {number} pointer - The location in memory.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        i = 0\n        while pointer < self.blockpointers[i] + self.blocksizes[i]:\n            if pointer >= self.blockpointers[i] and i < self.blockpointers[i] + self.blocksizes[i]:\n                return True\n            i += 1 \n        return False\n", "import copy\nclass MemoryManager:\n    def __init__(self, memory:list):\n        \"\"\"\n        @constructor Creates a new memory manager for the provided array.\n        @param {memory} An array to use as the backing memory.\n        \"\"\"\n        self.memory = memory\n        self.Firstindex = copy.copy(memory)\n        self.lens = len(self.Firstindex)\n    def allocate(self, size):\n        \"\"\"\n        Allocates a block of memory of requested size.\n        @param {number} size - The size of the block to allocate.\n        @returns {number} A pointer which is the index of the first location in the allocated block.\n        @raises If it is not possible to allocate a block of the requested size.\n        \"\"\"\n        if(size > self.lens):\n            raise Exception(\"allocate size ERROR\")\n        else:\n            # index = 0\n            tempindex = self.Firstindex\n            while(tempindex):\n                if(tempindex.count(None) == 0):\n                    # print(tempindex)\n                    break\n                else:\n                    index = self.Firstindex.index(None)\n                if(index+size > self.lens):\n                    break\n                else:\n                    last = index+size\n                if(self.Firstindex[index:last] == [None]*size):\n                    self.Firstindex[index:last] = [index]*size\n                    return index\n                else:\n                    needlist = self.Firstindex[index:last]\n                    s2 = list(filter(None, needlist))\n                    tempindex = (tempindex[tempindex.index(s2[-1]) + 1:])\n\n            raise Exception(\"allocate END ERROR\")\n    def release(self, pointer:int):\n        \"\"\"\n        Releases a previously allocated block of memory.\n        @param {number} pointer - The pointer to the block to release.\n        @raises If the pointer does not point to an allocated block.\n        \"\"\"\n        if(pointer not in self.Firstindex):\n            raise Exception(\"pointer release ERROR\")\n        counts = self.Firstindex.count(pointer)\n        first = self.Firstindex.index(pointer)\n        last = first +  counts\n        self.memory[first:last] = [None]*(counts)\n        self.Firstindex[first:last] = [None]*(counts)\n\n    def read(self, pointer):\n        \"\"\"\n        Reads the value at the location identified by pointer\n        @param {number} pointer - The location to read.\n        @returns {number} The value at that location.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        if(pointer >= self.lens):\n            raise Exception(\"pointer read ERROR1\")\n        if(self.Firstindex[pointer] == None):\n            raise Exception(\"pointer read ERROR2\")\n        else:\n            return self.memory[pointer]\n    def write(self, pointer, value):\n        \"\"\"\n        Writes a value to the location identified by pointer\n        @param {number} pointer - The location to write to.\n        @param {number} value - The value to write.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        if (pointer >= self.lens):\n            raise Exception()\n        if (self.Firstindex[pointer] == None):\n            raise Exception()\n        else:\n            self.memory[pointer] = value", "class MemoryManager:\n    def __init__(self, memory):\n        \"\"\"\n        @constructor Creates a new memory manager for the provided array.\n        @param {memory} An array to use as the backing memory.\n        \"\"\"\n        self.memory = memory\n        self.allocated = {}\n        self.free_memory = {0:len(memory)}\n\n    def allocate(self, size):\n        \"\"\"\n        Allocates a block of memory of requested size.\n        @param {number} size - The size of the block to allocate.\n        @returns {number} A pointer which is the index of the first location in the allocated block.\n        @raises If it is not possible to allocate a block of the requested size.\n        \"\"\"\n        if size > len(self.memory):\n            raise 'Cannot allocate more memory than exists'\n        for pointer, block_size in list(self.free_memory.items()):\n            if block_size >= size:\n                self.allocated[pointer] = size\n                self.free_memory[pointer+size]= block_size-size\n                del self.free_memory[pointer]\n                return pointer\n        raise 'Cannot allocate more memory than available'\n    \n    def release(self, pointer):\n        \"\"\"\n        Releases a previously allocated block of memory.\n        @param {number} pointer - The pointer to the block to release.\n        @raises If the pointer does not point to an allocated block.\n        \"\"\"\n        self.free_memory[pointer] = self.allocated[pointer]\n        del self.allocated[pointer]\n        for p, b_size in sorted(self.free_memory.items()):\n            if self.free_memory.get(p+b_size):\n                self.free_memory[p] += self.free_memory[p+b_size]\n                del self.free_memory[p+b_size]\n\n    def read(self, pointer):\n        \"\"\"\n        Reads the value at the location identified by pointer\n        @param {number} pointer - The location to read.\n        @returns {number} The value at that location.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        for p, b_size in list(self.allocated.items()):\n            if p <= pointer < p+b_size:\n                return self.memory[pointer]\n        raise 'No memory has been allocated'\n\n    def write(self, pointer, value):\n        \"\"\"\n        Writes a value to the location identified by pointer\n        @param {number} pointer - The location to write to.\n        @param {number} value - The value to write.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        for p, b_size in list(self.allocated.items()):\n            if p <= pointer < p+b_size:\n                self.memory[pointer] = value\n                return None\n        raise 'No memory has been allocated'\n            \n            \n", "class MemoryManager:\n    def __init__(self, memory):\n        \"\"\"\n        @constructor Creates a new memory manager for the provided array.\n        @param {memory} An array to use as the backing memory.\n        \"\"\"\n        self.memory = memory\n        self.available_memory = len(memory)\n        self.pointer_list = {0:0}\n        self.pointer = 0\n\n    def allocate(self, size):\n        \"\"\"\n        Allocates a block of memory of requested size.\n        @param {number} size - The size of the block to allocate.\n        @returns {number} A pointer which is the index of the first location in the allocated block.\n        @raises If it is not possible to allocate a block of the requested size.\n        \"\"\"\n        if self.available_memory >= size:\n            self.pointer_list[self.pointer] = size\n            _pointer = self.pointer\n            self.pointer += size\n            self.available_memory -= size\n            return _pointer\n        else:\n            raise Exception\n\n    def release(self, pointer):\n        \"\"\"\n        Releases a previously allocated block of memory.\n        @param {number} pointer - The pointer to the block to release.\n        @raises If the pointer does not point to an allocated block.\n        \"\"\"\n        free_memory = self.pointer_list[pointer]\n        self.available_memory += free_memory\n#         self.pointer -= free_memory\n        self.pointer = pointer if pointer < self.pointer else self.pointer\n        del self.pointer_list[pointer]\n\n    def read(self, pointer):\n        \"\"\"\n        Reads the value at the location identified by pointer\n        @param {number} pointer - The location to read.\n        @returns {number} The value at that location.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        for p, memory_block in self.pointer_list.items():\n            if pointer <= memory_block:\n                return self.memory[pointer]\n        raise Exception\n\n    def write(self, pointer, value):\n        \"\"\"\n        Writes a value to the location identified by pointer\n        @param {number} pointer - The location to write to.\n        @param {number} value - The value to write.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        for p, memory_block in self.pointer_list.items():\n            if pointer < memory_block:\n                self.memory[pointer] = value\n                return\n        raise Exception", "class MemoryManager:\n    def __init__(self, memory):\n        \"\"\"\n        @constructor Creates a new memory manager for the provided array.\n        @param {memory} An array to use as the backing memory.\n        \"\"\"\n        self._memory = memory\n        self._capacity = len(memory)\n        self._allocated = {i: False for i in range(self._capacity)}\n        self._pointers = dict() # Holds all current valid pointers, index -> size\n\n    def allocate(self, size):\n        \"\"\"\n        Allocates a block of memory of requested size.\n        @param {number} size - The size of the block to allocate.\n        @returns {number} A pointer which is the index of the first location in the allocated block.\n        @raises If it is not possible to allocate a block of the requested size.\n        \"\"\"\n        if size > self._capacity:\n            raise Exception(\"Request exceeds max system capacity\")\n\n        block_start = self._find_empty_block(size)\n        if block_start is None:\n            raise Exception(\"No free block of sufficient size found\")\n\n        self._pointers[block_start] = size\n        for i in range(size):\n            self._allocated[block_start + i] = True\n\n        return block_start\n\n\n    def release(self, pointer):\n        \"\"\"\n        Releases a previously allocated block of memory.\n        @param {number} pointer - The pointer to the block to release.\n        @raises If the pointer does not point to an allocated block.\n        \"\"\"\n        if pointer not in self._pointers:\n            raise Exception(\"Pointer was not allocated\")\n\n        pointer_size = self._pointers[pointer]\n        for i in range(pointer_size):\n            self._allocated[pointer + i] = False\n\n        del self._pointers[pointer]\n\n    def read(self, pointer):\n        \"\"\"\n        Reads the value at the location identified by pointer\n        @param {number} pointer - The location to read.\n        @returns {number} The value at that location.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        if not self._allocated[pointer]:\n            raise Exception(\"Memory space not allocated\")\n\n        return self._memory[pointer]\n\n\n    def write(self, pointer, value):\n        \"\"\"\n        Writes a value to the location identified by pointer\n        @param {number} pointer - The location to write to.\n        @param {number} value - The value to write.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        if not self._allocated[pointer]:\n            raise Exception(\"Cannot write at unallocated memory space\")\n\n        self._memory[pointer] = value\n\n    def _find_empty_block(self, size):\n        \"\"\"\n        Find an free block of size size\n        :param size: Pointer size\n        :return: index of block start\n        \"\"\"\n        contiguous_size = 0\n        index = 0\n        start_index = None\n\n        while index < self._capacity:\n            if index in self._pointers:\n                start_index = None\n                size_to_skip = self._pointers[index]\n                index = index + size_to_skip\n                continue\n            else:\n                if start_index is None:\n                    start_index = index\n\n                contiguous_size += 1\n\n                if contiguous_size == size:\n                    return start_index\n\n                index += 1\n\n        return None", "# https://www.codewars.com/kata/525f4206b73515bffb000b21/train/javascript\n# https://www.codewars.com/kata/51c8e37cee245da6b40000bd/train/python\n# https://www.codewars.com/kata/536e7c7fd38523be14000ca2/train/python\n# https://www.codewars.com/kata/52b7ed099cdc285c300001cd/train/python\n\n# [0, 0, 0, None, None, None, None, None]\n#           \n#  \u0437\u0430\u043d\u044f\u0442\u044b\u0435\n\n# 2\n\nclass MemoryManager:\n    def __init__(self, memory):\n        self.memory = [None] * len(memory)\n        self.disk = memory\n\n    def allocate(self, size):\n      previous = 0\n      for i in range(len(self.memory)):\n        if self.memory[i] == None:\n          previous += 1\n        else:\n          previous = 0\n        if previous == size:\n          start_index = i +1 - size \n          for x in range(start_index, i + 1):\n            self.memory[x] = start_index\n          return start_index\n      raise Exception('No space available')\n\n    \n    def release(self, pointer):\n      if pointer not in self.memory:\n        raise Exception('pointer not in memory')\n      for i in range(len(self.memory)):\n        if self.memory[i] == pointer:\n           self.memory[i] = None\n\n    def read(self, pointer):\n        if self.memory[pointer] == None:\n          raise Exception('No space alocated')\n        return self.disk[pointer]\n    def write(self, pointer, value):\n      if self.memory[pointer] == None:\n        raise Exception('No space alocated')\n      self.disk[pointer] = value\n", "class MemoryManager:\n    def __init__(self, memory):\n        self.memory = [None] * len(memory)\n        self.disk = memory\n\n    def allocate(self, size):\n      previous = 0\n      for i in range(len(self.memory)):\n        if self.memory[i] == None:\n          previous += 1\n        else:\n          previous = 0\n        if previous == size:\n          start_index = i +1 - size \n          for x in range(start_index, i + 1):\n            self.memory[x] = start_index\n          return start_index\n      raise Exception('No space available')\n\n    \n    def release(self, pointer):\n      if pointer not in self.memory:\n        raise Exception('pointer not in memory')\n      for i in range(len(self.memory)):\n        if self.memory[i] == pointer:\n           self.memory[i] = None\n\n    def read(self, pointer):\n        if self.memory[pointer] == None:\n          raise Exception('No space alocated')\n        return self.disk[pointer]\n    def write(self, pointer, value):\n      if self.memory[pointer] == None:\n        raise Exception('No space alocated')\n      self.disk[pointer] = value", "class MemoryManager:\n    \n    def __init__(self, memory):\n        \"\"\"\n        @constructor Creates a new memory manager for the provided array.\n        @param {memory} An array to use as the backing memory.\n        \"\"\"\n        self.memory = memory\n        self.allocationStarts = []\n        self.allocationSizes = []\n\n    def allocate(self, size):\n        \"\"\"\n        Allocates a block of memory of requested size.\n        @param {number} size - The size of the block to allocate.\n        @returns {number} A pointer which is the index of the first location in the allocated block.\n        @raises If it is not possible to allocate a block of the requested size.\n        \"\"\"\n        for i in range(len(self.memory)):\n            ok = True\n            for j in range(i, i + size): # j is the currently checking index\n                if j >= len(self.memory): # it has reached the end\n                    ok = False\n                    break\n                    raise Exception('No allocation available')\n#                 if it's already been allocated\n                for k in range(len(self.allocationStarts)):\n                    if j >= self.allocationStarts[k] and j < self.allocationStarts[k] + self.allocationSizes[k]:\n                        ok = False\n                        break\n            if ok:\n                self.allocationStarts.append(i)\n                self.allocationSizes.append(size)\n#                 print(i)\n                return i\n        \n        # this shouldn't usually be reached because it would stop when j crosses over the length\n        raise Exception('No allocation available')\n        \n        \n    \n    def release(self, pointer):\n        \"\"\"\n        Releases a previously allocated block of memory.\n        @param {number} pointer - The pointer to the block to release.\n        @raises If the pointer does not point to an allocated block.\n        \"\"\"\n        index = self.allocationStarts.index(pointer) # this raises a value error if it's not found\n        del self.allocationStarts[index]\n        del self.allocationSizes[index]\n        \n\n    def read(self, pointer):\n        \"\"\"\n        Reads the value at the location identified by pointer\n        @param {number} pointer - The location to read.\n        @returns {number} The value at that location.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        if len(self.allocationStarts) == 0:\n            raise Exception(\"No memory has been allocated\")\n            \n        for i in range(len(self.allocationStarts)):\n            if not(pointer < self.allocationStarts[i] + self.allocationSizes[i] and pointer >= self.allocationStarts[i]):\n                raise Exception(\"Cannot read from unallocated area\")\n            \n        return self.memory[pointer]\n\n    def write(self, pointer, value):\n        \"\"\"\n        Writes a value to the location identified by pointer\n        @param {number} pointer - The location to write to.\n        @param {number} value - The value to write.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        if len(self.allocationStarts) == 0:\n            raise Exception(\"No memory has been allocated\")\n\n        for i in range(len(self.allocationStarts)):\n            if not(pointer < self.allocationStarts[i] + self.allocationSizes[i] and pointer >= self.allocationStarts[i]):\n                raise Exception(\"Cannot write to unallocated area\")\n        \n        self.memory[pointer] = value\n        \n        \n        \n        \n        \n", "class MemoryManager:\n    def __init__(self, memory):\n        \"\"\"\n        @constructor Creates a new memory manager for the provided array.\n        @param {memory} An array to use as the backing memory.\n        \"\"\"\n        \n        # Key: starting index of block; Value: length of block.\n        self.cache = {}\n        self.memory = memory\n\n    def allocate(self, size):\n        \"\"\"\n        Allocates a block of memory of requested size. Strategy: \n        \n        1) assert that size is less than memory size, \n        2) add if memory is empty,\n        3) allocate memory before the first index,\n        4) in between each block, \n        5) Lastly try after the last index + length\n        6) Throw error\n        \n        @param {number} size - The size of the block to allocate.\n        @returns {number} A pointer which is the index of the first location in the allocated block.\n        @raises If it is not possible to allocate a block of the requested size.\n        \"\"\"\n        \n        if size > len(self.memory):\n            raise Exception(\"Cannot allocate mory memory than exists\")\n        elif len(self.cache.items()) == 0:\n            self.cache[0] = size - 1\n            return 0\n                \n        for start, length in self.cache.items():\n            index = list(self.cache.keys()).index(start)\n            next_block = list(self.cache.items())[index + 1] if index + 1 < len(self.cache.items()) else None\n            if index == 0 and (size - 1) < start:\n                # This is the first block and there is enough space\n                # between the start of the overall memory and the start\n                # of the first block.\n                self.cache[0] = size - 1\n                return 0\n            elif next_block and next_block[0] - (start + length + 1) >= size:\n                # There is a next block, the difference between the \n                # start of the next block and the end of the current block\n                # is large enough to fit the requested block size.\n                self.cache[start + length + 1] = size - 1\n                return start + length + 1\n            elif next_block is None and len(self.memory) - (start + length + 1) >= size:\n                # This is the last block and there is enough space\n                # between the end of overall memory and the end\n                # of the last block.\n                self.cache[start + length + 1] = size - 1\n                return start + length + 1\n            \n        raise Exception(\"Failed to allocate memory\")\n        \n    def release(self, pointer):\n        \"\"\"\n        Releases a previously allocated block of memory.\n        @param {number} pointer - The pointer to the block to release.\n        @raises If the pointer does not point to an allocated block.\n        \"\"\"\n        if pointer not in list(self.cache.keys()):\n            raise Exception(\"Pointer does not point towards allocated block\")\n\n        del self.cache[pointer]\n            \n    def read(self, pointer):\n        \"\"\"\n        Reads the value at the location identified by pointer\n        @param {number} pointer - The location to read.\n        @returns {number} The value at that location.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        \n        if len(self.cache.items()) == 0:\n            raise Exception(\"No memory has been allocated\")\n        \n        for start, length in self.cache.items():\n            if pointer not in range(start, start + length):\n                raise Exception(\"Pointer does not point towards allocated block\")\n        \n        return self.memory[pointer]\n\n    def write(self, pointer, value):\n        \"\"\"\n        Writes a value to the location identified by pointer\n        @param {number} pointer - The location to write to.\n        @param {number} value - The value to write.\n        @raises If pointer is in unallocated memory.\n        \"\"\"\n        \n        if len(self.cache.items()) == 0:\n            raise Exception(\"No memory has been allocated\")\n        \n        for start, length in self.cache.items():\n            if pointer not in range(start, start + length + 1):\n                raise Exception(\"Pointer does not point towards allocated block\")\n\n        self.memory[pointer] = value"]