["class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n        dq = collections.deque([start])\n        visited = set([start])\n        \n        while dq:\n            \n            curr = dq.pop()\n            \n            if arr[curr] == 0:\n                return True\n            \n            if (curr + arr[curr]) not in visited and (curr + arr[curr]) < len(arr):\n                dq.appendleft(curr + arr[curr])\n                visited.add(curr + arr[curr])\n            if (curr - arr[curr]) not in visited and (curr - arr[curr]) >= 0:\n                dq.appendleft(curr - arr[curr])\n                visited.add(curr - arr[curr])\n        \n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        if 0 not in arr:\n            return False\n        visited = set()\n        queue = []\n        queue.append(start)\n        visited.add(start)\n        while len(queue):\n            curr_index = queue.pop()\n            if arr[curr_index] == 0:\n                return True\n            next_index = curr_index + arr[curr_index]\n            if next_index < len(arr) and next_index not in visited:\n                visited.add(next_index)\n                queue.append(next_index)\n            next_index = curr_index - arr[curr_index]\n            if next_index >= 0 and next_index not in visited:\n                visited.add(next_index)\n                queue.append(next_index)\n        return False\n                \n            \n        \n        \n", "import sys\nsys.setrecursionlimit(10**6) \n\nclass Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:  \n        return self.canReach2(arr, start, [])\n        \n    def canReach2(self, arr, start, visited):\n        if start >= len(arr) or start < 0 or start in visited:\n            return False\n        if arr[start] == 0:\n            return True\n\n        visited.append(start)\n        # print(start)\n        res = self.canReach2(arr, start + arr[start], visited) or self.canReach2(arr, start - arr[start], visited)\n        if res is False:\n            visited.pop()\n        return res", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        def jump(arr, start, n, g):\n            g+=1\n            if g>25:\n                return False\n            if start<0 or start>n-1:\n                return False\n            \n            if arr[start] == 0:\n                return True\n            \n            if jump(arr, start+arr[start],n,g):\n                return True\n            else:\n                if jump(arr,start-arr[start],n,g):\n                    return True\n                else:\n                    return False\n            \n        return jump(arr,start,len(arr),0)", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n        memo = {}\n        def dfs(i):\n            if arr[i] == 0:\n                return True\n            if i in memo:\n                return memo[i]\n            memo[i] = False\n            new_i = i + arr[i]\n            if 0 <= new_i < len(arr):\n                if dfs(new_i):\n                    memo[i] = True\n                    return True\n            new_i = i - arr[i]\n            if 0 <= new_i < len(arr):\n                if dfs(new_i):\n                    memo[i] = True\n                    return True\n            \n            return memo[i]\n        \n        return dfs(start)", "class Solution:\n    def canReach(self, jumps: List[int], start: int) -> bool:\n        st = [start]\n        size = len(jumps)\n        \n        while st:\n            idx = st.pop()\n            jump = jumps[idx]\n            # print(jump, st)\n            if jump < 0:\n                continue\n            \n            left, right = idx - jump, idx + jump\n            for i in [left, right]:\n                if 0 <= i < size:\n                    if jumps[i] == 0:\n                        return True\n                    st.append(i)\n            jumps[idx] = -1\n        \n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        if 0 <= start < len(arr) and arr[start] >= 0:\n            if arr[start] == 0:\n                return True\n\n            arr[start] = -arr[start]\n            return self.canReach(arr, start+arr[start]) or self.canReach(arr, start-arr[start])\n\n        return False\n\n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        visited_indices = set()\n        \n        def visit(index: int):\n            if index < 0 or index >= len(arr):\n                return False\n            \n            if index in visited_indices:\n                return False\n            if arr[index] == 0:\n                return True\n            visited_indices.add(index)\n                \n            a = visit(index + arr[index])\n            b = visit(index - arr[index])\n            return a or b\n            \n        \n        return visit(start)", "# 20201002 Jenny sample 200 ms submission\nclass Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        v=set()\n        q = [start]\n        while q:\n            i = q.pop()\n            v.add(i)\n            if arr[i]==0:\n                return True\n            for idx in [(i+arr[i]),i-arr[i]]:\n                if 0<=idx<len(arr) and idx not in v:\n                    q.append(idx)\n        return False", "from collections import defaultdict, deque\n\nclass Solution:\n    \n    def canReach(self, arr: List[int], start: int) -> bool:\n        zero_value = set([])\n        \n        for i in range(len(arr)):\n            if arr[i] == 0:\n                zero_value.add(i)\n        \n        # bfs\n        queue = deque([start])\n        seen = set([])\n        while queue:\n            i = queue.popleft()\n            if i in zero_value:\n                return True\n            seen.add(i)\n\n            up = i + arr[i]\n            if up < len(arr) and up not in seen:\n                queue.append(up)\n            down = i - arr[i]\n            if down >=0 and down not in seen:\n                queue.append(down)\n        \n        return False\n\n#     def canReach(self, arr: List[int], start: int) -> bool:\n#         graph = defaultdict(set)\n#         zero_value = set([])\n        \n#         for i in range(len(arr)):\n#             if arr[i] == 0:\n#                 zero_value.add(i)\n#             else:\n#                 if i + arr[i] < len(arr):\n#                     graph[i].add(i + arr[i])\n#                 if i - arr[i] >=0:\n#                     graph[i].add(i - arr[i]) \n        \n#         # bfs\n#         queue = deque([start])\n#         seen = set([])\n#         while queue:\n#             item = queue.popleft()\n#             if item in zero_value:\n#                 return True\n#             seen.add(item)\n\n#             for nei in graph[item]:\n#                 if nei not in seen:\n#                     queue.append(nei)\n        \n#         return False\n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        visited = []\n        if arr[start] == 0:\n            return True\n        currNodes = [start]\n        \n        while len(visited) < len(arr):\n            temp = []\n            for i in currNodes:\n                visited += [i]\n                candidate1 = i+arr[i]\n                candidate2 = i-arr[i]\n                if candidate1 < len(arr) and candidate1 not in visited:\n                    if arr[candidate1] == 0:\n                        return True\n                    temp += [candidate1]\n                if candidate2 >= 0 and candidate2 not in visited:\n                    if arr[candidate2] == 0:\n                        return True\n                    temp += [candidate2]\n            if len(temp) == 0:\n                break\n            currNodes = temp\n        return False\n                    \n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        q = deque([start])\n        visited = set()\n        while q:\n            curr = q.popleft()\n            if arr[curr]==0: return True\n            if curr not in visited:\n                visited.add(curr)\n                if curr+arr[curr]<len(arr):\n                    q.append(curr+arr[curr])\n                if curr-arr[curr]>=0:\n                    q.append(curr-arr[curr])\n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        size = len(arr)\n        visited = [[0]*2 for _ in range(size)]\n        def trackback(index):\n            if arr[index] == 0:\n                return True\n            if index + arr[index] < size and visited[index][1] == 0:\n                visited[index][1] = 1\n                if trackback(index+arr[index]):\n                    return True\n            if index - arr[index] > -1 and visited[index][0] == 0:\n                visited[index][0] = 1\n                if trackback(index - arr[index]):\n                    return True\n            return False\n        return trackback(start)", "from collections import deque\n\nclass Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n            \n        queue = deque([start])\n        seen = set()\n        \n        while queue:\n            curr_index = queue.popleft()\n            seen.add(curr_index)\n            if arr[curr_index] == 0:\n                return True\n            if curr_index - arr[curr_index] >= 0 and curr_index - arr[curr_index] not in seen:\n                queue.append(curr_index - arr[curr_index])\n            if curr_index + arr[curr_index] < len(arr) and curr_index + arr[curr_index] not in seen:\n                queue.append(curr_index + arr[curr_index])\n                    \n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        if not arr: return False\n        if start<0 or start>=len(arr): return False\n        \n        queue = collections.deque()\n        queue.append(start)\n        visited = set([start])\n        while queue:\n            curr = queue.popleft()\n            if arr[curr] == 0:\n                return True\n            if 0<=curr+arr[curr]<len(arr) and curr+arr[curr] not in visited:\n                queue.append(curr+arr[curr])\n                visited.add(curr+arr[curr])\n            if 0<=curr-arr[curr]<len(arr) and curr-arr[curr] not in visited:\n                queue.append(curr-arr[curr])\n                visited.add(curr-arr[curr])\n                \n        return False\n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        size = len(arr)\n        visited = [0] * size\n        def trackback(index):\n            if arr[index] == 0:\n                return True\n            if index + arr[index] < size and visited[index+arr[index]] == 0:\n                visited[index+arr[index]] = 1\n                if trackback(index+arr[index]):\n                    return True\n            if index - arr[index] > -1 and visited[index-arr[index]] == 0:\n                visited[index - arr[index]] = 1\n                if trackback(index - arr[index]):\n                    return True\n            return False\n        visited[start] = 1\n        return trackback(start)", "from collections import deque\nfrom functools import reduce\nclass Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        if not arr:\n            return False\n        if arr[start] == 0:\n            return True\n\n        def add_edge(nodes, edge):\n            index, jump = edge\n            if jump == 0:\n                nodes[index].append(index)\n                return nodes\n            if (back:=index-jump) >= 0:\n                nodes[index].append(back)\n            if (forw:=index+jump) < len(arr):\n                nodes[index].append(forw)\n            return nodes    \n            \n        edges = reduce(add_edge, enumerate(arr), defaultdict(list))\n        \n        q = deque([start])\n        visited = {start}\n        while q:\n            popped = q.popleft()\n            for n in edges[popped]:\n                if n == popped:\n                    return True\n                if n in visited:\n                    continue\n                visited.add(n) \n                q.append(n)\n        return False     \n        \n        \n", "class Solution:\n    # returns an adjacency list representation of graph\n    def genGraph(self, arr: List[int]) -> List[List[int]]:\n        adjList = [[] for i in range(len(arr))]\n        for i in range(len(arr)):\n            left = i - arr[i]\n            right = i + arr[i]\n            if left >= 0:\n                adjList[i].append(left)\n            if right < len(arr):\n                adjList[i].append(right)\n        return adjList\n    \n    def canReach(self, arr: List[int], start: int) -> bool:\n        graph = self.genGraph(arr)\n        bfsQueue = [start]\n        visited = set()\n        while len(bfsQueue) > 0:\n            node = bfsQueue.pop(0)\n            if arr[node] == 0:\n                return True\n            if node in visited:\n                break\n            visited.add(node)\n            for neighbour in graph[node]:\n                if neighbour not in visited:\n                    bfsQueue.append(neighbour)\n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        graph = defaultdict(list)\n        for i in range(len(arr)):\n            if i+arr[i]< len(arr):\n                graph[i].append(i+arr[i])\n            if i-arr[i]>=0:\n                graph[i].append(i-arr[i])\n        def isReachable( s, d,graph): \n            # Mark all the vertices as not visited \n            visited =[False]*(len(arr)) \n\n            # Create a queue for BFS \n            queue=[] \n\n            # Mark the source node as visited and enqueue it \n            queue.append(s) \n            visited[s] = True\n\n            while queue: \n\n                #Dequeue a vertex from queue  \n                n = queue.pop(0) \n\n                # If this adjacent node is the destination node, \n                # then return true \n                if arr[n] == d: \n                    return True\n\n                #  Else, continue to do BFS \n                for i in graph[n]: \n                    if visited[i] == False: \n                        queue.append(i) \n                        visited[i] = True\n             # If BFS is complete without visited d \n            return False\n        return isReachable(start,0,graph)", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        graph = {}\n        \n        for i in range(len(arr)):\n            graph[i] = []\n            if arr[i] == 0: continue\n            if i + arr[i] < len(arr): graph[i] += [i+arr[i]]\n            if i - arr[i] >= 0: graph[i] += [i-arr[i]]\n                \n        stack = [start]\n        seen = set([start])\n        \n        while len(stack) > 0: \n            curr = stack.pop()\n            seen.add(curr)\n            if len(graph[curr]) == 0 and arr[curr] == 0: return True\n            for adj in graph[curr]: \n                if adj not in seen: stack.append(adj)\n            \n            \n        return False", "class Solution:\n    def recursion(self,arr,index,s):\n        if (index<0) | (index>=len(arr)):\n            return False\n        elif arr[index] == 0:\n            return True\n        elif index in s:\n            return False\n        else:\n            s.add(index)\n            return self.recursion(arr,index+arr[index],s) | self.recursion(arr,index-arr[index],s) \n    def canReach(self, arr: List[int], start: int) -> bool:\n        if 0 not in arr:\n            return False\n        s = set()\n        return self.recursion(arr,start,s)\n        \n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        graph = {}\n        \n        for i in range(len(arr)):\n            graph[i] = []\n            if arr[i] == 0: continue\n            if i + arr[i] < len(arr): graph[i] += [i+arr[i]]\n            if i - arr[i] >= 0: graph[i] += [i-arr[i]]\n                \n        stack = [start]\n        seen = set([start])\n        \n        while len(stack) > 0: \n            curr = stack.pop()\n            seen.add(curr)\n            if arr[curr] == 0: return True\n            for adj in graph[curr]: \n                if adj not in seen: stack.append(adj)\n            \n            \n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n        seen = set()\n        \n        def steps(i):\n            for next in [i + arr[i], i - arr[i]]:\n                if next >= 0 and next < len(arr) and next not in seen:\n                    seen.add(next)\n                    yield next\n                    \n        q = collections.deque()\n        \n        q.append(start)\n        \n        while q:\n            c = q.popleft()\n            for next in steps(c):\n                if arr[next] == 0:\n                    return True\n                q.append(next)\n        return False\n                \n        \n        \n", "class Solution:\n    \n    def dfs(self, graph, arr, root):\n        stack = []\n        stack.append(root)\n        visited = set()\n        while len(stack) > 0:\n            current = stack.pop()\n            if current in visited:\n                continue\n            visited.add(current)\n            if arr[current] == 0:\n                return True\n            # check the neighbors\n            for n in graph.get(current, []):\n                stack.append(n)\n        return False\n    \n    def canReach(self, arr: List[int], start: int) -> bool:\n        graph = dict()\n        for i in range(len(arr)):\n            graph[i] = graph.get(i, [])\n            if 0 <= i + arr[i] < len(arr):\n                graph[i].append(i + arr[i])\n            if 0 <= i - arr[i] < len(arr):\n                graph[i].append(i - arr[i])\n        return self.dfs(graph, arr, start)\n\nif False:\n    print((Solution().canReach([4,2,3,0,3,1,2], 0))) # true\n    print((Solution().canReach([3,0,2,1,2], 2))) # false\n    \n", "class Solution:\n    def canReach(self, jumps: List[int], start: int) -> bool:\n        size = len(jumps)\n        reach = [[] for i in range(size)]\n        \n        for pos, jump in enumerate(jumps):\n            l, r = pos - jump, pos + jump\n            if l >= 0 and pos not in reach[l]:\n                reach[l].append(pos)\n            if r < size and pos not in reach[r]:\n                reach[r].append(pos)\n            \n        def do(idx, path=set()):\n            if idx == start:\n                return True\n            for prev in reach[idx]:\n                if prev not in path and do(prev, path | {prev}):\n                    return True\n            return False\n        # print(reach)\n        for p, n in enumerate(jumps):\n            if n == 0 and do(p):\n                return True\n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        n = len(arr)\n        visited = [False] * n\n        def dfs(index:int)->bool:\n            if index < 0 or index >= n:\n                return False\n            if visited[index]:\n                return False\n            if arr[index] == 0:\n                return True\n            visited[index] = True\n            left = index - arr[index]\n            if dfs(left):\n                return True\n            right = index + arr[index]\n            return dfs(right)\n        return dfs(start)\n        return ans\n", "from collections import defaultdict, deque\n\nclass Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        graph = defaultdict(set)\n        zero_value = set([])\n        \n        for i in range(len(arr)):\n            if arr[i] == 0:\n                zero_value.add(i)\n            else:\n                if i + arr[i] < len(arr):\n                    graph[i].add(i + arr[i])\n                if i - arr[i] >=0:\n                    graph[i].add(i - arr[i]) \n        \n        # bfs\n        queue = deque([start])\n        seen = set([])\n        while queue:\n            for i in range(len(queue)):\n                item = queue.popleft()\n                if item in zero_value:\n                    return True\n                seen.add(item)\n                \n                for nei in graph[item]:\n                    if nei not in seen:\n                        queue.append(nei)\n        \n        return False\n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        if 0 <= start < len(arr) and arr[start] >= 0:\n            if arr[start] == 0:\n                return True\n\n            arr[start] = -arr[start]\n            return self.canReach(arr, start+arr[start]) or self.canReach(arr, start-arr[start])\n\n        return False\n", "from collections import defaultdict, deque\n\nclass Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        graph = defaultdict(set)\n        zero_value = set([])\n        \n        for i in range(len(arr)):\n            if arr[i] == 0:\n                zero_value.add(i)\n            else:\n                if i + arr[i] < len(arr):\n                    graph[i].add(i + arr[i])\n                if i - arr[i] >=0:\n                    graph[i].add(i - arr[i]) \n        \n        # bfs\n        queue = deque([start])\n        seen = set([])\n        while queue:\n            item = queue.popleft()\n            if item in zero_value:\n                return True\n            seen.add(item)\n\n            for nei in graph[item]:\n                if nei not in seen:\n                    queue.append(nei)\n        \n        return False\n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        n = len(arr)\n        graph = [set() for _ in range(n)]\n        for i, j in enumerate(arr):\n            if i+j < n:\n                graph[i].add(i+j)\n            if i-j >= 0:\n                graph[i].add(i-j)\n                \n        self.graph = graph        \n        self.visited = set()\n        return self.dfs(start)\n        \n    def dfs(self, i):\n        if i in self.visited:\n            return False\n        self.visited.add(i)\n        if i in self.graph[i]:\n            return True\n        else:\n            for j in self.graph[i]:\n                if self.dfs(j):\n                    return True", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        def solve(arr, i, done):\n            if arr[i] == 0:\n                return True\n            elif i in done:\n                return False\n            else:\n                a,b = False, False\n                if 0 <= i + arr[i] < len(arr):\n                    done[i] = 1\n                    a = solve(arr, i + arr[i], done)\n                if 0 <= i - arr[i] < len(arr):\n                    done[i] = 1\n                    b = solve(arr, i - arr[i], done)\n                return a or b\n        return solve(arr, start, {})", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        n = len(arr)\n        q = [start]\n        \n        while q:\n            node = q.pop(0)\n            if arr[node] == 0:\n                return True\n            if arr[node] < 0:\n                continue\n            for i in [node+arr[node], node-arr[node]]:\n                if 0 <= i < n:\n                    q.append(i)\n            arr[node] = -1\n        \n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        seen = set()\n        \n        def canReachRec(ix):\n            if ix < 0 or ix >= len(arr):\n                return False\n            if ix in seen:\n                return False\n            if arr[ix] == 0:\n                return True\n\n            seen.add(ix)\n            if canReachRec(ix + arr[ix]):\n                return True\n            if canReachRec(ix - arr[ix]):\n                return True\n            return False\n        return canReachRec(start)\n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        adj={i:[] for i in range(len(arr))}\n        target={}\n        \n        for idx,jump in enumerate(arr):\n            choice_a=idx-jump\n            choice_b=idx+jump\n            if choice_a>=0 and choice_a<len(arr):\n                adj[idx].append(choice_a)\n            if choice_b>0 and choice_b<len(arr):\n                adj[idx].append(choice_b)\n            if jump==0:\n                target[idx]=True\n            else:\n                target[idx]=False\n        q=deque([start])\n        visited=[]\n        while q:\n            cur=q[0]\n            q.popleft()\n            visited.append(cur)\n            for neighbor in adj[cur]:\n                if target[neighbor]:\n                    return True\n                if neighbor not in visited:\n                    q.append(neighbor)\n        return False\n", "class Solution:\n    def canReach1(self, arr: List[int], start: int) -> bool:\n        # recursive helper function\n        # recurse both left, right from i-th position\n        # invert arr value to check only once\n        # O(N) time, space in recursive stack\n\n        def rcrs(i):\n            if (0 <= i < len(arr)) and (arr[i] >= 0):\n                if arr[i] == 0:\n                    return True\n\n                arr[i] = -arr[i]\n                left_able = rcrs(i + arr[i])\n                right_able = rcrs(i - arr[i])\n                return left_able or right_able\n            return False\n\n        # recursive call\n        return rcrs(start)\n\n    def canReach(self, arr: List[int], start: int) -> bool:\n        # try iteratively: add values to deque w/ value inversion\n        # O(N) time, O(N) space\n\n        q = collections.deque([start])\n\n        while q:\n            i = q.popleft()\n\n            if (0 <= i < len(arr)) and arr[i] >= 0:\n                if arr[i] == 0:\n                    return True\n\n                arr[i] = -arr[i]\n                q.append(i+arr[i]) # left\n                q.append(i-arr[i]) # right\n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n        visited = set()\n        \n        def helper(i):\n            if i in visited:\n                return False\n            \n            if arr[i] == 0:\n                return True\n            \n            visited.add(i)\n            \n            left = helper(i-arr[i]) if i - arr[i] >= 0 else False\n            right = helper(i + arr[i]) if i + arr[i] < len(arr) else False\n            return left or right\n        \n        return helper(start)", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        seen=set()\n        return self.dfs(arr,start,seen)\n    \n    def dfs(self,arr,idx,seen):\n        if idx>=len(arr) or (idx<0) or (idx in seen):\n            return False\n        if arr[idx]==0:\n            return True\n        seen.add(idx)\n        return self.dfs(arr,idx-arr[idx],seen) or self.dfs(arr,idx+arr[idx],seen)", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n        nums = arr\n        update = True\n        while update:\n            update = False\n            for i in range(len(nums)):\n                j = nums[i]\n                if nums[i] == 0:\n                    continue\n                \n                if i-j>=0 and nums[i-j]==0:\n                    nums[i] = 0\n                    update = True\n                    \n            for i in reversed(list(range(len(nums)))):\n                j = nums[i]\n                if nums[i] == 0:\n                    continue\n                \n                if i+j<len(nums) and nums[i+j]==0:\n                    nums[i] = 0\n                    update = True\n        \n        return nums[start] == 0\n                    \n", "from functools import lru_cache\n\nclass Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        def dfs(idx, visited):\n            if arr[idx] == 0:\n                return True\n            left_idx = idx-arr[idx]\n            if left_idx >= 0 and left_idx not in visited:\n                visited.add(left_idx)\n                res = dfs(left_idx, visited)\n                if res:\n                    return True            \n            right_idx = idx+arr[idx]\n            if right_idx < len(arr) and right_idx not in visited:\n                visited.add(right_idx)\n                res = dfs(right_idx, visited)\n                if res:\n                    return True\n            return False\n        \n        return dfs(start, set([start]))\n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        q = collections.deque()\n        visited = set()\n        q.append(start)\n        visited.add(start)\n        while len(q) > 0:\n            curr_idx = q.popleft()\n            if arr[curr_idx] == 0:\n                return True\n            for next_idx in [curr_idx + arr[curr_idx], curr_idx - arr[curr_idx]]:\n                if 0 <= next_idx < len(arr):\n                    if next_idx not in visited:\n                        q.append(next_idx)\n                        visited.add(next_idx)\n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        q = deque([start])\n        visited = set()\n        N = len(arr)\n        while q:\n            cur = q.popleft()\n            if cur in visited: continue\n            visited.add(cur)\n            if arr[cur] == 0: return True\n            if cur + arr[cur] < N:\n                q.append(cur + arr[cur])\n            if cur - arr[cur] >= 0:\n                q.append(cur - arr[cur])\n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n#         n = len(arr);\n        \n#         visited = [False for _ in range(n)];\n        \n#         def helper(i):\n#             if  i < 0 or i > n-1 or visited[i]:\n#                 return False;\n#             if arr[i] == 0:\n#                 return True;\n            \n#             visited[i] = True;\n            \n#             right = helper(i+arr[i]);\n#             left  = helper(i-arr[i]);\n            \n#             visited[i] = False;\n            \n#             if right or left:\n#                 return True;\n#             return False;\n        \n#         return helper(start);\n\n        if not arr:\n            return False;\n        if arr[start] == 0:\n            return True;\n        queue = [start];\n        n = len(arr);\n        visited = [False for _ in range(n)];\n        \n        while queue:\n            index = queue.pop(0);\n            visited[index] = True;\n            newIndices = [index - arr[index], index + arr[index]];\n            \n            for i in newIndices:\n                if i>=0 and i<n and not visited[i]:\n                    queue.append(i);\n                    if arr[i] == 0:\n                        return True;\n        return False;\n            \n            \n        \n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        visited = set()\n        q = [start]\n        while q:\n            q = [i for x in q for i in (x - arr[x], x + arr[x]) if 0 <= i < len(arr) and i not in visited]\n            for i in q:\n                if arr[i] == 0: return True\n                visited.add(i)\n        return False", "class Solution:\n    visited = set()\n    def canReach(self, arr: List[int], start: int) -> bool:\n        visited = set()\n        return self.backtrack(arr, start, visited)\n    \n    def backtrack(self, arr, index, visited):\n        if index < 0 or index >= len(arr) or arr[index] < 0:\n            return False\n        if arr[index] == 0:\n            return True\n        temp = arr[index]\n        arr[index] *= -1\n        return self.backtrack(arr, index + temp, visited) or self.backtrack(arr, index - temp, visited)", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n#         n = len(arr);\n        \n#         visited = [False for _ in range(n)];\n        \n#         def helper(i):\n#             if  i < 0 or i > n-1 or visited[i]:\n#                 return False;\n#             if arr[i] == 0:\n#                 return True;\n            \n#             visited[i] = True;\n            \n#             right = helper(i+arr[i]);\n#             left  = helper(i-arr[i]);\n            \n#             visited[i] = False;\n            \n#             if right or left:\n#                 return True;\n#             return False;\n        \n#         return helper(start);\n\n\n        \n\n        n = len(arr);\n        if n==0:\n            return False;\n        if arr[start] == 0:\n            return True;\n        queue = [start];\n        visited = [False for _ in range(n)];\n        \n        while queue:\n            index = queue.pop(0);\n            visited[index] = True;\n            \n            right = index + arr[index];\n            left = index - arr[index];\n            \n            if right < n and not visited[right]:\n                if arr[right] == 0:\n                    return True;\n                queue.append(right);\n            \n            if left >=0 and not visited[left]:\n                if arr[left] == 0:\n                    return True;\n                queue.append(left);\n            \n        return False;\n        \n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        from collections import defaultdict\n        graph=defaultdict(list)\n        length=len(arr)\n        for i in range(len(arr)):\n            if arr[i]!=0:\n                if i-arr[i]>=0:\n                    graph[i].append(i-arr[i])\n                if i+arr[i]<length:\n                    graph[i].append(i+arr[i])\n        zeroindex=[i for i,j in enumerate(arr) if j==0]\n        visited=[]\n        print(graph,zeroindex)\n        def dfs(s,visited):\n            if s in zeroindex:\n                return True\n            if s in visited:\n                return False\n            visited.append(s)\n            for i in graph[s]:\n                if dfs(i,visited):\n                    return True\n            return False\n        return dfs(start,visited)", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n        def dfs(start, count):\n            if start < 0 or start >=len(arr):\n                return False\n            if count >= len(arr):\n                return False\n            if not arr[start]:\n                return True\n            return dfs(arr[start]+start, count+1) or dfs(start-arr[start], count+1)\n        return dfs(start, 0)", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        n = len(arr)\n        graph = collections.defaultdict(set)\n        for i in range(n):\n            if i+arr[i]<n:\n                graph[i].add(i+arr[i])\n            if i-arr[i]>=0:\n                graph[i].add(i-arr[i])\n        end = set([i for i in range(n) if arr[i]==0])\n        \n        q = [start]\n        visited = set([start])\n        \n        while q:\n            x = q.pop(0)\n            for i in graph[x]:\n                if i in end:\n                    return True\n                if i not in visited:\n                    visited.add(i)\n                    q.append(i)\n                    \n        return False\n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        \n        visited = set()\n        def helper(visited, arr, start):\n            if start < 0 or start >= len(arr) or start in visited:\n                return False\n            visited.add(start)\n            if arr[start] == 0:\n                return True\n            return helper(visited, arr, start-arr[start]) or helper(visited, arr,start+arr[start])\n        return helper(visited, arr, start)\n", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        n=len(arr)\n        q=[start]\n        while q:\n            node=q.pop(0)\n            #print(arr[node])\n            if arr[node]==0:\n                return True\n            if arr[node]<0:\n                continue\n            for i in [node+arr[node],node-arr[node]]:\n                #print(i)\n                if i>=0 and i<n:\n                    q.append(i)\n            #print(q)\n            arr[node]=-arr[node]\n            #print(arr)\n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        # dfs\n        if 0 <= start < len(arr):\n            return self.dfs(arr, start, set())\n        return False\n    \n    def dfs(self, arr, start, visited):\n        if arr[start] == 0:\n            return True\n        visited.add(start)\n        if 0 <= start + arr[start] < len(arr) and start + arr[start] not in visited:\n            if self.dfs(arr, start + arr[start], visited):\n                return True\n        if 0 <= start - arr[start] < len(arr) and start - arr[start] not in visited:\n            if self.dfs(arr, start - arr[start], visited):\n                return True\n        return False", "class Solution:\n    def canReach(self, arr: List[int], start: int) -> bool:\n        # array to add to check values and to pop current values\n        to_check = [start]\n        \n        \n        while len(to_check) > 0:\n            current = to_check.pop(0)\n            if arr[current] == 0:\n                return True\n            if arr[current] < 0:\n                continue\n            \n            for i in [current+arr[current], current-arr[current]]:\n                if 0 <= i < len(arr):\n                    to_check.append(i)\n                    \n            arr[current] = -1\n        \n        return False\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        # change = 1\n        # prevchange = 0\n        # n = len(arr)\n        # if arr[start] == 0:\n        #     return True\n        # while change != prevchange:\n        #     prevchange = change\n        #     for index, val in enumerate(arr):\n        #         print(arr)\n        #         # if val is 0 then skip\n        #         if val != 0:\n        #         # check the jump is within bounds\n        #             if index + val < n and arr[index + val] == 0 and index != start:\n        #                 arr[index] = 0\n        #                 change += 1\n        #             elif index - val > -1 and arr[index - val] == 0 and index != start:\n        #                 arr[index] = 0\n        #                 change += 1\n        #             elif index + val < n and arr[index + val] == 0 and index == start:\n        #                 return True\n        #             elif index - val > -1 and arr[index - val] == 0 and index == start:\n        #                 return True\n        # return False\n                        \n"]