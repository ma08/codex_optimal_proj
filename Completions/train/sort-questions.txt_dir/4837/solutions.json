["RANGES = {\n    'minute': (0, 59),\n    'hour': (0, 23),\n    'day of month': (1, 31),\n    'month': (1, 12),\n    'day of week': (0, 6),\n}\n\nALIASES = {\n    'month': ' JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC'.split(' '),\n    'day of week': 'SUN MON TUE WED THU FRI SAT'.split(),\n}\n\ndef get_alias(field, value):\n    try:\n        return ALIASES[field].index(value)\n    except:\n        return int(value)\n\ndef parse(crontab):\n    def parse_field(field, value):\n        values = set()\n        for part in value.split(','):\n            part, *end = part.split('/')\n            step = int(end[0]) if end else 1\n            if part == '*':\n                start, stop = RANGES[field]\n            else:\n                part, *end = part.split('-')\n                start = get_alias(field, part)\n                stop = get_alias(field, end[0]) if end else start\n            values.update(range(start, stop + 1, step))\n        return ' '.join(map(str, sorted(values)))\n    return '\\n'.join(f'{field:<15}{parse_field(field, value)}'\n                     for field, value in zip(RANGES, crontab.split()))", "from itertools import chain\nimport re\n\nMONTHS_DAYS = list(map(str.split, ('JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC', 'SUN MON TUE WED THU FRI SAT')))\nREPL_NAMES  = {s: str(i) for i,s in chain(*( enumerate(lst,detla) for lst,detla in zip(MONTHS_DAYS, (1,0))))}\nRANGES      = (('minute',0,59), ('hour',0,23), ('day of month',1,31), ('month',1,12), ('day of week',0,6))\n\ndef parse(s):\n    s = re.sub(r'[A-Z]+', lambda m: REPL_NAMES[m[0]], s)\n    return '\\n'.join( parsePart(part,name,(a,b)) for part,(name,a,b) in zip(s.split(), RANGES))\n\ndef parsePart(part, name, rng):\n    out = [] \n    for s in part.split(','):\n        i,j       = list(map(s.find,'-/'))\n        step,j    = (1,len(s)) if j==-1 else (int(s[j+1:]),j)\n        start,end = rng if s[0]=='*' else (int(s),)*2 if i==-1 else list(map(int, (s[:i],s[i+1:j])))\n        out.extend(list(range(start, end+1, step)))\n        \n    return f\"{name:15}{ ' '.join(map(str, sorted(out))) }\"\n", "import re\n\nD = {0:[0,59],1:[0,23],2:[1,31],3:[1,12],4:[0,6]}\nREGEXES = ['(\\d+)-(\\d+)','(\\d+)-(\\d+)/(\\d+)','(\\d+)']\nFORMAT = '''\\\nminute         {}\nhour           {}\nday of month   {}\nmonth          {}\nday of week    {}\\\n'''\nDAYS = 'SUN MON TUE WED THU FRI SAT'.split()\nMONTHS = 'X JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DES'.split()\n\ndef parse(ct):\n        ct = re.sub(r'{}'.format('|'.join(DAYS)),lambda x:str(DAYS.index(x.group())), ct)\n        ct = re.sub(r'{}'.format('|'.join(MONTHS)),lambda x:str(MONTHS.index(x.group())),ct)\n        ct = [re.sub(r'\\*',lambda _:'-'.join([str(k) for k in D[i]]),j) for i,j in enumerate(ct.split())]\n        parser = []\n        for i,j in enumerate(ct):\n              sep = []\n              for k in j.split(','):\n                  a,b,c = [re.search('^'+r+'$',k) for r in '(\\d+)-(\\d+) (\\d+)-(\\d+)/(\\d+) (\\d+)'.split()]\n                  if c : sep.append(int(k))\n                  elif b:\n                      x,y,z = map(int,b.groups())\n                      sep.extend(list(range(x,y+1,z)))\n                  elif a:\n                      x,y = map(int,a.groups())\n                      sep.extend(list(range(x,y+1)))\n              parser.append(' '.join([str(i) for i in sorted(sep)]))\n        return FORMAT.format(*parser)", "import re\n\nWILDCARDS = {\n    'minute': {\n        'range': list(range(60))\n    },\n    'hour': {\n        'range': list(range(24))\n    },\n    'day-of-month': {\n        'range': list(range(1, 32))\n    },\n    'month': {\n        'range': list(range(1, 13)),\n        'names': {\n            'JAN': 1,\n            'FEB': 2,\n            'MAR': 3,\n            'APR': 4,\n            'MAY': 5,\n            'JUN': 6,\n            'JUL': 7,\n            'AUG': 8,\n            'SEP': 9,\n            'OCT': 10,\n            'NOV': 11,\n            'DEC': 12\n        }\n    },\n    'day-of-week': {\n        'range': list(range(7)),\n        'names': {'MON': 1, 'TUE': 2, 'WED': 3, 'THU': 4, 'FRI': 5, 'SAT': 6, 'SUN': 0}\n    }\n}\n\ndef parse_interval(interval, type):\n    rng = WILDCARDS[type]['range']\n    substitutes = WILDCARDS[type].get('names', {})\n\n    for k, v in substitutes.items():\n        interval = interval.replace(k, str(v))\n\n    interval = interval.replace('*', '{}-{}'.format(rng[0], rng[-1]))\n    return range_parser(interval)\n\ndef parse(crontab):\n    (minute, hour, day_month, month, day_week) = crontab.split(' ')\n\n    out = [\n        ['minute', parse_interval(minute, 'minute')], \n        ['hour', parse_interval(hour, 'hour')], \n        ['day of month', parse_interval(day_month, 'day-of-month')], \n        ['month', parse_interval(month, 'month')], \n        ['day of week', parse_interval(day_week, 'day-of-week')]\n    ]\n\n    return format(out)\n\n\ndef format(cron_conf):\n    \"\"\"Formats results\"\"\"\n    out = []\n    for item in cron_conf:\n        out += [\"{}{}\".format(str.ljust(item[0], 15), ' '.join(map(str, item[1])))]\n    return '\\n'.join(out)\n\ndef range_parser(range_spec):\n    \"\"\"Expands the range range_spec into list\"\"\"\n    range_list = []\n    ranges = re.split(r'\\s?,\\s?', range_spec)\n\n    for rng in ranges:\n        out = parse_range(rng)\n        range_list += out\n\n    return sorted(range_list)\n\ndef parse_range(rng):\n    spec = re.split(r'-|/', rng)\n    spec = [int(s) for s in spec]\n\n    if len(spec) == 1:\n        return [spec[0]]\n    elif len(spec) == 2:\n        return list(range(spec[0], spec[1] + 1))\n    elif len(spec) == 3:\n        return list(range(spec[0], spec[1] + 1, spec[2]))", "def parse(crontab):\n    \"\"\"\n            \"minute         1\",\n            \"hour           2\",\n            \"day of month   3\",\n            \"month          4\",\n            \"day of week    5\",\n    \"\"\"\n    \n    fields = crontab.split()\n    \n    minutes = interpret_minutes(fields[0])\n    hours = interpret_hours(fields[1])\n    days_m = interpret_days_month(fields[2])\n    months = interpret_months(fields[3])\n    days_w = interpret_days_week(fields[4])\n    \n    result  = \"minute         \" + \" \".join([str(v) for v in sorted(list(minutes))]) + \"\\n\"\n    result += \"hour           \" + \" \".join([str(v) for v in sorted(list(hours))]) + \"\\n\"\n    result += \"day of month   \" + \" \".join([str(v) for v in sorted(list(days_m))]) + \"\\n\"\n    result += \"month          \" + \" \".join([str(v) for v in sorted(list(months))]) + \"\\n\"\n    result += \"day of week    \" + \" \".join([str(v) for v in sorted(list(days_w))])\n    \n    return result\n    \ndef interpret_minutes(cr_minutes):\n\n    def interpret_minute(cr_field):            \n        step = \"1\"   \n        value = cr_field\n        if cr_field.find('/') != -1:\n            (value, step) = cr_field.split(\"/\")\n            \n        low_min = 0\n        hig_min = 59\n        if value == \"*\":\n            low_min = 0\n            hig_min = 59\n        elif value.find('-') != -1:\n            (lm, hm) = value.split(\"-\")\n            low_min = int(lm)\n            hig_min = int(hm)\n        else:\n            low_min = hig_min = int(value)\n            \n        return set(range(low_min, hig_min+1, int(step)))\n        \n    result_set = set()\n    for request in cr_minutes.split(\",\"):\n        new_set = interpret_minute(request)\n        result_set.update(new_set)\n        \n    return result_set   \n        \n\ndef interpret_hours(cr_hours):\n    def interpret_hour(cr_field):            \n        step = \"1\"   \n        value = cr_field\n        if cr_field.find('/') != -1:\n            (value, step) = cr_field.split(\"/\")\n            \n        low_min = 0\n        hig_min = 23\n        if value == \"*\":\n            low_min = 0\n            hig_min = 23\n        elif value.find('-') != -1:\n            (lm, hm) = value.split(\"-\")\n            low_min = int(lm)\n            hig_min = int(hm)\n        else:\n            low_min = hig_min = int(value)\n            \n        return set(range(low_min, hig_min+1, int(step)))\n    \n    result_set = set()\n    for request in cr_hours.split(\",\"):\n        new_set = interpret_hour(request)\n        result_set.update(new_set)\n        \n    return result_set   \n\n\ndef interpret_days_month(cr_days_m):\n    def interpret_day_month(cr_field):            \n        step = \"1\"   \n        value = cr_field\n        if cr_field.find('/') != -1:\n            (value, step) = cr_field.split(\"/\")\n            \n        low_min = 1\n        hig_min = 31\n        if value == \"*\":\n            low_min = 1\n            hig_min = 31\n        elif value.find('-') != -1:\n            (lm, hm) = value.split(\"-\")\n            low_min = int(lm)\n            hig_min = int(hm)\n        else:\n            low_min = hig_min = int(value)\n            \n        return set(range(low_min, hig_min+1, int(step)))\n    \n    result_set = set()\n    for request in cr_days_m.split(\",\"):\n        new_set = interpret_day_month(request)\n        result_set.update(new_set)\n        \n    return result_set   \n\n    \ndef interpret_months(cr_months):\n    def interpret_month(cr_field):\n        names_to_numbers = {\n            'JAN': \"1\", 'FEB': \"2\", 'MAR': \"3\", 'APR': \"4\", 'MAY': \"5\",\n            'JUN': \"6\", 'JUL': \"7\", 'AUG': \"8\", 'SEP': \"9\", 'OCT': \"10\",\n            'NOV': \"11\", 'DEC': \"12\"\n        }\n        \n        step = \"1\"   \n        value = cr_field\n        if cr_field.find('/') != -1:\n            (value, step) = cr_field.split(\"/\")\n            \n        low_min = 1\n        hig_min = 12\n        if value == \"*\":\n            low_min = 1\n            hig_min = 12\n        elif value.find('-') != -1:\n            (lm, hm) = value.split(\"-\")\n            low_min = int(names_to_numbers.get(lm, lm))\n            hig_min = int(names_to_numbers.get(hm, hm))\n        else:\n            low_min = hig_min = int(names_to_numbers.get(value, value))\n            \n        return set(range(low_min, hig_min+1, int(step)))\n    \n    result_set = set()\n    for request in cr_months.split(\",\"):\n        new_set = interpret_month(request)\n        result_set.update(new_set)\n        \n    return result_set   \n\ndef interpret_days_week(cr_days_w):\n    def interpret_day_week(cr_field):\n        names_to_numbers = {\n            'SUN': \"0\", 'MON': \"1\", 'TUE': \"2\", 'WED': \"3\",\n            'THU': \"4\", 'FRI': \"5\", 'SAT': \"6\"\n        }\n        \n        step = \"1\"   \n        value = cr_field\n        if cr_field.find('/') != -1:\n            (value, step) = cr_field.split(\"/\")\n            \n        low_min = 0\n        hig_min = 6\n        if value == \"*\":\n            low_min = 0\n            hig_min = 6\n        elif value.find('-') != -1:\n            (lm, hm) = value.split(\"-\")\n            low_min = int(names_to_numbers.get(lm, lm))\n            hig_min = int(names_to_numbers.get(hm, hm))\n        else:\n            low_min = hig_min = int(names_to_numbers.get(value, value))\n            \n        return set(range(low_min, hig_min+1, int(step)))\n    \n    result_set = set()\n    for request in cr_days_w.split(\",\"):\n        new_set = interpret_day_week(request)\n        result_set.update(new_set)\n        \n    return result_set   \n", "from re import sub\n\ndef parse(crontab):\n    \n    ranges = {\n        0: ['minute', list(range(60))], \n        1: ['hour', list(range(24))], \n        2: ['day of month', list(range(1, 32))], \n        3: ['month', list(range(1, 13))], \n        4: ['day of week', list(range(7))]\n    }\n    trans = {\n        3: '# JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC'.split(' '), \n        4: 'SUN MON TUE WED THU FRI SAT SUN'.split(' ')\n    }\n    \n    tabs = crontab.split(' ')\n    res = []\n    \n    for i, tab in enumerate(tabs): \n        \n        lb, lst = ranges[i]\n        tokens = tab.split(',')\n        \n        local = []\n        for s in tokens: \n            if sub(r'[^A-Z]', '', s):\n                t_arr = trans[i]\n                for t in t_arr:\n                    if t in s: s = s.replace(t, str(t_arr.index(t)))\n                    \n            local += choose(lst, s)\n        \n        res.append('{}{}'.format(lb.ljust(15), ' '.join(str(v) for v in sorted(local))))\n    \n    return '\\n'.join(res)\n\ndef choose(lst, s): \n    res = []\n    \n    if s == '*': return lst\n    if s.isdigit(): return [i for i in lst if int(s) == i]\n    \n    if '-' in s and '/' not in s: \n        s, e = [int(v) for v in s.split('-')]\n        return [v for v in lst if s <= v <= e]\n    \n    if '/' in s: \n        cr, step = s.split('/')        \n        step = int(step)\n        return choose(lst, cr)[0::step]        \n    \n    return []", "D = {'JAN':1, 'FEB':2, 'MAR':3, 'APR':4, 'MAY':5, 'JUN':6, 'JUL':7, 'AUG':8, 'SEP':9, 'OCT':10, 'NOV':11, 'DEC':12,\n     'SUN':0, 'MON':1, 'TUE':2, 'WED':3, 'THU':4, 'FRI':5, 'SAT':6}\n\ndef read(s, mini, maxi):\n    res = set()\n    for x in s.split(','):\n        y = x.split('/')\n        a, n = y if len(y) == 2 else (x, '1')\n        z = a.split('-')\n        b, c = z if len(z) == 2 else (mini, maxi) if a == '*' else (a, a)\n        res.update(range(D[b] if b in D else int(b), (D[c] if c in D else int(c))+1, int(n)))\n    return ' '.join(map(str, sorted(res)))\n\ndef parse(crontab):\n    res, L = [], crontab.split()\n    res.append(f\"minute         {read(L[0], 0, 59)}\")\n    res.append(f\"hour           {read(L[1], 0, 23)}\")\n    res.append(f\"day of month   {read(L[2], 1, 31)}\")\n    res.append(f\"month          {read(L[3], 1, 12)}\")\n    res.append(f\"day of week    {read(L[4], 0, 6)}\")\n    return '\\n'.join(res)", "def parse(crontab):\n    crontab = crontab.replace('FEB', '2').replace('JUL', '7').replace('SUN', '0').replace('THU', '4').split()\n    output = [[], [], [], [], []]\n    valid = {0: [0, 59], 1: [0, 23], 2: [1, 31], 3: [1, 12], 4: [0, 6]}\n    def parser(s):\n        nums = '1234567890'\n        out = []\n        dig1 = dig2 = dig3 = ''\n        state = 0\n        for c in s:\n            if c == ',':\n                if not(dig3):\n                    dig3 = '1'\n                out.append([dig1, dig2, dig3])\n                dig1 = dig2 = dig3 = ''\n                state = 0\n            elif not(state):\n                dig1 += c\n                state = 1\n            elif state == 1:\n                if c in nums:\n                    dig1 += c\n                elif c == '-':\n                    state = 2\n                else:\n                    state = 3\n            elif state == 2:\n                if c in nums:\n                    dig2 += c\n                else:\n                    state = 3\n            elif state == 3:\n                dig3 += c\n        if not(dig3):\n            dig3 = '1'\n        out.append([dig1, dig2, dig3])\n        return out\n    for i in range(len(crontab)):\n        for p in parser(crontab[i]):\n            if p[0] == '*':\n                output[i].extend([x for x in range(valid[i][0], valid[i][1] + 1, int(p[2]))])\n            elif p[1]:\n                output[i].extend([x for x in range(int(p[0]), int(p[1]) + 1, int(p[2])) if valid[i][0] <= x <= valid[i][1]])\n            else:\n                output[i].append(int(p[0]))\n        output[i].sort()\n        output[i] = ' '.join([str(x) for x in output[i]])\n    return 'minute         ' + output[0] + '\\nhour           ' + output[1] + '\\nday of month   ' + output[2] + '\\nmonth          ' + output[3] + '\\nday of week    ' + output[4]\n", "def parse(crontab):\n    cron_list = crontab.split(' ')\n    cron_ranges = ['0-59', '0-23', '1-31', '1-12', '0-6']\n    weekdays = {'SUN': 0, 'MON': 1, 'TUE': 2, 'WED': 3, 'THU': 4, 'FRI': 5, 'SAT': 6}\n    months = {'JAN': 1, 'FEB': 2, 'MAR': 3, 'APR': 4, 'MAY': 5, 'JUN': 6, 'JUL': 7, 'AUG': 8, 'SEP': 9, 'OCT': 10, 'NOV': 11, 'DEC': 12}\n\n    for i, r in enumerate(cron_list):\n        val_out = []\n        for v in r.split(','):\n            step = 1\n            if '/' in v:\n                step = int(v.split('/')[1])\n                v = v.split('/')[0]\n            if '-' in v:\n                start = (months[v.split('-')[0]] if i == 3 else weekdays[v.split('-')[0]]) if not v.split('-')[0].isnumeric() else int(v.split('-')[0])\n                stop = (months[v.split('-')[1]] + 1 if i == 3 else weekdays[v.split('-')[1]] + 1) if not v.split('-')[1].isnumeric() else int(v.split('-')[1]) + 1\n                val_out += [i for i in range(start, stop, step)]\n            elif '*' in v:\n                start = int(cron_ranges[i].split('-')[0])\n                stop = int(cron_ranges[i].split('-')[1]) + 1\n                val_out += [i for i in range(start, stop, step)]\n            else:\n                val_out += [int(v)]\n        cron_list[i] = ' '.join([str(i) for i in sorted(val_out)])\n\n    return '{:<15}{}\\n{:<15}{}\\n{:<15}{}\\n{:<15}{}\\n{:<15}{}'.format('minute', cron_list[0], 'hour', cron_list[1],\n                                                                     'day of month', cron_list[2], 'month', cron_list[3],\n                                                                     'day of week', cron_list[4])", "isodays=['SUN','MON','TUE','WED','THU','FRI','SAT']\nisomonths=['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC']\ndef checkIso(start,end):\n    if start in isodays:\n        return str(isodays.index(start)),str(isodays.index(end))\n    if start in isomonths:\n        return str(isomonths.index(start)+1),str(isomonths.index(end)+1)\n    return start,end\n\ndef parseitem(itempart):\n    itemnums=list()\n    period,item,minmax = itempart\n    for i in item.split(','):\n    \n        if i.isnumeric():\n            itemnums.append(int(i))\n            continue\n\n        if i.find('-')>-1:\n            rangsplit=i.split('-') \n            step=1\n            start=rangsplit[0]\n            end=rangsplit[1]\n            if rangsplit[1].find('/')>-1:\n                step=int(rangsplit[1].split('/')[1])         \n                end=rangsplit[1].split('/')[0]\n            start,end=checkIso(start,end)\n            itemnums.extend(range(int(start),int(end)+1,step))\n            continue\n        if i.find('*')>-1:\n            step=1\n            if i.find('/')>-1:\n                step=int(i.split('/')[1])\n            itemnums.extend(range(minmax[0],minmax[1]+1,step))\n            continue\n\n    itemnums.sort()    \n    return period.ljust(15)+' '.join([ str(x) for x in itemnums ])\n\n\n\ndef parse(crontab):\n    periods=['minute','hour','day of month','month','day of week']\n    periodminmax=[[0,59],[0,23],[1,31],[1,12],[0,6]]\n    zipped=list(zip(periods,crontab.split(' '),periodminmax))\n    return '\\n'.join([ parseitem(x) for x in zipped ])"]