["def roundRobin(jobs, slice, index):\n    total_cc = 0\n    while True:\n        for idx in range(len(jobs)):\n            cc = min(jobs[idx], slice)\n            jobs[idx] -= cc\n            total_cc += cc\n            if idx == index and jobs[idx] == 0:\n                return total_cc", "def roundRobin(jobs, slice, index):\n    q = (jobs[index] - 1) // slice\n    return (\n        sum(min(x, (q+1) * slice) for x in jobs[:index+1]) +\n        sum(min(x, q * slice)     for x in jobs[index+1:])\n    )", "def roundRobin(jobs, slice, index):\n    i, res, jobs = 0, 0, jobs[:]\n    while jobs[index]:\n        res += min(slice, jobs[i])\n        jobs[i] = max(0, jobs[i]-slice)\n        i = (i+1)%len(jobs)\n    return res", "def roundRobin(jobs, slice, index):\n    cc = i = 0\n    while jobs[index] > 0:\n        cc += min(slice, jobs[i])\n        jobs[i] = max(0, jobs[i] - slice)\n        i = (i + 1) % len(jobs)\n    return cc\n", "import math\n\ndef ceil(value, step):\n    return math.ceil(value / step) * step\n\ndef floor(value, step):\n    return math.floor(value / step) * step\n\ndef roundRobin(jobs, frame, index):\n    for i in range(index):\n        jobs[i] = min(jobs[i], ceil(jobs[index], frame))\n    for i in range(index + 1, len(jobs)):\n        jobs[i] = min(jobs[i], floor(jobs[index] - 1, frame))\n    return sum(jobs)\n", "def roundRobin(jobs, slice, index):\n    num_slices = (jobs[index] + slice - 1) // slice\n    before = num_slices * slice\n    after = (num_slices - 1) * slice\n    return sum(min(before, cc) for cc in jobs[0:index]) \\\n            + sum(min(after, cc) for cc in jobs[index + 1:]) + jobs[index]\n", "roundRobin=lambda a,n,i:sum(min((a[i]+n*(i>=j)-1)//n*n,v)for j,v in enumerate(a))", "def roundRobin(jobs, sl, index):\n    start_sum = sum(jobs)\n    cur_idx = 0\n    while jobs[index] > 0:\n        jobs[cur_idx] = jobs[cur_idx] - min(jobs[cur_idx], sl)\n        cur_idx = (cur_idx + 1) % len(jobs)\n    return start_sum - sum(jobs)", "def roundRobin(jobs, limit, target):\n    queue = list(enumerate(jobs))\n    cycles = 0\n    while True:\n        index, job = queue.pop(0)\n        if limit >= job:\n            cycles += job\n            job = 0\n        else:\n            job -= limit\n            cycles += limit\n        if job:\n            queue.append((index, job))\n        elif index == target:\n            break\n    return cycles"]