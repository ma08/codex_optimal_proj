["def primeFactors(n):\n    \n    factors = []\n    \n    while n % 2 == 0: \n        n /= 2\n        factors.append(2)\n        \n    for i in range(3, int(n**.5) + 1,2): \n        while n % i == 0: \n            n /= i\n            factors.insert(0, i)\n            \n    if n > 2: factors.insert(0, int(n))\n        \n    return factors\n        \ndef score(p):\n    \n    last, xp, s = p[0], p[0], 0\n    \n    for j in p[1:]:\n        if j == last:\n            xp *= j\n        else:\n            s += xp\n            xp, last = j, j\n    return (s + xp) * len(p)\n    \n\ndef prod(lst):\n    \n    res = 1\n    \n    for v in lst: res *= v\n    return res\n\ndef multiply_partitions(partition): return [prod(sub) for sub in partition]\n\ndef partition(collection):\n    \n    if len(collection) == 1:\n        yield [collection]\n        return\n\n    first = collection[0]\n    \n    for smaller in partition(collection[1:]):      \n        for n, subset in enumerate(smaller):\n            yield smaller[:n] + [[ first ] + subset]  + smaller[n+1:]\n        yield [ [ first ] ] + smaller\n\n\ndef find_spec_prod_part(n, com):  \n    \n    factors = primeFactors(n)\n    \n    if len(factors) == 1: return 'It is a prime number'\n    \n    fn = min if com == 'min' else max\n    mplist = []\n    best = [factors, score(factors)]\n    \n    for p in partition(factors):\n        mp = multiply_partitions(p)\n        \n        if mp in mplist or mp[0]==n:\n            continue            \n        mplist.append(mp)\n        best = fn(best, [mp, score(mp)], key=lambda x: x[1])\n    \n    return [sorted(best[0], reverse=True), best[1]]", "def primeFactors(n):\n    factors = []\n    while n % 2 == 0: \n        n /= 2\n        factors.append(2)\n    for i in range(3,int(n**.5)+1,2): \n        while n % i == 0: \n            n /=i\n            factors.insert(0, i)\n    if n > 2: \n        factors.insert(0, int(n))\n    return factors\n        \ndef score(p):\n    last, xp, s = p[0], p[0], 0\n    for e in p[1:]:\n        if e == last:\n            xp *= e\n        else:\n            s += xp\n            xp, last = e, e\n    return (s + xp) * len(p)\n    \n\ndef prod(lst):\n    res = 1\n    for v in lst: res *= v\n    return res\n\ndef multiply_partitions(partition):\n    return [prod(sub) for sub in partition]\n\ndef partition(collection):\n    if len(collection) == 1:\n        yield [ collection ]\n        return\n\n    first = collection[0]\n    for smaller in partition(collection[1:]):\n        # insert `first` in each of the subpartition's subsets\n        for n, subset in enumerate(smaller):\n            yield smaller[:n] + [[ first ] + subset]  + smaller[n+1:]\n        # put `first` in its own subset \n        yield [ [ first ] ] + smaller\n\n\ndef find_spec_prod_part(n, com):    \n    factors = primeFactors(n)\n    if len(factors) == 1: return 'It is a prime number'\n    fn = min if com == 'min' else max\n    mplist = []\n    best = [factors, score(factors)]\n    for p in partition(factors):\n        mp = multiply_partitions(p)\n        if mp in mplist or mp[0]==n:\n            continue\n        mplist.append(mp)\n        best = fn(best, [mp, score(mp)], key=lambda x: x[1])\n    \n    return [sorted(best[0], reverse=True), best[1]]", "from collections import Counter\nfrom itertools import permutations\nfrom itertools import chain\nimport numpy as np\n\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        n = n // 2\n        factors.append(2)\n        \n    for k in range(3, n+1, 2):\n        while n % k == 0:\n            n = n // k\n            factors.append(k)\n        if n == 1:\n            break\n    return factors\n\n   \ndef get_score(factors):\n    factor_counts = Counter(factors)\n    return sum(f**factor_counts[f] for f in factor_counts)*sum(c for c in factor_counts.values())\n\n\ndef int_partitions(m, memo = {}):\n    if m in memo:\n        return memo[m]\n    all_partitions = [[m]]\n    \n    for i in range(1, m):\n        for p in int_partitions(m-i, memo):\n            all_partitions.append([i] + p)\n    \n    memo[m] = all_partitions\n    return all_partitions\n\n\ndef make_partitions(factors):\n    partitions = int_partitions(len(factors))\n    part_perm = []\n    \n    for p in partitions:\n        part_perm.append(set(list(permutations(p, len(p)))))\n\n    part_perm = set(list(chain.from_iterable(part_perm)))\n    all_new_factors = []\n\n    for inds in part_perm:        \n        new_factors = []\n        j_start = 0\n\n        for i in inds:\n            j_end = j_start + i\n            new_factors.append(np.product(factors[j_start:j_end]))\n            j_start = j_end\n        \n        if len(new_factors) > 1:\n            all_new_factors.append(new_factors) \n    \n    return all_new_factors\n\n\ndef find_spec_prod_part(n, com):\n    factors = prime_factors(n)   \n    \n    if len(factors) == 1:\n        return \"It is a prime number\"\n    \n    all_factors = make_partitions(factors)\n    scores = [get_score(x) for x in all_factors]\n    \n    if com == \"max\":\n        opt_id = np.argmax(scores)\n    else:\n        opt_id = np.argmin(scores)\n    \n    return [sorted(all_factors[opt_id], reverse=True), scores[opt_id]] ", "from itertools import cycle, groupby, islice\nfrom operator import lt, gt\n\ndef find_spec_prod_part(n, com):\n    prime_factors = list(factor(n))\n    if len(prime_factors) < 2:\n        return 'It is a prime number'\n    cmp = lt if com == 'min' else gt\n    best_part = None\n    best_score = None\n    for part in set(islice(partitions(prime_factors), 1, None)):\n        sc = score(part)\n        if not best_score or cmp(sc, best_score):\n            best_part = part\n            best_score = sc\n    return [list(best_part), best_score]\n\ndef factor(n):\n    if n < 1: raise ValueError('factor: n must be > 0')\n    for d in [2, 3, 5]:\n        while n % d == 0:\n            yield d\n            n = n // d\n    d = 7\n    wheel = cycle([4, 2, 4, 2, 4, 6, 2, 6])\n    while n > 1 and d * d <= n:\n        if n % d == 0:\n            yield d\n            n = n // d\n        else:\n            d += next(wheel)\n    if n > 1:\n        yield n\n\ndef partitions(factors):\n    if len(factors) == 1:\n        yield factors[0],\n        return\n    first = factors[0]\n    for subpart in partitions(factors[1:]):\n        for n, fact in enumerate(subpart):\n            yield tuple(sorted(subpart[:n] + (first * fact,) + subpart[n+1:], reverse=True))\n        yield tuple(sorted((first,) + subpart, reverse=True))\n\ndef score(part):\n    factors = [(f, len(list(g))) for f, g in groupby(part)]\n    return sum(f**e for f, e in factors) * sum(e for _, e in factors)\n", "import math\nfrom collections import Counter\nfrom itertools import permutations\n\ndef find_spec_prod_part(n, com):\n    # your code here\n    temp_partition = []    \n    factors = primeFactors(n)\n    counter = Counter(factors)\n    max_score = calculateScore(counter)\n    min_score = max_score\n    partition_min = factors\n    partition_max = factors\n    \n    x = len(factors)\n    \n    if len(factors) == 1:\n        return \"It is a prime number\"\n    \n    perms = list(set(list(permutations(factors))))\n    \n    \n    divs = list(accel_asc(len(factors)))     \n    \n\n    for div in divs:\n        if len(div) == 1 or len(div) == len(factors):\n            continue\n        for perm in perms:\n            temp_partition = []\n            start = 0\n            product = 1\n            seq = []\n\n            for i in div:\n                seq = perm[start:(start+i)]\n                for j in seq:\n                    product *= j\n                temp_partition.append(product)\n                start = start+i\n                product = 1\n\n            counter = Counter(temp_partition)\n            score = calculateScore(counter)\n            \n            if score > max_score:\n                max_score = score\n                partition_max = temp_partition\n                \n            if score < min_score:\n                min_score = score\n                partition_min = temp_partition\n                \n            \n    if com == 'max':\n        partition_max.sort(reverse = True)\n        return [partition_max, max_score]\n    if com == 'min':\n        partition_min.sort(reverse = True)\n        return [partition_min, min_score]\n\n\ndef calculateScore(count):\n    score = 0\n    coef = 0\n    for key in count:\n        score += key**count[key]\n        coef += count[key]\n    score = score * coef\n    return score\n\n# A function to print all prime factors of  \n# a given number n \ndef primeFactors(n): \n    prime_factors = []  \n    # Print the number of two's that divide n \n    while n % 2 == 0: \n        prime_factors.append(2), \n        n = n / 2\n          \n    # n must be odd at this point \n    # so a skip of 2 ( i = i + 2) can be used \n    for i in range(3, int(math.sqrt(n))+1, 2): \n          \n        # while i divides n, print i ad divide n \n        while n % i == 0: \n            prime_factors.append(i), \n            n = n / i \n    if n != 1:\n        prime_factors.append(int(n))\n\n    return prime_factors\n\ndef accel_asc(n):\n    a = [0 for i in range(n + 1)]\n    k = 1\n    y = n - 1\n    while k != 0:\n        x = a[k - 1] + 1\n        k -= 1\n        while 2 * x <= y:\n            a[k] = x\n            y -= x\n            k += 1\n        l = k + 1\n        while x <= y:\n            a[k] = x\n            a[l] = y\n            yield a[:k + 2]\n            x += 1\n            y -= 1\n        a[k] = x + y\n        y = x + y - 1\n        yield a[:k + 1]", "from functools import reduce\nfrom operator import mul,gt,lt\nfrom itertools import combinations\nfrom collections import Counter\ndef is_prime(n):\n    if n<2:\n        return False\n    elif n==2:\n        return True\n    elif n%2==0:\n        return False\n    for i in range(3,int(n**0.5)+1,2):\n        if n%i==0:\n            return False\n    return True\n\nmemo={}\n    \ndef _prot_part(arr):\n    if len(arr)<2:\n        return set({(arr[0],)})\n    elif len(arr)==2:\n        return set([tuple(sorted(arr)),(arr[0]*arr[1],)])\n    elif tuple(arr) in memo:\n        return memo[tuple(arr)]\n    r=set()\n    for j in range(1,len(arr)//2+1):\n        for t in combinations(arr,j):\n            arr2=arr[:]\n            for e in t:\n                arr2.remove(e)\n            s2=_prot_part(arr2)\n            for e1 in _prot_part(list(t)):\n                for e2 in s2:\n                    r.add(tuple(sorted(list(e1+e2))))\n    r.add((reduce(mul,arr),))\n    memo[tuple(arr)]=r\n    return r\n\ndef find_spec_prod_part(n, com):\n    if is_prime(n):\n        return 'It is a prime number'\n    r=[]\n    while(n%2==0):\n        r.append(2)\n        n//=2\n    x=3\n    while(n>1 and not is_prime(n)):\n        while(n%x==0):\n            r.append(x)\n            n//=x\n        x+=2\n    if n>1:\n        r.append(n)\n    p=_prot_part(r)\n    if com=='max':\n        m=[None,-1]\n        f=gt\n    else:\n        m=[None,10e10]\n        f=lt\n    for t in p:\n        if len(t)==1:\n            continue\n        a,b=0,0\n        for k,v in Counter(t).items():\n            a+=k**v\n            b+=v\n        score=a*b\n        if f(score,m[1]):\n            m=[sorted(t,reverse=True),score]\n    return m    ", "from numpy import prod\ndef find_spec_prod_part(n, com):\n    partitions = []\n    current_partition = 2\n    while n > 1:\n        if n % current_partition == 0:\n            partitions.append(current_partition)\n            n /= current_partition\n            current_partition  = 2\n        else:\n            current_partition += 1\n\n    if len(partitions) == 1:\n        return \"It is a prime number\"\n    \n    result = [([0], -1)] if com == \"max\" else [([0], float('Inf'),)]\n    sc_opt(partitions, result, com)\n        \n    result[0][0].sort(reverse=True)\n    return [result[0][0], result[0][1]]\n\ndef sc_opt(partitions, result, com):\n    if (com == \"min\" and result[0][1] > sc(partitions)) or (com == \"max\" and result[0][1] < sc(partitions)):\n        result[0] = (partitions, sc(partitions))\n    if len(partitions) == 2 or (com == \"min\" and max(partitions) > result[0][1]) or (com == \"min\" and max(partitions) > result[0][1]) :\n        return\n    for p in set(partitions):\n        current = partitions.copy()\n        current.remove(p)\n        for i in filter(lambda x: x >= p, set(current)):\n            curr = current.copy()\n            curr[curr.index(i)] *= p\n            sc_opt(curr, result, com)\n\ndef sc(partitions):\n    return sum([p ** partitions.count(p) for p in set(partitions)]) * len(partitions)", "def partition(n):\n    return [[int(n/x)] for x in range(1, 1+int(n/2)) if n % x == 0]\n    \ndef prod(a):\n    prod = 1\n    for n in a:\n        prod *= n\n    return prod\n\ndef score(a):\n    return sum(n ** a.count(n) for n in reversed(sorted(set(a)))) * len(a)\n    \ndef find_spec_prod_part(n, com):\n    #non-recursive way to find partitions\n    there_are_new = True\n    \n    partitions = partition(n)\n    \n    while there_are_new:\n        there_are_new = False\n        new_partitions = []\n        for p in partitions:\n            product = prod(p)\n            if product < n:\n                for new in partition(n/product):\n                    if new[0] <= p[-1] and prod(p+new) <= n:\n                        there_are_new = True\n                        new_partitions.append(p + new)\n            else: \n                new_partitions.append(p)\n    \n        partitions = new_partitions\n        \n    if len(partitions) <= 1:\n        return (\"It is a prime number\")\n        \n    func = max if com == \"max\" else min\n    return func( ([p, s] for (p, s) in ((p, score(p)) for p in partitions if len(p) > 1)), key=lambda x: x[1])", "def partition(n):\n    return [[int(n/x)] for x in range(1, 1+int(n/2)) if n % x == 0]\n    \ndef prod(a):\n    prod = 1\n    for n in a:\n        prod *= n\n    return prod\n\ndef score(a):\n    return sum(n**a.count(n) for n in reversed(sorted(set(a))))*len(a)  \n    \ndef find_spec_prod_part(n, com):\n    there_are_new = True\n    \n    partitions = partition(n)\n    \n    while there_are_new:\n        there_are_new = False\n        new_partitions = []\n        for p in partitions:\n            product = prod(p)\n            if product < n:\n                for new in partition(n/product):\n                    if new[0] <= p[-1] and prod(p+new) <= n:\n                        there_are_new = True\n                        new_partitions.append(p + new)\n            else: \n                new_partitions.append(p)\n    \n        partitions = new_partitions\n        \n    if len(partitions) <= 1:\n        return (\"It is a prime number\")\n        \n    result = None\n    result_score = None\n      \n    for p in partitions:\n        if len(p) > 1:\n            s = score(p)\n            if (com == \"max\" and (not result_score or result_score < s)) or (com == \"min\" and (not result_score or result_score > s)):\n                result = p\n                result_score = s\n            \n    return [result, result_score]"]