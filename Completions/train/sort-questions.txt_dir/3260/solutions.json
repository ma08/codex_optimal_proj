["from itertools import permutations\n\ndef rearranger(k, *args):\n    perms = permutations(map(str, args), len(args))\n    divisible_by_k = filter(lambda x: int(''.join(x)) % k == 0, perms)\n    try:\n        rearranged = min(divisible_by_k, key=lambda x: int(''.join(x)))\n        return 'Rearrangement: {} generates: {} divisible by {}'.format(', '.join(rearranged), ''.join(rearranged), k)\n    except ValueError:\n        return \"There is no possible rearrangement\"", "import itertools\ndef rearranger(k, *args):\n    arrengment, prep = list(set(itertools.permutations([x for x in args]))), []\n    for key, char in enumerate(arrengment):\n        seriesOfNumbers = [str(x) for x in arrengment[key]]\n        number = int(''.join([x for x in ''.join(str(arrengment[key])) if x.isdigit()]))\n        if number%k==0:\n            prep.append([seriesOfNumbers,number])\n    try:\n        minimum = min([x[1] for x in prep])\n        answer = [x[0] for x in prep if x[1]==minimum]+[x[1] for x in prep if x[1]==minimum]\n        if len(answer)==0: return 'There is no possible rearrangement'\n        elif len(answer)==2: return 'Rearrangement: %s generates: %d divisible by %d'%(', '.join([x for x in answer[0]]),\n                [y for x,y in enumerate(answer)if x%2 !=0][0], k)\n        elif len(answer)>2: return \"Rearrangements: %s and %s generates: %d divisible by %d\"%(\n            ', '.join([x for x in answer[0]]), ', '.join([x for x in answer[1]]), \n            [y for x,y in enumerate(answer)][2], k)\n    except ValueError:\n        return 'There is no possible rearrangement'", "from itertools import permutations\n\ndef rearranger(k, *args):\n    arguments = []\n    numbers = []\n    min_num = 10 ** 50\n    for arg in [*args]:\n        arguments.append(str(arg))\n    for perm in permutations(arguments):\n        num = int(\"\".join(perm))\n        if num % k == 0:\n            if num == min_num and not perm in numbers:\n                numbers.append(perm)\n            if num < min_num:\n                min_num = num\n                numbers = [perm]\n                \n    if len(numbers) == 0:\n        answer = \"There is no possible rearrangement\"\n    elif len(numbers) == 1:\n        nums = ', '.join(numbers[0])\n        answer = f\"Rearrangement: {nums} generates: {min_num} divisible by {k}\"\n    elif len(numbers) == 2:\n        nums1 = ', '.join(numbers[0])\n        nums2 = ', '.join(numbers[1])\n        answer = f\"Rearrangements: {nums1} and {nums2} generates: {min_num} divisible by {k}\"\n    return answer", "from itertools import permutations as p\n\ndef rearranger(k, *args):\n    res, u, t = 1E200, len(args),(0,0)\n    for i in p(args,u):\n        a = int(''.join(map(str,i)))\n        if a % k == 0:\n            if a < res:\n                res = a\n                t = i\n            if a == res:\n                if i < t:\n                    t = i\n    if t == (0,0):\n        return \"There is no possible rearrangement\"\n    else:\n        return \"Rearrangement: \" + str(t)[1:-1] + \" generates: \" + str(res) + \" divisible by \" + str(k)", "from itertools import permutations\n\ndef rearranger(k, *args):\n    options = sorted(permutations(args, len(args)), key=lambda option: (''.join(str(x) for x in option), option))\n    res = \"There is no possible rearrangement\"\n    for option in options: \n        aux = int(''.join(str(x) for x in option))\n        if aux%k==0: \n            res = \"Rearrangement: {} generates: {} divisible by {}\".format(', '.join(str(x) for x in option), aux, k)\n            break\n    return res\n", "from itertools import permutations\ndef rearranger(k, *args):\n    min_d=[10e50,None]\n    for p in permutations(args):\n        n=int(''.join(str(x) for x in p))\n        if n%k==0:\n            if n<min_d[0]:\n                min_d=[n,set({', '.join(map(str,p))})]\n            elif n==min_d[0]:\n                min_d[1].add(', '.join(map(str,p)))\n    if min_d[1] is None:\n        return 'There is no possible rearrangement'\n    return 'Rearrangement: {0} generates: {1} divisible by {2}'.format(' and '.join(min_d[1]),min_d[0],k)", "from itertools import permutations\nfrom collections import defaultdict\n\ndef rearranger(k, *args):\n    vals, D = map(str, args), defaultdict(set)\n    for p in permutations(vals):\n        x = int(''.join(p))\n        if not x % k: D[x].add(p)\n    try:\n        mini = min(D)\n        res = D[mini]\n        return f\"Rearrangement{'s' if len(res) > 1 else ''}: {' and '.join(map(', '.join, res))} generates: {mini} divisible by {k}\"\n    except:\n        return \"There is no possible rearrangement\"", "from itertools import permutations\n\ndef rearranger(k, *args):\n    res = set([(int(''.join(map(str, p))), p) for p in permutations(args) if int(''.join(map(str, p))) % k == 0])\n    if res:\n        res = sorted(res)\n        ans = []\n        min_val = res[0][0]\n        for i, p in res:\n            if i != min_val:\n                break\n            ans.append(f'{\", \".join(map(str, p))}')\n        return f'Rearrangement{\"s\" if len(ans) > 1 else \"\"}: {\" and \".join(ans)} {\" \" if len(ans) > 1 else \"\"}generates: {min_val} divisible by {k}'\n    return 'There is no possible rearrangement'", "import itertools\n\ndef from_list_to_string(A):\n    st = ''\n    for x in A:\n        st += str(x)\n    return st\n\ndef from_list_to_string_with_comma(A):\n    st = ''\n    for x in A:\n        st = st + str(x) + ', '\n    return st[:-2]\n\ndef rearranger(k, *args):\n    min = float(\"inf\")\n    index = None\n    list_of_permutations = list(itertools.permutations(args))\n    for i in range(len(list_of_permutations)):\n        tmp = int(from_list_to_string(list_of_permutations[i]))\n        if tmp % k == 0 and tmp < min:\n            min = tmp\n            index = i\n    if index == None:\n        return \"There is no possible rearrangement\"\n    else:\n        return \"Rearrangement: \" + str(from_list_to_string_with_comma(list_of_permutations[index])) + \" generates: \" + str(min) + \" divisible by \" + str(k)"]