["class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        char_map = {char: i for i, char in enumerate(order)}\n        for j in range(1, len(words)):\n            prev, curr = words[j - 1], words[j]\n\n            k = 0\n            while k < min(len(prev), len(curr)):\n                if prev[k] == curr[k]:\n                    k += 1\n                elif char_map[prev[k]] > char_map[curr[k]]:\n                    return False\n                else:\n                    break\n            if k >= len(curr):\n                return False\n        return True", "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        record = {o:i for i, o in enumerate(order)}\n        \n        def checkOrdered(w1, w2):\n            p = min(len(w1), len(w2))\n            i = 0\n            while(i < p):\n                if w1[i] == w2[i]:\n                    i += 1\n                else:\n                    break\n            if i != p:\n                l, r = record[w1[i]], record[w2[i]]\n                # l, r = order.index(w1[i]),order.index(w2[i]) \n                if l < r:\n                    return True\n                if l > r:\n                    return False\n            else:\n                return len(w1) <= len(w2)\n            \n        if len(words) <= 1:\n            return True\n        \n        left = self.isAlienSorted(words[:len(words)//2], order)\n        mid = checkOrdered(words[len(words)//2-1], words[len(words)//2])\n        right = self.isAlienSorted(words[len(words)//2:], order)\n        \n\n        return left and right and mid\n", "class Solution:\n    def alienCompare(self, word1: str, word2: str, order: str) -> int:\n        if word1 == word2:\n            return 0\n        else:\n            i: int = 0\n            while i < len(word1) and i < len(word2) and word1[i] == word2[i]:\n                i += 1\n            if i == len(word1):\n                return -1\n            elif i == len(word2):\n                return 1\n            elif order.index(word1[i]) < order.index(word2[i]):\n                return -1\n            else:\n                return 1\n    \n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        n: int = len(words)\n        if n == 0 or n == 1:\n            return True\n        else:\n            for i in range(1, n):\n                if self.alienCompare(words[i - 1], words[i], order) == 1:\n                    return False\n            return True", "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        # shorter strings with common alphabets are always preferred in ordering\n        # given the order, a O(m) dictionary mapping letter to a number can be made\n        # and by iterating through every word and computing the sum of numbers,\n        # when the number is smaller for earlier one, then terminate with False\n        # if the loop finishes without returning False, then return True\n        \n        if len(words) == 1:\n            return True\n        \n        i = 0\n\n        lex_dict = {l: o for o, l in enumerate(order)}\n        print(lex_dict)\n        # for o in range(len(order)):\n        #     lex_dict[order[o]] = o + 1\n\n        # instead of scrolling through each letter in all words,\n        # just compare the pairs in the order (list is an ordered data structure anyway)\n        \n        prev_word = words[0]\n        for i in range(1, len(words)):\n            word = words[i]\n            # do comparison\n            # print(\\\"prev_word: {}, word: {}\\\".format(prev_word, word))\n            for l1, l2 in zip(prev_word, word):\n                if lex_dict[l2] < lex_dict[l1]:\n                    return False\n                elif lex_dict[l2] > lex_dict[l1]:\n                    break  # no need for further checking\n            # # handle special case, if it survived and the length of prev_word is > word, return False\n            else:  # amazing trick! if no breakpoint occurred in the above for-loop, then come here\n                if len(prev_word) > len(word):\n                    return False\n            prev_word = word            \n            \n                    \n        return True\n", "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        for i in range(len(words)-1):\n            s1,s2 = words[i],words[i+1]\n            if not self.checkWords(s1,s2,order):\n                return False\n        return True\n    \n    def checkWords(self,s1,s2,order):\n        for i in range(len(s1)):\n            if i < len(s2):\n                if s1[i] != s2[i]:\n                    if order.index(s1[i]) > order.index(s2[i]): return False\n                    return True\n            else:\n                return False\n        return True", "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        index_lookup = {char: i for i,char in enumerate(order)}\n        for i in range(len(words) - 1):\n            first, second = words[i:i+2]\n            for j in range(min(len(first), len(second))):\n                if first[j] != second[j]:\n                    if index_lookup[first[j]] > index_lookup[second[j]]:\n                        return False\n                    break\n            else:\n                if len(first) > len(second):\n                    return False\n        return True\n", "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        '''\n        Questions:are all char in the order? any missing? any duplicates?\n        \n        O(wn) len of longest word, compare all words\n        order would be in a map to see\n        \n        '''\n        word_indexes = {ch : i for i, ch in enumerate(list(order))}\n        \n        for i, word1 in enumerate(words[1:], start=1):\n            word2 = words[i-1] # word before\n            \n            for j in range(min(len(word1), len(word2))):\n                if word1[j] != word2[j]: # only compare when they are different\n                    if word_indexes[word1[j]] < word_indexes[word2[j]]:\n                        return False\n                    break\n            else: # when break not hit\n                # complete word but there is more characters for one of the words: \n                # should be ordered after the shorter word\n                if len(word1) < len(word2):\n                    # word before is longer\n                    return False\n        \n        return True", "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        d = {c: i for i, c in enumerate(order)}\n        def compare(w1, w2):\n            for i in range(min(len(w1), len(w2))):\n                if d[w1[i]] < d[w2[i]]:\n                    return True\n                if d[w1[i]] > d[w2[i]]:\n                    return False\n            return len(w1) <= len(w2)\n        \n        for i in range(len(words) - 1):\n            if not compare(words[i], words[i+1]):\n                return False\n        \n        return True", "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        order_index = {c: i for i, c in enumerate(order)}\n\n        for i in range(len(words) - 1):\n            word1 = words[i]\n            word2 = words[i+1]\n\n            # Find the first difference word1[k] != word2[k].\n            for k in range(min(len(word1), len(word2))):\n                # If they compare badly, it's not sorted.\n                if word1[k] != word2[k]:\n                    if order_index[word1[k]] > order_index[word2[k]]:\n                        return False\n                    break\n            else:\n                # If we didn't find a first difference, the\n                # words are like (\\\"app\\\", \\\"apple\\\").\n                if len(word1) > len(word2):\n                    return False\n\n        return True", "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        \n        order_map = {c: i for i, c in enumerate(order)}\n        \n        words = [[order_map[w] for w in word] for word in words]\n        \n        return all([w1<=w2 for w1,w2 in zip(words, words[1:])])\n        \n        \n"]