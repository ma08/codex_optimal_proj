["m = int(input())\ns = input().strip()\n\nsa = [0] * len(s)\nfor i in range(len(s)):\n\tsa[i] = ord(s[i]) - ord('a')\n\nsa = [-1] + sa + [-1]\n\ndef check_value(sa, m, threshold):\n\tprev_ind = 0\n\tfor i in range(len(sa)):\n\t\tif sa[i] <= threshold:\n\t\t\tif i - prev_ind <= m:\n\t\t\t\tprev_ind = i\n\t\t\telse:\n\t\t\t\treturn False\n\treturn True\n\ndef get_indexes(sa, threshold):\n\tseq = [i for i in range(len(sa)) if sa[i] <= threshold]\n\t# seq = []\n\t# for i in range(len(sa)):\n\t# \tif sa[i] < threshold:\n\t# \t\tseq[i].append(sa[i], i)\n\treturn seq\n\ndef filter_indexes(sa, seq, el, m):\n\tnew_seq = [0]\n\tfor i in range(1, len(seq) - 1):\n\t\tif sa[seq[i]] != el or (sa[seq[i]] == el and seq[i+1] - new_seq[-1] > m):\n\t\t\tnew_seq.append(seq[i])\n\treturn new_seq[1:]\n\n\nthreshold = -1\nwhile (not check_value(sa, m, threshold)):\n\t# print(threshold, get_indexes(sa, threshold))\n\tthreshold += 1\n# print(threshold, get_indexes(sa, threshold), sa)\n\nseq = get_indexes(sa, threshold)\nseq = filter_indexes(sa, seq, threshold, m)\n\ns = ''.join(sorted([chr(ord('a') + sa[x]) for x in seq]))\nprint(s)", "abc = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\nm = int(input())\nstring = input()\ngood = False\ntoCheck = []\nlenS = len(string)\nholes = [(-1, lenS)]\nhave = {'s': 0, 'i': 0, 'y': 0, 'h': 0, 'r': 0, 'f': 0, 'd': 0, 'z': 0, 'q': 0, 't': 0, 'n': 0, 'g': 0, 'l': 0, 'k': 0, 'o': 0, 'c': 0, 'w': 0, 'm': 0, 'b': 0, 'u': 0, 'a': 0, 'v': 0, 'e': 0, 'p': 0, 'j': 0, 'x': 0}\nfor sym in range(26):\n    if not good:\n        good = True\n        for hole in holes:\n            i = hole[0] + 1\n            end = hole[1]\n            while i < end:\n                fill = string[i:min(end, i + m)].rfind(abc[sym])\n                if fill == -1:\n                    good = False\n                    break\n                else:\n                    have[abc[sym]] += 1\n                    i = i + fill + 1\n                    if end - i < m:\n                        break\n            if not good:\n                break\n        holes = []\n    if not good:\n        have = {'s': 0, 'i': 0, 'y': 0, 'h': 0, 'r': 0, 'f': 0, 'd': 0, 'z': 0, 'q': 0, 't': 0, 'n': 0, 'g': 0, 'l': 0, 'k': 0, 'o': 0, 'c': 0, 'w': 0, 'm': 0, 'b': 0, 'u': 0, 'a': 0, 'v': 0, 'e': 0, 'p': 0, 'j': 0, 'x': 0}\n        toCheck.append(abc[sym])\n        good = True\n        lastSeen = -1\n        for i in range(lenS):\n            if string[i] in toCheck:\n                have[string[i]] += 1\n                if i - lastSeen > m:\n                    holes.append((lastSeen, i))\n                    good = False\n                lastSeen = i\n        if lenS - lastSeen > m:\n            holes.append((lastSeen, lenS))\n            good = False\nalmost = [have[i] * i for i in abc]\nprint(''.join(almost))\n", "n = int(input())\nword = input()\n\ncnt = [0]*26\nfor x in word:\n    cnt[ord(x)-ord('a')] += 1\n\nind = 25\nsum = 0\n\nfor i in range(26):\n    pre = -1\n    cur = -1\n    ans = 0\n    flag = True\n    for j,x in enumerate(word):\n        if ord(x)-ord('a')<i:\n            pre = j\n        elif ord(x)-ord('a')==i:\n            cur = j\n        if j-pre==n:\n            if j-cur>=n:\n                flag = False\n                break\n            pre = cur\n            ans += 1\n        #print(i, j, pre, cur, ans)\n    if flag:\n        ind = i\n        sum = ans\n        break\n\nfor i in range(ind):\n    print(chr(ord('a')+i)*cnt[i],end='')\nprint(chr(ord('a')+ind)*sum)\n        \n    ", "from collections import Counter\nfrom string import ascii_lowercase as asc\nm, s = int(input()), input()\ng = Counter(s)\n\ndef solve(c):\n    p = 0\n    for q in ''.join(x if x >= c else ' ' for x in s).split():\n        i, j = 0, -1 \n        while j + m < len(q):\n            j = q.rfind(c, j + 1, j + m + 1)\n            if j == -1:\n                return None\n            i += 1\n        p += i\n    return p\n\nfor c in asc:\n    f = solve(c)\n    if f is not None:\n        g[c] = f\n        print(''.join(x*g[x] for x in asc if x <= c))\n        break\n", "m = int(input())\ns = input()\nans = []\nmark = [True for _ in range(len(s))]\nz = 'a'\ni = 0\nwhile i <= len(s) - m:\n    k = i\n    for j in range(i, i + m):\n        if s[j] <= s[k]:\n            k = j\n    ans.append(s[k])\n    z = max(z, s[k])\n    mark[k] = False\n    i = k\n    i += 1\nfor i in range(len(s)):\n    if s[i] < z and mark[i]:\n        ans.append(s[i])\nprint(''.join(str(i) for i in sorted(ans)))", "m = int(input())\ns = list(input())\n\nd = [0 for _ in range(26)]\n\nfor c in s:\n    d[ord(c) - ord('a')] += 1\n\nfor i in range(26):\n    c = chr(ord('a') + i)\n    l = -1\n    r = -1\n    cnt = 0\n    for j in range(len(s)):\n        if s[j] < c:\n            l = j\n        if s[j] == c:\n            r = j\n\n        if j - l >= m:\n            if j - r >= m:\n                cnt = -1\n                break\n            cnt += 1\n            l = r\n\n    if ~cnt:\n        for k in range(i):\n            print(chr(ord('a') + k) * d[k], end='')\n        print(chr(ord('a') + i) * cnt)\n        break\n", "m = int(input()) - 1\nk = input()\nr = ''\ni = 97\nt = [k]\nwhile 1:\n    q = chr(i)\n    p = []\n    for d in t:\n        for s in d.split(q):\n            if len(s) > m: p += [s]\n    if not p: break\n    r += q * k.count(q)\n    i += 1\n    t = p\ny = chr(i)\nfor d in t:\n    i = 0\n    for x in d:\n        if x == y: j = i\n        if i == m:\n            r += y\n            i -= j\n            j = 0\n        else: i += 1\nprint(r)", "m = int(input())\ns = input()\nn = len(s)\nt = []\nu = [1] * n\nd = 'a'\ni = 0\nwhile i <= n - m:\n    k = i\n    for j in range(m):\n        if s[i + j] <= s[k]: k = i + j\n    t += [s[k]]\n    d = max(d, s[k])\n    u[k] = 0\n    i = k + 1\nt += [q for q, v in zip(s, u) if q < d and v]\nprint(''.join(sorted(t)))", "from collections import defaultdict\n\nclass DenseSubsequence():\n    def __init__(self, m, s):\n        self.m = m\n        self.s = s\n        self.chars = sorted(set(s))\n\n    def get_min_sequence(self, ch, mask):\n        lv, lch, i = -1, -1, 0\n        is_possible = True\n        seq = []\n        while i < len(self.s):\n            if mask[i] == 1:\n                lv = i\n            elif self.s[i] == ch:\n                lch = i\n\n            if i-lv == self.m:\n                if lch > lv:\n                    seq.append(lch)\n                    lv = lch\n                else:\n                    is_possible = False\n                    break\n            i += 1\n        if not is_possible:\n            return False, []\n        else:\n            return True, seq\n\n    def get_sequence(self):\n        char_map = defaultdict(list)\n        for i in range(len(self.s)):\n            char_map[self.s[i]].append(i)\n\n        mask = [0]*len(self.s)\n\n        res = ''\n\n        for ch in self.chars:\n            is_possible, seq = self.get_min_sequence(ch, mask)\n            if is_possible:\n                res = res+''.join([ch]*len(seq))\n                break\n            else:\n                res = res+''.join([ch]*len(char_map[ch]))\n                for v in char_map[ch]:\n                    mask[v] = 1\n        print(res)\n\nm = int(input())\ns = input().strip(' ')\nDenseSubsequence(m,s).get_sequence()"]