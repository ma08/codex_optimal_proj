["class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        return len(set(''.join(sorted(s[0::2])) + ''.join(sorted(s[1::2])) for s in A))\n            \n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        \n        signature = set()\n        \n        # Use pair of sorted even substring and odd substring as unique key\n        \n        for idx, s in enumerate(A):\n            signature.add( ''.join( sorted( s[::2] ) ) + ''.join( sorted( s[1::2] ) )  )\n        \n        return len( signature )\n", "from collections import Counter\nclass Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        count = Counter()\n        for s in A:\n            seven = ''\n            sodd = ''\n            for i in range(len(s)):\n                if i % 2 == 0:\n                    seven += s[i]\n                else:\n                    sodd += s[i]\n            count[''.join(sorted(seven)), ''.join(sorted(sodd))] += 1\n        # print(count.keys())\n        return len(count)\n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        for i in range(len(A)):\n            A[i]=sorted(list(A[i][::2]))+sorted(list(A[i][1::2]))\n        A.sort()\n        n=0\n        while len(A)>0:\n            A=A[A.count(A[0]):]\n            n+=1\n        return n", "from collections import Counter\n\nclass Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        lst = []\n        for word in A:\n            evens = []\n            odds = []\n            for i, l in enumerate(word):\n                if i % 2 == 0:\n                    evens.append(l)\n                else:\n                    odds.append(l)\n            lst.append((sorted(evens), sorted(odds)))\n        s = []\n        for word in lst:\n            if word not in s:\n                s.append(word)\n        return len(s)", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        groups = []\n        for s in A:\n            info = len(s), Counter(s[::2]), Counter(s[1::2])\n            if info not in groups:\n                groups.append(info)\n        return len(groups)\n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        return len(set(''.join(sorted(a[::2])) + ''.join(sorted(a[1::2])) for a in A))\n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        \n        groups = []\n        \n        def match(string):\n            \n            odds, evens = {}, {}\n            \n            for i in range(0, len(string), 2):\n                evens[string[i]] = evens.get(string[i], 0) + 1\n            \n            for i in range(1, len(string), 2):\n                odds[string[i]] = odds.get(string[i], 0) + 1\n            \n            for g in groups:                \n                if g[0] == odds and g[1] == evens:\n                    return True, odds, evens\n                \n            return False, odds, evens\n            \n        \n        for s in A:\n            \n            matched, odds, evens = match(s)\n            \n            if not matched:\n                groups.append((odds, evens))\n            \n        return len(groups)\n        \n        \n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        group = list()\n        \n        count = 0\n        for el in A:\n            i = 0\n            counter = {0: dict(), 1: dict()}\n            for ch in el:\n                if ch not in counter[i]:\n                    counter[i][ch] = 1\n                else:\n                    counter[i][ch] += 1\n                i = 1 - i\n            if counter not in group:\n                group.append(counter)\n                count += 1\n        \n        return count\n            \n            \n            \n            \n        \n", "class Solution:\n     \n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        lst = [string2IndRes(string) for string in A]\n        \n        u_lst = unique(lst)\n        \n        return len(u_lst)\n        \n        \n\ndef string2IndRes(string):\n    \n    res = []\n    \n    for i,c in enumerate(string):\n        res.append((c,i%2))\n        \n    return Counter(res)\n\n\ndef unique(list1): \n  \n    # intilize a null list \n    unique_list = [] \n      \n    # traverse for all elements \n    for x in list1: \n        # check if exists in unique_list or not \n        if x not in unique_list: \n            unique_list.append(x) \n            \n    return unique_list\n    \n", "from collections import defaultdict \n\nclass Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        groups = []\n        for word in A:\n            result = {0: defaultdict(int), 1: defaultdict(int)}\n            for i, char in enumerate(word):\n                result[i % 2][char] += 1\n            if result not in groups:\n                groups.append(result)\n        return len(groups)\n               \n                \n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        \n        # set1 = set()\n        even_set = []\n        odd_set = []\n        for i in A:\n            even = []\n            odd = []\n            for j in range(len(i)):\n                if j %2 == 0:\n                    even.append(i[j])\n                else:\n                    odd.append(i[j])\n            even.sort()\n            odd.sort()\n            if even in even_set:\n                k = []\n                for p,values in enumerate(even_set):\n                    if even == values:\n                        k += [p]\n                flag = 0\n                for p in k:\n                    if odd_set[p] == odd:\n                        flag = 1 \n                        break\n                if flag == 0:\n                    even_set.append(even) \n                    odd_set.append(odd)\n            else:\n                even_set.append(even) \n                odd_set.append(odd)\n                \n        return len(even_set)\n            \n                \n                \n                \n                \n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        \n        set1 = set()\n        even_set = []\n        odd_set = []\n        for i in A:\n            even = []\n            odd = []\n            for j in range(len(i)):\n                if j %2 == 0:\n                    even.append(i[j])\n                else:\n                    odd.append(i[j])\n            even.sort()\n            odd.sort()\n            \n            if even in even_set:\n                k = []\n                for p,values in enumerate(even_set):\n                    if even == values:\n                        k += [p]\n                flag = 0\n                for p in k:\n                    if odd_set[p] == odd:\n                        flag = 1 \n                if flag == 0:\n                    even_set.append(even) \n                    odd_set.append(odd)\n            else:\n                even_set.append(even) \n                odd_set.append(odd)\n                \n        print((even_set,odd_set))\n        return len(even_set)\n            \n                \n                \n                \n                \n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        group = []\n        \n        for el in A:\n            i = 0\n            # counter = {0: dict(), 1: dict()}\n            counter = [dict(), dict()]\n            for ch in el:\n                if ch not in counter[i]:\n                    counter[i][ch] = 1\n                else:\n                    counter[i][ch] += 1\n                i = 1 - i\n            if counter not in group:\n                group.append(counter)\n        \n        return len(group)\n            \n            \n            \n            \n        \n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        haveList = list()\n        ans = 0\n        for i in range(len(A)):\n            odd = dict()\n            even = dict()\n            for y,v in enumerate(A[i]):\n                if y % 2 == 0:\n                    odd[v] = odd.get(v,0)+1\n                else:\n                    even[v] = even.get(v,0)+1\n            if [odd,even] not in haveList:\n                haveList.append([odd,even])\n        return len(haveList)", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        return len(set([''.join(sorted(s[0::2]))+''.join(sorted(s[1::2])) for s in A]));", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        haveList = list()\n        ans = 0\n        for i in A:\n            odd = dict()\n            even = dict()\n            for s in i[0::2]:\n                odd[s] = odd.get(s,0)+1\n            for s2 in i[1::2]:\n                even[s2] = even.get(s2,0)+1\n            if [odd,even] not in haveList:\n                haveList.append([odd,even])\n        length = len(haveList)\n        return length", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        odds = []\n        evens = []\n        n = len(A[0])\n        for s in A:\n            de = {}\n            do = {}\n            for i in range(n):\n                if i%2:\n                    if s[i] in de:\n                        de[s[i]] += 1\n                    else:\n                        de[s[i]] = 1\n                else:\n                    if s[i] in do:\n                        do[s[i]] += 1\n                    else:\n                        do[s[i]] = 1\n            odds.append(do)\n            evens.append(de)\n        \n        total = []\n        i = 0\n        while i < len(odds):\n            j = i + 1\n            while j < len(odds):\n                if odds[i] == odds[j] and evens[i] == evens[j]:\n                    odds.pop(j)\n                    evens.pop(j)\n                else:\n                    j += 1\n            i += 1\n        return len(odds)", "from collections import Counter\nclass Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        n = len(A)\n        groups = 0\n        taken = [0]*n\n        even_counters = list(map(Counter, [z[::2] for z in A]))\n        odd_counters = list(map(Counter, [z[1::2] for z in A]))\n        for i in range(n):\n            if taken[i]==0:\n                oci = odd_counters[i]\n                eci = even_counters[i]\n                for j in range(i+1, n):\n                    if taken[j]==1:\n                        continue\n                    ocj = odd_counters[j]\n                    ecj = even_counters[j]\n                    if oci==ocj and eci==ecj:\n                        taken[j] = 1\n                groups += 1\n        return groups\n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        res, count, ct = 0, [], collections.Counter\n        \n        for s in A:\n            even = collections.defaultdict(int)\n            odd = collections.defaultdict(int)\n            isEven = True\n            for c in s:\n                if isEven:\n                    even[c] += 1\n                else:\n                    odd[c] += 1\n                isEven = not isEven\n            count.append((even, odd))\n        \n        i = 0\n        while i < len(count):\n            j = i + 1\n            while j < len(count):\n                if count[i][0] == count[j][0] and count[i][1] == count[j][1]:\n                    count.pop(j)\n                    j -= 1\n                j += 1\n            res += 1\n            count.pop(i)\n        \n        return res", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        res, count, ct = 0, [], collections.Counter\n        \n        for s in A:\n            even = collections.defaultdict(int)\n            odd = collections.defaultdict(int)\n            isEven = True\n            for c in s:\n                if isEven:\n                    even[c] += 1\n                else:\n                    odd[c] += 1\n                isEven = not isEven\n            count.append((even, odd))      \n\n        while count:\n            i, count2 = 1, []\n            for i in range(1, len(count)):\n                if count[0][0] != count[i][0] or count[0][1] != count[i][1]:\n                    count2.append(count[i])\n            res += 1\n            count = count2\n        \n        return res", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        if len(A) == 1:\n            return 1\n        \n        def areSpecialEquiv(x: str, y: str) -> bool:\n            dic_x = {}\n            dic_y = {}\n            for c in x:\n                if c not in y:\n                    return False\n\n            for i in range(len(x)):\n                found = 0\n                for j in range(len(y)):\n                    if x[i] == y[j] and i % 2 == j % 2:\n                        found = 1\n                if not found:\n                    return False\n                \n            for l in x:\n                if l in dic_x:\n                    dic_x[l] += 1\n                else:\n                    dic_x[l] = 1\n                    \n            for l in y:\n                if l in dic_y:\n                    dic_y[l] += 1\n                else:\n                    dic_y[l] = 1\n                    \n            for l in dic_x:\n                if dic_x[l] != dic_y[l]:\n                    return False\n            \n            return True\n        \n        stack = A[:]\n        arr = []\n        \n        while stack:\n            arr2 = []\n            curr = stack.pop(0)\n            count = 1\n            \n            for w in stack:\n                if areSpecialEquiv(curr,w):\n                    count += 1\n                    arr2.append(w)\n            arr.append(count)\n\n            for i in arr2:\n                stack.remove(i)\n            \n        return len(arr)", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        s = set()\n        for a in A:\n            s.add(''.join(sorted(a[::2])) + ''.join(sorted(a[1::2])))\n        return len(s)\n        \n        \n#         dic = Counter()\n        \n#         def idx(x):\n#             ans = \\\"\\\"\n#             for k in sorted(x):\n#                 ans += k + str(x[k])\n#             return ans\n        \n#         for a in A:\n#             odd = Counter(a[1::2])\n#             even = Counter(a[::2])\n#             dic[idx(odd), idx(even)] += 1\n            \n#         return len(dic)\n            \n        \n            \n            \n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        \n        counter_list = set()\n        \n        for i in A:\n            \n            even = []\n            odd = []\n            \n            for index, item in enumerate(i):\n                if index % 2 == 0:\n                    even.append(item)\n                else:\n                    odd.append(item)\n                    \n            normalised = ''.join(sorted(even) + sorted(odd))\n            counter_list.add(normalised)\n            \n        return len(counter_list)\n\n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        l = len(A)\n        counter = {}\n        for i in range(l):\n            odd = []\n            even = []\n            for j in range(len(A[i])):\n                if j % 2 == 0:\n                    even.append(A[i][j])\n                else:\n                    odd.append(A[i][j])\n            even.sort()\n            odd.sort()\n            counter[(str(even), str(odd))] = counter.get((str(even), str(odd)), 0) + 1\n        \n        return len(counter)\n            \n            \n            \n            \n", "class Solution:\n    def numSpecialEquivGroups(self, A: List[str]) -> int:\n        d = set()\n        for w in A:\n            even = ''.join(sorted(w[0::2]))\n            odd = ''.join(sorted(w[1::2]))\n            d.add((even, odd))\n        return len(d)\n"]