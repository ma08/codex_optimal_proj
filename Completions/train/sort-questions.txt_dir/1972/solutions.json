["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def splitBST(self, root,target):\n         \"\"\"\n         :type root: TreeNode\n         :type V: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         \n         def split_bst_recur(root, target):\n             if not root:\n                 return (None, None)\n             \n             if not root.left and not root.right:\n                 if root.val <= target:\n                     return (root, None)\n                 else:\n                     return(None, root)\n             \n             if root.val > target:\n                 l, r = split_bst_recur(root.left, target)\n                 root.left = r\n                 return (l, root)\n             else:\n                 l, r = split_bst_recur(root.right, target)\n                 root.right = l\n                 return (root, r)\n         \n         if not root:\n             return [[],[]]\n         \n         l, r = split_bst_recur(root, target)\n         return [l, r]\n             \n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def splitBST(self, root, V):\n         \"\"\"\n         :type root: TreeNode\n         :type V: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if not root:\n             return [None,None]\n         if root.val==V:\n             temp= root.right\n             root.right= None\n             return [root, temp]\n         if root.val<V:\n             small, large= self.splitBST(root.right, V)\n             root.right=small\n             return [root, large]\n         if root.val>V:\n             small, large= self.splitBST(root.left, V)\n             root.left=large\n             return [small, root]\n             \n             \n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def splitBST(self, root, V):\n         left_bucket = []\n         right_bucket = []\n         \n         def explore(node, V):\n             if not node:\n                 return\n             \n             if node.val <= V:\n                 left_bucket.append(node)\n                 explore(node.right, V)\n                 node.right = None\n             else:\n                 right_bucket.append(node)\n                 explore(node.left, V)\n                 node.left = None\n         \n         explore(root, V)\n         \n         for i in range(1, len(left_bucket)):\n             parent = left_bucket[i-1]\n             child = left_bucket[i]\n             if child.val <= parent.val:\n                 parent.left = child\n             else:\n                 parent.right = child\n         \n         for i in range(1, len(right_bucket)):\n             parent = right_bucket[i-1]\n             child = right_bucket[i]\n             if child.val <= parent.val:\n                 parent.left = child\n             else:\n                 parent.right = child \n                 \n         left = None\n         \n         if len(left_bucket) > 0:\n             left = left_bucket[0]\n         right = None\n         if len(right_bucket) > 0:\n             right = right_bucket[0]\n         \n         return [left, right]\n         \n         \"\"\"\n         :type root: TreeNode\n         :type V: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         ", "# Given a Binary Search Tree (BST) with root node root, and a target value V, split the tree into two subtrees\n # where one subtree has nodes that are all smaller or equal to the target value, while the other subtree has all\n # nodes that are greater than the target value.  It's not necessarily the case that the tree contains a node with value V.\n #\n # Additionally, most of the structure of the original tree should remain.  Formally, for any child C with parent P in the original tree,\n # if they are both in the same subtree after the split, then node C should still have the parent P.\n #\n # You should output the root TreeNode of both subtrees after splitting, in any order.\n #\n # Example 1:\n #\n # Input: root = [4,2,6,1,3,5,7], V = 2\n # Output: [[2,1],[4,3,6,null,null,5,7]]\n # Explanation:\n # Note that root, output[0], and output[1] are TreeNode objects, not arrays.\n #\n # The given tree [4,2,6,1,3,5,7] is represented by the following diagram:\n #\n #           4\n #         /   \\\n #       2      6\n #      / \\    / \\\n #     1   3  5   7\n #\n # while the diagrams for the outputs are:\n #\n #           4\n #         /   \\\n #       3      6      and    2\n #             / \\           /\n #            5   7         1\n # Note:\n #\n # The size of the BST will not exceed 50.\n # The BST is always valid and each node's value is different.\n \n # Definition for a binary tree node.\n class TreeNode:\n     def __init__(self, x):\n         self.val = x\n         self.left = None\n         self.right = None\n \n class Solution:\n     def splitBST(self, root, V):\n         \"\"\"\n         :type root: TreeNode\n         :type V: int\n         :rtype: List[TreeNode]\n         \"\"\"\n \n         if not root:\n             return [None, None]\n \n         if root.val == V:\n             tmp = root.right\n             root.right = None   # \u5207\u8bb0\u8fd9\u91cc\u8981\u628a\u6839\u8282\u70b9\u7684\u53f3\u8282\u70b9\u7f6e\u4e3aNone\n             return [root, tmp]\n         elif V < root.val:\n             n1, n2 = self.splitBST(root.left, V)\n             root.left = n2\n             return [n1, root]\n         else:\n             n1, n2 = self.splitBST(root.right, V)\n             root.right = n1\n             return[root, n2]\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def splitBST(self, root, V):\n         \"\"\"\n         :type root: TreeNode\n         :type V: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if not root:\n             return [None, None]\n         if root.val == V:\n             a = root.right\n             root.right = None\n             return [root, a]\n         elif root.val<V:\n             small, large = self.splitBST(root.right, V)\n             root.right = small\n             return [root, large]\n         else:\n             small, large = self.splitBST(root.left, V)\n             root.left = large\n             return [root, small]"]