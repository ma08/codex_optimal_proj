["class Solution(object):\n     loc=0\n     lastloc=-1\n     f=''\n     def getNext(self,formular,locked=False):\n         stype=0 # 0:null, 1:numeric, 2/20: Elem, 3: parenthesis\n         ret=0\n         if self.loc==self.lastloc: return (0,0)\n         i=self.loc\n         while i <len(formular):\n             if stype in (0,1) and  formular[i].isnumeric():\n                 ret=int(formular[i])+ret*10\n                 stype=1\n             elif stype==0 and formular[i].isupper():\n                 stype=20\n                 ret=formular[i]\n             elif stype in (20,2) and formular[i].islower():\n                 stype=2\n                 ret+=formular[i]\n             elif stype==0 and formular[i] in \"()\":\n                 stype=3+\"()\".index(formular[i])\n                 ret=formular[i]\n             else: break\n             i+=1\n         if not locked:\n             self.lastloc=self.loc\n             self.loc=i\n         return (stype,ret)\n     \n     def countOfAtoms(self, formula):\n         stk=[]\n         cnt={}\n         r=''\n         self.loc=0\n         n=self.getNext(formula)\n         while n!=(0,0):\n             if n[0] in (2,3,20):\n                 stk.append([n[1],1])\n             elif n[0]==1:\n                 stk[-1][1]=n[1]\n             elif n[0]==4:\n                 time=1\n                 i=-1\n                 if self.getNext(formula,True)[0]==1:\n                     time=self.getNext(formula)[1]\n                 while stk[i][0]!='(':\n                     stk[i][1]*=time\n                     i-=1\n                 stk[i][0]='$'\n             n=self.getNext(formula)\n         while any(stk):\n             n=stk.pop()\n             if n[0]!='$':\n                 cnt[n[0]]=cnt.get(n[0],0)+n[1]\n         for i in sorted(cnt.keys()):\n             r+=\"%s%d\"%(i,cnt[i]) if cnt[i]>1 else i\n         return r", "class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         stack = [collections.Counter()]\n \n         i = 0\n         length = len(formula)\n         ss = \"\"\n         while i < length:\n             if formula[i].isupper():\n                 ss = formula[i]\n                 i += 1\n                 while i < length:\n                     if formula[i].islower():\n                         ss += formula[i]\n                         i += 1\n                     else:\n                         i -= 1\n                         break\n                 num = 0\n                 i += 1\n                 while i < length:\n                     if formula[i].isdigit():\n                         num = 10*num + int(formula[i])\n                         i += 1\n                     else:\n                         i -= 1\n                         break\n                 num = num if num else 1\n                 stack[-1][ss] = num if ss not in stack[-1] else stack[-1][ss]+num\n \n             elif formula[i] == \"(\":\n                 stack.append(collections.Counter())\n             elif formula[i] == \")\":\n                 i += 1\n                 multiplier = 0\n                 while i < length:\n                     if formula[i].isdigit():\n                         multiplier = 10*multiplier + int(formula[i])\n                         i += 1\n                     else:\n                         i -= 1\n                         break\n                 cur = stack.pop()\n                 for n, v in list(cur.items()):\n                     stack[-1][n] = stack[-1][n] + v*multiplier if n in stack[-1] else v*multiplier\n \n             i += 1\n         return \"\".join(name + (str(stack[-1][name]) if stack[-1][name] > 1 else '')\n                                for name in sorted(stack[-1]))\n", "class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         stack = []\n         mapping = collections.defaultdict(int)\n         s = \"\"\n         num = 0\n         i = 0\n         while i < len(formula):\n             c = formula[i]\n             if c.islower():\n                 s += c\n                 i += 1\n             elif c.isdigit():\n                 num = 10 * num + int(c)\n                 i += 1\n             else:\n                 if num == 0:\n                     num = 1\n                 if s != \"\":\n                     mapping[s] += num\n                 s = \"\"\n                 num = 0\n                 i += 1\n                 if c.isupper():\n                     s = c\n                 elif c == '(':\n                     stack.append(mapping)\n                     mapping = collections.defaultdict(int)\n                 elif c == ')':\n                     while i < len(formula) and formula[i].isdigit():\n                         num = 10 * num + int(formula[i])\n                         i += 1\n                     prev = stack.pop()\n                     for k in mapping:\n                         prev[k] += mapping[k] * num\n                     mapping = prev\n                     num = 0\n         if num == 0:\n             num = 1\n         if s != \"\":\n             mapping[s] += num\n         ans = []\n         for k, v in sorted(mapping.items()):\n             ans.append(k)\n             if v > 1:\n                 ans.append(str(v))\n         return ''.join(ans)\n", "class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         dict = self.helper(formula)\n         result = \"\"\n         for key in sorted(dict):\n             result += str(key) + (str(dict[key]) if dict[key] > 1 else \"\")\n         return result\n     \n     def helper(self, formula):\n         result = {}\n         j = 0 # conventional i, j are reversed\n         element = \"\"\n         while j < len(formula):\n             if formula[j] == \"(\":\n                 if len(element) > 0:\n                     result[element] = (result[element] if element in result else 0) + 1\n                     element = \"\"\n                 count = 1\n                 end = j + 1\n                 while end < len(formula) and count > 0:\n                     if formula[end] == \"(\":\n                         count += 1\n                     if formula[end] == \")\":\n                         count -= 1\n                     end += 1\n                 dict = self.helper(formula[j + 1: end - 1])\n                 i = end \n                 while i < len(formula) and formula[i].isdigit():\n                     i += 1\n                 m = int(formula[end: i])\n                 for key, value in list(dict.items()):\n                     result[key] = value * m + (result[key] if key in result else 0)\n             elif formula[j].isdigit():\n                 i = j + 1\n                 while i < len(formula) and formula[i].isdigit():\n                     i += 1\n                 result[element] = (result[element] if element in result else 0) + int(formula[j:i])\n                 element = \"\"\n             else:\n                 if len(element) > 0:\n                     result[element] = (result[element] if element in result else 0) + 1\n                     element = \"\"\n                 i = j + 1\n                 while i < len(formula) and formula[i].islower():\n                     i += 1\n                 element = formula[j:i]\n             j = i\n         if not formula[j - 1].isdigit():\n             result[element] = (result[element] if element in result else 0) + 1\n         return result\n \n", "class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         formula+=' '\n         stack,i=[{}],0\n         while i<len(formula):\n             if formula[i]>='A' and formula[i]<='Z':\n                 j=i+1\n                 while formula[j]>='a' and formula[j]<='z':\n                     j+=1\n                 k=j\n                 while formula[k]>='0' and formula[k]<='9':\n                     k+=1\n                 t=1 if k==j else int(formula[j:k])\n                 stack[-1][formula[i:j]]=stack[-1].get(formula[i:j],0)+t\n                 i=k\n             elif formula[i]=='(':\n                 stack.append({})\n                 i+=1\n             elif formula[i]==')':\n                 j=i+1\n                 while formula[j]>='0' and formula[j]<='9':\n                     j+=1\n                 t=1 if j==i+1 else int(formula[i+1:j])\n                 for x in stack[-1]:\n                     stack[-2][x]=stack[-2].get(x,0)+stack[-1][x]*t\n                 stack.pop()\n                 i=j\n             else:\n                 i+=1\n         a,s=sorted(stack[-1].keys()),''\n         for x in a:\n             s+=x if stack[-1][x]==1 else x+str(stack[-1][x])\n         return s", "class Solution:\n     \n     def __init__(self):\n         self.i = 0\n         self.formula = ''\n     \n     \n     @staticmethod\n     def _merge_into(dict_main, dict_added):\n         \"\"\"Change dict_main in place by adding the dict_added\"\"\"\n         for key, val in list(dict_added.items()):\n             dict_main[key] = dict_main.get(key, 0) + val\n     \n     @staticmethod\n     def _multiply(dict_main, mult):\n         \"\"\"Return a new dict from the multiplication of everything by a number\"\"\"\n         return {k: v * mult for k, v in list(dict_main.items())}    \n     \n     # Processing methods\n     def cur(self):\n         return self.formula[self.i]\n     \n     def consume(self):\n         res = self.formula[self.i]\n         self.i += 1\n         return res\n     \n     def atend(self):\n         return self.i == len(self.formula)\n \n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         # Adding a space for easier test than always testing if we are at the end\n         self.formula = formula\n         \n         res = {}\n         while not self.atend():\n             self._merge_into(res, self.process_next_part())\n             \n             \n         res_str = []\n         for key, value in sorted(res.items()):\n             res_str.append(key)\n             if value != 1:\n                 res_str.append(str(value))\n         return ''.join(res_str)\n         \n         \n     def process_next_part(self):\n         # Return i, dict_atoms\n         cur = self.cur()\n         if cur.isalpha():\n             name = self._consume_name()\n             value = self._consume_digit()\n             return {name: value}\n         elif cur == '(':\n             local_res = {}\n             self.consume()  # Consuming the '('\n             while self.cur() != ')':\n                 self._merge_into(local_res, self.process_next_part())\n             self.consume()  # Consuming the ')'\n             value = self._consume_digit()\n             return self._multiply(local_res, value)\n         else:\n             raise Exception(\"char unkwon\")\n \n \n     def _consume_name(self):\n         name = self.consume()\n         if not self.atend() and self.cur().isalpha() and self.cur().lower() == self.cur():\n             return name + self.consume()\n         return name\n         \n     def _consume_digit(self):\n         if self.atend() or not self.cur().isdigit():\n             return 1\n         res_str = self.consume()\n         while not self.atend() and self.cur().isdigit():\n             res_str += self.consume()\n         return int(res_str)\n \n", "class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         \n         def merge(d1, d2):\n             for k, v in list(d2.items()):\n                 if k in d1:\n                     d1[k] += v\n                 else:\n                     d1[k] = v\n                     \n         def mul(d, multiplier):\n             for k in list(d.keys()):\n                 d[k] *= multiplier\n                 \n         def helper(start):\n             c = formula[start]\n             els = {}\n             end = start\n             if c == '(':\n                 end += 1\n                 while formula[end] != ')':\n                     end, els2 = helper(end)\n                     merge(els, els2)\n                 end += 1\n             elif 'A' <= c <= 'Z':\n                 end += 1\n                 while end < len(formula) and 'a' <= formula[end] <= 'z':\n                     end += 1\n                 els[formula[start:end]] = 1\n             else:\n                 raise ValueError('Unexpected token')\n                 \n             end2 = end\n             while end2 < len(formula) and '0' <= formula[end2] <= '9':\n                 end2 += 1\n             count = int(formula[end:end2]) if end2 != end else 1\n             mul(els, count)\n             return end2, els\n         \n         \n         i, result = helper(0)\n         while i < len(formula):\n             i, els = helper(i)\n             merge(result, els)\n             \n         keys = sorted(result.keys())\n         s = \"\"\n         for k in keys:\n             if result[k] > 1:\n                 s+=\"%s%d\"%(k, result[k])\n             else:\n                 s+=k\n         return s\n         \n             \n", "from collections import Counter\n \n def tokenizer(formula):\n     result = []\n     \n     current_token = \"\"\n     \n     numbers = \"0123456789\"\n     \n     def append_current_token():\n         nonlocal current_token, result\n         \n         if current_token:\n             result.append(current_token)\n             current_token = \"\"\n     \n     for char in formula:\n         if char == \"(\":\n             append_current_token()\n             result.append(char)\n             \n         elif char == \")\":\n             append_current_token()\n             result.append(char)\n         \n         elif char in numbers:\n             if current_token and current_token[-1].isalpha():\n                 append_current_token()\n             \n             current_token += char\n             \n         elif char.isalpha():\n             if current_token and (current_token[-1] in numbers or char.isupper()) :\n                 append_current_token()\n             \n             current_token += char\n             \n     \n     append_current_token()\n     \n     return result\n     \n \n class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         result = Counter()\n         formula = tokenizer(formula)\n         \n         mult_stack = []\n         mult = 1\n         \n         precedent_number = 1\n         \n         for token in formula[::-1]:\n             if token.isdigit():\n                 n = int(token)\n                 precedent_number = n\n             \n             elif token.isalpha():\n                 result[token] += mult * precedent_number\n                 precedent_number = 1\n             \n             elif token == \")\":\n                 mult_stack.append(precedent_number)\n                 mult *= precedent_number\n                 precedent_number = 1\n             \n             elif token == \"(\":\n                 n = mult_stack[-1]\n                 mult_stack.pop()\n                 \n                 mult //= n\n         \n         \n         \n         str_result = []\n         \n         for token in sorted(result.keys()):\n                 str_result.append(token + str(result[token]) if result[token] != 1 else token)\n         \n         return ''.join(str_result)", "class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         atoms = self.helper(formula)\n         return ''.join([e + (str(c) if c > 1 else '') for e,c in sorted(atoms.items())])\n     \n     \n     def helper(self, formula):\n         i = 0\n         atoms = {}\n         while i < len(formula):\n             if formula[i] == '(':\n                 end = self.end_parens(formula, i)\n                 atom = self.helper(formula[i+1:end])\n             else:\n                 end = self.end_element(formula, i)\n                 atom = {formula[i:end+1]:1}\n                 \n             i = end + 1\n             mult = 0\n             while i < len(formula) and formula[i].isdigit():\n                 mult = mult * 10 + int(formula[i])\n                 i += 1\n                 \n             if mult == 0:\n                 mult = 1\n             \n             for element, count in atom.items():\n                 atoms.setdefault(element, 0)\n                 atoms[element] += count * mult\n         \n         return atoms\n                 \n \n     def end_element(self, formula, i):\n         i += 1\n         while i < len(formula) and formula[i].islower():\n             i += 1\n             \n         return i - 1\n \n \n     def end_parens(self, formula, start):\n         parens = 1\n         i = start + 1\n         while i < len(formula) and parens != 0:\n             if formula[i] in '()':\n                 parens += 1 if formula[i] == '(' else -1\n             i += 1\n         \n         return i - 1", "class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         stack = []\n         mapping = collections.defaultdict(int)\n         s = \"\"\n         num = 0\n         i = 0\n         while i < len(formula):\n             c = formula[i]\n             if c.islower():\n                 s += c\n                 i += 1\n             elif c.isdigit():\n                 num = 10 * num + int(c)\n                 i += 1\n             else:\n                 if s != \"\":\n                     mapping[s] = mapping[s] + num if num > 0 else mapping[s] + 1\n                 s = \"\"\n                 num = 0\n                 i += 1\n                 if c.isupper():\n                     s = c\n                 elif c == '(':\n                     stack.append(mapping)\n                     mapping = collections.defaultdict(int)\n                 elif c == ')':\n                     while i < len(formula) and formula[i].isdigit():\n                         num = 10 * num + int(formula[i])\n                         i += 1\n                     prev = stack.pop()\n                     for k in mapping:\n                         prev[k] += mapping[k] * num\n                     mapping = prev\n                     num = 0\n         if s != \"\":\n             mapping[s] = mapping[s] + num if num > 0 else mapping[s] + 1\n         ans = []\n         for k, v in sorted(mapping.items()):\n             ans.append(k)\n             if v > 1:\n                 ans.append(str(v))\n         return ''.join(ans)\n", "class Solution:\n     def countOfAtoms(self, formula):\n         \"\"\"\n         :type formula: str\n         :rtype: str\n         \"\"\"\n         \n         # stack = [dict()]\n         stack = [collections.Counter()]\n         i = 0\n         while i < len(formula):\n             if formula[i] == '(':\n                 # stack.append(dict())\n                 stack.append(collections.Counter())\n                 print('new stack', stack)\n                 i += 1\n             elif formula[i] == ')':\n                 i += 1\n                 \n                 num_start = i\n                 \n                 while i < len(formula) and formula[i].isdigit():\n                     i += 1\n                 \n                 mult = formula[num_start:i]\n                 \n                 if mult is '':\n                     mult = 1\n                 else:\n                     mult = int(formula[num_start:i])\n                     \n                 top = stack[-1]\n                 print('top: ', top)\n                 print('new mult: ', mult)\n                 stack.pop()\n                 print('poped top stack: ', stack)\n                 for name in top:\n                     stack[-1][name] = stack[-1][name] + top[name]*mult\n             else:\n                 name = formula[i]\n                 i += 1\n                 while i < len(formula) and formula[i].islower():\n                     name += formula[i]\n                     i += 1\n                     \n                 print('name of atom: ', name)\n                     \n                 num_start = i\n                 \n                 while i < len(formula) and formula[i].isdigit():\n                     i += 1\n                 \n                 mult = formula[num_start:i]\n                 \n                 if mult is '':\n                     mult = 1\n                 else:\n                     mult = int(formula[num_start:i])\n                 \n                 print('mult of {}: '.format(name), mult)\n                 \n                 stack[-1][name] += mult\n                 print('updated current stack: ', stack)\n         \n         return \"\".join(name + (str(stack[-1][name]) if stack[-1][name] > 1 else '')\n                        for name in sorted(stack[-1]))"]