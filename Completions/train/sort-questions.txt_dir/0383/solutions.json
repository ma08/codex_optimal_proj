["from collections import deque\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n\n        \n        def bfs(graph, seed, removed):\n            queue = deque(seed)\n            visited = seed\n            \n            while len(queue) > 0:\n                node = queue.popleft()\n                for next_node in range(len(graph[node])):\n                    if graph[node][next_node] == 0 or next_node in visited or next_node == removed:\n                        continue\n                    visited.add(next_node)\n                    queue.append(next_node)\n            return len(visited)\n                        \n        best = len(graph)\n        best_remove = initial[0]\n        initial = set(initial)\n        \n        for remove_node in initial:\n            initial_removed = initial - {remove_node}\n            node_result = bfs(graph, initial_removed, remove_node)\n\n            if (node_result < best) or (node_result == best) and (best_remove > remove_node):\n                best = node_result\n                best_remove = remove_node\n        return best_remove\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def dfs(i,s):\n            if i in visit or (i in ht and i!=s):\n                return\n            visit.add(i)\n            source[i].append(s)\n            for j in graph[i]:\n                dfs(j,s)\n     \n        ht=set(initial)\n        for i in range(len(graph)):\n            tmp=[]  \n            for j in range(len(graph[i])):\n                if graph[i][j]:\n                    tmp.append(j)\n            graph[i]=tmp\n                \n        source=[[] for _ in range(len(graph))]\n        for i in initial:\n            visit=set()\n            dfs(i,i)\n\n        dic=collections.defaultdict(int)\n        for i in range(len(source)):\n            if len(source[i])==1:\n                dic[source[i].pop()]+=1\n        res,val=len(graph),0\n        for i,cnt in list(dic.items()):\n            if cnt>val:\n                res,val=i,cnt\n            elif cnt==val:\n                res=min(res,i)\n\n        return res\n                \n                \n        \n", "import collections\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        numNodes = len(graph)\n        minSpread = float('inf')\n        minNode = None\n        initial.sort()\n        \n        for i in initial:\n            visited = set([i])\n            for j in initial:\n                self.helper(graph, j, visited)\n                        \n            if len(visited) < minSpread:\n                minSpread = len(visited)\n                minNode = i\n        \n        return minNode\n        \n    \n    def helper(self, graph, curr, visited):\n        if curr in visited:\n            return\n        \n        edges = graph[curr]\n        visited.add(curr)\n        \n        for i in range(len(edges)):\n            if graph[curr][i] == 1:\n                self.helper(graph, i, visited)\n                \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        \n        \n        \n        table={}\n        \n        for i in range(len(graph)):\n            table[i] = []\n        for i in range(len(graph)):\n            for j in range(i+1,len(graph[i])):\n                if graph[i][j] ==1:\n                    table[i].append(j)\n                    table[j].append(i)\n        \n        \n        print(table)\n        \n        def DFS(n,exclude_node):\n            for connect_node in table[n]:\n                if connect_node not in self.visited and connect_node != exclude_node:\n                    self.visited.append(connect_node)\n                    DFS(connect_node,exclude_node)\n        \n        res=[]\n        current_max = 0\n        \n        \n        for node in initial:\n            exclude = node\n            self.visited=[]\n            for i in range(len(initial)):\n                \n                if initial[i] != exclude:\n                    if initial[i] not in self.visited:\n                        self.visited.append(initial[i])\n                    DFS(initial[i],node)\n            left = len(graph)-len(self.visited)\n            if left >current_max:\n                res = [node]\n                current_max = left\n            elif left == current_max:\n                res.append(node)\n            print((node,self.visited))\n        \n        res.sort()\n        print(res)\n        return res[0]\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        d = collections.defaultdict(list)\n        for init in initial:\n            vis = set(initial)\n            Q = collections.deque([init])\n            while Q:\n                infect = Q.popleft()\n                for node in range(len(graph[infect])):\n                    if graph[infect][node] == 0:\n                        continue\n                    if node in vis:\n                        continue\n                    vis.add(node)\n                    d[node].append(init)\n                    Q.append(node)\n        res = [0]*n\n        for key in d:\n            if len(d[key])==1:\n                res[d[key][0]] += 1\n        if max(res) == 0: return min(initial)\n        return res.index(max(res))\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        index = 0\n        count = len(graph)\n        initial.sort()\n        def search(removed):\n            visited =set()\n            dfs = []\n            for i in initial:\n                if i != removed:\n                    dfs.append(i)\n            while dfs:\n                curr = dfs.pop()\n                if curr in visited:\n                    continue\n                visited.add(curr)\n                for n,i in enumerate(graph[curr]):\n                    if n == removed:\n                        continue\n                    if i:\n                        dfs.append(n)\n            return len(visited)\n        for i in initial:\n            z = search(i)\n            if z < count:\n                index = i\n                count = z\n        return index", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        index = 0\n        count = len(graph)\n        initial.sort()\n        def search(removed):\n            visited =set()\n            dfs = []\n            for i in initial:\n                if i != removed:\n                    dfs.append(i)\n            while dfs:\n                curr = dfs.pop()\n                if curr in visited:\n                    continue\n                visited.add(curr)\n                for n,i in enumerate(graph[curr]):\n                    if n == removed:\n                        continue\n                    if i:\n                        dfs.append(n)\n            return len(visited)\n        for i in initial:\n            z = search(i)\n            print(i, z)\n            if z < count:\n                index = i\n                count = z\n        return index", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        parent = list(range(n))\n        size = [1] * n\n\n        def find(u):\n            if parent[u] != u:\n                parent[u] = find(parent[u])\n            return parent[u]\n\n        def union(u, v):\n            x, y = find(u), find(v)\n            if x != y:\n                parent[y] = x\n                size[x] += size[y]\n\n        graph = [[v for v, x in enumerate(row) if x and u != v] for u, row in enumerate(graph)]\n        infected = [False] * n\n\n        for u in range(n):\n            if u in initial:\n                infected[u] = True\n\n        for u in range(n):\n            if not infected[u]:\n                for v in graph[u]:\n                    if not infected[v]:\n                        union(u, v)\n\n        threat = defaultdict(set)\n\n        for u in range(n): # find infected which threaten uninfected components\n            if not infected[u]:\n                for v in graph[u]:\n                    if infected[v]:\n                        threat[find(u)].add(v)\n\n        best = 0\n        best_idx = -1\n\n        for v in sorted(initial):   # for each infected\n            preventable = set()     # find sum of size of distinct uninfected components threatened by one and only one\n            for u in graph[v]:\n                if len(threat[find(u)]) == 1:\n                    preventable.add(find(u))\n            total = 1 + sum(size[u] for u in preventable)\n            if total > best:\n                best = total\n                best_idx = v\n        return best_idx\n", "from collections import defaultdict, Counter\n\nclass UF:\n    def __init__(self, keys):\n        self.uf = {}\n        for key in keys:\n            self.uf[key] = key\n\n    def find(self, x):\n        parent = self.uf[x]\n        if parent == x:\n            return x\n        ret = self.find(parent)\n        self.uf[x] = ret\n        return ret\n\n    def union(self, x, y):\n        xx = self.find(x)\n        yy = self.find(y)\n        self.uf[xx] = yy\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        initial.sort()\n        malware = set(initial)\n        uf = UF(range(len(graph)))\n        neighbors = defaultdict(set)\n        for i in range(len(graph)):\n            for j in range(len(graph[i])):\n                if graph[i][j] == 0:\n                    continue\n                elif i in malware and j in malware:\n                    continue\n                elif i in malware:\n                    neighbors[i].add(j)\n                elif j in malware:\n                    neighbors[j].add(i)\n                else:\n                    uf.union(i, j)\n        components = Counter([uf.find(x) for x in range(len(graph)) if x not in malware])\n        infected = defaultdict(set)\n        incoming = defaultdict(set)\n        for key, value in neighbors.items():\n            infected[key] = set([uf.find(x) for x in value])\n            for component in infected[key]:\n                incoming[component].add(key)\n        ret = initial[0]\n        score = 0\n        for mal in initial:\n            mal_score = 0\n            for component in infected[mal]:\n                if len(incoming[component]) == 1:\n                    mal_score += components[component]\n            if mal_score > score:\n                score = mal_score\n                ret = mal\n        print(components, neighbors, infected, incoming)\n        return ret", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def dfs(i,s):\n            if i in visit or (i in ht and i!=s):\n                return\n            visit.add(i)\n            source[i].append(s)\n            for j in graph[i]:\n                dfs(j,s)\n     \n        ht=set(initial)\n        for i in range(len(graph)):\n            tmp=[]  \n            for j in range(len(graph[i])):\n                if graph[i][j]:\n                    tmp.append(j)\n            graph[i]=tmp\n                \n        source=[[] for _ in range(len(graph))]\n        for i in initial:\n            visit=set()\n            dfs(i,i)\n\n        dic=collections.Counter()\n        for i in range(len(source)):\n            if len(source[i])==1:\n                dic[source[i].pop()]+=1\n        res,val=len(graph),0\n        for i,cnt in list(dic.items()):\n            if cnt>val:\n                res,val=i,cnt\n            elif cnt==val:\n                res=min(res,i)\n\n        return res\n                \n                \n        \n", "class UF:\n    def __init__(self, n):\n        self.arr = list(range(n + 1))\n        self.rank = [1] * (n + 1)\n    \n    def root(self, x):\n        curr = x\n        \n        while curr != self.arr[curr]:\n            curr = self.arr[curr]\n        return curr\n    \n    def union(self, x, y):\n        root_x = self.root(x)\n        root_y = self.root(y)\n        \n        rank_x = self.rank[root_x]\n        rank_y = self.rank[root_y]\n        \n        if rank_x >= rank_y:\n            self.arr[root_y] = root_x\n            self.rank[root_x] += rank_y\n        else:\n            self.arr[root_x] = root_y\n            self.rank[root_y] += rank_x\n            \nclass Solution:\n    \n    def dfs(self, root, seen, uf, intersection):\n        \n        for i, v in enumerate(self.graph[root]):\n            if v == 0:\n                continue\n            \n            if i in self.init_set:\n                if root not in intersection:\n                    intersection[root] = []\n                intersection[root].append(i)\n                continue\n                \n            uf.union(root, i)\n            if i in seen:\n                continue\n            seen.add(i)\n            self.dfs(i, seen, uf, intersection)\n        \n    \n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        self.graph = graph\n        self.init_set = set(initial)\n        initial.sort()\n        \n        uf = UF(len(graph[0]))\n        seen = set()\n        intersection = {}\n        for node in range(len(graph[0])):\n            if node in self.init_set:\n                continue\n            \n            self.dfs(node, seen, uf, intersection)\n        \n        islands = {}\n        for node in range(len(graph[0])):\n            root = uf.root(node)\n            if root not in islands:\n                islands[root] = set()\n            \n            if node in intersection:\n                for elt in intersection[node]:\n                    islands[root].add(elt)\n        #print(islands)\n        islandCounts = {}\n        for node in range(len(graph[0])):\n            root = uf.root(node)\n            if len(islands[root]) == 1:\n                for key in islands[root]:\n                    if key not in islandCounts:\n                        islandCounts[key] = 1\n                    else:\n                        islandCounts[key] += 1\n        #print(islandCounts)\n        if len(islandCounts) == 0:\n            return initial[0]\n        res = sorted(islandCounts, key = lambda x : (-islandCounts[x], x))\n        return res[0]\n            \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        conn = collections.defaultdict(set)\n        n = len(graph)\n        visited = [False] * n\n        for i in initial:\n            visited[i] = True\n            \n        def bfs(node):\n            q = collections.deque([node])\n            v = visited[:]\n            while q:\n                i = q.popleft()\n                for j, k in enumerate(graph[i]):\n                    if k and not v[j]:\n                        v[j] = True\n                        q.append(j)\n                        conn[j].add(node)\n        for i in initial:\n            bfs(i)\n        cnt = collections.Counter()\n        for k, v in list(conn.items()):\n            if len(v) == 1:\n                cnt[v.pop()] += 1\n        if not cnt:\n            return min(initial)\n        s = sorted(list(cnt.items()), key=lambda k: (k[1], -k[0]))\n        return s[-1][0]\n", "class Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        N = len(graph)\n        clean = set(range(N)) - set(initial)\n        def dfs(u, seen):\n            for v, adj in enumerate(graph[u]):\n                if adj and v in clean and v not in seen:\n                    seen.add(v)\n                    dfs(v, seen)\n\n        # For each node u in initial, dfs to find\n        # 'seen': all nodes not in initial that it can reach.\n        infected_by = {v: [] for v in clean}\n        for u in initial:\n            seen = set()\n            dfs(u, seen)\n\n            # For each node v that was seen, u infects v.\n            for v in seen:\n                infected_by[v].append(u)\n\n        # For each node u in initial, for every v not in initial\n        # that is uniquely infected by u, add 1 to the contribution for u.\n        contribution = collections.Counter()\n        for v, neighbors in infected_by.items():\n            if len(neighbors) == 1:\n                contribution[neighbors[0]] += 1\n\n        # Take the best answer.\n        best = (-1, min(initial))\n        for u, score in contribution.items():\n            if score > best[0] or score == best[0] and u < best[1]:\n                best = score, u\n        return best[1]", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        visited = [False] * n\n        for i in initial:\n            visited[i] = True\n        conn = [set() for i in range(n)]            \n        def bfs(node):\n            q = collections.deque([node])\n            v = visited[:]\n            while q:\n                i = q.popleft()\n                for j, k in enumerate(graph[i]):\n                    if k and not v[j]:\n                        v[j] = True\n                        q.append(j)\n                        conn[j].add(node)\n        for i in initial:\n            bfs(i)\n        cnt = collections.Counter()\n        for k, v in enumerate(conn):\n            if len(v) == 1:\n                cnt[v.pop()] += 1\n        if not cnt:\n            return min(initial)\n        s = sorted(list(cnt.items()), key=lambda k: (k[1], -k[0]))\n        return s[-1][0]\n", "class Solution:\n    def dfs(self, i, visited, graph):\n        if i in visited:\n            return\n        visited.add(i)\n        for x, edge in enumerate(graph[i]):\n            if edge:\n                self.dfs(x, visited, graph)\n    \n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        numInfected = float('inf')\n        minVal = None\n        initial.sort()\n        for i in initial:\n            visited = set([i])\n            for j in initial:\n                self.dfs(j, visited, graph)\n            if len(visited) < numInfected:\n                numInfected = len(visited)\n                minVal = i\n        \n        return minVal\n", "import collections\nclass Solution(object):\n    def minMalwareSpread(self, graph, initial):\n        N = len(graph)\n        clean = set(range(N)) - set(initial)\n        def dfs(u, seen):\n            for v, adj in enumerate(graph[u]):\n                if adj and v in clean and v not in seen:\n                    seen.add(v)\n                    dfs(v, seen)\n\n        # For each node u in initial, dfs to find\n        # 'seen': all nodes not in initial that it can reach.\n        infected_by = {v: [] for v in clean}\n        for u in initial:\n            seen = set()\n            dfs(u, seen)\n\n            # For each node v that was seen, u infects v.\n            for v in seen:\n                infected_by[v].append(u)\n\n        # For each node u in initial, for every v not in initial\n        # that is uniquely infected by u, add 1 to the contribution for u.\n        contribution = collections.Counter()\n        for v, neighbors in infected_by.items():\n            if len(neighbors) == 1:\n                contribution[neighbors[0]] += 1\n\n        # Take the best answer.\n        best = (-1, min(initial))\n        for u, score in contribution.items():\n            if score > best[0] or score == best[0] and u < best[1]:\n                best = score, u\n        return best[1]", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        #how many nodes\n        N = len(graph)\n        clean = set(range(N)) - set(initial)\n        def dfs(u, seen):\n            for v, adj in enumerate(graph[u]):\n                if adj and v in clean and v not in seen:\n                    seen.add(v)\n                    dfs(v, seen)\n\n        # For each node u in initial, dfs to find\n        # 'seen': all nodes not in initial that it can reach.\n        infected_by = {v: [] for v in clean}\n        for u in initial:\n            seen = set()\n            dfs(u, seen)\n\n            # For each node v that was seen, u infects v.\n            for v in seen:\n                infected_by[v].append(u)\n\n        # For each node u in initial, for every v not in initial\n        # that is uniquely infected by u, add 1 to the contribution for u.\n        contribution = collections.Counter()\n        for v, neighbors in infected_by.items():\n            if len(neighbors) == 1:\n                contribution[neighbors[0]] += 1\n        # Take the best answer.\n        best = (-1, min(initial))\n        for u, score in contribution.items():\n            if score > best[0] or score == best[0] and u < best[1]:\n                best = score, u\n        return best[1]", "from collections import defaultdict\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        if not graph:return -1\n        n = len(graph)\n        \n        initial = sorted(initial)\n        \n        clean = set([i for i in range(n)]) - set(initial)\n        infected_by = {i:[] for i in range(n)}\n        \n        def dfs(node):\n            for i,v in enumerate(graph[node]):\n                if v and i in clean and i not in seen:\n                    seen.add(i)\n                    dfs(i)\n        for node in initial:\n            seen = set()\n            dfs(node)\n            for u in seen:\n                infected_by[u].append(node)\n        \n        cnt = {v:0 for v in initial}\n        \n        for i in infected_by:\n            if len(infected_by[i]) == 1: \n                cnt[infected_by[i][0]] += 1\n        m = 0 \n        res = initial[0]\n        for i in cnt:\n            if cnt[i] > m:\n                res = i\n                m = cnt[i]\n        return res\n        \n", "from collections import Counter\n\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        # Depth First Search\n        # For each node v not in initial, we want to know which nodes u from initial can reach v in the graph G [with u (and its edges) added to G]. Let's say these nodes u \\\"infect\\\" v.\n        # Time  complexity: O(N^2)\n        # Space complexity: O(N)\n        N = len(graph)\n        clean = set(range(N)) - set(initial)\n        def dfs(u, seen):\n            for v, adj in enumerate(graph[u]):\n                if adj and v in clean and v not in seen:\n                    seen.add(v)\n                    dfs(v, seen)\n\n        # For each node u in initial, dfs to find\n        # 'seen': all nodes not in initial that it can reach.\n        infected_by = {v: [] for v in clean}\n        for u in initial:\n            seen = set()\n            dfs(u, seen)\n\n            # For each node v that was seen, u infects v.\n            for v in seen:\n                infected_by[v].append(u)\n\n        # For each node u in initial, for every v not in initial\n        # that is uniquely infected by u, add 1 to the contribution for u.\n        contribution = Counter()\n        for v, neighbors in list(infected_by.items()):\n            if len(neighbors) == 1:\n                contribution[neighbors[0]] += 1\n\n        # Take the best answer.\n        best = (-1, min(initial))\n        for u, score in list(contribution.items()):\n            if score > best[0] or score == best[0] and u < best[1]:\n                best = score, u\n\n        return best[1]\n\n\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        nodes = len(graph)\n        min_count = float('inf')\n        min_node = 0\n        for node in sorted(initial):\n            visited = set()\n            queue = deque()\n            count = 0\n            for i in initial:\n                if i != node and i not in visited:\n                    queue.append(i)\n                    visited.add(i)\n                    count += 1\n                    while queue:\n                        curr = queue.popleft()\n                        for i, edge in enumerate(graph[curr]):\n                            if edge == 1 and i != node and i not in visited:\n                                queue.append(i)\n                                visited.add(i)\n                                count += 1\n            if count < min_count:\n                min_count = count\n                min_node = node\n        return min_node\n            \n        \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        spreads = [[] for _ in range(len(graph))]\n        initial = set(initial)\n        for i in initial:\n            q = {i}\n            visited = set()\n            while q:\n                cur = q.pop()\n                if cur in visited or (cur in initial and cur != i):\n                    continue\n                visited.add(cur)\n                spreads[cur].append(i)\n                for j in range(len(graph[cur])):\n                    if graph[cur][j]:\n                        q.add(j)\n        counts = defaultdict(int)\n        for s in spreads:\n            if len(s) == 1:\n                counts[s[0]] += 1\n\n        most = next(iter(initial))\n        for i, c in list(counts.items()):\n            if c > counts[most] or (c == counts[most] and i < most):\n                most = i\n        return most\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        nodes = len(graph)\n        min_count = float('inf')\n        min_node = 0\n        for node in initial:\n            visited = set()\n            queue = deque()\n            count = 0\n            for i in initial:\n                if i != node and i not in visited:\n                    queue.append(i)\n                    visited.add(i)\n                    count += 1\n                    while queue:\n                        curr = queue.popleft()\n                        for i, edge in enumerate(graph[curr]):\n                            if edge == 1 and i != node and i not in visited:\n                                queue.append(i)\n                                visited.add(i)\n                                count += 1\n            if count < min_count or (count == min_count and node < min_node):\n                min_count = count\n                min_node = node\n        return min_node\n            \n        \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        bfs=[]\n        oinitial=set(initial)\n        for i in initial:\n            bfs.append([i,i])\n        #print(bfs)\n        frm={}\n        \n        \n        for init in initial:\n            seen=set(initial)\n            bfs=[init]\n            for n in bfs:\n                for i,c in enumerate(graph[n]):\n                    if i==n or i in seen or c==0:continue\n                    seen.add(i)\n                    if i in frm:\n                        frm[i].append(init)\n                    else:\n                        frm[i]=[init]\n                    bfs.append(i)\n        \n        #print(frm)\n        #print(src)\n        res=[0]*len(graph)\n        \n        for k in frm:\n            if len(frm[k])==1:\n                res[frm[k][0]]+=1\n        \n        \n        if max(res)==0:return min(initial)\n        \n        return res.index(max(res))\n                \n            \n            \n            \n        \n        \n        \n            \n                \n                \n            \n", "\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        numNodes, minSpread, minNode = len(graph), math.inf, None\n        initial.sort()\n        \n        def helper(curr, visited):\n\n            if curr in visited:return\n\n            edges = graph[curr]\n            visited.add(curr)\n\n            for i in range(len(edges)):\n                if graph[curr][i] == 1:\n                    helper(i, visited)     \n        \n        for i in initial:\n            visited = set([i])\n            for j in initial:\n                if i!= j:\n                    helper(j, visited)\n          \n            if len(visited) < minSpread:\n                minSpread = len(visited)\n                minNode = i\n        \n        return minNode\n        \n    \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        #build adjacent arrays to represent the graph\n        #go through the initial nodes and then do dfs, this could be be timeout.\n        d = collections.defaultdict(list)\n        for init in initial:\n            visit = set(initial)\n            q = collections.deque([init])\n            while q:\n                node = q.popleft()\n                for i in range(len(graph[node])):\n                    if graph[node][i] == 0 or i in visit:\n                        continue\n                    visit.add(i)\n                    d[i].append(init)\n                    q.append(i)\n                    \n        res = [0] * len(graph)\n        for m in d: #\u8fd9\u91cc\u51fa\u9519\u7684\uff0c\u662f\u91cc\u9762\u7684\u5143\u7d20\u800c\u4e0d\u662f\u7d22\u5f15\n        #for m in range(len(d)): wrong because d is dictionary, not array\n            if len(d[m]) == 1:\n                res[d[m][0]] += 1\n        if max(res) == 0: return min(initial) #\u4e3a\u4ec0\u4e48\u662fmin(initial)\u800c\u4e0d\u662finitial[0],\u9898\u610finitial\u91cc\u7684\u503c\u5c31\u662findex\n        return res.index(max(res))", "from functools import lru_cache\nfrom typing import List, Tuple\n\nimport numpy\nimport collections\n\nclass Solution:\n  def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n\n    const_n = len(graph)\n    d = collections.defaultdict(list)\n\n    for init in initial:\n      vis = set(initial)\n      q = collections.deque([init])\n      while q:\n        index = q.popleft()\n        for node in range(len(graph[index])):\n          if graph[index][node] == 0:\n            continue\n          if node in vis:\n            continue\n\n          vis.add(node)\n          d[node].append(init)\n          q.append(node)\n        pass\n      pass\n\n    res = [0] * const_n\n    for key, value in d.items():\n      if len(value) == 1:\n        res[value[0]] += 1\n\n    if max(res) == 0:\n      return min(initial)\n    return res.index(max(res))", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def dfs(i,s):\n            if i in visit or (i in ht and i!=s):\n                return\n            visit.add(i)\n            source[i].append(s)\n            for j in range(len(graph[i])):\n                if graph[i][j]:\n                    dfs(j,s)\n     \n        ht=set(initial)\n        source=[[] for _ in range(len(graph))]\n        for i in initial:\n            visit=set()\n            dfs(i,i)\n\n        dic=collections.defaultdict(int)\n        for i in range(len(source)):\n            if len(source[i])==1:\n                dic[source[i].pop()]+=1\n        res,val=len(graph),0\n        for i,cnt in list(dic.items()):\n            if cnt>val:\n                res,val=i,cnt\n            elif cnt==val:\n                res=min(res,i)\n\n        return res\n                \n                \n        \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        numNodes = len(graph)\n        minSpread = float('inf')\n        minNode = None\n        initial.sort()\n        \n        for i in initial:\n            visited = set([i])\n            for j in initial:\n                self.helper(graph, j, visited)\n          \n            if len(visited) < minSpread:\n                minSpread = len(visited)\n                minNode = i\n        \n        return minNode\n        \n    \n    def helper(self, graph, curr, visited):\n\n        if curr in visited:\n            return\n        \n        edges = graph[curr]\n        visited.add(curr)\n        \n        for i in range(len(edges)):\n            if graph[curr][i] == 1:\n                self.helper(graph, i, visited)        ", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        #build adjacent arrays to represent the graph\n        #go through the initial nodes and then do dfs, this could be be timeout.\n        d = collections.defaultdict(list)\n        for init in initial:\n            visit = set(initial)\n            q = collections.deque([init])\n            while q:\n                node = q.popleft()\n                for i in range(len(graph[node])):\n                    if graph[node][i] == 0 or i in visit:\n                        continue\n                    visit.add(i)\n                    d[i].append(init)\n                    q.append(i)\n                    \n        res = [0] * len(graph)\n        for m in d:\n        #for m in range(len(d)):\n            if len(d[m]) == 1:\n                res[d[m][0]] += 1\n        if max(res) == 0: return min(initial)\n        return res.index(max(res))", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        d = collections.defaultdict(list)\n        for init in initial:\n            vis = set(initial)\n            Q = collections.deque([init])\n            while Q:\n                infect = Q.popleft()\n                for node in range(len(graph[infect])):\n                    if graph[infect][node] == 0: continue\n                    if node in vis: continue\n                    vis.add(node)\n                    d[node].append(init)\n                    Q.append(node)\n        # count the most frequent node\n        res = [0] * n\n        for key in d:\n            if len(d[key]) == 1:\n                res[d[key][0]] += 1\n        if max(res) == 0: return min(initial)\n        return res.index(max(res))\n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        numNodes = len(graph)\n        minSpread = float('inf')\n        minNode = None\n        initial.sort()\n        \n        def helper(curr, visited):\n\n            if curr in visited:\n                return\n\n            edges = graph[curr]\n            visited.add(curr)\n\n            for i in range(len(edges)):\n                if graph[curr][i] == 1:\n                    helper(i, visited)     \n        \n        for i in initial:\n            visited = set([i])\n            for j in initial:\n                helper(j, visited)\n          \n            if len(visited) < minSpread:\n                minSpread = len(visited)\n                minNode = i\n        \n        return minNode\n        \n    \n", "\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        numNodes = len(graph)\n        minSpread = float('inf')\n        minNode = None\n        initial.sort()\n        \n        def helper(curr, visited):\n\n            if curr in visited:\n                return\n\n            edges = graph[curr]\n            visited.add(curr)\n\n            for i in range(len(edges)):\n                if graph[curr][i] == 1:\n                    helper(i, visited)     \n        \n        for i in initial:\n            visited = set([i])\n            for j in initial:\n                if i!= j:\n                    helper(j, visited)\n          \n            if len(visited) < minSpread:\n                minSpread = len(visited)\n                minNode = i\n        \n        return minNode\n        \n    \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        d = collections.defaultdict(list)\n        for init in initial:\n            vis = set(initial)\n            Q = collections.deque([init])\n            while Q:\n                infect = Q.popleft()\n                for node in range(len(graph[infect])):\n                    if graph[infect][node] == 0: continue\n                    if node in vis: continue\n                    vis.add(node)\n                    d[node].append(init)\n                    Q.append(node)\n        # count the most frequent node\n        res = [0] * n\n        for key in d:\n            if len(d[key]) == 1:\n                res[d[key][0]] += 1\n        if max(res) == 0: return min(initial)\n        return res.index(max(res))\n#         def find(x):\n#             if x != parents[x]:\n#                 parents[x] = find(parents[x])\n#             return parents[x]\n        \n#         def union(x,y):\n#             parents[find(x)] = parents[find(y)]\n            \n#         n = len(graph)\n#         parents = list(range(n))    \n#         for i in range(n):\n#             for j in range(i + 1, n):\n#                 if graph[i][j] == 1:\n#                     union(i , j)\n                    \n#         union = collections.Counter(find(i) for i in range(n))\n#         malware = collections.Counter(find(i) for i in initial)\n        \n#         save , res = min(initial) , 0\n#         for i in initial:\n#             if malware[find(i)] == 1:\n#                 if union[find(i)] > save:\n#                     save , res = union[find(i)] , i\n#                 elif union[find(i)] == save:\n#                     res = min(res, i)\n                    \n#         return res\n        \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        #build adjacent arrays to represent the graph\n        #go through the initial nodes and then do dfs, this could be be timeout.\n        d = collections.defaultdict(list)\n        for init in initial:\n            visit = set(initial)\n            q = collections.deque([init])\n            while q:\n                node = q.popleft()\n                for i in range(len(graph[node])):\n                    if graph[node][i] == 0 or i in visit:\n                        continue\n                    visit.add(i)\n                    d[i].append(init)\n                    q.append(i)\n                    \n        res = [0] * len(graph)\n        for m in d: #\u8fd9\u91cc\u51fa\u9519\u7684\uff0c\u662f\u91cc\u9762\u7684\u5143\u7d20\u800c\u4e0d\u662f\u7d22\u5f15\n        #for m in range(len(d)):\n            if len(d[m]) == 1:\n                res[d[m][0]] += 1\n        if max(res) == 0: return min(initial) #\u4e3a\u4ec0\u4e48\u662fmin(initial)\u800c\u4e0d\u662finitial[0],\u9898\u610finitial\u91cc\u7684\u503c\u5c31\u662findex\n        return res.index(max(res))", "from collections import Counter, defaultdict\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        # Total nodes\n        N = len(graph)\n        seen = set()\n        refcounter = Counter()\n        \n        #clean nodes which are not infected\n        clean_nodes = set(range(N)) - set(initial)\n        maxval = 0\n        \n        def dfs(node, seen):\n            for v, adj in enumerate(graph[node]):\n                if adj and v not in seen and v in clean_nodes:\n                    seen.add(node)\n                    dfs(v, seen)\n        \n        for key in initial:\n            seen = set()\n            dfs(key, seen)\n            refcounter[key] = len(seen)\n            if maxval < refcounter[key]:\n                maxval = refcounter[key]\n            seen.clear()\n\n        print(refcounter)\n        \n        maxlist = [ key for key,val in list(refcounter.items()) if refcounter[key] == maxval]\n        if not maxlist or len(maxlist) > 1:\n            return sorted(initial)[0]\n        return maxlist[0]\n        \n        \n            \n", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        d = collections.defaultdict(list)\n        for init in initial:\n            vis = set(initial)\n            Q = collections.deque([init])\n            while Q:\n                infect = Q.popleft()\n                for node in range(len(graph[infect])):\n                    if graph[infect][node] == 0: continue\n                    if node in vis: continue\n                    vis.add(node)\n                    d[node].append(init)\n                    Q.append(node)\n        # count the most frequent node\n        res = [0] * n\n        for key in d:\n            if len(d[key]) == 1:\n                res[d[key][0]] += 1\n        if max(res) == 0: return min(initial)\n        return res.index(max(res))", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        def infected(src, exclude=None):\n            infected = set()\n            def dfs(node, infected):\n                if node in infected:\n                    return\n                infected |= {node}\n                for neighbor in range(len(graph[node])):\n                    if graph[node][neighbor]==0 or neighbor==exclude:\n                        continue\n                    dfs(neighbor, infected)\n            for source in src:\n                if source == exclude:\n                    continue\n                dfs(source, infected)\n            return len(infected)\n        initial.sort()\n        res, best = initial[0], len(graph)\n        for source in initial:\n            temp = infected(initial, source)\n            if temp < best:\n                res, best = source, temp\n        return res", "class Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        \n        least_infections = len(graph)\n        node_to_remove = initial[0]\n        \n        for i in initial:\n            \n            total_infected = 0\n            \n            q = initial[:]\n            q.remove(i)\n            visited = set()\n            \n            while q != []:\n                # print(q)\n                v = q.pop()\n                if v != i and not v in visited:\n                    total_infected += 1\n                    visited.add(v)\n                    for j,edge in enumerate(graph[v]):\n                        if j!=i and (edge == 1) and not (j in visited):\n                            q.append(j)\n            \n            # print(total_infected,i)\n            \n            if total_infected < least_infections:\n                least_infections = total_infected\n                node_to_remove = i\n            elif total_infected == least_infections:\n                node_to_remove = min(i,node_to_remove)\n        \n        return node_to_remove\n                \n"]