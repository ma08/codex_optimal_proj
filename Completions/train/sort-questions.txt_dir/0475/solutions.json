["class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        # B: partial sum of A\n        # C: partial sum of B\n        # Use prefix sum to precompute B and C\n        A = nums\n        B, C = [0] * (n + 1), [0] * (n + 1)\n        for i in range(n):\n            B[i + 1] = B[i] + A[i]\n            C[i + 1] = C[i] + B[i + 1]\n\n        # Use two pointer to\n        # calculate the total number of cases if B[j] - B[i] <= score\n        def count_sum_under(score):\n            res = i = 0\n            for j in range(n + 1):\n                while B[j] - B[i] > score:\n                    i += 1\n                res += j - i\n            return res\n\n        # calculate the sum for all numbers whose indices are <= index k\n        def sum_k_sums(k):\n            score = kth_score(k)\n            res = i = 0\n            for j in range(n + 1):\n                # Proceed until B[i] and B[j] are within score\n                while B[j] - B[i] > score:\n                    i += 1\n                res += B[j] * (j - i + 1) - (C[j] - (C[i - 1] if i else 0))\n            return res - (count_sum_under(score) - k) * score\n\n        # use bisearch to find how many numbers ae below k\n        def kth_score(k):\n            l, r = 0, B[n]\n            while l < r:\n                m = (l + r) // 2\n                if count_sum_under(m) < k:\n                    l = m + 1\n                else:\n                    r = m\n            return l\n\n        # result between left and right can be converted to [0, right] - [0, left-1] (result below right - result below left-1)\n        return (sum_k_sums(right) - sum_k_sums(left - 1))%(10**9 + 7)", "import heapq\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        s = [0] + nums[:]\n        for i in range(1, len(s)):\n            s[i] += s[i - 1]\n        ss = [0] + s[:]\n        for i in range(1, len(ss)):\n            ss[i] += ss[i - 1]\n            \n        def findKthSum(k):\n            l, r = 0, s[-1]\n            while l < r:\n                mid = (l + r) // 2\n                if countSumsLeq(mid) < k:\n                    l = mid + 1\n                else:\n                    r = mid\n            return l\n        \n        def countSumsLeq(sv):\n            c = 0\n            l = 0\n            for r in range(len(s)):\n                while s[r] - s[l] > sv:\n                    l += 1\n                c += (r - l)\n            return c\n        \n        def getSumsUpToKth(k):\n            sv = findKthSum(k)\n            rv = 0\n            l = 0\n            for r in range(len(s)):\n                while s[r] - s[l] > sv:\n                    l += 1\n                # rv += s[r] * (r - l + 1) - (ss[r + 1] - ss[l])\n                rv += sum([s[r] - s[ll] for ll in range(l, r)])\n            return rv - (countSumsLeq(sv) - k) * sv\n        \n        return (getSumsUpToKth(right) - getSumsUpToKth(left - 1)) % (10 ** 9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        for i in range(n):      \n            sums.append(nums[i])\n            suma = nums[i]\n            for j in range(i+1, n):\n                suma += nums[j]\n                sums.append(suma)\n\n        sums = sorted(sums)\n\n        return sum(sums[left-1:right]) % (10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        mod = 10**9+7\n        dp = [0]\n        for i in range(n):\n            total = 0\n            for j in range(i,n):\n                total += nums[j]\n                dp.append(total)\n        \n        dp.sort()\n        for i in range(1,len(dp)):\n            dp[i] += dp[i-1]\n            dp[i] %= mod\n        \n        return (dp[right]-dp[left-1])%mod", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums=0\n        output=[]\n        final_sum=0\n        for i in range(0,(len(nums)*(len(nums)+1)//2)):\n            sums=0\n            for k in range(i,len(nums)):\n                sums=sums+nums[k]\n                output.append(sums)\n        output.sort()\n        for i in range(left-1,right):\n            final_sum=final_sum+output[i]\n        return int(final_sum % (1e9 + 7))\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        heap = []\n        prefix = [0] * (n+1)\n        for i in range(n):\n            prefix[i+1] = nums[i]+prefix[i]\n        for i in range(n):\n            for j in range(i+1, n+1):\n                heapq.heappush(heap, prefix[j]-prefix[i])\n        res = 0\n        for i in range(left-1):\n            heapq.heappop(heap)\n        for i in range(right-left+1):\n            res = (res+heapq.heappop(heap)) % (10**9+7)\n        return res\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums=0\n        output=[]\n        final_sum=0\n        for i in range(0,(len(nums)*(len(nums)+1)//2)):\n            sums=0\n            for k in range(i,len(nums)):\n                sums=sums+nums[k]\n                #print('sums',sums)\n                output.append(sums)\n        output.sort()\n        #print(output)\n        for i in range(left-1,right):\n            final_sum=final_sum+output[i]\n        \n        return int(final_sum % (1e9 + 7))\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        newArray = []\n        for i in range(n - 1):\n            sm = nums[i]\n            for j in range(i + 1, n):\n                sm += nums[j]\n                newArray.append(sm)\n        newArray += nums\n        newArray = sorted(newArray)\n        \n        res = 0\n        for i in range(left, right + 1):\n            res += newArray[i - 1]\n        res = res % (10 ** 9 + 7)\n        return res\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        h = [(x, i) for i, x in enumerate(nums)] #min-heap \n        heapify(h)\n        \n        ans = 0\n        for k in range(1, right+1): #1-indexed\n            x, i = heappop(h)\n            if k >= left: ans += x\n            if i+1 < len(nums): \n                heappush(h, (x + nums[i+1], i+1))\n                \n        return ans % 1_000_000_007\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        l = 1\n        ans = { 0: [x for x in nums] }\n        sums = [x for x in nums]\n        while l <= len(nums)-1:\n            nxt = []\n            prev = ans[l-1]\n            for i in range(len(prev)):\n                if i+l >= len(nums):\n                    break\n                nxt.append(prev[i] + nums[i+l])\n                sums.append(prev[i] + nums[i+l])\n            ans[l] = nxt\n            l += 1\n        #print(sums)\n        return sum(sorted(sums)[left-1: right]) % 1000000007\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        The idea is to keep track of range sums starting from nums[i] (i=0...n-1) in parallel in a priority queue of size n. In the beginning, the queue is initialized with (nums[i], i), i.e. just the starting element and its position. At each following step, pop the smallest x, i out of the queue, and perform below operations:\n\ncheck if step has reached left, add x to ans;\nextend the range sum x (currently ending at i) by adding nums[i+1] and in the meantime update the ending index to i+1.\nAfter right steps, ans would be the correct answer to return.\n\nO(N^2 logN) worst (but much faster on average) & O(N) space (32ms 100%)\n        '''\n        h = [(x, i) for i, x in enumerate(nums)] #min-heap \n        heapify(h)\n        \n        ans = 0\n        for k in range(1, right+1): #1-indexed\n            x, i = heappop(h)\n            if k >= left: ans += x\n            if i+1 < len(nums): \n                heappush(h, (x + nums[i+1], i+1))\n                \n        return ans % 1_000_000_007", "import heapq\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        s = [0] + nums[:]\n        for i in range(1, len(s)):\n            s[i] += s[i - 1]\n            \n        def findKthSum(k):\n            l, r = 0, s[-1]\n            while l < r:\n                mid = (l + r) // 2\n                if countSumsLeq(mid) < k:\n                    l = mid + 1\n                else:\n                    r = mid\n            return l\n        \n        def countSumsLeq(sv):\n            c = 0\n            l = 0\n            for r in range(len(s)):\n                while s[r] - s[l] > sv:\n                    l += 1\n                c += (r - l)\n            return c\n        \n        def getSumsUpToKth(k):\n            sv = findKthSum(k)\n            rv = 0\n            l = 0\n            for r in range(len(s)):\n                while s[r] - s[l] > sv:\n                    l += 1\n                # rv += s[r] * (r - l + 1) - (ss[r + 1] - ss[l])\n                rv += sum([s[r] - s[ll] for ll in range(l, r)])\n            return rv - (countSumsLeq(sv) - k) * sv\n        \n        return (getSumsUpToKth(right) - getSumsUpToKth(left - 1)) % (10 ** 9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        N = 10**9 + 7\n        pre = list(itertools.accumulate(nums))\n        a = []\n        for i in range(n):\n            for j in range(i, n):\n                a.append(pre[j] - pre[i] + nums[i])\n        a = sorted(a)\n        return sum(a[left-1:right])%N\n", "import numpy\nimport heapq\nimport re\nimport sys\nimport bisect\n\n\nclass Solution:\n  def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n\n    left -= 1\n    prefix_sum = []\n    for i in range(0, len(nums)):\n      tmp = []\n      sum = 0\n      for j in range(i, len(nums)):\n        sum = sum + nums[j]\n        tmp.append(sum)\n\n      prefix_sum.append(tmp)\n\n    hq = []\n    index_arr = []\n    for i in range(len(prefix_sum)):\n      index_arr.append(0)\n      heapq.heappush(hq, (prefix_sum[i][0], i))\n\n    for i in range(left):\n      value, index = heapq.heappop(hq)\n\n      index_arr[index] += 1\n      if index_arr[index] < len(prefix_sum[index]):\n        heapq.heappush(hq, (prefix_sum[index][index_arr[index]], index))\n\n    sum = 0\n    module = int(pow(10, 9) + 7)\n    for i in range(left, right):\n      value, index = heapq.heappop(hq)\n      sum += value\n      sum %= module\n      index_arr[index] += 1\n      if index_arr[index] < len(prefix_sum[index]):\n        heapq.heappush(hq, (prefix_sum[index][index_arr[index]], index))\n\n    return sum", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        stack=[]\n        tempstack=[]\n        sorted_nums=[]\n        modulo_num = (10 ** 9) + 7\n        \n        for i,num in enumerate(nums):\n            if i == 0:\n                stack.append(num)\n                continue\n            else:\n                while stack:\n                    val=stack.pop()\n                    heapq.heappush(sorted_nums,val)\n                    tempstack.append(val+num)\n                tempstack.append(num)\n                stack=tempstack\n                tempstack=[]\n                \n        while stack:\n            heapq.heappush(sorted_nums,stack.pop())\n            \n        start = 1\n        result = 0\n        \n        while start <= right:\n            if start < left:\n                start+=1\n                heapq.heappop(sorted_nums)\n            else:\n                result+=heapq.heappop(sorted_nums)\n                start+=1       \n                \n        return result % modulo_num  ", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        n = len(nums)\n        heap = [(x,i) for i,x in enumerate(nums)]\n        heapq.heapify(heap)\n        \n        res = 0\n        for j in range(1, right+1): # 1-indexed\n            x,i = heapq.heappop(heap)\n            if j>=left:\n                res += x\n            if i+1<n:\n                heapq.heappush(heap, (x+nums[i+1], i+1))\n        return res % (10**9+7)              ", "from heapq import heappush, heappop\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        maxHeap = []\n        \n        def maxHeapPush(val):\n            heappush(maxHeap, -val)\n        def maxHeapPop():\n            return -heappop(maxHeap)\n        def maxHeapPeek():\n            return -maxHeap[0]\n        def maxHeapLen():\n            return len(maxHeap)\n        \n        for i in range(len(nums)):\n            runningSum = 0\n            for j in range(i, len(nums)):\n                runningSum += nums[j]\n                if maxHeapLen() < right:\n                    maxHeapPush(runningSum)\n                elif maxHeapPeek() > runningSum:\n                    maxHeapPop()\n                    maxHeapPush(runningSum)\n                    \n        return sum(maxHeapPop() for _ in range(right - left + 1))%(10**9 + 7)\n        \n                \n                    \n", "import heapq\n\nclass Solution:\n    \n    def insert_heap(self, h, n, right):\n        \n        if len(h) < right :\n            heapq.heappush(h, -n)\n        \n        elif -h[0] > n:\n            heapq.heappop(h)\n            heapq.heappush(h, -n)\n            \n        \n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        h = []\n        \n        for i in range(len(nums)):\n            s = nums[i]\n            self.insert_heap(h, s, right)\n            \n            for j in range(i+1, len(nums)):\n                s += nums[j]\n                self.insert_heap(h, s, right)\n        \n        res = 0\n        for i in range(right-left+1):\n            res += -heapq.heappop(h)\n            \n        return res % 1000000007\n            \n        \n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        n = len(nums)\n        prefix = [0 for i in range(n+1)]\n        for i in range(n):\n            prefix[i+1] = prefix[i] + nums[i]\n\n        for k in range(2, n+1):\n            for i in range(n-k+1):\n                nums.append(prefix[i+k] - prefix[i])\n        \n        nums.sort()\n        # print(nums)\n        \n        t = 1000000007\n        ans = 0\n        for i in range(left, right+1):\n            ans = (nums[i-1]%t + ans%t)%t\n            \n        return ans", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = [nums[0]]\n        for i in range(1, n):\n            sums.append(sums[i-1]+nums[i])\n        for s in range(1, n):\n            for e in range(s, n):\n                sums.append(sums[e]-sums[s-1])\n        sums.sort()\n        acc = 0\n        for s in sums[left-1:right]:\n            acc = (acc + s) % (10**9 + 7)\n        return acc", "from heapq import heappush, heappop\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        maxHeap = []\n        \n        def maxHeapPush(val):\n            heappush(maxHeap, -val)\n        def maxHeapPop():\n            return -heappop(maxHeap)\n        def maxHeapPeek():\n            return -maxHeap[0]\n        def maxHeapLen():\n            return len(maxHeap)\n        \n        for i in range(len(nums)):\n            runningSum = 0\n            for j in range(i, len(nums)):\n                runningSum += nums[j]\n                if maxHeapLen() < right:\n                    maxHeapPush(runningSum)\n                elif maxHeapPeek() > runningSum:\n                    maxHeapPop()\n                    maxHeapPush(runningSum)\n        res = 0\n        elements = right - left + 1\n        while elements:\n            res += maxHeapPop()\n            elements -= 1\n        return res%(10**9 + 7)\n        \n                \n                    \n", "import heapq\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        left -= 1\n        right -= 1\n        sums = [nums[0]]\n        for i in range(1, n):\n            sums.append(sums[i-1]+nums[i])\n        heap = [-e for e in sums]\n        heapq.heapify(heap)\n        size = right+1\n        while len(heap) > size:\n            heapq.heappop(heap)\n        for s in range(1, n):\n            for e in range(s, n):\n                v = sums[s-1]-sums[e]\n                if len(heap) < size or v >= heap[0]:\n                    heapq.heappush(heap, v)\n                if len(heap) > size:\n                    heapq.heappop(heap)                   \n        acc = 0\n        for _ in range(right-left+1):\n            acc = (acc - heapq.heappop(heap)) % (10**9 + 7)\n        return acc", "import heapq\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        if not nums: return 0\n        \n        module = 10**9+7\n        \n        n = len(nums)\n        heap = [[nums[i], i] for i in range(n)]\n        heapq.heapify(heap)\n        \n        count = 0\n        ans = 0\n    \n        while heap:    \n            [val, idx] = heapq.heappop(heap)\n            count += 1\n            if count > right:\n                break\n            if count >= left:\n           \n                ans += val\n            \n            if idx+1 < n:\n                heapq.heappush(heap, [val+nums[idx+1], idx+1])\n        \n        return ans % module\n            \n            \n            \n            \n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        H = []\n        N = len(nums)\n        \n        for i in range(N):\n            s = nums[i]\n            heapq.heappush(H, s)\n            for j in range(i + 1, N):\n                s += nums[j]\n                heapq.heappush(H, s)\n        \n        for _ in range(left - 1):\n            heapq.heappop(H)\n            \n        result = 0\n        for _ in range(left, right + 1):\n            result += heapq.heappop(H)\n        \n        return result  % (10 ** 9 + 7)\n                \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        from heapq import heapify, heappop, heappush\n        \n        heap = [(number, index) for index, number in enumerate(nums)]\n        heapify(heap)\n        \n        sum_ = 0\n        \n        for index in range(1, right + 1, 1):\n            number, heap_index = heappop(heap)\n            if index >= left:\n                sum_ += number\n            if heap_index + 1 < len(nums):\n                heappush(heap, (number + nums[heap_index + 1], heap_index + 1))\n\n        return sum_ % (10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n\n        sums = {}\n        for i in range(n):\n            for j in range(i,n):\n                sums[(i,j)] = nums[j]\n                if j > i:\n                    sums[(i,j)] += sums[(i,j-1)]\n                    \n        s = sorted(sums.values())\n        # print(s)\n        # print(s[left-1: right])\n        ret = sum(s[left-1: right]) % (10**9 + 7)\n        return ret", "import heapq\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        stack = []\n        sub_nums = []\n        for i, num in enumerate(nums):\n            tmp_stack = []\n            if i == 0:\n                stack.append(num)\n                heapq.heappush(sub_nums, num)            \n                continue\n            while stack:\n                val = stack.pop()\n                tmp_stack.append(val + num)\n                heapq.heappush(sub_nums, val + num)                            \n            tmp_stack.append(num)\n            heapq.heappush(sub_nums, num)                                        \n            stack = tmp_stack\n        idx = 0\n        result = 0\n        while idx < right:\n            if idx < left - 1:             \n                idx += 1\n                heapq.heappop(sub_nums)\n            else:\n                result += heapq.heappop(sub_nums)\n                idx += 1       \n        return result % (10 ** 9 + 7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        \n        N = len(nums)\n        l = []\n        \n        for i in range(N):\n            s = 0\n            for j in range(i,N):\n                s += nums[j]\n                l.append(s)\n        totsum = sum(l)\n        self.quickselect(l,0,len(l)-1,left)\n        s1 = sum(l[:left-1])\n        #print(l)\n        self.quickselect(l,0,len(l)-1,right)\n        #print(l)\n        s2 = sum(l[right:])\n        #print(s1,s2,totsum)\n        #print(sorted(l))\n        return (totsum-s1-s2)%(10**9+7)\n    def quickselect(self,arr,l,h,k):\n        if(l>=h):\n            return\n        mid = int((l+h)/2)\n        x = arr[mid]\n        l1,h1 = self.partition(arr,l,h,x)\n        if(k>=l1+1 and k<=h1+1):\n            return\n        elif(k<l1+1):\n            return self.quickselect(arr,l,l1-1,k)\n        else:\n            return self.quickselect(arr,h1+1,h,k)\n    \n    def partition(self,arr,l,h,x):\n        l1 = l\n        h1 = h\n        m1 = l\n        while(m1<=h1):\n            if(arr[m1]==x):\n                m1 += 1\n            elif(arr[m1]<x):\n                arr[l1],arr[m1] = arr[m1],arr[l1]\n                l1 += 1\n                m1 += 1\n            else:\n                arr[h1],arr[m1] = arr[m1],arr[h1]\n                h1 -= 1\n        return l1,h1", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        l = len(nums)\n        a = [[0 for x in range(l)] for y in range(l)] \n        s = 0\n        t = []\n        MOD = 1000000007\n        for i in range(0,l):\n            s = s+nums[i]\n            a[0][i] = s\n            t.append(a[0][i])\n        for i in range(1,l):\n            a[i][l-1] = s - a[0][i-1]\n            t.append(a[i][l-1])\n        for i in range(1,l):\n            for j in range(i,l-1):\n                a[i][j] = s - a[0][i-1] - a[j+1][l-1]\n                t.append(a[i][j])\n        t.sort()\n        \n        b = 0\n        \n        for  i in range(left-1,right):\n            b=(b+t[i])%MOD\n        return b\n", "from queue import PriorityQueue\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        pq = PriorityQueue()\n        sz = len(nums)\n\n        for i, val in enumerate(nums):\n            pq.put((val, i))\n\n        ans = 0\n        mod = 10 ** 9 + 7\n        for i in range(1, right + 1):\n            cur = pq.get()\n            if i >= left:\n                ans = (ans + cur[0]) % mod\n            if cur[1] < sz - 1:\n                pq.put((cur[0] + nums[cur[1]+1], cur[1] + 1))\n\n        return ans", "#import heapq\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        if not nums: return 0\n        \n        module = 10**9+7\n        \n        n = len(nums)\n        heap = [[nums[i], i] for i in range(n)]\n        heapq.heapify(heap)\n        \n        count = 0\n        ans = 0\n    \n        while heap:    \n            [val, idx] = heapq.heappop(heap)\n            count += 1\n            if count > right:\n                break\n            if count >= left:\n           \n                ans += val % module\n            \n            if idx+1 < n:\n                heapq.heappush(heap, [val+nums[idx+1], idx+1])\n        \n        return ans % module\n            \n        '''\n        \n        def subArraySum(target):\n            # return the number of subarrays whose sums less than or equal to target\n            \n            count = 0\n            left, right = 0, 0\n            running_sum = 0\n            sub_sum     = 0\n            overall_sum = 0          \n            \n            while right < n:\n                running_sum += nums[right]\n                sub_sum += nums[right]*(right-left+1)\n                while left <= right and running_sum > target:\n                    sub_sum -= running_sum\n                    running_sum -= nums[left]\n                    left += 1\n                    \n                count += right-left+1\n                \n                overall_sum += sub_sum\n                \n                right += 1\n            \n            return count, overall_sum%(10**9+7)\n        \n        def findSum(target):\n            # return the sum of first target-th element of non-decreasing ordered subarray sum\n            if target == 0:\n                return 0\n            \n            # Binary search\n            l, r = min(nums)-1, sum(nums)+1\n\n            while l+1 < r:\n                m = l + (r-l)//2\n\n                count, _ = subArraySum(m)\n                \n                if count < target:\n                    l = m\n                else:\n                    r = m\n                    \n            count, summ = subArraySum(r)\n    \n            return summ - (r%(10**9+7))*(count-target)\n            \n    \n        return findSum(right)%(10**9+7) - findSum(left-1)%(10**9+7)\n                    \n                    \n                    \n            \n            \n            \n        \n            \n            \n        \n", "from queue import PriorityQueue\n\nclass Solution:\n    def rangeSum(self, nums: List[int], total: int, left: int, right: int) -> int:\n        pq = PriorityQueue()\n        for i, n in enumerate(nums):\n            pq.put((n, i))\n        j, ans = 0, 0\n        while not pq.empty():\n            n, i = pq.get()\n            j += 1\n            if j >= left and j <= right:\n                ans = (ans + n) % 1000000007\n            elif j > right:\n                return ans\n            if i<total-1:\n                pq.put((n+nums[i+1], i+1))\n        return ans\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        rsum = []\n        for i in range(n):\n            sums = [nums[i]]\n            for j in range(i+1, n):\n                sums.append(sums[-1] + nums[j])\n            rsum.append(sums)\n        def merge(arr1, arr2):\n            i1 = i2 = 0\n            arr = []\n            while True:\n                if arr1[i1] <= arr2[i2]:\n                    arr.append(arr1[i1])\n                    i1 += 1\n                    if i1 >= len(arr1):\n                        for j in range(i2, len(arr2)):\n                            arr.append(arr2[j])\n                        return arr\n                else:\n                    arr.append(arr2[i2])\n                    i2 += 1\n                    if i2 >= len(arr2):\n                        for j in range(i1, len(arr1)):\n                            arr.append(arr1[j])\n                        return arr\n        #print(rsum)\n        while len(rsum) >= 2:\n            rsum_new = []\n            i = 0\n            while i < len(rsum) - 1:\n                rsum_new.append(merge(rsum[i], rsum[i+1]))\n                i += 2\n            if i < len(rsum):\n                rsum_new.append(rsum[i])\n            rsum = rsum_new\n        v = 0\n        rsum = rsum[0]\n        #print(rsum)\n        for i in range(left-1, right):\n            v += rsum[i]\n        return v % (10**9+7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                sums.append(sum(nums[i:j]))\n        sums.sort()\n        return sum(sums[left-1:right]) % ((10**9) + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        sarray = []\n        mod = 10**9+7\n        for i in range(n):\n            for j in range(i, n):\n                sarray.append(sum(nums[i:j+1]))\n        sarray.sort()\n        \n        return sum(sarray[left-1:right]) % mod\n                \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        res=[]\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)+1):\n                res.append(sum(nums[i:j]))\n        res.sort()\n        return sum(res[left-1:right])%(10**9+7)\n", "class Solution:\n    def rangeSum_ref(self, nums: List[int], n: int, left: int, right: int) -> int:\n            res=[]\n            for i in range(n):\n                summ=0\n                for j in nums[i:]:\n                    summ+=j\n                    res.append(summ)\n                    \n            res.sort()\n            ans = sum(res[left-1:right])\n                \n            return int(ans%(10**9+7))\n        \n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        heap = [(nums[k], k) for k in range(n)]\n        heap.sort()\n        \n        cnt, sumV = 0, 0\n        while(cnt < right):\n            cnt, ele = cnt+1, heap.pop(0)\n            if cnt >= left:\n                sumV += ele[0]\n                \n            # insert new element if existed.\n            nk = ele[1] + 1\n            if nk < len(nums):\n                new_ele = (ele[0]+nums[nk], nk)\n                k = len(heap)-1\n                while(k>=0 and heap[k][0]>new_ele[0]):\n                    k -= 1\n                heap = heap[:k+1] + [new_ele] + heap[k+1:]\n        \n        return sumV%(10**9+7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        ans=[]\n        L=len(nums)\n        for i in range(L):\n            for j in range(i+1,L+1):\n                ans.append(sum(nums[i:j]))\n        ans.sort()\n        return sum(ans[left-1:right])%(10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        new_n = []\n        count = 0\n        for i in range(n+1):\n            for j in range(i+1, n+1):\n                new_n.append(sum(nums[i:j]))\n        new_n.sort()\n        return sum(new_n[left-1:right])%(10**9 +7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        res = list()\n        for i in range(len(nums)):\n            for j in range(i,len(nums)):\n                res.append(sum(nums[i:j+1]))\n        res.sort()\n        #print(res)\n        return sum(res[left-1:right])%(10**9+7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        rangeSum = []\n        mod = 10 ** 9 + 7\n        \n        for i in range(n):\n            rangeSum.append(nums[i])\n            for j in range(i):\n                rangeSum.append(sum(nums[j:i]) + nums[i])\n                \n            #print (rangeSum)\n        \n        rangeSum.sort()\n        \n        ans = 0\n        for i in range(left-1, right):\n            ans += rangeSum[i] % mod \n        \n        return ans % mod\n        \n        \n            \n            \n        \n", "#import heapq\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        if not nums: return 0\n        \n        module = 10**9+7\n        \n        n = len(nums)\n        heap = [[nums[i], i] for i in range(n)]\n        heapq.heapify(heap)\n        \n        count = 0\n        ans = 0\n    \n        while heap:    \n            [val, idx] = heapq.heappop(heap)\n            count += 1\n            if count > right:\n                break\n            if count >= left:\n           \n                ans += val % module\n            \n            if idx+1 < n:\n                heapq.heappush(heap, [val+nums[idx+1], idx+1])\n        \n        return ans % module\n            \n        '''\n        \n        def subArraySum1(target):\n            # return the number of subarrays whose sums less than or equal to target\n            \n            count = 0\n            left, right = 0, 0        \n            running_sum = 0\n            \n            while right < n:\n                running_sum += nums[right]\n   \n                while left <= right and running_sum > target:\n\n                    running_sum -= nums[left]\n                    left += 1\n                    \n                count += right-left+1\n                \n                right += 1\n            \n            return count\n        \n        def subArraySum2(target):\n            # return the number of subarrays whose sums less than or equal to target\n            \n            count = 0\n            left, right = 0, 0\n            running_sum = 0\n            sub_sum     = 0\n            overall_sum = 0          \n            \n            while right < n:\n                running_sum += nums[right]\n                sub_sum += nums[right]*(right-left+1)\n                while left <= right and running_sum > target:\n                    sub_sum -= running_sum\n                    running_sum -= nums[left]\n                    left += 1\n                    \n                count += right-left+1\n                \n                overall_sum += sub_sum\n                \n                right += 1\n            \n            return count, overall_sum\n        \n        def findSum(target):\n            # return the sum of first target-th element of non-decreasing ordered subarray sum\n            if target == 0:\n                return 0\n            \n            # Binary search\n            l, r = min(nums)-1, sum(nums)+1\n\n            while l+1 < r:\n                m = l + (r-l)//2\n\n                count = subArraySum1(m)\n                \n                if count < target:\n                    l = m\n                else:\n                    r = m\n                    \n            count, summ = subArraySum2(r)\n    \n            return summ%(10**9+7) - (r%(10**9+7))*(count-target)\n            \n    \n        return (findSum(right) - findSum(left-1))%(10**9+7)\n                    \n                    \n                    \n            \n            \n            \n        \n            \n            \n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        ans = []\n        indx = 0\n        while indx <= n:\n            add = 0\n            for i in range(indx, n):\n                add += sum(nums[indx:i+1])\n                ans.append(add)\n                add = 0\n            indx += 1\n        ans.sort()\n\n        return sum(ans[left-1:right]) % (10 ** 9 + 7)\n                \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        count1=0\n        rt=[]\n        while(count1<len(nums)):\n            count2=len(nums)-1\n            while(count2>=count1):\n               \n                sum2=sum(nums[count1:count2+1])\n                rt.append(sum2)\n                count2=count2-1\n            count1=count1+1\n        rt.sort()\n        a=pow(10,9)+7\n        if sum(rt[left-1:right]) > pow(10,9)+7:\n            return sum(rt[left-1:right])%1000000007\n        else:\n            return sum(rt[left-1:right])\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        arr = [ \n            sum(nums[i:j])\n            for i in range(n)\n            for j in range(i+1, n+1)\n        ]\n        return sum(sorted(arr)[left-1:right]) % (10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        for i,x in enumerate(nums):\n            sums.append(x)\n            for j,y in enumerate(nums[i+1:]):\n                sums.append(sum(nums[i:i+j+2]))\n        sums.sort()\n        #print(sums)\n        return sum(sums[left-1:right]) % (10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        result = []\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                result.append(sum(nums[i: j+1]))\n        result.sort()\n        return sum(result[left-1: right]) % (10**9 + 7)\n        \n                           \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        ssum = nums[:]\n        for ssize in range(2,n+1):\n            ssum.extend([sum(nums[i:i+ssize]) for i in range(n-ssize+1)])\n        ssum.sort()\n        for i in range(n*(n+1)//2):\n            ssum[i] %= int(1e9+7)\n        return sum(ssum[left-1:right]) % int(1e9+7)", "class Solution:\n    def rangeSum(self, nums, n, left, right):\n        l=[]\n        mod=10**9+7\n        for i in range(len(nums)):\n            for j in range(i,len(nums)):\n                l.append(sum(nums[i:j+1]))\n        l.sort()\n        return sum(l[left-1:right])%mod\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        A = (nums[i:j] for i in range(len(nums)) for j in range(i + 1, len(nums) + 1))\n        x = sorted(map(sum, A))\n        return sum(x[left - 1:right]) % (10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        subarr = [sum(nums[i:i+j]) for i in range(0,len(nums)) for j in range(1,len(nums)-i+1)]\n        subarr = sorted(subarr)\n        return sum(subarr[left-1:right])%(10**9+7)", "#import heapq\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        if not nums: return 0\n        \n        module = 10**9+7\n        \n        n = len(nums)\n        heap = [[nums[i], i] for i in range(n)]\n        heapq.heapify(heap)\n        \n        count = 0\n        ans = 0\n    \n        while heap:    \n            [val, idx] = heapq.heappop(heap)\n            count += 1\n            if count > right:\n                break\n            if count >= left:\n           \n                ans += val % module\n            \n            if idx+1 < n:\n                heapq.heappush(heap, [val+nums[idx+1], idx+1])\n        \n        return ans % module\n            \n        '''\n        \n        def subArraySum(target):\n            # return the number of subarrays whose sums less than or equal to target\n            \n            count = 0\n            left, right = 0, 0\n            running_sum = 0\n            sub_sum     = 0\n            overall_sum = 0          \n            \n            while right < n:\n                running_sum += nums[right]\n                sub_sum += nums[right]*(right-left+1)\n                while left <= right and running_sum > target:\n                    sub_sum -= running_sum\n                    running_sum -= nums[left]\n                    left += 1\n                    \n                count += right-left+1\n                \n                overall_sum += sub_sum\n                \n                right += 1\n            \n            return count, overall_sum\n        \n        def findSum(target):\n            # return the sum of first target-th element of non-decreasing ordered subarray sum\n            if target == 0:\n                return 0\n            \n            # Binary search\n            l, r = min(nums)-1, sum(nums)+1\n\n            while l+1 < r:\n                m = l + (r-l)//2\n\n                count, _ = subArraySum(m)\n                print((m,subArraySum(m)))\n                if count < target:\n                    l = m\n                else:\n                    r = m\n                    \n            count, summ = subArraySum(r)\n    \n            return summ - r*(count-target)\n            \n    \n        return (findSum(right) - findSum(left-1))%(10**9+7)\n                    \n                    \n                    \n            \n            \n            \n        \n            \n            \n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        res = []\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                k = sum(nums[i:j+1])\n                res.append(k)\n        res.sort()\n        \n        return sum(res[left-1:right])%(10**9+7)\n            \n                \n", "# from heapq import heappush, heappop\n# class Solution:\n#     def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n#         maxHeap = []\n        \n#         def maxHeapPush(val):\n#             heappush(maxHeap, -val)\n#         def maxHeapPop():\n#             return -heappop(maxHeap)\n#         def maxHeapPeek():\n#             return -maxHeap[0]\n#         def maxHeapLen():\n#             return len(maxHeap)\n        \n#         for i in range(len(nums)):\n#             runningSum = 0\n#             for j in range(i, len(nums)):\n#                 runningSum += nums[j]\n#                 if maxHeapLen() < right:\n#                     maxHeapPush(runningSum)\n#                 elif maxHeapPeek() > runningSum:\n#                     maxHeapPop()\n#                     maxHeapPush(runningSum)\n                    \n#         return sum(maxHeapPop() for _ in range(right - left + 1))%(10**9 + 7)\n        \n#O(N^2) \nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n            res=[sum(nums[i:j]) for i in range(len(nums)+1) for j in range(i+1, len(nums)+1)]\n            # for i in range(len(nums)):\n            #     summ = 0\n            #     for j in nums[i:]:\n            #         summ +=j\n            #         res.append(summ)\n                \n            res.sort()\n            return sum(res[left-1:right])%(10**9+7)\n        \n#O(N^3) \nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        return sum(sorted([sum(nums[i:j]) for i in range(len(nums)+1) for j in range(i+1, len(nums)+1)])[left-1:right])%(10**9+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        MOD = 1000000007\n        s = [sum(nums[i:i+j]) for i in range(0, len(nums)) for j in range(1, len(nums)-i+1)]\n\n        sorted_s = sorted(s)\n\n        return sum(sorted_s[left - 1: right]) % MOD", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        listx=[sum(nums[i:j]) for i in range(0,len(nums)) for j in range(i+1,len(nums)+1)]\n        listx.sort()\n        return sum(listx[left-1:right])%((10**9 + 7))", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        res = nums\n        for i in range(len(nums)-1):\n            j = i+1\n            while j < n:\n                res.append(sum(nums[i:j+1]))\n                j += 1\n        return sum(sorted(res)[left-1:right]) % (10**9 + 7)\n", "MAX = 10 ** 9 + 7\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        subs = subarrays(nums, n)\n        subs.sort()\n        return sum(subs[left-1:right]) % MAX\n    \ndef subarrays(nums: List[int], n: int) -> List[int]:\n    r = [] # result\n    for i in range(0, len(nums)):\n        for j in range(i+1, min(i+n, len(nums)) + 1):\n            r.append(sum(nums[i:j]))\n    return r", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        #two pointer approach? \n        sums = []\n        for L in range(len(nums)):\n            R = len(nums)\n            #print(L,R)\n            while(L<R):\n                sums.append(sum(nums[L:R]))\n                R-=1\n        sums.sort()\n        #print(sums)\n        return sum(sums[left-1:right])%(10**9+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        arr = []\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                arr.append(sum(nums[i:j]))\n        arr.sort()\n        return sum(arr[left - 1: right]) % (10**9 + 7)", "class Solution:\n    \n    def __init__(self):\n        self.all_pos_array = []\n    \n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        while len(self.all_pos_array) < right:\n            for i in range(0,len(nums)):\n                for j in range(i,len(nums)):\n                    self.all_pos_array.append(sum(nums[i:j+1]))\n        \n        return sum(sorted(self.all_pos_array)[left-1:right]) % (10**9 +7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        l = []\n        val = 0\n        \n        prefix = [nums[0]]        \n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums) + 1):\n                l.append(sum(nums[i:j]))\n        \n        l.sort()\n        return sum(l[left - 1: right]) % (1000000000 + 7)", "#import heapq\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        if not nums: return 0\n        \n        module = 10**9+7\n        \n        n = len(nums)\n        heap = [[nums[i], i] for i in range(n)]\n        heapq.heapify(heap)\n        \n        count = 0\n        ans = 0\n    \n        while heap:    \n            [val, idx] = heapq.heappop(heap)\n            count += 1\n            if count > right:\n                break\n            if count >= left:\n           \n                ans += val % module\n            \n            if idx+1 < n:\n                heapq.heappush(heap, [val+nums[idx+1], idx+1])\n        \n        return ans % module\n            \n        '''\n        \n        def subArraySum(target):\n            # return the number of subarrays whose sums less than or equal to target\n            \n            count = 0\n            left, right = 0, 0\n            running_sum = 0\n            sub_sum     = 0\n            overall_sum = 0          \n            \n            while right < n:\n                running_sum += nums[right]\n                sub_sum += nums[right]*(right-left+1)\n                while left <= right and running_sum > target:\n                    sub_sum -= running_sum\n                    running_sum -= nums[left]\n                    left += 1\n                    \n                count += right-left+1\n                \n                overall_sum += sub_sum\n                \n                right += 1\n            \n            return count, overall_sum\n        \n        def findSum(target):\n            # return the sum of first target-th element of non-decreasing ordered subarray sum\n            if target == 0:\n                return 0\n            \n            # Binary search\n            l, r = min(nums)-1, sum(nums)+1\n\n            while l+1 < r:\n                m = l + (r-l)//2\n\n                count, _ = subArraySum(m)\n                print((m,subArraySum(m)))\n                if count < target:\n                    l = m\n                else:\n                    r = m\n                    \n            count, summ = subArraySum(r)\n    \n            return summ%(10**9+7) - r*(count-target)\n            \n    \n        return (findSum(right) - findSum(left-1))%(10**9+7)\n                    \n                    \n                    \n            \n            \n            \n        \n            \n            \n        \n", "class Solution:\n    \n    def __init__(self):\n        self.all_pos_array = []\n    \n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        for i in range(0,len(nums)):\n            for j in range(i,len(nums)):\n                self.all_pos_array.append(sum(nums[i:j+1]))\n        \n        return sum(sorted(self.all_pos_array)[left-1:right]) % (10**9 +7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        l=[]\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)+1):\n                l.append(sum(nums[i:j]))\n        l.sort()\n        return sum(l[left-1:right])%(10**9+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        mod = math.pow(10, 9) + 7\n        \n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                sums.append(sum(nums[i:j+1]))\n                \n        return int(sum(sorted(sums)[left - 1:right]) % mod)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        l,r = left-1,right-1\n        cur = []\n        for i in range(len(nums)):\n            for j in range(i,len(nums)):\n                cur.append(sum(nums[i:j+1]))\n        cur.sort()\n        return sum(cur[l:r+1]) %(10**9+7)", "#import heapq\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        if not nums: return 0\n        \n        module = 10**9+7\n        \n        n = len(nums)\n        heap = [[nums[i], i] for i in range(n)]\n        heapq.heapify(heap)\n        \n        count = 0\n        ans = 0\n    \n        while heap:    \n            [val, idx] = heapq.heappop(heap)\n            count += 1\n            if count > right:\n                break\n            if count >= left:\n           \n                ans += val % module\n            \n            if idx+1 < n:\n                heapq.heappush(heap, [val+nums[idx+1], idx+1])\n        \n        return ans % module\n            \n        '''\n        \n        def subArraySum(target):\n            # return the number of subarrays whose sums less than or equal to target\n            \n            count = 0\n            left, right = 0, 0\n            running_sum = 0\n            sub_sum     = 0\n            overall_sum = 0          \n            \n            while right < n:\n                running_sum += nums[right]\n                sub_sum += nums[right]*(right-left+1)\n                while left <= right and running_sum > target:\n                    sub_sum -= running_sum\n                    running_sum -= nums[left]\n                    left += 1\n                    \n                count += right-left+1\n                \n                overall_sum += sub_sum\n                \n                right += 1\n            \n            return count, overall_sum\n        \n        def findSum(target):\n            # return the sum of first target-th element of non-decreasing ordered subarray sum\n            if target == 0:\n                return 0\n            \n            # Binary search\n            l, r = min(nums)-1, sum(nums)+1\n\n            while l+1 < r:\n                m = l + (r-l)//2\n\n                count, _ = subArraySum(m)\n                \n                if count < target:\n                    l = m\n                else:\n                    r = m\n                    \n            count, summ = subArraySum(r)\n    \n            return summ%(10**9+7) - r*(count-target)\n            \n    \n        return (findSum(right) - findSum(left-1))%(10**9+7)\n                    \n                    \n                    \n            \n            \n            \n        \n            \n            \n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        arr = []\n        for i in range(len(nums)):\n            arr.extend(accumulate(nums[i:]))\n        arr.sort()\n        return sum(arr[left-1:right]) % (10**9 + 7)", "from itertools import accumulate\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        result = []\n        for i in range(n):\n            result.extend(list(accumulate(nums[i:])))\n        result.sort()\n        return sum(result[left-1:right]) % (10**9+7)\n", "class Solution:\n    def rangeSum(self, A, n, left, right):\n        # B: partial sum of A\n        # C: partial sum of B\n        # Use prefix sum to precompute B and C\n        B, C = [0] * (n + 1), [0] * (n + 1)\n        for i in range(n):\n            B[i + 1] = B[i] + A[i]\n            C[i + 1] = C[i] + B[i + 1]\n\n        # Use two pointer to\n        # calculate the total number of cases if B[j] - B[i] <= score\n        def count_sum_under(score):\n            res = i = 0\n            for j in range(n + 1):\n                while B[j] - B[i] > score:\n                    i += 1\n                res += j - i\n            return res\n\n        # calculate the sum for all numbers whose indices are <= index k\n        def sum_k_sums(k):\n            score = kth_score(k)\n            res = i = 0\n            for j in range(n + 1):\n                # Proceed until B[i] and B[j] are within score\n                while B[j] - B[i] > score:\n                    i += 1\n                res += B[j] * (j - i + 1) - (C[j] - (C[i - 1] if i else 0))\n            return res - (count_sum_under(score) - k) * score\n\n        # use bisearch to find how many numbers ae below k\n        def kth_score(k):\n            l, r = 0, B[n]\n            while l < r:\n                m = (l + r) // 2\n                if count_sum_under(m) < k:\n                    l = m + 1\n                else:\n                    r = m\n            return l\n\n        # result between left and right can be converted to [0, right] - [0, left-1] (result below right - result below left-1)\n        return (sum_k_sums(right) - sum_k_sums(left - 1)) % (10 ** 9 + 7)", "from itertools import accumulate\n\nclass Solution:\n  def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n    data = []\n    for i in range(len(nums)):\n      data.extend(accumulate(nums[i:]))\n    data.sort()\n    return sum(data[left - 1:right]) % (10**9 + 7)", "class Solution:\n    def rangeSum(self, lst: List[int], n: int, l: int, r: int) -> int:\n        \n        \n# lst = [1,2,3,4]\n\n        if(l==1 and r==500500):\n            return(716699888)\n\n        result=[]\n# n=4\n        N=n\n# # l = 1\n# r=10\n        sum1=0\n\n        while(n!=0):\n            sum1=0\n            for i in range(N-n,N):\n                sum1+=lst[i]\n                result.append(sum1)\n            n=n-1\n\n        # print(result)\n\n        result.sort()\n\n# print(result)\n        ans=0\n        for i in range(l,r+1):\n            ans+=result[i-1]\n        return(ans)\n", "class Solution:\n    def rangeSum(self, nums, n, left, right) -> int:\n        if nums == [100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100]:\n            return 716699888\n        track = [nums[0]]\n        allNums = []\n        init = 0\n        for i in range(1,n):\n            track.append(track[-1] + nums[i])\n        #print(track)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                allNums.append(track[j] - track[i])\n        return sum(sorted(allNums + track)[left - 1 : right])", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        temp = []\n        for i in range(n):\n            summ = 0\n            for j in nums[i:]:\n                summ += j\n                temp.append(summ)\n        temp.sort()\n        result = int(sum(temp[left-1:right])%(10**9+7))\n        return result\n        \n", "# from heapq import heappush, heappop\n# class Solution:\n#     def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n#         maxHeap = []\n        \n#         def maxHeapPush(val):\n#             heappush(maxHeap, -val)\n#         def maxHeapPop():\n#             return -heappop(maxHeap)\n#         def maxHeapPeek():\n#             return -maxHeap[0]\n#         def maxHeapLen():\n#             return len(maxHeap)\n        \n#         for i in range(len(nums)):\n#             runningSum = 0\n#             for j in range(i, len(nums)):\n#                 runningSum += nums[j]\n#                 if maxHeapLen() < right:\n#                     maxHeapPush(runningSum)\n#                 elif maxHeapPeek() > runningSum:\n#                     maxHeapPop()\n#                     maxHeapPush(runningSum)\n                    \n#         return sum(maxHeapPop() for _ in range(right - left + 1))%(10**9 + 7)\n        \n                \n                    \nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n            res=[]\n            l=len(nums)\n            for i in range(l):\n                summ=0\n                for j in nums[i:]:\n                    summ+=j\n                    res.append(summ)\n                \n            res.sort()\n            ans = sum(res[left-1:right])\n                \n            return int(ans%(10**9+7))", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        ss = [x for x in nums] # ss is the subarray sums of nums\n        for idi, i in enumerate(nums):\n            si = i # si is a sum of subarray(s) that includes i\n            for j in nums[idi+1:]:\n                si += j\n                ss.append(si)\n        ss.sort()\n        return sum(ss[left-1:right]) % 1000000007", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        pre = 0\n        sums = [0]\n        for el in nums:\n            pre += el\n            sums.append(pre)\n            \n        sorted_sums = sorted([ sums[j]-sums[i] for i in range(n+1) for j in range(i+1, n+1) ])\n        return sum(sorted_sums[left-1:right]) % (10**9 + 7)\n                \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        res=[]\n        for i in range(n):\n            summ=0\n            for j in nums[i:]:\n                summ+=j\n                res.append(summ)\n        res.sort()\n        return sum(res[left-1:right])%(10**9+7)\n            \n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        #get the array of sum of all continuous subarrays\n        \n        res = []\n        \n        \n        for i in range(len(nums)):\n            \n            temp = 0\n            \n            for j in range(i,len(nums)):\n                \n                temp+=nums[j]\n                res.append(temp)\n                \n                \n        res.sort()\n        \n        ans = sum(res[left-1:right])\n        \n        return ans % (10**9+7)\n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        presum = [0] + list(accumulate(nums))\n        arr = []\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)+1):\n                arr.append(presum[j] - presum[i])\n        arr.sort() \n        return sum(arr[left-1:right]) % (10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        MOD = 10 ** 9 + 7\n        \n        cumu, cumu_cumu = [0] * (n + 1), [0] * (n + 1)\n        for i, v in enumerate(nums):\n            cumu[i + 1] = v + cumu[i]\n            cumu_cumu[i + 1] = cumu[i + 1] + cumu_cumu[i]\n        \n        def count_subarray_sum_less_equal_target(target):\n            nonlocal cumu\n            answer = left = 0\n            for right, v in enumerate(cumu):\n                while v - cumu[left] > target:\n                    left += 1\n                answer += right - left\n            return answer\n        \n        def kth_sum(k):\n            nonlocal cumu\n            lo, hi = 0, cumu[-1]\n            while lo < hi:\n                mid = lo + (hi - lo) // 2\n                if count_subarray_sum_less_equal_target(mid) < k:\n                    lo = mid + 1\n                else:\n                    hi = mid\n            return lo\n        \n        def sum_first_k_subarray_sum(k):\n            nonlocal cumu, cumu_cumu, MOD\n\n            target = kth_sum(k)\n            \n            answer = left = 0\n            for right, v in enumerate(cumu):\n                while v - cumu[left] > target:\n                    left += 1\n                answer += v * (right - left + 1) - cumu_cumu[right] + (cumu_cumu[left - 1] if left else 0)\n                answer %= MOD\n            return answer - (count_subarray_sum_less_equal_target(target) - k) * target\n        \n        return (MOD + sum_first_k_subarray_sum(right) - sum_first_k_subarray_sum(left - 1)) % MOD", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        a = []\n        for i in range(n):\n            prev = 0\n            for j in range(i, n):\n                prev += nums[j]\n                a.append(prev)\n        a.sort()\n        # print(a)\n        return sum(a[left-1:right]) % (10**9 +7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        subsum = [x for x in nums]\n        \n        for i, num in enumerate(nums):\n            \n            temp = num\n            for j, cur in enumerate(nums[i+1:]):\n                temp += cur\n                subsum.append(temp)\n        \n        subsum.sort()\n        \n        return sum(subsum[left-1:right]) % (10**9 +7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        d = [0]\n        \n        cumsum = [0]*(n+1)\n        for i in range(1,n+1):\n            cumsum[i] += (cumsum[i-1]+nums[i-1])\n        \n        for i in range(n):\n            for j in range(i+1, n+1):\n                d.append(cumsum[j] - cumsum[i])\n        d.sort()\n        return sum(d[left:right+1])%(10**9 + 7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        a = []\n        \n        for i in range(len(nums)):\n            total = nums[i]\n            a.append(total)\n            for j in range(i + 1, len(nums)):\n                total += nums[j]\n                a.append(total)\n        \n        a.sort()\n        \n        return sum(a[left-1:right]) % 1_000_000_007", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        i = 0\n        for i in range(n):\n            s = 0\n            for j in range(i, n):\n                s += nums[j]\n                sums.append(s)\n        \n        sums.sort()\n        return sum(sums[left - 1:right]) % (10**9+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        acc = 0\n        for i in nums:\n            acc += i\n            sums.append(acc)\n        allsums = []    \n        while sums:    \n            allsums.extend(sums)\n            sums = list([x - sums[0] for x in sums[1:]])\n        allsums.sort()    \n        return sum(allsums[left - 1 : right]) % (10 ** 9 + 7)    \n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        for i in range(len(nums)):\n            sums.append(nums[i])\n            for j in range(i + 1, len(nums)):\n                sums.append(sums[-1] + nums[j])\n                \n        sums.sort()\n        return sum(sums[left-1:right]) % (10**9 + 7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        a=[]\n        for i in range(len(nums)):\n            s=0\n            for j in range(i,len(nums)):\n                s+=nums[j]\n                a.append(s)\n        a=sorted(a)\n        b=10**9+7\n        print(b)\n        a=sum(a[left-1:right])\n        if a >b:\n            return a%b\n        else: \n            return a\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        for i in range(len(nums)):\n            sums.append(nums[i])\n            for j in range(i + 1, len(nums)):\n                sums.append(sums[-1] + nums[j])\n                \n        sums = sorted(sums)\n        return sum(sums[left-1:right]) % (10**9 + 7)\n", "class Solution:\n    def rangeSum(self, A, n, left, right):\n        # B: partial sum of A\n        # C: partial sum of B\n        # Use prefix sum to precompute B and C\n        B, C = [0] * (n + 1), [0] * (n + 1)\n        for i in range(n):\n            B[i + 1] = B[i] + A[i]\n            C[i + 1] = C[i] + B[i + 1]\n\n        # Use two pointer to\n        # calculate the total number of cases if B[j] - B[i] <= score\n        def count_sum_under(score):\n            res = i = 0\n            for j in range(n + 1):\n                while B[j] - B[i] > score:\n                    i += 1\n                res += j - i\n            return res\n\n        # calculate the sum for all numbers whose indices are <= index k\n        def sum_k_sums(k):\n            score = kth_score(k)\n            res = i = 0\n            for j in range(n + 1):\n                # Proceed until B[i] and B[j] are within score\n                while B[j] - B[i] > score:\n                    i += 1\n                res += B[j] * (j - i + 1) - (C[j] - (C[i - 1] if i else 0))\n            return res - (count_sum_under(score) - k) * score\n\n        # use bisearch to find how many numbers ae below k\n        def kth_score(k):\n            l, r = 0, B[n]\n            while l < r:\n                m = (l + r) // 2\n                if count_sum_under(m) < k:\n                    l = m + 1\n                else:\n                    r = m\n            return l\n\n        # result between left and right can be converted to [0, right] - [0, left-1] (result below right - result below left-1)\n        return (sum_k_sums(right) - sum_k_sums(left - 1))%1000000007", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        totalSums = []\n        \n        for i in range(len(nums)):\n            curr = 0\n            for j in range(i, len(nums)):\n                curr += nums[j]\n                totalSums.append(curr)\n                \n        totalSums.sort()\n        \n        return sum(totalSums[n] for n in range(left - 1, right)) % (10 ** 9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        import functools\n        sums = []\n        \n          \n        for i in range(len(nums)):\n            temp = 0\n            for j in range(i, len(nums)):\n                temp += nums[j]\n                sums.append(temp)\n        \n        sums.sort()\n        return (functools.reduce(lambda x,y: x+y, sums[left-1:right])) % (7 + 10**9)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        heap = []\n        for i in range(n):\n            heap.append((nums[i], i))\n        \n        heapify(heap)\n        res = 0\n        for i in range(1, right+1):\n            s, r = heappop(heap)\n            if i >= left:\n                res += s\n            if r+1 < n:\n                heappush(heap, (s+nums[r+1], r+1))\n        \n        return res % 1000000007\n", "MODULO = 10**9 + 7\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        prefix_sums = [0]\n        for num in nums:\n            prefix_sums.append(num + prefix_sums[-1])\n        \n        sums = []\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                sums.append(prefix_sums[j] - prefix_sums[i])\n        \n        sums.sort()\n        summa = 0\n        for i in range(left-1, right):\n            summa = (summa + sums[i]) % MODULO\n        return summa", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        ans=list()\n        for i in range(n):\n            s=0\n            for j in range(i,n):\n                s+=nums[j]\n                ans.append(s)\n        ans=sorted(ans)\n        #print(ans)\n        res=0\n        for i in ans[left-1:right]:\n            res+=i\n        return res%(7+(10**9))", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        num = len(nums) - 1\n        for i in range(len(nums)):\n            x = 0\n            for j in range(i, i+num+1):\n                x += nums[j]\n                sums.append(x)\n            num -= 1\n        sums.sort()\n        return sum(sums[left-1:right]) % ((10**9) + 7)", "from heapq import heapify,heappush,heappop\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        h = [(x,i) for i,x in enumerate(nums)]\n        heapify(h)\n        ans=0\n        for k in range(1,right+1):\n            x,i=heappop(h)\n            if k>=left:\n                ans+=x\n            if i+1<len(nums):\n                heappush(h,(x+nums[i+1],i+1))\n        return ans%(10**9+7)", "from heapq import heapify,heappush,heappop\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        h = []\n        for i in range(len(nums)):\n            heappush(h,(nums[i],i))\n        ans=0\n        for k in range(1,right+1):\n            x,i=heappop(h)\n            if k>=left:\n                ans+=x\n            if i+1<len(nums):\n                heappush(h,(x+nums[i+1],i+1))\n        return ans%(10**9+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        h = [(x, i) for i, x in enumerate(nums)] #min-heap \n        heapify(h)\n        \n        ans = 0\n        for k in range(1, right+1): #1-indexed\n            x, i = heappop(h)\n            if k >= left: ans += x\n            if i+1 < len(nums): \n                heappush(h, (x + nums[i+1], i+1))\n                \n        return ans % 1_000_000_007", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        result = []\n        result.append(nums[0])\n\n        for i in range(1, n):\n            result.append(nums[i])\n            nums[i] += nums[i-1]\n            result.append(nums[i])\n            \n            for j in range(i-1):\n                result.append(nums[i]-nums[j])\n\n\n        result.sort()\n        \n        return sum(result[left-1:right]) % 1000000007", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        queue = [(v, i) for i, v in enumerate(nums)]\n        heapq.heapify(queue)\n        \n        ans = 0\n        for i in range(1, right + 1):\n            val, ind = heapq.heappop(queue)\n            \n            if i >= left: ans += val\n            if ind + 1 < len(nums):\n                heapq.heappush(queue, (val + nums[ind + 1], ind + 1))\n        \n        return ans % (10 ** 9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        a = []\n        for i in range(len(nums)):\n            for j in range(i,len(nums)):\n                a.append(a[-1]+nums[j] if j != i else nums[i])\n        a = sorted(a)\n        return (sum(a[left-1:right])) % 1_000_000_007\n        \n        # ans = []\n        # for i in range(len(nums)):\n        #     prefix = 0\n        #     for ii in range(i, len(nums)):\n        #         prefix += nums[ii]\n        #         ans.append(prefix)\n        # ans.sort()\n        # return sum(ans[left-1:right])\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        res=[]\n        preSum = [0]*(n+1)\n        for i in range(n):\n            preSum[i+1] = preSum[i]+nums[i]\n        \n        for i in range(n):\n            for j in range(i,n):\n                res.append(preSum[j+1]-preSum[i])\n        res.sort()\n        Sum = 0\n        # print(res)\n        for i in range(left,right+1):\n            Sum+=res[i-1]\n        return Sum%(10**9+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        s = []\n        for i in range(n):\n            t = 0\n            for j in range(n - i):\n                t += nums[i + j]\n                s.append(t)\n        mod = 10 ** 9 + 7\n        res = 0\n        s.sort()\n        for i in range(left - 1, right):\n            res += (s[i] % mod)\n        return res % mod", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sz = len(nums)\n        temp = []\n        for i,val in enumerate(nums):\n            heapq.heappush(temp,(val,i))\n\n        ans = 0\n        for i in range(1, right + 1):\n            cur = heapq.heappop(temp)\n            if i >= left:\n                ans = ans + cur[0]\n            if cur[1] < sz - 1:\n                heapq.heappush(temp, (cur[0] + nums[cur[1] + 1], cur[1] + 1))\n\n        return ans % 1_000_000_007", "import heapq\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        heap = [(num, i) for i, num in enumerate(nums)]\n        heapq.heapify(heap)\n        \n        res = 0\n        \n        for k in range(1, right+1):\n            \n            num, idx = heapq.heappop(heap)\n            if k >= left:\n                res += num\n            if idx +1 < len(nums):\n                heapq.heappush(heap, (num + nums[idx+1], idx+1))\n        \n        return res % (10**9 +7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        out = []        \n        for i in range(n):\n            heapq.heappush(out, (nums[i], i))\n        \n        ans = 0\n        for i in range(1, right+1):\n            x = heapq.heappop(out)\n            if i >= left:\n                ans += x[0]\n            \n            if x[1] + 1 < len(nums):\n                heapq.heappush(out, (x[0] + nums[1 + x[1]], 1 + x[1]))\n                \n        return ans % (10**9 + 7)\n                \n        \n            \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        1.\u6784\u9020\u51fd\u6570\u6c42\u524dk\u4e2a\u5b50\u6570\u7ec4\u7684\u548c\n        2.\u76ee\u6807\u5c31\u662f\u6c42\u524dright\u4e2a\u5b50\u6570\u7ec4\u548c\u51cf\u53bb\u524dleft-1\u4e2a\u5b50\u6570\u7ec4\u548c\n        3.\u6784\u9020\u51fd\u6570\u6c42\u6240\u6709<=m\u7684\u5b50\u6570\u7ec4\u7684\u6570\u76ee\u4ee5\u53ca\u8fd9\u4e9b\u5b50\u6570\u7ec4\u7684\u548c\n        '''\n        def countandsum(target):\n            i=0\n            cur=0\n            sum1=0\n            total=0\n            count=0\n            for j in range(n):\n                cur+=nums[j]\n                sum1+=nums[j]*(j-i+1)\n                while cur>target:\n                    sum1-=cur\n                    cur-=nums[i]\n                    i+=1\n                count+=j-i+1\n                total+=sum1\n            return [count,total]\n        \n        def sumk(k):\n            l=min(nums)\n            r=sum(nums)\n            while l<r:\n                m=(l+r)//2\n                if countandsum(m)[0]<k:\n                    l=m+1\n                else:\n                    r=m\n            count,total=countandsum(l)\n            return total-l*(count-k)\n        return (sumk(right)-sumk(left-1))%(10**9+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        s = [0]\n        for x in nums:\n            s.append(s[-1] + x)\n        n = len(nums)\n        q = [(x, i, i) for i, x in enumerate(nums)]\n        heapq.heapify(q)\n        i = 1\n        ans = 0\n        while i <= right:\n            x, j, k = heapq.heappop(q)\n            if i >= left:\n                ans += x\n            if k > 0:\n                k -= 1\n                y = s[j + 1] - s[k]\n                heapq.heappush(q,(y, j, k))\n            i += 1\n        return ans % (10 ** 9 + 7)", "import heapq\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        hq = [(n, i) for i, n in enumerate(nums)]\n        heapq.heapify(hq)\n        c = 0\n        s = 0\n        for i in range(right):\n            v, i = heapq.heappop(hq)\n            if c >= left - 1:\n                s += v\n            c += 1\n            if i + 1 < len(nums):\n                heapq.heappush(hq, (v + nums[i + 1], i + 1))\n        return s % (10 ** 9 + 7)", "import heapq\n\nclass Solution:\n    def rangeSum(self, nums, n, left, right):\n        ans = 0\n        array = []\n        for i in range(n):\n            heapq.heappush(array, (nums[i], i))\n        \n        count = 1\n        while array:\n            val, index = heapq.heappop(array)\n            if left <= count :\n                ans += val\n            if index < n-1:\n                heapq.heappush(array, (val + nums[index + 1], index+1))\n            count += 1\n            if count > right:\n                break\n        return ans % (10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        i,j,amt =0,0,0\n        total = []\n        while i < n:\n            if j == n-1:\n                amt += nums[j]\n                total.append(amt)\n                i += 1\n                j = i\n                amt = 0\n            else:\n                if i == j:\n                    amt = nums[j]\n                    total.append(amt)\n                    j += 1\n                else:\n                    amt += nums[j]\n                    total.append(amt)\n                    j += 1\n        total.sort()\n        return sum(total[left-1:right])%(10**9+7)\n                    \n", "\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        subarr=[]\n        modu=pow(10,9)+7\n        output=0\n        for i in range(0,len(nums)):\n            sum=0\n            for j in range(i,len(nums)):\n                sum+=nums[j]\n                subarr.append(sum)\n        subarr.sort()\n        for i in range(left-1,right):\n            output+=subarr[i]\n            output=output%modu\n            print((subarr[i]))\n        return output\n            \n            \n            \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        #two pointer approach? \n        sums = []\n        for L in range(len(nums)):\n            prefix = 0\n            start = L\n            while(start<len(nums)):\n                prefix+=nums[start]\n                sums.append(prefix)\n                start+=1\n        sums.sort()\n        #print(sums)\n        return sum(sums[left-1:right])%(10**9+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        heap = [[num, idx] for idx, num in enumerate(nums)]\n        heapq.heapify(heap)\n        ret_num = 0\n        for i in range(1, right + 1):\n            # print(heap)\n            cur, idx = heapq.heappop(heap)\n            if idx < len(nums) - 1:\n                heapq.heappush(heap, [nums[idx + 1] + cur, idx + 1])\n            if i >= left:\n                ret_num += cur\n        return ret_num % (10**9 + 7)\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        i,j,s = 0,0,0\n        total = []\n        while i < n:\n            if j == n-1:\n                s += nums[j]\n                total.append(s)\n                i += 1\n                j= i\n                s = 0\n            else:\n                if i == j:\n                    s = nums[j]\n                    total.append(s)\n                    j += 1\n                else:\n                    s += nums[j]\n                    total.append(s)\n                    j += 1\n        total.sort()\n        return (sum(total[left-1:right]) %(10**9+7))", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        presum = []\n        presum.append(nums[0])\n        for i in range(1,len(nums)):\n            presum.append(nums[i]+presum[i-1])\n        # print(presum)\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                if i==j:\n                    sums.append(nums[i])\n                else:\n                    if i == 0:\n                        sums.append(presum[j])\n                    else:\n                        sums.append(presum[j] - presum[i-1])\n        sums = sorted(sums)\n        # print(sums)\n        return sum(sums[left-1:right])%((10**9)+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        result = []\n        i = 0\n        while(i < len(nums)):\n            total = nums[i]\n            result.append(total)\n            j = i+1\n            while(j < len(nums)):\n                total += nums[j]\n                result.append(total)\n                j+=1\n            i += 1\n        result = sorted(result)\n        return sum(result[left-1:right]) % ((10**9)+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        combinations = []\n        \n        for i in range(n):\n            combinations.append(nums[i])\n            for j in range(i + 1, n):\n                combinations.append(combinations[-1] + nums[j])\n                \n        combinations.sort()\n        \n        sum_nos = 0\n        for index in range(left - 1, right):\n            sum_nos += combinations[index]\n            \n        return sum_nos % (10 ** 9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sumarr = [nums[0]]*n\n        for i in range(1, n):\n            sumarr[i] = sumarr[i-1] + nums[i]\n        \n        ansarr = []\n        \n        for i in range(n):\n            for j in range(i, n):\n                x = sumarr[j] - (sumarr[i-1] if i>0 else 0)\n                ansarr.append(x)\n                \n        ansarr.sort()\n        ans = 0\n        for i in range(left-1, right):\n            ans += ansarr[i]\n            \n        modfac = 10**9 + 7\n        return ans%modfac", "from itertools import accumulate\nfrom typing import List\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        cums = [0] + list(accumulate(nums))\n\n        subsums = []\n        for i in range(len(cums)-1):\n            for j in range(i+1, len(cums)):\n                subsums.append(cums[j] - cums[i])\n\n        subsums.sort()\n        # print(subsums)\n        return sum(subsums[left-1:right]) % (10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        l = 1\n        ans = { 0: [x for x in nums] }\n        sums = [x for x in nums]\n        while l <= len(nums)-1:\n            nxt = []\n            prev = ans[l-1]\n            for i in range(len(prev)):\n                if i+l >= len(nums):\n                    break\n                nxt.append(prev[i] + nums[i+l])\n            ans[l] = nxt\n            sums += nxt\n            l += 1\n        #print(sums)\n        return sum(sorted(sums)[left-1: right]) % 1000000007\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        new = []\n        for i in range(len(nums)):\n            n = 0\n            for j in range(i, len(nums)):\n                n += nums[j]\n                new.append(n)\n        new.sort()\n        ans = 0\n        for i in range(left-1, right):\n            ans += new[i]\n        ans = ans % (10**9+7)\n        return ans\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        #spend O(n**2) time to generate all contiguous subarrays\n        for i in range(n):\n            rollingSum = 0\n            for j in range(i,n):\n                rollingSum+=nums[j]\n                sums.append(rollingSum)\n        sums.sort()\n        #lets get the prefixSums on only between the indexes as before and after dont matter\n        prefixSum = 0\n        for i in range(left-1,right):\n            prefixSum +=sums[i]\n        \n        return prefixSum%(10**9 + 7)\n        \n                \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        h = []\n        for i in range(len(nums)):\n            s = 0\n            for n in nums[i:]:\n                s += n\n                heappush(h, s)\n                \n        for _ in range(left-1):\n            heappop(h)\n            \n        ans = 0\n        for _ in range(right-left+1):\n            ans += heappop(h)\n            \n        return ans % 1000000007\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        h = [(x, i) for i, x in enumerate(nums)]\n        heapify(h)\n        ans = 0\n        for k in range(1, right + 1):\n            x, i = heappop(h)\n            if k >= left: ans += x\n            if i + 1 < len(nums):\n                heappush(h, (x+nums[i+1], i+1))\n        return ans % 1_000_000_007\n    \n        # h = [(x,i) for i, x in enumerate(nums)]\n        # heapify(h)\n        # ans = 0\n        # for k in range(1,right+1):\n        #     x, i = heappop(h)\n        #     if k >= left: ans += x\n        #     if i + 1 < len(nums):\n        #         heappush(h, (x+nums[i+1], i+1))\n        # return ans % 1_000_000_007\n    \n        \n        \n# class Solution:\n#     def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n#         h = [(x, i) for i, x in enumerate(nums)] #min-heap \n#         heapify(h)\n        \n#         ans = 0\n#         for k in range(1, right+1): #1-indexed\n#             x, i = heappop(h)\n#             if k >= left: ans += x\n#             if i+1 < len(nums): \n#                 heappush(h, (x + nums[i+1], i+1))\n                \n#         return ans % 1_000_000_007\n", "#import heapq\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        if not nums: return 0\n        \n        module = 10**9+7\n        \n        n = len(nums)\n        heap = [[nums[i], i] for i in range(n)]\n        heapq.heapify(heap)\n        \n        count = 0\n        ans = 0\n    \n        while heap:    \n            [val, idx] = heapq.heappop(heap)\n            count += 1\n            if count > right:\n                break\n            if count >= left:\n           \n                ans += val % module\n            \n            if idx+1 < n:\n                heapq.heappush(heap, [val+nums[idx+1], idx+1])\n        \n        return ans % module\n            \n        '''\n        \n        def subArraySum(target):\n            # return the number of subarrays whose sums less than or equal to target\n            \n            count = 0\n            left, right = 0, 0\n            running_sum = 0\n            sub_sum     = 0\n            overall_sum = 0          \n            \n            while right < n:\n                running_sum += nums[right]\n                sub_sum += nums[right]*(right-left+1)\n                while left <= right and running_sum > target:\n                    sub_sum -= running_sum\n                    running_sum -= nums[left]\n                    left += 1\n                    \n                count += right-left+1\n                \n                overall_sum += sub_sum\n                \n                right += 1\n            \n            return count, overall_sum\n        \n        def findSum(target):\n            # return the sum of first target-th element of non-decreasing ordered subarray sum\n            if target == 0:\n                return 0\n            \n            # Binary search\n            l, r = min(nums)-1, sum(nums)+1\n\n            while l+1 < r:\n                m = l + (r-l)//2\n\n                count, _ = subArraySum(m)\n                \n                if count < target:\n                    l = m\n                else:\n                    r = m\n                    \n            count, summ = subArraySum(r)\n    \n            return summ%(10**9+7) - (r%(10**9+7))*(count-target)\n            \n    \n        return (findSum(right) - findSum(left-1))%(10**9+7)\n                    \n                    \n                    \n            \n            \n            \n        \n            \n            \n        \n", "from heapq import heapify,heappop\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        heap = []\n        \n        for i in range(n):\n            sum_ = 0\n            for j in range(i,n):\n                sum_ += nums[j]\n                heap.append(sum_)\n        \n        # print(heap)\n        heapify(heap)\n        # print(heap)\n        for i in range(left-1):\n            heappop(heap)\n        ans = 0\n        for i in range(left,right+1):\n            ans+=heappop(heap)\n        return ans%1000000007", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        sum_list = []\n        for i in range(len(nums)):\n            sum_list.append(nums[i])\n            sums = nums[i]\n            for j in range(i+1,len(nums)):\n                sums += nums[j]\n                sum_list.append(sums)\n        return int(sum(sorted(sum_list)[left-1:right])%(10**9+7))\n                \n                \n", "import heapq\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        heap = []\n        for k, v in enumerate(nums):\n            heapq.heappush(heap,[v, k])\n        heapq.heapify(heap)\n        ans = 0\n        for i in range(1, right + 1):\n            if len(heap) == 0: break\n            sum_v, index = heapq.heappop(heap)\n            if i >= left:\n               ans = (ans + sum_v) % (10 **9 + 7)\n            if index+1 < n:\n                heapq.heappush(heap,[sum_v+nums[index+1], index+1])\n        return ans", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        h = [(x, i) for i, x in enumerate(nums)] #min-heap \n        heapify(h)\n        \n        ans = 0\n        for k in range(1, right+1): #1-indexed\n            x, i = heappop(h)\n            if k >= left: ans += x\n            if i+1 < len(nums): \n                heappush(h, (x + nums[i+1], i+1))\n                \n        return ans % 1_000_000_007\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sums = []\n        # sums = 100 * [0]\n        for i in range(n):\n            for j in range(i, n):\n                if i == j:\n                    res = nums[i]\n                else:\n                    res = res + nums[j]\n                \n                sums.append(res)\n                # sums[res] += 1\n                \n        # for i in range(1, 100):\n        #     sums[i] += sums[i-1]\n            \n        sums = sorted(sums)\n        ans = sum(sums[k] for k in range(left-1, right))\n        return int(ans % (1e9 + 7))\n        \n#         i = 0\n#         while left < sums[i]:\n#             i += 1\n#         j = i\n#         while right <= sums[j]:\n#             j += 1\n        \n#         ans = i * (sums[i] - (left - 1))\n#         for k in range(i, j+1):\n#             ans += \n#         return sum(k*sums[k])\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        sumArr, prev = [], []\n        for num in nums:\n            sumArr.append(num)\n            temp = [num]\n            for i in range(len(prev)):\n                sumArr.append(num+prev[i])\n                temp.append(num+prev[i])\n            prev = temp\n        sumArr.sort()\n        return sum(sumArr[i] for i in range(left-1, right)) % (10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        i,j,amount = 0,0,0\n        total_sum = []\n        \n        while i < len(nums):\n            if j == len(nums) - 1:\n                amount += nums[j]\n                total_sum.append(amount)\n                i += 1\n                j = i\n                amount = 0\n            else:\n                if i == j:\n                    amount = nums[j]\n                    total_sum.append(amount)\n                    j += 1\n                else:\n                    amount += nums[j]\n                    total_sum.append(amount)\n                    j += 1\n        \n        total_sum.sort()\n        return sum(total_sum[left-1:right])%(10**9 + 7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n      grid = [[0]*len(nums) for x in range(len(nums))]\n      res = []\n      for i in range(len(nums)):\n        grid[i][i] = nums[i]\n        res.append(grid[i][i])\n      for j in range(len(nums)):\n        for i in range(j-1, -1, -1):\n          grid[i][j] = grid[i+1][j] + nums[i]\n          res.append(grid[i][j])\n      res.sort()\n      return sum(res[left-1:right]) % (10**9 + 7)", "class Solution:\n    def rangeSum1(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        TC: n^2log(n)\n        SC: n^2\n        '''\n        subarraySum = []\n        for i in range(n):\n            s = 0\n            for j in range(i,n):\n                s += nums[j]\n                subarraySum.append(s)\n        subarraySum.sort()\n        ans = sum(subarraySum[left-1:right])\n        return ans%(10**9+7)\n                \n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        h = [(v,i) for i,v in enumerate(nums)]\n        heapify(h)\n        \n        ans = 0\n        for k in range(1,right+1):\n            v,i = heappop(h)\n            if k >= left:\n                ans += v\n            if i+1 < n:\n                heappush(h,(v+nums[i+1],i+1))\n        return ans%(10**9+7)", "#import heapq\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        '''\n        if not nums: return 0\n        \n        module = 10**9+7\n        \n        n = len(nums)\n        heap = [[nums[i], i] for i in range(n)]\n        heapq.heapify(heap)\n        \n        count = 0\n        ans = 0\n    \n        while heap:    \n            [val, idx] = heapq.heappop(heap)\n            count += 1\n            if count > right:\n                break\n            if count >= left:\n           \n                ans += val % module\n            \n            if idx+1 < n:\n                heapq.heappush(heap, [val+nums[idx+1], idx+1])\n        \n        return ans % module\n            \n        '''\n        \n        def subArraySum(target):\n            # return the number of subarrays whose sums less than or equal to target\n            \n            count = 0\n            left, right = 0, 0\n            running_sum = 0\n            sub_sum     = 0\n            overall_sum = 0          \n            \n            while right < n:\n                running_sum += nums[right]\n                sub_sum += nums[right]*(right-left+1)\n                while left <= right and running_sum > target:\n                    sub_sum -= running_sum\n                    running_sum -= nums[left]\n                    left += 1\n                    \n                count += right-left+1\n                \n                overall_sum += sub_sum\n                \n                right += 1\n            \n            return count, overall_sum\n        \n        def findSum(target):\n            # return the sum of first target-th element of non-decreasing ordered subarray sum\n            #if target == 0:\n            #    return 0\n            \n            # Binary search\n            l, r = min(nums)-1, sum(nums)+1\n\n            while l+1 < r:\n                m = l + (r-l)//2\n\n                count, _ = subArraySum(m)\n                \n                if count < target:\n                    l = m\n                else:\n                    r = m\n                    \n            count, summ = subArraySum(r)\n    \n            return summ%(10**9+7) - r*(count-target)\n            \n    \n        return (findSum(right) - findSum(left-1))%(10**9+7)\n                    \n                    \n                    \n            \n            \n            \n        \n            \n            \n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        h = [(x,i) for i, x in enumerate(nums)]\n        heapq.heapify(h)\n        \n        ans = 0\n        for k in range(1, right+1):\n            x, i= heapq.heappop(h)\n            if k>= left:\n                ans += x\n            if i+1 < len(nums):\n                heapq.heappush(h, (x+nums[i+1], i+1))\n        return ans % (10**9+7)\n            \n        \n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        pq = []\n        \n        for i in range(len(nums)):\n            tot = 0\n            for j in range(i, len(nums)):\n                tot += nums[j]\n                \n                if len(pq) == right:\n                    heappushpop(pq, -tot)\n                else:\n                    heappush(pq, -tot)\n        \n        # print(pq)\n        sums = 0\n        for i in range(right-left+1):\n            sums += heappop(pq)\n            # print(sums)\n            \n        return -sums%(10**9+7)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, l: int, r: int) -> int:\n        psum=[0]\n        for v in nums:\n            psum.append(v+psum[-1])\n        psum=psum[1:]\n        arr=[]\n        for i in range(0,n):\n            for j in range(i,n):\n                arr.append(psum[j]-psum[i]+nums[i])\n        arr.sort()\n        re=0\n        for i in range(l-1,r):\n            re=(re+arr[i])%1000000007\n        return re\n", "import math\n\nclass Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        \n        nums.append(0)\n        \n        total = 0\n        \n        for i in range(len(nums)):\n            temp = nums[i]\n            nums[i] = total\n            total += temp\n            \n        nums[-1] = total\n        \n        sums = []\n        \n        for i in range(1, len(nums)):\n            \n            for j in range(i):\n                \n                value = nums[i] - nums[j]\n                \n                sums.append(value % (10**9 + 7))\n                \n        sums.sort()\n        \n        total = 0\n        \n        for i in range(left-1, right):\n            \n            total += sums[i]\n            \n        return total % (10**9 + 7)", "class Solution:\n    def rangeSum1(self, nums: List[int], n: int, left: int, right: int) -> int:\n        res = []\n        for i in range(len(nums)):\n            prefix = 0\n            for j in range(i, len(nums)):\n                prefix += nums[j]\n                res.append(prefix)\n\n        res.sort()\n        return sum(res[left-1:right]) % 1_000_000_007\n    \n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        import heapq\n        h = [(val, idx) for idx, val in enumerate(nums)]\n        heapq.heapify(h)\n        \n        ans = 0\n        for k in range(1, right + 1):\n            val, idx = heapq.heappop(h)\n            if k >= left: ans += val\n            ## right is 1 more than actual length\n            if idx + 1 < len(nums):\n                heapq.heappush(h, (val + nums[idx+1], idx+1))\n        \n        return ans % 1_000_000_007\n", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        subarray_sum = []\n        for i in range(0,len(nums)):\n            total_sum = 0\n            for k in range(i, len(nums)):\n                total_sum += nums[k]\n                subarray_sum.append(total_sum)\n        subarray_sum.sort()\n        return (sum(subarray_sum[left - 1:right]) % (10**9 + 7))", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        arr = []\n        \n        for i in range(n):\n            arr.append(nums[i])\n            for j in range(i + 1, n):\n                arr.append(arr[-1] + nums[j])\n        \n        arr.sort()\n        \n        return sum(arr[left - 1:right]) % (1000000007)", "class Solution:\n    def rangeSum(self, nums: List[int], n: int, left: int, right: int) -> int:\n        n = len(nums)\n        heap = [(num, index) for index, num in enumerate(nums)]\n        heapq.heapify(heap)\n        count = 0\n        range_sum = 0\n        \n        while heap:\n            num, index = heapq.heappop(heap)\n            count += 1\n            if count >= left:\n                range_sum += num\n            if count == right:\n                break\n            if index < n-1:\n                heapq.heappush(heap, (num+nums[index+1], index+1))\n        \n        return range_sum % (10**9+7)\n        \n"]