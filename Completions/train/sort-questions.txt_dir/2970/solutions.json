["def prod_int_part(n, min_=2):\n    total, fac = 0, []\n    for d in range(min_, int(n ** .5) + 1):\n        if not n % d:\n            count, sub = prod_int_part(n // d, d)\n            total += count + 1\n            if not count: sub = [n // d]\n            if not fac: fac = [d] + sub\n    return [total, fac]", "def allmult(n):\n    l = list(range(2, n))\n    l = l[: len(l)//2 + 1]\n    m = set()\n    for i, n1 in enumerate(l):\n        for n2 in l[i:]:\n            if n1 * n2 == n:\n                m.add((n1, n2))\n    return m\n\ndef addPart(n, s):\n    news = set()\n    for t in s:\n        newt = tuple(sorted(t + (n,)))\n        news.add(newt)\n    return news\n\ndef is_mult(l, num):\n    m = 1\n    for n in l:\n        m *= n\n    return m == num\n\ndef lastPart(newpart, n):\n    lastpart = newpart.copy()\n    for nums in newpart:\n        nums = list(nums)\n        great = max(nums)\n        nums.remove(great)\n        for mult in map(list, allmult(great)):\n            mult.extend(nums)\n            part = tuple(sorted(mult))\n            if is_mult(part, n):\n                lastpart.add(part)\n    return lastpart\n\ndef prod_int_part(n):\n    part = allmult(n)\n    newpart = part\n    for n1, n2 in part:\n        newpart = newpart.union(addPart(n1, allmult(n2)))\n        newpart = newpart.union(addPart(n2, allmult(n1)))\n    lastpart = lastPart(lastPart(newpart, n), n)\n    return [len(lastpart), list(max(lastpart, key=len))] if lastpart else [0, []]\n", "def partition(n,s=2):\n    if n <= 1:return []\n    if n < 4:return [[n]]\n    ans = []\n    while True:\n        while n % s != 0:s += 1\n        if s > n ** 0.5: break\n        l = [s]\n        p = partition(n / s,s)\n        for i in p:\n            x = sorted(l + i)\n            if not x in ans:ans += [x]\n        ans += [l + [n/s]]\n        s += 1\n    return ans\n\ndef prod_int_part(n):\n    p = partition(n)\n    return [len(p), min(p) if p else []]", "div=lambda n:[[i,n//i] for i in range(2,int(n**.5)+1) if not n%i]\ndef prod_int_part(n):\n        li,parts = div(n),set()\n        def recur(li, s=[]):\n            parts.add(tuple(sorted(s)))\n            for i in li:\n                recur(div(i[1]),s+i if not s else s[:-1]+i)\n        recur(li)\n        return [len(parts)-1,list(max(parts,key=len))]", "def product_way(n, start=2):\n    result = 0\n    for i in range(start, n//2+1):\n        if n%i == 0 and i<=n/i:\n            result += 1 + product_way(n//i, i)\n    return result\n\n\ndef prod_int_part(n):\n    x = product_way(n, 2)\n    y = []\n    m = n\n    for i in range(2, n//2+1):\n        if n%i == 0:\n            while (m%i == 0):\n                m /= i\n                y.append(i)\n    return [x, y]", "def prod_int_part(n):\n    ans = []\n    stack = [(n, 2, [])]\n    while stack:\n        v, m, divs = stack.pop()\n        for i in range(m, int(v**0.5)+1):\n            if v % i == 0:\n                stack.append((v // i, i, divs + [i]))\n                ans.append(divs + [i, v // i])\n    return [len(ans), sorted(ans)[0]] if ans else [0, []]", "product_numbers = {\n    1: [4, 6, 9, 10, 14, 15, 21, 22, 25, 26, 33, 34, 35, 38, 39, 46, 49, 51, 55, 57, 58, 62, 65, 69, 74, 77, 82, 85, 86, 87, 91, 93, 94, 95],\n    2: [8, 27],\n    3: [12, 18, 20, 28, 44, 45, 50, 52, 63, 68, 75, 76, 92, 98, 99],\n    4: [16, 30, 42, 66, 70, 78, 81],\n    6: [24, 32, 40, 54, 56, 88],\n    8: [36, 72],\n    10: [60, 64, 84, 90],\n    11: [48, 80],\n    18: [96]\n}\n\nis_prime = lambda number: all([number % i for i in range(2, number)])\n\nPRIMES = [i for i in range(2, 100) if is_prime(i) == True]\n\ndef prod_int_part(n):\n    assert n <= 100\n    a = number_of_products(n)\n    b = prime_factorization(n)\n    return [a, b]\n\ndef number_of_products(n):\n    for number in product_numbers:\n        if n in product_numbers[number]:\n            return number\n    return 0\n\ndef prime_factorization(number):\n    if number in PRIMES:\n        return []\n    result = []\n    prime_factors = [prime for prime in PRIMES if number % prime == 0]\n    for factor in prime_factors:\n        while number % factor == 0:\n            result.append(factor)\n            number = number // factor\n    return result", "from math import sqrt\n\ndef non_unique_partitions(n, floor = 2):\n    count = 0\n    for i in range(floor, int(sqrt(n)) + 1):\n        if n % i == 0:\n            count += 1 + non_unique_partitions(n // i, i)\n    return count\n\ndef factorize_without_n(n):\n    fac = []\n    for i in range(2, n):\n        while n % i == 0:\n            fac.append(i)\n            n = n // i\n    return fac\n\ndef prod_int_part(n):\n    return [non_unique_partitions(n), factorize_without_n(n)]", "import itertools\nimport collections\n\ndef factorize(n):\n    factors = []\n    if n <= 1:\n        return [n]\n    for i in range(2, n + 1):\n        if n <= 1:\n            break\n        while n % i == 0:\n            factors.append(i)\n            n /= i\n    return factors\n\ndef prod_int_part(n):\n    fac = factorize(n)\n    x = len(fac) - 1\n    for i in range(x):\n        fac.append(\"/\")\n    perms = set(list(itertools.permutations(fac)))\n    all_perm_factors = []\n    for perm in perms:\n        perm_factors = []\n        prod = 1\n        for i in range(len(perm)):\n            if perm[i] != \"/\":\n                prod *= perm[i]\n            elif perm[i] == \"/\":\n                perm_factors.append(prod)\n                prod = 1\n        perm_factors.append(prod)\n        perm_counter = collections.Counter(x for x in perm_factors if x != 1)\n        if not perm_counter in all_perm_factors:\n            all_perm_factors.append(perm_counter)\n    l = factorize(n)\n    if len(l) == 1:\n        del(l[0])\n    return [len(all_perm_factors) - 1, l]"]