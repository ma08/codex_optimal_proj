["# cook your dish here\n# cook your dish here\nimport numpy as np\nimport sys\n\ndef findSeq(n, s, k, m, M):\n    midInd = n // 2\n    seqs = []\n    for ind in range(midInd + 2, midInd - 3, -1):\n        if ind >= n or ind < 0:\n            continue     \n        seq = genBestSeq(n, ind, m, M, s)\n        if seq is not -1 and testSeq(k, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)\n\n#def findSeq(n, s, k, m, M):\n#    midInd = n // 2\n#    if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\n#        return genBestSeq(n, midInd + 1, m, M, s) \n#    elif k > midInd + 1 and n % 2 == 1:\n#        return -1\n#    return genBestSeq(n, midInd, m, M, s)\n\ndef genBestSeq(n, diffInd, m, M, s):\n    #inc = M - m - 1\n    arr = np.full((n,), m)\n    arr[diffInd:] += 1\n    #remainder = s - np.sum(arr)\n    #if remainder < 0:\n    #    return -1\n\n    #nFull, remainder = divmod(remainder, inc)\n    #if nFull > n or (nFull == n and remainder > 0):\n    #    return -1\n\n    #addingInd = n - nFull -1\n    #arr[addingInd + 1:] += inc\n    #arr[addingInd] += remainder\n    #return arr\n    s = s - np.sum(arr)\n    if s < 0:\n        return -1\n    inc = M - m - 1\n    ind = n - 1\n    while (ind >= 0):\n        z = min(inc, s)\n        arr[ind] += z\n        s -= z\n        ind -= 1\n    if s != 0:\n        return -1\n    return arr\n\ndef testSeq(k, seq):\n    seq = sorted(seq)\n    n = len(seq)\n    if n % 2 == 1:\n        median = seq[n // 2]\n    else:\n        median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n    seq.pop(n % k)\n    seq.pop(k - 1)\n    return (median != seq[(n - 2) // 2]) \n    \n\ndef __starting_point():\n    nCases = int(input())\n    answers = []\n    #ks = []\n    for i in range(nCases):\n        #nums = [int(val) for val in input().split()]\n        #ks.append(nums[2])\n        #answers.append(findSeq(*nums))\n        answers.append(findSeq(*(int(val) for val in input().split())))\n        ans = answers[-1]\n        if not isinstance(ans, int):\n            print(*ans, sep=' ')\n        else:\n            print(ans)\n    #for i, ans in enumerate(answers):\n\n    #for ans in answers:\n    #    if isinstance(ans, np.ndarray):\n    #        print(*ans, sep=' ')\n    #    else:\n    #        print(ans)\n\n__starting_point()", "# cook your dish here\n# cook your dish here\nimport numpy as np\nimport sys\n\ndef findSeq(n, s, k, m, M):\n    midInd = n // 2\n    seqs = []\n    for ind in range(midInd + 2, midInd - 3, -1):\n        if ind >= n or ind < 0:\n            continue     \n        seq = genBestSeq(n, ind, m, M, s)\n        if seq is not -1 and testSeq(k, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)\n\n#def findSeq(n, s, k, m, M):\n#    midInd = n // 2\n#    if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\n#        return genBestSeq(n, midInd + 1, m, M, s) \n#    elif k > midInd + 1 and n % 2 == 1:\n#        return -1\n#    return genBestSeq(n, midInd, m, M, s)\n\ndef genBestSeq(n, diffInd, m, M, s):\n    #inc = M - m - 1\n    arr = np.full((n,), m)\n    arr[diffInd:] += 1\n    #remainder = s - np.sum(arr)\n    #if remainder < 0:\n    #    return -1\n\n    #nFull, remainder = divmod(remainder, inc)\n    #if nFull > n or (nFull == n and remainder > 0):\n    #    return -1\n\n    #addingInd = n - nFull -1\n    #arr[addingInd + 1:] += inc\n    #arr[addingInd] += remainder\n    #return arr\n    s = s - np.sum(arr)\n    if s < 0:\n        return -1\n    inc = M - m - 1\n    ind = n - 1\n    while (ind >= 0):\n        z = min(inc, s)\n        arr[ind] += z\n        s -= z\n        ind -= 1\n    if s != 0:\n        return -1\n    return arr\n\ndef testSeq(k, seq):\n    seq = sorted(seq)\n    n = len(seq)\n    if n % 2 == 1:\n        median = seq[n // 2]\n    else:\n        median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n    seq.pop(n % k)\n    seq.pop(k - 1)\n    return (median != seq[(n - 2) // 2]) \n    \n\ndef __starting_point():\n    nCases = int(input())\n    answers = []\n    #ks = []\n    for i in range(nCases):\n        #nums = [int(val) for val in input().split()]\n        #ks.append(nums[2])\n        #answers.append(findSeq(*nums))\n        answers.append(findSeq(*(int(val) for val in input().split())))\n        ans = answers[-1]\n        if not isinstance(ans, int):\n            print(*ans, sep=' ')\n        else:\n            print(ans)\n    #for i, ans in enumerate(answers):\n\n    #for ans in answers:\n    #    if isinstance(ans, np.ndarray):\n    #        print(*ans, sep=' ')\n    #    else:\n    #        print(ans)\n\n__starting_point()", "# cook your dish here\nimport numpy as np\nimport sys\n\ndef findSeq(n, s, k, m, M):\n    midInd = n // 2\n    seqs = []\n    for ind in range(midInd + 2, midInd - 3, -1):\n        if ind >= n or ind < 0:\n            continue     \n        seq = genBestSeq(n, ind, m, M, s)\n        if seq is not -1 and testSeq(k, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)\n\n#def findSeq(n, s, k, m, M):\n#    midInd = n // 2\n#    if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\n#        return genBestSeq(n, midInd + 1, m, M, s) \n#    elif k > midInd + 1 and n % 2 == 1:\n#        return -1\n#    return genBestSeq(n, midInd, m, M, s)\n\ndef genBestSeq(n, diffInd, m, M, s):\n    #inc = M - m - 1\n    arr = np.full((n,), m)\n    arr[diffInd:] += 1\n    #remainder = s - np.sum(arr)\n    #if remainder < 0:\n    #    return -1\n\n    #nFull, remainder = divmod(remainder, inc)\n    #if nFull > n or (nFull == n and remainder > 0):\n    #    return -1\n\n    #addingInd = n - nFull -1\n    #arr[addingInd + 1:] += inc\n    #arr[addingInd] += remainder\n    #return arr\n    s = s - np.sum(arr)\n    if s < 0:\n        return -1\n    inc = M - m - 1\n    ind = n - 1\n    while (ind >= 0):\n        z = min(inc, s)\n        arr[ind] += z\n        s -= z\n        ind -= 1\n    if s != 0:\n        return -1\n    return arr\n\ndef testSeq(k, seq):\n    seq = sorted(seq)\n    n = len(seq)\n    if n % 2 == 1:\n        median = seq[n // 2]\n    else:\n        median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n    seq.pop(n % k)\n    seq.pop(k - 1)\n    return (median != seq[(n - 2) // 2]) \n    \n\ndef __starting_point():\n    nCases = int(input())\n    answers = []\n    #ks = []\n    for i in range(nCases):\n        #nums = [int(val) for val in input().split()]\n        #ks.append(nums[2])\n        #answers.append(findSeq(*nums))\n        answers.append(findSeq(*(int(val) for val in input().split())))\n        ans = answers[-1]\n        if not isinstance(ans, int):\n            print(*ans, sep=' ')\n        else:\n            print(ans)\n    #for i, ans in enumerate(answers):\n\n    #for ans in answers:\n    #    if isinstance(ans, np.ndarray):\n    #        print(*ans, sep=' ')\n    #    else:\n    #        print(ans)\n\n__starting_point()", "# cook your dish here\nimport numpy as np\nimport sys\n\ndef findSeq(n, s, k, m, M):\n    midInd = n // 2\n    seqs = []\n    for ind in range(midInd + 2, midInd - 3, -1):\n        if ind >= n or ind < 0:\n            continue     \n        seq = genBestSeq(n, ind, m, M, s)\n        if seq is not -1 and testSeq(k, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)\n\n#def findSeq(n, s, k, m, M):\n#    midInd = n // 2\n#    if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\n#        return genBestSeq(n, midInd + 1, m, M, s) \n#    elif k > midInd + 1 and n % 2 == 1:\n#        return -1\n#    return genBestSeq(n, midInd, m, M, s)\n\ndef genBestSeq(n, diffInd, m, M, s):\n    #inc = M - m - 1\n    arr = np.full((n,), m)\n    arr[diffInd:] += 1\n    #remainder = s - np.sum(arr)\n    #if remainder < 0:\n    #    return -1\n\n    #nFull, remainder = divmod(remainder, inc)\n    #if nFull > n or (nFull == n and remainder > 0):\n    #    return -1\n\n    #addingInd = n - nFull -1\n    #arr[addingInd + 1:] += inc\n    #arr[addingInd] += remainder\n    #return arr\n    s = s - np.sum(arr)\n    if s < 0:\n        return -1\n    inc = M - m - 1\n    ind = n - 1\n    while (ind >= 0):\n        z = min(inc, s)\n        arr[ind] += z\n        s -= z\n        ind -= 1\n    if s != 0:\n        return -1\n    return arr\n\ndef testSeq(k, seq):\n    seq = sorted(seq)\n    n = len(seq)\n    if n % 2 == 1:\n        median = seq[n // 2]\n    else:\n        median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n    seq.pop(n % k)\n    seq.pop(k - 1)\n    return (median != seq[(n - 2) // 2]) \n    \n\ndef __starting_point():\n    nCases = int(input())\n    answers = []\n    #ks = []\n    for i in range(nCases):\n        #nums = [int(val) for val in input().split()]\n        #ks.append(nums[2])\n        #answers.append(findSeq(*nums))\n        answers.append(findSeq(*(int(val) for val in input().split())))\n        ans = answers[-1]\n        if not isinstance(ans, int):\n            print(*ans, sep=' ')\n        else:\n            print(ans)\n    #for i, ans in enumerate(answers):\n\n    #for ans in answers:\n    #    if isinstance(ans, np.ndarray):\n    #        print(*ans, sep=' ')\n    #    else:\n    #        print(ans)\n\n__starting_point()", "import numpy as np\r\nimport sys\r\n\r\ndef findSeq(n, s, k, m, M):\r\n    midInd = n // 2\r\n    seqs = []\r\n    for ind in range(midInd + 2, midInd - 3, -1):\r\n        if ind >= n or ind < 0:\r\n            continue     \r\n        seq = genBestSeq(n, ind, m, M, s)\r\n        if seq is not -1 and testSeq(k, seq):\r\n            seqs.append(list(seq))\r\n    if len(seqs) == 0:\r\n        return -1\r\n    return min(seqs)\r\n\r\n#def findSeq(n, s, k, m, M):\r\n#    midInd = n // 2\r\n#    if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\r\n#        return genBestSeq(n, midInd + 1, m, M, s) \r\n#    elif k > midInd + 1 and n % 2 == 1:\r\n#        return -1\r\n#    return genBestSeq(n, midInd, m, M, s)\r\n\r\ndef genBestSeq(n, diffInd, m, M, s):\r\n    #inc = M - m - 1\r\n    arr = np.full((n,), m)\r\n    arr[diffInd:] += 1\r\n    #remainder = s - np.sum(arr)\r\n    #if remainder < 0:\r\n    #    return -1\r\n\r\n    #nFull, remainder = divmod(remainder, inc)\r\n    #if nFull > n or (nFull == n and remainder > 0):\r\n    #    return -1\r\n\r\n    #addingInd = n - nFull -1\r\n    #arr[addingInd + 1:] += inc\r\n    #arr[addingInd] += remainder\r\n    #return arr\r\n    s = s - np.sum(arr)\r\n    if s < 0:\r\n        return -1\r\n    inc = M - m - 1\r\n    ind = n - 1\r\n    while (ind >= 0):\r\n        z = min(inc, s)\r\n        arr[ind] += z\r\n        s -= z\r\n        ind -= 1\r\n    if s != 0:\r\n        return -1\r\n    return arr\r\n\r\ndef testSeq(k, seq):\r\n    seq = sorted(seq)\r\n    n = len(seq)\r\n    if n % 2 == 1:\r\n        median = seq[n // 2]\r\n    else:\r\n        median = (seq[n // 2 - 1] + seq[n // 2]) / 2\r\n    seq.pop(n % k)\r\n    seq.pop(k - 1)\r\n    return (median != seq[(n - 2) // 2]) \r\n    \r\n\r\ndef __starting_point():\r\n    nCases = int(input())\r\n    answers = []\r\n    #ks = []\r\n    for i in range(nCases):\r\n        #nums = [int(val) for val in input().split()]\r\n        #ks.append(nums[2])\r\n        #answers.append(findSeq(*nums))\r\n        answers.append(findSeq(*(int(val) for val in input().split())))\r\n        ans = answers[-1]\r\n        if not isinstance(ans, int):\r\n            print(*ans, sep=' ')\r\n        else:\r\n            print(ans)\r\n    #for i, ans in enumerate(answers):\r\n\r\n    #for ans in answers:\r\n    #    if isinstance(ans, np.ndarray):\r\n    #        print(*ans, sep=' ')\r\n    #    else:\r\n    #        print(ans)\r\n\n__starting_point()", "import numpy as np\r\nimport sys\r\n\r\ndef findSeq(n, s, k, m, M):\r\n    midInd = n // 2\r\n    seqs = []\r\n    for ind in range(midInd + 2, midInd - 3, -1):\r\n        if ind >= n or ind < 0:\r\n            continue     \r\n        seq = genBestSeq(n, ind, m, M, s)\r\n        if seq is not -1 and testSeq(k, seq):\r\n            seqs.append(list(seq))\r\n    if len(seqs) == 0:\r\n        return -1\r\n    return min(seqs)\r\n\r\n#def findSeq(n, s, k, m, M):\r\n#    midInd = n // 2\r\n#    if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\r\n#        return genBestSeq(n, midInd + 1, m, M, s) \r\n#    elif k > midInd + 1 and n % 2 == 1:\r\n#        return -1\r\n#    return genBestSeq(n, midInd, m, M, s)\r\n\r\ndef genBestSeq(n, diffInd, m, M, s):\r\n    #inc = M - m - 1\r\n    arr = np.full((n,), m)\r\n    arr[diffInd:] += 1\r\n    #remainder = s - np.sum(arr)\r\n    #if remainder < 0:\r\n    #    return -1\r\n\r\n    #nFull, remainder = divmod(remainder, inc)\r\n    #if nFull > n or (nFull == n and remainder > 0):\r\n    #    return -1\r\n\r\n    #addingInd = n - nFull -1\r\n    #arr[addingInd + 1:] += inc\r\n    #arr[addingInd] += remainder\r\n    #return arr\r\n    s = s - np.sum(arr)\r\n    if s < 0:\r\n        return -1\r\n    inc = M - m - 1\r\n    ind = n - 1\r\n    while (ind >= 0):\r\n        z = min(inc, s)\r\n        arr[ind] += z\r\n        s -= z\r\n        ind -= 1\r\n    if s != 0:\r\n        return -1\r\n    return arr\r\n\r\ndef testSeq(k, seq):\r\n    seq = sorted(seq)\r\n    n = len(seq)\r\n    if n % 2 == 1:\r\n        median = seq[n // 2]\r\n    else:\r\n        median = (seq[n // 2 - 1] + seq[n // 2]) / 2\r\n    seq.pop(n % k)\r\n    seq.pop(k - 1)\r\n    return (median != seq[(n - 2) // 2]) \r\n    \r\n\r\ndef __starting_point():\r\n    nCases = int(input())\r\n    answers = []\r\n    #ks = []\r\n    for i in range(nCases):\r\n        #nums = [int(val) for val in input().split()]\r\n        #ks.append(nums[2])\r\n        #answers.append(findSeq(*nums))\r\n        answers.append(findSeq(*(int(val) for val in input().split())))\r\n        ans = answers[-1]\r\n        if not isinstance(ans, int):\r\n            print(*ans, sep=' ')\r\n        else:\r\n            print(ans)\r\n    #for i, ans in enumerate(answers):\r\n\r\n    #for ans in answers:\r\n    #    if isinstance(ans, np.ndarray):\r\n    #        print(*ans, sep=' ')\r\n    #    else:\r\n    #        print(ans)\r\n\n__starting_point()", "import numpy as np\r\nimport sys\r\n\r\ndef findSeq(n, s, k, m, M):\r\n    midInd = n // 2\r\n    seqs = []\r\n    for ind in range(midInd + 2, midInd - 3, -1):\r\n        if ind >= n or ind < 0:\r\n            continue     \r\n        seq = genBestSeq(n, ind, m, M, s)\r\n        if seq is not -1 and testSeq(k, seq):\r\n            seqs.append(list(seq))\r\n    if len(seqs) == 0:\r\n        return -1\r\n    return min(seqs)\r\n\r\n#def findSeq(n, s, k, m, M):\r\n#    midInd = n // 2\r\n#    if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\r\n#        return genBestSeq(n, midInd + 1, m, M, s) \r\n#    elif k > midInd + 1 and n % 2 == 1:\r\n#        return -1\r\n#    return genBestSeq(n, midInd, m, M, s)\r\n\r\ndef genBestSeq(n, diffInd, m, M, s):\r\n    #inc = M - m - 1\r\n    arr = np.full((n,), m)\r\n    arr[diffInd:] += 1\r\n    #remainder = s - np.sum(arr)\r\n    #if remainder < 0:\r\n    #    return -1\r\n\r\n    #nFull, remainder = divmod(remainder, inc)\r\n    #if nFull > n or (nFull == n and remainder > 0):\r\n    #    return -1\r\n\r\n    #addingInd = n - nFull -1\r\n    #arr[addingInd + 1:] += inc\r\n    #arr[addingInd] += remainder\r\n    #return arr\r\n    s = s - np.sum(arr)\r\n    if s < 0:\r\n        return -1\r\n    inc = M - m - 1\r\n    ind = n - 1\r\n    while (ind >= 0):\r\n        z = min(inc, s)\r\n        arr[ind] += z\r\n        s -= z\r\n        ind -= 1\r\n    if s != 0:\r\n        return -1\r\n    return arr\r\n\r\ndef testSeq(k, seq):\r\n    seq = sorted(seq)\r\n    n = len(seq)\r\n    if n % 2 == 1:\r\n        median = seq[n // 2]\r\n    else:\r\n        median = (seq[n // 2 - 1] + seq[n // 2]) / 2\r\n    seq.pop(n % k)\r\n    seq.pop(k - 1)\r\n    return (median != seq[(n - 2) // 2]) \r\n    \r\n\r\ndef __starting_point():\r\n    nCases = int(input())\r\n    answers = []\r\n    #ks = []\r\n    for i in range(nCases):\r\n        #nums = [int(val) for val in input().split()]\r\n        #ks.append(nums[2])\r\n        #answers.append(findSeq(*nums))\r\n        answers.append(findSeq(*(int(val) for val in input().split())))\r\n        ans = answers[-1]\r\n        if not isinstance(ans, int):\r\n            print(*ans, sep=' ')\r\n        else:\r\n            print(ans)\r\n    #for i, ans in enumerate(answers):\r\n\r\n    #for ans in answers:\r\n    #    if isinstance(ans, np.ndarray):\r\n    #        print(*ans, sep=' ')\r\n    #    else:\r\n    #        print(ans)\r\n\n__starting_point()", "import numpy as np\nimport sys\n\ndef findSeq(n, s, k, m, M):\n    midInd = n // 2\n    seqs = []\n    for ind in range(midInd + 2, midInd - 3, -1):\n        if ind >= n or ind < 0:\n            continue     \n        seq = genBestSeq(n, ind, m, M, s)\n        if seq is not -1 and testSeq(k, seq):\n            seqs.append(list(seq))\n    if len(seqs) == 0:\n        return -1\n    return min(seqs)\n\n#def findSeq(n, s, k, m, M):\n#    midInd = n // 2\n#    if k <= midInd: #and (n % 2 == 1 or s < m * midInd + M * (n - midInd)):\n#        return genBestSeq(n, midInd + 1, m, M, s) \n#    elif k > midInd + 1 and n % 2 == 1:\n#        return -1\n#    return genBestSeq(n, midInd, m, M, s)\n\ndef genBestSeq(n, diffInd, m, M, s):\n    #inc = M - m - 1\n    arr = np.full((n,), m)\n    arr[diffInd:] += 1\n    #remainder = s - np.sum(arr)\n    #if remainder < 0:\n    #    return -1\n\n    #nFull, remainder = divmod(remainder, inc)\n    #if nFull > n or (nFull == n and remainder > 0):\n    #    return -1\n\n    #addingInd = n - nFull -1\n    #arr[addingInd + 1:] += inc\n    #arr[addingInd] += remainder\n    #return arr\n    s = s - np.sum(arr)\n    if s < 0:\n        return -1\n    inc = M - m - 1\n    ind = n - 1\n    while (ind >= 0):\n        z = min(inc, s)\n        arr[ind] += z\n        s -= z\n        ind -= 1\n    if s != 0:\n        return -1\n    return arr\n\ndef testSeq(k, seq):\n    seq = sorted(seq)\n    n = len(seq)\n    if n % 2 == 1:\n        median = seq[n // 2]\n    else:\n        median = (seq[n // 2 - 1] + seq[n // 2]) / 2\n    seq.pop(n % k)\n    seq.pop(k - 1)\n    return (median != seq[(n - 2) // 2]) \n    \n\ndef __starting_point():\n    nCases = int(input())\n    answers = []\n    #ks = []\n    for i in range(nCases):\n        #nums = [int(val) for val in input().split()]\n        #ks.append(nums[2])\n        #answers.append(findSeq(*nums))\n        answers.append(findSeq(*(int(val) for val in input().split())))\n        ans = answers[-1]\n        if not isinstance(ans, int):\n            print(*ans, sep=' ')\n        else:\n            print(ans)\n    #for i, ans in enumerate(answers):\n\n    #for ans in answers:\n    #    if isinstance(ans, np.ndarray):\n    #        print(*ans, sep=' ')\n    #    else:\n    #        print(ans)\n\n__starting_point()"]