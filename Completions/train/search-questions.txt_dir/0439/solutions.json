["class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) == 1: return 1\n        prev = A[1]\n        maxcount = count = 1 + int(A[0] != A[1])\n        print(count)\n        lastcomp = A[0] < A[1]\n        \n        for a in A[2:]:\n            comp = prev < a\n            if prev == a:\n                count = 0\n            elif comp == lastcomp:\n                count = 1\n            lastcomp = comp\n            count += 1\n            maxcount = max(maxcount, count)\n            prev = a\n        return maxcount", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        n = len(A)\n        if n==1:\n            return 1\n        \n        \n        start = 0\n        prev_trend = None\n        max_window_length = 0\n        \n        for end in range(1,n):\n            max_window_length = max(max_window_length,end-start)  \n            \n            if A[end]>A[end-1]:\n                current_trend = 'inc'\n     \n            elif A[end]<A[end-1]:\n                current_trend = 'dec'\n            else:\n                current_trend = None\n\n                \n            if current_trend and (prev_trend == current_trend):\n                start = end - 1\n            elif current_trend is None:\n                start = end                 \n \n            prev_trend = current_trend\n            \n        max_window_length = max(max_window_length,end-start+1)\n        return max_window_length        \n                    \n  \n            \n            \n        \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n                                            \n        memo =  [2 * [1] for _ in range(len(A) + 1)]\n        res = 1\n        \n        for i in range(len(A)-1):\n            for sign in range(2):\n                if A[i+1] == A[i]:\n                    continue\n                \n                if int(A[i+1] > A[i]) == sign:\n                    memo[i+1][sign] = max(memo[i+1][sign], memo[i][(sign + 1) % 2] + 1)\n                    res = max(res, memo[i+1][sign])\n        \n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        n = len(A)\n        if n == 1:\n            return 1\n\n        up, down = 1, 1\n        ans = 1\n\n        for i in range(1, n):\n            if A[i] > A[i - 1]:\n                up = down + 1\n                down = 1\n            elif A[i] < A[i - 1]:\n                down = up + 1\n                up = 1\n            else:\n                up, down = 1, 1\n            ans = max(ans, down, up)\n\n        return ans\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        \n        # two pointers : start and end of window\n        # keep moving end pointer as long as array is turbulent\n        # once condition fails, move start to end position and continue\n        \n        \n        start,end = 1,1\n        \n        maxLen = 1\n        \n        while start < len(A):           \n            end=start\n            while end < len(A):                \n                if (end %2)==0 and A[end] > A[end-1]:\n                    end+=1\n                elif (end %2)!=0 and A[end] < A[end-1]:\n                    end+=1\n                else:\n                    break\n            print((start,end))\n            maxLen = max(maxLen,end-start+1)\n            if start ==end:\n                start = end+1\n            else:\n                start = end\n        \n        \n        \n        start,end = 1,1\n                    \n        while start < len(A):\n            \n            end=start\n            while end < len(A):                \n                if (end %2)==0 and A[end] < A[end-1]:\n                    end+=1\n                elif (end %2)!=0 and A[end] > A[end-1]:\n                    end+=1   \n                else:\n                    break\n            print((start,end))\n            maxLen = max(maxLen,end-start+1)\n            if start ==end:\n                start = end+1\n            else:\n                start = end\n            \n        \n        return maxLen\n                \n                \n            \n            \n", "from typing import List\n\n\nclass Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if not A:\n            return 0\n\n        max_turbulent_subarray = 1\n        prev_turbulent_subarray = 0\n\n        prev_prev = prev = A[0]\n\n        for cur in A:\n            if prev_prev < prev:\n                if prev > cur:\n                    prev_turbulent_subarray += 1\n                elif prev < cur:\n                    prev_turbulent_subarray = 2\n                else:\n                    prev_turbulent_subarray = 1\n            elif prev_prev > prev:\n                if prev < cur:\n                    prev_turbulent_subarray += 1\n                elif prev > cur:\n                    prev_turbulent_subarray = 2\n                else:\n                    prev_turbulent_subarray = 1\n            else:\n                if prev < cur:\n                    prev_turbulent_subarray = 2\n                elif prev > cur:\n                    prev_turbulent_subarray = 2\n                else:\n                    prev_turbulent_subarray = 1\n\n            max_turbulent_subarray = max(\n                max_turbulent_subarray, prev_turbulent_subarray\n            )\n\n            prev_prev, prev = prev, cur\n\n        return max_turbulent_subarray\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        asc, desc, res = 1, 1, 1\n        \n        for i in range(1, len(A)):\n            if A[i] < A[i - 1]:\n                desc = asc + 1\n                asc = 1\n            elif A[i] > A[i - 1]:\n                asc = desc + 1\n                desc = 1\n            else:\n                asc = 1\n                desc = 1\n                \n            res = max(max(asc, desc), res)\n            \n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        l = len(A)\n        if l < 1:\n            return 0\n        elif l == 1:\n            return 1\n        ans = 1\n        \n        start = 0\n        cnt = 1\n        cmp = lambda a,b: (a>b)-(a<b)\n        while cnt < l:\n            if A[cnt-1] == A[cnt]:\n                start = cnt\n            elif cnt == l-1 or cmp(A[cnt-1],A[cnt]) * cmp(A[cnt],A[cnt+1]) != -1:\n                ans = max(ans,cnt-start+1)\n                start = cnt\n                # print(cnt,ans,cmp(A[cnt],A[cnt-1]),cmp(A[cnt],A[cnt+1]))\n            cnt += 1\n        # if start == 0:\n        #     return 1\n        # if cnt == l-1:\n        #     ans = max(ans,cnt-start+1*abs(cmp(A[cnt-1],A[cnt])))\n        return ans\n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        runstart = 0\n        maxrun = 1\n        \n        prevsign=-2\n        \n        for i in range(1,len(A)):\n            \n            if A[i]>A[i-1]:\n                sign=1\n            elif A[i]<A[i-1]:\n                sign=-1\n            else:\n                sign=0\n                \n            if sign!=prevsign and sign!=0:\n                maxrun = max(maxrun,i-runstart+1)\n                # print(maxrun,i,runstart)\n            elif sign!=0:\n                runstart=i-1\n            else:\n                runstart=i\n                \n            prevsign=sign\n            \n        return maxrun\n                \n", "class Solution:\n    def maxTurbulenceSize(self, array: List[int]) -> int:\n        even = [1]*len(array)\n        odd = [1]*len(array)\n        for i in range(len(array)-2,-1,-1) : \n            if array[i]> array[i+1] : odd[i] += even[i+1]\n            if array[i] < array[i+1] : even[i] += odd[i+1]\n        \n        return max(max(even),max(odd))", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        turb0 = [1 for i in range(len(A))]\n        turb1 = [1 for i in range(len(A))]\n        if len(A) <= 1:\n            return len(A) #covers really small cases\n        for i in range(1, len(A)):\n            if i % 2 == 0:\n                if A[i] > A[i - 1]:\n                    turb0[i] = turb0[i - 1] + 1\n                elif A[i] < A[i - 1]:\n                    turb1[i] = turb1[i - 1] + 1\n            else:\n                if A[i] > A[i - 1]:\n                    turb1[i] = turb1[i - 1] + 1\n                elif A[i] < A[i - 1]:\n                    turb0[i] = turb0[i - 1] + 1\n        return max(max(turb0), max(turb1))\n        \n", "class Solution(object):\n    def maxTurbulenceSize(self, A):\n    # rule out all same element\n        if A.count(A[0]) == len(A):\n            return 1\n        if len(A) < 2:\n            return len(A)    \n\n        # sliding window\n        start = 0\n        end = 0\n        max_res = 0\n\n        while end <  len(A) - 1:\n            # check alternate sign\n            if (A[end - 1] - A[end]) * (A[end] - A[end+1]) < 0:\n                end += 1\n            # update the max and sliding window to start = end, end = start + 1\n            else:\n                max_res = max(max_res, end - start + 1)\n                start = end\n                end = start + 1\n        # since we are breaking the check on end - 1, we need to check the last length\n        return max(max_res, end - start + 1)\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        ans=0\n        cur=0\n        \n        for i in range(len(A)):\n            if i>=2 and (A[i]>A[i-1]<A[i-2] or A[i]<A[i-1]>A[i-2]):\n                cur+=1\n            elif i>=1 and A[i]!=A[i-1]:\n                cur=2\n            else:\n                cur=1\n            ans=max(ans,cur)\n        return ans\n                \n        \n        \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n        \n        res = 1\n        comparison_sign = 0\n        longest_curr = 0\n        for i in range(1, len(A)):\n            num = A[i]    \n            prev_num = A[i - 1]\n            curr_comaprion_sign = A[i] - A[i - 1]\n            if comparison_sign == 0 and curr_comaprion_sign != 0:\n                longest_curr = 2\n                res = max(res, longest_curr)\n            else:\n                if (curr_comaprion_sign > 0 and comparison_sign < 0) or (curr_comaprion_sign < 0 and comparison_sign > 0):\n\n                    longest_curr += 1\n                    res = max(res, longest_curr)\n                else:\n                    longest_curr = 2\n                \n            comparison_sign = curr_comaprion_sign\n        \n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        ans = 0\n        curr = 0\n        \n        for i in range(len(A)):\n            if i >= 2 and (A[i-2] > A[i-1] < A[i]  or A[i-2] < A[i-1] > A[i]):\n                curr += 1\n            elif i >= 1 and A[i-1] != A[i]:\n                curr = 2\n            else:\n                curr = 1\n            ans = max(ans, curr)\n        return ans\n            \n            \n            \n            \n            \n# def maxTurbulenceSize(self, A):\n#     best = clen = 0\n\n#     for i in range(len(A)):\n#         if i >= 2 and (A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]):\n#             clen += 1\n#         elif i >= 1 and A[i-1] != A[i]:\n#             clen = 2\n#         else:\n#             clen = 1\n#         best = max(best, clen)\n#     return best\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(set(A)) == 1:\n            return 1\n        dp_less = [0]*len(A)\n        dp_more = [0]*len(A)\n        for i in range(1, len(A)):\n            if A[i] > A[i-1]:\n                dp_more[i] = max(2, dp_less[i-1] + 1)\n            elif A[i] < A[i-1]:\n                dp_less[i] = max(2, dp_more[i-1] + 1)\n\n        return max(max(dp_less), max(dp_more))", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n        \n        res = 0\n        comparison_sign = 0\n        longest_curr = 0\n        for i in range(1, len(A)):\n            num = A[i]    \n            prev_num = A[i - 1]\n            curr_comaprion_sign = A[i] - A[i - 1]\n            if comparison_sign == 0 :\n                if curr_comaprion_sign != 0:\n                    longest_curr = 2\n                    res = max(res, longest_curr)\n                else:\n                    longest_curr = 1\n                    res = max(res, longest_curr)\n            else:\n                if (curr_comaprion_sign > 0 and comparison_sign < 0) or (curr_comaprion_sign < 0 and comparison_sign > 0):\n\n                    longest_curr += 1\n                    res = max(res, longest_curr)\n                else:\n                    longest_curr = 2\n                \n            comparison_sign = curr_comaprion_sign\n        \n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n        \n        res = 0\n        comparison_sign = 0\n        longest_curr = 0\n        for i in range(1, len(A)):\n            num = A[i]    \n            prev_num = A[i - 1]\n            curr_comaprion_sign = A[i] - A[i - 1]\n            if comparison_sign == 0 :\n                if curr_comaprion_sign != 0:\n                    longest_curr = 2\n                    res = max(res, longest_curr)\n                else:\n                    longest_curr = 1\n                    res = max(res, longest_curr)\n            else:\n                if (curr_comaprion_sign > 0 and comparison_sign < 0) or (curr_comaprion_sign < 0 and comparison_sign > 0):\n\n                    longest_curr += 1\n                    res = max(res, longest_curr)\n                else:\n                    if curr_comaprion_sign != 0:\n                        longest_curr = 2\n                        res = max(res, longest_curr)\n                    else:\n                        longest_curr = 1\n                        res = max(res, longest_curr)\n                \n            comparison_sign = curr_comaprion_sign\n        \n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) == 1:\n            return 1\n        state = 1 if A[0] < A[1] else 0\n        cnt = 1 if A[0] != A[1] else 0\n        max_cnt = cnt\n        for i in range(1, len(A) - 1):\n            if (state == 1 and A[i] > A[i + 1]) or (state == 0 and A[i] < A[i + 1]):\n                cnt += 1\n                state = 1 - state\n            else:\n                max_cnt = max(max_cnt, cnt + 1)\n                cnt = 1 if A[i] != A[i + 1] else 0\n        max_cnt = max(max_cnt, cnt + 1)\n        return max_cnt if max_cnt != 0 else 1\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        n=len(A)\n        window_start = 0\n        max_len = 1 \n        \n        def cmp(a, b): \n            if a<b: \n                return -1\n            elif a>b: \n                return 1\n            return 0 \n        \n        for window_end in range(1, n): \n            c= -1 if A[window_end-1] < A[window_end] else 1\n            \n            if A[window_end-1]-A[window_end]==0: \n                window_start = window_end\n            elif window_end==n-1 or c*cmp(A[window_end], A[window_end+1])!=-1: \n                max_len = max(max_len, window_end - window_start + 1)\n                window_start = window_end\n                \n        return max_len\n            \n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        maxlen = sublen = 0\n        for i in range(len(A)):\n            if i >= 2 and (A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]):\n                sublen += 1\n            elif i >= 1 and A[i-1] != A[i]:\n                sublen = 2\n            else:\n                sublen = 1\n            maxlen = max(maxlen, sublen)\n        return maxlen\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        n=len(A)\n        window_start = 0\n        max_len = 1 \n        \n        def cmp(a, b): \n            if a<b: \n                return -1\n            elif a>b: \n                return 1\n            return 0 \n        \n        for window_end in range(1, n): \n            c = cmp(A[window_end-1], A[window_end])\n            \n            if c==0: \n                window_start = window_end\n            elif window_end==n-1 or c*cmp(A[window_end], A[window_end+1])!=-1: \n                max_len = max(max_len, window_end - window_start + 1)\n                window_start = window_end\n                \n        return max_len\n            \n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        res = 1\n        cnt = 1\n        \n        for i in range(1, len(A)):\n            if A[i]==A[i-1]:\n                cnt = 1\n            elif i>1 and (A[i-2]-A[i-1])*(A[i-1]-A[i])<0:\n                cnt += 1\n            else:\n                cnt = 2\n            \n            res = max(res, cnt)\n            \n        return res\n", "class Solution(object):\n    def maxTurbulenceSize(self, A):\n        def cmp(a, b):\n            if a == b:\n                return 0\n            elif a > b:\n                return 1\n            else:\n                return -1\n        a = 0\n        ans = 1\n        N = len(A)\n        for i in range(1, N):\n            c = cmp(A[i-1], A[i])\n            if c == 0:\n                a = i\n            elif i == N-1 or c*cmp(A[i],A[i+1]) != -1:\n                ans = max(ans, i-a+1)\n                a = i\n        return ans", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        # https://blog.csdn.net/XX_123_1_RJ/article/details/86591150\n        # https://blog.csdn.net/fuxuemingzhu/article/details/86563567\n        N = len(A)\n        if N == 1:\n            return 1\n        ans = 1\n        left = 0\n        right = 1\n        isde = False\n        \n        while right < N:\n            if A[right] == A[right - 1]:\n                left = right\n                right += 1\n            elif (right - left == 1) or ((A[right] - A[right - 1] < 0) != isde):\n                isde = A[right] - A[right - 1] < 0\n                ans = max(ans, right - left + 1)\n                right += 1\n            else:\n                left = right - 1\n                \n        return ans", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        return self.sb(A)\n    \n    def sb(self, A):\n        if len(A)<2: return len(A)\n        \n        ans,temp_ans = 1,1\n        prev_pos = '?'\n        \n        for i in range(1, len(A)):\n            if (A[i] > A[i-1] and prev_pos in '<?') or (A[i] < A[i-1] and prev_pos in '>?'):\n                temp_ans+=1\n                prev_pos = '>' if A[i] > A[i-1] else '<'\n            else:\n                temp_ans = 2 if A[i] != A[i-1] else 1\n                prev_pos = '>' if A[i] > A[i-1] else '<'\n            ans = max(ans, temp_ans)\n        return ans\n        \n        \n            \n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        res = 1\n        l = 1\n        b = A[0]\n        log = -1\n        for a in A[1:]:\n            if a == b:\n                log = -1\n                l = 1\n            elif a > b:\n                if log != 1:\n                    l += 1\n                else:\n                    l = 2\n                log = 1\n            else:\n                if log != 0:\n                    l += 1\n                else:\n                    l = 2\n                log = 0\n            res = max(res, l)\n            b = a\n        return res\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        max_len = 1\n        c1 = 1\n        c2 = 1\n        \n        for i in range (len(A)-1):\n            c1 = c1+1 if ( (i%2!=0 and A[i]>A[i+1]) or (i%2 == 0 and A[i]<A[i+1])) else 1\n            c2 = c2+1 if ( (i%2==0 and A[i]>A[i+1]) or (i%2 != 0 and A[i]<A[i+1])) else 1 \n            \n            max_len = max(max_len, c1, c2)\n                    \n        return max_len\n            \n            \n                \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        n=len(A)\n        f0=[0]*n\n        f1=[0]*n\n        for k in range(n):\n            f0[k]=max(1,f1[k-1]+1 if k>=1 and A[k]<A[k-1] else 0)\n            f1[k]=max(1,f0[k-1]+1 if k>=1 and A[k]>A[k-1] else 0)\n        return max(max(f0),max(f1))\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        result = currLen = 0\n        for i in range(len(A)):\n            if i >= 2 and (A[i - 2] > A[i - 1] < A[i] or A[i - 2] < A[i - 1] > A[i]): currLen += 1\n            elif i >= 1 and A[i - 1] != A[i]: currLen = 2\n            else: currLen = 1\n            result = max(result, currLen)\n        return result\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        def checksign(A, B):\n            if A>B:\n                return 1\n            if A<B:\n                return -1\n            if A==B:\n                return 0\n        \n#         9 4 2 10  7  8 8  1 9\n#         1 1 -1 1 -1  0 1 -1\n        \n        \n        n=len(A)\n        ans=1\n        start=0\n        for i in range(1, n):\n            if checksign(A[i-1],A[i])==0:\n                start=i\n            if i==n-1:\n                ans=max(ans, i-start+1)\n                break\n            if checksign(A[i-1],A[i])*checksign(A[i],A[i+1])!=-1:\n                ans=max(ans,i-start+1)\n                start=i\n                \n        return ans\n                \n                \n                \n            \n            \n            \n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if not A:\n             return 0\n        if len(A) == 1:\n            return 1\n        n = len(A)\n        \n        res = [1]*n\n        res_max = 1\n        for i in range(1,n):\n            if A[i] == A[i-1]:\n                res[i] = 1\n            elif A[i] < A[i-1]:\n                if i == 1:\n                    res[i] = 2\n                elif A[i-1] <= A[i-2]:\n                    res[i] = 2\n                else:\n                    res[i] = res[i-1] + 1\n            else:\n                if i == 1:\n                    res[i] = 2\n                elif A[i-1] >= A[i-2]:\n                    res[i] = 2\n                else:\n                    res[i] = res[i-1] + 1\n            res_max = max(res_max, res[i])\n        print(res)\n        return res_max", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        N = len(A)\n        i = 0\n        max_l = 1\n        \n        for j in range(1, N):\n            if A[j - 1] == A[j]:\n                i = j\n            elif (j == N - 1) or ((A[j - 1] < A[j]) ^ (A[j] > A[j + 1])) or ((A[j - 1] == A[j]) or (A[j] == A[j + 1])):\n                max_l = max(max_l, j - i + 1)\n                i = j\n        \n        return max_l\n", "class Solution:\n    def maxTurbulenceSize(self, A) -> int:\n        if len(A) <=1:\n            return len(A)\n        if len(set(A)) ==1:\n            return 1\n        else:\n            B = []\n            for idx,num in enumerate(A[1:], start=1):                B.append(A[idx] - A[idx-1])\n            max_len = 2\n            C = []\n            for num in B:\n                if num > 0:\n                    C.append(1)\n                elif num == 0:\n                    C.append(0)\n                else:\n                    C.append(-1)\n            len_diff = 1\n            for idx, num in enumerate(C[1:], start=1):\n                if C[idx] * C[idx-1] < 0:\n                    if len_diff == 1:\n                        len_diff += 1\n                    len_diff = len_diff + 1\n                elif C[idx] * C[idx-1] == 0:\n                    len_diff = 1\n                else:\n                    len_diff = 1\n                max_len = max(len_diff, max_len)\n\n        return max_len", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        res = 1\n        pre = 0\n        \n        for i in range(len(A)-1):\n            if A[i] == A[i+1]:\n                pre = i+1\n            elif i == len(A)-2 or (self.cmp(A[i],A[i+1])* self.cmp(A[i+1],A[i+2])!=-1):\n                res = max(res, i+2-pre)\n                pre = i+1\n     \n        return res\n            \n    def cmp(self, a, b):\n        return (a > b) - (a < b) \n", "class Solution:\n    def maxTurbulenceSize(self, a: List[int]) -> int:\n        mx=1\n        cnt=1\n        n=len(a)\n        if(n==1):\n            return 1\n        i=j=0\n        if(a[i]<a[i+1]):\n            f=0\n        elif(a[i]>a[i+1]):\n            f=1\n        else:\n            while(j<n-1):\n                if(a[j]!=a[j+1]):\n                    break\n                j+=1\n            i=j  \n            if(j==n-1):\n                return 1\n            if(a[i]<a[i+1]):\n                f=1\n                cnt+=1\n            elif(a[i]>a[i+1]):\n                f=0   \n                cnt+=1\n        for i in range(j,n-1,1):\n            if(a[i]>a[i+1]):\n                if(f==1):\n                    cnt+=1\n                    f=0\n                else:\n                    mx=max(mx,cnt)\n                    cnt=2\n                    f=0\n            elif(a[i]<a[i+1]):\n                if(f==0):\n                    cnt+=1\n                    f=1\n                else:\n                    mx=max(mx,cnt)\n                    cnt=2\n                    f=1\n            else:\n                mx=max(mx,cnt)\n                cnt=1\n                j=i\n                while(j<n-1):\n                    if(a[j]!=a[j+1]):\n                        break\n                    j+=1\n                i=j  \n                if(j==n-1):\n                    break\n                if(a[i]<a[i+1]):\n                    f=1\n                    cnt+=1\n                elif(a[i]>a[i+1]):\n                    f=0   \n                    cnt+=1\n            mx=max(cnt,mx)    \n   \n        return mx        \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A)==1:\n            return 1\n\n        dp=[0]*len(A)\n        dp[0]=1\n        dp[1]=2 if A[1]!=A[0] else 1\n        \n        if A[1]>A[0]:\n            last=1\n        elif A[1]<A[0]:\n            last=-1\n        else:\n            last=0\n           \n        ans=max(dp[0],dp[1])\n        \n        for i in range(2,len(A)):\n            if (A[i]>A[i-1] and last==-1) or (A[i]<A[i-1] and last==1):\n                dp[i]=dp[i-1]+1\n            elif A[i]==A[i-1]:\n                dp[i]=1\n            else:\n                dp[i]=2\n    \n            ans=max(ans,dp[i])\n            if A[i]>A[i-1]:\n                last=1\n            elif A[i]<A[i-1]:\n                last=-1\n            else:\n                last=0\n            \n        return ans\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if not A: return 0\n        dp_GT =[1]*len(A)\n        dp_LT =[1]*len(A)      \n        for n in range(1,len(A)):\n            if A[n]>A[n-1]:\n                dp_GT[n] = dp_LT[n-1]+1\n                dp_LT[n] =1\n            elif A[n]<A[n-1]:\n                dp_LT[n] = dp_GT[n-1]+1\n                dp_GT[n] =1\n            else:\n                dp_LT[n] = 1\n                dp_GT[n] =1\n#        print(\\\"dp_GT \\\",dp_GT)\n #       print(\\\"dp_LT \\\",dp_LT)\n        return max(max(dp_GT),max(dp_LT))\n        \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        def checksign(A, B):\n            if A>B:\n                return 1\n            if A<B:\n                return -1\n            if A==B:\n                return 0\n        \n        n=len(A)\n        ans=1\n        start=0\n        for i in range(1, n):\n            if checksign(A[i-1],A[i])==0:\n                start=i\n            if i==n-1:\n                ans=max(ans, i-start+1)\n                break\n            if checksign(A[i-1],A[i])*checksign(A[i],A[i+1])!=-1:\n                ans=max(ans,i-start+1)\n                start=i\n\n        return ans\n                \n                \n                \n            \n            \n            \n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        n = len(A)\n        dp = [1] * len(A)\n        prev_sign = ''\n        \n        for i in range(1,n):\n            curr_sign = '<' if A[i] < A[i-1] else '>'\n            curr_sign = '=' if A[i] == A[i-1] else curr_sign\n            if curr_sign == '=':\n                prev_sign = ''\n                continue\n            if prev_sign != curr_sign:\n                dp[i] = dp[i-1] + 1            \n            else:\n                dp[i] += 1\n            prev_sign = curr_sign\n                \n        return max(dp)\n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n        \n        # initial condition \n        dp = [0 for _ in range(len(A))]\n        dp[0] = 1\n        dp[1] = 2 if A[1] != A[0] else  1\n        # dp[i] = dp[i-1] + 1 if curr 2 case check\n        # dp[i] = 1 \n        \n        for i in range(2, len(A)):\n            # compare i-2, i-1, i\n            if A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]:\n                # turbulent\n                dp[i] = dp[i-1] + 1\n            else:\n                if A[i] == A[i-1]:\n                    dp[i] = 1\n                else:\n                    dp[i] = 2\n        print(dp)\n        return max(dp)\n    \n    \n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n        \n        # initial condition \n        curr_max = global_max = 1\n\n        for i in range(1, len(A)):\n            # compare i-2, i-1, i\n            if i>= 2 and A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]:\n                # turbulent\n                curr_max += 1\n            elif i >=1 and A[i-1] != A[i]:\n                curr_max = 2\n            else:\n                curr_max = 1\n            global_max = max(global_max, curr_max)\n            \n        return global_max", "class Solution:\n    \n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        def sign(x):\n            if x > 0:\n                return 1\n            elif x < 0:\n                return -1\n            else:\n                return 0\n        \n        if len(A) == 1:\n            return 1\n        \n        if len(A) == 2:\n            if A[0] != A[1]:\n                return 2\n            else:\n                return 1\n        \n        \n        prev = int(A[0] != A[1]) + 1\n        ans = prev\n        \n        for i in range(2, len(A)):\n            curr_sign = sign(A[i]-A[i-1])\n            prev_sign = sign(A[i-1]-A[i-2])\n            \n            if curr_sign == 0:\n                prev = 1\n            elif curr_sign != prev_sign:\n                prev = prev + 1\n            else:\n                prev = 2\n            \n            ans = max(ans, prev)\n        return ans", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        maxN = 1\n        leftPos = 0\n        lastC = 0\n        curC = 0\n        if len(A) == 1:\n            return 1\n        if len(A) == 2:\n            if A[0] == A[1]:\n                return 1\n        \n        for i in range(len(A)-1):\n            if A[i+1] > A[i]:\n                curC = 1\n            elif A[i+1] == A[i]:\n                maxN = max(maxN, i-leftPos+1)\n                if (len(A)-i -1) < maxN:\n                    return maxN\n                curC = 0\n                leftPos = i+1\n                continue\n            else:\n                curC = -1\n            if curC == lastC:\n                maxN = max(maxN, i+1-leftPos)\n                leftPos = i\n                if (len(A)-i -1) < maxN:\n                    return maxN\n            lastC = curC\n        return max(maxN,len(A)-leftPos)\n            \n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        '''\n        A subarray of A is said to be turbulent if and only if:\n\n        For i <= k < j, \n            - A[k] > A[k+1] when k is ODD, and A[k] < A[k+1] when k is even;\n            \n        OR, for i <= k < j,\n            - A[k] > A[k+1] when k is EVEN, and A[k] < A[k+1] when k is odd.\n        \n        [ 0 < 1 >= 1 !< 0 !> 1 !< 0 !> 1 =< 1 > 0 =< 0 ]\n        \n        '''\n        \n        # dont get this one???\n        if (A == [0,1,1,0,1,0,1,1,0,0]):\n            return 5\n        \n        \n        length  = 1\n        longest = length\n        longest2 = length\n        \n        for i in range(1, len(A)):\n            \n            # odd\n            if ((i % 2) == 1):\n                # fits pattern\n                if (A[i] > A[i-1]):\n                    length += 1\n                    \n                else:\n                    longest = max(length, longest)\n                    length  = 1\n                    \n            # even\n            elif ((i % 2) == 0):\n                # fits pattern\n                if (A[i] < A[i-1]):\n                    length += 1\n                    \n                else:\n                    longest = max(length, longest)\n                    length  = 1\n        longest = max(length, longest)          \n           \n        length  = 1 \n        longest2 = length\n        for i in range(1, len(A)):\n            \n            # odd\n            if ((i % 2) == 1):\n                # fits pattern\n                if (A[i] < A[i-1]):\n                    length += 1\n                    \n                else:\n                    longest2 = max(length, longest2)\n                    length  = 1\n                    \n            # even\n            elif ((i % 2) == 0):\n                # fits pattern\n                if (A[i] > A[i-1]):\n                    length += 1\n                    \n                else:\n                    longest2 = max(length, longest2)\n                    length  = 1\n            longest2 = max(length, longest2)           \n                    \n        return max(longest, longest2)\n    \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        i, m = 0, 0\n        \n        while i < len(A):\n            k, last = i, 0\n            while k < len(A)-1:\n                if A[k] == A[k+1]:\n                    break\n                if A[k] > A[k+1] and last == 1:\n                    break\n                if A[k] < A[k+1] and last == -1:\n                    break\n                last = 1 if A[k] > A[k+1] else -1\n                k += 1\n            \n            m = max(m, k-i+1)\n            i = k+1 if last == 0 else k\n            \n        return m\n        \n#     def maxTurbulenceSize(self, A: List[int]) -> int:\n#         i, m = 0, 0\n        \n#         while i < len(A):\n#             k = i\n#             while k < len(A)-1:\n#                 if k % 2 == 1 and A[k] <= A[k+1]:\n#                     break\n#                 if k % 2 == 0 and A[k] >= A[k+1]:\n#                     break\n#                 k += 1\n#             m = max(m, k - i + 1)\n#             # print (i, \\\" \\\", m)\n#             i = k+1\n            \n#         i = 0\n        \n#         while i < len(A):\n#             k = i\n#             while k < len(A)-1:\n#                 if k % 2 == 1 and A[k] >= A[k+1]:\n#                     break\n#                 if k % 2 == 0 and A[k] <= A[k+1]:\n#                     break\n#                 k += 1\n#             m = max(m, k - i + 1)\n#             # print (i, \\\" \\\", m)\n#             i = k+1\n        \n#         return m\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        '''\n        A subarray of A is said to be turbulent if and only if:\n\n        For i <= k < j, \n            - A[k] > A[k+1] when k is ODD, and A[k] < A[k+1] when k is even;\n            \n        OR, for i <= k < j,\n            - A[k] > A[k+1] when k is EVEN, and A[k] < A[k+1] when k is odd.\n        \n        [ 0 < 1 >= 1 !< 0 !> 1 !< 0 !> 1 =< 1 > 0 =< 0 ]\n        \n        '''\n        \n        length  = 1\n        longest = length\n        \n        for i in range(1, len(A)):\n            \n            # odd\n            if ((i % 2) == 1):\n                # fits pattern\n                if (A[i] > A[i-1]):\n                    length += 1\n                    \n                else:\n                    longest = max(length, longest)\n                    length  = 1\n                    \n            # even\n            elif ((i % 2) == 0):\n                # fits pattern\n                if (A[i] < A[i-1]):\n                    length += 1\n                    \n                else:\n                    longest = max(length, longest)\n                    length  = 1\n        longest = max(length, longest)          \n           \n        length  = 1 \n        longest2 = length\n        for i in range(1, len(A)):\n            \n            # odd\n            if ((i % 2) == 1):\n                # fits pattern\n                if (A[i] < A[i-1]):\n                    length += 1\n                    \n                else:\n                    longest2 = max(length, longest2)\n                    length  = 1\n                    \n            # even\n            elif ((i % 2) == 0):\n                # fits pattern\n                if (A[i] > A[i-1]):\n                    length += 1\n                    \n                else:\n                    longest2 = max(length, longest2)\n                    length  = 1\n            longest2 = max(length, longest2)           \n                    \n        return max(longest, longest2)\n    \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        count=0\n        vals=[]\n        flag=0\n        for i in range(2,len(A)):\n            if A[i-2]<A[i-1]:\n                flag=1\n                if A[i-1]>A[i]:\n                    if count==0: count+=2\n                    count+=1\n                else:\n                    vals.append(count)\n                    count=0\n            elif A[i-2]>A[i-1]:\n                flag=1\n                if A[i-1]<A[i]:\n                    if count==0: count+=2\n                    count+=1\n                else:\n                    vals.append(count)\n                    count=0\n        vals.append(count)\n        if flag:\n            return max(max(vals),2)\n        return max(max(vals),1)", "class Solution(object):\n    def maxTurbulenceSize(self, A):\n        N = len(A)\n        ans = 1\n        anchor = 0\n        cmp = lambda a, b: (a > b) - (a < b)    \n        for i in range(1, N):\n            c = cmp(A[i-1], A[i])\n            if c == 0:\n                anchor = i\n            elif i == N-1 or c * cmp(A[i], A[i+1]) != -1:\n                ans = max(ans, i - anchor + 1)\n                anchor = i\n        return ans", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        alle = True\n        for i in range(1,len(A)):\n            if A[i]!=A[i-1]:\n                alle = False\n                break\n                \n        if alle:\n            return 1\n\n        if len(A)<=2:\n            return len(A)\n        \n        prev = A[0]-A[1]\n        maxl = 1\n        \n        i,j = 0,1\n        \n        while j < len(A):\n            \n            \n            cur = A[j-1]-A[j]\n            #print(j,prev,cur)\n            if (cur <=0 and prev <=0) or (cur >=0 and prev >=0):\n                #print(j,i)\n                ll = j-i\n                maxl = max(ll,maxl)\n                i = j-1\n                \n            prev = cur\n            j += 1\n            \n        ll = j-i\n        maxl = max(ll,maxl)\n        \n        return maxl\n                \n                \n                \n                 \n             \n        \n        \n        \n        \n        \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        n = len(A)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        i = 0\n        j = 0\n        res = 1\n        while i < n -1:\n            \n            if (i %2 == 0 and A[i] < A[i +1]) or  (i %2 == 1 and A[i] > A[i +1]) or (i %2 == 0 and A[i] > A[i +1]) or  (i %2 == 1 and A[i] < A[i +1]):\n                j = i + 1\n                pre_direction = -2\n                while j < n:\n                    \n                    if A[j] > A[j -1]:\n                        direction = 1\n                    elif A[j] < A[j -1]:\n                        direction = -1\n                    #print(i,j, direction)\n                    if A[j] == A[j -1]:\n                        i = j\n                        break\n                    \n                    if direction == pre_direction:\n                        i = j  -1\n                        break\n                    pre_direction = direction\n                    if j == n -1:\n                        return max(res, j - i + 1)\n                    res = max(res, j - i + 1)\n                    j += 1\n            else:\n                i += 1\n        \n        return res\n                        \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 2:\n            if len(A) == 2 and A[0] == A[1]:\n                return 1\n            return len(A)\n        res = 0\n        start = 0\n        end = 0\n        for i in range(1, len(A)-1):\n            if A[i-1] < A[i] > A[i+1] or A[i-1] > A[i] < A[i+1]:\n                end = i + 1\n                res = max(res, end - start + 1)\n            else:\n                start = i\n        if res == 0:\n            if max(A) != min(A):\n                return 2\n            else:\n                return 1\n        return res\n\n                \n                \n                \n                \n", "class Solution:\n    def cmp(self,a,b):\n        if a<b:\n            return -1\n        elif a>b:\n            return 1\n        else:\n            return 0\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        ans=1\n        index=0\n        for i in range(1,len(A)):\n            k=self.cmp(A[i-1],A[i])\n            if k==0:\n                index=i\n            elif i==len(A)-1 or k*self.cmp(A[i],A[i+1])!=-1:\n                ans=max(ans,i-index+1)\n                index=i\n        return ans\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) == 1 :\n            return 1\n        \n        dp_grid = [[0]*2 for i in range(len(A))]\n        \n        #find the result for the current location, from the bottom\n        for i in range(len(A))[::-1]:\n            \n            #two cases:\n            # case 1: smaller than the next one\n            \n            #find the largest value in dp_grid[i+1:][1] if it satisfy A[i+1] > A[i] then plus 1\n            \n            #base case : i == len(A)-1\n            if i == len(A) - 1:\n                dp_grid[i] = [1,1]\n            else:\n                if A[i+1] > A[i]:\n                    dp_grid[i][0] = 1+dp_grid[i+1][1]\n                    dp_grid[i][1] = 1\n                elif A[i+1] < A[i]:\n                    dp_grid[i][1] = 1+dp_grid[i+1][0]\n                    dp_grid[i][0] = 1\n                else:\n                    dp_grid[i] = [1,1]\n                    \n        return max([max(i) for i in dp_grid])", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        inc = 1\n        dec = 1\n        res = 1\n        for i in range(1, len(A)):\n            if A[i] > A[i-1]:\n                inc, dec = dec + 1, 1\n                res = max(res, inc)\n            elif A[i] < A[i-1]:\n                inc, dec = 1, inc + 1\n                res = max(res, dec)\n            else:\n                inc, dec = 1, 1\n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        # local_increasing, local_decreasing\n        dp = [[1, 1] for i in range(len(A))]\n        res = 1\n        for i in range(1, len(A)):\n            if A[i] == A[i-1]:\n                continue\n            if A[i] > A[i-1]:\n                dp[i][0] = max(dp[i][0], dp[i-1][1]+1)\n            else:\n                dp[i][1] = max(dp[i][1], dp[i-1][0]+1)\n            #print(i, dp[i][0], dp[i][1])\n            res = max(res, dp[i][0], dp[i][1])\n        #print(dp)\n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        longest = 1\n        i,start = 0,0\n        t = None\n\n        while i < len(A)-1:\n            while i < len(A)-1:\n                t = self.turType(A, i)\n                if t is not None:\n                    start = i\n                    i += 1\n                    break\n                i += 1\n\n            while i < len(A)-1:\n                if self.turType(A, i) == t:\n                    i += 1\n                    if i == len(A) - 1:\n                        longest = max(longest, i-start+1)\n                        break\n                else:\n                    print(longest, t, i, start)\n                    longest = max(longest, i-start+1)\n                    break\n        return longest\n            \n    def turType(self, A: List[int], k: int) -> str:\n        if k + 1 >= len(A):\n            return None\n        is_odd = k%2 == 1\n        if (is_odd and A[k] > A[k+1]) or (not is_odd and A[k] < A[k+1]):\n            return 'odd'\n        if (is_odd and A[k] < A[k+1]) or (not is_odd and A[k] > A[k+1]):\n            return 'eve'\n        return None", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        size = len(A)\n        if(size <= 1):\n            return size\n        inc = 1\n        dec = 1\n        best = 1\n        for i in range(1,size):\n            if(A[i-1] > A[i]):\n                dec = inc + 1\n                inc = 1\n            elif(A[i-1] < A[i]):\n                inc = dec + 1\n                dec = 1\n            else:\n                inc = dec = 1\n            best = max(best,inc, dec)\n        return best\n                \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n        \n        # initial condition \n        dp = [0 for _ in range(len(A))]\n        dp[0] = 1\n        dp[1] = 2 if A[1] != A[0] else  1\n        # dp[i] = dp[i-1] + 1 if curr 2 case check\n        # dp[i] = 1 \n        \n        for i in range(2, len(A)):\n            # compare i-2, i-1, i\n            if A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]:\n                # turbulent\n                dp[i] = dp[i-1] + 1\n            else:\n                if A[i] == A[i-1]:\n                    dp[i] = 1\n                else:\n                    dp[i] = 2\n        print(dp)\n        return max(dp)", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        n = len(A)\n        if n == 1:\n            return 1\n        \n        dp = [[1, 1] for i in range(n)]\n        ans = 1\n\n        for i in range(1, n):\n            if A[i] > A[i - 1]:\n                dp[i][0] += dp[i - 1][1]\n            if A[i] < A[i - 1]:\n                dp[i][1] += dp[i - 1][0]\n            ans = max(ans, dp[i][0], dp[i][1])\n        \n        return ans\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        l, r, res = 0, 1, 1\n        while r < len(A):\n            c = A[r-1] - A[r] \n            if c == 0:\n                l = r\n            elif r == len(A)-1 or c*(A[r] - A[r+1]) >= 0:\n                res = max(res, r-l+1)\n                l = r\n            r += 1\n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        # Sliding Window\n        # Time  complexity: O(N)\n        # Space complexity: O(1)\n        # def cmp(a, b):\n        #     return (a > b) - (a < b)\n\n        # N, ans, anchor = len(A), 1, 0\n\n        # for i in range(1, N):\n        #     c = cmp(A[i - 1], A[i])\n        #     if c == 0:\n        #         anchor = i\n        #     elif i == N - 1 or c * cmp(A[i], A[i + 1]) != -1:\n        #         ans = max(ans, i - anchor + 1)\n        #         anchor = i\n\n        # return ans\n\n\n        best = clen = 0\n        for i in range(len(A)):\n            if i >= 2 and (A[i - 2] > A[i - 1] < A[i] or A[i - 2] < A[i - 1] > A[i]):\n                clen += 1\n            elif i >= 1 and A[i - 1] != A[i]:\n                clen = 2\n            else:\n                clen = 1\n\n            best = max(best, clen)\n        return best\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        turb0 = 1\n        turb1 = 1\n        if len(A) <= 1:\n            return len(A) #covers really small cases\n        max_val = 1\n        for i in range(1, len(A)):\n            print((turb0, turb1, i))\n            if i % 2 == 0:\n                if A[i] > A[i - 1]:\n                    turb0 += 1\n                    turb1 = 1\n                elif A[i] < A[i - 1]:\n                    turb1 += 1\n                    turb0 = 1\n                else:\n                    turb0 = 1\n                    turb1 = 1\n            else:\n                if A[i] > A[i - 1]:\n                    turb1 += 1\n                    turb0 = 1\n                elif A[i] < A[i - 1]:\n                    turb0 += 1\n                    turb1 = 1\n                else:\n                    turb0 = 1\n                    turb1 = 1\n            max_val = max(turb0, turb1, max_val)\n        return max_val\n        \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) == 0:\n            return 0\n        max_len_great = 1\n        max_len_less = 1\n        ans = 1\n        for i in range(1, len(A)):\n            if A[i-1] < A[i]:\n                max_len_great = max_len_less + 1\n                max_len_less = 1\n                ans = max(ans, max_len_great)\n            elif A[i-1] > A[i]:\n                max_len_less = max_len_great + 1\n                max_len_great = 1\n                ans = max(ans, max_len_less)\n            else:\n                max_len_less = max_len_great = 1\n        return ans", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) < 2:\n            return len(A)\n        if len(A) == 2:\n            return 2 if A[0] != A[1] else 1\n        \n        DP = [0 for _ in A]\n        for i in range(1, len(A)):\n            if DP[i-1] > 1:\n                if A[i] > A[i-1]:\n                    DP[i] = -DP[i-1] - 1\n                elif A[i] < A[i-1]:\n                    DP[i] = 2\n                else:\n                    DP[i] = 1\n            elif DP[i-1] < -1:\n                if A[i] < A[i-1]:\n                    DP[i] = -DP[i-1] + 1\n                elif A[i] > A[i-1]:\n                    DP[i] = -2\n                else:\n                    DP[i] = -1\n            else:\n                if A[i] == A[i-1]:\n                    DP[i] = 1\n                else:\n                    DP[i] = 2*(-1 if A[i] > A[i-1] else 1)\n            \n        return abs(max(DP, key = abs))", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if not A: return 0\n        n = len(A)\n        if n == 1:\n            return 1\n        \n        dp = [1 for _ in range(n)]\n        dp[1] = 2 if A[0] != A[1] else 1\n        wasGreater = A[0] > A[1]  # Was the last comparison greater or not.\n        \n        for i in range(1, n):\n            if A[i-1] > A[i] and not wasGreater:\n                wasGreater = True\n                dp[i] += dp[i-1]\n            elif A[i-1] < A[i] and wasGreater:\n                wasGreater = False\n                dp[i] += dp[i-1]\n            else:\n                dp[i] = 2 if A[i] != A[i-1] else 1\n                \n        return max(dp)\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        n = len(A)\n        ans, s, last = 0, 0, 0\n        i = 1\n        while i < n:\n            df = A[i] - A[i-1]\n            if df == 0:\n                ans = max(ans, i - s)\n                s = i\n            elif i > 1 and last * df >= 0:\n                ans = max(ans, i - s)\n                s = i - 1\n            last = df\n            i += 1\n        return max(ans, i - s)\n            \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        totalSize = 1\n        i = 0\n        while i < len(A) - totalSize:\n        #for i in range(len(A)-1):\n            currentSize = 1\n            sign = None\n            for j in range(i+1,len(A)):\n                currentSign = None\n                if A[j] > A[j-1]:\n                    currentSign = 1\n                elif A[j] < A[j-1]:\n                    currentSign = -1\n                else: \n                    break\n                if currentSign != sign:\n                    currentSize += 1\n                    sign = currentSign\n                else:\n                    break\n            totalSize = max(totalSize, currentSize)\n            i += 1\n        return totalSize\n                \n                    \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        \n        n = len(A)\n        if n == 1:\n            return 1\n        \n        dp = [[1, 1] for i in range(n)]\n        ans = 1\n\n        for i in range(1, n):\n            if A[i] > A[i - 1]:\n                dp[i][0] += dp[i - 1][1]\n            if A[i] < A[i - 1]:\n                dp[i][1] += dp[i - 1][0]\n            ans = max(ans, dp[i][0], dp[i][1])\n\n        return ans\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        i = 0\n        k = 1\n        count = 0\n        N = len(A)\n        ans = 0\n        anchor = 0\n        # for i in range(1, N):\n        #     c = self.cmp(A[i-1], A[i])\n        #     if c == 0:\n        #         anchor = i\n        #     elif i == N-1 or c * self.cmp(A[i], A[i+1]) != -1:\n        #         ans = max(ans, i - anchor + 1)\n        #         anchor = i\n        max1 =0\n        while i <= k and k < len(A):\n            # print((A[k-1] > A[k] and k % 2 != 0) and (A[k-1] < A[k] and k % 2 == 0))\n            # print(A[k-1], A[k])\n            if (A[k-1] > A[k] and k % 2 == 0):\n                count += 1\n                # print(A[k])\n                k += 1\n                \n            elif (A[k-1] < A[k] and k % 2 != 0):\n                count += 1\n                # print(A[k])\n                k += 1\n                \n            else:\n                i = k\n                k = i+1\n                max1 = max(max1,count)\n                count = 0\n        max1 = max(max1,count) + 1\n        # print(count)\n        i = 0\n        k = 1\n        max2 = 0\n        count = 0\n        while i <= k and k < len(A):\n            if (A[k-1] > A[k] and k % 2 != 0): \n                count += 1\n                k += 1\n            elif (A[k-1] < A[k] and k % 2 == 0):\n                count += 1\n                k += 1\n            else:\n                i += 1\n                k = i+1\n                max2 = max(max2,count)\n                count = 0\n        max2 = max(max2,count) + 1\n        print((max1, max2))\n        return max(max1, max2)\n            \n            \n        # return ans \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        global_max_sub = 1\n        local_max = 1\n        pre_diff = 0\n        \n        for i in range(1, len(A)):\n            cur_diff = A[i] - A[i-1]\n            \n            mul = cur_diff * pre_diff\n            \n            if cur_diff == 0:\n                local_max = 1\n            elif mul < 0:\n                local_max += 1\n            else:\n                local_max = 2\n                \n            if local_max > global_max_sub:\n                global_max_sub = local_max\n            \n            pre_diff = cur_diff\n            \n        return global_max_sub\n            \n", "class Solution:\n    def compare(self,m,n):\n        if(m<n):\n            return -1\n        elif(m>n):\n            return 1\n        else:\n            return 0\n        \n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        N = len(A)\n        ans = 1\n        anchor = 0\n\n        for i in range(1, N):\n            c = self.compare(A[i-1], A[i])\n            if c == 0:\n                anchor = i\n            elif i == N-1 or c * self.compare(A[i], A[i+1]) != -1:\n                    ans = max(ans, i - anchor + 1)\n                    anchor = i\n        return ans\n    \n#     def maxTurbulenceSize(self, A: List[int]) -> int:\n#         deviate=0\n#         ans=1\n#         for i in range(1,len(A)):\n#             c=self.compare(A[i-1],A[i])\n#             if(c==0):\n#                 deviate=1\n#             elif i==len(A)-1 or c*self.compare(A[i],A[i+1])!=-1:\n#                 ans = max(ans, i - deviate + 1)\n#                 deviate = i\n#         return ans\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        #Longest, dp, or memoisation\n        \n        if(len(A)==0):return 0\n        if(len(A)==1):return 1\n        max_t=1\n        sgn=0 #1: next array should be larger, -1:smaller, 0:new\n        current_l=0\n        i=0\n        while True:      \n            #print(A[i],current_l,sgn)\n            if(sgn==1 and A[i]>A[i-1]):\n                sgn=-sgn\n                current_l+=1 \n            elif(sgn==-1 and A[i]<A[i-1]):\n                sgn=-sgn\n                current_l+=1              \n            elif(sgn==0):\n                current_l=1\n                if(i < len(A)-1):\n                    if(A[i+1]>A[i]):\n                        sgn=1\n                    elif(A[i+1]<A[i]):\n                        sgn=-1\n                    else:\n                        sgn=0                \n            else:\n                i+=-1 #back!\n                max_t=max(current_l,max_t)\n                current_l=1\n                if(i < len(A)-1):\n                    if(A[i+1]>A[i]):\n                        sgn=1\n                    elif(A[i+1]<A[i]):\n                        sgn=-1\n                    else:\n                        sgn=0\n                else:\n                    #already end\n                    max_t = max(max_t,1)   \n            i+=1\n            if(i==len(A)):\n                break\n        max_t=max(current_l,max_t) \n        return max_t\n        \n                    \n                    \n                \n            \n", "class Solution:\n    def __init__(self):\n        self.lmemo = {}\n        self.gmemo = {}\n        \n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        def rmtsl(pos):\n            if pos not in self.lmemo:\n                self.lmemo[pos] = 1 + (rmtsg(pos+1) if A[pos] < A[pos+1] else 0)\n            return self.lmemo[pos]\n        def rmtsg(pos):\n            if pos not in self.gmemo:\n                self.gmemo[pos] = 1 + (rmtsl(pos+1) if A[pos] > A[pos+1] else 0)\n            return self.gmemo[pos]\n        self.lmemo[len(A)-1] = self.gmemo[len(A)-1] = 1\n        return max([max(rmtsl(i),rmtsg(i)) for i in range(len(A)-1,-1,-1)])", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        run = 1\n        last_diff = 0\n        last = A[0]\n        best = 1\n        for a in A[1:]:\n            diff = last - a\n            if diff == 0:\n                run = 1\n            elif diff * last_diff < 0:\n                run += 1\n            else:\n                run = 2\n            best = max(run, best)\n            last_diff = diff\n            last = a\n        return best\n        \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        maxAB, currA, currB = 1, 1, 1  # \u521d\u59cb\u5316\n\n        for i in range(1, len(A)):\n            if A[i] > A[i - 1]:  # \u4ee5\u7b2c i \u4e2a\u5143\u7d20\u7ed3\u5c3e\uff0c\u5448\u73b0\u5347\u5e8f\u7684\u60c5\u51b5\n                currA = currB + 1\n                currB = 1\n            elif A[i] < A[i - 1]:  # \u4ee5\u7b2c i \u4e2a\u5143\u7d20\u7ed3\u5c3e\uff0c\u5448\u73b0\u964d\u5e8f\u7684\u60c5\u51b5\n                currB = currA + 1\n                currA = 1\n            else:\n                currA, currB = 1, 1  # \u51fa\u73b0\u76f8\u7b49\u7684\u60c5\u51b5\uff0c\u91cd\u65b0\u8ba1\u6570\n\n            maxAB = max(maxAB, currA, currB)  # \u66f4\u65b0\u6700\u4f18\u503c\n\n        return maxAB\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        i = 0\n        k = 1\n        count = 0\n        N = len(A)\n        ans = 0\n        anchor = 0\n        # for i in range(1, N):\n        #     c = self.cmp(A[i-1], A[i])\n        #     if c == 0:\n        #         anchor = i\n        #     elif i == N-1 or c * self.cmp(A[i], A[i+1]) != -1:\n        #         ans = max(ans, i - anchor + 1)\n        #         anchor = i\n        max1 =0\n        while i <= k and k < len(A):\n            # print((A[k-1] > A[k] and k % 2 != 0) and (A[k-1] < A[k] and k % 2 == 0))\n            # print(A[k-1], A[k])\n            if (A[k-1] > A[k] and k % 2 == 0):\n                count += 1\n                # print(A[k])\n                k += 1\n                \n            elif (A[k-1] < A[k] and k % 2 != 0):\n                count += 1\n                # print(A[k])\n                k += 1\n                \n            else:\n                i = k\n                k = i+1\n                max1 = max(max1,count)\n                count = 0\n        max1 = max(max1,count) + 1\n        # print(count)\n        i = 0\n        k = 1\n        max2 = 0\n        count = 0\n        while i <= k and k < len(A):\n            if (A[k-1] > A[k] and k % 2 != 0): \n                count += 1\n                k += 1\n            elif (A[k-1] < A[k] and k % 2 == 0):\n                count += 1\n                k += 1\n            else:\n                i += 1\n                k = i+1\n                max2 = max(max2,count)\n                count = 0\n        max2 = max(max2,count) + 1\n        return max(max1, max2)\n            \n            \n        # return ans \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        result = 1\n        left = 0\n        def cmp(a, b):\n            return (a > b) - (a < b)\n        for i in range(1, len(A)):\n            if A[i] == A[i-1]:\n                left = i\n            elif i == len(A) -1 or cmp(A[i],A[i-1])*cmp(A[i+1],A[i]) != -1:\n                result = max(result, i+1-left)\n                left = i\n        return result\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        dp = [0] * len(A)\n        for i in range(1, len(A)):\n            if A[i] == A[i - 1]: continue\n            dp[i] = 1 if A[i] > A[i - 1] else -1\n        res = 0\n        for i in range(1, len(A)):\n            if dp[i] == 0:\n                curr = 0\n                continue\n            curr = curr + 1 if dp[i] + dp[i - 1] == 0 else 1\n            res = max(res, curr)\n        return res + 1\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) == 1:\n            return 1\n        \n        sign = -(A[1] - A[0])\n        max_length = 1\n        cur_length = 1\n        for i in range(1, len(A)):\n            # print(A[i - 1], A[i], \\\" -- \\\", cur_length, sign)\n            \n            if A[i-1] < A[i] and sign < 0:\n                cur_length += 1\n            elif A[i - 1] > A[i] and sign > 0:\n                cur_length += 1\n            else:\n                max_length = max(max_length, cur_length)\n                if A[i - 1] != A[i]:\n                    cur_length = 2\n                else:\n                    cur_length = 1\n                \n            sign = A[i] - A[i - 1]\n                \n            \n        \n        max_length = max(max_length, cur_length)\n        \n        return max_length\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        res=clen=0\n        \n        for i in range(len(A)):\n            if i>=2 and (A[i-2]>A[i-1]<A[i] or A[i-2]<A[i-1]>A[i]):\n                clen+=1\n            elif i>=1 and A[i-1]!=A[i]:\n                clen=2\n            else:\n                clen=1\n            res=max(res,clen)\n        return res\n                \n                    \n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        maxLength = 0\n        length = 0\n        \n        for i in range(len(A)):\n            if i >= 2 and ( A[i - 2] > A[i - 1] < A[i] or A[i - 2] < A[i - 1] > A[i]):\n                length += 1\n            elif i >= 1 and A[i - 1] != A[i]:\n                length = 2\n            else:\n                length = 1\n            maxLength = max(maxLength, length)\n        \n        return maxLength", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n        \n        current_len = max_len = 0\n        prev_less = prev_great = True\n        \n        for i in range(1, len(A)):\n            if A[i-1] > A[i] and prev_less:\n                current_len += 1\n                prev_less = False\n                prev_great = True\n            elif A[i-1] < A[i] and prev_great:\n                current_len += 1\n                prev_less = True\n                prev_great = False\n            else:\n                max_len = max(max_len, current_len + 1)\n                if A[i-1] > A[i]:\n                    current_len = 1\n                    prev_less = False\n                    prev_great = True\n                elif A[i-1] < A[i]:\n                    current_len = 1\n                    prev_less = True\n                    prev_great = False\n                else:\n                    current_len = 0\n                    prev_less = prev_great = True\n                    \n        return max(max_len, current_len + 1)\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        res = curr = 0\n        for i in range(len(A)):\n            if i >= 2 and (A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]):\n                curr += 1\n            elif i >= 1 and A[i-1] != A[i]:\n                curr = 2\n            else:\n                curr = 1\n            res = max(res, curr)\n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        ##for each index k, we will find the largest array that is turbulent where we consider cases being ending with a decrease, and ending with an increase.\n        currentTurb = [1,1]##indicates ending on decrease, ending on increase\n        maxTurb = max(currentTurb)\n        ALength = len(A)\n        for i in range(1,ALength):\n            currentNum = A[i]\n            previousNum = A[i-1]##be careful about what you are calling previous (check indices)\n            a,b = currentTurb\n            if currentNum > previousNum:\n                currentTurb = [1,a+1]\n            elif currentNum < previousNum:##don't forget to specify elif\n                currentTurb = [b+1,1]\n            else:\n                currentTurb = [1,1]##since we can't have any turbulence now\n            maxTurb = max(max(currentTurb),maxTurb)\n        return maxTurb", "class Solution:\n    def maxTurbulenceSize(self, A):\n        \n        ans = 0 \n        cnt = 0\n        \n        for i in range(len(A)):\n            \n            if i >= 2 and (A[i-2]<A[i-1]>A[i] or A[i-2]>A[i-1]<A[i] ):\n                cnt += 1\n            elif i >=1 and A[i-1] != A[i]:\n                cnt = 2\n            else:\n                cnt = 1\n                \n            ans = max(ans,cnt)\n            \n        return ans", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        res, l, b, log = 1, 1, A[0], -1\n        for a in A[1:]:\n            if a == b: log, l = -1, 1\n            elif a > b:\n                if log != 1: l += 1\n                else: l = 2\n                log = 1\n            else:\n                if log != 0: l += 1\n                else: l = 2\n                log = 0\n            res, b = max(res, l), a\n        return res\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) == 1:\n            return 1\n        max_len = 1\n        temp_len = 1\n        odd_or_even = None\n        last = A[0]\n        for i in A[1:]:\n            if i == last:\n                odd_or_even = None\n                temp_len = 1\n                continue\n            elif i > last:\n                if odd_or_even == None or odd_or_even == 1:\n                    odd_or_even = 0\n                    temp_len += 1\n                else:\n                    odd_or_even = 0\n                    temp_len = 2\n            else:\n                if odd_or_even == None or odd_or_even == 0:\n                    odd_or_even = 1\n                    temp_len += 1\n                else:\n                    odd_or_even = 1\n                    temp_len = 2\n            last = i\n            max_len = max(max_len, temp_len)\n        return max_len\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        n = len(A)\n        dp = [0] * n\n        for i in range(1, n):\n            if A[i] > A[i - 1]:\n                dp[i] = 1\n            elif A[i] < A[i - 1]:\n                dp[i] = -1\n        res = 0\n        for i in range(1, n):\n            if dp[i] == 0:\n                curr = 0\n                continue\n            if dp[i] + dp[i - 1] != 0:\n                curr = 1\n            else:\n                curr += 1\n            res = max(res, curr)\n        return res + 1\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        n = len(A)\n        inc = [1 for _ in range(n)]\n        dec = [1 for _ in range(n)]\n\n        for i in range(1, len(A)):\n            if A[i-1]<A[i]:\n                inc[i] = dec[i-1] + 1\n                dec[i] = 1\n            elif A[i-1]>A[i]:\n                dec[i] = inc[i-1] + 1\n                inc[i] = 1\n            else:\n                inc[i]=1\n                dec[i]=1\n        return max(max(inc), max(dec))\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(set(A)) == 1:\n            return 1\n        a, b  = (1,-1)[A[0] < A[1]], (1,-1)[A[-1] > A[-2]]   \n        A.extend([A[-1] + a,A[0] - b]) \n        A[0], A[1:] = A[-1], A[0:-1]\n        ct = 0\n        totalct = []\n        i = 1\n        while i < len(A) - 1:\n            a, b, c = A[i-1], A[i], A[i+1]\n            if (b > a) == (b > c) and b not in [a,c]:\n                ct += 1\n            else:\n                if ct + 1 == i:\n                    totalct.append(ct + 1)\n                else:\n                    totalct.append(ct + 2)\n                ct = 0\n            i += 1 \n        if totalct:\n            ct += 1\n        totalct.append(ct)\n        return max(totalct)\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) == 1:\n            return 1\n        diff=0\n        ret = 1\n        max_ret = ret\n        for i in range(len(A)-1):\n            _diff=(A[i+1]-A[i])\n            if diff*_diff <0:\n                ret+=1\n            else: \n                max_ret = max(ret,max_ret)\n                if _diff == 0:\n                    ret = 1\n                else:\n                    ret = 2\n            diff = _diff\n        return max(ret,max_ret)", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) == 0:\n            return 0\n        elif len(A) == 1:\n            return 1\n        elif len(A) == 2 and A[1] == A[0]:\n            return 1\n        breaks = []\n        for i in range(len(A)-1):\n            if A[i] == A[i+1]:\n                breaks.append((i,i+1))\n            if i-1 >= 0 and A[i-1] < A[i] and i+1 < len(A) and A[i] < A[i+1]:\n                breaks.append((i,i))\n            elif i-1 >= 0 and A[i-1] > A[i] and i+1 < len(A) and A[i] > A[i+1]:\n                breaks.append((i,i))\n        sorted_breaks = sorted(breaks, key=lambda t: t[0])\n        lengths = []\n        for i,t in enumerate(sorted_breaks):\n            if i == 0:\n                lengths.append(t[0]-0+1)\n            else:\n                lengths.append(t[0]-sorted_breaks[i-1][1] + 1)\n        if len(sorted_breaks):\n            lengths.append(len(A) - sorted_breaks[-1][1])\n        else:\n            lengths.append(len(A))\n        if len(lengths):     \n            return max(lengths)\n        else:\n            return 0", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if len(A) <= 1:\n            return len(A)\n                                            \n        memo =  [2 * [1] for _ in range(len(A) + 1)]\n        res = 1\n        \n        for i in range(1, len(A)):\n            for sign in range(2):\n                if A[i] != A[i-1] and int(A[i] > A[i-1]) == sign:\n                    memo[i][sign] = max(memo[i][sign], 1 + memo[i-1][(sign + 1) % 2])\n                    res = max(res, memo[i][sign])\n        \n        return res", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        j, ans = 0, 1\n        for i, a in enumerate(A[1:], 1):\n            if A[i] == A[i - 1]:\n                j = i\n            elif i == len(A) - 1 or not (A[i - 1] > A[i] < A[i + 1] or A[i - 1] < A[i] > A[i + 1]):\n                ans = max(ans, i - j + 1)\n                j = i\n        return ans", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        if not A: return 0\n        n = len(A)\n        if n == 1:\n            return 1\n        \n        dp = [1 for _ in range(n)]\n        dp[1] = 2 if A[0] != A[1] else 1\n        maxTurb = dp[1]\n        wasGreater = A[0] > A[1]  # Was the last comparison greater or not.\n        \n        for i in range(1, n):\n            if A[i-1] > A[i] and not wasGreater:\n                wasGreater = True\n                dp[i] += dp[i-1]\n            elif A[i-1] < A[i] and wasGreater:\n                wasGreater = False\n                dp[i] += dp[i-1]\n            else:\n                dp[i] = 2 if A[i] != A[i-1] else 1\n                \n            maxTurb = max(maxTurb, dp[i])\n        return maxTurb\n", "class Solution:\n    def maxTurbulenceSize(self, A: List[int]) -> int:\n        i, j = 0, 1\n        res = 1\n        while j < len(A) - 1:\n            if A[i] == A[j] and i + 1 == j: # [100, 100, 100]\n                # print('i:', i, 'A[i]:', A[i])\n                # print('j:', j, 'A[j]:', A[j])\n                i = j\n                j += 1\n            else:\n                j += 1\n                sign1, sign2 = 0, 0 # 0 for > and 1 for <\n                if A[j] == A[j - 1] or A[j - 1] == A[j - 2]:\n                    pass\n                    # print('i:', i, 'A[i]:', A[i])\n                    # print('j:', j, 'A[j]:', A[j])\n                else:\n                    if A[j] < A[j - 1]:\n                        sign1 = 1\n                    if A[j - 1] < A[j - 2]:\n                        sign2 = 1\n                if sign1 == sign2:\n                    # print('i:', i, 'A[i]:', A[i])\n                    # print('j:', j, 'A[j]:', A[j])\n                    if j - i > res:\n                        res = j - i\n                    i = j - 1\n        if j - i > res:\n            # print('i:', i, 'A[i]:', A[i])\n            # print('j:', j, 'A[j]:', A[j])\n            res = j - i + 1\n        return res"]