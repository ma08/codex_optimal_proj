["import re\n\ndef compare(a, b):\n    return a if specificity(a) > specificity(b) else b\n  \ndef specificity(s):\n    return [len(re.findall(r, s)) for r in (r'#\\w+', r'\\.\\w+', r'(^| )\\w+')]", "import re\ndef compare(a, b):\n\n  def scoreCSS(s):\n    d = {'#':0, '.':0, ' ':0}\n    for c in re.findall(\"[#\\. ](?=[\\w-])\", \" {}\".format(s)):\n        d[c] = d[c] + 1\n    return (d['#'], d['.'], d[' '])\n  \n  return a if (scoreCSS(a) > scoreCSS(b)) else b\n", "from functools import reduce\nimport re\n\n\nSIMPLE_SELECTOR_PATTERN = re.compile(r'[\\s+~>]+|(\\[[^[]+\\]|[#\\.:]?[^[\\s#\\.:+~>]+)')\nSPECIFICITY_PATTERN = re.compile(r'(^#)|(^[\\.\\[:][^:]?)|(^::|^[^#\\.:[])')\n\n\ndef compare(a, b):\n    return max((b,a), key=get_specificity)\n\n\ndef get_specificity(selector):\n    return reduce(sum_specificities, list(map(simple_selector_to_specificity, get_simple_selectors(selector))))\n\n\ndef sum_specificities(*specificities):\n    return list(map(sum, list(zip(*specificities))))\n\n\ndef simple_selector_to_specificity(simple_selector):\n    if simple_selector == '*':\n        return [0,0,0]\n    return [1 if x else 0 for x in SPECIFICITY_PATTERN.match(simple_selector).groups()]\n\n\ndef get_simple_selectors(selector):\n    return [\n        match.group(1)\n        for match in SIMPLE_SELECTOR_PATTERN.finditer(selector)\n        if match.group(1)\n    ]\n", "tagname = __import__(\"re\").compile(r\"(^|(?<=\\s))[^#\\.*]\").findall\n\ndef compare(a, b):\n    return max(b, a, key=lambda x: (x.count('#'), x.count('.'), len(tagname(x))))", "def tokenise(s, split='*#. '):\n    \"\"\"\n    Takes a string and splits it on any of the characters in the split string, \n    yields each split with the character used to split as it's prefix, with \n    the exception of spaces followed by another split character, when spaces \n    are removed\n    \n    Example:\n        split('.abc #123 .def.ghi *')\n    will yield the following strings:\n        '.abc', '#123', '.def', '.ghi', '*'\n    \"\"\"\n    buffer = ''\n    for c in s:\n        if c in split:\n            if buffer.strip():\n                yield buffer.strip()\n                buffer = ''\n        buffer += c\n    if buffer.strip():\n        yield buffer.strip()\n\ndef score_selector(selector):\n    \"\"\"\n    Given a CSS selector build a score for the selector that can be used for \n    sorting precendence.\n    \n    Returns a tuple with counts of the following:\n        (stars, ids, classes, tagnames)\n    Stars are numbered positively, the others are numbered negatively \n    so that natural ordering can be used without having to specify a key\n    for the sort call.\n    \"\"\"\n    low, ids, classes, tags = 0, 0, 0, 0\n    for part in tokenise(selector):\n        if part.startswith('.'):\n            classes -= 1\n        elif part.startswith('#'):\n            ids -= 1\n        elif part.startswith('*'):\n            low += 1\n        else:\n            tags -= 1\n        \n    return low, ids, classes, tags \n\n\ndef compare(a, b):\n    \"\"\"Compares two CSS selectors and returns the one with highest precedence\"\"\"\n    return sorted([(score_selector(s), -i, s) for i, s in enumerate([a, b])])[0][-1]\n", "import re\n\ndef compare(a, b):\n  [pa, pb] = [(x.count('#'), x.count('.'), len(re.findall(r\"[\\w']+\", x)) - x.count('#') - x.count('.')) for x in [a, b]]\n  return a if pa > pb else b", "import re\n\ndef key(t):\n    i,s = t\n    return (s.count('#'), s.count('.'), len(re.split(r'(?!<^)[ .#]+', s)), s!='*', i)\n\ndef compare(*args):\n    return max(enumerate(args), key=key)[1]", "def compare(a, b):\n    return max((b, a), key=lambda sel:\n        (sel.count('#'), sel.count('.'),\n            sum(not t.startswith(('.', '#', '*')) for t in sel.split())))"]