["class Solution:\n     def __init__(self):\n         self.k = 0\n         self.result = None\n \n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         if root.left and self.k < k:\n             self.kthSmallest(root.left, k)\n         self.k += 1\n         if self.k == k:\n             self.result = root.val\n         if root.right and self.k < k:\n             self.kthSmallest(root.right, k)\n         return self.result", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def find(self, root, k):\n         if root is None:\n             return (None, 0)\n         else:\n             (v, num), rnum = self.find(root.left, k), 0\n             if v is None:\n                 v, num = (root.val, 0) if num == k - 1 else (None, num)\n                 if v is None:\n                     v, rnum = self.find(root.right, k - num - 1)\n             return (v, num + rnum + 1)\n                 \n     \n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         return self.find(root, k)[0]", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         if root == None:\n             return None\n         else:\n             node = root\n             visited = []\n             count = 0\n             while node or visited:\n                 if node:\n                     visited.append(node)\n                     node = node.left\n                 else:\n                     cur = visited.pop()\n                     count = count+1\n                     if count == k:\n                         return cur.val\n                     else:\n                         node = cur.right\n             return None\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         cur = root\n         stack = []\n         count = 0\n         while(len(stack) > 0 or cur):\n             while(cur):\n                 stack.append(cur)\n                 cur = cur.left\n             tmp = stack.pop()\n             count += 1\n             if(count == k): return tmp.val\n             cur = tmp.right\n         return -1", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def helper(self,node):\n         if node is not None:\n             self.helper(node.left)\n             self.stack.append(node.val)\n             self.helper(node.right)\n         \n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         self.stack = []\n         if root is not None:\n             self.helper(root)\n             return self.stack[k-1]\n         else:\n             return None\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         res=[];\n         self.kthRec(root,res);\n         return res[k-1];\n     \n     def kthRec(self,root,res):\n         if(root!=None):\n             self.kthRec(root.left,res);\n             res.append(root.val);\n             self.kthRec(root.right,res);\n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         if not root:\n             return 0\n         \n         distanceToLeft = self.dfs(root.left)\n         if distanceToLeft + 1 == k:\n             return root.val\n         elif distanceToLeft + 1< k:\n             return self.kthSmallest(root.right, k - distanceToLeft - 1)\n         else:\n             return self.kthSmallest(root.left, k)\n     \n     def dfs(self, root):\n         if not root:\n             return 0\n         left = self.dfs(root.left)\n         right = self.dfs(root.right)\n         return left + right + 1", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def getlist(self, root):\n         if root == None:\n             return []\n         \n         s = []\n         \n         if root.left != None:\n             s = s + self.getlist(root.left)\n         s = s + [root.val]\n         if root.right != None:\n             s = s + self.getlist(root.right)\n         return s\n             \n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         s = self.getlist(root)\n         if len(s) == 0:\n             return 0\n         return s[k - 1]\n         \n                 \n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         stack = []\n         curr = root\n         count = 0\n         while True:\n             if curr:\n                 stack.append(curr)\n                 curr = curr.left\n             else:\n                 if stack:\n                     node = stack.pop()\n                     count += 1\n                     if count == k: return node.val\n                     curr = node.right\n                 else:\n                     return -1\n             \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         count=[0]\n         ans=[None]\n         \n         def search (head):\n             if not head:\n                 return\n             if head.left:\n                 search(head.left)\n             count[0] +=1\n             print(k,count[0])\n             if count[0]==k:\n                 ans[0]=head.val\n             search(head.right)\n         search(root)\n         return ans[0]", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def kthSmallest(self, root, k):\n         \"\"\"\n         :type root: TreeNode\n         :type k: int\n         :rtype: int\n         \"\"\"\n         return self.use_in_order_count_iteration(root, k)\n     \n     def use_binary_search(self, root, k):\n         # if tree is a balanced BST\n         count = self.count_tree(root.left)\n         if count + 1 == k:\n             return root.val\n         if count + 1 > k:\n             return self.use_binary_search(root.left, k)\n         else:\n             return self.use_binary_search(root.right, k - count - 1)\n         \n     def count_tree(self, node):\n         if not node:\n             return 0\n         return 1 + self.count_tree(node.left) + self.count_tree(node.right)\n     \n     def use_in_order_count(self, root, k):\n         self.count = k\n         self.ret = root.val\n         self.in_order_count(root, k)\n         return self.ret\n     \n     def use_in_order_count_iteration(self, root, k):\n         \n         stack = collections.deque()\n         curr = root\n         count = k\n         ret = root.val\n         while stack or curr:\n             while curr:\n                 stack.append(curr)\n                 curr = curr.left\n             node = stack.pop()\n             count -= 1\n             if count == 0:\n                 ret = node.val\n                 break\n             curr = node.right\n         return ret\n     \n     def in_order_count(self, node, k):\n         if not node:\n             return\n         self.in_order_count(node.left, k)\n         self.count -= 1\n         if self.count == 0:\n             self.ret = node.val\n             return\n         self.in_order_count(node.right, k)\n     \n     def use_in_order(self, root, k):\n         self.data = []\n         self.in_order(root)\n         return self.data[k-1]\n     \n     def in_order(self, root):\n         if not root:\n             return\n         self.in_order(root.left)\n         self.data.append(root.val)\n         self.in_order(root.right)"]