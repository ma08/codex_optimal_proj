["\"\"\"\n of course this is a dp problem.\n if we consider upper bound and lower bound for each sub tree, \n we will have a index-based solution over all posible numbers.\n \n each time we part a sub-tree into two parts, the question then becomes:\n how many possible boundaries can we find (start, end).\n \"\"\"\n \n class Solution:\n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         dp = dict()\n         ret = self.generate_recursively(list(range(1, n+1)), 0, n, dp)\n         if n == 0:\n             ret = []\n         return ret\n \n     # list is a sorted list of trees\n     def generate_recursively(self, l, start, end, dp):\n         ret = []\n         if end - start == 1:\n             ret = [TreeNode(l[start]),]\n         elif end - start <= 0:\n             ret = [None,]\n \n         # take each index as partition place\n         else:\n             for idx in range(0, end - start):\n                 left_nodes = dp[(start, start+idx)] if (start, start+idx) in dp.keys() else self.generate_recursively(l, start, start+idx, dp)\n                 right_nodes = dp[(start+idx+1, end)] if (start+idx+1, end) in dp.keys() else self.generate_recursively(l, start+idx+1, end, dp)\n \n                 for left in left_nodes:\n                     for right in right_nodes:\n                         root = TreeNode(l[start+idx])\n                         root.left = left \n                         # if left != '<E>' else None\n                         root.right = right \n                         # if right !='<E>' else None\n                         ret.append(root)\n         dp[(start, end)] = ret\n         return ret\n \n s = Solution()\n s.generateTrees(3)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if n <= 0:\n             return []\n         \n         mem = {}\n         \n         return self.genTrees(mem, 1, n)\n     \n     def genTrees(self, mem, start, end):\n         cached = mem.get((start, end))\n         if cached != None:\n             return cached\n         \n         if start > end:\n             return [None]\n         \n         if start == end:\n             return [TreeNode(start)]\n         \n         retVal = []\n         for i in range(start, end + 1):\n             left = self.genTrees(mem, start, i - 1)\n             right = self.genTrees(mem, i + 1, end)\n             \n             for lnode in left:\n                 for rnode in right:\n                     root = TreeNode(i)\n                     root.left = lnode\n                     root.right = rnode\n                     retVal.append(root)\n \n         mem[(start, end)] = retVal\n         return retVal\n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         \n         if n == 0:\n             return []\n         \n         root_dict = dict()\n         \n         def recur(start, end):\n             if start > end:\n                 return [None]\n             \n             rl = root_dict.get((start, end))\n             if not rl:\n                 rl = []\n                 for v in range(start, end+1):\n                     for lc in recur(start, v-1):\n                         for rc in recur(v+1, end):\n                             root = TreeNode(v)\n                             root.left, root.right = lc, rc\n                             rl.append(root)\n                             \n                 root_dict[(start, end)] = rl\n                 \n             return rl\n                         \n         return recur(1, n)\n                         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         \n         if n < 1: return []\n         \n         def genTrees(trees, i, j):\n             if (i, j) in trees: return trees[(i, j)]\n             if i > j: return [None]\n             \n             trees[(i, j)] = []\n             \n             for k in range(i, j + 1):\n                 leftTrees = genTrees(trees, i, k-1) \n                 rightTrees = genTrees(trees, k+1, j)\n                 newTrees = []\n                 for l in leftTrees:\n                     for r in rightTrees:\n                         newNode = TreeNode(k)\n                         newNode.left = l\n                         newNode.right = r\n                         newTrees.append(newNode)\n                 trees[(i, j)] += newTrees\n                 \n             return trees[(i, j)]\n         \n         trees = {}\n         return genTrees(trees, 1, n)\n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if not n:\n             return []\n         all_tress = {}\n         for r in range(1, n+1):\n             for start in range(1, n+2-r):\n                 end = start + r - 1\n                 all_tress[self.to_key(start, end)] = []\n                 if r == 1:\n                     all_tress[str(start) + str(end)] = [TreeNode(start)]\n                 else:\n                     for index_root in range(start, end + 1):\n                         left_trees = all_tress.get(self.to_key(start, index_root - 1), [None])\n                         right_trees = all_tress.get(self.to_key(index_root + 1, end), [None])\n                         for left_tree in left_trees:\n                             for right_tree in right_trees:\n                                 new_root = TreeNode(index_root)\n                                 new_root.left = left_tree\n                                 new_root.right = right_tree\n                                 all_tress[self.to_key(start, end)].append(new_root)\n         return all_tress.get(self.to_key(1, n))\n \n     def to_key(self, start, end):\n         return str(start) + str(end)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def generateSubTrees(self, left, right):\n         ret = []\n         if left >= right:\n             ret.append(None)\n         \n         for i in range(left, right):\n             left_sub_trees = self.generateSubTrees(left, i)\n             right_sub_trees = self.generateSubTrees(i + 1, right)\n             \n             for left_tree in left_sub_trees:\n                 for right_tree in right_sub_trees:\n                     root = TreeNode(i)\n                     root.left = left_tree\n                     root.right = right_tree\n                     ret.append(root)\n         return ret\n     \n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         \n         if n==0:\n             return []\n         return self.generateSubTrees(1, n+1)\n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         def helper(n, start):\n             if n < 1:\n                 return [None]\n             \n             res = []\n             for i in range(1, n+1):\n                 lefts = helper(i-1, start)\n                 rights = helper(n-i, start+i)\n                 \n                 for left in lefts:\n                     for right in rights:\n                         root = TreeNode(i+start)\n                         root.left = left\n                         root.right = right\n                         res.append(root)\n                         \n             return res\n         \n         return helper(n, 0) if n else []\n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def clone(self,root):\n         if root==None: return root\n         left=self.clone(root.left)\n         temp=TreeNode(self.n)\n         self.n+=1\n         temp.left=left\n         temp.right=self.clone(root.right)\n         return temp\n         \n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if n==0: return []\n         mapp={0:[None],1:[TreeNode(0)]}\n         \n         for i in range(2,n+1):\n             mapp[i]=[]\n             for l in range(0,i):\n                 r=i-l-1\n                 for treel in mapp[l]:\n                     for treer in mapp[r]:\n                         temp=TreeNode(0)\n                         temp.left=treel\n                         temp.right=treer\n                         mapp[i].append(temp)\n         ans=[]\n         for tree in mapp[n]:\n             self.n=1\n             temp=self.clone(tree)\n             ans.append(temp)\n         return ans\n                         \n                         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def clone(self,root):\n         if root==None: return root\n         temp=TreeNode(root.val)\n         temp.left=self.clone(root.left)\n         temp.right=self.clone(root.right)\n         return temp\n     def populate(self,root):\n         if root==None: return\n         self.populate(root.left)\n         root.val=self.n\n         self.n+=1\n         self.populate(root.right)\n         \n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if n==0: return []\n         mapp={0:[None],1:[TreeNode(0)]}\n         \n         for i in range(2,n+1):\n             mapp[i]=[]\n             for l in range(0,i):\n                 r=i-l-1\n                 for treel in mapp[l]:\n                     for treer in mapp[r]:\n                         temp=TreeNode(0)\n                         temp.left=treel\n                         temp.right=treer\n                         mapp[i].append(temp)\n         ans=[]\n         for tree in mapp[n]:\n             self.n=1\n             temp=self.clone(tree)\n             self.populate(temp)\n             ans.append(temp)\n         return ans\n                         \n                         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def clone(self,root):\n         if root==None: return root\n         temp=TreeNode(root.val)\n         temp.left=self.clone(root.left)\n         temp.right=self.clone(root.right)\n         return temp\n     def populate(self,root):\n         if root==None: return\n         self.populate(root.left)\n         root.val=self.n\n         self.n+=1\n         self.populate(root.right)\n         \n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if n==0: return []\n         mapp={0:[None],1:[TreeNode(0)]}\n         \n         for i in range(2,n+1):\n             mapp[i]=[]\n             for l in range(0,i):\n                 r=i-l-1\n                 for treel in mapp[l]:\n                     for treer in mapp[r]:\n                         temp=TreeNode(0)\n                         temp.left=self.clone(treel)\n                         temp.right=self.clone(treer)\n                         mapp[i].append(temp)\n         \n         for tree in mapp[n]:\n             self.n=1\n             self.populate(tree)\n         return mapp[n]\n                         \n                         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if not n:\n             return []\n         return self.generateBST(1,n)\n         \n     def generateBST(self,start,end):\n         res = []\n         if start>end:\n             res.append(None) \n         for i in range(start,end+1):\n             leftlists = self.generateBST(start,i-1)\n             rightlists = self.generateBST(i+1,end)\n             for left in leftlists:\n                 for right in rightlists:\n                     root = TreeNode(i)\n                     root.left = left\n                     root.right = right\n                     res.append(root)\n         return res ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def generateTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: List[TreeNode]\n         \"\"\"\n         if n == 0:\n             return []\n         rtnList = []\n         for i in range(n,0,-1):\n             newList = []\n             if rtnList == []:\n                 newList = [TreeNode(i)]\n             else:\n                 for t in rtnList:\n                     newList += self.insertNode(t, i)\n             rtnList = newList\n         return rtnList\n     \n     def insertNode(self, tree, i):\n         \"\"\"\n         insert node to the bottom left\n         \"\"\"\n         p = tree\n         rtnTree = []\n         node = TreeNode(i)\n         node.right = self.copyTree(tree)\n         rtnTree += node,\n         while True:\n             node = TreeNode(i)\n             newTree = self.copyTree(tree)\n             newP = newTree\n             while newP.val != p.val:\n                 newP = newP.left\n             node.right = newP.left\n             newP.left = node\n             rtnTree += newTree,\n             if p.left:\n                 p = p.left\n             else:\n                 break\n         return rtnTree\n         \n         \n     \n     def copyTree(self,tree):\n         newTree = None\n         if tree:\n             newTree = TreeNode(tree.val)\n         if tree.left:\n             newTree.left = self.copyTree(tree.left)\n         if tree.right:\n             newTree.right = self.copyTree(tree.right)\n         return newTree\n             \n         "]