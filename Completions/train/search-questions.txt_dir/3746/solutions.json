["def palindrome(n):\n    s = str(n)\n    return s[::-1] == s\n\ndef next_pal(val):\n    val += 1\n    while not palindrome(val):\n        val += 1\n    return val", "def next_pal(val):\n    int_to_digits = lambda n: [int(d) for d in str(n)]\n    digits_to_int = lambda a: int(\"\".join(map(str, a)))\n    \n    digits = int_to_digits(val)\n    half, odd = len(digits) // 2, len(digits) % 2\n    build = lambda start: digits_to_int(start + start[::-1][-half:])\n\n    base_start = digits[:half + odd]\n    possible = build(base_start)\n    if possible > val:\n        return possible\n    return build(int_to_digits(digits_to_int(base_start) + 1))\n", "def next_pal(val):\n    val += 1\n    while str(val) != str(val)[::-1]:\n        val += 1\n    return val", "def is_palindrome(n):\n    return str(n)[::-1] == str(n)\n\ndef next_pal(val):\n    for i in range(val + 1, 10*val):\n        if is_palindrome(i): return i\n", "def next_pal(val):\n    n = val+1\n    while n != int(str(n)[::-1]):\n        n += 1\n    return n   \n        \n    \n", "from itertools import count,dropwhile\n\ndef next_pal(val): return next(dropwhile(isNotPal, count(val+1)))\ndef isNotPal(n):   return n!=int(str(n)[::-1])", "def next_pal(val):\n    val += 1\n    while f\"{val}\" != f\"{val}\"[::-1]:\n        val += 1\n    return val", "def next_pal(val):\n    ret = val + 1\n    while str(ret) != str(ret)[::-1]:\n        ret += 1\n    return ret", "import itertools\n\ndef next_pal(val):\n    for n in itertools.count(val + 1):\n        s = str(n)\n        if s == s[::-1]:\n            return n"]