["from math import factorial,pi\nfrom fractions import Fraction\n\ndef comb(n,k):\n    return factorial(n)//(factorial(n-k)*factorial(k))\n\ndef bernoulli(m):\n    b=[1]\n    for i in range(1,m+1):\n        n=0\n        for k in range(0,i):\n            n+=comb(i+1,k)*b[k]\n        b.append(Fraction(-n,i+1))\n    return b\n\nb=bernoulli(31)\n\ndef series(k, nb) :\n    if k<0:\n        k=-k\n        return (b[k+1]*(-1)**k)/(k+1)\n    elif k%2==1:\n        return sum(1/(n**k) for n in range(1,nb+1))\n    else:\n        return abs(b[k])*((2*pi)**k)/(2*factorial(k))", "import math\n\nfrom scipy.special import comb\n\n\ndef Bornoulli(i):\n    if i == 0:\n        return 1\n    elif i == 1:\n        return -0.5\n    elif i % 2 == 1:\n        return 0\n    else:\n        s = 0\n        for k in range(i):\n            s -= comb(i, k) * Bornoulli(k) / (i - k + 1)\n        return s\n\ndef series(k, nb) :\n    if k  >= 2:\n        if k % 2 == 1:\n            return sum(1/i**k for i in range(1,nb+1))\n        else:\n            return 0.5 * abs(Bornoulli(k)) * (2 * math.pi) ** k / math.factorial(k)\n    elif k < -1:\n        return (-1) ** k * Bornoulli(-k+1) / (-k+1)", "import math \nfrom math import pi \ndef comb(n,k):\n    return(math.factorial(n)/math.factorial(n-k)/math.factorial(k))\n\ndef bernoulli():\n    A=[1]\n    yield A[0]\n    counter=0;\n    while True:\n        somma=0\n        p=len(A)\n        for i in range(len(A)):\n            somma+=A[i]*comb(p+1,i)/(p+1)\n        A.append(-somma)\n        if (len(A)<4 or len(A)%2==1):\n            counter+=1\n            yield A[counter]\n    \n\ndef series(k, nb) :\n    if (k%2==1 and k>2):\n        return sum(map(lambda x:1/(x**k), range(1,nb+1)))\n    bn2 = [ix for ix in zip(range(abs(k)+2), bernoulli())]\n    bn2 = [b for i,b in bn2]\n    if (k%2==0 and k>=2):\n        return 1/2*abs(bn2[k])*(2*pi)**k/math.factorial(k)\n    else:\n        k=abs(k)\n        return ((-1)**k*bn2[k+1]/(k+1))", "from math import factorial as f\nimport numpy as np\n\ndef combination(n, k):\n    return f(n) // (f(k) * f(n-k))\n\ndef bern(target_level):\n    b0 = 1\n    b1 = -(1./2.)\n    bern_nums = [b0,b1]\n    n = 3\n    while n <= target_level + 1:\n        ser = []\n        k = 0\n        comb_list = []\n        while k < n - 1:\n            comb_list.append(combination(n, k))\n            k += 1\n        result_l = [c*b for c,b in zip(comb_list, bern_nums)]\n        result_s = 0\n        for element in result_l:\n            result_s += element\n        b_k = -result_s / combination(n,k)\n        bern_nums.append(b_k)\n        n += 1\n    return bern_nums[-1]\n    \n\ndef series(k, nb) :\n    if k > 2 and k % 2 != 0:\n        n = 1\n        result = 0\n        while n <= nb:\n            result += 1/(n**k)\n            n += 1\n        return result\n    elif k >= 2 and k % 2 == 0:\n        bern_num = bern(k)\n        return 1./2. * abs(bern_num) * (2*np.pi)**k / f(k)\n    else:\n        k = abs(k)\n        bern_num = bern(k+1)\n        return (-1)**k * bern_num / (k + 1)\n    return 0\n    \n    \n    \n    \n    \n    \n    \n", "from fractions import Fraction\nimport math\n\ndef comb(m,n):\n    return math.factorial(m)//(math.factorial(n)*math.factorial(m-n))\n\ndef simplify(a,b):\n    return [a // math.gcd(a, b), b // math.gcd(a, b)]\n\narr=[[1,1],[-1,2]]\n\ndef _b(n):\n    product_denominators=1\n    triangles = []\n    for i in range(0,n):\n        p=comb(n,i)\n        triangles.append(p)\n        if i<len(arr):\n            product_denominators*=arr[i][1]\n    sum_numerator=0\n    for i in range(0,n-1):\n        p = (product_denominators * arr[i][0] // arr[i][1]) * triangles[i]\n        sum_numerator += p\n    [a, b] = simplify(-sum_numerator, product_denominators * triangles[-1])\n    arr.append([a,b])\ndef b(n):\n    if n%2 and n>1:\n        return 0\n    if n>=len(arr):\n        for i in range(len(arr)+1,n+2):\n            _b(i)\n    return arr[n]\n\n\ndef series(k, nb) :\n    if k>0 and k%2==0:\n        temp = b(k)\n        bk = abs(temp[0] / temp[1])\n        fk = math.factorial(k)\n        return (1 / 2) * bk * (2 * math.pi) ** k / fk\n    elif k>0 and k%2:\n        sum=0\n        for i in range(1,nb):\n            sum+=1/(i)**k\n        return sum\n    elif k<0:\n        temp = b(1 - k)\n        bk = temp[0] / temp[1] if type(temp) is list else temp\n        return (-1) ** (-k) * bk / (1 - k)"]