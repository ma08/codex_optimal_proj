["def bishop_diagonal(a, b):\n    a, b = sorted([['abcdefgh'.index(f), '12345678'.index(r)] for f, r in [a, b]])\n    m = int((b[1] - a[1])/(b[0] - a[0])) if abs(a[1] - b[1]) == abs(a[0] - b[0]) and abs(a[1] - b[1]) else 0\n    if m:\n        while all(0 < e < 7 for e in a): a = [a[0] - 1, a[1] - m]\n        while all(0 < e < 7 for e in b): b = [b[0] + 1, b[1] + m]\n    return ['abcdefgh'[c] + '12345678'[r] for c, r in [a, b]]", "# Convert chess notation to zero indexed tuple (x, y)\nint_pos = lambda s: (ord(s[0]) - ord(\"a\"), int(s[1]) - 1)\n# Convert zero indexed tuple (x, y) to chess notation\nnote_pos = lambda t: \"{}{}\".format(chr(t[0] + ord(\"a\")), t[1] + 1)\n\ndef bishop_extend(pos, move):\n    \"\"\"\n    Extend a bishops attack position in the given move\n    direction, until a legal move is not possible\n    yielding each legal position in turn\n    \"\"\"\n    x, y = pos\n    dx, dy = move\n    while 0 <= x + dx < 8 and 0 <= y + dy < 8:\n        x += dx\n        y += dy\n        yield (x, y)\n\ndef bishop_attack(pos):\n    \"\"\"\n    Given a position, return a dict of all possible \n    attackable positions and the direction of movement\n    required to attack that position\n    \"\"\"\n    result = {}\n    for dx, dy in [(x, y) for x in [-1, 1] for y in [-1, 1]]:\n        for attack_pos in bishop_extend(pos, (dx, dy)):\n            result[attack_pos] = (dx, dy)\n    return result\n\ndef bishop_diagonal(bishop1, bishop2):\n    \"\"\"\n    Given two bishops on a chess board, if they are able to attack each other\n    move them as far apart as possible.\n    \"\"\"\n    b1, b2 = int_pos(bishop1), int_pos(bishop2)\n    b1_attack, b2_attack = bishop_attack(b1), bishop_attack(b2)\n    if b1 in b2_attack:\n        # Attack paths intersect\n        b1d, b2d = b1_attack[b2], b2_attack[b1]\n        # move b1 in the direction b2 attacked and keep last legal move\n        bishop1 = note_pos(list(bishop_extend(b1, b1d))[-1])\n        # Same for b2\n        bishop2 = note_pos(list(bishop_extend(b2, b2d))[-1])\n    return sorted([bishop1, bishop2])\n", "import re\n\ndef moveBishop(bs, deltas):\n    posBishops = []\n    for b,coef in zip(bs, [-1,1]):\n        while True:\n            tmpPos = ''.join( chr(ord(l) + coef*direc) for l,direc in zip(b, deltas) )\n            if not bool(re.match(r'[a-h][1-8]', tmpPos)): break\n            b = tmpPos\n        posBishops.append(b)\n    return posBishops\n    \ndef bishop_diagonal(*args):\n    bishops = sorted(args)\n    deltas = [ ord(b) - ord(a) for a,b in zip(*bishops) ]\n    return moveBishop(bishops, list(map(lambda v: v//abs(v), deltas))) if len(set(map(abs, deltas))) == 1 else bishops", "def on_left_diagonal(b1, b2):\n    return b1[0] + b1[1] == b2[0] + b2[1]\n\ndef on_right_diagonal(b1, b2):\n    return b1[0] - b2[0] == b1[1] - b2[1]\n\n\ndef bishop_diagonal(bishop1, bishop2):\n    b1, b2 = (ord(bishop1[0]) - 96, int(bishop1[1])), (ord(bishop2[0]) - 96, int(bishop2[1]))\n    \n    if on_left_diagonal(b1, b2):\n        key = b1[0] + b1[1]\n        if key < 10:\n            return ['a' + str(key - 1), chr(key + 95) + '1']\n        else:\n            return [chr(key + 88) + '8', 'h' + str(key - 8)]\n    elif on_right_diagonal(b1, b2):\n        if b1[0] >= b1[1]:\n            return [chr(b1[0] - b1[1] + 97) + '1', 'h' + str(8 - b1[0] + b1[1])]\n        else:\n            return ['a' + str(b1[1] - b1[0] + 1), chr(b1[1] - b1[0] + 100) + '8']\n    else:\n        return sorted([bishop1, bishop2])", "def bishop_diagonal(A, B):\n    t = lambda x: (ord(x[0]) - 97, 8 - int(x[1]))\n    I = lambda x: ''.join([chr(97 + x[0]), str(8 - x[1])])\n    a1, a2 = t(A)\n    b1, b2 = t(B)\n    if a1 + a2 != b1 + b2 and a1 - a2 != b1- b2:\n        return sorted([B, A])\n    E =((a1-b1)//abs(a1-b1), (a2-b2)//abs(a2-b2))\n    while min(a1, a2) != 0 and max(a1, a2) != 7:\n        a1 += E[0]\n        a2 += E[1]\n    while min(b1, b2) != 0 and max(b1, b2) != 7:\n        b1 -= E[0]\n        b2 -= E[1]\n    return sorted([I((a1,a2)), I((b1, b2))])", "def bishop_diagonal(bishop1, bishop2):\n    coords = lambda p: ('abcdefgh'.index(p[0]), int(p[1]) - 1)\n    pos = lambda i, j: 'abcdefgh'[i] + str(j + 1)\n    x, y = coords(bishop1)\n    u, v = coords(bishop2)\n    if x + y == u + v:\n        d = x + y\n        c = [pos(max(0, d - 7), d - max(0, d - 7)), pos(min(7, d), d - min(7, d))]\n    elif x - y == u - v:\n        d = x - y\n        c = [pos(max(0, d), max(0, d) - d), pos(min(7, 7 + d), min(7, 7 + d) - d)]\n    else:\n        c = [bishop1, bishop2]\n    return sorted(c)", "import string\n\nchars = [char for char in string.ascii_lowercase[:8]]\nnumbs = [char for char in string.digits[1:9]]\n\nchessboard = {}\n\nx = -1\nfor let in chars:\n    x += 1\n    y = 0\n    for num in numbs:\n        chessboard[let + num] = [x, y]\n        y += 1\n\ndef bishop_diagonal(bishop1, bishop2):\n    result = []\n    same_diagonal = False\n    bishop1_coord = chessboard[bishop1.lower()]\n    bishop2_coord = chessboard[bishop2.lower()]\n\n    directions = [[1,1], [-1,1], [1,-1], [-1,-1]]\n\n    for direction in directions:\n        pos_coord = bishop1_coord[:]\n        while pos_coord[0] > -1 and pos_coord[0] < 8 and pos_coord[1] > -1 and pos_coord[1] < 8 and bishop2_coord != pos_coord:\n            pos_coord[0] += direction[0]\n            pos_coord[1] += direction[1]\n\n            if bishop2_coord == pos_coord:\n                direction_to_bishop2 = direction\n                same_diagonal = True\n\n    if same_diagonal:\n        pos_coord = bishop2_coord[:]\n        while pos_coord[0] > 0 and pos_coord[0] < 7 and pos_coord[1] > 0 and pos_coord[1] < 7:\n            pos_coord[0] += direction_to_bishop2[0]\n            pos_coord[1] += direction_to_bishop2[1]\n\n        bishop2_to_field = pos_coord[:]\n\n        direction_to_bishop1 = [x * -1 for x in direction_to_bishop2]\n\n        pos_coord = bishop1_coord[:]\n        while pos_coord[0] > 0 and pos_coord[0] < 7 and pos_coord[1] > 0 and pos_coord[1] < 7:\n            pos_coord[0] += direction_to_bishop1[0]\n            pos_coord[1] += direction_to_bishop1[1]\n\n        bishop1_to_field = pos_coord[:]\n\n        result.append(list(chessboard.keys())[list(chessboard.values()).index(bishop1_to_field)])\n        result.append(list(chessboard.keys())[list(chessboard.values()).index(bishop2_to_field)])\n        result.sort()\n        return result\n\n    else:\n        result.append(bishop1)\n        result.append(bishop2)\n        result.sort()\n        return result\n", "def bishop_diagonal(bishop1, bishop2):\n    \n    rank, file = ord(bishop1[0]) - ord(bishop2[0]), int(bishop1[1]) - int(bishop2[1])\n    \n    if abs(rank) == abs(file):\n        \n        ranksign, filesign = -1 if rank < 0 else 1, -1 if file < 0 else 1\n        \n        while bishop1[0] not in \"ah\" and bishop1[1] not in \"18\":\n            bishop1 = chr(ord(bishop1[0]) + ranksign) + str(int(bishop1[1]) + filesign) \n    \n        while bishop2[0] not in \"ah\" and bishop2[1] not in \"18\":\n            bishop2 = chr(ord(bishop2[0]) - ranksign) + str(int(bishop2[1]) - filesign)\n        \n    return sorted([bishop1, bishop2])", "def bishop_diagonal(bishop1, bishop2):\n    \n    board = [i+str(j) for i in 'abcdefgh' for j in range(1,9)]\n    \n    diagonal1 = [m for m in board if abs(ord(m[0])-ord(bishop1[0])) == abs(int(m[1]) - int(bishop1[1]))]\n    diagonal2 = [m for m in board if abs(ord(m[0])-ord(bishop2[0])) == abs(int(m[1]) - int(bishop2[1]))]\n    diagonal = list(set(diagonal1).intersection(set(diagonal2)))\n        \n    if abs(ord(bishop1[0])-ord(bishop2[0])) == abs(int(bishop1[1])-int(bishop2[1])):\n    \n        top = [m for m in diagonal if int(m[1]) == max([int(i[1]) for i in diagonal])][0]\n        bottom = [m for m in diagonal if int(m[1]) == min([int(i[1]) for i in diagonal])][0]\n        return sorted([top,bottom])\n    \n    else:\n        return sorted([bishop2,bishop1]) # not on same diagonal", "def bishop_diagonal(bishop1, bishop2):\n    letters = ' abcdefgh'\n    x1, y1 = int(letters.index(bishop1[0])), int(bishop1[1])\n    x2, y2 = int(letters.index(bishop2[0])), int(bishop2[1])\n    if abs(x1 - x2) == abs(y1 - y2):\n        xdir = (x1 - x2) // abs(x1 - x2)\n        ydir = (y1 - y2) // abs(y1 - y2)\n        while 1 < x1 < 8 and 1 < y1 < 8:\n            x1 += xdir\n            y1 += ydir\n        while 1 < x2 < 8 and 1 < y2 < 8:\n            x2 -= xdir\n            y2 -= ydir\n    return sorted([letters[x1] + str(y1), letters[x2] + str(y2)])"]