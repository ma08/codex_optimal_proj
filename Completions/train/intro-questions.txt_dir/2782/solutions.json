["import operator\n\ndef calc(expr):\n    OPERATORS = {'+': operator.add, '-': operator.sub, '*': operator.mul, '/': operator.truediv}\n    stack = [0]\n    for token in expr.split(\" \"):\n        if token in OPERATORS:\n            op2, op1 = stack.pop(), stack.pop()\n            stack.append(OPERATORS[token](op1,op2))\n        elif token:\n            stack.append(float(token))\n    return stack.pop()", "operator = set(['+', '-', '*', '/'])\n\ndef calc(expr):\n    stack = list()\n    for c in expr.split():\n        if c in operator : \n            first = stack.pop()\n            second = stack.pop()\n            stack.append(str(eval(second + c + first)))\n        else : stack.append(c)\n    return eval(stack.pop()) if stack else 0", "def calc(expr):\n    # Empty\n    if len(expr.strip()) < 1:\n        return 0\n\n    # Only Numbers\n    if expr.count('+') == 0 and expr.count('-') == 0 and expr.count('*') == 0 and expr.count('/') == 0:\n        return float(expr.split(' ')[-1])\n\n    # Normal\n    op_flags = '+-*/'\n    nums = []\n    ops = []\n    expr_list = expr.split(' ')\n\n    for e in expr_list:\n        if e in op_flags:\n            b = float(nums.pop())\n            a = float(nums.pop())  # Reverse the order.\n\n            if e == '+':\n                nums.append(a + b)\n            elif e == '-':\n                nums.append(a - b)\n            elif e == \"*\":\n                nums.append(a * b)\n            elif e == \"/\":\n                nums.append(a / b)\n        else:\n            nums.append(e)\n\n    return nums[0]", "OPS = {'+': lambda x, y: y + x, '-': lambda x, y: y - x, '*': lambda x, y: y * x, '/': lambda x, y: y / x}\n\n\ndef calc(expr):\n    if not expr:\n        return 0\n    stack = []\n    [stack.append(*map(OPS[sign], [stack.pop()], [stack.pop()])) if sign in OPS else stack.append(float(sign)) for sign in expr.split(' ')]\n    return stack[-1]", "def calc(s):\n    ops = {\"+\": (lambda x, y: x + y), \"-\": (lambda x, y: x - y), \"*\": (lambda x, y: x * y), \"/\": (lambda x, y: x - y)}\n    pre = [0]\n    for i in s.split():\n        if i in ops:\n            b, a = pre.pop(), pre.pop()\n            pre.append(ops[i](a, b))\n        else:\n            pre.append(float(i))\n    return pre.pop()", "def calc(expr):\n    oplist=[]\n    if expr=='': return 0\n    for op in expr.split(' '):\n        try:\n            op=float(op)\n            oplist.append(op)            \n        except ValueError:\n            op2=oplist.pop()\n            op1=oplist.pop()\n            oplist.append(eval(str(op1)+op+str(op2)))\n    return oplist.pop()\n", "ops = {\"+\": (lambda x,y: x+y), \"-\": (lambda x,y: x-y), \"*\": (lambda x,y: x*y), \"/\": (lambda x,y: x/y)}\n\ndef calc(expr): #obscure version\n    stack, tokens = [], expr.split(\" \") if expr != \"\" else [\"0\"]\n    for token in tokens: stack.append(float(token)) if token not in ops else stack.append(ops[token](*(stack.pop(), stack.pop())[::-1]))\n    return stack[-1]", "def calc(expr):\n  stack = []\n  [stack.append(eval(\"{1}{2}{0}\".format(stack.pop(), stack.pop(), e)) if e in ('+', '-', '/', '*') else e) for e in expr.split()]\n  return float(stack.pop()) if stack else 0", "def calc(expr):\n    print(expr)\n    s = [0]\n    for arg in expr.split(' '):\n        try:\n            s.append(float(arg))\n        except:\n            try:\n                s.append(eval(f\"{s.pop(-2)} {arg} {s.pop(-1)}\"))\n            except:\n                pass\n    \n    return s[-1]\n"]