["import numpy\n\ndef poly_from_roots(r): return list(reversed(numpy.poly(tuple(r)))) if len(r)>0 else [1]", "from collections import Counter\nfrom itertools import product\nfrom functools import reduce\nfrom operator import mul\n\nclass P(Counter):\n    def __mul__(self, other):\n        m = P()\n        for (ao, av), (bo, bv) in product(self.items(), other.items()):\n            m[ao+bo] += av*bv\n        return m\n        \ndef poly_from_roots(roots):\n    result = reduce(mul, (P({0: -r, 1: 1}) for r in roots), P({0: 1}))\n    return [result[i] for i in range(len(roots) + 1)]", "from numpy.polynomial import polynomial as P\n\ndef poly_from_roots(r):\n    return P.polyfromroots(r).tolist()", "def poly_from_roots(r):\n    lst = [1]\n    while r:\n        v   = -r.pop()\n        lst.append(0)\n        lst = [1 if i==len(lst)-1 else x*v+lst[i-1] for i,x in enumerate(lst)]\n    return lst\n", "from functools import reduce\nfrom itertools import combinations\n\ndef poly_from_roots(r):\n    return [sum(reduce(lambda x, y: -x * y, c, 1) for c in combinations(r, i)) for i in range(len(r), -1, -1)]", "def poly_multiply(p1, p2):\n    answer = [0] * (len(p1) + len(p2) - 1)\n    for i, coeff1 in enumerate(p1):\n        for j, coeff2 in enumerate(p2):\n            answer[i + j] += coeff1 * coeff2\n    return [] if all(coeff == 0 for coeff in answer) else answer\n\ndef poly_from_roots(r):\n    if not r:\n        return [1]\n    parts = [[-root, 1] for root in r]\n    answer = parts[0]\n    for part in parts[1:]:\n        answer = poly_multiply(answer, part)\n    return answer", "from numpy import poly\npoly_from_roots=lambda r:list(reversed(poly(r))) if len(r) else [1]", "from itertools import combinations\nfrom functools import reduce\nfrom operator import mul\ndef poly_from_roots(r):\n    res = []\n    for p in range(len(r)+1):\n        factor = sum(reduce(mul, [v for v in k], 1)\n                     for k in combinations(r, p))\n        res.append(-factor if p % 2 else factor)\n    return res[::-1]"]