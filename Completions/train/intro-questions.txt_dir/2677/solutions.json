["import re\n\nH, W     = 6, 8\nKEYBOARD = \"abcde123fghij456klmno789pqrst.@0uvwxyz_/* \"\nMAP      = {c: (i//W, i%W) for i,c in enumerate(KEYBOARD)}\n\n\ndef manhattan(*pts):\n    dxy = [abs(z2-z1) for z1,z2 in zip(*pts)]\n    return 1 + sum( min(dz, Z-dz) for dz,Z in zip(dxy, (H,W)) )\n\ndef toggle(m):\n    ups, end = m.groups()\n    return f'*{ups.lower()}*{end}'                    # Toggle Shift ON if uppercase presents, and then OFF if lowercase after (or end of the string)\n\n\ndef tv_remote(words):\n    reWords = re.sub(r'([A-Z][^a-z]*)([a-z]?)', toggle, words).rstrip('*')                # Strip any useless toggle OFF at the end\n    return sum( manhattan(MAP[was], MAP[curr]) for was,curr in zip('a'+reWords, reWords))\n", "from collections import namedtuple\n\nPosition = namedtuple('Position', 'y x')\n\n\ndef tv_remote(word: str):\n    remote = (\n        'a', 'b', 'c', 'd', 'e', '1', '2', '3',\n        'f', 'g', 'h', 'i', 'j', '4', '5', '6',\n        'k', 'l', 'm', 'n', 'o', '7', '8', '9',\n        'p', 'q', 'r', 's', 't', '.', '@', '0',\n        'u', 'v', 'w', 'x', 'y', 'z', '_', '/',\n        '', ' '\n    )\n    shift, shift_pressed = Position(5, 0), False\n\n    prev = Position(0, 0)\n    button_presses = 0\n    for letter in word:\n        if letter.isalpha() and letter.isupper() != shift_pressed:\n            button_presses += calc_presses(prev, shift)\n            prev, shift_pressed = shift, not shift_pressed\n\n        cur = Position(*divmod(remote.index(letter.lower()), 8))\n        button_presses += calc_presses(prev, cur)\n        prev = cur\n\n    return button_presses\n\n\ndef calc_presses(pos1: Position, pos2: Position):\n    dif_y, dif_x = abs(pos1.y - pos2.y), abs(pos1.x - pos2.x)\n    return min(dif_y, 6 - dif_y) + min(dif_x, 8 - dif_x) + 1", "def tv_remote(word):\n    caps, cases, shift = coords[\"\u2191\"], (str.isupper, str.islower), 0\n    moves, current = 0, (0, 0)\n    for char in word:\n        target = coords[char.lower()]\n        if cases[shift](char):\n            moves, current, shift = moves + distance(current, caps), caps, 1 - shift\n        moves, current = moves + distance(current, target), target\n    return moves\n\nkeyboard = (\"abcde123\", \"fghij456\", \"klmno789\", \"pqrst.@0\", \"uvwxyz_/\", \"\u2191 \")\ncoords = {char: (line.index(char), y) for y, line in enumerate(keyboard) for char in line}\n\ndef distance(pos1, pos2):\n    d0, d1 = abs(pos2[0] - pos1[0]), abs(pos2[1] - pos1[1])\n    return 1 + min(d0, 8 - d0) + min(d1, 6 - d1)", "def navigate(s,e):\n    a = 'abcde123fghij456klmno789pqrst.@0uvwxyz_/*&'\n    d = {i: [a.index(i)//8, a.index(i)%8] for i in a}\n    x=0\n    y=0\n    i=0\n    j=0\n    rowdis=0\n    coldis=0\n    for k,v in d.items():\n        if k == s:\n            i = v[0]\n            j = v[1]\n        if k == e:\n            x = v[0]\n            y = v[1]\n        if abs(i-x) > 2.5:\n            if i<x:\n                rowdis = 6+i-x\n            else : rowdis = 6-i+x\n        else : rowdis = abs(i-x)\n        if abs(j-y) > 3.5:\n            if j<y:\n                coldis = 8+j-y\n            else : coldis = 8-j+y\n        else : coldis = abs(j-y)\n    return rowdis + coldis\ndef tv_remote(word):\n    ans = 0\n    cursor = 'a'\n    shift = False\n    for c in word:\n        if c.isspace():        \n            ans += navigate(cursor,'&') + 1\n            cursor = '&'\n            continue\n        if c in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n            if c.isupper():\n                if not shift:\n                    ans += navigate(cursor,'*') + 1\n                    shift = True\n                    cursor = '*'\n            if c.islower():\n                if shift:\n                    ans += navigate(cursor,'*') + 1\n                    shift = False\n                    cursor = '*'\n        ans += navigate(cursor,c.lower()) + 1\n        cursor = c.lower()\n    return ans", "def tv_remote(word):\n    matrix = [\n             ['a', 'b', 'c', 'd', 'e', '1', '2', '3'],\n             ['f', 'g', 'h', 'i', 'j', '4', '5', '6'],\n             ['k', 'l', 'm', 'n', 'o', '7', '8', '9'],\n             ['p', 'q', 'r', 's', 't', '.', '@', '0'],\n             ['u', 'v', 'w', 'x', 'y', 'z', '_', '/'],\n             ['aA', ' '],\n             ]\n\n    vertical_inversion = {0:0, 1:1, 2:2, 3:3, 4:2, 5:1}\n    horizontal_inversion = {0:0, 1:1, 2:2, 3:3, 4:4, 5:3, 6:2, 7:1}\n    actions = ([0, 0],)\n    upper_mode = False\n    press_ok = 0\n    func = lambda x, y: (vertical_inversion[abs(x[0]-y[0])] + horizontal_inversion[abs(x[1]-y[1])])\n\n    for char in word:\n        for i in range(6):\n            if char.lower() in matrix[i]:\n                if char.isupper() and not upper_mode:\n                    actions += ([5, 0],)\n                    upper_mode = True\n                    press_ok += 1\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n                elif char.isupper() and upper_mode:\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n                elif char.islower() and upper_mode:\n                    actions += ([5, 0],)\n                    upper_mode = False\n                    press_ok += 1\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n                elif char.islower() and not upper_mode:\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n                else:\n                    actions += ([i, matrix[i].index(char.lower())],)\n                    press_ok += 1\n\n    return sum([func(i[0], i[1]) for i in list(zip(actions, actions[1:]))]) + press_ok", "D = {v:(r, c) for r, row in enumerate(['abcde123', 'fghij456', 'klmno789', 'pqrst.@0', 'uvwxyz_/', 'U ??????']) for c, v in enumerate(row)}\n\nmind = lambda d, mx: min(d, mx - d)\nmove = lambda t, lastr, lastc, r, c: (t + mind(abs(r - lastr), 6) + mind(abs(c - lastc), 8) + 1, r, c)\n\ndef tv_remote(words):\n\n    t, lastr, lastc, lower = 0, 0, 0, True\n    \n    for e in words:\n        if e.isalpha() and lower != e.islower():\n            t, lastr, lastc = move(t, lastr, lastc, 5, 0)\n            lower = not lower\n        t, lastr, lastc = move(t, lastr, lastc, *D[e.lower()])\n    return t    ", "SHIFT = 'aA'\nsyms = {\n    x: (i, j)\n    for i, row in enumerate([\n        'abcde123',\n        'fghij456',\n        'klmno789',\n        'pqrst.@0',\n        'uvwxyz_/',\n    ])\n    for j, x in enumerate(row)\n}\nsyms[' '] = (5, 1)\nsyms[SHIFT] = (5, 0)\n\n\ndef tv_remote(words):\n    r = c = 0\n    n = 0\n    lower = True\n    def press(x):\n        nonlocal n, r, c, lower\n        r1, c1 = syms[x]\n        n += min(abs(r1-r), 6 - abs(r1-r)) + min(abs(c1-c), 8 - abs(c1-c)) + 1\n        r, c = r1, c1\n        if x == SHIFT:\n            lower = not lower\n        \n    for ch in words:\n        if ch.isalpha() and ch.islower() != lower:\n            press(SHIFT)\n        press(ch.lower())\n    return n", "import  re\ndef tv_remote(words):\n    letters = {c: (x, y)\n        for y, row in enumerate((\n        \"abcde123\",\n        \"fghij456\",\n        \"klmno789\",\n        \"pqrst.@0\",\n        \"uvwxyz_/\",\n        \"\u21e7 \"))\n        for x, c in enumerate(row)}\n    words = re.sub(r'((?:^|[a-z])[^A-Z]*)([A-Z])', r'\\1\u21e7\\2', words)\n    words = re.sub(r'([A-Z][^a-z]*)([a-z])', r'\\1\u21e7\\2', words)\n    words = words.lower()\n    return sum(\n        min(abs(letters[c1][0] - letters[c2][0]),8-abs(letters[c1][0] - letters[c2][0])) +\n        min(abs(letters[c1][1] - letters[c2][1]),6-abs(letters[c1][1] - letters[c2][1])) + 1\n        for c1, c2 in zip(\"a\" + words, words))", "D = {v:[r, c] for r, row in enumerate(['abcde123', 'fghij456', 'klmno789', 'pqrst.@0', 'uvwxyz_/','* ']) for c, v in enumerate(row)}\n\ndef manhattan_dist(*points): \n    print('points md: ', points)\n    return  [abs(z2-z1) for z1,z2 in zip(*points)]\n\ndef wrap_manhattan_dist(*points):\n    dist = manhattan_dist(*points)\n    wdist = [min(dist[0],6-dist[0]), min(dist[1],8-dist[1])]\n    return sum(wdist)\n\nimport re\ndef tv_remote(words):\n    words = re.sub('([A-Z])',r'*\\1*',words).lower()\n    words = re.sub('\\*([\\d.@_/ ]*)(\\*|$)',r'\\1',words)\n    words = re.sub('\\*$','',words)\n    words = re.sub('\\*([0-9.@_/ ]+)([^\\*])',r'\\1*\\2',words)\n    words = 'a' + words\n    moves = sum([wrap_manhattan_dist(D[words[i]], D[words[i+1]])+1 for i in range(len(words)-1)])\n    return moves", "def tv_remote(words:str):\n    screen_keyboard_symbols = \"abcde123fghij456klmno789pqrst.@0uvwxyz_/* \"\n    symbols_map = {c: (i // 8, i % 8) for i, c in enumerate(screen_keyboard_symbols)}\n    kb_dims = (len(screen_keyboard_symbols) // 8 + 1, 8)\n\n    def dist(pos1, pos2):\n        return sum(min(abs(p1-p2), dim - abs(p1-p2)) for p1, p2, dim in zip(pos1, pos2, kb_dims))\n\n    button_presses = 0\n    cur_position, next_position = (0, 0), (0, 0)\n    caps_on = False\n\n    words_to_type = []\n    for ch in words:\n        if ch.islower() and caps_on or ch.isupper() and not caps_on:\n            words_to_type.append(\"*\" + ch.lower())\n            caps_on = not caps_on\n        else:\n            words_to_type.append(ch.lower())\n    words_to_type = \"\".join(words_to_type)\n\n    for ch in words_to_type:\n        if ch in screen_keyboard_symbols:\n            next_position = symbols_map[ch]\n            button_presses += 1 + dist(cur_position, next_position)\n            cur_position = next_position\n        else:\n            return -1\n    return button_presses"]