["def largest_rect(h):\n    st=[]; m=0; i=0\n    while i<len(h):\n        if len(st)==0 or h[st[-1]]<=h[i]: st.append(i); i+=1\n        else: l=st.pop(); m=max(m, h[l]*(i if len(st)==0 else i-st[-1]-1))\n    while len(st)>0: l=st.pop(); m=max(m, h[l]*(i if len(st)==0 else i-st[-1]-1))\n    return m", "def largest_rect(h):\n  r,s,i,l=0,[],0,len(h)\n  while i<l:\n    if not s or h[s[-1]]<=h[i]: s.append(i); i+=1\n    else:  t=s.pop(); a=i-s[-1]-1 if s else i; a*=h[t]; r=r if r>a else a\n  while s: t=s.pop(); a=i-s[-1]-1 if s else i; a*=h[t]; r=r if r>a else a\n  return r", "from itertools import groupby\n\ndef largest_rect(histogram):\n    histogram.append(0)\n    stack = [-1]\n    result = 0\n    for i in range(len(histogram)):\n        while histogram[i] < histogram[stack[-1]]:\n            h = histogram[stack.pop()]\n            w = i - stack[-1] - 1\n            result = max(result, h * w)\n        stack.append(i)\n    histogram.pop()\n    return result", "def largest_rect(histogram):\n    stack, max_area = [], 0\n    for i, h in enumerate(histogram + [0]):\n        while stack and h <= histogram[stack[-1]]:\n            height = histogram[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area", "def largest_rect(histogram):\n  dim = len(histogram)\n  if dim == 0: return 0\n  max_el = max(histogram)\n  min_el = min(histogram)\n  if max_el == min_el: return dim * max_el\n  area = max_el if max_el > min_el * dim else min_el * dim\n  \n  arr_work = [histogram]\n  while len(arr_work) > 0:\n    h = arr_work.pop()\n    dim = len(h)\n    max_el = max(h)\n    min_el = min(h)\n    if max_el * dim < area:\n      continue\n    if max_el == min_el: \n      if area < dim * max_el:\n        area = dim * max_el\n      continue\n    area = min_el * dim if area < min_el * dim else area\n    split_index = h.index(min_el)\n    if split_index * max_el >= area:\n      arr_work.append(list(reversed(h[:split_index])))\n    if (dim - 1 - split_index) * max_el >= area:\n      arr_work.append(list(reversed(h[(split_index + 1):])))\n\n  return area", "def largest_rect(heights):\n        maxArea = 0\n        stack = [] # stack of pairs: (index, height)\n        \n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i - index))\n                start = index\n            stack.append((start, h))\n        \n        # remaining heights extended to the end of the histogram\n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights) - i))\n        return maxArea", "def largest_rect(r):\n    s,m = [-1], 0\n    for i in range(len(r)):\n        while s[-1]!=-1 and r[s[-1]]>=r[i]:m=max(m,r[s.pop()]*(i-s[-1]-1))\n        s.append(i)\n    while s[-1]!=-1:m=max(m,r[s.pop()]*(len(r)-s[-1]-1))\n    return m", "from collections import deque\n\ndef largest_rect(a):\n    areas, stack, a = [], deque(), a + [0]\n    for i, x in enumerate(a):\n        j = i\n        while len(stack) > 0 and x <= stack[-1][1]:\n            j, h = stack.pop()\n            areas.append((i-j) * h)\n        stack.append((j, x))\n    return max(areas or [0])", "def largest_rect(histogram):\n    lis, ris = [], []\n    st = []\n    for i in range(len(histogram)):\n        while st and histogram[st[-1]] >= histogram[i]:\n            st.pop()\n        lis.append(st[-1] if st else -1)\n        st.append(i)\n    st = []\n    for i in reversed(range(len(histogram))):\n        while st and histogram[st[-1]] >= histogram[i]:\n            st.pop()\n        ris.append(st[-1] if st else len(histogram))\n        st.append(i)\n    return max((w * (ri - li - 1) for w, li, ri in zip(histogram, lis, reversed(ris))), default=0)", "def largest_rect(histogram):\n    if not histogram : return 0\n     \n    maxi = 0\n    pile = []\n     \n    for elt in histogram:\n        coeff =0 \n        while(pile and elt<pile[-1][0]):\n            top1, top2 = pile.pop()\n            coeff += top2\n            score = top1*coeff\n            maxi = max(maxi, score)\n             \n        pile.append([elt,coeff+1])\n    \n    coeff = 0\n    while(pile):\n        top1, top2 = pile.pop()\n        coeff += top2\n        score = top1*coeff\n        maxi = max(maxi, score)\n    \n    return maxi"]