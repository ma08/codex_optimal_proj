["import sys\ninput = sys.stdin.readline\nrInt = lambda: int(input())\nmInt = lambda: map(int, input().split())\nrLis = lambda: list(map(int, input().split()))\n\nouts = []\n\nt = rInt()\nfor _ in range(t):\n    n, k = mInt()\n    s = input()\n\n    pref = [0]\n    for c in s:\n        if c == '1':\n            pref.append(pref[-1] + 1)\n        else:\n            pref.append(pref[-1])\n\n    best = pref[-1]\n\n    dp = []\n    for i in range(n):\n        cost = pref[i]\n        if i >= k:\n            case2 = dp[i - k] + pref[i] - pref[i - k + 1]\n            if case2 < cost:\n                cost = case2\n        if s[i] == '0':\n            cost += 1\n\n        dp.append(cost)\n        actual = cost + pref[-1] - pref[i + 1]\n        if actual < best:\n            best = actual\n\n    outs.append(best)\n\n\nprint(*outs, sep = '\\n')\n", "import sys\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\n\ndef solve():\n    n, k = nm()\n    s = list(map(int, list(ns())))\n    w = sum(s)\n    sc = n\n    for i in range(k):\n        t = s[i::k]\n        m = len(t)\n        dp = [[0]*3 for j in range(m+1)]\n        for j in range(m):\n            dp[j+1][0] = dp[j][0] + t[j]\n            dp[j+1][1] = min(dp[j][0], dp[j][1]) + 1 - t[j]\n            dp[j+1][2] = min(dp[j][1], dp[j][2]) + t[j]\n        sc = min(sc, min(dp[m]) + w - sum(t))\n    print(sc)\n    return\n\n\n\n\n# solve()\n\nT = ni()\nfor _ in range(T):\n    solve()\n", "from collections import defaultdict as dd\nfrom collections import deque\nimport bisect\nimport heapq\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(map(int, input().split()))\n\n\ndef solve():\n    n, k = rl()\n    S = input()\n    zero_blocks = dd(int)\n    cost_all_zeros = 0\n    rem = 0\n    for i, c in enumerate(S):\n        if c == '1':\n            cost_all_zeros += 1\n            zero_blocks[rem] += 1\n        rem += 1\n        if rem == k:\n            rem = 0\n\n    global_best = n\n    for offset in range(k):\n        zero_others = cost_all_zeros - zero_blocks[offset]\n\n        pre, mid, post = 0, n, n\n        for i in range(offset, n, k):\n            if S[i] == '1':\n                new_pre = pre + 1\n                new_mid = min(mid, pre)\n                new_post = min(post + 1, mid + 1)\n            else:\n                new_pre = pre\n                new_mid = min(mid + 1, pre + 1)\n                new_post = min(post, mid)\n            pre, mid, post = new_pre, new_mid, new_post\n        best = min(pre, mid, post)\n\n        # print (offset, zero_others)\n        # print (pre, mid, post)\n        global_best = min(global_best, best + zero_others)\n\n\n    print (global_best)\n    # print ()\n\n\n\nmode = 'T'\n\nif mode == 'T':\n    t = ri()\n    for i in range(t):\n        solve()\nelse:\n    solve()\n", "import sys\nstrs = iter(sys.stdin.read().split())\nints = (int(x) for x in strs)\nsys.setrecursionlimit(3000)\n\ndef main():\n    ntc = next(ints)\n    for tc in range(1,ntc+1):\n        n, k = (next(ints) for i in range(2))\n        s = next(strs)\n        R = (n+k-1)//k\n        m = [[int(i*k+j<n and s[i*k+j]=='1') for i in range(R)] for j in range(k)]\n        s = [sum(m[j]) for j in range(k)]\n        s_sum = sum(s)\n        ans = [0]*k\n        #0  1  1  0  1  0  1  1  0\n        for j in range(k):\n            off = [0]*(R+1)\n            on  = [0]*(R+1)\n            for i in range(R-1, -1, -1):\n                off[i] = m[j][i] + off[i+1]\n                on[i] = 1-m[j][i]+min(on[i+1], off[i+1])\n            for i in range(R+1):\n                off[i] = (i and off[i-1]) + (i<R and m[j][i])\n                on[i] = on[i] + (i and off[i-1])\n            ans[j] = s_sum-s[j] + min(on)\n        print(min(ans))\n    return\n\nmain()\n", "t = int(input())\nwhile t > 0 :\n\tt -= 1\n\tn, k = map(int, input().split())\n\ts = input()\n\tcnt, v = [0] * k, [list() for i in range(k)]\n\tans = 0\n\tfor i in range(n) :\n\t\tif s[i] == '1' :\n\t\t\tcnt[i % k] += 1\n\t\t\tans += 1\n\t\tv[i % k].append(int(s[i]))\n\ttot = ans\n\tfor i in range(k) :\n\t\tcurAns = tot - cnt[i]\n\t\ttot0, tot1 = 0, 0\n\t\tmnsum = 0\n\t\tfor j in range(len(v[i])) :\n\t\t\tif v[i][j] == 0 :\n\t\t\t\ttot0 += 1\n\t\t\telse :\n\t\t\t\ttot1 += 1\n\t\t\tans = min(ans, curAns + mnsum + tot0 + (cnt[i] - tot1))\n\t\t\tmnsum = min(mnsum, tot1 - tot0)\n\n\tprint(ans)"]