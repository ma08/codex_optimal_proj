["def over_the_road(address, n):\n    '''\n    Input: address (int, your house number), n (int, length of road in houses) \n    Returns: int, number of the house across from your house. \n    '''\n    # this is as much a math problem as a coding one \n    # if your house is [even/odd], the opposite house will be [odd/even] \n    # highest number on street is 2n \n    # Left side houses are [1, 3, ... 2n-3, 2n-1] \n    # Right side houses are [2n, 2n-2, ... 4, 2] \n    # Sum of opposite house numbers will always be 2n+1 \n    return (2*n + 1 - address) ", "def over_the_road(address, n):\n    return n * 2 + 1 - address", "def over_the_road(a,n):\n    return 2*n+1-a if 0<a<=2*n else -1", "def over_the_road(address, n):\n    return n*2-address+1", "def over_the_road(address, n):\n    return 2 * n + 1 - address", "def over_the_road(address, n):\n    l = range(1, n*2, 2)\n    r = range(n*2, 0, -2)\n    if address%2:\n        return r[l.index(address)]\n    else:\n        return l[r.index(address)]        ", "def over_the_road(address, n):\n    return (n - address // 2) * 2 + (1 - address % 2)", "def over_the_road(address, n):\n    #two opposite addresses add to 2n+1\n    return ((n*2) + 1)-address", "def over_the_road(address, n):\n    n = n*2 - (address-1)\n    return n \n\n", "def over_the_road(address, n):\n    lim = 2*n + 1\n    return lim - address", "def over_the_road(address, n):\n    if address % 2 == 0: #Rechts\n        return int((n*2-1)-(((address)/2)-1)*2)\n    else:\n        return int((n*2)-((((address+1)/2)-1)*2))", "def over_the_road(a, n):\n    return n * 2 - a + 1", "def over_the_road(address, n):\n    return n * 2 - (address - 1)", "def over_the_road(address, street):\n        return 2*street - address + 1 ", "def over_the_road(address, n):\n    if (address % 2) == 0 :\n        i = (2*n - address)/2\n        return int(2*i + 1)\n    else:  \n        i = (address - 1)/2\n        return int(2*n - 2*i) ", "def over_the_road(a, n):\n    return n * 2 - 2 * (a // 2) + (a % 2 == 0)", "def over_the_road(address, n):\n    houses = n*2\n    return houses-address+1", "def over_the_road(a, n):\n    \n    if a%2!=0:\n        return (2*n-int(a/2)*2)\n    else:\n        return 2*n-int(a/2)*2+1\n        \n        \n    \n    #return st[a]\n", "def over_the_road(address, n):\n    return (n - address // 2) * 2 if address % 2 else (n - address // 2) * 2 + 1", "def over_the_road(address, n):\n    if address % 2 == 1:\n        return 2*(n - address//2)\n    return 1 + 2*(n - address//2)", "def over_the_road(address, n):\n    result=0\n    if address%2==0:\n        result =(n*2-address) + 1\n        \n    elif address%2==1:\n        result = n*2-(address-1)\n    return result ", "def over_the_road(address, n):\n    return 2*n-address+1\n                \n\n# a n o 10(3*n+1)                \n# 1 3 6\n# 2 3 5\n# 3 3 4\n# 4 3 3\n# 5 3 2\n# 6 3 1\n\n# a = 2*(n-1)\n# 16\n# a n    16=o+n+a o=3n+1-n-a 2*n-a+1\n# 1 5 10\n# 3 5 8\n# 5 5 6\n# 7 5 4\n# 9 5 2\n", "def over_the_road(address, n):\n    # calculate address position and neighbor if address is odd \n    if address % 2 != 0:\n        position = (address + 1) / 2\n        neighbor = (n - position + 1) * 2\n    # calculate address position and neighbor if address is even \n    else:\n        position = - (address / 2) + n + 1\n        neighbor = (position * 2) - 1\n    return neighbor", "def over_the_road(address, n):\n    if address % 2 != 0:\n        position = (address + 1) / 2\n        neighbor = (n - position + 1) * 2\n    else:\n        position = - (address / 2) + n + 1\n        neighbor = (position * 2) - 1\n    return neighbor", "def over_the_road(address, n):\n    if(address % 2):\n        nth = ((address - 1) // 2) + 1\n        event_nth = (n + 1) - nth\n        print((2 + (event_nth - 1 ) * 2))\n        return 2 + (event_nth - 1 ) * 2\n    else:\n        nth = ((address - 2) // 2) + 1\n        odd_nth = (n + 1) - nth\n        print((1 + (odd_nth - 1 ) * 2))\n        return 1 + (odd_nth - 1 ) * 2\n", "def over_the_road(address, n):\n    dist = abs(1-address)\n    return n*2-dist", "over_the_road=lambda add, n: n*2-(add-1)", "def over_the_road(address, n):\n    if address%2==0:return 2*(n-(address/2-1)-1)+1\n    else:return 2*(n-(address-1)/2)", "def over_the_road(address, n):\n    if address % 2 == 0:\n        p = (n * 2 - address) / 2\n        return 1 + 2 * p\n    else:\n        p = ((n * 2 - 1) - address) / 2\n        return 2 + 2 * p", "def over_the_road(address, n):\n    return 1 + (n * 2 - address) if address % 2 == 0 else n * 2 - (address - 1)", "def over_the_road(n, l):\n    return abs(n - (l * 2 + 1))", "over_the_road = lambda a, n: 2*n- 2*(a//2) + (1+a) % 2", "def over_the_road(address, n):\n    opposite_neighbour=2*n-address+1\n    return opposite_neighbour", "def over_the_road(address, n):\n\n    nums = range(1, 2 * n + 1)\n  \n    if address <= n:\n        return nums[-address]\n    else:\n        return nums[2*n - address]", "def over_the_road(a, n):\n    return -(a-2*n-1)", "def over_the_road(add, n):\n    return 2*n-add+1", "def over_the_road(address, n):\n    pass\n    s = n * 2 + 1\n    return s - address\n\n", "def over_the_road(address, n):\n    house = (address+1)/2\n    opposite = int(n*2-((house-1)*2))\n    return opposite", "def over_the_road(address, n):\n    x=0\n    if address in range(2*n, 0, -2):\n            x = range(2*n, 0, -2).index(address)\n            return range(1, 1+2*n, 2)[x]\n    else:\n        if address in range(1, 1+2*n, 2):\n            x = range(1, 1+2*n, 2).index(address)\n            return range(2*n, 0, -2)[x]", "def over_the_road(address,\n                  n):\n\n    max_address = n * 2\n    gap = max_address - address\n    target = 1 + gap\n\n    return target\n", "def over_the_road(address, n):\n    return 2*n - (address//2)*2 + ((address+1)%2)", "def over_the_road(address, n):\n    ans = 2*n + 1 - address\n    return(ans)", "def over_the_road(address, n):\n    return 2 * n - address + 1    \n\n    #2n -1 + 1 \n", "def over_the_road(address, n):\n    biggest_num = n*2\n    lowest_num = 1\n    if address%2 > 0:\n        step = address - lowest_num\n        result = biggest_num - step\n        return result\n    else:\n        step = biggest_num - address\n        result = lowest_num + step\n        return result\n    \n                \n    \n    \n", "def over_the_road(address, n):\n    return 2 * (n - address // 2) if address % 2 else 2 * (n - address // 2) + 1", "def over_the_road(address, n):\n    s = n * 2 + 1\n    r = s - address\n    return r", "def over_the_road(address, n):\n    '''\n    Input: address (int, your house number), n (int, length of road in houses) \n    Returns: int, number of the house across from your house. \n    '''\n\n    return (2*n + 1 - address) ", "def over_the_road(address, n):\n    house_index = (n * 2 - address) / 2 if address % 2 == 0 else (address - 1) / 2\n    return house_index * 2 + 1 if address % 2 == 0 else (n * 2) - (house_index * 2)\n\n", "def over_the_road(address, n):\n    n = n*2\n    address = (n-address)+1\n    return address", "def over_the_road(address, n):\n    if address % 2 == 0:\n        return 1 + 2 * (n - (address / 2))\n    else:\n        return 2 * (n - (address // 2))", "def over_the_road(address, n):\n    \n    if address % 2 == 0:\n        evenpos = address/2\n        oddpos = n - evenpos\n        op = (oddpos * 2) + 1\n        return op\n    else:\n        oddpos = (address - 1)/2\n        evenpos = n - oddpos\n        op = (evenpos * 2)\n        return op\n        \n        \n        \n", "def over_the_road(a, n):\n    if a%2==0:\n        return 1+2*(n-a*0.5)\n    else:\n        return 2*(n-(a//2))\n", "def over_the_road(address, n):\n    if address%2==0:\n        address = n*2 - address\n        return 1+address\n    else:\n        address = address - 1\n        return n*2-address", "def over_the_road(address, n):\n    return 1 + (2*n - address) if address % 2 == 0 else (2 * n) - (address - 1)", "def over_the_road(address, n):\n    # Loops, dictionaries and maps didn't meet performance requirements. Now trying pure math\n    return (n * 2) - address + 1\n\n    #all_addr = {index: value for index, value in enumerate(range((n*2)+1,-1,-1))}\n    #rev_all_addr = {}\n    #count = n * 2\n    \n    # return [value for index, value in enumerate(range((n*2)+1,-1,-1)) if index == address][0]\n    # even_addr = n * 2\n    \n    # map opposite addresses\n#     for odd_addr in range(1, even_addr):\n#         if odd_addr % 2 > 0:\n#             all_addr[odd_addr] = even_addr\n#             even_addr -= 2\n#     for i in range(1, count):\n#         all_addr[i] = count\n#         count -= 1\n    \n    # invert address\n    # rev_all_addr = {even_addr: odd_addr for odd_addr, even_addr in all_addr.items()}\n    #return all_addr[address]\n\n\n#     if address % 2 > 0:\n#         return all_addr[address]\n#     else:\n#         return rev_all_addr[address]\n        #return [odd_addr for odd_addr, even_addr in all_addr.items() if even_addr == address][0]\n", "def over_the_road(address, street_length):\n    if address % 2 == 1:\n        positionFromBottom = street_length - address // 2\n        return 2 * positionFromBottom\n    if address % 2 == 0:\n        positionFromTop = street_length - address // 2 + 1\n        return 2 * (positionFromTop-1) + 1", "def over_the_road(address, n):\n numHouse = n*2\n if address%2 == 0:\n  p = int(((numHouse-address)/2)+1)\n  return (int((p*2)-1))\n\n else:\n  p = (address+1)/2\n  return (int(numHouse - 2*(p-1)))", "from math import floor\n\ndef over_the_road(address, n):\n    return (n - floor((address - 1) / 2)) * 2 - ((address + 1) % 2)", "def over_the_road(address, n):\n    if address % 2 !=0:\n        opp = (n * 2) - (address - 1)\n        return opp\n    else:\n        opp = ((n * 2) - address)  + 1\n        return opp\n", "def over_the_road(address, n):\n    return (2 * (n - (address - 1) / 2))", "def over_the_road(address, n):\n    if address%2 == 1:\n        return n*2 - (address//2)*2\n    else :\n        return n*2 - address + 1\n", "def over_the_road(address, n):\n    if address%2>0:\n        return (n*2)-(address//2)*2\n    else:\n        return (n*2-address)/2*2+1\n", "def over_the_road(address, n):\n    if(address%2==0):\n        return(2*n-address+1)\n    else:\n        index = int((address+1)/2)\n        return(2*n-2*(index-1))\n", "def over_the_road(address, n):\n    return ((2*n)-(address-1))\n    \n        \nover_the_road(1,3)", "def over_the_road(address, n):\n    return 2*n - address + 1\n    #     oe = address%2\n#     list1 = [2*(n-2) + oe - 4*i for i in range(n)]\n#     return address+list1[(address-oe)/2]\n\n#     my_street = [1 + i*2 for i in range(n)]\n#     op_street = [my_street[-1]+1 - i*2 for i in range(n)]\n#     if address % 2 == 0:\n#         return my_street[op_street.index(address)]\n#     else:\n#         return op_street[my_street.index(address)]\n", "def over_the_road(address, n):\n        current = (n - address//2)*2\n        if not address%2:\n            current +=1\n        return current\n        \n", "def over_the_road(address, n):\n    if address % 2 != 0:\n        return (n*2 - (address-1))\n    else:\n        return (2*n - address) + 1", "def over_the_road(address, n):\n    x=(n*2-address)/2\n    y=1+x*2\n    return y", "def over_the_road(address, n):\n    if address % 2 == 0: \n        high_even = n * 2           \n        count = (high_even - address)/2  \n        return (count * 2) + 1    \n    else:\n        high_odd = (n * 2) - 1       \n        count = (high_odd - address)/2 \n        return (count * 2) + 2", "def over_the_road(address, n):\n    if address % 2 > 0:\n        return (n * 2) - (address // 2) * 2\n    else:\n        return ((n * 2 - address) // 2) * 2 + 1\n\n\n\n\n", "def over_the_road(address, n):\n    maxHouse = n * 2\n    return maxHouse + 1 - address", "def over_the_road(address, n):\n    if address % 2 != 0:\n        return 2*n - (address//2)*2\n    else:\n        return 2*n - (address//2)*2 + 1", "def over_the_road(address, n):\n#     the sum of the right side of the node is[1,3,5,.....,2n-1]\n#     the sum of the left side of the node is [2n,2n-2,...,2]\n    return (2*n+1 - address)\n    pass", "def over_the_road(address, n):    \n    return address + 2 * (n - address) + 1", "def over_the_road(address, n):\n    # address + opposite house = 2n + 1\n    return 2*n + 1 - address\n", "def over_the_road(address, n):\n    return address + (-1)**(2*address) * ( 2*(n-address) + 1 )", "def over_the_road(address, n):\n#     odd, even = [], []\n#     for i in range(1, n*2+1):\n#         if i % 2 == 0:\n#             even += [i]\n#         if i % 2 != 0:\n#           odd += [i]\n#     even = even[::-1]\n\n#     return even[odd.index(address)] if address in odd else odd[even.index(address)]\n    return n*2+1 - address", "def over_the_road(address, n):\n    \n    address=int(address)\n    \n    if address%2==0:\n       return n*2 - (address-1)\n    else: \n        return (n*2 - address+1)", "def over_the_road(address, n):\n    return (n - address // 2) * 2 + (not (address % 2))", "def over_the_road(adress, dlina):\n    if adress % 2 == 0:\n        z = (adress//2)-1\n        end = (2*dlina) - 1\n    else:\n        z = ((adress-1)//2)\n        end = 2 * dlina\n    return end - (2*z)", "def over_the_road(address, n):\n    ans = n*2+1 - address\n    return ans", "def over_the_road(ad, n):\n    return 2*n+1-ad", "def over_the_road(address, n):\n    return 2*(n-address//2)+((address+1)%2)*1", "def over_the_road(address, n):\n    max = 2*n\n    return max-(address-1)", "def over_the_road(address, n):\n    \n    # Even Number Address\n    if address % 2 == 0:\n        x = n - address / 2\n        return int(1 + 2 * x)\n    \n    # Odd Number Address\n    else:\n        x = n - (address + 1) / 2\n        return int(2 + 2 * x)\n", "def over_the_road(address, n):\n    answer = 0\n    if address % 2 == 0:\n        steps = n - (address/2)\n        answer = 1 + (2*steps)\n    else:\n        steps = (n*2) - address\n        answer = steps + 1\n    return answer", "import math\n\ndef over_the_road(address, n):\n    return (2*n+1) - address ", "def over_the_road(ad, n):\n    od = list(range(1, n*2, 2))\n    ev = list(range(n*2, 0,-2))\n    return od[ev.index(ad)] if ad %2 == 0 else ev[od.index(ad)]\n# Flez\n", "def over_the_road(address, n):\n    totale=2*n\n    x=(totale-address)//2\n    y=(address-1)//2\n    if address % 2 ==0:\n        z= -totale+1 + x*4\n        return (address + z)\n    else:\n        z= totale-1 - y*4\n        return(address + z)\n        \n        \n", "def over_the_road(address, n):\n    if address%2==1:\n        x=(n*2)-(address+1)+2\n    if address%2==0:\n        x=((n*2)-1)-(address-2)\n    return(x)", "def over_the_road(address, n):\n    if address % 2 == 1:\n        max = n * 2\n        trunum = (address + 1) / 2    \n    else:\n        max = (n * 2)-1\n        trunum = address/2\n    trunum = int(trunum)\n    max = max - (trunum - 1) * 2\n    return max", "def over_the_road(address, n):\n    return 1 + n * 2 - address\nprint(over_the_road(7,11)) # and etc...", "def over_the_road(address, n):\n    return 1 + n * 2 - address\nprint(over_the_road(7, 11))", "def over_the_road(address, n):\n    # By calculating pos of address in sequence of house nums\n    # address of house in other sequence can be calculated\n    \n    if address//2 == 0:\n        # address = 2(n + 1 - pos)\n        return 2 * ((address - (2 * n) - 2) / -2) - 1\n    else:\n        # address = 2n - 1\n        return 2 * (n + 1 - ((address + 1)/2))", "def over_the_road(address, n):\n    x=(address-1)\n    x1=(n-x)*2+x\n    return x1", "def over_the_road(address, n):\n    n = n*2\n    return (n - (address - 1))", "def over_the_road(address, n):\n    if address%2==0: return -address+(2*n+1)\n    else: return -address+(2*n+1)", "def over_the_road(address, n):\n    total = n * 2 \n    reultado  = total - address + 1\n    return reultado", "def over_the_road(address, n):\n    return (2 * n  - address) + 1 if address % 2 == 0 else ((2 * n - 1) - address) + 2 ", "def over_the_road(address, n):\n    TotalHouseNumber = n * 2\n    if (address % 2) == 0:\n        posl = (TotalHouseNumber - address) / 2\n        oddnumber = ((posl + 1) * 2) - 1\n        return oddnumber\n    else:\n        posr = (TotalHouseNumber - (address + 1)) / 2\n        evennumber = (posr + 1) * 2\n        return evennumber"]