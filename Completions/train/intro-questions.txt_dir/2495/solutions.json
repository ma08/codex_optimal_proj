["class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        return sorted(target) == sorted(arr)", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        if sorted(target) == sorted(arr):\n            return True\n        else:\n            return False", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        if sum(arr) != sum(target):\n            return False\n        boolean = True\n        for i, v in enumerate(target):\n            if v in arr:\n                boolean = True & boolean\n            else: \n                boolean = False & boolean\n        return boolean", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        if sum(arr) != sum(target):\n            return False\n        boolean = True\n        for i, v in enumerate(target):\n            if v in arr:\n                boolean = True & boolean\n            else: \n                boolean = False & boolean\n                break\n        return boolean", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        # if target == arr:\n        #     return True\n        result = all(elem in target  for elem in arr)\n        if result:\n            return sorted(arr) == sorted(target)\n        else:\n            return False", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        for i in range(len(target)):\n            if target[i] not in arr:\n                return False\n            arr.pop(arr.index(target[i]))\n        return True", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        for i in arr:\n            if i in target:\n                target.remove(i)\n            else:\n                return False\n        return True\n", "from collections import Counter\n\nclass Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        arr_counter = Counter(target)\n        tgt_counter = Counter(arr)\n        \n        return arr_counter == tgt_counter", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        if collections.Counter(target) != collections.Counter(arr):\n            return False\n        return True\n        \n        def reverse(left,right):\n            while left<right:\n                arr[left],arr[right] = arr[right],arr[left]\n                left += 1\n                right -=1\n                \n        for i in range(len(target)):\n            if target[i] == arr[i]:\n                continue\n            j = arr.find(target[i])\n            reverse(i,j)\n            \n        \n", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        # time O(n); space O(1)\n        return Counter(target) == Counter(arr)", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        return collections.Counter(target) == collections.Counter(arr)", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        if sorted(target)==sorted(arr):\n            return True\n        else:\n            return False\n", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        import numpy as np\n        return((np.sort(target) == np.sort(arr)).all())", "def sort(list_a):\n    low =[]\n    high=[]\n    if len(list_a)<=1:\n        return list_a\n    else:\n        v=list_a.pop()\n        for i in range(len(list_a)):\n            if list_a[i]> v:\n                high.append(list_a[i])\n            else:\n                low.append(list_a[i])\n        return sort(low) + [v] + sort(high)\nclass Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        target = sort(target)\n        arr = sort(arr)\n        if arr == target:\n            return True\n        else:\n            return False", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        # this is basically a buble sort kinda technique, but not sorted\n        # if need to do this then??\n        # put first element in place based on target\n        # reverse from i to numIndex\n        # increase i\n        \n        # or iterate both at the same time and check for 0 at the end\n        if len(target) != len(arr):\n            return False\n        mp = {}\n        for num in target:\n            mp[num] = mp.get(num, 0) + 1\n        \n        for num in arr:\n            if num not in mp:\n                return False\n            mp[num] -= 1\n            if mp[num] < 0:\n                return False\n        return True\n        \n        \n", "class Solution:\n    def canBeEqual(self, target, arr) -> bool:\n        \n        target = sorted(target)\n        arr = sorted(arr)\n\n        return target == arr", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        if len(target)!=len(arr):\n            return False\n        \n        p=0\n        a=sorted(arr)\n        t=sorted(target)\n        while(p<len(t)):\n            if a[p]!=t[p]:\n                return False\n            p+=1\n        \n        return True", "class Solution:\n    def partition(self, arr, start, end):\n        follower = leader = start\n        while leader < end:\n            if arr[leader] <= arr[end]:\n                arr[leader], arr[follower] = arr[follower], arr[leader]\n                follower += 1\n            leader += 1\n        arr[follower], arr[end] = arr[end], arr[follower]\n        return follower\n    \n    def quicksort(self, arr, start, end):\n        if start >= end:\n            return\n        else:\n            p = self.partition(arr, start, end)\n            self.quicksort(arr, p + 1, end)\n            self.quicksort(arr, start, p - 1)\n            \n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        self.quicksort(arr, 0, len(arr) - 1)\n        self.quicksort(target, 0, len(arr) - 1)\n        return target == arr\n    \n    \n", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        for a in arr:\n            if a in target:\n                target.remove(a)\n            else:\n                return False\n        return True", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        for i in range(len(target)):\n            if target[i] != arr[i]:\n                if target[i] not in arr[i:]:\n                    return False\n                else:\n                    j = arr[i:].index(target[i]) + len(arr[:i])\n                    arr[i], arr[j] = arr[j], arr[i]\n        return True", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        for i in target:\n            if i not in arr:\n                return False\n            arr[arr.index(i)] = None\n        return True\n", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        for i in range(len(target)):\n            for j in range(i, len(target)):\n                if arr[j] == target[i]:\n                    break\n            else:\n                return False\n            \n            arr[i:j+1] = reversed(arr[i:j+1:])\n        \n        return arr == target", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        count = 0\n        for item in target:\n            if item not in arr:\n                return False\n        hash_map_arr = {}\n        hash_map_target = {}\n        for i in range(len(arr)):\n            if arr[i] not in hash_map_arr:\n                hash_map_arr[arr[i]] = 1\n            else:\n                hash_map_arr[arr[i]] += 1\n            if target[i] not in hash_map_target:\n                hash_map_target[target[i]] = 1\n            else:\n                hash_map_target[target[i]] += 1\n        for item in target:\n            if hash_map_arr[item] != hash_map_target[item]:\n                return False\n        return True", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        \n        for i in range(len(target)):\n            if target[i] not in arr:\n                return False\n            if target[i] in arr:\n                arr[arr.index(target[i])]  = 0\n        return True\n", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        for i in range(len(target)):\n            if target[i] in arr:\n                arr.remove(target[i])\n            else:\n                pass\n        if arr==[]:\n            return True\n        else:\n            return False", "class Solution:\n    \n    def compare(self,x,y):\n        x_ = set(x)\n        for i in x_:\n            if x.count(i)!=y.count(i):\n                return False\n        return True\n    \n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        return self.compare(target,arr) ", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        for i in arr:\n            if i not in target:\n                return 0\n            else:\n                target.remove(i)\n        else:\n            return 1\n", "from collections import Counter\n\nclass Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        c1 = Counter(target)\n        c2 = Counter(arr)\n        return not set(c1.keys()).symmetric_difference(set(c2.keys())) and all([c1[k1]==c2[k1] for k1 in c1])", "from collections import defaultdict\n\nclass Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        if (len(target) != len(arr)):\n            return False\n            \n        numbers = defaultdict(int)    \n        for val in arr:\n            numbers[val] += 1\n        \n        for val in target:\n            numbers[val] -= 1\n        \n        print(numbers)\n        \n        if (min(numbers.values()) == 0 and max(numbers.values()) == 0):\n            return True\n        \n        return False", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n        \n        d1 = {}\n        d2 = {}\n        \n        for i in target:\n            if i not in d1:\n                d1[i] = 1\n            else:\n                d1[i] += 1\n        \n        for i in arr:\n            if i not in d2:\n                d2[i] = 1\n            else:\n                d2[i] += 1\n        \n        for k,v in d1.items():\n            if k not in d2:\n                return False\n            elif v != d2[k]:\n                return False\n        \n        return True", "class Solution:\n    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:\n                \n        differences_dict = {}\n        for i in range(len(target)):\n            differences_dict[target[i]] = differences_dict.get(target[i], 0) + 1\n            \n            differences_dict[arr[i]] = differences_dict.get(arr[i], 0) - 1\n            \n            if not differences_dict[target[i]]:\n                differences_dict.pop(target[i])\n                \n            if arr[i] != target[i] and not differences_dict[arr[i]]:\n                differences_dict.pop(arr[i])                \n        \n        return False if differences_dict else True        "]