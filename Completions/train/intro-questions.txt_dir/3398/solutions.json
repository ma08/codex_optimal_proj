["def solve(arr):\n    res = []\n    for first in (arr[0]-1, arr[0], arr[0]+1):\n        for second in (arr[1]-1, arr[1], arr[1]+1):\n            val, step, count = second, second-first, abs(arr[0]-first) + abs(arr[1]-second)\n            for current in arr[2:]:\n                val += step\n                if abs(val-current) > 1: break\n                count += abs(val-current)\n            else:\n                res.append(count)\n    return min(res, default=-1)", "def solve(arr):\n    def isProgression(array):\n        prevstep = array[1] - array[0]\n        for j, v in enumerate(array[1:]):\n            curstep = array[j + 1] - array[j]\n            if curstep != prevstep:\n                return False\n            prevstep = curstep\n\n        return True\n\n    if isProgression(arr):\n        return 0\n\n    lst = [arr]\n    chg = [0]\n    good = [isProgression(arr)]\n\n    for j in range(len(arr)):\n        for k in range(len(lst)):\n            if j>2 and isProgression(lst[k][:j-1]) is not True:\n                continue\n            lstp1 = lst[k][:j] + [lst[k][j] + 1] + lst[k][j + 1:]\n            lst.append(lstp1)\n            chg.append(chg[k] + 1)\n            good.append(isProgression(lstp1))\n\n            lstm1 = lst[k][:j] + [lst[k][j] - 1] + lst[k][j + 1:]\n            lst.append(lstm1)\n            chg.append(chg[k] + 1)\n            good.append(isProgression(lstm1))\n\n    filtered_lst = [x for j, x in enumerate(lst) if good[j]]\n    filtered_chg = [x for j, x in enumerate(chg) if good[j]]\n\n    if len(filtered_lst) == 0:\n        return -1\n\n    return min(filtered_chg)", "solve=lambda a,d={-1,0,1}:min((sum(l)for l in([abs(a[0]+u+(a[1]+v-a[0]-u)*n-x)for n,x in enumerate(a)]for u in d for v in d)if set(l)<=d),default=-1)", "solve=lambda a,d=(-1,0,1):min((sum(l)for l in([abs(a[0]+u+q*n-x)for n,x in enumerate(a)]for u in d for q,r in(divmod(a[-1]+v-a[0]-u,len(a)-1)for v in d)if r<1)if all(x in d for x in l)),default=-1)", "def solve(arr):\n    n = len(arr)\n    k, s = n - 1, n + 1\n    d = arr[k] - arr[0]\n    for d in range((d - 2) // k, (d + 2) // k + 1):\n        for i in (-1, 0, 1):\n            p = [abs(arr[0] + i + d * k - q) for k, q in enumerate(arr)]\n            if max(p) < 2: s = min(s, sum(p))\n    return (-1 if s > n else s)", "def solve(arr):\n\n    head = arr[0]\n    tail = arr[-1]\n    \n    check = [(i,j) for i in range(head-1,head+2) for j in range(tail-1,tail+2)]\n    \n    possibles = []\n    for start, end in check:\n        if (end-start)%(len(arr)-1) == 0:\n            possibles.append((start,end))\n    \n    global_changes = float('inf')\n    \n    for start, end in possibles:\n        \n        diff = int((end-start)/(len(arr)-1))\n        \n        if diff == 0: tester = [start]*len(arr)\n        else: tester = list(range(start, end+diff, diff))\n        \n        current_changes = 0\n        \n        for i in range(len(tester)):\n            if abs(tester[i] - arr[i]) > 1:\n                current_changes = float('inf')\n                break\n            elif abs(tester[i] - arr[i]) == 1:\n                current_changes += 1\n        \n        global_changes = min(current_changes, global_changes)\n                \n    \n    return global_changes if global_changes != float('inf') else -1", "import numpy as np\ndef solve(arr):\n    l = len(arr)\n    fst = arr[0]\n    lst = arr[l-1]\n    diff_range = lst - fst\n    diffs = []\n    for diff in range(diff_range - 2, diff_range + 3):\n        if diff == 0:\n            diffs.append(diff)\n        elif diff % (l - 1) == 0:\n            diffs.append(diff)\n    \n    progs = []\n    for diff in diffs:\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if fst + i + diff == lst + j:\n                  seq = []\n                  if diff == 0:\n                    seq = l * [fst+i]\n                  else:\n                    k = 1\n                    if diff < 0:\n                        k = -1 \n                    seq = list(np.arange(fst + i, lst + j + k, diff / (l - 1)))\n                  if len(seq) == l:\n                      progs.append(seq)\n      \n    changes = []\n    for seq in progs:\n        change = 0\n        complete = True\n        for a,b in zip(seq,arr):\n            diff = abs(a-b)\n            if diff > 1:\n              complete = False\n              continue\n            if diff != 0:\n              change += 1\n        if complete:\n          changes.append(change)\n  \n    if len(changes) == 0:\n      return -1\n    return min(changes)\n", "from itertools import product\n\ndef solve(arr):\n    res = []\n    for p, q in product([-1, 0, 1], repeat=2):\n        step = (arr[-1] + q - (arr[0] + p)) / (len(arr) - 1)\n        if step.is_integer():\n            exp = range(arr[0]+p, arr[-1]+q+int(step), int(step)) if step else [arr[0]+p] * len(arr)\n            res.append(sum(abs(a - e) if abs(a - e) in (0, 1) else float('inf') for a, e in zip(arr, exp)))\n    return min(res) if min(res, default=float('inf')) != float('inf') else -1", "def solve(a):\n    r = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            curr_diff = a[-1]-a[0]+j-i\n            if curr_diff%(len(a)-1) == 0:\n                curr_a = [a[0]+i] + a[1:-1] + [a[-1]+j] \n                k = curr_diff//(len(a)-1)\n                t = [abs(curr_a[0]+i*k-a[i]) for i in range(len(a))]  \n                if max(t) <= 1: r.append(sum(t))\n                    \n    return min(r) if r else -1", "def solve(ls):\n    result = [ls[each]-ls[each-1] for each in range(1, len(ls))] \n    gap = round(sum(result)/len(result))\n    tries = [ls[0]+1, ls[0], ls[0]-1] \n    answer = []\n    \n    while True:\n        count = 0    \n        copy_ls = ls[:]\n        \n        copy_ls[0] = tries.pop(0)\n        if copy_ls[0] != ls[0]:\n            count += 1\n        \n        for each in range(len(ls)-1):\n            sub_gap = copy_ls[each+1] - copy_ls[each]\n            if sub_gap < gap:\n                copy_ls[each+1] += 1\n                count += 1\n            elif sub_gap > gap:\n                copy_ls[each+1] -= 1\n                count += 1\n        \n        result = [copy_ls[each]-copy_ls[each-1] for each in range(1, len(ls))]\n        \n        if len(set(result)) == 1:\n            answer.append(count)\n        if len(tries) == 0:\n            if len(answer) == 0:\n                return -1\n            else:\n                answer.sort()\n                return answer[0]"]