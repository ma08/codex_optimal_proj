["def find_last(n, m):\n    li, start = [[0, i + 1] for i in range(n)], 0      # form list of circle with numbers\n    while len(li) != 1:\n        prev, l_ = li[start][1], len(li)               # starting point and length of circle\n        for k in range(m):                             # adding 1 to first m players in circle             \n            li[start][0] += 1\n            start = (start + 1) % l_\n\n        if m < len(li):                                # if there's anyone left from adding 1 if so..\n            k = start\n            while li[k][1] != prev:                    # adding 2 to remaining players\n                li[k][0] += 2\n                k = (k + 1) % l_\n                \n        li[start][0] += li.pop((start - 1) % l_)[0]    # add last person who receives last 1 coin to next person\n        start = [(start - 1) % l_ ,start][start==0]\n    return tuple(li[0][::-1])                          # return last person with score and original number", "def find_last(n, m):\n    num = 0\n    for i in range(2, n+1): num = (num + m) % i\n    return num+1, n*(n+1)+m*(m-2)-n*m", "from collections import deque\n\ndef person(n, m):\n    q = deque(range(n))\n    for i in range(n):\n        q.rotate(1-m)\n        x = q.popleft()\n    return x + 1\n\ndef coins(n, m):\n    return sum(m + max(i-m, 0) * 2 for i in range(n, 1, -1))\n\ndef find_last(n, m):\n    return person(n, m), coins(n, m)", "class Cycle:\n    def __init__(self, n):\n        self.length = n\n        self.h = current = node = Node(1)\n        for i in range(2, n+1):\n            current.next = Node(i)\n            current = current.next\n        current.next = node\n        \n    def minimize(self, n):\n        current = Node(0)\n        current.next = self.h\n        while self.length > 1:\n            for i in range((n - 1) % self.length):\n                current = current.next\n            current.next = current.next.next\n            self.length -= 1\n            pass\n        return current.next.n\n    \nclass Node:\n    def __init__(self, n):\n        self.n = n\n        self.next = None\n    \ndef find_last(n, m):\n    x = n - m\n    return (Cycle(n).minimize(m), (1 + x) * x + (n - 1) * m)", "def find_last(n, m):\n    people = list(range(1, n + 1))\n    coins = 0\n    for staying in range(n, 1, -1):\n        if staying >= m:\n            people = people[m:] + people[:m - 1]\n            coins += m + (staying - m) * 2\n        else:\n            last = (m % staying - 1) % staying\n            people = people[last + 1:] + people[:last]\n            coins += m\n    return people[0], coins", "def find_last(n, m):\n    pp=list(range(1,n+1))\n    p=0\n    while len(pp)>1:\n        p=(p+m-1)%len(pp)\n        del pp[p]\n    s=(n-1)*m+(n-m)*(n-m+1)\n    return pp[0],s", "def next_man(people, k):\n    while True:\n        if people[k] != '.':\n            return k\n        else:\n            if k + 1 >= len(people):\n                k = 0\n            else:\n                k += 1\n\n\ndef find_last(n, m):\n    people = [0 for i in range(n)]\n    lost_people = n\n    k = 0\n\n    while lost_people > 1:\n\n        counter = 0\n        while counter < m:\n            if people[k] != '.':\n                people[k] += 1\n                counter += 1\n                if k + 1 >= n:\n                    k = 0\n                else:\n                    k += 1\n            else:\n                if k + 1 >= n:\n                    k = 0\n                else:\n                    k += 1\n        if k - 1 < 0:\n            sub_money = people[-1]\n            people[-1] = '.'\n        else:\n            sub_money = people[k - 1]\n            people[k - 1] = '.'\n        k = next_man(people, k)\n        people[k] += sub_money\n        lost_people -= 1\n\n        whom2 = lost_people - m + 1\n        flag = k\n        if whom2 > 0:\n            for i in range(whom2):\n                people[k] += 2\n                if k + 1 >= n:\n                    k = 0\n                else:\n                    k += 1\n                k = next_man(people, k)\n        k = flag\n\n    return k+1, people[k]\n", "def find_last(n, m):\n    num, i, L = 0, 0, [0]*n\n    ni = lambda i: (i+1)%len(L)\n    pi = lambda i: (i-1)%len(L)\n    for v in range(2, n+1):\n        num = (num + m) % v\n        seen = set(range(len(L)))\n        for _ in range(m):\n            L[i] += 1\n            seen.discard(i)\n            i = ni(i)\n        for x in seen: L[x] += 2\n        j = pi(i)\n        L[i] += L[j]\n        del L[j]\n        i = pi(i)\n    return num+1, L[0]", "from collections import deque\n\ndef find_last(n, m):\n    circle = deque(range(1, n+1))\n    coin = 0\n    for _ in range(1, n):\n        coin += m if len(circle) <= m else (2 * len(circle)) - m\n        circle.rotate(-(m-1))\n        circle.popleft()\n    return (circle[0], coin)"]