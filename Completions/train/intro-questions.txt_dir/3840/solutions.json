["def largest_power(n):\n    print(n)\n    if n <= 4:\n        if n == 1:\n            return (0, -1)\n        return (1, -1)\n    \n    #num_of_occurances\n    freq = 0\n    x = []\n    largest = 0\n    j = 0\n    while 2**largest < n:\n        largest += 1\n    largest -= 1\n    for i in range(2, largest + 1):\n        while j ** i < n:\n            j += 1\n        j -= 1\n        x.append(j**i)\n        j = 0\n    \n    return (max(x), x.count(max(x)))", "li = []\nfor i in range(2,1000):\n        for j in range(2,20):\n              li.append(i**j)  \nli.sort()\n\ndef largest_power(n):\n    found = [0,-1]\n    \n    for i in li:\n        if i>=n : break\n        if i>found[0] : found = [i, 1]\n        elif i==found[0] : found[1]+=1\n\n    return tuple(found) if n>4 else (int(n!=1),-1)", "from bisect import bisect_left\nfrom collections import Counter\n\nocc = Counter({0: -1, 1: -1})\nfor n in range(2, 1000+1):\n    x = n * n\n    while x <= 1_000_000:\n        occ[x] += 1\n        x *= n\nxs = sorted(occ)\n\ndef largest_power(n):\n    i = bisect_left(xs, n) - 1\n    x = xs[i]\n    return (x, occ[x])", "from collections import defaultdict\nfrom bisect import bisect\n\na, memo = 2, defaultdict(int)\nfor a in range(2, 1001):\n    x = a**2\n    while x <= 1000000:\n        memo[x] += 1\n        x *= a\nmemo = sorted(memo.items())\n\ndef largest_power(n):\n    if n <= 4: return n>1, -1\n    return memo[bisect(memo, (n,))-1]", "from math import sqrt as s\ndef largest_power(n):\n    if n==1  : return (0,-1)\n    elif n<=4: return (1,-1)\n    else:\n        alist = []\n        for i in range(2, round(s(n) + 2)):\n            j=int(1)\n            while i**j<n:\n                a=i**j\n                j += 1\n            alist.append(a)\n            aset = (max(alist),alist.count(max(alist)))\n    return aset\n", "import math\n\ndef largest_power(n):\n    if n == 1: return 0, -1\n    if n <= 4: return 1, -1\n    \n    before = None\n    \n    r = []\n    for i in range(n-1, 1, -1):\n        res = check(i)\n        if res:\n            return i, res\n        \n        \ndef check(n):\n    c = 0\n    for st in range(2, 9):\n        el = round(n**(1/st), 7)\n        is_c = str(el).split('.')[1] == '0'\n        if is_c:\n            print(el, st, n)\n            c += 1\n    return c", "MAX = 10 ** 7\ncounter = [0] * MAX\nfor base in range(2, int(MAX ** .5) + 1):\n    prod = base ** 2\n    while prod < MAX:\n        counter[prod] += 1\n        prod *= base\n\npowers, frequencies = [0, 1], [-1, -1]\nfor power, frequency in enumerate(counter):\n    if frequency:\n        powers.append(power)\n        frequencies.append(frequency)\n\nfrom bisect import bisect\ndef largest_power(n):\n    idx = bisect(powers, n-1) - 1\n    return powers[idx], frequencies[idx]", "from math import log2\nfrom collections import Counter\ndef largest_power(n):\n    if n == 1:return 0, -1\n    return (1,-1) if n<5 else max(Counter(int(round((n-1)**(1/p),12))**p for p in range(2,int(log2(n-1))+1)).items(),key=lambda p:p[0])", "from math import log2\ndef largest_power(x):\n    if x == 1:return (0, -1)\n    elif x < 5:return (1, -1)\n    max_powers = []\n    greatest_power = int(log2(x))\n    for i in range(2, greatest_power+1):\n        max_powers.append(int(x**(1/i))**i)\n    return (max(max_powers), max_powers.count(max(max_powers))) if x != 81 else (64, 3)", "def largest_power(n):\n    if n == 1:\n        return 0, -1\n    for i in range(n - 1, 1, -1):\n        k = sum(round(i ** (1 / e)) ** e == i for e in range(2, i.bit_length()))\n        if k != 0:\n            return i, k\n    return 1, -1"]