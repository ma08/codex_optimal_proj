["from pprint import *\nuni= {'q': '\\u2655', 'B': '\\u265D', 'p': '\\u2659', 'K': '\\u265A',\n                   'N': '\\u265E', 'Q': '\\u265B', 'P': '\\u265F', 'R': '\\u265C',\n                   'n': '\\u2658', 'r': '\\u2656', 'b': '\\u2657', 'k': '\\u2654',\n              1:\"\\u2587\",0:\"\\uFF3F\"}\ndef parse_fen(string):\n    board=[[1,0,1,0,1,0,1,0] if not i%2 else [0,1,0,1,0,1,0,1] for i in range(8) ]\n\n    col,row=0,0\n    pos=0\n    placement,turn=string.split(\" \")[:2]\n\n    while pos<len(placement):\n        if placement[pos]==\"/\":\n            row+=1\n            col=0\n\n        elif (placement[pos]).isdigit():\n            col+=int(placement[pos])\n\n        else:\n            board[row][col] = uni[placement[pos]]\n            col+=1\n\n        pos+=1\n\n    board = [[uni[i] if type(i) is int else i for i in x] for x in board]\n\n    if turn==\"b\":\n        board=[list(v)[::-1] for v in zip(*[i[::-1] for i in zip(*board)])]\n        \n    return \"\\n\".join([\"\".join(i) for i in board])+\"\\n\"\n\n", "fen_notation = \"rnbqkbnrpc/CPRNBQKBNR\"\nchess_board = '''\\u2656\\u2658\\u2657\\u2655\\u2654\\u2657\\u2658\\u2656\\u2659\\uff3f\n\\u2587\\u265f\\u265c\\u265e\\u265d\\u265b\\u265a\\u265d\\u265e\\u265c'''\ntable = dict(list(zip(fen_notation, chess_board)))\n\ndef parse_fen(fen_string):\n    rev = lambda p: p[1][::(-1) ** (p[0] % 2)]\n    board = list('/'.join(map(rev, enumerate(['Cc'*4] * 8))))\n    idx, (game, turn) = 0, fen_string.split()[:2]\n    for c in game:\n        if c.isdigit(): idx += int(c)\n        else:\n            board[idx] = c\n            idx += 1\n    return rev((turn == 'b', ''.join(map(table.get, board)))) + '\\n'\n", "def parse_fen(string):\n    unicodes = {\"p\":\"\\u2659\", \"n\":\"\\u2658\", \"b\":\"\\u2657\", \"r\":\"\\u2656\", \"q\":\"\\u2655\", \"k\":\"\\u2654\",\n                \"P\":\"\\u265F\", \"N\":\"\\u265E\", \"B\":\"\\u265D\", \"R\":\"\\u265C\", \"Q\":\"\\u265B\", \"K\":\"\\u265A\",\n                \"black\":\"\\u2587\", \"white\":\"\\uff3f\"}\n                \n    black,white = unicodes[\"black\"],unicodes[\"white\"]     \n    empty = [list((black+white))*4 if i % 2 == 0 else list((white+black))*4 for i in range(8)]\n\n    field_one,active,*rest = string.split(\" \")   \n    rows = field_one.split(\"/\")\n\n    if active != \"w\":\n        rows = [i[::-1] for i in rows[::-1]]\n        \n    for row_index,row in enumerate(rows):\n        count = 0\n        for char in row:\n            if char.isdigit():\n                count += int(char)\n            else:\n                empty[row_index][count] = unicodes[char]\n                count += 1\n\n    return \"\\n\".join([\"\".join(i) for i in empty])+\"\\n\"", "TOME = {0:'\u2587', 1:'\uff3f', 'K':'\u265a', 'Q':'\u265b', 'R':'\u265c', 'B':'\u265d', 'N':'\u265e', 'P':'\u265f', 'k':'\u2654', 'q':'\u2655', 'r':'\u2656', 'b':'\u2657', 'n':'\u2658', 'p':'\u2659'}\n\ndef parse_fen(s):\n    bd,color,*_ = s.split()\n    bd = [formatRow(row, x&1) for x,row in enumerate(bd.split('/'))]\n    if color=='b':\n        bd = (r[::-1] for r in reversed(bd))\n    return '\\n'.join(bd) + '\\n'\n\ndef formatRow(row,p):\n    out = ''.join( TOME[c] if not c.isdigit() else 'x'*int(c) for i,c in enumerate(row))\n    return ''.join(c if c!='x' else TOME[p^i&1] for i,c in enumerate(out))", "def parse_fen(string):\n    placement, active, *_ = string.split()\n    board = []\n    for color, pieces in enumerate(placement.split('/')):\n        color %= 2\n        rank = []\n        for piece in pieces:\n            if piece.isdigit():\n                spaces = int(piece)\n                for i in range(spaces): rank.append(empty[(color+i)%2])\n                color ^= spaces % 2\n            else:\n                rank.append(symbols[piece])\n                color ^= 1\n        board.append(rank)\n    d = 1 if active == 'w' else -1\n    return '\\n'.join(''.join(c for c in rank[::d]) for rank in board[::d]) + '\\n'\n\nsymbols = dict(list(zip('PNBRQKpnbrqk', '\u265f\u265e\u265d\u265c\u265b\u265a\u2659\u2658\u2657\u2656\u2655\u2654')))\nempty = '\u2587\uff3f'\n", "BOARD = '\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\\n\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\\n\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\\n\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\\n\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\\n\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\\n\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\\n\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587'\nPIECES = dict(zip('kqrbnpKQRBNP', '\u2654\u2655\u2656\u2657\u2658\u2659\u265a\u265b\u265c\u265d\u265e\u265f'))\n\ndef parse_fen(string):\n    board = list(map(list, BOARD.splitlines()))\n    pieces, color = string.split()[:2]\n\n    for r, rank in enumerate(pieces.split('/')):\n        f = 0\n        for square in rank:\n            if square.isdigit():\n                f += int(square)\n            else:\n                board[r][f] = PIECES[square]\n                f += 1\n    return '\\n'.join(map(''.join, board if color == 'w' else [rank[::-1] for rank in board[::-1]])) + '\\n'", "BOARD = '\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\\n\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\\n\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\\n\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\\n\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\\n\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\\n\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\\n\uff3f\u2587\uff3f\u2587\uff3f\u2587\uff3f\u2587'\nPIECES = dict(zip('kqrbnpKQRBNP', '\u2654\u2655\u2656\u2657\u2658\u2659\u265a\u265b\u265c\u265d\u265e\u265f'))\n\ndef parse_fen(string):\n    board = list(map(list, BOARD.splitlines()))\n    pieces, color, *_ = string.split()\n\n    i = 0 if color == 'w' else 7\n\n    for r, rank in enumerate(pieces.split('/')):\n        f = 0\n        for square in rank:\n            if square.isdigit():\n                f += int(square)\n            else:\n                board[abs(r - i)][abs(f - i)] = PIECES[square]\n                f += 1\n    return '\\n'.join(map(''.join, board)) + '\\n'", "def parse_fen(string):\n    ranks = string.split('/')\n    game_info_fields = ranks[7].split(' ')\n    ranks[7] = game_info_fields[0] # trimming out the unused fields after the last rank\n    color = game_info_fields[1]\n    \n    pretty_pieces = {'r' : '\u2656', 'n' : '\u2658', 'b' : '\u2657', 'q' : '\u2655', 'k' : '\u2654', 'p' : '\u2659', \n                     'R' : '\u265c', 'N' : '\u265e', 'B' : '\u265d', 'Q' : '\u265b', 'K' : '\u265a', 'P' : '\u265f'}\n    squares = ['\u2587', '\uff3f']\n    board = [[squares[(i + j) % 2] for i in range(0, 8)] for j in range(0, 8)]\n    \n    for row in range(0, 8):\n        rank = ranks[row]\n        column = 0\n        for char in rank:\n            if char.isnumeric():\n                column += int(char)\n            else:\n                board[row][column] = pretty_pieces[char]\n                column += 1\n\n    stringify = '\\n'.join([ ('').join(board[i])  for i in range(0, 8)])\n    return stringify + '\\n' if color is 'w' else stringify[::-1] + '\\n'"]