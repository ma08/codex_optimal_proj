["def hofstadter_Q(n):\n    try:\n        return hofstadter_Q.seq[n]\n    except IndexError:\n        ans = hofstadter_Q(n - hofstadter_Q(n - 1)) + hofstadter_Q(n - hofstadter_Q(n - 2))\n        hofstadter_Q.seq.append(ans)\n        return ans\nhofstadter_Q.seq = [None, 1, 1]", "def hofstadter_Q(n):\n    q = [1, 1]\n    while len(q) < n:\n        q.append(q[-q[-1]] + q[-q[-2]])\n    return q[-1]", "def hofstadter_Q(n):\n    lst = [0,1,1]\n    while len(lst) <= n: lst += [ lst[-lst[-1]] + lst[-lst[-2]] ]\n    return lst[n]", "def hofstadter_Q(n):\n    a = [None, 1, 1]\n    for i in range(3, n + 1):\n        a.append(a[(i - a[-1])] + a[i - a[-2]])\n    return a.pop()", "li = [1, 1]\nwhile len(li) != 1000 : li.append(li[-li[-1]] + li[-li[-2]])\nhofstadter_Q=lambda n:li[n-1]", "import sys; sys.setrecursionlimit(10000)\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef Q(n):\n    if n <= 2:\n        return 1\n    return Q(n - Q(n-1)) + Q(n - Q(n-2))\n    \ndef hofstadter_Q(n):\n    return Q(n)", "memory = {1:1, 2:1}\ndef hofstadter_Q(n):\n    if n not in memory.keys():\n        memory[n] = hofstadter_Q(n-hofstadter_Q(n-1)) + hofstadter_Q(n-hofstadter_Q(n-2))\n    return memory[n]", "hofstadter_Q_values = [0, 1, 1]\n\ndef hofstadter_Q(n):\n    values = hofstadter_Q_values\n    for i in range(len(values), n + 1):\n        values.append(\n            values[i - values[i - 1]] +\n            values[i - values[i - 2]])\n    return values[n]", "def hofstadter_Q(n):\n    a=[1,1]\n    for i in range(2,n):\n        a.append(a[i-a[i-1]]+a[i-a[i-2]])\n    return a[n-1]", "from functools import lru_cache\n@lru_cache(maxsize = 1024)\ndef hofstadter_Q(n):\n    if n in (1, 2):\n        return 1\n    return hofstadter_Q(n-hofstadter_Q(n-1))+hofstadter_Q(n-hofstadter_Q(n-2))\n# Precompute to cache values and avoid exceeding too deep recursion\nfor i in range(100, 1000, 100):\n    hofstadter_Q(i)"]