["def shortest_arrang(n):\n    # For odd n, we can always construct n with 2 consecutive integers.\n    if n % 2 == 1:\n        return [n//2 + 1, n//2]\n\n    # For even n, n is the sum of either an odd number or even number of\n    # consecutive positive integers. Moreover, this property is exclusive.\n\n    for i in range(3, n // 2):\n        if i % 2 == 1 and n % i == 0:\n        # For odd i, if n / i is an integer, then the sequence, which has\n        # odd length, is centered around n / i.\n            return list(range(n//i + i//2, n//i - i//2 - 1, -1))\n        elif i % 2 == 0 and n % i == i // 2:\n        # For even i, if the remainder of n / i is 1/2, then the sequence\n        # (even length) is centered around n / i.\n            return list(range(n//i + i//2, n//i - i//2, -1))\n\n    # If none of the above are satisfied, then n is a power of 2 and we cannot\n    # write it as the sum of two consecutive integers.\n    return [-1]\n", "def shortest_arrang(n):\n    k = 1\n    while n >= 0:\n        n -= k\n        k += 1\n        d, m = divmod(n, k)\n        if not m:\n            return list(range(d + k - 1, d - 1, -1))\n    return [-1]", "def shortest_arrang(n):\n    nGrpMax = int( ((1+8*n)**.5-1)/2 )\n    for nGrp in range(2, nGrpMax+1):\n        maxInG = (2*n + nGrp**2 - nGrp) / (2*nGrp)\n        if maxInG == int(maxInG):\n            maxInG = int(maxInG)\n            return list(range(maxInG, maxInG-nGrp, -1))\n    return [-1]", "def shortest_arrang(n):\n    r = n // 2 + 2\n    a = [i for i in range(r, 0, -1)]\n    for i in range(r):\n        for j in range(r + 1):\n            if sum(a[i:j]) == n:\n                return a[i:j]\n    return [-1]\n", "def shortest_arrang(n):\n    a = n // 2\n    b = a + 1\n    \n    while a:\n        total = sum(range(a, b+1))\n        if total == n:\n            return list(range(b, a-1, -1))\n        \n        if total > n:\n            b -= 1\n            a = b-1\n        else:\n            a -= 1\n    else:\n        return [-1]", "def shortest_arrang(num):\n    for n in reversed(range((num+3) // 2)):\n        for j in reversed(range(n)):\n            x = range(j, n+1)\n            if sum(x) == num:\n                return list(reversed(x))\n    return [-1]    ", "def shortest_arrang(n):\n    for i in range(2,n):\n        if (n/i)*2<i: break\n        if i%2==0 and (n/i)%1==0.5: return [n//i-i//2+1+j for j in range(0,i)[::-1]]\n        if i%2==1 and (n/i)%1==0: return [n//i-(i-1)//2+j for j in range(0,i)[::-1]]\n    return [-1]\n", "shortest_arrang=lambda n:(lambda ngm:next(((lambda x:list(range(x,x-ng,-1)))(int((2*n+ng**2-ng)/(2*ng)))for ng in range(2,ngm+1)if not((2*n+ng**2-ng)/(2*ng))%1),[-1]))(int(((1+8*n)**.5-1)/2)) "]