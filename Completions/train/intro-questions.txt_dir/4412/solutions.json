["def subsets(collection):\n    if len(collection) == 1:\n        yield [collection]\n        return\n\n    first = collection[0]\n    for smaller in subsets(collection[1:]):\n        yield [first] + smaller\n        for n, subset in enumerate(smaller):\n            yield smaller[:n] + [first + subset]  + smaller[n+1:]\n\ndef bucket_digit_distributions_total_sum(n):\n    return sum(sum(map(int, sub)) for sub in subsets(str(n))) - n\n\ndef find(n, z):\n    f_nf = bucket_digit_distributions_total_sum(n) + z\n    while 1:\n        n += 1\n        if bucket_digit_distributions_total_sum(n) > f_nf:\n            return n", "from functools import reduce\nfrom itertools import count\ncoefs = [\n    [22, 13, 4],\n    [365, 167, 50, 14],\n    [5415, 2130, 627, 177, 51],\n    [75802, 27067, 7897, 2254, 661, 202],\n    [1025823, 343605, 100002, 28929, 8643, 2694, 876]\n]\ndef f(n): return sum(c*int(d) for c,d in zip(coefs[len(str(n))-3], str(n)))\n\ndef find(n,z):\n    t = f(n)+z\n    for nf in count(n):\n        if f(nf) > t: return nf", "from itertools import count\n\ndef rec(n):\n    if not n: yield 0; return\n    for i in range(1 << (len(n) - 1)):\n        tmp = [[], []]\n        for t in n:\n            i, r = divmod(i, 2)\n            tmp[r].append(t)\n        x, y = int(''.join(tmp[0])), tmp[1]\n        for k in rec(y): yield x + k\nval = lambda n: sum(rec(str(n))) - n\n\ndef find(n, z):\n    z += val(n)\n    return next(i for i in count(n+1) if val(i) > z)", "def find(n,z):\n  r=n+1\n  sumn=sumof(n)\n  while True:\n    if sumof(r)>sumn+z: return r\n    r+=1\n  return \"Perhaps this is a different way to solve the kata, but it works ;-)(not cheat)\"\ndef sumof(n):\n  fm=[[],[],[],[22,13,4],[365,167,50,14],[5415,2130,627,177,51],[75802,27067,7897,2254,661,202],[123456,123456,123456,123456,123456,123456,123456]]\n  l=1 if n<10 else(2 if n<100 else(3 if n<1000 else(4 if n<10000 else (5 if n<100000 else (6 if n<1000000 else 7)))))\n  a,i,r=fm[l],l-1,0\n  while n>0:\n    t=n%10\n    n//=10\n    r+=t*a[i]\n    i-=1\n  return r", "# Partition generator taken from \n# https://stackoverflow.com/questions/19368375/set-partitions-in-python\ndef partition(collection):\n    if len(collection) == 1:\n        yield [ collection ]\n        return\n\n    first = collection[0]\n    for smaller in partition(collection[1:]):\n        # insert `first` in each of the subpartition's subsets\n        for n, subset in enumerate(smaller):\n            yield smaller[:n] + [[ first ] + subset]  + smaller[n+1:]\n        # put `first` in its own subset \n        yield [ [ first ] ] + smaller\n        \ndef part_sum(part_list):\n    tot_sum = 0\n    for elem in part_list:\n        tot_sum += sum(int(''.join(x)) for x in elem)\n    return tot_sum\n\ndef find(n,z):\n    min_sum = part_sum([x for x in partition(list(str(n)))][1:]) + z\n    i = 1\n    nf_sum = part_sum([x for x in partition(list(str(n+i)))][1:])\n    while nf_sum <= min_sum:\n        i += 1\n        nf_sum = part_sum([x for x in partition(list(str(n+i)))][1:])\n    return n+i", "def find(n, z):\n    lim = bucket_digit_distributions_total_sum(n) + z\n    num = n\n    \n    while True: \n        num += 1\n        res = bucket_digit_distributions_total_sum(num)\n        if lim < res: \n            return num\n            \n    return num\n\ndef bucket_digit_distributions_total_sum(n): \n    parts = get_partitions(list(str(n)), len(str(n)))\n    buckets_sum = 0\n    \n    for p in parts: \n        if len(p) > 1:\n            b = [int(''.join(l)) for l in p]\n            buckets_sum += sum(b)\n        \n    return buckets_sum\n    \n\ndef get_partitions(lst, n):\n    if n <= 0: \n        yield []\n        return\n    else: \n        curr = lst[n - 1]\n        for part in get_partitions(lst, n - 1): \n            for l in list(part): \n                l.append(curr)\n                yield part\n                l.pop()\n            yield part + [[curr]]", "def find(n, z):\n    \n    \n    lim = bucket_digit_distributions_total_sum(n) + z\n    num = n\n    \n    while True: \n        num += 1\n        res = bucket_digit_distributions_total_sum(num)\n        if lim < res: \n            return num\n            \n    return num\n\ndef bucket_digit_distributions_total_sum(n): \n    parts = get_partitions(list(str(n)), len(str(n)))\n    buckets_sum = 0\n    \n    for p in parts: \n        if len(p) > 1:\n            b = [int(''.join(l)) for l in p]\n            buckets_sum += sum(b)\n        \n    return buckets_sum\n    \n\ndef get_partitions(lst, n):\n    if n <= 0: \n        yield []\n        return\n    else: \n        curr = lst[n - 1]\n        for part in get_partitions(lst, n - 1): \n            for l in list(part): \n                l.append(curr)\n                yield part\n                l.pop()\n            yield part + [[curr]]\n            \nprint(find(9457, 4))", "#def find(n,z):\n\n#    s = [i for i in str(n)]\n#    print (s)\n#    k = []\n#    for i in range(len(s)):\n#        s_n = s[:i]+s[i+1:]\n#        b = [s[i]]\n#        k = [s[i]] + [s_n]\n#        print (k)\n#        for i in range(len(s_n)):\ndef subsets(collection):\n    if len(collection) == 1:\n        yield [collection]\n        return\n\n    first = collection[0]\n\n    for smaller in subsets(collection[1:]):\n        yield [first] + smaller\n        for n, subset in enumerate(smaller):\n            yield smaller[:n] + [first + subset]  + smaller[n+1:]\n\ndef bucket_digit_distributions_total_sum(n):\n    return sum(sum(map(int, sub)) for sub in subsets(str(n))) - n\n\ndef find(n, z):\n    f_nf = bucket_digit_distributions_total_sum(n) + z\n    while 1:\n        n += 1\n        if bucket_digit_distributions_total_sum(n) > f_nf:\n            return n         ", "def get_partitionr(ss):\n    out = []\n    if len(ss) <= 1:\n        return [ss]\n    for i in range(2**len(ss)//2):\n        parts = [[], []]\n        for item in ss:\n            parts[i&1].append(item)\n            i >>= 1\n        bb = get_partitionr(parts[1])\n        for b in bb:\n            out.append([parts[0]]+ b)\n    return out\n\ndef add(parts):\n    total = 0\n    for part in parts:\n        total += sum(int(''.join(p)) if isinstance(p, list) else int(p) for p in part)\n    return total\n\ndef find(n, z):\n    parts = get_partitionr(list(str(n)))[1:]\n    add_parts = add(parts)\n    target = add_parts + z\n    while add_parts <= target:\n        n += 1\n        parts = get_partitionr(list(str(n)))[1:]\n        add_parts = add(parts)\n    return n", "import itertools\ndef find(n,z):\n    find.combination_dict = {0:((),), \n        1:( ((0,),), ), }\n        # 2:(((0,), (1,)), ((0, 1),), ), }\n        # 3: (((0,), (1,), (2,)), ((0,), (1,2)), ((1,), (0,2)), ((2,), (0,1)), ((0,1,2),),)}\n    def get_combination(length):\n        if length not in find.combination_dict:\n            for i in range(length):\n                get_combination(i)\n            template = list(range(length))\n            result = [{tuple(i for i in template)}]\n            for init_tuple_length in range(1, length):\n                for c in itertools.combinations(template, init_tuple_length):\n                    remain = [i for i in template if i not in c]\n                    for combinations in find.combination_dict[length - init_tuple_length]:\n                        new_combination = [tuple(c)]\n                        for combination in combinations:\n                            new_combination.append(tuple(remain[index] for index in combination))\n                        if set(new_combination) not in result:\n                            result.append(set(new_combination))\n            find.combination_dict[length] = tuple(tuple(i) for i in result)\n        return find.combination_dict[length]\n\n    def f(num):\n        num = str(num)\n        value = []\n        for combinations in get_combination(len(num)):            \n            if len(combinations) != 1:\n                for combination in combinations:\n                    value.append(''.join(num[i] for i in combination))\n        return sum(map(int, value))\n        \n#     print('running', n, f(n), z)\n    limit = f(n) + z\n    for nf in itertools.count(n):\n        if f(nf) > limit:      \n            return nf\n"]