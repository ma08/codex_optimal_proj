["from collections import defaultdict as dd\nfrom collections import deque\nimport bisect\nimport heapq\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(map(int, input().split()))\n\n\ndef solve():\n    n = ri()\n    output = [0] * (n)\n\n    Q = [(-n, 0 ,n - 1)]\n    for i in range(1, n + 1):\n        prev = heapq.heappop(Q)\n        lo, hi = prev[1], prev[2]\n        mid = (lo + hi) // 2\n        output[mid] = i\n        if mid > lo:\n            heapq.heappush(Q, (-(mid - 1 - lo), lo, mid - 1))\n        if hi > mid:\n            heapq.heappush(Q, (-(hi - 1 - mid), mid + 1, hi))\n    print(*output)\n\n\n\n\n\nmode = 'T'\n\nif mode == 'T':\n    t = ri()\n    for i in range(t):\n        solve()\nelse:\n    solve()\n", "from heapq import heappush, heappop\n\nfor _ in range(int(input())):\n    n = int(input())\n    pq = [(-n, 1, n)]\n    a = [0 for i in range(n + 1)]\n    for i in range(1, n + 1):\n        sz, l, r = heappop(pq)\n        j = (l + r) // 2 if (r - l + 1) % 2 else (l + r - 1) // 2\n        a[j] = i\n        if j + 1 <= r:\n            heappush(pq, (-(r - (j + 1) + 1), j + 1, r))\n        if l <= j - 1:\n            heappush(pq, (-((j - 1) - l + 1), l, j - 1))\n    print(*a[1:])\n", "import heapq\nt = int(input())\n\nfor loop in range(t):\n\n    n = int(input())\n\n    q = []\n    q.append([-1*n,0,n-1])\n\n    ans = [0] * n\n    cnt = 1\n\n    while len(q) > 0:\n\n        tmppop = heapq.heappop(q)\n        length,l,r = tmppop\n        mid = (l+r)//2\n\n        ans[mid] = cnt\n        cnt += 1\n\n        if mid-1 >= l:\n            heapq.heappush(q,[-1 * ((mid-1)-l+1) , l , mid-1])\n        if mid +1 <= r:\n            heapq.heappush(q,[-1 * (r-(mid+1)+1) , mid+1 , r])\n\n    print(*ans)\n", "import sys\nimport heapq as hq\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\n\ndef solve():\n    n = ni()\n    a = [0]*n\n    q = [(-n, 0, n-1)]\n    for i in range(n):\n        v, l, r = hq.heappop(q)\n        m = (l + r)//2\n        a[m] = i + 1\n        hq.heappush(q, (-(m-l), l, m-1))\n        hq.heappush(q, (-(r-m), m+1, r))\n    print(*a)\n\n\n# solve()\n\nT = ni()\nfor _ in range(T):\n    solve()\n", "from heapq import *\nt = int(input())\n\nwhile t:\n    t-=1\n    n = int(input())\n    q = []\n    heappush(q,(-n,0,n-1))\n    arr = [0]*n\n    for i in range(n):\n        # print(q)\n        # print(arr)\n        p = heappop(q) \n        l,r = p[1],p[2]\n        mid = (l+r)//2\n        arr[mid] = i+1\n        if mid-l > 0:\n            heappush(q,(-mid+l,l,mid-1))\n        if r-mid > 0:\n            heappush(q,(-r+mid,mid+1,r))\n    print(*arr)", "import heapq\nfor _ in range(int(input())):\n    n=int(input())\n    a=[0]*n\n    que=[(-n,0,n-1)]\n    heapq.heapify(que)\n    i=1\n    while que:\n        len,l,r=heapq.heappop(que)\n        if len%2==1:\n            a[(l+r)//2]=i\n            if r!=l:\n                nl=(-(r-l)//2,l,(l+r)//2-1)\n                nr=(-(r-l)//2,(l+r)//2+1,r)\n                heapq.heappush(que,nl)\n                heapq.heappush(que,nr)\n        else:\n            a[(l+r-1)//2]=i\n            nl=(-(r-l-1)//2,l,(l+r-1)//2-1)\n            nr=(-(r-l+1)//2,(l+r-1)//2+1,r)\n            if r==l+1:\n                heapq.heappush(que,nr)\n            else:\n                heapq.heappush(que,nr)\n                heapq.heappush(que,nl)\n        i+=1\n    print(*a)", "import heapq\nimport sys\ninput=sys.stdin.readline\nfrom collections import defaultdict as dd\nt=int(input())\nwhile t:\n    n=int(input())\n    ans=[0]*n\n    i=0\n    j=n-1\n    h=[(i-j-1,i,j)]\n    heapq.heapify(h)\n    ii=1\n    while h:\n        le,x,y=heapq.heappop(h)\n        le=-le\n        mid=(x+y)//2\n        ans[mid]=ii\n        ii+=1\n        if(mid-x>0):\n            heapq.heappush(h,(x-mid,x,mid-1))\n        if(y-mid>0):\n            heapq.heappush(h,(mid-y,mid+1,y))\n    print(*ans)\n    t-=1\n            \n        \n", "import heapq\n\ndef solve():\n    n = int(input())\n    cur = 1\n    a = [0] * n\n    q = []\n    heapq.heappush(q, (-n, 0, n))\n    while q:\n        _, l, r = heapq.heappop(q)\n        mid = (l + r - 1) // 2\n        a[mid] = cur\n        cur += 1\n        if l < mid:\n            heapq.heappush(q, (l - mid, l, mid))\n        if mid + 1 < r:\n            heapq.heappush(q, ((mid + 1) - r, mid + 1, r))\n    print(*a)\n\nt = int(input())\nfor _ in range(t):\n    solve()", "for f in range(int(input())):\n    n=int(input())\n    segs=[[n,0]]\n    sol=[0]*n\n    i=0\n    prev=n\n    j=0\n    while i<n:\n        i+=1\n        if j<0:\n            segs.sort(reverse=True)\n            j=0\n            while j<len(segs) and segs[j][0]==segs[j+1][0]:\n                j+=1\n            prev=segs[0][0]\n        m=segs[j][1]+(segs[j][0]-1)//2\n        sol[m]=i\n        segs.append([segs[j][0]//2,m+1])\n        segs.append([(segs[j][0]-1)//2,segs[j][1]])\n        segs[j][0]=0\n        j-=1\n    print(*sol)", "import sys\ninput = sys.stdin.readline\n\ndef construct(A,count,MAX):\n    #print(ANS,A,count,MAX)\n    B=[]\n    NMAX=0\n    for l,r in A:\n        if r-l+1==MAX:\n            ANS[(r+l)//2]=count\n            count+=1\n\n            if l<=(r+l)//2-1:\n                NMAX=max(NMAX,(r+l)//2-l)\n                B.append((l,(r+l)//2-1))\n            if r>=(r+l)//2+1:\n                NMAX=max(NMAX,r-(r+l)//2)\n                B.append(((r+l)//2+1,r))\n        else:\n            NMAX=max(NMAX,r-l+1)\n            B.append((l,r))\n    if NMAX!=0:\n        construct(B,count,NMAX)\n                \n            \n\nt=int(input())\nfor tests in range(t):\n    n=int(input())\n    ANS=[0]*n\n    construct([(0,n-1)],1,n)\n    print(*ANS)\n", "import heapq\n\ndef solve(k):\n\n    stack = [(-k,0,k-1)]  # -length, start, end (both inclusive)\n    heapq.heapify(stack) \n\n    res = [\"x\" for _ in range(k)]\n    cnt = 0\n\n    while stack:\n        # print(res, stack)\n        cnt += 1\n        length, start, end = heapq.heappop(stack)\n        length = -length  # fix sign\n        if length%2 == 1:  # if segment is odd length\n            mid_point = (start+end)//2\n            res[mid_point] = cnt\n            if not start == end:\n                heapq.heappush(stack, (-(mid_point-start), start, mid_point-1))\n                heapq.heappush(stack, (-(mid_point-start), mid_point+1, end))\n        else:  # segment is of even length\n            mid_point = (start+end-1)//2\n            res[mid_point] = cnt\n            if length == 2:  # one other left\n                heapq.heappush(stack, (-1, end, end))\n            else: \n                heapq.heappush(stack, (-(length//2 - 1), start, mid_point-1))\n                heapq.heappush(stack, (-(length//2), mid_point+1, end))\n\n        # if cnt > 5:\n        #     break\n\n    # print()\n    # print()\n    # print()\n    return \" \".join([str(x) for x in res])\n                \n\n\nstrr = input()\nfor _ in range(int(strr)):\n    k = int(input())\n    print(solve(k))\n", "import heapq\n\ndef solve(n):\n    h = [(-n, 0, n-1)]\n    sol = [0]*n\n    curr = 1\n    while h:\n        _, l, r = heapq.heappop(h)\n        mid = l+(r-l)//2\n        if l <= mid-1:\n            heapq.heappush(h, (l-mid+1, l, mid-1))\n        if r >= mid+1:\n            heapq.heappush(h, (mid+1-r, mid+1, r))\n        sol[mid] = curr\n        curr += 1\n    return sol\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    # n, k = map(int, input().split())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n    print(' '.join(map(str, solve(n))))"]