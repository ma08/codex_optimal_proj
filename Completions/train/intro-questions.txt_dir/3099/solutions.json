["from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c:i for i,c in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef whoIsWinner(moves, con, sz):\n    def gen(i, j):\n        for x in range(1, con):\n            yield ((i, j-x), (i-x, j), (i+x, j), (i-x, j-x), (i+x, j+x), (i+x, j-x), (i-x, j+x))\n    \n    def check(i, j, p):\n        memo, count = [True]*7, [0]*7\n        for L in gen(i, j):\n            for x,(k,l) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < sz and 0 <= l < sz and grid[k][l] == p\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1]+count[2], count[3]+count[4], count[5]+count[6])+1 >= con\n        return True\n    \n    if sz >= con <= len(moves):\n        grid = [[None]*sz for _ in range(sz)]\n        for move in moves:\n            i, p = D[move[0]], move[-1]\n            j = next(j for j,x in enumerate(grid[i]) if x is None)\n            if check(i, j, p): return p\n            grid[i][j] = p\n    return \"Draw\"", "from string import ascii_letters as rows\nROWS = {c: n for n, c in enumerate(rows[26:] + rows[:26])}\nDIRS = [(1, 0), (1, 1), (0, 1), (-1, 1)]\n\ndef whoIsWinner(moves, connect, size):\n    def check_line(dx, dy):\n        n = 0\n        for _ in range(2):\n            dx, dy, x, y = -dx, -dy, p, q\n            while (0 <= x < size and 0 <= y < len(grid[x])\n                   and grid[x][y] == player):\n                n += 1; x += dx; y += dy\n        return n > connect\n\n    grid = [[] for _ in range(size)]\n    for move in moves:\n        row, player = move.split('_')\n        p = ROWS[row]; q = len(grid[p])\n        grid[p].append(player)\n        if any(check_line(u, v) for u, v in DIRS):\n            return player\n    return 'Draw'", "from itertools import count,takewhile\n\nMOVES = ((0,1), (1,1), (1,0), (-1,1))\n\n    \ndef whoIsWinner(moves,nCon,sz):\n    \n    def insideAndSameYet(z): x,y=z ; return 0<=x<sz and 0<=y<sz and grid[x][y] == who\n    \n    def isWinner(x, y, who):\n        for dx,dy in MOVES:\n            s = 1 + sum(1 for c in (-1,1) for _ in takewhile(insideAndSameYet, ((x+c*n*dx, y+c*n*dy) for n in count(1))))\n            if s >= nCon: return True\n        return False\n    \n    \n    grid    = [ ['']*sz for _ in range(sz) ]\n    xInCols = [0] * sz\n    \n    for m in moves:\n        who = m[-1]\n        y = ord(m[0]) - (65 if m[0].isupper() else 71)\n        x = xInCols[y]\n        \n        xInCols[y] += 1\n        grid[x][y] = who\n        \n        if isWinner(x,y,who): return who\n    \n    else:\n        return \"Draw\"", "import re\nfrom string import Template\ndef whoIsWinner(moves,con,sz):\n    z = (sz+1)**2\n    r = [\"-\"]*z\n    d = dict()\n    reg = Template(\"(\\\\w)(((.{$s1}\\\\1){$c})|(\\\\1{$c})|((.{$s2}\\\\1){$c})|((.{$s3}\\\\1){$c}))\")\n    reg = re.compile((reg.substitute(s1 = str(sz-1), c = str(con-1), s2=str(sz), s3=str(sz+1))))\n    for i,x in enumerate(list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\")[:sz]):\n        d[x]=z-(sz+1)+i\n    for s in moves:\n        r[d[s[0]]] = s[2]\n        d[s[0]] -= sz+1\n        m = reg.findall((\"\").join(r))\n        if(m):\n            return m[0][0]\n    return \"Draw\"", "whoIsWinner=lambda M,C,Z:(lambda g,X:next((w for w,y in map(lambda m:(m[-1],ord(m[0])-(65 if m[0].isupper()else 71)),M)for x in(X.__getitem__(y),)if X.__setitem__(y,X.__getitem__(y)+1)or g.__getitem__(x).__setitem__(y,w)\n                                           or any(C<=1+sum(1 for c in(-1,1)for _ in __import__(\"itertools\").takewhile(lambda z:0<=z[0]<Z and 0<=z[1]<Z and g[z[0]][z[1]]==w,((x+c*n*dx,y+c*n*dy)for n in __import__(\"itertools\").count(1))))for dx,dy in((0,1),(1,1),(1,0),(-1,1)))),\"Draw\")\n                         )(*([['']*Z for _ in range(Z)],[0]*Z))", "from itertools import count\n\nMOVES = ((0,1), (1,1), (1,0), (-1,1))\n\n    \ndef whoIsWinner(moves,nCon,sz):\n\n    def isWinner(rX,rY, who):\n        for dx,dy in MOVES:\n            s = 1\n            for c in (-1,1):\n                for n in count(1):\n                    x,y = rX + c*n*dx, rY + c*n*dy\n                    if not (0<=x<sz and 0<=y<sz and grid[x][y] == who): break\n                    s += 1\n            if s >= nCon: return True\n        return False\n    \n    \n    grid    = [ ['']*sz for _ in range(sz) ]\n    xInCols = [0] * sz\n    \n    for m in moves:\n        who = m[-1]\n        y = ord(m[0]) - (65 if m[0].isupper() else 71)\n        x = xInCols[y]\n        \n        xInCols[y] += 1\n        grid[x][y] = who\n        if isWinner(x,y,who): return who\n    \n    else:\n        return \"Draw\"", "from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c:i for i,c in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef whoIsWinner(moves, con, sz):\n    def gen(i, j):\n        for x in range(1, con):\n            yield ((i, j-x), (i-x, j), (i+x, j), (i-x, j-x), (i+x, j+x), (i+x, j-x), (i-x, j+x))\n    \n    def check(i, j, p):\n        memo, count = [True]*7, [0]*7\n        for L in gen(i, j):\n            for x,(k,l) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < sz and 0 <= l < sz and grid[k][l] == p\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1]+count[2], count[3]+count[4], count[5]+count[6])+1 >= con\n        else: return True\n    \n    if sz >= con <= len(moves):\n        grid = [['0']*sz for _ in range(sz)]\n        for move in moves:\n            i, p = D[move[0]], move[-1]\n            j = next(j for j,x in enumerate(grid[i]) if x == '0')\n            if check(i, j, p): return p\n            grid[i][j] = p\n    return \"Draw\"", "from string import ascii_uppercase, ascii_lowercase\nfrom collections import Counter\nimport re\n\nA = {x: i for i, x in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef f(P, W):\n    row, col = divmod(P, W)\n    r = [\n        [row * W + i for i in range(W)],\n        [W * i + col for i in range(W)]\n    ]\n    if P >= (W + 1) * row:\n        s = P - row * (W + 1)\n        r.append([s + (W + 1) * i for i in range(W - s)])\n    else:\n        s = W * (row - col)\n        r.append([s + (W + 1) * i for i in range(W - row + col)])\n    ###\n    if P >= (W - 1) * (row + 1):\n        s = W * (W - 2) + col + row + 1\n        r.append([s - (W - 1) * i for i in range(W - s % W)])\n    else:\n        s = W * row + W * col\n        r.append([s - (W - 1) * i for i in range(s // W + 1)])\n    return r\n\ndef whoIsWinner(G, n, w, d=\"Draw\"):\n    if n > w: return d\n    D, P, C = dict(), Counter(), Counter()\n    for x in G:\n        p, t = x.split(\"_\")\n        col = A[p]\n        rp = col + P[col] * w\n        P[col] += 1\n        D[rp] = t\n        C[t] += 1\n        if C[t] < n:\n            continue\n        if next((1 for x in f(rp, w) if re.search(fr\"({t})\\1{{{n-1}}}\", \"\".join(D.get(y, \".\") for y in x))), None):\n            return t\n    return d", "import re\n\ndef check(line, ch, connect):\n    return re.search(re.escape(ch)+'{'+re.escape(str(connect))+'}', ''.join(line))\n\ndef decide(matrix, i, j, connect, size):\n        ch = matrix[i][j]\n        row = matrix[i][max(0, j - connect + 1):j + connect]\n        if check(row, ch, connect) : return True\n    \n        column = [k[j] for k in matrix[max(0, i - connect + 1):i + connect]]\n        if check(column, ch, connect) : return True\n    \n        for x in [[(-1, -1), (1, 1)], [(-1, 1), (1, -1)]]:\n            diagonal = []\n            for ind, (k, l) in enumerate(x):\n                ni, nj, li = i + k, j + l, []\n                while 0 <= ni < size and 0 <= nj < size and len(li) != connect and matrix[ni][nj] != ' ':\n                    li.append(matrix[ni][nj])\n                    ni += k\n                    nj += l\n                diagonal.extend(li[::[-1,1][ind]] + [ch])\n            if check(diagonal[:-1], ch, connect) : return True\n        return False\n\ndef whoIsWinner(moves,connect,size):\n    matrix = [[' ' for _ in range(size)] for _ in range(size)]\n    columns = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'[:size]\n    AVL = {i: size - 1 for i in columns}\n\n    for move in moves:\n        col, player = move.split('_')\n        r, c = AVL[col], columns.index(col)\n    \n        matrix[r][c] = player\n        AVL[col] -= 1\n\n        if decide(matrix, r, c, connect, size) : return player\n    return 'Draw'", "columns = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndef parseMove(move):\n  (loc, player) = move.split(\"_\")\n  return (columns.index(loc), player)\n\ndef placeMove(move, board):\n  (loc, player) = parseMove(move)\n  board[loc].append(player)\n\ndef isConnect(loc, dir, connect, board):\n  count = 1\n  (x,y) = loc\n  player = board[x][y]\n\n  s = 1\n  isCheckForward = True\n  isCheckBack = True\n\n  while count < connect and (isCheckForward or isCheckBack):\n    (sx,sy) = tuple(e * s for e in dir)\n    \n    if (isCheckForward and \n        x+sx < len(board) and x+sx >= 0 and \n        y+sy < len(board[x+sx]) and y+sy >= 0 and\n        board[x+sx][y+sy] == player):\n      count += 1\n    else:\n      isCheckForward = False\n\n    if (isCheckBack and \n        x-sx >= 0 and x-sx < len(board) and\n        y-sy >= 0 and y-sy < len(board[x-sx]) and\n        board[x-sx][y-sy] == player):\n      count += 1\n    else:\n      isCheckBack = False\n\n    s += 1\n\n  return count >= connect\n\n\ndef findWinner(move, connect, board):\n  (x, player) = parseMove(move)\n  y = len(board[x]) - 1\n  loc = (x,y)\n\n  for d in [(1,0), (0,1), (1,1), (1, -1)]:\n    if isConnect(loc, d, connect, board):\n      return player\n\n  return None\n\ndef whoIsWinner(moves,connect,size):\n  board = [[] for _ in range(size)]\n  winner = None\n\n  while not winner and len(moves) > 0:\n    move = moves.pop(0)\n    placeMove(move, board)\n    winner = findWinner(move, connect, board)\n\n  return winner if winner else \"Draw\"\n\n"]