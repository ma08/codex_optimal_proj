["from collections import Counter\nfrom itertools import count, islice\n\ndef performant_smallest(arr, n):\n    cnts = Counter(arr)\n    total = 0\n    for i, c in sorted(cnts.items()):\n        total += c\n        if total >= n:\n            break\n    available = count(c + n - total, -1)\n    it = (x for x in arr if x < i or (x == i and next(available) > 0))\n    return list(islice(it, n))", "def performant_smallest(xs, n):\n    ys = sorted(xs)\n    del ys[n:]\n    m = ys[-1]\n    km = ys.count(m)\n    res = []\n    for x in xs:\n        if x <= m:\n            if x < m:\n                res.append(x)\n            elif km > 0:\n                res.append(x)\n                km -= 1\n    return res", "def performant_smallest(arr, n):\n    keys = sorted(list(range(len(arr))), key=arr.__getitem__)\n    return [arr[i] for i in sorted(keys[:n])]\n", "import numpy as np\ndef performant_smallest(a, n):\n    l = len(a)\n    arr = np.array([v + (i / l) for i, v in enumerate(a)])\n    ag = np.argpartition(arr, n - 1)\n    args = np.sort(ag[:n])\n    return [a[x] for x in args]", "def performant_smallest(lst, n):\n    c = [0]*201     #Our counter.\n    for itm in lst:     c[itm+100] += 1     #Map each number to num+100.\n    res, sm = [0]*n, 0\n    for k in range(201):    #Iterate through the numbers in our counter.\n        sm += c[k]\n        if sm >= n:\n            c[k] += n - sm  #The sum of `c[:k+1]` should be equal to `n`, and this would give us the count of the `n` smallest elements.\n            break\n    sm = 0\n    for itm in lst:     #Iterate through the list to present the elements in their appearance order in the list.\n        v = itm+100     #The mapping between the list item and its index in our counter.\n        if v <= k and c[v] > 0:     #The item is one of the `n` smallest items.\n            res[sm] = itm   #Place it in its position in the result list.\n            sm += 1\n            c[v] -= 1\n        if sm == n: break\n    return res", "def performant_smallest(arr, n):\n    c = [0]*51\n    o = [0]*n\n    #Count each number 1-50 in arr        \n    for i in arr:        \n        c[i] += 1 \n    #find least max number       \n    j, st =  0, (len(arr)-n) #count of max numbers in arr\n    for m in range(50, -1, -1):   \n        j += c[m]\n        if j >= st:\n            c[m] = j - st\n            break #m contains least max number\n    j = 0\n    #put elements from arr upto n, less than m upto c counts\n    for i in arr:\n        if i <= m and c[i] > 0:\n            o[j] = i \n            j += 1\n            c[i] -= 1\n        if j == n: #out has all n elements for out\n            break\n    return o", "from bisect import bisect_left\n\ndef performant_smallest(arr, n):\n    sarr = sorted(arr)\n    limit = sarr[n-1]\n    r = n - bisect_left(sarr, limit)\n    ans = []\n    for a in arr:\n        if a < limit or (a == limit and r):\n            ans.append(a)\n            r -= (a == limit)\n            if len(ans) == n:\n                return ans\n", "import numpy as np\n\ndef performant_smallest(arr, n):\n    return np.asarray(arr)[np.sort(np.argsort(arr, kind='mergesort')[:n])].tolist()", "def performant_smallest(arr, n):\n    count = [0] * 51\n    \n    for num in arr:\n        count[num] += 1\n    \n    take = [0] * 51\n    i = 1\n    \n    while True:\n        c = count[i]\n        if c >= n:\n            take[i] = n\n            break\n        else:\n            take[i] = c\n            n -= c\n        i += 1\n    \n    res = []\n\n    for num in arr:\n        if take[num]:\n            res.append(num)\n            take[num] -= 1\n    \n    return res\n    \n", "from collections import Counter\n\n\ndef performant_smallest(arr, n):\n    counts = Counter(arr)\n    total = 0\n    num_max = 0\n    result = []\n    for item, count in sorted(counts.items()):\n        if total + count >= n:\n            maximum = item\n            max_max = n - total\n            break\n        total += count\n    for element in arr:\n        if element < maximum:\n            result.append(element)\n        elif element == maximum and num_max < max_max:\n            result.append(element)\n            num_max += 1\n    return result"]