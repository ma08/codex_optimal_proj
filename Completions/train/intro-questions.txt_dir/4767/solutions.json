["from itertools import starmap, combinations\nfrom operator import lt, gt\n\ndef longest_comb(arr, command):\n    check = lt if command.startswith('<') else gt\n    for i in range(len(arr), 2, -1):\n        # if all(map(check, x, x[1:])) In Python 3\n        result = [list(x) for x in combinations(arr, i) if all(starmap(check, zip(x, x[1:])))]\n        # Also always annoying to return only the first element when we only have one\n        if result: return result[0] if len(result) == 1 else result\n    return []", "from operator import gt, lt\ndef longest_comb(arr, command):\n    max_length, stack, op = 1, [], {'>': gt, '<': lt}[command[0]]\n    for n in arr[::-1]:\n        for i in range(len(stack)):\n            if op(n, stack[i][0]):\n                stack.append([n] + stack[i])\n                max_length = max(max_length, len(stack[-1]))\n        stack.append([n])\n    ret = [seq for seq in stack if len(seq) == max_length][::-1]\n    return [] if max_length < 3 else ret if len(ret) > 1 else ret.pop()", "def longest_comb(a, cmd):\n    r = comb(a, {'>>':lambda x,y: x > y, '<<':lambda x,y: x < y}[cmd.replace(' ','')])\n    r = [e for e in r if len(e) == max([len(k) for k in r] + [3])]\n    return r[0] if len(r) == 1 else r\n    \ndef comb(a, op):\n    return [[e] for e in a] + [[v] + c for i, v in enumerate(a) for c in comb([e for e in a[i:] if op(v, e)], op)]", "from operator import lt,gt\nfrom itertools import combinations as c\ndef longest_comb(a,s):\n    o=lt if s in '< <<' else gt\n    for k in xrange(len(a)-1,2,-1):\n        r=[]\n        for x in c(a,k):\n            if all(o(x[i-1],e) if i else True for i,e in enumerate(x)):\n                r+=[list(x)]\n        if len(r):\n            return r if len(r)>1 else r[0]\n    return []", "from functools import reduce\nfrom itertools import combinations\n\ndef longest_comb(arr,s):\n    f = int.__lt__ if s[0]=='<' else int.__gt__\n    ret = [list(c) for n in range(3,len(arr)) for c in combinations(arr,n) if all(f(c[i],c[i+1]) for i in range(n-1))]\n    m = max(map(len,ret),default=0)\n    ret = [r for r in ret if len(r)==m]\n    return ret if len(ret)!=1 else ret.pop()", "from operator import gt, lt\n\ndef longest_comb(arr, command):\n    cond = lt if command in ('< <', '<<') else gt\n    lst = [[]]\n    for a in arr:\n        u = []\n        for l in lst:\n            if not l:\n                u.append([a])\n            else:\n                if cond(l[-1], a):\n                    u.append(l + [a])\n            u.append(l)\n        lst = u\n    m_len = max(len(max(lst, key=len)), 3)\n    ans = [l for l in lst if len(l) == m_len]\n    return ans[0] if len(ans) == 1 else ans", "from itertools import combinations\ndef longest_comb(arr, command):\n    reverse=True if command[0]=='>' else False\n    if arr==sorted(arr,reverse=reverse) and len(arr)==len(set(arr)):\n        return arr\n    n=len(arr)-1\n    while(n>2):\n        r=[]\n        for c in combinations(range(0,len(arr)),n):\n            a=[arr[i] for i in c]\n            if a==sorted(a,reverse=reverse) and len(a)==len(set(a)):\n                r.append(a)\n        if len(r)==1:\n            return r[0]\n        elif len(r)>1:\n            return r\n        n-=1\n    return []", "def longest_comb(arr, sign):\n    comb=lambda p:[[(p,arr[p]),(p+j+1, i)] for j,i in enumerate(arr[p+1:]) if [arr[p]>i,arr[p]<i]['<'in sign]]\n    m = []\n    for i, j in enumerate(arr):\n        r = comb(i)\n        for k, l in enumerate(r):\n            inner = comb(l[-1][0])\n            if inner : r[k].append(inner.pop()[-1])\n            if inner:\n                for n in inner : r.append(r[k][:-1] + [tuple(n[-1])])\n        m.extend(r)\n    l = len(max(m, key=len))\n    r = list(map(lambda x: list(map(lambda x: x[1], x)), sorted([i for i in m if len(i) == l], key=lambda x: [i[0] for i in x])))\n    return (r if len(r)>1 else r[0]) if l > 2 else []", "def get_combos(arr, comm):\n\n    if len(arr) == 1:\n        return [arr]\n\n    comm = comm.replace(' ', '')\n    sublists = get_combos(arr[:-1], comm)\n    newlists = []\n    for sublist in sublists:\n        if (comm == '>>' and arr[-1] < sublist[-1]) or (comm == '<<' and arr[-1] > sublist[-1]):\n            newlists.append(sublist+[arr[-1]])\n        newlists.append(sublist)\n    newlists.append([arr[-1]])\n    return newlists\n    \ndef longest_comb(arr, comm):\n\n    combos = get_combos(arr, comm)\n    max_length = 3\n    longest_combos = []\n    for combo in combos:\n        if len(combo) == max_length:\n            longest_combos.append(combo)\n        elif len(combo) > max_length:\n            max_length = len(combo)\n            longest_combos = [combo]\n    \n    if len(longest_combos) == 1:\n        return longest_combos[0]\n    else:\n        return longest_combos\n        \n    \n\n", "from itertools import combinations\n\ndef longest_comb(arr, command):\n    inc, mx, res = command.replace(' ', '') == '<<', 0, []\n    for k in range(len(arr), 2, -1):\n        if k < mx: break\n        for comb in combinations(arr, k): \n            if (inc and all(a < b for a, b in zip(comb, comb[1:]))) or (not inc and all(a > b for a, b in zip(comb, comb[1:]))):\n                if k > mx: \n                    res = [list(comb)]\n                    mx = k\n                elif k == mx: \n                    res.append(list(comb))\n    return res[0] if len(res) == 1 else res"]