["def n_closestPairs_tonum(upper_lim, k):\n    square_lim = int((2 * upper_lim) ** .5) + 1\n    squares = [n*n for n in range(1, square_lim)]\n    p, s = [], set(squares)\n    for m in range(upper_lim - 1, 1, -1):\n        for b in squares:\n            if b >= m: break\n            if 2*m - b in s:\n                p.append([m, m - b])\n                if len(p) == k: return p", "def n_closestPairs_tonum(n, k):\n    found = []\n    for number in range(n-1, 1, -1):\n        i, limit = 1, int(number ** .5)\n        while i <= limit and len(found) < k:\n            sq = i * i\n            diff = number - sq\n            sq1 = (number + diff) ** .5\n            if sq1.is_integer() and diff:\n                found.append([number, diff])\n            i += 1\n        if len(found) == k : break\n    return found", "from itertools import combinations\nfrom operator import itemgetter\nfrom bisect import bisect_left\n\n# 600 is too low but 700 works, so let's use this\nsquares = [i*i for i in range(1, 666)]\nbuild = sorted([(x+y)>>1, (x-y)>>1] for y,x in combinations(squares, 2) if x&1 == y&1)\nsearch = list(map(itemgetter(0), build))\n\n# Down to about 7sec total\ndef n_closestPairs_tonum(num, k):\n    n = bisect_left(search, num) - 1\n    return build[n:n-k:-1]", "def n_closestPairs_tonum(n, k):\n    a = [i**2 for i in range(1, int((2*n)**0.5)+1)]\n    res = [[(s1+s2)/2, (s2-s1)/2] for i, s1 in enumerate(a) for s2 in a[i+1:] if s1+s2<2*n and (s1+s2)%2==0]\n    return sorted(res, key=lambda sl: (-sl[0], -sl[1]))[:k]", "def n_closestPairs_tonum(upper_lim, k):\n    solution = []\n    count = 0\n    for i in range(upper_lim - 1, 1, -1):\n        second_num = i\n        square_num = 1\n        while True:\n            second_num = i - (square_num ** 2)\n            if second_num <= 0:\n                break\n            elif ((second_num + i) ** 0.5).is_integer():\n                solution.append([i, second_num])\n                count += 1\n                if count ==k:\n                    return solution\n            square_num += 1\n", "def n_closestPairs_tonum(num, k):\n    #m+n=p**2\n    #m-n=q**2 => n=m-q**2\n    result = []\n    for m in range(num-1,1,-1):\n        for q in range(1,int(m**.5)):\n            n=m-q**2\n            if int((m+n)**.5)**2 == m+n:\n                result.append([m, n])\n                if len(result)==k:\n                    return result\n    return result", "def n_closestPairs_tonum(num, k):\n    r = []\n    for a in range(int((2 * num - 2) ** 0.5), 1, -1):\n        for b in range(min(int((a * a - 1) ** 0.5), int((2 * num - 2 - a * a) ** 0.5)), 0, -1):\n            if a % 2 == b % 2:\n                r.append([a ** 2 + b ** 2 >> 1, a ** 2 - b ** 2 >> 1])\n    return sorted(r, reverse=True)[:k]", "from math import sqrt\n\ndef n_closestPairs_tonum(num, k):\n    # m+n = A^2 , m-n = B^2 ,then m = (A^2+B^2)/2 , n =(A^2-B^2)/2\n    # A <= int(sqrt(num*2-1))\n    bound = int(sqrt(num*2-1))\n    odd_sol = []\n    even_sol = []\n    if bound % 2 ==1:\n        A_square_odd = [i*i for i in list(range(1,bound+1,2))[::-1] ]\n        A_square_even = [i*i for i in list(range(2,bound,2))[::-1] ] \n    else:\n        A_square_odd = [i*i for i in list(range(1,bound,2))[::-1] ]\n        A_square_even = [i*i for i in list(range(2,bound+1,2))[::-1] ] \n    for A_square in A_square_odd:\n        for B_square in A_square_odd:\n            if len(odd_sol)==num//2:\n                break\n            if (A_square+B_square)//2<num and (A_square-B_square)//2>0:\n                odd_sol.append([(A_square+B_square)//2,(A_square-B_square)//2])\n        if len(odd_sol)==num//2:\n            break\n    for A_square in A_square_even:\n        for B_square in A_square_even:\n            if len(even_sol)==num//2:\n                break\n            if (A_square+B_square)//2<num and (A_square-B_square)//2>0:\n                even_sol.append([(A_square+B_square)//2,(A_square-B_square)//2])\n        if len(even_sol)==num//2:\n            break\n\n    ans_li = odd_sol + even_sol\n    ans_li.sort(reverse=True)\n    return ans_li[:k]", "def n_closestPairs_tonum(num, k):\n    r=[]\n    m=2\n    while(m*m<num):\n        for n in range(1,m):\n            if (m*m+n*n>=num):\n                break\n            r.append([m*m+n*n,2*m*n])\n        m+=1\n    return sorted(r,reverse=True)[:k]", "def n_closestPairs_tonum(num, k):\n    result = []\n    squares = []\n    for i in range(1, (int)((2 * num) ** 0.5) + 2):\n        squares.append(i ** 2)\n    squares.reverse()\n    for i in range(1, num):\n        m = num - i\n        np = []\n        for s in squares:\n            if s > m:\n                np.append(s - m)\n            else:\n                break\n        for n in np:\n            if (m - n) in squares:\n                result.append([m, n])\n                if len(result) == k:\n                    return result"]