["sum_dig = lambda n, D={str(d): d*d for d in range(10)}: sum(map(D.get, str(n)))\nis_happy = lambda n: n > 4 and is_happy(sum_dig(n)) or n == 1\n\nhappy_set = set(filter(is_happy, range(100)))\nfor n in range(100, 3 * 10 ** 5):\n    if sum_dig(n) in happy_set: happy_set.add(n)\n\nfrom bisect import bisect\ndef performant_numbers(n, happy_list=sorted(happy_set)): return happy_list[:bisect(happy_list, n)]", "def is_happy(n):\n    while n > 4:\n        n = sum((d - 48)**2 for d in str(n).encode())\n    return n == 1\n\nhappy = list(filter(is_happy, range(3 * 10 ** 5)))\n\nfrom bisect import bisect_right\ndef performant_numbers(n):\n    return happy[:bisect_right(happy, n)]", "F = [2,4,16,37,58,89,145,42,20]\n\nfrom bisect import bisect\n\ndef f(n):\n    for i in range(50):\n        n = sum(int(i)**2 for i in str(n))\n        if n in F:\n            return False\n        if n == 1:\n            return True\n\nH = [i for i in range(1,300000) if f(i)]\n\ndef performant_numbers(n):\n    return H[:bisect(H, n)]", "# generate happy numbers up to LIMIT\nLIMIT = 300000\nHAPPY, SAD = set(), set()\n\nfor n in range(1, LIMIT+1):\n    seen = set()\n    while True:\n        seen.add(n)\n        n = sum( d*d for d in map(int, str(n)) )\n        \n        if n == 1 or n in HAPPY:\n            HAPPY |= seen\n            break\n        elif n in seen or n in SAD:\n            SAD |= seen\n            break\n\nHAPPY = sorted(HAPPY)\n\n\nfrom bisect import bisect\n\ndef performant_numbers(n):\n    return HAPPY[:bisect(HAPPY, n)]", "b = [False]\na = []\na2 = [None]\n\ndef f(n):\n    def is_happy(n):\n        s = {n}\n        while n != 1:\n            nn = 0\n            while n > 0: nn += (n%10)**2; n//=10\n            n = nn\n            if n < len(b): return b[n]\n            if n in s: return False\n            s.add(n)\n        return True\n    for k in range(1, n+1):\n        b.append(is_happy(k))\n        if b[k]: a.append(k)\n        a2.append(len(a))\nf(300000)\n\ndef performant_numbers(n):\n    return a[:a2[n]]", "from bisect import bisect\n\nLIMIT = 1 + 300000\nhappySieve = [None] * LIMIT\nhappySieve[1] = 1\n    \ndef happyOnes(n):\n    seen = set()\n    while 1:\n        if happySieve[n] is not None: return happySieve[n], seen\n        if n in seen or n == 1:  return n==1, seen\n        seen.add(n)\n        n = sum( int(d)**2 for d in str(n) )\n    \n\nfor n in range(1,LIMIT):\n    isH, seen = happyOnes(n)\n    for x in seen: happySieve[x] = isH\n\nHAPPY = [i for i in range(1,LIMIT) if happySieve[i]]\n\ndef performant_numbers(n): return HAPPY[:bisect(HAPPY,n)]", "from bisect import bisect\n\ndef happy_numbers(n):\n    happy_list = []\n    happy = {1}\n    unhappy = set()\n    for k in range(1, n+1):\n        i = k\n        seen = set()\n        while True:\n            if i in happy:\n                happy_list.append(k)\n                happy |= seen\n                break\n            elif i in unhappy or i in seen:\n                unhappy |= seen\n                break\n            seen.add(i)\n            i = sum(int(d)**2 for d in str(i))\n    return happy_list\n\nhappy_list = happy_numbers(300000)\n\ndef performant_numbers(n):\n    i = bisect(happy_list, n)\n    return happy_list[:i]", "from bisect import bisect\n\nsieve = [None] * 300001\n\ndef is_happy(n):\n    seen = set()\n    while True:\n        if sieve[n] is not None:\n            return sieve[n], seen\n            \n        if n == 1:\n            break\n        elif n < 7:\n            return False, seen\n        seen.add(n)\n        n = sum(int(x)**2 for x in str(n))\n\n    return True, seen\n\n\nfor i in range(1, 300000+1):\n    state, seen = is_happy(i)\n    for x in seen:\n        sieve[x] = state\n\n\nFINAL = [1] + [idx for idx in range(1,300001) if sieve[idx]]\n\ndef performant_numbers(n):\n    first = 0\n    last = len(FINAL)-1\n    idx = float('inf')\n\n    while first <= last:\n        mid = (first+last)//2\n\n        if n == FINAL[mid]:\n            idx = mid+1\n            break\n        \n        elif n < FINAL[mid]:\n            idx = mid\n            last = mid - 1\n        \n        else:\n            first = mid + 1\n        \n    return FINAL[:idx]\n"]