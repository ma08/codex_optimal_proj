["class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         stack = []\n         dict = {\"]\":\"[\", \"}\":\"{\", \")\":\"(\"}\n         \n         for i in s:\n             if i in dict.values():\n                 stack.append(i)\n             elif i in dict.keys():\n                 if stack == [] or dict[i] != stack.pop():\n                     return False\n             else:\n                 return False\n         return not stack", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         stack, lookup = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n         for parenthese in s:\n             #print(parenthese)\n             if parenthese in lookup.keys():\n                 stack.append(parenthese)\n             elif len(stack) == 0 or lookup[stack.pop()] != parenthese:\n                 return False\n             #print(stack)\n         return len(stack) == 0", "class Solution:\n     \n     import re\n     \n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         \n         while(s!=\"\"):\n             len_orig = len(s)\n             s = s.replace('()', '')\n             s = s.replace('[]', '')\n             s = s.replace('{}', '')\n             if len(s) == len_orig:\n                 return False\n     \n         return True\n             \n", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         l=list(s)\n         stack=[]\n         if l[0]==\")\" or l[0]==\"]\" or l[0]==\"}\" or len(l)<2:\n             return False\n         else:\n             stack.append(l[0])\n             l=l[1:]\n         while stack!=[] or l!=[]:\n             if l==[]:\n                 return False\n             else:\n                 if l[0]==\"(\" or l[0]==\"[\" or l[0]==\"{\":\n                     stack.append(l[0])\n                 else:\n                     if stack==[]:\n                         return False\n                     elif stack[-1]==\"(\" and l[0]==\")\":\n                         stack.pop()\n                     elif stack[-1]==\"[\" and l[0]==\"]\":\n                         stack.pop()\n                     elif stack[-1]==\"{\" and l[0]==\"}\":\n                         stack.pop()\n                     else:\n                         return False\n                 l=l[1:]\n \n \n         return True", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         correct = ['()', '[]', '{}']\n         out = \"\"\n         a = s\n         while self.contains(a, correct):\n             for sym in correct: \n                 a = a.replace(sym, '')\n         if len(a)==0:\n             return True\n         else: \n             return False\n         \n     def contains(self, st, chars):\n         for ch in chars: \n             if ch in st: \n                 return True \n         return False\n", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         if len(s)==0:return True\n         stack=[]\n         for i in s:\n             if i=='(' or i=='{'or i=='[':\n                 stack.append(i)\n             else:\n                 if len(stack)==0:return False\n                 j=stack.pop()\n                 if (j=='('and i!=')')or(j=='['and i!=']')or(j=='{'and i!='}'):\n                     return False\n         return len(stack)==0\n", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         if len(s)%2 != 0:\n             return(False)\n         \n         stack=[]\n         for i in range(len(s)):\n             stack.append(s[i])\n             if stack[0] == ')' or stack[0] == ']' or stack[0] == '}':\n                 return(False)\n             if stack[-1] == ')' :\n                 if stack[-2] =='(':\n                     stack.pop()\n                     stack.pop()\n             elif stack[-1] == ']' :\n                 if stack[-2] =='[':\n                     stack.pop()\n                     stack.pop()\n             elif stack[-1] == '}':\n                 if stack[-2] =='{':\n                     stack.pop()\n                     stack.pop()\n         if stack == []:\n             return(True)\n         else:\n             return(False)", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         lefty = ['(', '{', '[']\n         D = { ')':'(', '}':'{', ']':'[' }\n         L = []\n         for b in s:\n             if b in lefty:\n                 L.append(b)\n             else:\n                 if len(L)==0 or D[b]!=L.pop():\n                     return False\n         if len(L)!=0:\n             return False\n         else:\n             return True\n", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         \n         # ###method1\n         # while  \"()\" in s or \"[]\" in s or \"{}\" in s:\n         #     s = s.replace(\"()\",\"\").replace(\"[]\",\"\").replace(\"{}\",\"\")\n         # return len(s)==0\n         \n         stack = []\n         dict = {\")\":\"(\", \"]\":\"[\", \"}\":\"{\"}\n         for char in s:\n             if char in list(dict.values()):\n                 stack.append(char)\n             elif char in list(dict.keys()):\n                 if stack==[] or dict[char] != stack.pop():\n                     return False\n             else:\n                 return False\n         return stack==[]\n     \n  \n", "class Solution:\n     \n     # stack approach\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n \n         open_chars = set(['(', '[', '{'])\n \n         # matching open char for given closing char\n         open_match = {')':'(', ']':'[', '}':'{'}\n \n         # open chars found in input with no matching\n         # closing char yet\n         open_stack = []\n \n         for ch in s:\n \n             if ch in open_chars:\n \n                 open_stack.append(ch)\n \n             else:\n \n                 if not open_stack \\\n                     or open_stack[-1] != open_match[ch]:\n \n                     return False\n \n                 open_stack.pop()\n \n         return not open_stack\n", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         while  \"()\" in s or \"[]\" in s or \"{}\" in s:\n             s = s.replace(\"()\",\"\").replace(\"[]\",\"\").replace(\"{}\",\"\")\n         return len(s)==0\n", "class Solution:\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n         n = len(s)\n         if n == 0:\n             return True\n         \n         if n % 2 != 0:\n             return False\n             \n         while '()' in s or '{}' in s or '[]' in s:\n             s = s.replace('{}','').replace('()','').replace('[]','')\n         \n         if s == '':\n             return True\n         else:\n             return False", "class Solution:\n     def isValid(self, s):\n         while '()' in s or '{}' in s or '[]' in s:\n             s = s.replace('{}','').replace('()','').replace('[]','')\n         \n         if s == '':\n             return True\n         else:\n             return False\n             \n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n", "class Solution:\n     \n     # stack approach\n     def isValid(self, s):\n         \"\"\"\n         :type s: str\n         :rtype: bool\n         \"\"\"\n \n         open_chars = set(['(', '[', '{'])\n \n         # matching open char for given closing char\n         open_match = {')':'(', ']':'[', '}':'{'}\n \n         # open chars found in input with no matching\n         # closing char yet\n         open_stack = []\n \n         for ch in s:\n \n             if ch in open_chars:\n \n                 open_stack.append(ch)\n \n             else:\n \n                 if not open_stack \\\n                     or open_stack[-1] != open_match[ch]:\n \n                     return False\n \n                 open_stack.pop()\n \n         return not open_stack\n"]