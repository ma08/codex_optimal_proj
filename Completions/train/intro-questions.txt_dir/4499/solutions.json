["e = [1, 2]\nfor n in range(1, 10 ** 4):\n    for f in 1, 2 * n, 1:\n        e.append(f * e[-1] + e[-2])\nconvergents_of_e = lambda n: sum(map(int, str(e[n])))", "def convergents_of_e(n):\n    def b(n):\n        return n // 3 * 2 if n % 3 == 0 else 1\n    x, y = b(n), 1\n    for k in range(n - 1, 0, -1):\n        x, y = b(k) * x + y, x\n    return sum(int(d) for d in str(x + y))", "def fracte():\n    yield 2\n    i=2\n    while True:\n        yield 1\n        yield i\n        yield 1\n        i+=2        \ndef convergents_of_e(n):\n    fe=fracte()\n    an=[next(fe) for f in range(n)]\n    n,d=1,an.pop()\n    while an:d,n=(d*an.pop()+n),d\n    return sum(map(int,str(d)))", "import itertools\nfrom fractions import Fraction as F\nimport functools\n\ndef convergents_of_e(n):\n    print(n)\n    \n    for i in range(200,n,200): h(cont_e_2, i) # recursion depth error prevent by precalculating\n    \n    return sum_dig(h(cont_e_2, n-1))\n    \ndef sum_dig(n):\n    return sum(map(int, str(n)))\n    \ndef cont_e():\n    for i in [2,1,2]: yield i\n    for i in itertools.count(start=2):\n        yield 1\n        yield 1\n        yield 2*i\n\n@functools.lru_cache(None)      \ndef cont_e_2(n):\n    if n==0: return 2\n    if n%3 == 2: return ((n+1)*2)//3\n    return 1\n    \n\n@functools.lru_cache(maxsize=None)\ndef h(func, n):\n    # source: https://en.wikipedia.org/wiki/Continued_fraction#Some_useful_theorems\n    a = func(n)\n    if n<0:\n        val = 2+n\n    else:\n        val =  a*h(func, n-1) + h(func, n-2)\n    return val\n", "import math\n\n \na_vals = [2]\n\n\nfor i in range(2,50000): \n    if i % 3 != 0:\n        a_vals.append(1)\n    else:\n        a_vals.append(int(i/3)*2)\nh_vals = [0,1]\nfor s in a_vals:\n    h = s*h_vals[-1] + h_vals[-2]\n    h_vals.append(h)\n\n\n\ndef convergents_of_e(n):\n    \n    \n\n    \n    output = sum([int(x) for x in str(h_vals[n+1])])\n    print(output)\n    return(output)\n    \n    \n\n", "def convergents_of_e(n):\n    a0, a1, i = 1, 2, 2\n    \n    while i <= n: \n        f =  1 if i % 3 else 2 * i // 3\n    \n        a = a0 + a1 * f\n        a0, a1 = a1, a\n        i += 1\n    \n    return sum(map(int, str(a1)))", "\ndef convergents_of_e(n):\n    \n    n0, n1, L = 1, 2, n\n    for i in range(2, n + 1):\n        if i % 3 != 0:\n            m = 1\n        else:\n            m = 2 * i // 3\n        n0, n1 = n1, n0 + n1 * m\n    return sum((int(i) for i in str(n1)))", "\ndef convergents_of_e(m):\n    old=2\n    new=3\n    for i in range(3,m+1):\n        temp = old\n        old = new\n        if i % 3 == 0:\n            new = old*((i // 3) * 2) + temp\n        else:\n            new = old*1+ temp\n\n    new=[int(i) for i in str(new)]\n    s=sum(new)\n    \n    return s", "from fractions import gcd\n\ndef convergents_of_e(n):\n    def b(n):\n        return n // 3 * 2 if n % 3 == 0 else 1\n    x, y = b(n), 1\n    for k in range(n - 1, 0, -1):\n        x, y = b(k) * x + y, x\n    x = (x + y) // gcd(x + y, x)\n    return sum(int(d) for d in str(x))\n", "def e_coeffs(n):\n    def gen():\n        i = 1\n        while True:\n            yield 1\n            yield 2*i\n            i += 1\n            yield 1\n    x = gen()\n    return [next(x) for _ in range(n)]\n\ndef convergents_of_e(n):\n    if n <= 1: return 2\n    xs = e_coeffs(n - 1)\n    xs.reverse()\n    p, q = 1, xs[0]\n    for x in xs[1:]:\n        p, q = q, x * q + p\n    return sum(int(x) for x in str(2*q+p))\n"]