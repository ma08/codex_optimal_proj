["def square_sums_row(n):\n\n    def dfs():\n        if not inp: yield res\n        for v in tuple(inp):\n            if not res or not ((res[-1]+v)**.5 % 1):\n                res.append(v)\n                inp.discard(v)\n                yield from dfs()\n                inp.add(res.pop())\n\n    inp, res = set(range(1,n+1)), []\n    return next(dfs(), False)", "def square_sums_row(n):\n    r=[]\n    def dfs(r):\n        if len(r)==n:return 1\n        for i in range(1,n+1):\n            if not len(r) or (i not in r and not(i+r[-1])**.5%1):\n                r.append(i)\n                if dfs(r):return 1\n                r.pop()\n        return 0\n    return r if dfs(r) else 0", "# ==========================================================================================================================================\n# title         : squares, v2: faster with dictionnary instead of graph\n# description   :\n# author        : JR\n# date          : 28.04.20\n# version       :\n# IDE           : PyCharm\n# ==========================================================================================================================================\nimport math\n\n# code standard graphs (dirty-duct-copy networkx behavior)\nclass nx(dict):\n    @staticmethod\n    def empty_graph(nodes):\n        return nx(nodes)\n\n    @staticmethod\n    def squares_graph(n=23):\n        square_candidates = [(x+1)**2 for x in range(1, math.floor(math.sqrt(2*n-1)))]\n        G = nx.empty_graph(list(range(1, n+1)))\n\n        for s in square_candidates:\n            true_indexes = [x for x in range(1, 1+math.floor((s-1) / 2)) if s-x <= n]\n            for k in true_indexes:\n                G.add_edge(k, s-k)\n\n        return G\n\n    @staticmethod\n    def Graph(G):\n    # here we will implement the by-copy\n        return nx(G.copy())\n\n    def __init__(self, nodes, edges=None):\n        if edges is None:\n            if isinstance(nodes, dict):\n                # by-copy => this one should not really be used for our problem, but it is simpler at the beginning to be able to concentrate\n                # on the central matter\n                dict.__init__(self, {n: e.copy() for n,e in list(nodes.items())})\n            else:\n                dict.__init__(self, {n: set() for n in nodes})\n        else:\n            dict.__init__(self, {nodes[i]: edges[i] for i in range(len(nodes))})\n\n    def add_edge(self, x, y):\n        self[x] |= {y}\n        self[y] |= {x}\n\n    def remove_edge(self, x, y):\n        self[x] -= {y}\n        self[y] -= {x}\n\n    def remove_node(self, n):\n        edges = self[n].copy()\n        for e in edges:\n            self.remove_edge(n, e)\n\n        del self[n]\n\n    def display(self):\n        import matplotlib.pyplot as plt\n        import networkx as true_nx\n        plt.clf()\n        true_nx.draw(true_nx.Graph(G), labels={x: x for x in G.nodes})\n        plt.show()\n\n    @property\n    def nodes(self):\n        return list(self.keys())\n\n    @property\n    def degree(self):\n        return {(n, len(e)) for n, e in list(self.items())}\n\n\ndef square_sums_row(n):\n    return dfs_travel(n)\n\n\ndef dfs_travel(G=23, visit_ordered=None, N=None, display=False, verbose=False):\n    if isinstance(G, int):\n        G = nx.squares_graph(G)\n\n    if N is None:\n        N = len(G.nodes)\n\n    if visit_ordered is None:\n        visit_ordered = []\n\n    if len(visit_ordered) == N:\n        if verbose:\n            print('SUCCESS')\n        return visit_ordered\n\n    impossible_nodes = [n for n, d in G.degree if d == 0]\n    if len(impossible_nodes) > 0:\n        return False\n    ending_nodes = [n for n, d in G.degree if d == 1]\n\n    if len(ending_nodes) > 2:\n        return False\n\n    if len(visit_ordered) == 0:\n\n        # We do the best guess to visit nodes by random... starting by most certain ones\n        if len(ending_nodes) > 0:\n            if verbose:\n                print('Guess zero')\n            return dfs_travel(G, [ending_nodes[-1]], N, verbose=verbose)  # if two, it will arrive at the second node !\n\n        degrees = G.degree\n        max_degree = max([y for x, y in degrees])\n        for d in range(2, max_degree+1):\n            for n in [nd for nd, deg in degrees if deg == d]:\n                sol = dfs_travel(G, [n], verbose=verbose)\n                if sol != False:  # don't want the unsafe \"if sol\" with list\n                    if verbose:\n                        print('YESSS')\n                    return sol\n\n        if verbose:\n            print('Exhausted guesses')\n        return False\n\n    elif len(ending_nodes) == 2 and not visit_ordered[-1] in ending_nodes:\n        return False\n\n    G2 = nx.Graph(G)  # copy the graph... will need to improve if >100 graphs are needed !\n\n    last_idx = visit_ordered[-1]\n    for current_idx in G2[last_idx]: #.keys():\n        if verbose:\n            print((last_idx, current_idx))\n        visit_ordered.append(current_idx)\n        if verbose:\n            print(visit_ordered)\n        G3 = nx.Graph(G2)\n        G3.remove_node(last_idx)\n        sol = dfs_travel(G3, visit_ordered, N, verbose=verbose)\n\n        if sol != False:\n            return visit_ordered\n\n        visit_ordered.pop()\n    if verbose:\n        print(visit_ordered)\n        print((len(visit_ordered) - N))\n    return False\n", "def square_sums_row(n):\n    def dfs():\n        if not n: yield r\n        for p in tuple(n):\n            if not r or not ((r[-1]+p)**.5 % 1):\n                r.append(p)\n                n.discard(p)\n                yield from dfs()\n                n.add(r.pop())\n    n, r = set(range(1,n+1)), []\n    return next(dfs(), False)", "squares = {x**2 for x in range(10)}\n\ndef square_sums_row(n):\n    def rec(x, L):\n        if not L:\n            return x and [x]\n        for i,y in enumerate(L):\n            if x==0 or x+y in squares:\n                test = rec(y, L[:i]+L[i+1:])\n                if test:\n                    return (x and [x] or []) + test\n        return False\n    return rec(0, list(range(1, n+1)))", "from math import sqrt\n\nclass Graph:\n    def __init__(self, connections):\n        self.n = len(connections)\n        self.connections = connections\n        self.adjacency_matrix = [[0] * (self.n) for _ in range(self.n)]\n\n        for i, j in enumerate(self.connections):\n            for k in j:\n                self.adjacency_matrix[i][k - 1] = 1\n\n    def hamilton(self):\n        for i in range(self.n):\n            visited = [False] * self.n\n            path = []\n\n            def _hamilton(curr):\n                path.append(curr)\n                if len(path) == self.n:\n                    return True\n\n                visited[curr] = True\n                for next in range(self.n):\n                    if self.adjacency_matrix[curr][next] == 1 and not visited[next]:\n                        if _hamilton(next):\n                            return True\n                visited[curr] = False\n                path.pop()\n                return False\n\n            if _hamilton(i):\n                return [n + 1 for n in path]\n\n        return False\n\ndef square_sums_row(n):\n    connections = []\n    temp = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if sqrt(i + j).is_integer():\n                temp.append(j)\n        connections.append([*temp])\n        temp.clear()\n\n    g = Graph(connections)\n    return g.hamilton()\n", "ans = [0 for i in range(44)]\nhash1 = [False for i in range(44)]\n\ndef Dfs(num, cnt):\n\n    if(num == cnt):\n        return True\n\n    for i in range(1, cnt + 1):\n        if not hash1[i] and (not((i + ans[num])**0.5%1)):\n            ans[num + 1] = i\n            hash1[i] = True\n            if Dfs(num + 1, cnt): return True\n            hash1[i] = False\n    return False\n\n\ndef square_sums_row(n):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            hash1[j] = False\n        ans[1] = i\n        hash1[i] = True\n        if Dfs(1, n):\n            return ans[1: n + 1]\n\n    return False", "def square_sums_row(n):\n    solutions = {\n    15: [9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8],\n    16: [16, 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8],\n    17: [16, 9, 7, 2, 14, 11, 5, 4, 12, 13, 3, 6, 10, 15, 1, 8, 17],\n    30: [18, 7, 29, 20, 16, 9, 27, 22, 14, 2, 23, 26, 10, 6, 30, 19, 17, 8, 28, 21, 4, 5, 11, 25, 24, 12, 13, 3, 1, 15],\n    31: [31, 18, 7, 29, 20, 16, 9, 27, 22, 14, 2, 23, 26, 10, 6, 30, 19, 17, 8, 28, 21, 4, 5, 11, 25, 24, 12, 13, 3, 1, 15],\n    32: [1, 8, 28, 21, 4, 32, 17, 19, 30, 6, 3, 13, 12, 24, 25, 11, 5, 31, 18, 7, 29, 20, 16, 9, 27, 22, 14, 2, 23, 26, 10, 15],\n    33: [2, 23, 26, 10, 6, 30, 19, 17, 8, 28, 21, 15, 1, 3, 13, 12, 24, 25, 11, 14, 22, 27, 9, 16, 33, 31, 18, 7, 29, 20, 5, 4, 32],\n    34: [1, 8, 17, 32, 4, 5, 11, 25, 24, 12, 13, 3, 33, 31, 18, 7, 29, 20, 16, 9, 27, 22, 14, 2, 23, 26, 10, 6, 19, 30, 34, 15, 21, 28],\n    35: [1, 3, 6, 19, 30, 34, 2, 7, 18, 31, 33, 16, 9, 27, 22, 14, 11, 25, 24, 12, 13, 23, 26, 10, 15, 21, 28, 8, 17, 32, 4, 5, 20, 29, 35],\n    36: [1, 3, 6, 10, 26, 23, 2, 7, 18, 31, 33, 16, 9, 27, 22, 14, 35, 29, 20, 5, 11, 25, 24, 12, 13, 36, 28, 8, 17, 19, 30, 34, 15, 21, 4, 32],\n    37: [1, 3, 13, 36, 28, 8, 17, 32, 4, 21, 15, 34, 30, 19, 6, 10, 26, 23, 2, 7, 18, 31, 33, 16, 9, 27, 22, 14, 35, 29, 20, 5, 11, 25, 24, 12, 37]}\n    \n    return solutions[n] if n in solutions else False", "def square_sums_row(n):\n    stack = [ (set(range(1, n+1)), []) ]\n\n    while stack:\n        existing_nums, out = stack.pop()\n        if len(out) == n:\n            return out\n        \n        for num in existing_nums:\n            if not out or not ((num+out[-1])**.5)%1:\n                stack.append( (existing_nums-{num}, out+[num]) )\n\n    return False"]