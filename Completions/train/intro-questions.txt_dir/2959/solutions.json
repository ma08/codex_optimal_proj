["from functools import lru_cache\n\n\ndef optimal_number_of_coins(n, coins):\n    @lru_cache(maxsize=None)\n    def f(amount: int, idx: int) -> float:\n        q, r = divmod(amount, coins[idx])\n        if r == 0:\n            return q\n        elif amount < 0 or idx <= 0:\n            return float(\"inf\")\n        else:\n            return min(1 + f(amount - coins[idx], idx), f(amount, idx - 1))\n\n    coins = sorted(set(coins))\n    return f(n, len(coins) - 1)", "def optimal_number_of_coins(n, coins):\n    s = [0]*(n+1)\n    for c in coins:\n        if c<=n: s[c]=1\n    for i in range(n+1): s[i]=min((s[i-v]+1 for v in coins if i-v>=0),default=0)\n    return s[n]", "def optimal_number_of_coins(n,coins):\n    dicto = {}\n    def optimal_number_of_coinss(n, coins,mino = 0,indo = 0):\n        key = f\"{n}mino:{mino}\"\n        if key in dicto: return dicto[key]\n        if not n: return mino\n        if indo >= len(coins) : return 10000\n        if n < 0: return 100100\n        dicto[key] = min(optimal_number_of_coinss(n - coins[indo],coins,mino + 1,indo) \n                   , optimal_number_of_coinss(n,coins,mino ,indo+1))\n        return dicto[key]\n    return optimal_number_of_coinss(n, coins)", "def optimal_number_of_coins(n,coins):\n    dicto = {}\n    def optimal_number_of_coinss(n, coins,mino = 0,indo = 0):\n        key = f\"{n}indo:{indo}mino:{mino}\"\n        if key in dicto: return dicto[key]\n        if not n: return mino\n        if indo >= len(coins) : return 10000\n        if n < 0: return 100100\n        dicto[key] = min(optimal_number_of_coinss(n - coins[indo],coins,mino + 1,indo) \n                   , optimal_number_of_coinss(n,coins,mino ,indo+1))\n        return dicto[key]\n    return optimal_number_of_coinss(n, coins)", "def optimal_number_of_coins(n,A):\n    D={}\n    for i in range(1,n+1):D[i]=min(-~j+(i+~j*x and D[i+~j*x])for x in A for j in range(i//x))\n    return D[n]", "def optimal_number_of_coins(n,A):\n    D={}\n    for i in range(1,n+1):D[i]=min(j+(i-j*x and D[i-j*x])for x in set(A) for j in range(1,i//x+1))\n    return D[n]", "def optimal_number_of_coins(n, coins):\n    return change_making(coins,n)\n\n\n\n\ndef _get_change_making_matrix(set_of_coins, r: int):\n    m = [[0 for _ in range(r + 1)] for _ in range(len(set_of_coins) + 1)]\n    for i in range(1, r + 1):\n        m[0][i] = float('inf')  # By default there is no way of making change\n    return m\n\ndef change_making(coins, n: int):\n    \"\"\"This function assumes that all coins are available infinitely.\n    n is the number to obtain with the fewest coins.\n    coins is a list or tuple with the available denominations.\n    \"\"\"\n    m = _get_change_making_matrix(coins, n)\n    for c in range(1, len(coins) + 1):\n        for r in range(1, n + 1):\n            # Just use the coin coins[c - 1].\n            if coins[c - 1] == r:\n                m[c][r] = 1\n            # coins[c - 1] cannot be included.\n            # Use the previous solution for making r,\n            # excluding coins[c - 1].\n            elif coins[c - 1] > r:\n                m[c][r] = m[c - 1][r]\n            # coins[c - 1] can be used.\n            # Decide which one of the following solutions is the best:\n            # 1. Using the previous solution for making r (without using coins[c - 1]).\n            # 2. Using the previous solution for making r - coins[c - 1] (without\n            #      using coins[c - 1]) plus this 1 extra coin.\n            else:\n                m[c][r] = min(m[c - 1][r], 1 + m[c][r - coins[c - 1]])\n    return m[-1][-1]", "def optimal_number_of_coins(n, a):\n    q = [float('inf')] * (n+1)\n    q[0] = 0\n    for i in range(1, n+1):\n        q[i] = min(q[i-x]+1 for x in a if x <= i)\n    return q[n]"]