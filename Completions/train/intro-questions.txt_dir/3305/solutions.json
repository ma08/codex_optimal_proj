["import heapq\nfrom collections import defaultdict\n\ndef shortest(N, edge):\n    ver, inf = defaultdict(list), 10**10\n    for e in edge: ver[e[0]].append(e[1:])\n\n    dist = {i:inf for i in range(N)}\n    dist[0], pq = 0, []\n    heapq.heappush(pq, [dist[0], 0])\n    while pq: \n        u_dis, u_node = heapq.heappop(pq)\n        if u_dis == dist[u_node]:\n            for v in ver[u_node]:\n                v_node = v[0]\n                v_wei = v[1]\n                if dist[u_node] + v_wei < dist[v_node]:\n                    dist[v_node] = dist[u_node] + v_wei\n                    heapq.heappush(pq, [dist[v_node], v_node])\n    return -1 if dist[N-1] == inf else dist[N-1]", "def shortest(n, edges):\n    m = [0] + [float('inf')] * (n-1)\n    for start, end, weight in sorted(edges):\n        if m[start] == float('inf'): continue\n        m[end] = min(m[start] + weight, m[end])\n    return -1 if m[-1] == float('inf') else m[-1]", "def shortest(N, edgeList):\n    \n    edgeList.sort(key= lambda x: x[0])\n    path_values = [None for _ in range(N)]\n    path_values[0] = 0\n        \n    for edge in edgeList:\n\n        if path_values[edge[0]] != None: # If the node value is 0, then we can not use it as a base to go further.\n            new_val = edge[2] + path_values[edge[0]]\n        \n            if path_values[edge[1]] == None:\n                path_values[edge[1]] = new_val\n            else:\n                path_values[edge[1]] = min(path_values[edge[1]], new_val)\n    \n    if path_values[-1] == None: # no path goes to the end\n        return -1\n    else:\n        return path_values[-1]", "def shortest(N, edges):\n    \n    path = [0]+[float('inf')]*(N-1)\n    for start,end,weight in sorted(edges):\n        if path[start]==-1: continue\n        path[end] = min(path[start]+weight, path[end] )\n        \n        \n        \n    return -1 if path[-1]==float('inf') else path[-1]", "from collections import defaultdict\n\n\nINFINITY = 2 ** 80\n\n\ndef shortest(N, edgeList):\n    edges = defaultdict(list)\n    for (fro, to, weight) in edgeList:\n        edges[fro].append((to, weight))\n    \n    dist_dp = [INFINITY] * N\n    dist_dp[0] = 0\n    \n    for i in range(N):\n        for (to, w) in edges[i]:\n            dist_dp[to] = min(dist_dp[to], dist_dp[i] + w)\n    \n    return -1 if dist_dp[N - 1] >= INFINITY else dist_dp[N - 1]", "from collections import defaultdict\nfrom heapq import heappop, heappush\nfrom typing import List, Tuple\n\n\ndef shortest(N: int, edgeList: List[Tuple[int, int, int]]) -> int:\n    graph = defaultdict(list)\n    for v, u, e in edgeList:\n        graph[v].append((u, e))\n\n    pathes = defaultdict(lambda: float('inf'), {0: 0})\n\n    queue = [(0, 0)]\n    while queue:\n        cost, v = heappop(queue)\n\n        if v == N - 1:\n            return cost\n\n        for u, e in graph[v]:\n            new_cost = cost + e\n            if new_cost < pathes[u]:\n                pathes[u] = new_cost\n                heappush(queue, (new_cost, u))\n\n    return -1", "def shortest(n, edges):\n    m = [0] + [-1] * (n-1)\n    for start, end, weight in sorted(edges):\n        if m[start] == -1: continue\n        m[end] = min(m[start] + weight,\n                     m[end] == -1 and float('inf') or m[end])\n    return m[-1]", "def shortest(N, es):\n    ee = [[] for _ in range(N)]\n    for f, t, w in es:\n        ee[f].append((t, w))\n    dd = [0x7f7f7f7f for _ in range(N)]\n    f = [False for _ in range(N)]\n    dd[0] = 0\n    q = [0]\n    f[0] = True\n    while len(q) > 0:\n        k = q.pop()\n        f[k] = False\n        for t, w in ee[k]:\n            if dd[t] > dd[k] + w:\n                dd[t] = dd[k] + w\n                if not f[t]:\n                    q.append(t)\n                    f[t] = True\n    return -1 if dd[N - 1] == 0x7f7f7f7f else dd[N - 1]", "def shortest(N, edgeList):\n    import math\n    edgeList.sort(key=lambda x: x[0])\n    path_length = [math.inf for _ in range(N)]\n    path_length[0] = 0\n        \n    for start, end, weight in edgeList:\n#         each edge is written as [start, end, weight] where from < to wi\u0119c to dzia\u0142a, \n#         ale gdyby taki warunek nie by\u0142 prawdziwy to np.\n#         shortest(5, [(0,2,0), (0,3,1), (2,1,0), (3,4,1), (1,4,0)]) zwraca\u0142oby 2, zamiast 0\n        if path_length[start] == math.inf:\n            continue\n        path_length[end] = min(path_length[start] + weight, path_length[end])\n    \n    result = path_length[N-1]\n    return result if result is not math.inf else -1\n\n\n\n\n\n# def shortest(N, edgeList):\n#     import math, heapq, collections\n#     edges = collections.defaultdict(lambda:collections.defaultdict(lambda:math.inf))\n#     path_length = [math.inf for _ in range(N)]\n#     path_length[0] = 0\n#     for start, end, weight in edgeList:\n#         edges[start][end] = min(weight, edges[start][end])\n#     h = [(0,0)]\n#     visited = set()\n#     heapq.heapify(h)\n#     while h:\n#         sum, start = heapq.heappop(h)\n#         if start == N-1: return sum\n#         if start in visited: continue\n#         for end, weight in edges[start].items():\n#             if end in visited: continue\n#             if sum + weight < path_length[end]:\n#                 path_length[end] = sum + weight\n#                 heapq.heappush(h, (sum+weight, end))\n#         visited.add(start)\n#     return -1\n", "from collections import defaultdict\nfrom heapq import *\n\ndef shortest(N, edges):\n    '''Same as def dijkstra(edges, f, t)'''\n    f=0;t=N-1\n    g = defaultdict(list)\n    for l,r,c in edges:\n        g[l].append((c,r))\n\n    q, seen, mins = [(0,f,())], set(), {f: 0}\n    while q:\n        (cost,v1,path) = heappop(q)\n        if v1 not in seen:\n            seen.add(v1)\n            path = (v1, path)\n            if v1 == t: return cost#,path\n\n            for c, v2 in g.get(v1, ()):\n                if v2 in seen: continue\n                prev = mins.get(v2, None)\n                next = cost + c\n                if prev is None or next < prev:\n                    mins[v2] = next\n                    heappush(q, (next, v2, path))\n\n    return -1 #float(\"inf\")"]