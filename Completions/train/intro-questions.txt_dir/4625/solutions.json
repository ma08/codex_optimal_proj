["def processes(start, end, processes):\n  '''Dijkstra's shortest path algorithm'''\n  q = [(start,[])]\n  visited = set()\n  \n  while q:\n      s, path = q.pop(0)\n      if s == end: return path\n      visited.add(s)\n      for p in [x for x in processes if x[1] == s]:\n          if not p[2] in visited:\n              q.append((p[2], path + [p[0]]))\n  return []\n", "from collections import deque\ndef processes(start, end, graph):\n    Q = deque([[i,[]] for i in graph if i[1]==start])\n    visited = set()\n    while Q:\n        (p, s, e), path = Q.popleft()\n        path.append(p)\n        visited.add((s, e))\n        if e == end : return path\n        for k in graph:\n            if k[1] == e and tuple(k[1:]) not in visited : Q.append([k, path[:]])\n    return []", "from collections import defaultdict, deque\n\ndef processes(start, end, processes):\n    D, L, S = defaultdict(dict), deque([(start, [])]), set()\n    for a, b, c in processes: D[b][a] = c\n    while L:\n        current, path = L.pop()\n        if current == end: return path\n        if current not in S:\n            S.add(current)\n            for k,v in D[current].items():\n                L.appendleft((v, path+[k]))\n    return []", "def processes(start, end, processes):\n    if start == end: return []\n    result = check(start, end, processes, [])\n    if result == None: return []\n    return result\n    \ndef check(start, end, processes, result):\n    if start == end: return result\n    results = []\n    for i in processes:\n        if i[1] == start:\n            try:\n                tmp = result.copy()\n                tmp.append(i[0])\n                tmp2 = check(i[2], end, processes, tmp)\n                if tmp2 != None:\n                    results.append(tmp2)\n            except: return None\n    if len(results) > 0: return min(results, key=len)\n    else: return None", "from collections import defaultdict, namedtuple\n\nEdge = namedtuple('Edge', ['process_name', 'to'])\nState = namedtuple('State', ['stack', 'visited', 'min_stack'])\n\ndef dfs(graph, cur_node, end_node, state):\n    if cur_node in state.visited:\n        return\n    if len(state.min_stack) and len(state.stack) >= len(state.min_stack):\n        return\n    if cur_node == end_node:\n        state.min_stack.clear()\n        state.min_stack.extend(state.stack)\n        return\n\n    state.visited.add(cur_node)\n    for process, node in graph[cur_node]:\n        state.stack.append(process)\n        dfs(graph, node, end_node, state)\n        state.stack.pop()\n    state.visited.remove(cur_node)\n\ndef processes(start, end, processes):\n  if start == end:\n      return []\n  graph = defaultdict(list)\n  \n  for process_name, start_node, end_node in processes:\n      graph[start_node].append(Edge(process_name, end_node))\n  \n  state = State([], set(), [])\n  dfs(graph, start, end, state)\n  \n  return state.min_stack", "def processes(start, end, procs):\n    def _p(start, end, procs, re_):\n        for step in procs:\n            res = re_[:]\n            if step[1] == start:\n                res.append(step[0])\n\n                _p(step[2], end, [x for x in procs if x != step], res)\n\n                if step[2] == end:\n                    _p.gres.append(res);\n\n\n    _p.gres = []\n    _p(start, end, procs, [])\n    return min(_p.gres, key=lambda x: len(x)) if _p.gres else []\n", "def processes(start, end, processes):\n  sequences=[[start,[]]]\n  while len(sequences) > 0:\n      k = sequences[0]\n      del sequences[0]\n      node=k[0]\n      path=k[1]\n      if node == end: return path\n      for n in processes:\n          if n[1] == node and n[0] not in path:\n              sequences.append([n[2],path+[n[0]]])\n  return []", "def processes(start, end, processes):\n    pss = []\n    def proc(start, end, ps, l=[]): [pss.append(l + [ps[i][0]]) if ps[i][-1] == end else proc(ps[i][-1], end,  ps[:i] + ps[i+1:], l + [ps[i][0]]) for i in range(len(ps)) if ps[i][1] == start]    \n    return proc(start, end, processes) or (min(pss, key=len) if pss else [])", "from collections import defaultdict\n\ndef processes(start, end, processes):\n    d = defaultdict(list)\n    for process, x, y in processes:\n        d[x].append((y, process))\n    visited, nodes = set(), [(start, [])]\n    while nodes:\n        next = []\n        for node, path in nodes:\n            if node in visited: \n                continue\n            if node == end:\n                return path\n            visited.add(node)\n            for y, process in d[node]:\n                next.append((y, path + [process]))\n        nodes = next\n    return []", "from collections import defaultdict\n\ndef prcs(start, end, procs, path):\n    if start == end:\n        return path\n\n    paths = []\n    try:\n        for p in procs[start]:\n            if p in path:\n                continue\n            paths.append(prcs(p[1], end, procs, path + [p]))\n        return min([a for a in paths if a and a[-1][1] == end], key=len)\n    except (KeyError, ValueError):\n        return []\n    \n\n\ndef processes(start, end, procs):\n    dd = defaultdict(list)\n    for n, s, e in procs:\n        dd[s].append((n, e))\n\n    return [n for n, _ in prcs(start, end, dd, [])]"]