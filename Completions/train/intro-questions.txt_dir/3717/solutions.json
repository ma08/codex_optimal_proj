["def covered_pawns(pawns):\n    pawns = set(pawns)\n    return len({p for p in pawns for x,y in [map(ord, p)] if {chr(x-1)+chr(y-1), chr(x+1)+chr(y-1)} & pawns})", "def covered_pawns(pawns):\n    count = 0\n    for i in range(len(pawns)):\n        x, y = list(pawns[i])\n        if \"\".join([chr(ord(x) - 1), str(int(y) - 1)]) in pawns or \\\n                \"\".join([chr(ord(x) + 1), str(int(y) - 1)]) in pawns:\n            count += 1\n    return count", "def covered_pawns(pawns):\n    return sum(\n        any(chr(ord(c)+delta) + chr(ord(r)-1) in pawns for delta in [-1, 1])\n        for c, r in pawns\n    )", "def covered_pawns(pawns):\n    count = 0\n    pawn_pos = set(pawns)\n    for p in pawns:\n        if p[-1] != \"1\":\n            if any(f\"{chr(ord(p[0]) + i)}{int(p[1]) - 1}\" in pawn_pos for i in (-1, 1)):\n                count += 1\n    return count\n", "letters = {\n    'a': ('b',),\n    'b': ('a', 'c',),\n    'c': ('b', 'd',),\n    'd': ('c', 'e',),\n    'e': ('d', 'f',),\n    'f': ('e', 'g',),\n    'g': ('f', 'h',),\n    'h': ('g',),\n}\n\n\ndef get_cells(pawn):\n    x, y = pawn\n    y = int(y)\n    if y < 8:\n        cells = [letter + str(y + 1) for letter in letters[x]]\n        return cells\n    return []\n\n\ndef covered_pawns(pawns):\n    res = set()\n    pawns = set(pawns)\n    for pawn in pawns:\n        cells = get_cells(pawn)\n        for cell in cells:\n            if cell in pawns:\n                res.add(cell)\n    return len(res)\n", "covered_pawns=lambda p:len(set(p)&set.union(*({chr(ord(c)+b)+chr(ord(r)+1)for b in(-1,1)}for c,r in['  ']+p)))", "def protects(location):\n    \"\"\"Returns the protected spaces (as a set), given a location.\n       Examples:\n          protects('b2') == {'a3', 'c3'}\n          protects('a2') == {'b2'}\n          protects('f8') == set()\n    \"\"\"\n    if location[1] == '8':  return set()\n    row = int(location[1]) + 1\n    col = location[0]\n    if col == 'a':\n        cols = {'b'}\n    elif col == 'h':\n        cols = {'g'}\n    else:\n        cols = {chr(ord(col)-1), chr(ord(col)+1)}\n    return {f'{c}{row}' for c in cols}\n\n\ndef covered_pawns(pawns):\n    protected_spaces = set()\n    for p in pawns:\n        protected_spaces |= protects(p)\n    return len(set(pawns) & protected_spaces)", "import numpy as np\ndef covered_pawns(pawns):\n    n = len(pawns)\n    p = np.zeros(n)\n    for i in range(0,n):\n        for j in range(0,n):\n            if int(pawns[j][1]) == int(pawns[i][1])+1 and abs(ord(pawns[j][0])-ord(pawns[i][0])) == 1:\n                p[j] = 1\n    return sum(p)\n", "def covered_pawns(pawns):\n    board = [[0]*8 for _ in range(8)]\n    for c,r in pawns:\n        board[8 - int(r)][ord(c) - 97] = 1\n    return sum(board[i][j] and (j and board[i+1][j-1] or 7-j and board[i+1][j+1]) for i in range(7) for j in range(8))", "def covered_pawns(pawns):\n    covered = 0\n    for pos in pawns:\n        if chr(ord(pos[0]) + 1) + str(int(pos[1]) - 1) in pawns \\\n            or chr(ord(pos[0]) - 1) + str(int(pos[1]) - 1) in pawns:\n                covered += 1\n    return covered\n"]