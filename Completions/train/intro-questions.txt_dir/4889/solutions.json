["from itertools import cycle,chain\n\ndef max_hexagon_beam(n,seq):\n    h    = 2*n-1\n    seq  = cycle(seq)\n    sums = [ [0]*h for _ in range(3)]            # [horz, diagUp, diagDown]\n    \n    for r in range(h):\n        for c,v in zip(list(range(n+r if r<n else h+n-1-r)),seq):\n            idxs = (r, c+max(0,r-n+1), c+max(0,n-1-r))\n            for i,j in enumerate(idxs): sums[i][j] += v\n            \n    return max(chain.from_iterable(sums))\n", "def max_hexagon_beam(n: int, seq: tuple):\n    \"\"\"Compute maximum sum along \"beams\" of an hexagon\n    \n            _-'-_   _-'-_                 o--- +i\n          .'     '.'     '.               |\n          |0,-1,1 |1,-1,0 |               '\n        _-'-_   _-'-_   _-'-_            +j\n      .'     '.'     '.'     '.     \n      |-1,0,1 | q,r,s | 1,0,-1|     +s         +q\n      '-_   _-'-_   _-'-_   _-'       '-_   _-'\n         '.'     '.'     '.'             'o'\n          |-1,1,0 | 0,1,-1|               |\n          '-_   _-'-_   _-'               '\n             '.'     '.'                 +r\n    \n    hex->grid: i = r+n-1\n               j = q+n-1+min(r,0)\n    \n    grid->hex: r = i+1-n\n               q = j+1-n-min(r,0)\n               s = -q-r\n    \n    beams: 1-n-min(r,0) <= q,s <= n-1-max(r,0)  etc.\n    \"\"\"\n    \n    i = 0\n    grid = []\n    length = len(seq)\n\n    for r in range(1-n, n):\n        grid.append([])\n        for q in range(1-n-min(r,0), n-max(r,0)):\n            grid[r+n-1].append(seq[i % length])\n            i += 1\n    \n    return max((\n        max(sum(grid[r+n-1][q+n-1+min(r,0)] for r in range(1-n-min(q,0), n-max(q,0))) for q in range(1-n, n)),\n        max(sum(grid[r+n-1][-s-r+n-1+min(r,0)] for s in range(1-n-min(r,0), n-max(r,0))) for r in range(1-n, n)),\n        max(sum(grid[-q-s+n-1][q+n-1+min(-q-s,0)] for q in range(1-n-min(s,0), n-max(s,0))) for s in range(1-n, n)),\n    ))", "from itertools import chain, cycle\nfrom collections import defaultdict\n\n\ndef max_hexagon_beam(n: int, seq: tuple):\n    sums = {c: [0] * (2 * n - 1) for c in \"qrs\"}\n    it = cycle(seq)\n    \n    for q in range(-n + 1, n):\n        for r in range(max(-n, -q - n) + 1, min(n, -q + n)):\n            s = -q - r\n            v = next(it)\n            sums['q'][q + n - 1] += v\n            sums['r'][r + n - 1] += v\n            sums['s'][s + n - 1] += v\n\n    return max(chain.from_iterable(list(sums.values())))\n", "from itertools import cycle, zip_longest\n\ndef max_hexagon_beam(n, seq):\n    seq = cycle(seq)\n    hexagon = [[next(seq) for _ in range(2*n-abs(r)-1)] for r in range(1-n,n)]\n    x = list(zip_longest(*([0]*i+r for i, r in enumerate(hexagon, 1-n)), fillvalue=0))\n    y = list(zip_longest(*([0]*-i+r for i, r in enumerate(hexagon, 1-n)), fillvalue=0))\n    return max(map(sum, hexagon + x + y))", "from itertools import cycle\n\ndef max_hexagon_beam(n: int,seq: tuple):\n    l=n*2-1                                  #the number of rows of the hexagon\n    ll =[l-abs(n-i-1) for i in range(l)]     #the lengths of each row\n    c=cycle(seq)\n    hex = [[next(c) for i in range(j)] for j in ll]    # the hexagon\n    sums = [sum(i)for i in hex] # the straight lines\n    for index, i in enumerate(ll):\n        start_row = [0, index%n + 1][index>=n]\n        hex_row=[]\n        hex_row2=[]\n        for j in range(i):\n            y=j+start_row #the y-axis or the row used\n            x=index-[0, y%n + 1][y>=n] # the x-axis or the position in the row.\n            hex_row.append(hex[y][x]) # the line going right-up\n            hex_row2.append(hex[y][-1-x]) # the line going right-down\n        sums +=[sum(hex_row), sum(hex_row2)]\n    sums.sort()\n    return sums[-1]\n    \n# I also considered extending the hexagon with edges of zeros so the x and y would have less possibility to go out of the list.\n    \n            \n", "import numpy as np\nfrom collections import deque\n\ndef max_hexagon_beam(n: int,seq: tuple):\n    max_len = n*2-1\n\n    mat = [0]*max_len**2\n    hexag_1 = np.zeros((max_len, max_len))\n    hexag_2 = np.zeros((max_len, max_len))\n    for i in range(0, len(mat)):\n        mat[i] = seq[i%(len(seq))]\n    \n    for i in range(n):\n        hexag_1[i][0:n+i] = mat[0:n+i]\n        rot = deque(hexag_1[i])\n        rot.rotate(n-i-1)\n        hexag_2[i] = np.array(rot)\n        mat[0:n+i] = []\n\n    j=1\n    for i in range(n, max_len):\n        hexag_1[i][j:] = mat[0:max_len-j]\n        rot = deque(hexag_1[i])\n        rot.rotate(n-i-1)\n        hexag_2[i] = np.array(rot)\n        mat[0:max_len-j] = []\n        j+=1\n\n    horiz = hexag_1.sum(axis=1)\n    diag_1 = hexag_1.sum(axis=0)\n    diag_2 = hexag_2.sum(axis=0)\n\n    a = [max(horiz), max(diag_1), max(diag_2)]\n    return max(a)", "from itertools import cycle\ndef max_hexagon_beam(n: int, seq: tuple):\n    q = cycle(seq)\n    sx, sy, sz = [0] * (2 * n - 1), [0] * (2 * n - 1), [0] * (2 * n - 1)\n    for z in range(-(n - 1), n):\n        xp = -(n-1) if z >= 0 else -(n - 1) - z\n        xk = n-1 if z <= 0 else n - 1 - z\n        for x in range(xp, xk + 1):\n            y = -(z + x)\n            v = next(q)\n            sx[x + n - 1] += v\n            sy[y + n - 1] += v\n            sz[z + n - 1] += v\n    return max(sz + sy + sx)\n", "from itertools import cycle,chain\ndef printhex(b):\n    for x in b:\n        st=' '.join(map(str,x))\n        print(f'{st:^{2*len(b)-1}}')\n\ndef d1sum(b,n,l):\n    d1_sum = []\n    for i in range(l):\n        dsum=0\n        if i+n <= l:\n            k=1\n            for x in range(n+i):\n                if x <n:\n                    dsum+=b[x][i]\n                else:\n                    dsum+=b[x][i-k]\n                    k+=1        \n        else:\n            k=1\n            for x in range(i-n+1,l): \n                if x <n:\n                    dsum+=b[x][i]\n                else:\n                    dsum+=b[x][i-k]\n                    k+=1\n        d1_sum.append(dsum)\n    return d1_sum\n        \ndef d2sum(b,n,l):\n    d2_sum = []\n    for i in range(l):\n        dsum=0\n        if i+n <= l:\n            k=1\n            for x in range(n+i):\n                if x <n:\n                    dsum+=b[x][-1-i]\n                else:\n                    dsum+=b[x][-1-i+k]\n                    k+=1        \n        else:\n            k=1\n            for x in range(i-n+1,l): \n                if x <n:\n                    dsum+=b[x][-1-i]\n                else:\n                    dsum+=b[x][-1-i+k]\n                    k+=1\n        d2_sum.append(dsum)\n    return d2_sum\n    \n    \ndef max_hexagon_beam(n: int,seq: tuple):\n    print((n,seq))\n    l = 2*n-1\n    b = []\n    hb_sum = []\n    itr = cycle(seq)\n    for i in range(l):\n            tmp = []\n            if i+n <=l:\n                k = i+n\n            else:\n                k = l-(i-n+1)\n            for j in range(k):\n                tmp.append(next(itr))\n            b.append(tmp)\n            hb_sum.append(sum(tmp))\n    \n    #printhex(b)\n    d1_sum = d1sum(b,n,l)\n    d2_sum = d2sum(b,n,l)\n    return(max(chain(hb_sum,d1_sum,d2_sum)))\n    \n        \n", "def max_hexagon_beam(n: int,ll: tuple):\n# n = 5\n# l1 = [4,3,8,7,5,1]\n    l1 = list(ll)\n    tn = (n * ((2*n)-1)) + (((2*n)-n-1)**2)\n    mid = (2*n-1)\n    nest = [0 for i in range(mid)]\n    for i in range (0, n):\n        nest[n-i-1] = mid-i\n        nest[n+i-1] = mid-i\n    xv = l1[:tn%len(l1)]\n    l2 = [l1*(tn//len(l1))+xv]\n    cnt = 0\n    a0 = [[]]*len(nest)\n    a1 = [[0] * mid] * mid\n    a2 = [[0] * mid] * mid\n    for st in range (0, len(nest)):\n        a0[st] = l2[0][cnt:cnt+nest[st]]\n        cnt += nest[st]\n    for st in range (0,n):\n        a1[st] = a0[st] + [0]*(mid-nest[st])\n        a1[mid-1-st] = [0]*(mid-nest[st]) + a0[mid-st-1]\n        a2[st] = [0]*(mid-nest[st]) + a0[st]\n        a2[mid-1-st] = a0[mid-st-1] + [0]*(mid-nest[st]) \n    sm0 = [0]*mid\n    sm1 = [0]*mid\n    sm2 = [0]*mid\n    for i in range (0, mid):\n        for j in range (0, mid):\n            sm1[j] += a1[i][j]\n            sm2[j] += a2[i][j]\n    for i in range (0, mid):\n        sm0[i] = sum(a0[i])\n    return (max(sm0+sm1+sm2))\n", "def fila_left(n, fila):\n    \"\"\"Asigna al array con las filas de la grid el array de filas a la izqda\"\"\"\n    output = [None] * (2 * n - 1)\n    column = 0\n    while column <= n - 1:\n        output[column] = [fila[row][0] for row in range(n + column)]\n        for row in range(n + column):\n            fila[row].pop(0)\n        column += 1\n    while column <= 2 * n - 2:\n        output[column] = [fila[row][0] for row in range(column - n + 1, 2 * n - 1)]\n        for row in range(column - n + 1, 2 * n - 1):\n            fila[row].pop(0)\n        column += 1\n    return output\n\n\ndef max_hexagon_beam(n: int, seq: tuple):\n    celdas = 3 * n ** 2 - 3 * n + 1\n    elementos = [n + i for i in range(n)] + [2 * n - 2 - i for i in range(n - 1)]\n    filas = len(elementos)\n    grid = []\n    for i in range(celdas):\n        grid.append(seq[i % len(seq)])\n    # Analizamos filas\n    fila = [None] * filas\n    usados = 0\n    for i in range(filas):\n        fila[i] = grid[usados:usados + elementos[i]]\n        usados += elementos[i]\n    maximo = max(sum(fila[i]) for i in range(filas))\n\n    # Analizamos filas a la izquierda por dos veces\n    fila2 = fila_left(n, fila)\n    fila2 = [row[::-1] for row in fila2]\n    maximo_left = max(sum(fila2[i]) for i in range(filas))\n    fila3 = fila_left(n, fila2)\n    fila3 = [row[::-1] for row in fila3]\n    maximo_right = max(sum(fila3[i]) for i in range(filas))\n    return max(maximo, maximo_left, maximo_right)"]