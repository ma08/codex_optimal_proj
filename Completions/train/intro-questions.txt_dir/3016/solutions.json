["from itertools import product\n\nNOTES =  [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']]*2\nconfig = [('Major', 4), ('Minor', 3)]\n\nDCT_CHORDS = {c: mode for mode, offset in config\n                      for i in range(len(NOTES)//2)\n                      for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef minor_or_major(chord):\n    chord = tuple(chord.split()) if isinstance(chord, str) else \"\"\n    return DCT_CHORDS.get(chord, \"Not a chord\")", "from itertools import product\n\nNOTES =  [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'],\n    ['A'], ['A#', 'Bb'], ['B']]*2\nMAJOR = set(c for i in range(len(NOTES)//2) for c in product(NOTES[i], NOTES[i+4], NOTES[i+7]))\nMINOR = set(c for i in range(len(NOTES)//2) for c in product(NOTES[i], NOTES[i+3], NOTES[i+7]))\n\ndef minor_or_major(chord):\n    chord = tuple(chord.split()) if isinstance(chord, str) else (\"\", \"\", \"\")\n    return \"Major\" if chord in MAJOR else \"Minor\" if chord in MINOR else \"Not a chord\"", "notes = [\"C\", [\"C#\", \"Db\"], \"D\", [\"D#\", \"Eb\"], \"E\", \"F\", [\"F#\", \"Gb\"], \"G\", [\"G#\", \"Ab\"], \"A\", [\"A#\", \"Bb\"], \"B\"]\nmom = {(3, 4): \"Minor\", (4, 3): \"Major\"}\nlevels = {\n    x: i\n    for i, xs in enumerate(notes)\n    for x in ([xs] if isinstance(xs, str) else xs)\n}\n\ndef minor_or_major(chord):\n    xs = [levels.get(c) for c in chord.split()]\n    if None in xs:\n        return \"Not a chord\"\n    deltas = tuple((b - a) % len(notes) for a, b in zip(xs, xs[1:]))\n    return mom.get(deltas, \"Not a chord\")", "base={'C':0,'C#':1,'Db':1,'D':2,'D#':3,'Eb':3,'E':4,'F':5,'F#':6,'Gb':6,'G':7,'G#':8,'Ab':8,'A':9,'A#':10,'Bb':10,'B':11,}; minor_or_major=lambda c: \"Not a chord\" if sum(n in base for n in c.split())!=3 else (lambda ns: \"Major\" if (12+base[ns[1]]-base[ns[0]])%12==4 and (12+base[ns[2]]-base[ns[1]])%12==3 else \"Minor\" if (12+base[ns[1]]-base[ns[0]])%12==3 and (12+base[ns[2]]-base[ns[1]])%12==4 else \"Not a chord\")(c.split())", "NOTES = {'C':0, 'C#':1, 'Db':1, 'D':2, 'D#':3, 'Eb':3, 'E':4, 'F':5, 'F#':6, 'Gb':6, 'G':7, 'G#':8, 'Ab':8, 'A':9, 'A#':10, 'Bb':10, 'B':11 }\ndef minor_or_major(chord):\n    notes = chord.split(' ')\n    if len(notes) != 3 : return 'Not a chord'\n    first,second,third = [NOTES[note] if note in NOTES else 0 for note in notes]\n    interval = (second-first+12)%12\n    return 'Not a chord' if (third-first+12)%12 != 7 or interval not in (3,4) else 'Minor' if interval==3 else 'Major'", "def minor_or_major(chord):\n  \n  interval = {\"C\":1,'C#':2,'Db':2,'D':3,'D#':4,'Eb':4,'E':5,'F':6,\n  'F#':7,'Gb':7,'G':8,'G#':9,'Ab':9,'A':10,'A#':11,'Bb':11,'B':12}\n\n  chord = chord.split()\n\n  if len([i for i in chord if i in interval]) == 3:\n    if interval[chord[1]] - interval[chord[0]] in [4,-8] and interval[chord[2]] - interval[chord[1]] in [3,-9]:\n        return \"Major\"\n\n    elif interval[chord[1]] - interval[chord[0]] in [3,-9] and interval[chord[2]] - interval[chord[1]] in [4,-8]:\n        return \"Minor\"\n\n    else:\n        return \"Not a chord\"\n  else:\n      return \"Not a chord\"", "def minor_or_major(s):\n    p = ['C D EF G A B'.find(n[0]) + ('#' in n) - ('b' in n) for n in s.split()]\n    return {(3,4): 'Minor', (4,3): 'Major'}.get(tuple((b - a + 12) % 12 for a,b in zip(p, p[1:])), 'Not a chord')"]