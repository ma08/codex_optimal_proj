["from itertools import product\ndef proc_seq(*args):\n    nums = set(int(''.join(l)) for l in product(*(str(a) for a in args)) if l[0] != '0')\n    if len(nums) == 1: return [1, nums.pop()]\n    return [len(nums), min(nums), max(nums), sum(nums)]", "from itertools import product\n\ndef proc_seq(*args):\n    p = set([int(''.join(e)) for e in product(*[[c for c in str(arg) if i or c != '0'] for i, arg in enumerate(args)])])\n    return [len(p)] + ([min(p), max(p)] if len(p) > 1 else []) + [sum(p)]", "def proc_seq(*li):\n    un = {(i,) for i in str(li[0]) if i[0] != '0'}\n    for i in li[1:]  :  un = {k + (l,) for k in un for l in str(i)}\n    un = {int(''.join(i)) for i in un}  \n    return [1,un.pop()] if len(un)==1 else [len(un),min(un),max(un),sum(un)]", "from itertools import product\ndef proc_seq(*li):\n    un = {int(''.join(i)) for i in list(product(*map(str, li))) if i[0]!='0'}\n    return [1,un.pop()] if len(un)==1 else [len(un),min(un),max(un),sum(un)]", "from itertools import product\n\ndef proc_seq(*args):\n    res = [int(''.join(s)) for s in set(product(*map(str, args))) if s[0] != '0']\n    if len(res) == 1: return [1, res[0]]\n    return [len(res), min(res), max(res), sum(res)]", "def proc_seq(*args):\n    result = []\n    mems = []\n    numbers = [\"\"]\n    for a in args:\n      mems.append(list(set(str(a))))    \n    \n    nnumbers = []\n    for a in mems:\n      nnumbers = list(map(lambda x: (list(map(lambda y: y+x, numbers))),a))\n      numbers = []\n      for a in nnumbers:\n        for b in a:\n          numbers.append(b)     \n    \n    numbers = list(filter(lambda x: x[0] != '0', numbers))\n    \n    numbers = list(map(lambda x: int(x), numbers))\n    numbers.sort()    \n        \n    if(len(numbers)==1):\n      return [len(numbers), sum(numbers)]\n    return [len(numbers), numbers[0], numbers[len(numbers)-1],sum(numbers)]", "from itertools import product as p\ndef proc_seq(*a):\n    r,s=[],[]\n    for i,x in enumerate(map(str,a)):\n        s+=[''.join(set(d for d in x if d!='0' or i))]\n    for x in p(*[[d for d in x] for x in s]):\n        r+=[int(''.join(x))]\n    l,h=min(r),max(r)\n    return [len(r)]+([] if l==h else [l,h])+[sum(r)]", "from functools import reduce\ndef prod(arr):\n    return reduce(lambda x,y:x*y, arr)\n\ndef proc_seq(*args):\n    args = [set(str(n)) for n in args]\n    args[0] -= {'0'}\n    minimum = int(\"\".join(min(n) for n in args))\n    maximum = int(\"\".join(max(n) for n in args))\n    total = get_total(args)\n    number = prod(len(arg) for arg in args)\n    \n    return [number, minimum, maximum, total] if number > 1 else [1, minimum]\n\ndef get_total(args):\n    total = 0\n    args = args[::-1]\n    for i, arg in enumerate(args):\n        total += 10 ** i * sum(map(int, arg)) * prod(len(x) for x in args[:i] + args[i+1:])\n    return total\n"]