["def missing(seq):\n    for digits in range(1, len(seq) // 2 + 1):\n        my_seq = last = seq[:digits]\n        n = int(my_seq)\n        missing = None\n        \n        while len(my_seq) < len(seq):\n            n += 1\n            my_seq += str(n)\n            \n            if not seq.startswith(my_seq):\n                if missing == None:\n                    missing = n\n                    my_seq = last\n                else:\n                    break\n            else:\n                last = my_seq\n        \n        if my_seq == seq and missing:\n            return missing\n    \n    return -1", "def missing(s):\n    i = 1\n    while True:\n        start, missing, j = int(s[:i]), [], i\n        number = start + 1\n        while j <= len(s) - len(str(number)):\n            if int(s[j:j + len(str(number))]) != number : missing.append(number)\n            else : j += len(str(number))\n            number += 1\n            if len(missing) > 1 : break\n        else:\n            if not missing : return -1\n            return missing[0]\n        i += 1", "def missing(seq):\n    digits = 1\n    \n    while digits <= len(seq) // 2:\n        my_seq = last = seq[:digits]\n        n = int(my_seq)\n        missing = None\n        \n        while len(my_seq) < len(seq):\n            n += 1\n            my_seq += str(n)\n            \n            if not seq.startswith(my_seq):\n                if missing == None:\n                    missing = n\n                    my_seq = last\n                else:\n                    break\n            else:\n                last = my_seq\n        \n        if my_seq == seq and missing:\n            return missing\n        \n        digits += 1\n    \n    return -1", "def missing(s):\n    for k in range(1, 7):\n        p, n, l, gaps = s, int(s[:k]), k, []\n        while p:\n            p = p[l:]\n            if p.startswith(str(n+1)):\n                l, n = len(str(n+1)), n + 1\n            elif p.startswith(str(n+2)):\n                gaps += [n + 1]\n                l, n = len(str(n+2)), n + 2\n            else: \n                break\n        if len(gaps) == 1 and p == '': return gaps.pop()    \n    return -1", "def missing(s):\n    for i in range(1, len(s)//2+1):\n        save, j, miss = int(s[:i]), i, None\n        while j < len(s):\n            x, y = str(save+1), str(save+2)\n            if s[j:].startswith(x):\n                j += len(x)\n                save = int(x)\n            elif s[j:].startswith(y) and miss is None:\n                j += len(y)\n                save = int(y)\n                miss = int(x)\n            else:\n                miss = None\n                break\n        if miss is not None: return miss\n    return -1", "def missing(s):\n    for i in range(1, len(s) // 2 + 1):\n        n, missing = int(s[:i]), None\n        while i < len(s):\n            n += 1\n            j = len(str(n))\n            if s.startswith(str(n)[:len(s) - i], i):\n                i += j\n            elif missing:\n                missing = None  # 2 missing numbers\n                break\n            else: missing = n\n        else:\n            if not missing: return -1  # No missing number\n        if missing: return missing  # 1 missing number\n    return -1  # Error in the sequence", "def missing(s):\n    for nd in range(1,min(7, len(s)//2+1)):\n        guess, miss = s[:nd], ''\n        n = int(guess)\n        while len(guess) < len(s):\n            n += 1\n            guess += str(n)\n            if not s.startswith(guess):\n                if miss:\n                    miss = ''\n                    break\n                miss = str(n)\n                guess = guess[:-len(miss)]\n        if miss: return int(miss)\n    return -1", "\nclass State:\n\n    def __init__(self, pos, missing_candidate, expected1, expected2):\n        self.pos = pos\n        self.missing_candidate = missing_candidate\n        self.expected1 = expected1\n        self.expected2 = expected2\n        self.valid = None\n        \n    def update_found_seq(self):\n        self.pos += len(str(self.expected1))\n        self.expected1 += 1\n        self.expected2 = self.expected1 + 1\n    \n    def update_found_skip(self):\n        self.missing_candidate = self.expected1\n        self.pos += len(str(self.expected2))\n        self.expected1 = self.expected2 + 1\n        self.expected2 = self.expected1 + 1\n\n    def __str__(self):\n        return \"State({0}, {1}, {2}, {3})\".format(self.pos, self.missing_candidate, self.expected1, self.expected2)\n\ndef missing(s):\n    res = -1\n    for l in range(1, len(s)//3+1):\n        q = State(0, None, int(s[0:l]), 0)\n        while q.pos < len(s) and q.valid==None:\n            if s[q.pos:].startswith(str(q.expected1)):\n                q.update_found_seq()\n            elif not q.missing_candidate and s[q.pos:].startswith(str(q.expected2)):\n                q.update_found_skip()\n            else:\n                q.valid = False\n            if q.pos == len(s):\n                q.valid = True\n        if q.valid:\n            if q.missing_candidate:\n                res = q.missing_candidate\n            else:\n                res = -1\n            break\n\n    return res\n", "def missing(s):\n    def missing(s, base, candidate=-1):\n        head, tail = int(s[:base]), s[base:]\n        if tail.startswith(str(head + 1)):\n            return missing(tail, len(str(head + 1)), candidate)\n        if tail.startswith(str(head + 2)):\n            return missing(tail, len(str(head + 2)), head + 1) if candidate == -1 else -1\n        return candidate if tail == \"\" else -1\n    for base in range(1, len(s) // 2 + 1):\n        result = missing(s, base)\n        if result != -1:\n            return result\n    return -1", "def missing(s):\n    result = -1\n    for start_chunk in range(1,len(s)//2 +1):\n        res = inner(s,start_chunk)\n        if res != -1:\n            result = res\n    return result\n\ndef inner(s,start_chunk):\n    result = -1\n    nums = []\n    rest = s\n    rip_count = 0\n    last = int(rest[:start_chunk])\n    rest = rest[start_chunk:]\n    nums.append(last)\n    chunk = start_chunk\n    while rest!= '':\n        if int(rest[:chunk]) - last != 1:\n            if int(rest[:chunk+1]) - last == 1:\n                chunk +=1\n                print('chunk +=1')\n            elif int(rest[:chunk+1]) - last == 2:\n                chunk +=1\n                rip_count+=1\n                print('chunk +=1')\n                print('rip_count+=1')\n                result = last + 1\n            elif int(rest[:chunk]) - last  == 2:\n                rip_count+=1\n                print('rip_count+=1')\n                result = last + 1\n            else: return -1\n        nums.append(int(rest[:chunk]))\n        last = int(rest[:chunk])\n        rest = rest[chunk:]\n        print(nums)\n        if(rip_count)>1:\n            return -1\n    return result"]