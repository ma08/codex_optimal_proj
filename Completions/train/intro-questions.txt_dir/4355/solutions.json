["from math import floor, exp\n    \ndef ex_euler(n):\n    # fct to study\n    F = lambda t,y : 2 - exp(-4 * t) - 2 * y\n    # initial conditions\n    t0 = 0; y0 = 1; # pt A0\n    T = 1; \n    # variables\n    h = T / float(n); X = [t0]; Y = [y0]; Z = []; R = []\n    # points A1 ... An\n    for k in range(0, n):\n        X.append((k + 1) * h)\n        Y.append(Y[k] + h * F(X[k],Y[k]))\n    # pts on the exact curve\n    for k in range(0, n + 1):\n        # exact solution\n        Z.append(1 + 0.5 * exp(-4 * X[k]) - 0.5 * exp(-2 * X[k]))\n        # relative error\n        R.append(abs(Y[k] - Z[k]) / float(Z[k]))\n    return floor((sum(R) / float(n + 1)) * 1e6) / 1e6 ", "from math import exp\ndef ex_euler(n):\n    f = lambda x, y: 2 - exp(-4*x) - 2*y\n    exact = lambda x: 1 + 0.5*exp(-4*x) - 0.5*exp(-2*x)\n    x, y, T = 0, 1, 1\n    h = T/n\n    mx = [0]\n    for _ in range(n):    \n        y += h*f(x, y)\n        x += h\n        z = exact(x)\n        mx.append(abs(y-z)/z)\n    return float(str(sum(mx)/(n+1))[:8])", "def ex_euler(n):\n    import numpy as np\n    n_steps = n+1\n    T=1\n    t = np.linspace(0,T,n_steps)\n    h=T/n\n    zk = 1+0.5*np.exp(-4*t)-0.5*np.exp(-2*t)\n    yk = [1]\n    \n    for i in range(1,n_steps):\n        dy_dt = 2 - np.exp(-4*t[i-1])-2*yk[i-1]\n        yk.append(yk[i-1]+dy_dt*h)\n        \n    err = np.divide(np.abs(np.array(yk) - zk),zk)\n    err = str(np.sum(err)/(n+1))\n    err = float(err[:err.find('.')+7])\n    return err\n    \n", "import math\n\ndef exact_sol(t):\n    return  1 + 0.5*math.exp(-4*t) - 0.5*math.exp(-2*t)\n\ndef slope(y, t):\n    return 2 - math.exp(-4*t) - 2*y\n    \ndef ex_euler(n):\n    y = 1\n    t = 0\n    error = abs(y - exact_sol(t))/exact_sol(t)\n    for _ in range(n):\n        y += slope(y,t)*(1/n)\n        t += 1/n\n        error += abs(y - exact_sol(t))/exact_sol(t)\n    \n    return (int((error/(n+1))*1e6))/1e6", "import math\ndef ex_euler(n):\n    h = 1.0 / n\n    xk = 0\n    yk = 1\n    sm = 0\n    Y = [1.0]\n    Z = [1.0]\n\n    for i in range(n):\n        \n        yk += (2 - math.exp(-4 * xk) - 2 * yk) * h\n        Y.append(yk)\n\n        xk += h\n\n        zk = 1 + 0.5 * math.exp(-4 * xk) - 0.5 * math.exp(-2 * xk)\n        Z.append(zk)\n\n    for i in range(len(Y)):\n        sm += abs(Y[i] - Z[i]) / Z[i]\n\n    return int(sm/(n+1)*1000000) / 1000000.0", "from math import *\nimport numpy as np\nfrom decimal import *\n\ndef f(xk,yk):\n    return 2 - exp(-4*xk) - 2*yk\ndef Y(t):\n    return 1 + 0.5*exp(-4*t) - 0.5*exp(-2*t)\n    \ndef ex_euler(n):\n        x = 0\n        y0 = 1\n        T = 1\n        h = 1/n\n        y = np.zeros(n+1)\n        z = np.zeros(n+1)\n        y[0] = y0        \n        for i in range(n):\n            y[i+1] = y[i] + f(x,y[i])*h\n            z[i] = Y(x)\n            x+=h\n        z[len(z)-1] = Y(x)\n        A = [abs(y[i] - z[i])/z[i] for i in range(n+1)]\n        return round(1e-6 * trunc(1e6*(np.mean(A, dtype=np.float32))),6)    \n", "from math import exp\n\ndef ex_euler(n):\n    e=0\n    h=1/n\n    y=1-h\n    for i in range(1,n+1):\n        t=i/n\n        e2=exp(-2*t)\n        e4=e2**2\n        z=1+(e4-e2)/2\n        e+=abs(y-z)/z\n        y+=(2-e4-2*y)*h\n    return e*1000000//(n+1)/1000000", "from math import exp\n\ndef ex_euler(n):\n    dx = 1 / n\n    def f(x, y):\n        return 2 - exp(-4*x) - 2*y\n    def z(x, y):\n        return 1 + 0.5*exp(-4*x) - 0.5*exp(-2*x)\n    x, y = 0, 1\n    errors = []\n    for _ in range(n + 1):\n        errors.append(abs(y - z(x, y)) / z(x, y))\n        y += f(x, y)*dx\n        x += dx\n    return float(str(sum(errors) / (n + 1))[:8])", "from math import e\n\ndef ex_euler(n):\n    x,y,h,r = 0,1,1/n,[1]\n    for _ in range(n):\n        f = 2 - e**(-4*x) - 2*y\n        yy = y + h*f\n        r.append(yy)\n        x,y = x+h,yy\n\n    real = [(1+.5*e**(-4*x*h)-.5*e**(-2*x*h)) for x in range(n+1)]\n    err = [abs(i-j)/j for i,j in zip(r,real)]\n    return float(str(sum(err)/(n+1))[:8])", "from math import exp, floor\ndef ex_euler(n):\n    y = 1\n    x = 0\n    T = 1/n\n    error = 0\n    \n    for i in range (n):\n        y = y + (2 - exp(-4*x) - 2*y)*T \n        x = x + T\n        zk = (1 + 0.5 * exp(-4*x) - 0.5 * exp(-2*x))\n        error = error + abs(y - zk)/zk\n    return floor(error/(n+1) * 10 ** 6 )/10 ** 6\n#float(\"{:.6f}\".format(error/(n+1)))\n#round(error/(n+1),6)\n"]