["from math import ceil\n\ndef branch(n):\n    if n == 1:\n        return 0\n    l = int(ceil(n ** 0.5)) // 2\n    n -= (2 * l - 1) ** 2 + 1\n    return n // (2*l or 1)", "branch=lambda n:(lambda r:r and(n-2)//r+2-r)(0-(1-n**.5)//2*2)", "branch=lambda n: 0 if n==1 else (lambda s: (n-s*s-1)//(s+1))(((n-1)**0.5-1)//2*2+1)", "def branch(n):\n    if n==1:\n        return 0\n    i=1\n    while(True):\n        if n<=(2*i-1)**2:\n            break\n        i+=1\n    return int((n-(2*i-3)**2-1)/(2*i-2))", "k, li = 1, [0]\n\nfor i in range(1, 1000000):\n    li.append(k)\n    k += 8 * i\n    \ndef branch(n):\n    a,b = next([i,li[i-1]+1] for i,j in enumerate(li) if j>=n)\n    step = a*2-2\n    for i in range(4):\n        if b<=n<b+step : return i\n        b += step\n    return 0", "def branch(n):\n    if n==1: return 0\n    l=(1 + int((n-1+0.5)**.5)) // 2\n    x=(2*l-1)**2+1\n    return (n-x)//(l*2)", "import math\n\ndef branch(n):\n    l = (math.sqrt(n)+1)//2\n    d = n-(2*l-1)**2\n    if d == 0:\n        if l == 1:\n            return 0\n        else:\n            return 3\n    else:\n        return int((d-1)/(2*l))", "from math import ceil\ndef branch(n):\n    k = ceil(n ** 0.5) // 2\n    lst = list(range((2 * k - 1) ** 2 + 1, (2 * k + 1) ** 2 + 1 )) or [1]\n    return lst.index(n) // (len(lst) / 4)\n", "memo = [[0, 0, 0, 0], [1, 1, 1, 1]]\nfor i in range(3, 1000000, 2):\n    memo.append([j for j in range(i ** 2, i ** 2 - (i - 1) * 3 - 1, -i + 1)][::-1])\n\ndef branch(n):\n    layer = int((1 + (n - 1)**0.5)//2 + 1)\n    for branch, coner_number in enumerate(memo[layer]):\n        if n <= coner_number:\n            return branch", "from math import sqrt, ceil \ndef branch(n):\n    if n == 1:\n        return 0\n    x = ceil(sqrt(n))//2*2\n    return (n-1-(x-1)**2)//x"]