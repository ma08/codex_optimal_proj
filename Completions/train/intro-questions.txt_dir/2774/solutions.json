["def is_balanced(s, caps):\n    stack = []\n    openers, closers = caps[::2], caps[1::2]\n    for char in s:\n        if char in openers:\n            if char in closers and stack and stack[-1] == char:\n                stack.pop()\n            else:\n                stack.append(char)\n        elif char in closers:\n            if not stack or openers[closers.index(char)] != stack[-1]:\n                return False\n            else:\n                stack.pop()\n    return not stack", "from itertools import cycle \n\ndef is_balanced(source, caps, i = 0):\n    it = iter(cycle([ caps[i: i +2] for i in range(0, len(caps), 2) ]) )\n    cl = ''.join([ e for e in source if e in caps ] )\n    while i<len(source):\n        if not cl: return True\n        n = next(it)\n        if n in cl: cl = cl.replace(n,'')\n        i += 1\n    return False\n", "def is_balanced(verify, pairs):\n    opened,closed,records,same = [],[],[],[]\n    for i in range(0, len(pairs), 2):\n        opened.append(pairs[i])\n        closed.append(pairs[i + 1])\n    for i in verify:\n        if i in opened and i in closed : same.append(not verify.count(i) & 1)\n        elif i in opened : records.append(i)\n        elif i in closed:\n            if not records:return 0\n            if records[-1] == opened[closed.index(i)] : records.pop()\n    return not records and all(same)", "def is_balanced(source, caps):\n    oldLen, source = len(source), ''.join( l for l in source if l in caps )\n    while oldLen != len(source):\n        oldLen = len(source)\n        for i in range(0,len(caps),2):\n            source = source.replace(caps[i:i+2],'')\n    return len(source)==0", "def is_balanced(source, caps):\n    matches = dict([(b,a) for a,b in zip(caps[::2],caps[1::2]) ])\n    source = [char for char in source if char in caps]\n    stack = []\n    for char in source:\n        if len(stack) == 0: stack.append(char)\n        elif matches.get(char) == stack[-1]: del stack[-1]\n        else: stack.append(char)\n    return len(stack) == 0", "from functools import reduce\ndef is_balanced(source, caps):\n    _map = {c2:c1 for c1, c2 in zip(caps[0::2], caps[1::2])}\n    red = lambda s, e: s[:-1] if s and s[-1] == _map.get(e) else s + e\n    return not reduce(red, [c for c in source if c in caps], '')\n", "def is_balanced(s, caps):\n    s = ''.join(i for i in s if i in caps)\n    caps = [caps[i:i+2] for i in range(0,len(caps),2)]\n    prev = ''\n    while s != prev:\n        prev = s\n        for c in caps:\n            s = s.replace(c,'')\n    return not s"]