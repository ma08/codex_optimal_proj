["from fractions import gcd\nimport re\nfrom functools import reduce\n\ndef min_special_mult(arr):\n    l = [e for e in arr if not re.match('(None)|([+-]?\\d+)', str(e))]\n    if len(l) == 1:\n        return 'There is 1 invalid entry: {}'.format(l[0])\n    if len(l) > 1:\n        return 'There are {} invalid entries: {}'.format(len(l), l)\n    \n    return reduce(lambda s, e: s * int(e) / gcd(s, int(e)) if e else s, arr, 1)\n", "from functools import reduce\ngcd = lambda a, b: a if not b else gcd(b, a%b)\nlcm = lambda a, b: a * b / gcd(a, b)\n\ndef min_special_mult(arr):\n    errors = []\n    xs = set()\n    for x in [_f for _f in arr if _f]:\n        try: xs.add(int(x))\n        except: errors.append(x)\n    if not errors: return reduce(lcm, xs)\n    if not errors[1:]: return \"There is 1 invalid entry: %s\" % errors[0]\n    return \"There are %d invalid entries: %s\" % (len(errors), errors)\n", "from functools import reduce\nfrom math import gcd\n\nlcm = lambda x,y: x * y // gcd(x, y)\n\ndef min_special_mult(arr):\n    try:\n        return abs(reduce(lcm, map(int, filter(None, arr))))\n    except ValueError:\n        errors = [x for x in arr if type(x) != int and not (type(x) == str and x.isdigit())]\n        if len(errors) == 1: return f\"There is 1 invalid entry: {errors[0]}\"\n        return f\"There are {len(errors)} invalid entries: {errors}\"", "from fractions import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_special_mult(arr):\n    valid, invalid = [], []\n    for x in filter(None, arr):\n        try:\n            valid.append(abs(int(x)))\n        except ValueError:\n            invalid.append(x)\n    if len(invalid) == 1:\n        return 'There is 1 invalid entry: {}'.format(invalid[0])\n    elif invalid:\n        return 'There are {} invalid entries: {}'.format(len(invalid), invalid)\n    return reduce(lcm, valid)", "def gcd(a,b):\n    while b > 0: a, b = b, a % b\n    return a\n    \ndef lcm(a, b):\n    return a * b / gcd(a, b)\n\ndef min_special_mult(arr):\n    try:\n        return reduce(lcm, map(abs, map(int, filter(None, arr))))\n    \n    except:\n        invalid = [i for i in arr if type(i) == str and not i.isdigit()]\n        \n        if len(invalid) == 1:\n            return \"There is 1 invalid entry: %s\" % invalid[0]\n        \n        return \"There are %s invalid entries: %s\" % (len(invalid), invalid)", "from fractions import gcd\nfrom functools import reduce\nimport math\ndef min_special_mult(arr):\n    a = filter(lambda x:type(x)!=int, [i for i in arr if not str(i).lstrip(\"-\").isdigit() and i!=None])\n    arr = [int(i) for i in arr if str(i).lstrip(\"-\").isdigit()]\n    if a:\n        return \"There {} {} invalid entr{}: {}\".format(\"are\" if len(a)>1 else \"is\",len(a),\"ies\" if len(a)>1 else \"y\",a if len(a)>1 else a[0])\n    return abs(reduce((lambda x,y : x*y/gcd(x,y)),arr))", "from fractions import gcd\n\ndef min_special_mult(arr):\n    def is_int(n):\n        try:\n            int(n)\n            return True\n        except:\n            return False\n    orig_arr = [x for x in arr if x]\n    arr = [int(x) for x in orig_arr if is_int(x)]\n    if len(orig_arr) - len(arr) > 0:\n        freaks = [x for x in orig_arr if not is_int(x)]\n        if len(freaks) > 1:\n            return \"There are {} invalid entries: {}\".format(len(freaks), freaks)\n        return \"There is 1 invalid entry: {}\".format(freaks[0])\n    \n    arr = [abs(x) for x in arr]\n    return reduce(lambda x, y: x * y // gcd(x, y), arr)", "def gcd(a,b):\n    while b:\n        a,b = b,a%b\n    return a\n\ndef lcd(a,b):\n    return a*b/gcd(a,b)\n\ndef checkstring(arr):\n    strlist = []\n    for elem in arr:\n        if type(elem) == str:\n            strlist.append(elem)\n    return strlist\n\ndef converttoint(arr):\n    intarray = []\n    for elem in arr:\n        if elem is None: pass\n        else:\n            try:\n                intarray.append(int(elem))\n            except:\n                intarray.append(elem)\n    return intarray\n    \ndef min_special_mult(arr):\n    arr = converttoint(arr)\n    if len(checkstring(arr)) == 1: \n        return 'There is 1 invalid entry: ' + str(checkstring(arr)[0])\n    elif len(checkstring(arr)) > 1: \n        return 'There are ' + str(len(checkstring(arr))) + ' invalid entries: ' + str(checkstring(arr))\n    current = 1\n    for elem in arr:\n        current = lcd(current,elem)\n    return current", "from functools import reduce\nprimes = [2, 3, 5, 7, 11, 13, 17]\n\ndef gen_primes():\n    for p in primes:\n        yield p\n\n    next_prime = primes[-1]\n    limit = int(next_prime ** 0.5) + 1\n    while True:\n        next_prime += 2\n        if limit * limit < next_prime:\n            limit += 2\n        for p in primes:\n            if next_prime % p == 0:\n                break\n            if p > limit:\n                primes.append(next_prime)\n                yield next_prime\n                break\n\ndef gen_prime_factor_multiplicities(n):\n    for p in gen_primes():\n        count = 0\n        while n % p == 0:\n            count += 1\n            n /= p\n        if count > 0:\n            yield (p, count)\n        if n == 1:\n            break\n\ndef min_special_mult(arr):\n    bad = []\n    good = []\n    for a in arr:\n        try:\n            if a is not None:\n                good.append(int(a))\n        except:\n            bad.append(a)\n    if bad:\n        if len(bad) == 1:\n            return \"There is 1 invalid entry: {}\".format(bad[0])\n        return \"There are {} invalid entries: {}\".format(len(bad), bad)\n\n    maxes = {}\n    for n in good:\n        for p, m in gen_prime_factor_multiplicities(abs(n)):\n            maxes[p] = max(maxes.get(p, m), m)\n    factors = [p ** m for p, m in maxes.items()]\n    return reduce(lambda a, b: a * b, factors)\n    \n", "def min_special_mult(arr):  #just simple \"straight forward\"...\n    narr=[]; l=[]; c=0 \n    for a in arr:\n       if a==None: continue\n       if isinstance(a,int): narr.append(a)\n       else:\n          try:\n             if int(a)==a: narr.append(a); continue\n          except:\n             l.append(a); c+=1 \n    if c==1: return \"There is 1 invalid entry: \"+l[0]\n    if c>0: return \"There are \"+str(c)+\" invalid entries: \"+str(l)\n    narr.sort(); n=narr[-1]; n1=n\n    while True:\n       f=0\n       for a in reversed(narr):\n          if n%a!=0: f=1; break\n       if f==0: return n\n       n+=n1"]