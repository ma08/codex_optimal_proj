["def find_spec_partition(n, k, com):\n    x,r = divmod(n,k)\n    return {'max': [x+1]*r + [x]*(k-r),\n            'min': [n+1-k] + [1]*(k-1)}[com]", "def find_spec_partition(n, k, com):\n    return [n-k+1] + [1] * (k-1) if com == \"min\" else [n//k + 1] * (n%k) + [n//k] * (k - n%k)", "def find_spec_partition(n, k, com):\n    if com == 'min':\n        return [n - k + 1] + [1] * (k-1)\n    q, r = divmod(n, k)\n    return [q+1] * r + [q] * (k-r)", "def find_spec_partition(n, k, com):\n    if com == 'min':\n        answer = [n]\n        while len(answer) != k:\n            answer[0] -= 1\n            answer.append(1)\n        return answer\n    else:\n        answer = [1 for i in range(k)]\n        cur = 0\n        while sum(answer) != n:\n            answer[cur] += 1\n            cur += 1\n            if cur == k:\n                cur = 0\n        return answer", "def find_spec_partition(n, k, com):\n    if com == 'min':\n        return [n - k + 1] + [1] * (k - 1)\n    else:\n        return [(n // k + 1 if i < n % k else n //k) for i in range(k)]\n    return r", "def find_spec_partition(n, k, com):\n    # your code here\n    part = [0]*k\n    if com == 'min':\n        part[1:k] = [1]*(k-1)\n        part[0] = n-k+1\n    else:\n        for p in range(len(part)):\n            maxPart = round(n/(k-p))\n            part[p] = maxPart\n            n -= maxPart\n    part.sort(reverse=True)\n    return part", "def find_spec_partition(n, k, com):\n    if com == 'min' : return [n-k+1]+[1]*(k-1)\n    else:\n        li, i = [1]*k, 0\n        while sum(li)<n: li[i%k]+=1; i+=1\n        return li"]