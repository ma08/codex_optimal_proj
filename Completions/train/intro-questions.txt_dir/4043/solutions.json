["def calc(gamemap):\n    nr, nc = len(gamemap), len(gamemap[0])\n    def _i(ra, rb):\n        return ra*nr + rb\n    vs, ws = [0] * nr**2, [0] * nr**2\n    for s in range(nr + nc - 1):\n        for ra in range(max(0, s - nc + 1), min(s + 1, nr)):\n            for rb in range(ra, min(s + 1, nr)):\n                ws[_i(ra, rb)] = (\n                    gamemap[ra][s - ra] +\n                    (gamemap[rb][s - rb] if ra != rb else 0) +\n                    max(vs[_i(ra - da, rb - db)]\n                        for da in (0, 1) if da <= ra\n                        for db in (0, 1) if db <= rb))\n        vs, ws = ws, vs\n    return vs[-1]", "def calc(gamemap):\n    nr, nc = len(gamemap), len(gamemap[0])\n    def _i(ra, rb):\n        return ra*nr + rb\n    vs, ws = [0] * nr**2, [0] * nr**2\n    for s in range(nr + nc - 1):\n        for ra in range(max(0, s - nc + 1), min(s + 1, nr)):\n            for rb in range(ra, min(s + 1, nr)):\n                ws[_i(ra, rb)] = (\n                    gamemap[ra][s - ra] +\n                    (gamemap[rb][s - rb] if ra != rb else 0) +\n                    max(vs[_i(ra - da, rb - db)]\n                        for da in (0, 1) if da <= ra\n                        for db in (0, 1) if db <= rb))\n        vs, ws = ws, vs\n    return vs[-1]\n    \"\"\"SUPER_MAN\"\"\"", "from itertools import product\nfrom functools import lru_cache\n\n\ndef calc(gamemap):\n    @lru_cache(None)\n    def calc0(p1, p2):\n        (y1, x1), (y2, x2) = p1, p2\n        cost = gamemap[y1][x1] \n        if p1 != p2:\n            cost += gamemap[y2][x2]\n        res = 0\n        for (dy1, dx1), (dy2, dx2) in moves:\n            p1 = (y1 + dy1, x1 + dx1)\n            if p1 not in playground:\n                continue\n            p2 = (y2 + dy2, x2 + dx2)\n            if p2 not in playground:\n                continue\n            r = calc0(p1, p2) if p1 < p2 else calc0(p2, p1)\n            if r > res:\n                res = r\n        return cost + res\n        \n    playground = set(product(range(len(gamemap)), range(len(gamemap[0]))))\n    moves = list(product(((0, 1), (1, 0)), repeat=2))\n    return calc0((0,0), (0,0))", "from itertools import combinations\n\n\ndef calc(gamemap):\n    x_max, y_max = len(gamemap)-1, len(gamemap[0])-1\n    last_step = x_max + y_max - 1\n    best_paths = {((0, 1), (1, 0)): gamemap[0][0] + gamemap[0][1] + gamemap[1][0] + gamemap[-2][-1] + gamemap[-1][-2] + gamemap[-1][-1]}\n    for step in range(2, last_step):\n        new_best_paths, x_lower_limit, x_upper_limit = {}, max(0, step-y_max), min(step, x_max)\n        for x1, x2 in combinations(range(x_lower_limit, x_upper_limit+1), 2):\n            y1, y2 = step-x1, step-x2\n            # find potential previous steps\n            previous_steps = set(((_x1, _y1), (_x2, _y2)) for _x1, _y1 in ((x1-1, y1), (x1, y1-1)) for _x2, _y2 in ((x2-1, y2), (x2, y2-1)))\n            best_path_value = max([best_paths[points] for points in previous_steps if points in best_paths])\n            # evaluate current path best value\n            new_best_paths[((x1, y1), (x2, y2))] = gamemap[x1][y1] + gamemap[x2][y2] + best_path_value\n        best_paths = new_best_paths\n    return max(best_paths.values())", "from itertools import combinations\n\n\ndef calc(gamemap):\n    x_max, y_max = len(gamemap)-1, len(gamemap[0])-1\n    last_step = x_max + y_max - 1\n    dynamic_table = {((0, 1), (1, 0)): gamemap[0][0] + gamemap[0][1] + gamemap[1][0] + gamemap[-2][-1] + gamemap[-1][-2] + gamemap[-1][-1]}\n    for step in range(2, last_step):\n        _dynamic_table = {}\n        x_lower_limit = max(0, step-y_max)\n        x_upper_limit = min(step+1, x_max+1)\n        for x1, x2 in combinations(range(x_lower_limit, x_upper_limit), 2):\n            y1, y2 = step-x1, step-x2\n            # store potential previous steps\n            previous_steps = set()\n            d1 = []\n            if x1:\n                d1.append((-1, 0))\n            if y1:\n                d1.append((0, -1))\n            d2 = []\n            if x2:\n                d2.append((-1, 0))\n            if y2:\n                d2.append((0, -1))\n            for _dx1, _dy1 in d1:\n                for _dx2, _dy2 in d2:\n                    _x1, _y1 = x1 + _dx1, y1 + _dy1\n                    _x2, _y2 = x2 + _dx2, y2 + _dy2\n                    if _x1 != _x2:\n                        previous_steps.add(((_x1, _y1), (_x2, _y2)))\n            best_path_value = max([dynamic_table[points] for points in previous_steps])\n            # evaluate current path best value\n            _dynamic_table[((x1, y1), (x2, y2))] = gamemap[x1][y1] + gamemap[x2][y2] + best_path_value\n        dynamic_table = _dynamic_table\n    return max(dynamic_table.values())", "def calc(gamemap):\n    nr, nc = len(gamemap), len(gamemap[0])\n    vs, ws = [0] * nr**2, [0] * nr**2\n    vs[0] = gamemap[0][0]\n    for s in range(nr + nc - 2):\n        for ra in range(min(s + 1, nr)):\n            ca = s - ra\n            for rb in range(ra, min(s + 1, nr)):\n                cb = s - rb\n                v = vs[ra*nr + rb]\n                for da in (0, 1):\n                    ra_, ca_ = ra + da, ca + (1 - da)\n                    if ra_ < nr and ca_ < nc:\n                        for db in (0, 1):\n                            rb_, cb_ = rb + db, cb + (1 - db)\n                            if rb_ < nr and cb_ < nc:\n                                v_ = v + gamemap[ra_][ca_] + (gamemap[rb_][cb_] if ra_ != rb_ else 0)\n                                ws[ra_*nr + rb_] = max(ws[ra_*nr + rb_], v_)\n        vs, ws = ws, vs\n    return vs[-1]\n\n\n# # Unoptimized:\n# from collections import defaultdict, namedtuple\n\n# def calc(gamemap):\n#     nr, nc = len(gamemap), len(gamemap[0])\n#     vs = {(Point(0, 0), Point(0, 0)): gamemap[0][0]}\n#     for _ in range(nr + nc - 2):\n#         ws = defaultdict(int)\n#         for (a, b), v in vs.items():\n#             for a_ in a.next_points(nr, nc):\n#                 for b_ in b.next_points(nr, nc):\n#                     v_ = v + gamemap[a_.r][a_.c] + (gamemap[b_.r][b_.c] if a_ != b_ else 0)\n#                     ws[a_, b_] = max(ws[a_, b_], v_)\n#         vs = ws\n#     return vs[Point(nr-1, nc-1), Point(nr-1, nc-1)]\n\n# class Point(namedtuple('Point', 'r c')):\n#     def next_points(self, nr, nc):\n#         if self.c < nc - 1:\n#             yield Point(self.r, self.c + 1)\n#         if self.r < nr - 1:\n#             yield Point(self.r + 1, self.c)\n", "from itertools import combinations\n\ndef calc(game_map):\n    \"\"\" A state is denoted a NE-SW diagonal of :game_map: and two different cells contained in it.        \n        Its key is a triplet (diagonal, row_cell_1, row_cell_2), where holds the invariant\n        diagonal == row_cell_1 + column_cell_1 == row_cell_2 + column_cell_2\n        Its value is the sum of the points scored by respective paths from the top left to the cells.\n    \"\"\"\n    rows = len(game_map)\n    cols = len(game_map[0])\n    \n    states = {\n        (1, 0, 1): game_map[0][0] + game_map[0][1] + game_map[1][0]\n        }\n    \n    state_keys = []\n    for diagonal in range(2, rows + cols - 1):\n        min_row = max(0, diagonal - cols + 1)\n        max_row = min(rows - 1, diagonal)\n        row_codes = range(min_row, max_row + 1)\n        for (row_cell_1, row_cell_2) in combinations(row_codes, 2):\n            state_keys.append((diagonal, row_cell_1, row_cell_2))\n\n    for (diagonal, row_cell_1, row_cell_2) in state_keys:       \n        prev_values = []\n        \n        # Both paths downwards\n        if row_cell_1 > 0:\n            prev_values.append(states[(diagonal - 1, row_cell_1 - 1, row_cell_2 - 1)])\n            \n        # Cell 1 downwards and cell 2 rightwards\n        if row_cell_1 > 0 and row_cell_2 < diagonal:\n            prev_values.append(states[(diagonal - 1, row_cell_1 - 1, row_cell_2)])\n            \n        # Cell 1 rightwards and cell 2 downwards. Excluded the case\n        # where both paths come from a common cell for efficiency.\n        if row_cell_2 > row_cell_1 + 1:\n            prev_values.append(states[(diagonal - 1, row_cell_1, row_cell_2 - 1)])\n            \n        # Both paths rightwards\n        if row_cell_2 < diagonal:\n            prev_values.append(states[(diagonal - 1, row_cell_1, row_cell_2)])\n            \n        prev_value = max(prev_values)\n        col_cell_1 = diagonal - row_cell_1\n        col_cell_2 = diagonal - row_cell_2\n        new_value = prev_value + game_map[row_cell_1][col_cell_1] + game_map[row_cell_2][col_cell_2]\n        states[(diagonal, row_cell_1, row_cell_2)] = new_value\n    \n    final_diagonal = (rows + cols - 3, rows - 2, rows - 1)\n    return states[final_diagonal] + game_map[rows - 1][cols - 1]", "def calc(Q) :\n    H,W,M,N,G = len(Q),~-len(Q[0]),[0] * len(Q) ** 2,[0] * len(Q) ** 2,lambda Q,S : M[H * Q + S]\n    for S in range(1,~-H + W) :\n        for V in range(max(0,S - W),min(-~S,H)) :\n            for B in range(-~V,min(-~S,H)) :\n                N[H * V + B] = Q[V][S - V] + Q[B][S - B] + max(G(V,B),G(~-V,B),G(V,~-B),G(~-V,~-B))\n        M,N = N,M\n    return Q[0][0] + Q[~-H][W] + G(~-~-H,~-H)", "def calc(mp):\n  h=len(mp)\n  w=len(mp[0])\n  dp=[[[0 for j in range(h+1)]for i in range(h+1)]for k in range(h+w+1)]\n  for s in range(1,h+w+1):\n    for i1 in range(1,h+1):\n      j1=s-i1+1\n      if j1>0 and j1<=w:\n        for i2 in range(1,h+1):\n          j2=s-i2+1\n          if j2>0 and j2<=w:\n            dp[s][i1][i2]=max(dp[s-1][i1][i2-1],dp[s-1][i1-1][i2],dp[s-1][i1-1][i2-1],dp[s-1][i1][i2])+mp[i1-1][j1-1]+mp[i2-1][j2-1]\n            if i1==i2: dp[s][i1][i2]-=mp[i1-1][j1-1]\n  return dp[h+w-1][h][h]"]