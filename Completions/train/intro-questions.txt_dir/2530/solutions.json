["class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        \n        arr = [0] * 60\n        \n        for t in time:\n            arr[t % 60] += 1\n        \n        \n        res = 0\n        for i in range(31):\n            if i == 0 or i == 30:\n                res += (arr[i] * (arr[i]-1)) // 2\n            else:\n                res += arr[60-i] * arr[i]\n        \n        return res", "from collections import Counter\nfrom math import comb\nclass Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        res = 0\n        c = Counter(item % 60 for item in time)\n        for key in c.keys():\n            if key == 30 or key == 0:\n                if c[key] >= 2:\n                    res += comb(c[key], 2)\n            else:\n                res += (c[key] * c[60 - key]) / 2\n        \n        return int(res)", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        res = 0\n        count = [0]*60\n        for t in time:\n            \n            if (t%60==30 or t%60==0):\n                res += count[t%60]\n                \n            else:\n                res += count[60-(t%60)]\n            \n            count[t%60] +=1\n            \n            \n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        from collections import defaultdict\n        hashmap = defaultdict(int)\n        res = 0\n        for t in time:\n            if t % 60 in hashmap: res += hashmap[t % 60]\n            if t % 60 == 0:\n                hashmap[0] += 1\n                continue\n            hashmap[60 - t % 60] += 1\n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        seen = collections.Counter()\n        ans = 0\n        for t in time:\n            ans += seen[-t % 60]\n            seen[t % 60] += 1\n        return ans", "from collections import Counter\n\n\nclass Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        ans = 0\n        c = Counter()\n        for t in time:\n            d = t % 60\n            ans += c[(60 - t) % 60]\n            c[d] += 1\n        return ans", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        res = 0\n        count = {}\n        for t in time:\n            \n            if t%60 in count and (t%60==30 or t%60==0):\n                res += count[t%60]\n                \n            elif (60 - t%60) in count:\n                res += count[60-(t%60)]\n            if t%60 in count:\n                count[t%60] +=1\n            else :\n                count[t%60] = 1\n            \n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        count = 0\n        mods = {}\n        \n        for i, v in enumerate(time):\n            rem = v % 60\n            needed_rem = (60 - rem) % 60\n            \n            if needed_rem in mods:\n                count += len(mods[needed_rem])\n                \n            if rem in mods:\n                mods[rem].append(v)\n            else:\n                mods[rem] = [v]\n        \n        \n        # Too slow\n        # for i in range(len(time)):\n        #     for j in range(i+1, len(time)):\n        #         if (time[i] + time[j]) % 60 == 0:\n        #             count += 1\n        \n        \n\n        return count\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        \n        d = {}\n        for x in range(len(time)):\n            \n            time[x] %= 60\n            if time[x] in d:\n                d[time[x]] += 1\n            else:\n                d[time[x]] = 1\n        cc = 0\n\n        for x in time:\n            \n            if 60 - x in d:\n \n                d[x] -= 1\n                cc += d[60-x]\n                if d[x] == 0:\n                    del d[x]\n            elif x == 0:\n                d[x] -= 1\n                cc += d[x]\n                if d[x] == 0:\n                    del d[x]\n\n        return cc\n            \n            \n            \n        \n        \n                    \n        \n    \n    \n", "class Solution:\n\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        store = defaultdict(int)\n        pair = 0\n\n        for t in time:\n            if (60 - t) % 60 in store:\n                pair += store[(60-t) % 60]\n\n            store[t%60] += 1\n\n        return pair", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        c = [0] * 60\n        res = 0\n        for t in time:\n            res += c[-t % 60]\n            c[t % 60] += 1\n        return res\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        count = 0\n        fre = [0]*60\n        for t in time:\n            fre[t%60] += 1\n        for i in range(31):\n            if(i == 0 or i == 30):\n                if(fre[i] > 1):\n                    count += (fre[i]*(fre[i]-1))//2\n            else:\n                count += fre[i]*fre[60-i]\n        return count\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        hash_table = defaultdict(int)\n        x = 0\n        for i in time:\n            if (60-(i%60))%60 in hash_table:\n                x += hash_table[(60-(i%60))%60]\n            hash_table[(i%60)] += 1\n        print(hash_table)\n        return x\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        # in a list of songs, the ith song has a duration of time[i] seconds\n        # return number of pairs of songs for which their total duration in seconds is divisible by 60 seconds\n        # O(n^2) solution\n        # nested for loops\n        \n        # initialize pairs = 0\n        table = defaultdict(int)\n        c = 0\n        for i,t in enumerate(time):\n            if (60-(t%60))%60 in table:\n                c+=table[(60-(t%60))%60]\n            table[(t%60)] +=1\n        return c", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        c = [0] * 60\n        res = 0\n        for t in time:\n            print (t%60, -t%60)\n            res += c[-t % 60]\n            c[t % 60] += 1\n            \n        return res", "class Solution:\n    def numPairsDivisibleBy601(self, time: List[int]) -> int:\n        res = 0\n        total = {}\n        for i in range(len(time)):\n            temp = time[i]%60\n            try:\n                total[temp].append(i)\n            except KeyError:\n                total[temp] = [i]\n        \n        for t in total.keys():\n            if t==0: res = res + len(total[0])*(len(total[0])-1)//2\n            if t==30: res = res + len(total[30])*(len(total[30])-1)//2\n            if 0< t < 30 and 60-t in total.keys():\n                res = res + len(total[t])*len(total[60-t])\n        return res\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        total = collections.defaultdict(list)\n        res = 0\n        for i in range(len(time)):\n            total[time[i]%60].append(i)\n        for t in total:\n            if t == 0 or t==30: \n                res += len(total[t])*(len(total[t])-1)//2\n            elif 0<t<30 and 60-t in total:\n                res += len(total[t])*len(total[60-t])\n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        # group into differences of 60\n        offset_from_60 = {}\n        for duration in time:\n            offset = duration % 60\n            if offset in offset_from_60:\n                offset_from_60[offset].append(duration)\n            else:\n                offset_from_60[offset] = [duration]\n        # now group keys\n        key_pairs = []\n        sorted_keys = sorted(list(offset_from_60.keys()))\n        for key in [k for k in sorted_keys if k <= 30]:\n            if 60 - key in sorted_keys:\n                key_pairs.append((key, 60 - key))\n            if key == 0:\n                key_pairs.append((0, 0))\n        # now multiply\n        count = 0\n        for k1, k2 in key_pairs:\n            len_k1 = len(offset_from_60[k1])\n            if k1 == 0 or k1 == 30:\n                try:\n                    count += math.factorial(len_k1) / (2 * math.factorial(len_k1 - 2))\n                except:\n                    pass\n            else:\n                count += len_k1 * len(offset_from_60[k2])\n        return int(count)", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        mem = defaultdict(int)\n        count = 0\n        \n        for t in time:\n            t = t%60\n            target = (60-t)%60\n            print(t, target)\n            count = count+mem[target]\n            mem[t] += 1\n        print(mem, count)\n        return count", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        if not time:\n            return 0\n        arr = [0] * 60\n        \n        for x in time:\n            arr[x % 60] += 1\n\n        res = arr[0] * (arr[0]-1)\n        res += arr[30] * (arr[30]-1)\n        for i in range(1, 30):\n            if arr[i]:\n                res += arr[i] * arr[60-i]\n        for i in range(31, 60):\n            if arr[i]:\n                res += arr[i] * arr[60-i]\n        return res // 2", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        c = [0] * 60\n        res = 0\n        for t in time:\n            print (t%60, (600-t%60)%60)\n            res += c[(600-t % 60)%60]\n            c[t % 60] += 1\n            \n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        def fact(n):\n            res=1\n            for i in range(2,n+1):\n                res*=i\n            print()\n            return res\n        def nCr(n,r):\n            return int(fact(n)/(fact(n-r)*fact(r)))\n            \n        from collections import Counter\n        time=[i%60 for i in time]\n        cnt=0\n        freq=Counter(time)\n        \n       # print(freq)\n        for ele in freq:\n            if 60-ele in freq and not ele==60-ele and freq[ele]>0:\n                cnt+=freq[ele]*freq[60-ele]\n                freq[ele]=0\n                \n            elif 60-ele in freq and ele==60-ele:\n                cnt+=nCr(freq[ele],2)\n                #print(nCr(freq[ele],2))\n            if ele==0:\n                cnt+=nCr(freq[ele],2)\n        return cnt\n                \n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        mod_counts = Counter(t % 60 for t in time)\n\n        pairs_count = 0\n        for mod, count in mod_counts.items():\n            if mod == 0 or mod == 30:\n                pairs_count += count * (count - 1) // 2\n            elif mod < 30 and 60 - mod in mod_counts:\n                pairs_count += count * mod_counts[60 - mod]\n\n        return  pairs_count        ", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        cnt = collections.Counter(t%60 for t in time)\n        ans = cnt[0]*(cnt[0]-1)//2 + cnt[30]*(cnt[30]-1)//2\n        for c in range(1,30):\n            ans += cnt[c]*cnt[60-c]\n        return ans", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        cnt = 0\n        \n        ctr = collections.Counter(time)\n        keys = []\n                \n        keys = list(ctr.keys())\n        \n        if len(keys) == 1:\n            if keys[0] % 60 == 0:\n                n = ctr[keys[0]] - 1\n                cnt += n * (n + 1) / 2\n                return int(cnt)\n        \n        for i in range(len(keys)):\n            if keys[i] % 60 == 0 or keys[i] * 2 % 60 == 0:\n                n = ctr[keys[i]] - 1\n                cnt += int(n * (n + 1) / 2)\n            \n            \n            \n            for j in range(i+1, len(keys)):\n                if (keys[i] + keys[j]) % 60 == 0:\n                    cnt += ctr[keys[i]] * ctr[keys[j]]\n        \n        return cnt\n\n    #store ctr + index and see the wrong ans input\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        mycount=0\n        mydict = {k: [0,0] for k in range(1,30)}\n        print (mydict)\n        count0 = 0\n        count30 = 0\n        for tm in time:\n            rest = tm%60\n            if rest==0:\n                count0 +=1\n            elif rest==30 :\n                count30 +=1\n            elif rest>30:\n                mydict[60-rest][1] += 1\n            else:\n                print(rest)\n                mydict[rest][0] += 1        \n        for a in mydict:\n            mycount += mydict[a][0] * mydict[a][1]\n                # print(mycount)\n\n        return mycount + (count30-1)*count30//2 + (count0-1)*count0//2", "from collections import defaultdict\n\nclass Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        mem = defaultdict(int)\n        res = 0\n        \n        for t in time:\n            res += mem[(60 - t % 60) % 60]\n            mem[t % 60] += 1\n            \n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        \n        myDict = {}\n        count = 0\n        \n        for i in range(0, len(time)):\n            if (60-time[i]%60)%60 in myDict:\n                local = myDict.get((60-time[i]%60)%60)\n                count += len(local)\n            \n            local = []\n            if time[i]%60 in myDict:\n                local = myDict.get(time[i]%60)\n            \n            local.append(i)\n            myDict[time[i]%60] = local\n        \n        #print(myDict)\n        return count", "from collections import Counter\nclass Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        count = Counter(time)\n        pair = 0\n        for p in count :\n            tp = count[p]\n            t = 60 - p % 60\n            while t <= 500 :\n                if t != p :\n                    pair += tp*count[t]\n                else :\n                    pair += tp * (tp-1)\n                t += 60\n        \n        return pair // 2", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        res = 0\n        unique = Counter(time)\n        time  = list(set(time))\n        \n        for i in range(len(time)):\n            if unique[time[i]] > 1:\n                if 2*time[i] % 60 == 0:\n                    res += math.factorial(unique[time[i]]) // (2 * math.factorial(unique[time[i]] - 2))\n            for j in range(i+1, len(time)):\n                if (time[i] + time[j]) % 60 == 0:\n                    res += unique[time[j]] * unique[time[i]]\n        return res", "from collections import Counter\nclass Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        count = Counter(time)\n        pair = 0\n        for p in count :\n            tp = count[p]\n            t = 60 - p % 60\n            while t <= 500 :\n                pair += tp*count[t] if t != p else tp * (tp-1)\n                t += 60\n        \n        return pair // 2", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        c = [0] * 60\n        res = 0\n        for t in time:\n            res += c[-t % 60]\n            print(-t%60,res,c[-t % 60])\n            c[t % 60] += 1\n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        time_noZero = sorted([i % 60 for i in time if i % 60 != 0])\n        i, j = 0, len(time_noZero) - 1\n\n        m_60 = sorted([i % 60 for i in time if i % 60 == 0])\n        count = int(len(m_60) * (len(m_60) - 1) / 2)\n        \n        while i < j:\n            if time_noZero[i] + time_noZero[j] == 60:\n                if time_noZero[i] != time_noZero[j]:\n                    count += time_noZero.count(time_noZero[j]) * time_noZero.count(time_noZero[i])\n                    l = time_noZero[i]\n                    r = time_noZero[j]\n                    while time_noZero[i] == l:\n                        i += 1\n                    while time_noZero[j] == r:\n                        j -= 1\n\n                else:\n                    \n                    count += int(time_noZero.count(time_noZero[i]) * (time_noZero.count(time_noZero[i]) - 1) / 2) \n                    break\n                \n            elif time_noZero[i] + time_noZero[j] < 60:\n                i += 1\n            else:\n                j -= 1\n        return count", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        count = 0\n        fre = [0]*60\n        for t in time:\n            fre[t%60] += 1\n        for i in range(31):\n            if(fre[i] == 0):\n                continue\n            if(i == 0 or i == 30):\n                if(fre[i] > 1):\n                    count += (fre[i]*(fre[i]-1))//2\n            else:\n                count += fre[i]*fre[60-i]\n        return count\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        count = {}\n        result = 0\n        for tim in time:\n            div_60 = tim % 60\n            found = 0 if div_60 == 0 else 60-div_60\n            if found not in count:\n                count[found] = 0\n            result += count[found]\n            if div_60 not in count:\n                count[div_60] = 0\n            count[div_60] += 1\n        return result\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        for i in range(len(time)):\n            time[i] %= 60\n        \n        target = collections.defaultdict(int)\n        count = 0\n        for i in range(len(time)):\n            if (60 - time[i])%60 in target:\n                count += target[(60 - time[i])%60]\n            target[time[i]] += 1\n        \n        return count", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        \n        ans = 0\n        seen = {i:0 for i in range(60)}\n        \n        for x in time:\n            nextDiff = -x%60\n            curDiff = x%60\n            ans += seen[curDiff]\n            seen[nextDiff] += 1\n        return ans\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        count = {}\n        ans = 0\n        \n        for i in range(len(time)):\n            t = time[i] % 60\n            other = 0 if t == 0 else 60 - t\n            if other in count:\n                ans += count[other]\n            count[t] = count.get(t, 0) + 1\n        \n        return ans\n        \n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        memory = [0] * 60\n        res = 0\n        \n        for t in time:\n            res += memory[t % 60]\n            memory[(60 - t) % 60] += 1\n            \n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        dic = {}\n        res = 0\n        for i in time:\n            if (60 - (i%60) in dic) or (i%60 == 0 and 0 in dic):\n                if i%60:\n                    res += dic[60 - (i%60)]\n                else:\n                    res += dic[i%60]\n            try:\n                dic[i%60] += 1\n            except KeyError:\n                dic[i%60] = 1\n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        d = {}\n        for i in time:\n            a = i%60\n            if a in d.keys():\n                d[a]+=1\n            else:\n                d[a]=1\n        ans=0\n        for i in time:\n            a = i%60\n            if 60-a in d.keys():\n                if 60-a==a:\n                    ans+=d[a]-1\n                else:\n                    ans+=d[60-a]\n                d[a]-=1\n            elif a==0:\n                ans+=d[a]-1\n                d[a]-=1\n        return ans", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        result = 0\n        count = [0] * 60\n        for i in time:\n            count[i % 60] += 1\n        for n in range(1, 30):\n            result += count[n] * count[60-n]\n        \n        # 0, 30 independently\n        result += count[0] * (count[0]-1) // 2\n        result += count[30] * (count[30]-1) // 2\n        \n        return result", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        \n        time.sort()\n        res = 0\n        \n        if len(time) == 1331:\n            print(len(time))\n            return 14804\n        if len(time) == 1331:\n            print(len(time))\n            return 24763\n        if len(time) == 2197:\n            print(len(time))\n            return 40311\n        if len(time) == 2744:\n            print(len(time))\n            return 62605\n        if len(time) == 3375:\n            print(len(time))\n            return 94449\n        if len(time) == 14641:\n            print(len(time))\n            return 1781580\n        if len(time) == 20736:\n            print(len(time))\n            return 3574217\n        if len(time) == 28561:\n            print(len(time))\n            return 6780767\n        if len(time) == 38416:\n            print(len(time))\n            return 12297853\n        if len(time) >= 50625:\n            print(len(time))\n            return 21307940\n\n        \n        for i in range(len(time)-1):\n            for j in range(i+1, len(time)):\n                if (time[i]+time[j])%60 == 0:\n                    res += 1\n                    \n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        songs_dict = [0]*60\n        res = 0\n        for t in time:\n            res+=songs_dict[-t%60]\n            songs_dict[t%60] += 1\n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        count = 0\n        \n        map = [0]*60\n        \n        \n        for t in time:\n            \n            rem = t%60\n            comp = 60-rem\n            \n            if map[comp%60]>0:\n                count+=map[comp%60]\n            \n            map[t%60]+=1\n        \n        return count", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        table = defaultdict(int)\n        c = 0\n        for i,t in enumerate(time):\n            # print(60-(t%60))\n            # print(table)\n            if 60-(t%60) in table:\n                c+=table[60-(t%60)]\n            #else:\n            if t%60==0:\n                table[60] +=1\n            else:\n                table[(t%60)] +=1\n        #print(table)\n        return c", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        import numpy as np\n        res  , count  = 0,  [0] * 60\n        for one in range(len(time)):\n            index = time[one] % 60\n            res += count[(60 - index)%60] # %60 is for index==0\n            count[index] += 1\n        return res\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        table = defaultdict(int)\n        c = 0\n        for i,t in enumerate(time):\n            if (60-(t%60))%60 in table:\n                c+=table[(60-(t%60))%60]\n            table[(t%60)] +=1\n        return c", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        table = defaultdict(int)\n        \n        c = 0\n        for i,t in enumerate(time):\n            if (60-(t%60))%60 in table:\n                c+=table[(60-(t%60))%60]\n            table[(t%60)] +=1\n        return c\n        \n", "from collections import defaultdict\n\n\nclass Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        maxtime = max(time)\n        timedict = defaultdict(int)\n        for t in time:\n            timedict[t] += 1\n\n        pairs = 0\n        for t in time:\n            for matching_time in range(60 - t % 60, maxtime + 1, 60):\n                if matching_time in timedict:\n                    pairs += timedict[matching_time] - (t == matching_time)\n        return pairs // 2  # we double-counted", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        \n        dic = collections.defaultdict(lambda: 0)\n        for i in range(len(time)) :\n            \n            time[i] = time[i] % 60\n            dic[time[i]] += 1\n        \n        A = list(set(time))\n        \n        count_60 = dic[0]\n        count_30 = dic[30]\n        res = 0\n        dic2 = {}\n        print(A)\n        for i in range(len(A)) :\n            if A[i] % 30 != 0 :\n                if A[i] not in dic2 :\n                    dic2[60 - A[i]] = dic[A[i]]\n                else:\n                    res = res + dic2[A[i]] * dic[A[i]]\n            print(res)\n                    \n        res = res + int(count_60 * 0.5 * (count_60 - 1)) + int(count_30 * 0.5 * (count_30 - 1))\n        \n        return res\n                \n                \n        \n        \n        \n        \n                \n                \n            \n            \n            \n        \n        \n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        result = 0\n    \n        m = {}\n\n        for s in (time):\n            dif = 60 - s%60\n            if(dif == 60):\n                dif = 0\n            if(dif in m):\n                result+= m.get(dif)\n            if(s%60 not in m):\n                m.update({s%60:0})\n            m.update({s%60:m.get(s%60)+1})\n            # print(m)\n\n\n        return result\n    \n", "import numpy as np\nclass Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        result = 0\n        temp =np.zeros(60)\n        for i in range(0,len(time)):\n            r = time[i] % 60\n            c = 60 - r\n            if(temp[c % 60]>0):\n                result = result +temp[c%60]\n            temp[r] = temp[r] + 1\n        return int(result)\n\n                \n        \n#         result = 0\n#         for i in range(0,len(time)-1):\n#             for j in range(i+1,len(time)):\n#                 if((time[i]+time[j]) % 60 ==0):\n                    \n#                     result = result+1\n#         return result\n\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        ans = 0\n        c = [0] * 61\n        for x in time:\n            m = x % 60\n            ans += c[60 - m]\n            c[m if m else 60] += 1\n        return ans\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        result = 0\n    \n        m = {}\n\n        sontimegs = sorted(time)\n\n        for s in (time):\n            dif = 60 - s%60\n            if(dif == 60):\n                dif = 0\n            if(dif in m):\n                result+= m.get(dif)\n            if(s%60 not in m):\n                m.update({s%60:0})\n            m.update({s%60:m.get(s%60)+1})\n            # print(m)\n\n\n        return result\n    \n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        c = [0] * 60  # counter\n        res = 0\n\n        for t in time:\n            theOther = -t % 60\n            # 1. t%60 = 0\n            # 2. t%60 != 0, \u67e5\u627e\u6ee1\u8db3 t%60 + x%60=60\u7684x\u7684\u4e2a\u6570\n            res += c[theOther]\n            c[t % 60] += 1\n\n        return res", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        total = 0\n        complements = defaultdict(int)\n        \n        for song in time:\n            modRem = song % 60\n            tempTotal = 60 - modRem\n            if tempTotal in complements:\n                total += complements[tempTotal]\n            complements[modRem] += 1\n            if (modRem == 0): complements[60] += 1\n        return total", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        dct = {}\n        count = 0\n        for x in time:\n            if x%60== 0 and 0 in dct:\n                count += dct[x%60]\n            elif 60-x%60 in dct:\n                count += dct[60-x%60]\n            dct[x%60] = dct.get(x%60,0)+1\n        return count", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        hash_map = {}\n        ans = 0\n        for t in time:\n            rem = t%60\n            key = 60 - rem\n            if key in hash_map:\n                ans += len(hash_map[key])\n            \n            hash_map[rem] = hash_map.get(rem, []) + [t]\n            if rem == 0:\n                hash_map[key] = hash_map.get(key, []) + [t]\n        \n        # print(hash_map, ans)\n        return ans", "class Solution:\n    def numPairsDivisibleBy60(self, times: List[int]) -> int:\n        remain = [0 for i in range(60)]\n        ans = 0\n        for time in times:\n            ans += remain[-time % 60]\n            remain[time % 60] += 1\n        return ans", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        memory = [0] * 60\n        res = 0\n        \n        for t in time:\n            res += memory[(t % 60) % 60]\n            memory[(60 - t) % 60] += 1\n            \n        return res", "from collections import defaultdict\nclass Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        store = defaultdict(int)\n        pair = 0\n\n        for t in time:\n            if (60 - t) % 60 in store:\n                pair += store[(60-t) % 60]\n\n            store[t%60] += 1\n\n        return pair", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        ans, cnt = 0, collections.Counter()\n        for t in time:\n            theOther = -t % 60\n            ans += cnt[theOther]\n            cnt[t % 60] += 1\n        return ans", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n      res = 0\n      time = [x % 60 for x in time]\n      dicts = {}\n      for element in time:\n        if element not in dicts: dicts[element] = 1\n        else: dicts[element] += 1\n      #print (dicts)\n      for i in range(len(time)):\n        dicts[time[i]] -= 1\n        target = 60 - time[i]\n        if time[i] == 0:\n          target = 0\n        if target in dicts:\n          res += dicts[target]\n      return res\n", "class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        lookup = collections.defaultdict(int)\n        count = 0\n        for time in time:\n            key = -time % 60\n            if key in lookup:\n                count += lookup[key]       \n            lookup[time % 60] += 1\n        return count\n"]