["from itertools import compress, product, chain\nfrom functools import partial\n\ndef check(f, s):\n    if f.is_literal(): return f in s\n    elif f.is_and(): return all(check(e, s) for e in f.args)\n    elif f.is_or(): return any(check(e, s) for e in f.args)\n    elif f.is_not(): return not check(f.args[0], s)\n\ndef get_name(f):\n    if f.is_literal(): yield f\n    else: yield from chain.from_iterable(map(get_name, f.args))\n\ndef sat(f):\n    s = set(get_name(f))\n    return next(filter(partial(check, f), map(set, map(partial(compress, s), product((0,1), repeat=len(s))))), False)", "from itertools import product\n\ndef sat(f: Formula):\n\n    def getLiterals(f,s):\n        if f.is_literal(): s.add(f)\n        else:\n            for n in f.args: getLiterals(n,s)\n        return s\n        \n    def evaluate(f,bools):\n        return ( bools[f] if f.is_literal() else \n                 any(evaluate(n,bools) for n in f.args) if f.is_or() else\n                 all(evaluate(n,bools) for n in f.args) ^ f.is_not() )\n                 \n    lst = list(getLiterals(f,set()))\n    for p in product([0,1],repeat=len(lst)):\n        bools = dict(zip(lst,p))\n        if evaluate(f,bools):\n            return {n for n,v in bools.items() if v}\n    return False", "from itertools import combinations\nfrom typing import Iterable, List\n\ndef literals(f: Formula) -> List[Literal]:\n    if f.is_literal():\n        return [f]\n    return [x for g in f.args for x in literals(g)]\n    \ndef evaluate(f: Formula, i: Iterable[Literal]) -> bool:\n    if f.is_literal():\n        return f in i\n    if f.is_not():\n        return not evaluate(f.args[0], i)\n    args = (evaluate(g, i) for g in f.args)\n    if f.is_and():\n        return all(args)\n    if f.is_or():\n        return any(args)\n\ndef sat(f: Formula):\n    lits = set(literals(f))\n    n = len(lits)\n    for r in range(0, n + 1):\n        for i in combinations(lits, r):\n            if evaluate(f, set(i)):\n                return set(i)\n    return False", "def sat(f: Formula):\n    literals = total_literals(f, {})\n    length = len(literals)\n\n    for b in range(2**length):\n        table = {i:int(j) for i,j in zip(literals.keys(), bin(b)[2:].zfill(length))}\n        if satisfiable(f, table):\n            return {literals[i] for i in table if table[i]}\n    return False\n    \ndef total_literals(f, lit):\n    for i in f.args:\n        if i.is_literal() : lit[i.name] = i\n        else : total_literals(i, lit)\n    return lit\n\ndef satisfiable(f, table):\n    if f.is_literal() : return table[f.name]\n    if f.is_and() : return all(satisfiable(i,table) for i in f.args)\n    if f.is_or()  : return any(satisfiable(i,table) for i in f.args)\n    return not satisfiable(f.args[0], table)", "from itertools import product\ndef sat(f: Formula):\n    t=lambda f,s=set():s.add(f) or s if f.is_literal() else list(map(t,f.args)) and s\n    e=lambda f,d:d[f] if f.is_literal() else any(e(n,d)for n in f.args) if f.is_or() else all(e(n,d)for n in f.args)^f.is_not()\n    lst = list(t(f))\n    return next(({n for n in d if d[n]} for p in product([0,1],repeat=len(lst)) for d in [dict(zip(lst,p))] if e(f,d)), False)", "from itertools import product\n\ndef evaluate(self):\n    return ( self.val if self.is_literal() else\n             all(n.evaluate() for n in self.args) if self.is_and() else\n             any(n.evaluate() for n in self.args) if self.is_or() else\n             not self.args[0].evaluate() )\n\nFormula.evaluate=evaluate\n\n\ndef sat(f: Formula):\n    \n    def travel(f):\n        if f.is_literal(): s.add(f)\n        else:              \n            for n in f.args:\n                travel(n)\n    \n    s=set()\n    travel(f)\n    lst = list(s)\n    for p in product([0,1], repeat=len(lst)):\n        s=set()\n        for n,v in zip(lst,p):\n            n.val=v\n            if v: s.add(n)\n        if f.evaluate(): return s\n    return False", "def sat(f: Formula):\n    literals = total_literals(f, {})\n    length = len(literals)\n\n    for b in range(2**length):\n        table = {i:int(j) for i,j in zip(list(literals.keys()), bin(b)[2:].zfill(length))}\n        if satisfiable(f, table):\n            return {literals[i] for i in table if table[i]}\n    return False\n    \ndef total_literals(f, lit):\n    for i in f.args:\n        if i.is_literal() : lit[i.name] = i\n        else : total_literals(i, lit)\n    return lit \n\ndef satisfiable(f, table):\n    if f.is_literal() : return table[f.name]\n    x = [satisfiable(i,table) for i in f.args]    \n    return all(x) if f.is_and() else any(x) if f.is_or() else not all(x)\n\n#very INeffecient\n", "from itertools import combinations\n\ndef sat(f: Formula) -> set or False:\n    def eval_sat(f: Formula, true_vars: set) -> bool:\n        if f.is_literal():\n            return f in true_vars\n        elif f.is_and():\n            return all(eval_sat(ff, true_vars) for ff in f.args)\n        elif f.is_or():\n            return any(eval_sat(ff, true_vars) for ff in f.args)\n        elif f.is_not():\n            return not eval_sat(*f.args, true_vars)\n    \n    def get_vars(f: Formula) -> set:\n        if f.is_literal():\n            return {f}\n        else:\n            return set(var for ff in f.args for var in get_vars(ff))\n    \n    variables = get_vars(f)\n    for i in range(len(variables) + 1):\n        for true_vars in map(set, combinations(variables, i)):\n            if eval_sat(f, true_vars):\n                return true_vars\n    return False", "from itertools import combinations\n\n\ndef sat(f: Formula):\n    \n    literals = set()\n    allLiterals(f, literals)\n    all_lit = list(literals)\n    for i in range (0, len(all_lit)+1):\n        lit_comb = set(combinations(all_lit, i))\n        for j in lit_comb:\n            if evaluate(f, j): return set(j)\n    return False\n    \n\ndef evaluate(f: Formula, inter):\n\n    if f.is_literal():\n        if f in inter:\n            return True\n        else:\n            return False\n    elif f.is_and(): \n        flag = True\n        for i in f.args:\n            flag = flag and evaluate(i, inter)\n        return flag\n    elif f.is_or():\n        flag = False\n        for i in f.args:\n            flag = flag or evaluate(i, inter)\n        return flag\n    else: return (not evaluate(f.args[0], inter))\n    \n\ndef allLiterals(f: Formula, lit_set):\n\n    for i in f.args:\n        if i.is_literal(): lit_set.add(i)\n        else: allLiterals(i, lit_set)", "def _sat_and(models1, models2):\n    models = []\n    for model1 in models1:\n        for model2 in models2:\n            candidate = (model1[0] | model2[0], model1[1] | model2[1])\n            if candidate[0] & candidate[1] == set():\n                models.append(candidate)\n    return models\n\ndef _sat_not(f: Formula):\n    if f.is_literal():\n        return [(set(), {f})]\n    if f.is_not():\n        return _sat(f.args[0])\n    if f.is_and():\n        return [option for arg in f.args for option in _sat_not(arg)]\n    if f.is_or():\n        models = [(set(), set())]\n        for arg in f.args:\n            models = _sat_and(models, _sat_not(arg))\n        return models\n    \n\ndef _sat(f: Formula):\n    if f.is_literal():\n        return [({f}, set())]\n    if f.is_not():\n        return _sat_not(f.args[0])\n    if f.is_or():\n        return [option for arg in f.args for option in _sat(arg)]\n    if f.is_and():\n        models = [(set(), set())]\n        for arg in f.args:\n            models = _sat_and(models, _sat(arg))\n        return models\n    \n        \n\ndef sat(f: Formula):\n    options = _sat(f)\n    if len(options) == 0:\n        return False\n    return options[0][0]"]