["def jumbled_string(s, n):\n    iterations = [s]\n    \n    while True:\n        s = s[::2] + s[1::2]\n        if s == iterations[0]: break\n        iterations.append(s)\n    \n    return iterations[n % len(iterations)]", "#Kata: String -> N iterations -> String  Rating 5kyu\n\n\n#To optimize this problem, we must look at the circular (modular) nature of the iterations\n#of the even/odd rule.  Given any string, under the even/odd rule, the number of permutations\n#will be no longer than the length of the original message.  \n# e.g. 'abcdefghijklmnop' has only four unique permutations under the even/odd rule:\n#      ['abcdefghijklmnop', 'acegikmobdfhjlnp', 'aeimbfjncgkodhlp', 'aibjckdlemfngohp']\n# So, if we want to apply the even/odd rule N times for string 'abcdefghijklmnop', we need but\n# access the 'N modulo n' element in the permutation list (where m is the length of permutation list)\n\n\ndef buildPermList(originalMsg):\n    \n    listPerms = []\n    listPerms.append(originalMsg)   #index 0 is original message\n    curMsg = originalMsg\n    \n    while True:\n        even = curMsg[0::2]\n        odd = curMsg[1::2]\n        curMsg = even+odd\n        if curMsg != originalMsg:   #Scenario: Back to the original message\n            listPerms.append(curMsg)\n        else:\n            break\n\n    #listPerms is <= the length of the origianl message; ith element is the ith permutation under\n    # the even/odd rules\n    return listPerms    \n#-----end function\n\n\ndef jumbled_string(msg, n):\n\n    permList = buildPermList(msg)\n    numUniquePerms = len(permList)\n    desiredRotIndex = n % numUniquePerms\n\n    return permList[desiredRotIndex]\n\n#-----end function\n\n\n#Demonstrative test code\n# msg = 'abcdefghijklmnop'\n# n=18\n# myList = buildPermList(msg)\n# print(\"---Length of list: \", len(myList))\n# print(\"---List: \", myList)\n# lenList = len(myList)\n# desiredIndex = n % lenList\n# print( \"The location: \", str(desiredIndex) )\n# print( \"Desired String\",  rotationsByN(msg, n) )\n", "def jumbled_string(s, n):\n    seen = []\n    while s not in seen:\n        seen.append(s)\n        s = f\"{s[::2]}{s[1::2]}\"\n    return seen[n % len(seen)]", "def jumbled_string(s, n):\n    ml = ['bullshit']\n    new_str = s\n\n    while s != ml[-1]:\n        new_str = new_str[::2] + new_str[1::2]\n        ml.append(new_str)\n    return ml[n% (len(ml)-1)]", "def jumbled_string(s, n):\n    mixer = lambda s: s[::2] + s[1::2]\n    \n    if n == 1: return mixer(s) \n    \n    # Count max possible iterations\n    cnt = 1\n    x = s\n    while s != mixer(x):\n        cnt += 1\n        x = mixer(x)\n            \n    # Calculate needed amount of iterations         \n    max = n % cnt\n    while max != 0:\n        s = mixer(s)\n        max -= 1\n    return s", "def jumbled_string(s, n):\n    results = [s]\n    while n:\n        s = s[::2] + s[1::2]\n        n -= 1\n        if s == results[0]:\n            return results[n % len(results)]\n        else:\n            results.append(s)\n    return s", "def jumbled_string(s, n):\n   a = s\n   i = 0\n   while i < n:            # Find the period of string after which it's the same\n      s = s[::2] + s[1::2]\n      i += 1\n      if s == a:\n         break\n   n = n % i\n   for i in range(n):\n      s = s[::2] + s[1::2]\n   return s", "def jumbled_string(s, n):\n    idx  = list(range(0,len(s),2)) + list(range(1,len(s),2))\n    lst = []\n    while not lst or s != lst[0]:\n        lst.append(s)\n        s = ''.join(s[i] for i in idx)\n        if len(lst) == n: return s\n    return lst[ n%len(lst) ]", "def jumbled_string(s, n):\n    combine = lambda s : s[0::2] + s[1::2]\n    for _ in range(n%multiplicativeOrder(2, len(s))):\n        s = combine(s)\n    return s\n\ndef GCD (a, b ) : \n    if (b == 0 ) : \n        return a \n    return GCD( b, a % b ) \n\ndef multiplicativeOrder(A, N) : \n    if (GCD(A, N ) != 1) : \n        return multiplicativeOrder(A, N-1)\n    result = 1\n\n    K = 1\n    while (K < N) : \n        result = (result * A) % N \n        if (result == 1) : \n            return K \n        K = K + 1\n    return -1\n\n", "\"\"\"\nl = length of string\nm = l (if l is odd) or l - 1 (if l is even)\nk = length of a cycle to get back to original string\nthen (2^k) mod m = 1\n\"\"\"\n# find minimum k where (b ^ k) % m = 1 and k > 0\ndef multiplicativeOrder(b, m):\n    k, r = 1, 1\n    while True:\n        r = (r * b) % m\n        if r == 1:\n            return k\n        k += 1\n\ndef jumbled_string(s, n):\n    l = len(s)\n    m = l if l & 1 else l - 1\n    k = multiplicativeOrder(2, m)\n    answer = s\n    for i in range(n % k):\n        answer = answer[::2] + answer[1::2]\n    return answer"]