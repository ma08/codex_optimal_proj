["def find_next_power(val, pow_):\n    return int(val ** (1.0 / pow_) + 1) ** pow_", "import math\n\ndef find_next_power(val, pow_):\n    next_power_value = math.floor( 1 + val ** (1/pow_))\n    return next_power_value ** pow_", "def find_next_power(val, pow_):\n    return int(val ** (1 / pow_) + 1) ** pow_", "def find_next_power(val, power):\n\n  return int((val ** (1.0 / power)) + 1) ** power", "def find_next_power(val, pow_):\n    import math\n    a=val**(1./pow_)\n    b=math.ceil(a)\n    return b**pow_\n", "find_next_power=lambda n,p:int(n**(1./p)+1)**p", "find_next_power=lambda v, p: (int(v**(1.0/p))+1)**p", "def find_next_power(val, pow_):\n    return round((int(val ** (1.0 / pow_)) + 1) ** pow_)", "\ndef find_next_power(val, pow_):\n    num, next_power_value = 1, 1\n    while val > next_power_value:\n        next_power_value = num ** pow_\n        num += 1\n    \n    return next_power_value", "from math import ceil\n\ndef find_next_power(val, pow_):\n    return ceil((val + 1) ** (1 / pow_)) ** pow_"]