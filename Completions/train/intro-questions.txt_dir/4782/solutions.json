["# -*- coding: utf-8 -*-\nimport operator\n\n\nclass Placeholder:\n    def __init__(self, op=None, left=None, right=None):\n        self.op = op\n        self.left = left\n        self.right = right\n\n    def calc(self, args):\n        if self.op:\n            x, args = self.left.calc(args) if isinstance(self.left, Placeholder) else (self.left, args)\n            y, args = self.right.calc(args) if isinstance(self.right, Placeholder) else (self.right, args)\n            return self.op(x, y), args\n        return args[0], args[1:]\n\n    def __call__(self, *args):\n        return self.calc(args)[0]\n\n    def __add__(self, other):\n        return Placeholder(op=operator.add, left=self, right=other)\n\n    def __sub__(self, other):\n        return Placeholder(op=operator.sub, left=self, right=other)\n\n    def __mul__(self, other):\n        return Placeholder(op=operator.mul, left=self, right=other)\n\n    def __floordiv__(self, other):\n        return Placeholder(op=operator.floordiv, left=self, right=other)\n\n    def __radd__(self, other):\n        return Placeholder(op=operator.add, left=other, right=self)\n\n    def __rsub__(self, other):\n        return Placeholder(op=operator.sub, left=other, right=self)\n\n    def __rmul__(self, other):\n        return Placeholder(op=operator.mul, left=other, right=self)\n\n    def __rfloordiv__(self, other):\n        return Placeholder(op=operator.floordiv, left=other, right=self)\n\n\nx = Placeholder()", "import re\n\nclass Exp(object):\n    def __init__(self, v='x') : \n        self.exp = v\n\n    __str__ = lambda self : self.exp\n    make = lambda self, other, sign, r=1:Exp('({}{}{})'.format(*[self.exp,sign,str(other)][::r]))\n    oparation = lambda self, a, b, sign:str(a + b if sign == '+' else a - b if sign == '-' else a * b if sign == '*' else a // b)\n    \n    def __call__(self, *args, sr=r'\\((-?\\d+)([+\\-*/])(-?\\d+)\\)'):\n        args = list(args)\n        s = re.sub(r'x', lambda x: str(args.pop(0)), self.exp)\n        k = re.search(sr, s)\n        while k:\n            a, sign, b = k.groups()\n            s = s[:k.start()] + self.oparation(int(a), int(b), sign) + s[k.end():]\n            k = re.search(sr, s)\n        return int(s)\n\nx = Exp()\nfor i, j in zip('add sub mul floordiv radd rsub rmul rfloordiv'.split(), ('+-*/' * 2)):\n    setattr(Exp, f'__{i}__', lambda self, other, sign=j, r=[1,-1][i[0]=='r']: self.make(other, sign, r))", "import operator\n\nclass Placeholder:\n    def __init__(self, op=None, left=None, right=None):\n        self.op = op\n        self.left = left\n        self.right = right\n    def eval(self, args):\n        if self.op:\n            x, args = self.left.eval(args) if isinstance(self.left, Placeholder) else (self.left, args)\n            y, args = self.right.eval(args) if isinstance(self.right, Placeholder) else (self.right, args)\n            return self.op(x, y), args\n        return args[0], args[1:]\n    def __call__(self, *args):\n        return self.eval(args)[0]\n    def __add__(self, other):\n        return Placeholder(op=operator.add, left=self, right=other)\n    def __sub__(self, other):\n        return Placeholder(op=operator.sub, left=self, right=other)\n    def __mul__(self, other):\n        return Placeholder(op=operator.mul, left=self, right=other)\n    def __floordiv__(self, other):\n        return Placeholder(op=operator.floordiv, left=self, right=other)\n    def __radd__(self, other):\n        return Placeholder(op=operator.add, left=other, right=self)\n    def __rsub__(self, other):\n        return Placeholder(op=operator.sub, left=other, right=self)\n    def __rmul__(self, other):\n        return Placeholder(op=operator.mul, left=other, right=self)\n    def __rfloordiv__(self, other):\n        return Placeholder(op=operator.floordiv, left=other, right=self)\n\nx = Placeholder()", "def unwrap(obj, x):\n    return obj.do(x) if hasattr(obj, \"do\") else obj\n\n\nclass Placeholder:\n    def __init__(self, action=lambda x: x.pop(0)):\n        self.do = action\n\n    def __call__(self, *args):\n        return self.do([*args])\n\n    def __add__(self, other):\n        return Placeholder(lambda x: self.do(x) + unwrap(other, x))\n\n    def __sub__(self, other):\n        return Placeholder(lambda x: self.do(x) - unwrap(other, x))\n\n    def __mul__(self, other):\n        return Placeholder(lambda x: self.do(x) * unwrap(other, x))\n\n    def __floordiv__(self, other):\n        return Placeholder(lambda x: self.do(x) // unwrap(other, x))\n\n    def __radd__(self, other):\n        return Placeholder(lambda x: unwrap(other, x) + self.do(x))\n\n    def __rsub__(self, other):\n        return Placeholder(lambda x: unwrap(other, x) - self.do(x))\n\n    def __rmul__(self, other):\n        return Placeholder(lambda x: unwrap(other, x) * self.do(x))\n\n    def __rfloordiv__(self, other):\n        return Placeholder(lambda x: unwrap(other, x) // self.do(x))\n\nx = Placeholder()", "from operator import mul, add,  floordiv, sub\n\n\nclass Placeholder:\n    num = -1\n    def __init__(self, so_farr=[]):\n#         if Placeholder.num != -1:\n#             Placeholder.num = -1\n        self.so_far = so_farr\n\n    def __call__(self, *args):\n        ds = self.unpacked()\n        priori, m = 0, 0\n        for i in range(len(ds)):\n            if ds[i] == \"\":\n                ds[i] = args[m]\n                m += 1\n        i = 0\n        while len(ds) > 1:\n            if i < len(ds) and isinstance(ds[i], tuple):\n                if ds[i][1] == priori:\n                    ds[i] = ds[i][0](ds[i-1], ds[i+1])\n                    del ds[i-1]\n                    del ds[i]\n                    priori += 1\n                    continue\n            i += 1\n            if i >= len(ds):\n                i = 0\n        Placeholder.num = -1\n        return ds[0]\n\n    def unpacked(self):\n        ds = []\n        for i in range(len(self.so_far)):\n            if isinstance(self.so_far[i], Placeholder):\n                ds += self.so_far[i].unpacked()\n            else:\n                ds += [self.so_far[i]]\n        if not self.so_far:\n            ds += [\"\"]\n        return ds\n\n    def __add__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder(self.so_far + [(add, self.num), other])\n\n    def __sub__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder(self.so_far + [(sub, self.num), other])\n\n    def nullif(self):\n        if not self.so_far:\n            self.so_far.append(\"\")\n\n    def __mul__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder(self.so_far + [(mul, self.num), other])\n\n    def __floordiv__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder(self.so_far + [(floordiv, self.num), other])\n\n    def __radd__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder([other, (add, self.num)] + self.so_far)\n\n    def __rsub__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder([other, (sub, self.num)] + self.so_far)\n\n    def __rmul__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder([other, (mul, self.num)] + self.so_far)\n\n    def __rfloordiv__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder([other, (floordiv, self.num)] + self.so_far)\n\n\nx = Placeholder()", "from operator import mul, add,  floordiv, sub\n\n\nclass Placeholder:\n    num = -1\n    def __init__(self, so_farr=[]):\n#         if Placeholder.num != -1:\n#             Placeholder.num = -1\n        self.so_far = so_farr\n\n    def __call__(self, *args):\n        ds = self.unpacked()\n        priori, m = 0, 0\n        for i in range(len(ds)):\n            if ds[i] == \"\":\n                ds[i] = args[m]\n                m += 1\n        i = 0\n        while len(ds) > 1:\n            if i < len(ds) and isinstance(ds[i], tuple):\n                if ds[i][1] == priori:\n                    ds[i] = ds[i][0](ds[i-1], ds[i+1])\n                    del ds[i-1]\n                    del ds[i]\n                    continue\n            i += 1\n            if i >= len(ds):\n                i = 0\n                priori += 1\n        Placeholder.num = -1\n        return ds[0]\n\n    def unpacked(self):\n        ds = []\n        for i in range(len(self.so_far)):\n            if isinstance(self.so_far[i], Placeholder):\n                ds += self.so_far[i].unpacked()\n            else:\n                ds += [self.so_far[i]]\n        if not self.so_far:\n            ds += [\"\"]\n        return ds\n\n    def __add__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder(self.so_far + [(add, self.num), other])\n\n    def __sub__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder(self.so_far + [(sub, self.num), other])\n\n    def nullif(self):\n        if not self.so_far:\n            self.so_far.append(\"\")\n\n    def __mul__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder(self.so_far + [(mul, self.num), other])\n\n    def __floordiv__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder(self.so_far + [(floordiv, self.num), other])\n\n    def __radd__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder([other, (add, self.num)] + self.so_far)\n\n    def __rsub__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder([other, (sub, self.num)] + self.so_far)\n\n    def __rmul__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder([other, (mul, self.num)] + self.so_far)\n\n    def __rfloordiv__(self, other):\n        self.nullif()\n        Placeholder.num += 1\n        return Placeholder([other, (floordiv, self.num)] + self.so_far)\n\n\nx = Placeholder()", "class Placeholder:\n    def __init__(self, n, f):\n        self.n, self.f = n, f\n    def __call__(self, *args):\n        return self.f(*args)\n    def __add__(self, other):\n        if isinstance(other, Placeholder):\n            return Placeholder(self.n + other.n,\n                               lambda *args: self(*args[:self.n]) + other(*args[self.n:]))\n        return Placeholder(self.n,\n                           lambda *args: self(*args) + other)\n    def __sub__(self, other):\n        if isinstance(other, Placeholder):\n            return Placeholder(self.n + other.n,\n                               lambda *args: self(*args[:self.n]) - other(*args[self.n:]))\n        return Placeholder(self.n,\n                           lambda *args: self(*args) - other)\n    def __mul__(self, other):\n        if isinstance(other, Placeholder):\n            return Placeholder(self.n + other.n,\n                               lambda *args: self(*args[:self.n]) * other(*args[self.n:]))\n        return Placeholder(self.n,\n                           lambda *args: self(*args) * other)\n    def __floordiv__(self, other):\n        if isinstance(other, Placeholder):\n            return Placeholder(self.n + other.n,\n                               lambda *args: self(*args[:self.n]) // other(*args[self.n:]))\n        return Placeholder(self.n,\n                           lambda *args: self(*args) // other)\n    def __radd__(self, other):\n        if isinstance(other, Placeholder):\n            return Placeholder(self.n + other.n,\n                               lambda *args: other(*args[:self.n]) + self(*args[self.n:]))\n        return Placeholder(self.n,\n                           lambda *args: other + self(*args))\n    def __rsub__(self, other):\n        if isinstance(other, Placeholder):\n            return Placeholder(self.n + other.n,\n                               lambda *args: other(*args[:self.n]) - self(*args[self.n:]))\n        return Placeholder(self.n,\n                           lambda *args: other - self(*args))\n    def __rmul__(self, other):\n        if isinstance(other, Placeholder):\n            return Placeholder(self.n + other.n,\n                               lambda *args: other(*args[:self.n]) * self(*args[self.n:]))\n        return Placeholder(self.n,\n                           lambda *args: other * self(*args))\n    def __rfloordiv__(self, other):\n        if isinstance(other, Placeholder):\n            return Placeholder(self.n + other.n,\n                               lambda *args: other(*args[:self.n]) // self(*args[self.n:]))\n        return Placeholder(self.n,\n                           lambda *args: other // self(*args))\n    \nx = Placeholder(1, int)", "# a skeleton class with required operators provided for convenience\n# feel free to use another approach\nimport operator\n\n\ndef placeholdify(other):\n    if not isinstance(other, Placeholder):\n        return Placeholder(lambda: other, 0)\n    return other\n\ndef make_bin_op(op):\n    def __op__(self, other):\n        other = placeholdify(other)\n        return Placeholder(\n            lambda *args: op(self(*args[:self.n]), other(*args[self.n:])),\n            self.n + other.n\n        )\n    return __op__\n            \n        \ndef make_bin_rop(op):\n    def __rop__(self, other):\n        other = placeholdify(other)\n        return Placeholder(\n            lambda *args: op(other(*args[:other.n]), self(*args[other.n:])),\n            self.n + other.n\n        )\n    return __rop__\n\n\nclass Placeholder:\n    def __init__(self, f, n):\n        self.f = f\n        self.n = n\n    def __call__(self, *args):\n        return self.f(*args)\n    __add__ = make_bin_op(operator.add)\n    __sub__ = make_bin_op(operator.sub)\n    __mul__ = make_bin_op(operator.mul)\n    __floordiv__ = make_bin_op(operator.floordiv)\n    __radd__ = make_bin_rop(operator.add)\n    __rsub__ = make_bin_rop(operator.sub)\n    __rmul__ = make_bin_rop(operator.mul)\n    __rfloordiv__ = make_bin_rop(operator.floordiv)\n\nx = Placeholder(lambda x: x, 1)", "class Placeholder:\n  def __init__(self, num=None):\n      self.func = None\n      self.needed = 1 if num is None else 0\n      self.num = num\n      self.left = None\n      self.right = None\n      \n  def __call__(self, *args):\n      if type(args[0]) == tuple:\n          args = args[0]\n      if self.func is None:\n          return args[0] if self.num is None else self.num\n      left = self.left(args[:self.left.needed])\n      right = self.right(args[self.left.needed:])   \n      return self.func(left, right)\n  \n  def op(self, other, func):\n      x = Placeholder()\n      x.left = self\n      x.right = Placeholder(other) if type(other)==int else other\n      x.num = None\n      x.func = func\n      x.needed = x.left.needed + x.right.needed\n      return x      \n  \n  def __add__(self, other):\n      return self.op(other, lambda x, y: x + y)\n          \n  def __sub__(self, other):\n      return self.op(other, lambda x, y: x - y)\n          \n  def __mul__(self, other):\n      return self.op(other, lambda x, y: x * y)\n      \n  def __floordiv__(self, other):\n      return self.op(other, lambda x, y: x // y)\n\n  def rop(self, other, func):\n      x = Placeholder()\n      x.right = self\n      x.left = Placeholder(other) if type(other)==int else other\n      x.num = None\n      x.func = func\n      x.needed = x.left.needed + x.right.needed\n      return x   \n      \n  def __radd__(self, other):\n      return self.rop(other, lambda x, y: x + y)\n      \n  def __rsub__(self, other):\n      return self.rop(other, lambda x, y: x - y)\n      \n  def __rmul__(self, other):\n      return self.rop(other, lambda x, y: x * y)\n      \n  def __rfloordiv__(self, other):\n      return self.rop(other, lambda x, y: x // y)\n\nx = Placeholder()", "import operator\n# a skeleton class with required operators provided for convenience\n# feel free to use another approach\ndef calc(tree, args):\n      if tree.left is None:\n          tree.left = args.pop(0)      \n      if isinstance(tree.left, Tree):\n          tree.left = calc(tree.left, args)\n      if tree.right is None:\n          tree.right = args.pop(0)\n      if isinstance(tree.right, Tree):\n          tree.right = calc(tree.right, args)\n      return tree.op(tree.left, tree.right)\n          \nclass Tree:\n  def __init__(self, left=None, op=None, right=None):\n    self.left = left\n    self.right = right\n    self.op = op  \n          \n  def __call__(self, *args):\n    args = list(args)\n    result = calc(self, args)\n    self.__init__()\n    return result\n    \n  def __add__(self, other):\n    return self._left_op(other, operator.add)\n  def __sub__(self, other):\n    return self._left_op(other, operator.sub)\n  def __mul__(self, other):\n    return self._left_op(other, operator.mul)\n  def __floordiv__(self, other):\n    return self._left_op(other, operator.floordiv)\n  def __radd__(self, other):\n    return self._right_op(other, operator.add)\n  def __rsub__(self, other):\n    return self._right_op(other, operator.sub)\n  def __rmul__(self, other):\n    return self._right_op(other, operator.mul)\n  def __rfloordiv__(self, other):\n    return self._right_op(other, operator.floordiv)\n    \n  def _left_op(self, right, op):\n    left = None\n    if self.op:\n        left = self\n    current = Tree(left, op, right)    \n    if isinstance(right, Tree):\n        if self is right:\n            current.right = None\n        elif right.op:\n            current.right = Tree(right.left, right.op, right.right)\n        else:\n            current.right = None\n    return current\n    \n  def _right_op(self, left, op):\n    right = None\n    if self.op:\n        right = self\n    current = Tree(left, op, right) \n    if isinstance(left, Tree):\n        if self is left:\n            current.left = None\n        elif left.op:\n            current.left = Tree(left.left, left.op, left.right)\n        else:\n            current.left = None       \n    return current\n\nx = Tree()"]