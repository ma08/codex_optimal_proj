["def solve(a):\n    for i in a:\n        li = [i]\n        while 1:\n            if li[-1] % 3 == 0 and li[-1] // 3 in a : li.append(li[-1] // 3)\n            elif li[-1] * 2 in a : li.append(li[-1] * 2)\n            else : break\n        if len(li) == len(a) : return li", "def solve(arr):   \n    ar, v = arr[:], lambda p: lambda n: 0 if n % p else 1 + v(p)(n // p)\n    return sorted(reversed(sorted(ar, key=v(3))), key=v(2))", "def decompose(n):\n    res = [0,0,n]\n    for i,p in enumerate((3,2)):\n        while not n%p: res[i]+=1 ; n//=p\n    res[0] = -res[0]\n    return res\n\ndef solve(arr):\n    return [n for _,_,n in sorted(map(decompose,arr))]", "def solve(arr):\n    fn = lambda p: lambda n: 0 if n % p else 1 + fn(p)(n // p)\n    return sorted(sorted(arr, key=fn(3), reverse=True), key=fn(2))", "k,solve=lambda n,p:n%p<1and-~k(n//p,p),lambda a:sorted(a,key=lambda n:(-k(n,3),k(n,2)))", "def solve(arr):\n    links = {}\n    for a in arr:\n        if a % 3 == 0:\n            next_val = a // 3\n            if next_val in arr:\n                links[a] = next_val\n        if a * 2 in arr:\n            links[a] = a * 2\n            \n    start = (set(links.keys()) - set(links.values())).pop()\n    result = [start]\n    while True:\n        next_val = links.get(result[-1])\n        if next_val is None:\n            break\n        result.append(next_val)\n    return result", "def solve(arr):\n    stack = []\n    for num in arr:\n        branches = arr.copy()\n        branches.remove(num)\n        stack = [([num], branches)]\n        while len(stack) != 0:\n            (current, remaining) = stack.pop()\n            if len(remaining) == 0:\n                return current\n            x = current[len(current) - 1]\n            valid_leaves = [leaf for leaf in remaining if x / 3 == leaf or x * 2 == leaf]\n            for valid in valid_leaves:\n                valid_current = current.copy()\n                valid_current.append(valid)\n                valid_remaining = remaining.copy()\n                valid_remaining.remove(valid)\n                stack.append((valid_current, valid_remaining))\n                \n", "def solve(arr):\n    stack = []\n    for i in arr:\n        x = arr[:]\n        x.remove(i)\n        stack.append(([i],x))\n    while True:\n        a,b = stack.pop(0)\n        v = a[-1]\n        a1,a2 = a[:],a[:]\n        b1,b2 = b[:],b[:]\n        if v*2 in b:\n            a1.append(v*2)\n            b1.remove(v*2)\n            stack.append((a1,b1))\n        if not v%3:\n            if v//3 in b:\n                a2.append(v//3)\n                b2.remove(v//3)\n                stack.append((a2,b2))\n        if not b1:\n            return a1\n        if not b2:\n            return a2", "def solve(lst):\n    return sorted(lst, key=factors_count)\n    \ndef factors_count(n):\n    result = []\n    for k in (2, 3):\n        while n % k == 0:\n            n //= k\n            result.append(k)\n    return -result.count(3), result.count(2)\n", "def solve(lst):\n    return sorted(lst, key=factors_count)\n    \ndef factors_count(n):\n    result = [0, 0]\n    for k in (2, 3):\n        while n % k == 0:\n            n //= k\n            result[k-2] += (-1)**k\n    return result"]