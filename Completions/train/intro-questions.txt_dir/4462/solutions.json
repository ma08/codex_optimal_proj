["def adjacent_element_product(array):\n    return max( a*b for a, b in zip(array, array[1:]) )", "def adjacent_element_product(array):\n    return max(array[i]*array[i+1] for i in range(len(array)-1))", "def adjacent_element_product(array):\n    return max(x * y for x, y in zip(array, array[1:]))\n", "from operator import mul\ndef adjacent_element_product(array):\n    return max(map(mul, array, array[1:]))", "from itertools import islice\n\ndef adjacent_element_product(xs):\n    return max(x * y for x, y in zip(xs, islice(xs, 1, None)))", "def adjacent_element_product(array):\n    new_list = []\n    sum = 1\n    for e in range(len(array)):\n        if e == 0:\n            sum *= array[e] * array[e+1]\n            new_list.append(sum)\n            sum = 1\n            \n        elif e in range(1, len(array) - 1):\n            sum *= array[e-1] * array[e]\n            new_list.append(sum)\n            sum = 1\n            sum *= array[e+1] * array[e]\n            new_list.append(sum)\n            sum = 1\n            \n        else:\n            sum *= array[e] * array[e-1]\n            \n    return max(new_list)", "def adjacent_element_product(x):\n    L=[]\n    for i in range(len(x)-1):\n        L.append(x[i]*x[i+1])\n    return max(L)\n    \n    \n", "def adjacent_element_product(array):\n    products = []\n    for i in range(0, len(array) - 1):\n        products.append(array[i] * array[i + 1])\n    return max(products)", "def adjacent_element_product(arr):\n    product = [arr[i]*arr[i+1] for i in range(len(arr)-1)]\n    return max(product)", "def adjacent_element_product(array):\n    max = array[0]*array[1];\n    for i in range(1,len(array)-1):\n        temp = array[i]*array[i+1]\n        if max < temp:\n            max = temp \n    return max", "def adjacent_element_product(lst):\n    return max(lst[i]*lst[i+1] for i in range(len(lst)-1))", "def adjacent_element_product(array):\n    max_product = array[0] * array[1]\n    i = 2\n    while i < len(array):\n        max_product = max(max_product, array[i-1]*array[i])\n        i += 1\n    return max_product", "def adjacent_element_product(arr):\n    return max(arr[i] * n for i, n in enumerate(arr[1:]))", "def adjacent_element_product(array):\n    return max([array[i]*array[i+1] for i in range(len(array)-1)])", "def adjacent_element_product(a):\n    return max(x * y for x, y in zip(a, a[1:]))", "def adjacent_element_product(xs):\n    return max(xs[i - 1] * xs[i] for i in range(1, len(xs)))", "def adjacent_element_product(n):\n    return max([n[i]*n[i+1] for i in range(len(n) - 1)])\n", "adjacent_element_product=lambda array:max([a*b for a,b in zip(array[:-1],array[1:])])", "def adjacent_element_product(array):\n    return(max([j*array[i+1] for i,j in enumerate(array[:-1])]))", "adjacent_element_product = lambda arr: len(arr) and max(x*y for x,y in zip(arr, arr[1:]))", "def adjacent_element_product(arr):\n    a = arr[0] * arr[1]\n    for i in range(1,len(arr)):\n        if arr[i] * arr[i-1] > a:\n            a = arr[i] * arr[i-1]\n    return a", "def adjacent_element_product(array):\n    arr = []\n    for i in range(0,len(array)-1):\n        arr.append(array[i]*array[i+1])\n    return max(arr)", "def adjacent_element_product(arr):\n    s = []\n    for i in range(len(arr)- 1):\n        s.append(arr[i] * arr[i + 1])\n    n = max(s)\n    return n", "def adjacent_element_product(arr):\n    return sorted([arr[x] * arr[x + 1] for x in range(len(arr) -1 )] , reverse=True)[0]\n", "def adjacent_element_product(array):\n    john=[]\n    for i,v in enumerate(array):\n        if i==len(array)-1:\n            pass\n        else:\n            john.append(array[i]*array[i+1])\n    return max(john)\n            \n", "def adjacent_element_product(array):\n    m = -10000000\n    for n,i in enumerate(array[:-1]):\n        m = max(m,i*array[n+1])\n        \n    return m        ", "def adjacent_element_product(array):\n    list_pro=list()\n    for index in range(len(array[:-1])):\n        product=array[index]*array[index+1]\n        list_pro.append(product)\n    return max(list_pro)", "def adjacent_element_product(array):\n    return max([i * l for i, l in zip(array, array[1:])])", "def adjacent_element_product(A):\n    return max([a*b for a, b in zip(A[:-1], A[1:])])", "def adjacent_element_product(array):\n    a=[]\n    print(array)\n    for i in range(len(array)):\n        a.append(array[i]*array[i-1])\n    return max(a[1:])# max product\n", "def adjacent_element_product(array):\n    max = array[0] * array[1]\n    for i in range(len(array) - 1):\n        temp = array[i] * array[i + 1]\n        if(max < temp):\n            max = temp\n    return max", "def adjacent_element_product(array):\n    M = array[0]*array[1]\n    for i, element in enumerate(array[1:]):\n        x = element * array[i]\n        if x > M:\n            M = x\n    return M", "def adjacent_element_product(array):\n    arr_max=[]\n    for i in range(len(array)-1):\n        arr_max.append(array[i]*array[i+1])\n    return max(arr_max)", "def adjacent_element_product(array):\n    new=[]\n    for i in range(len(array)-1):\n        numero=array[i]*array[i+1]\n        new.append(numero)\n    \n    return max(new)", "def adjacent_element_product(array):\n    result = array[0] * array[1]\n    for i in range(1,len(array)-1):\n        temp = array[i] * array[i+1]\n        if result < temp:\n            result = temp\n    return result\n", "def adjacent_element_product(array):\n    m=None\n    for i in range(1,len(array)):\n        if m==None or array[i]*array[i-1]>m:\n            m=array[i]*array[i-1]\n    return m\n", "def adjacent_element_product(a):\n    b=[]\n    for i in range(len(a)-1):\n        c=a[i]*a[i+1]\n        b.append(c)\n    return max(b)", "def adjacent_element_product(array):\n    maxProduct = array[0] * array[1];\n    for i in range(1, len(array) - 1):\n        product = array[i] * array[i + 1]\n        if product > maxProduct:\n            maxProduct = product\n        \n    return maxProduct;", "def adjacent_element_product(a):\n    return max(a[x]* a[x+1] for x in range(len(a)-1))", "def adjacent_element_product(p):\n    return max(p[i]*p[-~i] for i in range(~-len(p)))", "def adjacent_element_product(array):\n    lst = [array[i] * array[i+1] for i in range(len(array)-1)]\n    return max(lst)", "def adjacent_element_product(array):\n    k=[]\n    for i in range(len(array)-1):\n        k.append(array[i]*(array[i+1]))\n    return max(k)", "def adjacent_element_product(array):\n    length = len(array)\n    res = []\n    for i in range(length):\n        if i < length-1:\n            res.append(array[i] * array[i+1])\n            \n    res.sort()\n    return res[-1]", "def adjacent_element_product(array):\n    l=array[-2]*array[-1]\n    for i in range(len(array)-2):\n        l=max(l,array[i]*array[i+1])\n    return l", "def adjacent_element_product(array):\n    arr = []\n    left_index = 0\n    right_index = -len(array) + 1\n    middle_index = 1\n    if len(array) == 2:\n        return array[0] * array[1]\n    while middle_index < len(array):\n        arr.append(array[left_index] * array[right_index])\n        left_index += 1\n        right_index += 1\n        middle_index += 1\n    return max(arr)", "def adjacent_element_product(array):\n    return max(m*n for m, n in zip(array, array[1:]))\n   \n", "def adjacent_element_product(array):\n    max_product = array[0] * array[1]\n    for i in range(len(array)-1):\n        subset = array[i] * array[i+1]\n        if subset > max_product:\n            max_product = subset \n    return max_product", "def adjacent_element_product(array):\n    return max(i * array[idx - 1] for idx, i in enumerate(array[1:], 1))", "def adjacent_element_product(array):\n    return max([array[x] * array[x-1] for x in range(1,len(array))])\n", "def adjacent_element_product(array):\n    max = array[0]*array[1]\n    for i in range(2,len(array)):\n        if(array[i]*array[i-1] > max): max = array[i]*array[i-1]\n    return max", "def adjacent_element_product(array):\n    return max(list(map(lambda x, y: x*y, array[:-1],array[1:])))\n", "def adjacent_element_product(array):\n    maximum = array[0] * array[1]\n    for n1, n2 in zip(array[1:], array[2:]):\n        maximum = max(maximum, n1*n2)\n    return maximum", "adjacent_element_product = lambda a: max( x*y for x,y in zip(a,a[1:]) )", "def adjacent_element_product(array):\n    m = 0\n    max = array[0]*array[1]\n    for i in range(1, len(array)-1) :\n        m = array[i]*array[i+1]\n        if m > max : max = m\n    return max # max product", "def adjacent_element_product(array):\n    results_list = []\n    prev = array[0]\n\n    for element in array[1:]:\n        maximum = prev * element\n        prev = element\n        results_list.append(maximum)\n\n    return max(results_list)", "def adjacent_element_product(array):\n    new_list = []\n    for x in range(len(array)):\n        if x+1 >= len(array):\n            break\n        else:\n            new_list.append(array[x] * array[x+1])\n    return max(new_list)", "def adjacent_element_product(array):\n    res = array[0] * array[1]\n    for i in range(2, len(array)):\n        prod = array[i] * array[i-1]\n        if prod > res: res = prod\n    return res", "from itertools import starmap\nfrom operator import mul\nfrom typing import List\n\n\ndef adjacent_element_product(array: List[int]) -> int:\n    return max(starmap(mul, list(zip(array, array[1:]))))\n", "def adjacent_element_product(array):\n    max = - float('inf')\n    for i in range(1,len(array)):\n            if array[i] * array[i-1] > max:\n                max = array[i] * array[i-1]\n    return max", "adjacent_element_product = lambda lst: max(x * y for x, y in zip(lst, lst[1:]))", "def adjacent_element_product(array):\n    m = -1000000\n    for i in range(len(array)-1):\n        m = max(m, array[i] * array[i+1])\n        \n    return m", "def adjacent_element_product(array):\n    maxp=None\n    i=1\n    while i<len(array):\n        product=array[i]*array[i-1]\n        if maxp==None or product>maxp:\n            maxp=product\n        i=i+1\n    return maxp", "def adjacent_element_product(array):\n    biggest = -1000000\n    i = 0\n    \n    while i < len(array)-1:\n        prod = array[i] * array[i+1]\n        if prod > biggest: biggest = prod\n        i += 1\n    return biggest\n", "def adjacent_element_product(lst):\n    return max(a * b for a, b in zip(lst[:-1], lst[1:]))", "def adjacent_element_product(array):\n     return max(array[i] * array[i + 1] for i in range(len(array) - 1))\n         # max product\n", "def adjacent_element_product(a):\n#     return max([x*y for x in a[:-1] for y in a[1:] ])\n    return max([a[i]*a[i+1] for i in range(0,len(a)-1)])", "def adjacent_element_product(arr):\n    return max([ e1*e2 for e1,e2 in zip(arr[1:] , arr[:-1])])", "def adjacent_element_product(array):\n    max_prod = array[0] * array[1]\n    for i in range(1,len(array)):\n        if array[i] * array[i-1] > max_prod:\n            max_prod = array[i] * array[i-1]\n    return max_prod", "def adjacent_element_product(array):\n    \n    a = []\n    \n    for i in range(0,len(array)):\n    \n        for j in range(0,len(array)):\n        \n            if abs(j-i)==1:\n        \n                p = array[i]*array[j]\n                \n                a.append(p)\n    \n\n    return max(a)\n    \n    \n", "def adjacent_element_product(a):\n    m = a[0] * a[1]\n    for i in range(len(a)):\n        try:\n            if a[i] * a[i+1] > m:\n                m = a[i] * a[i+1]\n        except:\n            return m", "def adjacent_element_product(array):\n    res = []\n    start = array[0]\n\n    for num in array[1:]:\n        res.append(start * num)\n        start = num\n    \n    return max(res)", "def adjacent_element_product(array):\n    return max([array[e]*array[e+1] for e in range(len(array)-1)])", "def adjacent_element_product(array):\n    prods = []\n    for i in range(len(array)-1):\n        prods.append(array[i]*array[i+1])\n    return max(prods)", "def adjacent_element_product(arr):\n    list = []\n    for number in range(len(arr)-1):\n        list.append(arr[number] * arr[number+1])\n    return max(list)", "def adjacent_element_product(array):\n    max_prod=array[0]*array[1]\n    \n    if len(array)>2:\n        for i in range(1,len(array)-1):\n            if array[i]*array[i+1]>max_prod:\n                max_prod= array[i]*array[i+1]\n    \n    return max_prod", "def adjacent_element_product(array):\n    max_prod = array[0] * array[1]\n    for i in range(2, len(array)):\n        temp = array[i] * array[i-1]\n        if temp > max_prod:\n            max_prod = temp\n    return max_prod", "def adjacent_element_product(array):\n    max_sum = array[0] * array[1]\n    for i in range(0,len(array)-1):\n        if array[i] * array[i+1] > max_sum:\n            max_sum = array[i] * array[i+1]\n    return max_sum", "def adjacent_element_product(array):\n    max = -99999999999\n    for i, n in enumerate(array):\n        if i < len(array) - 1 and n * array[i + 1] > max:\n            max = n * array[i + 1]\n\n    return max", "def adjacent_element_product(array):\n    index1 = 0\n    index2 = 0\n    max1 = -9999999\n    for i in range(len(array)-1):\n        if((array[i] * array[i+1]) > max1):\n            max1 = array[i] * array[i+1]\n            index1 = i\n            index2 = i+1\n    return array[index1] * array[index2]", "def adjacent_element_product(array):\n    res = []\n    for i in range(len(array) - 1):\n        ans = array[i] * array[i + 1]\n        res.append(ans)\n    return max(res)", "def adjacent_element_product(array):\n    return max(map(lambda i: array[i] * array[i + 1], range(len(array) - 1)))", "def adjacent_element_product(array):\n    max_product = array[0] * array[1]\n    \n    for index, item in enumerate(array[1:-1]):\n        next_item = array[index+2]\n        product = item * next_item\n        \n        if product > max_product:\n            max_product = product\n    \n    return max_product", "def adjacent_element_product(array):\n    return max(k*i for i,k in zip(array, array[1:]))", "def adjacent_element_product(array):\n    return max(array[i]*array[i+1] for i,x in enumerate(array[:-1]))", "from operator import mul\n\ndef adjacent_element_product(a):\n    return max(map(mul,a,a[1:]))", "\ndef adjacent_element_product(array):\n    m = array[0] * array[1]\n    for i in range(1,len(array)-1):\n        m = max(m,array[i] * array[i+1])\n    return m# max product", "def adjacent_element_product(array):\n    new_list =[]\n    for i in range (len(array)):\n        if array[i] != array[-1]:\n            new_list.append(array[i] * array[i+1])\n    new_list.sort()\n    return new_list[-1]", "def adjacent_element_product(array):\n    i = 1\n    maximum = (array[0]*array[i])\n    for c in array[:-1]:\n        if (c*array[i])> maximum:\n            maximum = (c*array[i])\n        i += 1\n    return maximum", "def adjacent_element_product(array):\n    mults = []\n    i = 0\n    while i+1 < len(array):\n        mults.append(array[i]*array[i+1])\n        i += 1\n    return max(mults)\n    \n        \n        \n", "def adjacent_element_product(array):\n    len_array = len(array)\n    products = []\n    for value in range(0, (len_array-1)):\n        products.append(array[value]*array[value+1])\n    products.sort()\n    return products[-1]", "def adjacent_element_product(a):\n    list=[]\n    for i in range(0,len(a)-1):\n        list.append(a[i]*a[i+1])\n    return max(list)\n", "\ndef adjacent_element_product(array):\n    i = 0\n    listy = []\n    while i < (len(array)-1):\n        num = int(array[i])*int(array[i+1])\n        listy.append(num)\n        i+=1\n    \n    \n    \n    return max(listy)", "def adjacent_element_product(array):\n    \n    if len(array) == 2:\n        \n        product_1 = 1\n        for element in array:\n            product_1 *= element\n        \n        return product_1\n    \n    elif len(array) >= 2:\n        \n        products = []\n        for number in range(1, len(array)):\n            product_2 = 1\n            product_2 *= array[number - 1] * array[number]\n            products.append(product_2)\n            \n        return max(products)    \n            \n        \n        \n        \n", "def adjacent_element_product(arr):\n    product = [arr[i]*arr[i+1] for i in range(len(arr)-1)]\n    print (product)\n    return max(product)", "def adjacent_element_product(array):\n    biggest = array[0] * array[1]\n    index = 1\n    while index < len(array):\n        if array[index] * array[index-1] > biggest:\n            biggest = array[index] * array[index-1]\n        index += 1\n    return biggest", "def adjacent_element_product(array):\n    num = array[0] * array[1]\n    i = 1\n    while i+1 < len(array):\n        if array[i]*array[i+1] > num:\n            num = array[i]*array[i+1]\n        i += 1\n    return num", "def adjacent_element_product(array):\n    print(array)\n    i = 1\n    rtot = array[0]*array[1]\n    while i+1 <= len(array):\n        if array[i]*array[i-1] >= rtot:\n            rtot = array[i]*array[i-1]\n            print(rtot)\n        i += 1\n    return rtot", "def adjacent_element_product(array):\n    \n    max_prod = max([ i * array[_index+1] for _index, i in enumerate(array[:-1]) ])\n        \n    return max_prod", "def adjacent_element_product(array):\n    maximum = array[0]*array[1]\n    for number in range(1, len(array)-1):\n        if array[number]*array[number+1] > maximum:\n            maximum = int(array[number])*int(array[number+1])\n    return maximum", "from functools import reduce\n\n\ndef adjacent_element_product(array):\n    return max([reduce(lambda n, m: n * m, array[x:x+2]) for x in range(len(array) - 1)])", "def adjacent_element_product(array):\n    maxp = float('-inf')\n    for i in range(1, len(array)):\n        x = array[i]\n        y = array[i-1]\n        maxp = max(maxp, x*y)\n    return maxp", "def adjacent_element_product(a):\n    return max(a[i+1]*a[i] for i in range(len(a) - 1))", "def adjacent_element_product(array):\n    res = min(array) * max(array)\n    for i, item in enumerate(array):\n        if (i + 1) < len(array):\n            if (item * array[i + 1]) >= res:\n                res = item * array[i + 1]\n    return res", "def adjacent_element_product(array):\n  products = []\n  for i in range(len(array)-1):\n    \n    product = array[i] * array[i +1]\n    products.append(product)\n  return max(products)", "def adjacent_element_product(array):\n    a = []\n    for i in range(0,len(array)-1):\n        a.append(array[i] * array[i+1])\n    a = sorted(a)\n    return a[len(a)-1]", "def adjacent_element_product(array):\n    maxpro = -111111111111\n    p = 0\n    while p < len(array)-1:\n        maxar = array[p] * array[p+1]\n        if maxar > maxpro:\n            maxpro = maxar\n        p = p + 1\n    return(maxpro)", "def adjacent_element_product(array):\n    i=0\n    c=array[0]*array[1]\n    while i<len(array)-1:\n        if array[i]*array[i+1]>c:\n            c=array[i]*array[i+1]\n        i+=1\n    return c\n", "def adjacent_element_product(array):\n    i=0\n    b=0\n    c=array[0]*array[1]\n    while i < len(array)-1:\n        b = array[i]*array[i+1]\n        if b>c:\n            c=b\n            i+=1\n        else:\n            i+=1\n    \n    return c", "def adjacent_element_product(array):\n    i=0\n    j=1\n    x=array[i]*array[i+1]\n    while i<=len(array)-2:\n        j=array[i]*array[i+1]\n        print (j)\n        i+=1\n        if j>=x:\n            x=j\n        else:\n            x=x\n    return x"]