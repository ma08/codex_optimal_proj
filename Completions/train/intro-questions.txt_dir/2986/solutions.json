["def segments(m, arr):\n    return [i for i in range(m+1) if not any(a<=i<=b for a,b in arr)]", "def segments(m, a):\n    vals = set(range(m+1))\n    for st, en in a:\n        vals -= set(range(st, en+1))\n    return sorted(vals)\n", "def segments(m, a):\n    return [p for p in range(m+1) if all(not x[0]<=p<=x[1] for x in a)]", "def segments(m, a):\n    occupied = []\n    for i in a:\n        for x in range(i[0], i[1]+1):\n            occupied.append(x)\n    \n    free = []\n    for n in range(0,m+1):\n        if n not in occupied:\n            free.append(n)\n    \n    return free\n", "def segments(m, a):\n    return [x for x in range(m + 1) if all(x not in range(A[0], A[1]+1) for A in a)]", "def segments(m, a):\n    return([i for i in range (m+1) if not any([i in range(x[0], x[1]+1) for x in a])])", "def segments(m, a):\n\n    new_list = []\n    \n    for sub_list in a:\n        new_list = new_list + list(range(sub_list[0], sub_list[1]+1))\n    \n    new_set = set(new_list)\n\n    expected_set = set(range(0, m+1))\n\n    return sorted(list(expected_set.difference(new_set)))", "def segments(m, a):\n    segments = {n for l, r in a for n in range(l, r+1)}\n    return [n for n in range(m+1) if n not in segments]\n\n# one-liner: [n for n in range(m+1) if n not in {n for l, r in a for n in range(l, r+1)}]\n", "from functools import reduce\nfrom itertools import filterfalse\n\ndef segments(m, a):\n    return list(filterfalse(reduce(set.union, (set(range(x, y+1)) for x,y in a), set()).__contains__, range(0, m+1)))", "def segments(m, a):\n    answer = [i for i in range(m+1)]\n    for i in a:\n        for j in range(i[0], i[1]+1):\n            try:\n                answer.remove(j)\n            except ValueError:\n                pass\n    return answer"]