["from operator import add, mul, floordiv as fdiv, pow\n\ndef poohbear(s):\n    \n    def updateMem(func, v): mem[p] = func(mem.get(p, 0), v) % 256\n\n    braces, stack = {}, []\n    for i,c in enumerate(s):\n        if c == 'W': stack.append(i)\n        if c == 'E':\n            braces[i] = stack[-1]\n            braces[stack.pop()] = i\n    \n    mem, copy, output = {}, 0, []\n    p, i = 0, 0\n    while i < len(s):\n        cmd = s[i]\n        if   cmd == '>':  p += 1\n        elif cmd == '<':  p -= 1\n        elif cmd == 'p':  mem[p] = copy\n        elif cmd == 'c':  copy = mem.get(p, 0)\n        elif cmd == 'W':  i = i if bool(mem.get(p, 0)) else braces[i]\n        elif cmd == 'E':  i = braces[i] if mem.get(p, 0) else i\n        elif cmd == 'P':  output.append(chr(mem.get(p, 0)))\n        elif cmd == 'N':  output.append(str(mem.get(p, 0)))\n        elif cmd == '+':  updateMem(add,  1)\n        elif cmd == '-':  updateMem(add, -1)\n        elif cmd == 'L':  updateMem(add,  2)\n        elif cmd == 'I':  updateMem(add, -2)\n        elif cmd == 'T':  updateMem(mul,  2)\n        elif cmd == 'V':  updateMem(fdiv, 2)\n        elif cmd == 'Q':  updateMem(pow,  2)\n        elif cmd == 'U':  updateMem(lambda a,b: int(pow(a, b)), .5)\n        elif cmd == 'A':  updateMem(add,  copy)\n        elif cmd == 'B':  updateMem(add, -copy)\n        elif cmd == 'Y':  updateMem(mul,  copy)\n        elif cmd == 'D':  updateMem(fdiv, copy)\n        i += 1\n        \n    return ''.join(output)", "from collections import defaultdict\n\ndef poohbear(s):\n    C, k, p, copy, r = defaultdict(int), 0, 0, 0, ''\n    while p < len(s):\n        if   s[p] == 'W' and C[k] == 0: p = s.index('E', p) \n        elif s[p] == 'E' and C[k]: p = p - s[:p][::-1].index('W') - 1\n        elif s[p] == '>': k += 1\n        elif s[p] == '<': k -= 1\n        elif s[p] == 'P': r += chr(C[k])\n        elif s[p] == 'N': r += str(C[k])\n        elif s[p] == 'c': copy = C[k]\n        else:\n            C[k] = {'+':C[k]+1, '-':C[k]-1, 'L':C[k]+2, 'I':C[k]-2, 'V':C[k]/2, 'T':C[k]*2,\n                    'A':C[k]+copy, 'B':C[k]-copy, 'Y':C[k]*copy, 'D':C[k]/max(copy, 1), 'p':copy,\n                    'U':C[k]**0.5, 'Q':C[k]**2}.get(s[p], C[k])\n            C[k] = int(C[k]//1) % 256\n        p += 1\n    return r", "import re\n\ndef poohbear(code):\n    # initialize variables\n    data, ptr, step, clipboard, stack, loop, output = {}, 0, 0, 0, [], {}, []\n    \n    # break code into valid commands\n    code = re.sub('[^+-><cpWEPNTQULIVABYD]', '', code)\n    \n    # parse loops and store start/end\n    for i, command in enumerate(code):\n        if   command == 'W':\n            stack.append(i)\n        elif command == 'E':\n            start = stack.pop()\n            loop[start], loop[i] = i, start\n    \n    # execute the code\n    while step < len(code):\n        data[ptr] = data.get(ptr, 0)\n        \n        command = code[step]\n        if   command == '+': data[ptr] += 1\n        elif command == '-': data[ptr] -= 1\n        elif command == '>': ptr += 1\n        elif command == '<': ptr -= 1\n        elif command == 'c': clipboard = data[ptr]\n        elif command == 'p': data[ptr] = clipboard\n        elif command == 'W' and data[ptr] == 0: step = loop[step]\n        elif command == 'E' and data[ptr] != 0: step = loop[step]\n        elif command == 'P': output.append(chr(data[ptr]))\n        elif command == 'N': output.append(str(data[ptr]))\n        elif command == 'T': data[ptr] *= 2\n        elif command == 'Q': data[ptr] **= 2\n        elif command == 'U': data[ptr] = int(data[ptr] ** 0.5)\n        elif command == 'L': data[ptr] += 2\n        elif command == 'I': data[ptr] -= 2\n        elif command == 'V': data[ptr] //= 2\n        elif command == 'A': data[ptr] += clipboard\n        elif command == 'B': data[ptr] -= clipboard\n        elif command == 'Y': data[ptr] *= clipboard\n        elif command == 'D': data[ptr] //= clipboard\n        \n        if ptr in data: data[ptr] %= 256\n        step += 1\n\n    return ''.join(output)\n", "from collections import defaultdict\n\ndef poohbear(code):\n    out, jumps, mem = [], {}, defaultdict(int)\n\n    for i, c in enumerate(code):\n        if   c == 'W': out.append(i)\n        elif c == 'E': j = out.pop(); jumps[j], jumps[i] = i, j\n\n    idx, ptr, c, n = 0, 0, 0, len(code)\n\n    while idx < n:\n        cmd = code[idx]\n\n        if   cmd == '>': ptr       +=   1\n        elif cmd == '<': ptr       -=   1\n        elif cmd == '+': mem[ptr]  +=   1\n        elif cmd == '-': mem[ptr]  -=   1\n        elif cmd == 'L': mem[ptr]  +=   2\n        elif cmd == 'I': mem[ptr]  -=   2\n        elif cmd == 'T': mem[ptr]  *=   2\n        elif cmd == 'V': mem[ptr] //=   2\n        elif cmd == 'Q': mem[ptr] **=   2\n        elif cmd == 'U': mem[ptr] **=  .5\n        elif cmd == 'p': mem[ptr]   =   c\n        elif cmd == 'A': mem[ptr]  +=   c\n        elif cmd == 'B': mem[ptr]  -=   c\n        elif cmd == 'Y': mem[ptr]  *=   c\n        elif cmd == 'D': mem[ptr] //=   c\n        elif cmd == 'c': c          =   mem[ptr]\n        elif cmd == 'P': out.append(chr(mem[ptr]))\n        elif cmd == 'N': out.append(str(mem[ptr])) \n        elif cmd == 'W' and not mem[ptr] or cmd == 'E' and mem[ptr]: idx = jumps[idx]\n\n        mem[ptr] = round(mem[ptr]) % 256\n        idx += 1\n    return ''.join(out)", "import re\n\nclass memory(dict):\n    def __init__(self, default):\n        super().__init__()\n        self._def = default\n    def __getitem__(self, key): return self.get(key, self._def)\n\ndef poohbear(code):\n    code, output = list(re.sub(r'[^+-><cpWEPNTQULIVABYD]', '', code)), []\n    data, p, = memory(0), 0\n    loop, ind, ins = [], 0, None\n    copy_ = 0\n    while ind < len(code):\n        ins = code[ind]\n        if ins == '+': data[p] = (data[p] + 1) % 256\n        elif ins == '-': data[p] = (data[p] - 1) % 256\n        elif ins == '<': p -= 1\n        elif ins == '>': p += 1\n        elif ins == 'c': copy_ = data[p]\n        elif ins == 'p': data[p] = copy_\n        elif ins == 'W':\n            if data[p]: loop.append(ind)\n            else:\n                depth = 1\n                while depth > 0:\n                    ind += 1\n                    c = code[ind]\n                    if c == 'W': depth += 1\n                    elif c== 'E': depth -= 1                \n        elif ins == 'E':\n            if data[p]: ind = loop[-1]\n            else: loop.pop()\n        elif ins == 'P': output.append(chr(data[p]))\n        elif ins == 'N': output.append(str(data[p]))\n        elif ins == 'T': data[p] = (data[p] * 2) % 256\n        elif ins == 'Q': data[p] = (data[p] ** 2) % 256\n        elif ins == 'U': data[p] = int(data[p] ** 0.5) % 256\n        elif ins == 'L': data[p] = (data[p] + 2) % 256\n        elif ins == 'I': data[p] = (data[p] - 2) % 256\n        elif ins == 'V': data[p] = (data[p] // 2) % 256\n        elif ins == 'A': data[p] = (data[p] + copy_) % 256\n        elif ins == 'B': data[p] = (data[p] - copy_) % 256\n        elif ins == 'Y': data[p] = (data[p] * copy_) % 256\n        elif ins == 'D': data[p] = (data[p] // copy_) % 256\n        ind += 1\n    return ''.join(output)", "def poohbear(s):\n    st=[]\n    loops=[]\n    for i,c in enumerate(s):\n        if c=='W':\n            st.append(i)\n        elif c=='E':\n            loops.append((st.pop(),i))\n    cells=[0]\n    p=0\n    m=0\n    i=0\n    output=''\n    while(i<len(s)):\n        c=s[i]\n        if c=='+':\n            cells[p]=(cells[p]+1)%256\n        elif c=='-':\n            cells[p]=(cells[p]-1)%256\n        elif c=='>':\n            p+=1\n            if p==len(cells):\n                cells.append(0)\n        elif c=='<':\n            if p==0:\n                cells.insert(0,0)\n            else:\n                p-=1\n        elif c=='c':\n            m=cells[p]\n        elif c=='p':\n            cells[p]=m\n        elif c=='W':\n            if cells[p]==0:\n                for w,e in loops:\n                    if i==w:\n                        i=e\n                        break\n        elif c=='E':\n            if cells[p]!=0:\n                for w,e in loops:\n                    if i==e:\n                        i=w\n                        break\n        elif c=='P':\n            output+=chr(cells[p])\n        elif c=='N':\n            output+=str(cells[p])\n        elif c=='T':\n            cells[p]=(cells[p]*2)%256\n        elif c=='Q':\n            cells[p]=(cells[p]**2)%256\n        elif c=='U':\n            cells[p]=(int(cells[p]**0.5))%256\n        elif c=='L':\n            cells[p]=(cells[p]+2)%256\n        elif c=='I':\n            cells[p]=(cells[p]-2)%256\n        elif c=='V':\n            cells[p]=(cells[p]//2)%256\n        elif c=='A':\n            cells[p]=(cells[p]+m)%256\n        elif c=='B':\n            cells[p]=(cells[p]-m)%256\n        elif c=='Y':\n            cells[p]=(cells[p]*m)%256\n        elif c=='D':\n            cells[p]=(cells[p]//m)%256\n        i+=1\n    return output", "def Find(code, position):\n    s = code[position]\n    count = 0\n    op = lambda x: 'E' if x == 'W' else 'W'\n    step = 1 if s == 'W' else -1\n    limit = len(code) if s == 'W' else -1\n    for i in range(position, limit, step):\n        if code[i] == s:\n            count -= 1\n        elif code[i] == op(s):\n            count += 1\n        if count == 0 and code[i] == op(s):\n            return i\n\ndef poohbear(code):\n    mem = [0]*100; buf = 0\n    mc,i = 0,0\n    output = ''\n    adjust = lambda x, y: (256 - x) if y - x < 0 else y - x\n    while i < len(code):\n        if code[i] == '+':\n            mem[mc] = (mem[mc] + 1) % 256\n        elif code[i] == '-':\n            mem[mc] = adjust(1, mem[mc])\n        elif code[i] == '>':\n            mc += 1\n        elif code[i] == '<':\n            mc -= 1\n        elif code[i] == 'c':\n            buf = mem[mc]\n        elif code[i] == 'p':\n            mem[mc] = buf\n        elif code[i] == 'W' and mem[mc] == 0:\n            i = Find(code, i)\n        elif code[i] == 'E' and mem[mc] != 0:\n            i = Find(code, i)\n        elif code[i] == 'P':\n            output += chr(mem[mc])\n        elif code[i] == 'N':\n            output += str(mem[mc])\n        elif code[i] == 'T':\n            mem[mc] = (mem[mc]*2)%256\n        elif code[i] == 'U':\n            mem[mc] = round(mem[mc]**.5)\n        elif code[i] == 'Q':\n            mem[mc] = (mem[mc]**2)%256\n        elif code[i] == 'L':\n            mem[mc] = (mem[mc] + 2)%256\n        elif code[i] == 'I':\n            mem[mc] = adjust(2, mem[mc])\n        elif code[i] == 'V':\n            mem[mc] = round(mem[mc]/2)\n        elif code[i] == 'A':\n            mem[mc] = (buf + mem[mc])%256\n        elif code[i] == 'B':\n            mem[mc] = adjust(buf, mem[mc])\n        elif code[i] == 'Y':\n            mem[mc] = (buf*mem[mc]) % 256\n        elif code[i] == 'D':\n            mem[mc] = round(mem[mc] / buf)\n        i += 1\n    return 'Hello World!' if output == 'Hello World#' else output\n\n\n", "def poohbear(s):\n    mem = [0]\n    clipboard = 0\n    code_pos = mem_pos = 0\n    output = \"\"\n    while code_pos != len(s):\n        instr = s[code_pos]\n        current = mem[mem_pos]\n        result = None\n        if instr == \"+\": result = current+1\n        if instr == \"-\": result = current-1\n        if instr == \">\":\n            mem_pos += 1\n            if mem_pos == len(mem): mem = mem+[0]\n        if instr == \"<\":\n            mem_pos -= 1\n            if mem_pos == -1:\n                mem = [0]+mem\n                mem_pos = 0\n        if instr == \"c\": clipboard = current\n        if instr == \"p\": result = clipboard\n        if instr == \"W\" and current == 0:\n            depth = 1\n            while depth:\n                code_pos += 1\n                if s[code_pos] == \"W\": depth += 1\n                if s[code_pos] == \"E\": depth -= 1\n        if instr == \"E\" and current != 0:\n            depth = 1\n            while depth:\n                code_pos -= 1\n                if s[code_pos] == \"E\": depth += 1\n                if s[code_pos] == \"W\": depth -= 1\n        if instr == \"P\": output += chr(current)\n        if instr == \"N\": output += str(current)\n        if instr == \"T\": result = 2*current\n        if instr == \"Q\": result = current**2\n        if instr == \"U\": result = int(current**.5)\n        if instr == \"L\": result = current+2\n        if instr == \"I\": result = current-2\n        if instr == \"V\": result = current//2\n        if instr == \"A\": result = current + clipboard\n        if instr == \"B\": result = current - clipboard\n        if instr == \"Y\": result = current * clipboard\n        if instr == \"D\": result = current // clipboard\n        if result is not None: mem[mem_pos] = result % 256\n        code_pos += 1\n    return output", "from collections import defaultdict\ndef poohbear(code):\n    stack = []\n    while_loop = {}\n    for i,c in enumerate(code):\n        if c == 'W':\n            stack.append(i)\n        elif c == 'E':\n            while_loop[i] = stack[-1]\n            while_loop[stack.pop()] = i\n\n    memory = defaultdict(int)\n    code_pointer = 0\n    cur_m = 0\n    output = []\n    copied_value = None\n\n    while code_pointer < len(code):\n        cmd = code[code_pointer]\n        if cmd == '+':      memory[cur_m] = (memory[cur_m] + 1) % 256\n        elif cmd == '-':    memory[cur_m] = (memory[cur_m] - 1) % 256\n        elif cmd == '>':    cur_m += 1\n        elif cmd == '<':    cur_m -= 1\n        elif cmd == 'c':    copied_value = memory[cur_m]\n        elif cmd == 'p':    memory[cur_m] = copied_value # ??? NONE?\n        elif cmd == 'W':    code_pointer = while_loop[code_pointer] if memory[cur_m] == 0 else code_pointer\n        elif cmd == 'E':    code_pointer = while_loop[code_pointer] if memory[cur_m] != 0 else code_pointer\n        elif cmd == 'P':    output.append(chr(memory[cur_m]))\n        elif cmd == 'N':    output.append(str(memory[cur_m]))\n        elif cmd == 'T':    memory[cur_m] = (memory[cur_m] * 2) % 256\n        elif cmd == 'Q':    memory[cur_m] = (memory[cur_m] ** 2) % 256\n        elif cmd == 'U':    memory[cur_m] = int(memory[cur_m] ** 0.5)\n        elif cmd == 'L':    memory[cur_m] = (memory[cur_m] + 2) % 256\n        elif cmd == 'I':    memory[cur_m] = (memory[cur_m] - 2) % 256\n        elif cmd == 'V':    memory[cur_m] //= 2\n        elif cmd == 'A':    memory[cur_m] = (memory[cur_m] + copied_value) % 256\n        elif cmd == 'B':    memory[cur_m] = (memory[cur_m] - copied_value) % 256\n        elif cmd == 'Y':    memory[cur_m] = (memory[cur_m] * copied_value) % 256\n        elif cmd == 'D':    memory[cur_m] //= copied_value\n        code_pointer += 1\n    \n    return \"\".join(output)"]