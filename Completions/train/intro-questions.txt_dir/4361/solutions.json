["from itertools import count, permutations\n\ndef next_perfectsq_perm(limit_below, k):\n    for n in count(int(limit_below**.5)+1):\n        s = str(n**2)\n        if '0' not in s:\n            sq_set = {x for x in (int(''.join(p)) for p in permutations(s)) if (x**.5).is_integer()}\n            if len(sq_set) == k:\n                return max(sq_set)", "from itertools import permutations\nfrom math import sqrt\n\ndef is_per(n):\n    return str(sqrt(int(n)))[-1] == '0'\ndef next_perfectsq_perm(lower_limit, k): \n    perfect = [i**2 for i in range(2000) if '0' not in str(i**2) if i**2 > lower_limit]\n    for i in perfect: \n        if i > lower_limit:\n            num = set()\n            per = set(permutations(str(i)))\n            tem = [int(''.join(j)) for j in per if is_per(''.join(j))]\n            if len(tem) == k:\n                num.add(i)\n                ma = max(tem)\n                break\n    return max(tem)", "from itertools import permutations\ndef next_perfectsq_perm(lower_limit, k): \n    while 1:\n        lower_limit += 1\n        if '0' not in str(lower_limit) and int(lower_limit ** 0.5 + 0.5) ** 2 == lower_limit:\n            perms = list([''.join(x) for x in set(permutations(str(lower_limit)))])\n            perms = list(map(int, perms))\n            perfects = 0\n            perfect_list = []\n            for i in perms:\n                if int(i ** 0.5 + 0.5) ** 2 == i:\n                    perfects += 1\n                    perfect_list.append(i)\n            if perfects == k:\n                return max(perfect_list)   \n", "candidates = ((sq, str(sq)) for sq in (i*i for i in range(12, 3000)))\ncandidates = ((sq, s) for sq, s in candidates if '0' not in s)\n\nd = {}  # 144: [144, 441], 256: [256, 625], ...\nsqs = {}  # 144: [144, 441], 256: [256, 625], 441: [144, 441], 625: [256, 625], ...\nfor sq, s in candidates:\n    sqs[sq] = d.setdefault(int(''.join(sorted(s))), [])\n    sqs[sq].append(sq)\n\ndef next_perfectsq_perm(lower_limit, k): \n    return sqs[min(x for x in sqs if x > lower_limit and len(sqs[x]) == k)][-1]", "from itertools import permutations\n\ndef is_perfect(square):\n    return round(square**0.5)**2 == square\n\ndef permuted(n):\n    return (int(\"\".join(p)) for p in set(permutations(str(n))))\n\ndef perfect_permutations(n):\n    return tuple(p for p in permuted(n) if is_perfect(p))\n    \ndef next_perfectsq_perm(lower_limit, k): \n    root = int(lower_limit**0.5) + 1\n    while True:\n        square = root**2\n        if not \"0\" in str(square):\n            p = perfect_permutations(square)\n            if len(p) == k:\n                return max(p)\n        root += 1\n", "from collections import *\n\nNUM_DIG = 8\npalindromes = OrderedDict()\nfor n in range(int(10 ** (NUM_DIG / 2)) + 1):\n    key = Counter(str(n ** 2))\n    if '0' not in key:\n        palindromes.setdefault(\n            frozenset(key.most_common()), []).append(n ** 2)\n\nlasts, lengths = {}, defaultdict(list)\nfor seq in palindromes.values():\n    for n in seq:\n        lengths[len(seq)].append(n)\n        lasts[n] = seq[-1]\nfor k in lengths: lengths[k].sort()\n\nfrom bisect import bisect\ndef next_perfectsq_perm(lower_limit, k):\n    return lasts[lengths[k][bisect(lengths[k], lower_limit)]]", "K_PERMS = {\n    2: [144, 256, 441, 625, 1369, 1764, 1936, 4761, 11236, 12769, 14884, 21316, 24649, 24964,\n        27556, 29584, 34596, 36864, 43264, 45369, 46656, 48841, 51984, 54289, 66564, 74529,\n        75625, 79524, 86436, 95481, 96721, 99856, 112225, 113569, 118336, 133956, 139876,\n        142884, 147456, 148225, 148996, 154449, 155236, 166464, 167281, 169744, 173889, 174724,\n        175561, 194481, 198916, 212521, 216225, 224676, 225625, 227529, 233289, 237169, 238144,\n        264196, 265225, 267289, 272484, 287296, 293764, 314721, 316969, 323761, 328329, 329476,\n        344569, 345744, 355216, 368449, 369664, 374544, 383161, 391876, 398161, 427716, 432964,\n        434281, 447561, 456976, 459684, 463761, 467856, 474721, 498436, 521284, 522729, 546121,\n        591361, 594441, 611524, 619369, 622521, 627264, 646416, 649636, 654481, 659344, 667489,\n        669124, 675684, 678976, 712336, 729316, 736164, 741321, 748225, 755161, 758641, 769129,\n        772641, 779689, 781456, 786769, 793881, 795664, 799236, 817216, 835396, 842724, 844561,\n        848241, 874225, 877969, 891136, 894916, 919681, 927369, 933156, 948676, 956484, 964324,\n        972196, 976144, 9114361],\n    3: [961, 9216, 11664, 12544, 16641, 18225, 23716, 25281, 32761, 41616, 42849, 44521, 49284,\n        52441, 72361, 81225, 82944, 131769, 141376, 149769, 164836, 165649, 197136, 319225,\n        349281, 364816, 378225, 381924, 417316, 471969, 481636, 541696, 837225, 931225, 974169,\n        7112889],\n    4: [81796, 112896, 132496, 168921, 195364, 214369, 269361, 298116, 346921, 395641, 436921,\n        543169, 962361, 4511376],\n    5: [43681, 6395841],\n    6: [7241481],\n    7: [4532641] }\n\n\ndef next_perfectsq_perm(lower_limit, k, answer = 0):\n    \n    for number in K_PERMS[k]:\n        if not answer and number > lower_limit:\n            answer = number\n        elif answer and sorted(str(number)) == sorted(str(answer)):\n            answer = number\n    \n    return answer", "from itertools import permutations, count\n\ndef next_perfectsq_perm(lower_limit, k):\n    for i in count(int(lower_limit ** 0.5) + 1):\n        j = i ** 2\n        if '0' in str(j):\n            continue\n        k_count = 0\n        matches = [j]\n        perms = set(permutations(str(j))) - set(matches)\n        for p in perms:\n            num = int(''.join(p))\n            if int(num ** 0.5) ** 2 == num:\n                matches.append(num)\n                k_count += 1\n        if k_count == k:\n            return sorted(matches)[-1]", "M,U = {},[]\ndef H(Q) :\n    R = 0\n    while Q :\n        if Q % 10 < 1 : return 0\n        R += 1 << (Q % 10 * 3)\n        Q //= 10\n    return R\nfor F in range(1,10000) :\n    F = F * F\n    R = H(F)\n    if R :\n        U.append(F)\n        M.setdefault(R,[]).append(F)\ndef next_perfectsq_perm(Q,S) :\n    for V in U :\n        if Q < V :\n            T = M.get(H(V))\n            if T and S == len(T) : return T[-1]", "import itertools\ndef next_perfectsq_perm(l, k):\n    perf = lambda n: n**0.5%1 == 0\n    while True:\n        l += 1\n        if perf(l) and '0' not in str(l):\n            r = [x for x in set([int(''.join(x)) for x in list(itertools.permutations(str(l)))]) if perf(x)]\n            if len(r) == k: return max(r)"]