["def candidates(ymd):\n    y, m, d = ymd.split('-')\n    return {ymd, f'{y}-{d}-{m}'}\n\ndef check_dates(records):\n    result = [0, 0, 0]\n    for start, end in records:\n        xs = [(dt1, dt2) for dt1 in candidates(start) for dt2 in candidates(end)\n              if dt1 <= dt2 and dt1[5:7] <= '12' >= dt2[5:7]]\n        i = 2 if len(xs) > 1 else xs[0] != (start, end)\n        result[i] += 1  # 2: uncertain, 1(True): recoverable, 0(False): correct\n    return result", "from itertools import product\n\ndef disambiguate(timestamp):\n    t = timestamp.split(\"-\")\n    return (f\"{t[0]}-{t[1+i]}-{t[2-i]}\" for i in (0, 1) if (t[1+i] != t[2-i] or i) and t[1+i] < \"13\")\n\ndef check_dates(records):\n    result = [0, 0, 0]\n    for record in records:\n        valid = [list(p) for p in product(*(disambiguate(timestamp) for timestamp in record)) if p[0] <= p[1]]\n        result[2 if len(valid) != 1 else 0 if record in valid else 1] += 1\n    return result", "from itertools import product\n\ndef check_dates(records):\n    correct, recoverable, uncertain = 0, 0, 0\n    for begin, end in records:\n        parsings = [(d1,d2) for d1,d2 in product(parse(begin), parse(end)) if d1 <= d2]\n        if len(parsings) != 1: uncertain += 1\n        elif parsings[0] == (begin,end): correct += 1\n        else: recoverable += 1\n    return [correct, recoverable, uncertain]\n\ndef parse(date):\n    y,m,d = date.split(\"-\")\n    if d <= \"12\" and m != d: yield \"-\".join([y,d,m])\n    if m <= \"12\": yield date", "from datetime import datetime as dt\nfrom itertools import product, starmap\nfrom collections import defaultdict\n\n\nCORRECT, RECOVER, UNSURE = range(3)\nTIMESTR_MODELS = ('%Y-%m-%d','%Y-%d-%m')            # wanted, inverted\n\n\ndef check_dates(records):\n    out = [0]*3\n    for r in records: out[check(*r)] += 1\n    return out\n    \ndef check(start, finish):\n    cndsS, cndsF = getPossibleDates(start), getPossibleDates(finish)\n    areOK = [ i1+i2 for(d1,i1),(d2,i2) in product(cndsS, cndsF) if d1<=d2 ]\n    \n    return ( UNSURE  if len(areOK)>1 else\n             RECOVER if areOK[0] else\n             CORRECT )\n\ndef getPossibleDates(s):\n    cnds = defaultdict(lambda:1)\n    for i,model in enumerate(TIMESTR_MODELS):\n        try: cnds[dt.strptime(s, model)] *= i\n        except ValueError: pass\n    return cnds.items()", "from datetime import date\nfrom itertools import product\n\n\ndef check_dates(records):    \n    correct, recoverable, uncertain = 0, 0, 0\n    parse = lambda s: date( *[int(d) for d in s.split(\"-\")] )\n    \n    for date_pair in records:\n        start_date, end_date = map(parse, date_pair)\n        orig_duration_valid = (end_date - start_date).days >= 0\n        \n        poss_start_dates = set( [start_date] + ([date(start_date.year, start_date.day, start_date.month)] if start_date.day <= 12 else []) )\n        poss_end_dates   = set( [ end_date ] + ([date(end_date.year,   end_date.day,   end_date.month)  ] if end_date.day   <= 12 else []) )\n        \n        only_one_possible = sum( (poss_end - poss_start).days >= 0 for poss_start, poss_end in product(poss_start_dates, poss_end_dates) ) == 1\n        \n        if orig_duration_valid and only_one_possible:\n            correct += 1\n        elif only_one_possible:\n            recoverable += 1\n        else:\n            uncertain += 1\n    \n    return [ correct, recoverable, uncertain ]", "from datetime import datetime\nfrom itertools import product\n\nFORMATS = [\"%Y-%m-%d\", \"%Y-%d-%m\"]\n\ndef check_dates(records):\n    correct     = 0\n    recoverable = 0\n    uncertain   = 0\n    for start, end in records:\n        good = set()\n        right = False\n        for i, (start_format, end_format) in enumerate(product(FORMATS, FORMATS)):\n            try:\n                start_date = datetime.strptime(start, start_format)\n                end_date   = datetime.strptime(end,   end_format)\n                if end_date>=start_date:\n                    good.add((start_date, end_date))\n                    if i == 0:\n                        right = True\n            except ValueError as e:\n                pass\n        if len(good) > 1:\n            uncertain += 1\n        elif len(good)==1:\n            if right:\n                correct += 1\n            else:\n                recoverable += 1\n    return [correct, recoverable, uncertain]", "from datetime import date\n\ndef less(d1, d2):\n    if d1 == None or d2 == None:\n        return 0\n    return 1 if d1 <= d2 else 0\n\ndef check_dates(records):\n    print(records)\n    correct = recoverable = uncertain = 0\n    for interval in records:\n        start = interval[0].split('-')\n        end = interval[1].split('-')\n        try:\n            a, b, c = map(int, (start[0], start[1], start[2]))\n            start1 = date(a, b, c)\n        except:\n            start1 = None\n        try:\n            a, b, c = map(int, (start[0], start[2], start[1]))\n            start2 = date(a, b, c)\n        except:\n            start2 = None\n        try:\n            a, b, c = map(int, (end[0], end[1], end[2]))\n            end1 = date(a, b, c)\n        except:\n            end1 = None\n        try:\n            a, b, c = map(int, (end[0], end[2], end[1]))\n            end2 = date(a, b, c)\n        except:\n            end2 = None\n        \n        \n        combinations = less(start1, end1) + less(start1, end2) + less(start2, end1) + less(start2, end2)\n        if start1 == start2:\n            combinations -= 1\n        if end1 == end2:\n            combinations -= 1\n        if start1 == start2 and end1 == end2:\n            combinations -= 1\n\n        if less(start1, end1) == 1 and combinations == 1:\n            correct += 1\n        elif combinations == 1:\n            recoverable += 1\n        else:\n            uncertain += 1\n        \n    return [correct, recoverable, uncertain]", "from datetime import date\n\ndef less(d1, d2):\n    if d1 == None or d2 == None:\n        return 0\n    \n    return 1 if d1 <= d2 else 0\n\ndef check_dates(records):\n    correct = recoverable = uncertain = 0\n    for interval in records:\n        start = interval[0].split('-')\n        end = interval[1].split('-')\n        try:\n            start1 = date(int(start[0]), int(start[1].lstrip('0')), int(start[2].lstrip('0')))\n        except:\n            start1 = None\n        try:\n            start2 = date(int(start[0]), int(start[2].lstrip('0')), int(start[1].lstrip('0')))\n        except:\n            start2 = None\n        try:\n            end1 = date(int(end[0]), int(end[1].lstrip('0')), int(end[2].lstrip('0')))\n        except:\n            end1 = None\n        try:\n            end2 = date(int(end[0]), int(end[2].lstrip('0')), int(end[1].lstrip('0')))\n        except:\n            end2 = None\n        \n        combinations = less(start1, end1) + less(start1, end2) + less(start2, end1) + less(start2, end2)\n        if start1 == start2:\n            combinations -= 1\n        if end1 == end2:\n            combinations -= 1\n        if start1 == start2 and end1 == end2:\n            combinations -= 1\n\n        if less(start1, end1) == 1 and combinations == 1:\n            correct += 1\n        elif combinations == 1:\n            recoverable += 1\n        else:\n            uncertain += 1\n        \n    return [correct, recoverable, uncertain]", "def check_dates(records):\n    correct = 0; recoverable = 0; uncertain = 0\n    for rec in records:\n        rec = DateRange(*rec)\n        if rec.correct: correct += 1\n        elif rec.recoverable: recoverable += 1\n        elif rec.uncertain: uncertain += 1\n    return [correct,recoverable,uncertain]\n\nclass Date:\n    def __init__(self,date):\n        self.date = [int(n) for n in date.split('-')]\n        if 12<self.date[1]: self.date[2], self.date[1] = self.date[1:]; self.corrected = True\n        else: self.corrected = False\n        self.ambiguous = self.date[1]<13 and self.date[2]<13 and self.date[1]!=self.date[2]\n    def swap(self):\n        date = self.date[:]; date[2], date[1] = date[1:]\n        return Date('-'.join([str(d) for d in date]))\n    def __le__(self,other):\n        if self.date[0]!=other.date[0]: return self.date[0]<other.date[0]\n        if self.date[1]!=other.date[1]: return self.date[1]<other.date[1]\n        return self.date[2]<=other.date[2]\n\nclass DateRange:\n    def __init__(self,start,end):\n        self.start = Date(start); self.end = Date(end)\n        self.correct = None; self.recoverable = None; self.uncertain = None\n        self.ambiguous = self.start.ambiguous or self.end.ambiguous\n        if not self.ambiguous and self.start<=self.end:\n            if self.start.corrected or self.end.corrected: self.recoverable = True\n            else: self.correct = True\n        else:\n            self.start = [self.start]; self.end = [self.end]\n            if self.start[0].ambiguous: self.start.append(self.start[0].swap())\n            if self.end[0].ambiguous: self.end.append(self.end[0].swap())\n            self.ranges = [(self.start[0],self.end[0])]\n            if self.end[0].ambiguous: self.ranges.append((self.start[0],self.end[1]))\n            if self.start[0].ambiguous:\n                self.ranges.append((self.start[1],self.end[0]))\n                if self.end[0].ambiguous: self.ranges.append((self.start[1],self.end[1]))\n            self.ranges = [r for r in self.ranges if r[0]<=r[1]]\n            if len(self.ranges)==1:\n                if self.start[0]==self.ranges[0][0] and self.end[0]==self.ranges[0][1]: self.correct = True\n                else: self.recoverable = True\n            else: self.uncertain = True\n", "def check_dates(A):\n    Z=[0, 0, 0]\n    for X in A:\n        y0,m0,d0=map(int,X[0].split('-'))\n        y1,m1,d1=map(int,X[1].split('-'))\n        \n        if y0<y1 and 12<d0 and 12<d1:Z[0]+=1    \n        elif y0<y1 and m0==d0 and 12<d1:Z[0]+=1    \n        elif y0<y1 and m0==d0 and m1==d1:Z[0]+=1    \n        elif (m1==d1)and(12<m0 or 12<d0):Z[0]+=1    \n        elif y0==y1 and m0==d0 and(12<m1 or 12<d1):Z[0]+=1   \n        elif y0==y1 and m0==d0 and m1==d1:Z[0]+=1    \n        elif y0==y1 and 12<d0 and 12<d1:Z[0]+=1\n        elif y0==y1 and m0<=m1<d0<=12<d1:Z[0]+=1\n        elif y0==y1 and m0<m1==d1<d0:Z[0]+=1\n        elif y0==y1 and m0==d1<m1<d0:Z[0]+=1 \n        elif y0==y1 and d1<m0<m1<=d0:Z[0]+=1                \n        elif y0==y1 and d1<m0==d0<m1:Z[0]+=1    \n        \n        elif y0==y1 and (m0<=12<d0) and (m1<=12<d1):Z[1]+=1   \n        elif y0==y1 and m1<=m0<=d1<=12<d0:Z[1]+=1     \n        elif y0==y1 and d0<=m1<m0<=12<d1:Z[1]+=1     \n        elif y0==y1 and d0<m1==d1<m0:Z[1]+=1    \n        elif y0==y1 and d0==d1<m1<m0:Z[1]+=1        \n        elif y0==y1 and m1<m0<d0==d1:Z[1]+=1    \n        elif y0==y1 and m1<m0==d0<d1:Z[1]+=1   \n        elif y0==y1 and m1<=m0<d1<d0:Z[1]+=1 \n        elif y0==y1 and m1<d0<d1<=m0:Z[1]+=1\n        elif y0==y1 and m1==d0<d1<m0:Z[1]+=1\n        elif y0==y1 and d1<d0<m1<=m0:Z[1]+=1\n        \n        else:Z[2]+=1\n    return Z"]