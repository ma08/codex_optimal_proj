["def chess_board(rows, columns):\n    return [[\"OX\"[(row+col)%2] for col in range(columns)] for row in range(rows)]", "def chess_board(rows, columns):\n    ans=[]\n    for i in range(1,rows+1,1):\n        l=[]\n        for j in range(i,columns+i,1):\n            if j%2!=0:\n                l.append('O')\n            else:\n                l.append('X')\n        ans.append(l)\n    return ans", "chess_board = lambda rows, cols: [['X' if (y + x) % 2 else 'O' for x in range(cols)] for y in range(rows)] ", "chess_board=lambda r,c:[['OX'[i+j&1]for i in range(c)]for j in range(r)]", "def chess_board(rows, columns):\n    board = []\n    for row in range(rows):\n        if row % 2:\n            board.append([\"X\" if not column % 2 else \"O\" for column in range(columns)])\n        else:\n            board.append([\"O\" if not column % 2 else \"X\" for column in range(columns)])\n    return board", "def chess_board(a, b):\n    return [list(\"OXXO\"[i%2::2] * (b // 2 + 1))[:b] for i in range(a)]", "from itertools import cycle\n\ndef chess_board(rows, columns):\n    result = []\n    for i in range(rows):\n        grida = cycle(['O', 'X'])\n        gridb = cycle(['X', 'O'])\n        result.append([next(gridb) if i % 2  else next(grida) for x in range(columns)])\n    return result", "def chess_board(rows, columns):\n    return [[\"OX\"[(row + column) % 2] for column in range(columns)] for row in range(rows)]", "def chess_board(rows, columns):\n    line = [\"X\", \"O\"] * columns\n    return [line[:columns] if r % 2 else line[1:columns+1] for r in range(rows)]", "chess_board = lambda r, c: [[\"OX\"[(i+j)%2] for j in range(c)] for i in range(r)]"]