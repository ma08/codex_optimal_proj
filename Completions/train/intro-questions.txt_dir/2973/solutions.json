["def array_conversion(arr):\n    sign = 0\n    while len(arr) > 1:\n        sign = 1^sign\n        arr = list(map(lambda x, y: x+y, arr[0::2],arr[1::2]) if sign else map(lambda x, y: x*y, arr[0::2],arr[1::2]))\n    return arr[0]", "array_conversion=c=lambda a,p=0:a[1:]and c([[x+y,x*y][p]for x,y in zip(*[iter(a)]*2)],1-p)or a[0]", "def array_conversion(l):\n    iter = 0\n    while len(l) > 1:\n        iter += 1\n        l = [[l[i] * l[i + 1], l[i] + l[i + 1]][iter % 2]  for i in range(0, len(l) - 1, 2)]\n    return l[0]", "from itertools import count\n\ndef array_conversion(arr):\n    for i in count(1):\n        it = iter(arr)\n        arr = [a+b if i%2 else a*b for a,b in zip(it,it)]\n        if len(arr) == 1: return arr.pop()", "from operator import add, mul\nfrom itertools import count\n\ndef array_conversion(arr):\n    for i in count():\n        if len(arr) == 1: return arr[0]\n        arr = list(map((add, mul)[i&1], arr[::2], arr[1::2]))", "from operator import add, mul\n\ndef array_conversion(a):\n    i, f = 1, [mul, add]\n    while len(a) > 1:\n        a = [f[i](x, y) for x, y in zip(a[::2], a[1::2])]\n        i ^= 1\n    return a[0]", "from operator import add, mul\n\ndef array_conversion(arr):\n    iteration = 0\n    while len(arr) > 1:\n        iteration += 1\n        arr = [(add if iteration & 1 else mul)(a, b) for a, b in zip(arr[::2], arr[1::2])]\n    return arr[0]", "def array_conversion(arr):\n    ops = [int.__mul__, int.__add__]\n    c = 1\n    while len(arr) != 1:\n        arr = [ops[c](x, y) for x, y in zip(arr[::2], arr[1::2])]\n        c = 1 - c\n    return arr[0]", "def array_conversion(a,add=True):\n    while len(a) > 1:\n        a = [x+y if add else x*y for (x,y) in zip(*[iter(a)]*2)]; add = not add\n    return a[0]", "from math import log2\n\ndef array_conversion(arr):\n    for it in range(int(log2(len(arr)))):\n         arr = [arr[i] * arr[i+1] if it % 2 else arr[i] + arr[i+1] for i in range(0, len(arr), 2)]\n    return arr[0]\n"]