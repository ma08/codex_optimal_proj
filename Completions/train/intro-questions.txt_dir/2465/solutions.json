["class Solution:\n    def divisorGame(self, N: int) -> bool:\n        return N%2 == 0\n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        m = 0 \n        if N > 1: \n            for x in range(1, N):\n                N -= x \n                m += 1 \n            if m % 2 == 0:\n                return False \n            else:\n                return True \n            \n", "class Solution:\n    memo = {}\n    def divisorGame(self, N: int) -> bool:\n        return self.move(N)\n    def move(self, N):\n        if N in self.memo:\n            return self.memo[N]\n        if N == 2:\n            return True\n        for f in self.factors(N):\n            if self.move(N-f) == False:\n                self.memo[N] = True\n                return True\n        self.memo[N] = False\n        return False\n    def factors(self,n):\n        a = []\n        for x in range(1,n):\n            if n % x == 0:\n                a.append(x)\n        return a\n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        memo = set()\n        def check(factor, player):\n            if factor==1:\n                return player!='A'\n            if factor in memo:\n                return False\n            player = 'A' if player=='B' else 'B'\n            \n            for i in range(1, 1 + (factor//2)):\n                if factor % i==0:\n                    memo.add(factor)\n                    if check(factor-i, player):\n                        return True\n        return check(N, 'A')\n\n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        memo = [None]*(N+1)\n        ans = self.canWin(N, memo)\n        return ans\n        \n    def canWin(self, N, memo) :\n        if N<=1 :\n            return False\n        if memo[N] is not None :\n            return memo[N]\n        for i in range(1, N//2 + 1) :\n            if N%i == 0 :\n                if not self.canWin(N-i, memo) :\n                    memo[N] = True\n                    return True\n        memo[N] = False\n        return False\n        \n        \n        \n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        dp=[False for i in range(N+1)]\n        for i in range(N+1):\n            for x in range(1,i//2+1):\n                if i%x==0 and (not dp[i-x]):\n                    dp[i]=True\n                    break\n        return dp[N]            \n        \n", "import math\nclass Solution:\n    def divisorGame(self, N: int) -> bool:\n        m = [0 for x in range(N+1)]\n        m[1] = 0\n        for x in range(2, N+1):\n            temp = []\n            i = 1\n            while i < math.sqrt(x):\n                if x%i == 0:\n                    if x/i == i:\n                        temp.append(i)\n                    else:\n                        temp.append(i)\n                        if x/i != x:\n                            temp.append(int(x/i))\n                i += 1\n            \n            for y in temp:\n                print(('x-y', x-y))\n                if m[x-y] == 0:\n                    m[x] = 1\n        \n        return True if m[N]==1 else False\n", "class Solution:\n    def divisorGame(self, n: int) -> bool:\n        return self.helper(n, {})\n    \n    def helper(self, n, memo):\n        if n == 1:\n            return False\n        elif n in memo:\n            return memo[n]\n        else:\n            for f in self.factors(n):                \n                if self.helper(n-f, memo) == False:\n                    memo[n] = True\n                    return True\n            memo[n] = False\n            return False\n        \n    def factors(self, n):\n        l = []\n        i = 1\n        while i**2 <= n:\n            if n % i == 0:\n                l.append(i)\n            i += 1\n        for num in l:\n            if num**2< n and num > 1:\n                l.append(int(n/num))\n                \n        return l", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        dp = [False for i in range(N+1)]\n        for i in range(N+1):\n            for j in range(1, i//2+1):\n                if i % j == 0 and (not dp[i - j]):\n                    dp[i] = True\n                    break\n        return dp[N]", "\n\nclass Solution:\n    def divisorGame(self, N: int) -> bool:\n        return recurse_game(N, 0)\n\n        \ndef find_factors(n):\n    factors = []\n    for i in range(1,n):\n        if n%i==0:\n            factors.append(i)\n    return factors\n\n\nlookup = {}\n\ndef recurse_game(N, P):\n    if (N,P) in lookup:\n        return lookup[(N,P)]\n    \n    if N<=1 and P==0:\n        lookup[(N,P)] = False\n        return False\n    elif N<=1 and P==1:\n        lookup[(N,P)] = True\n        return True\n        \n    next_P = 0 if P == 1 else 1\n    \n    results = []\n    for factor in find_factors(N):\n        results.append(recurse_game(N-factor,next_P))\n        \n    # print(N,P,results)\n        \n    if P == 0:\n        if True in results:\n            lookup[(N,P)] = True\n            return True\n        else:\n            lookup[(N,P)] = False\n            return False\n        \n    if P == 1:\n        if False in results:\n            lookup[(N,P)] = False\n            return False\n        else:\n            lookup[(N,P)] = True\n            return True\n        \n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        return N % 2 == 0", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        game = [False for i in range(N+1)]\n        \n        for i in range(2,N+1):\n            for j in range(1,i):\n                if i%j == 0 and game[i-j] == False:\n                    game[i] = True\n                    break\n                    \n        return game[N]", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        if N <= 1:\n            return False\n        dp = [False] * (N + 1)\n        for i in range(2, N + 1):\n            for j in range(1, i // 2 + 1):\n                if i % j == 0:\n                    nextN = i - j\n                    if dp[nextN] == False:\n                        dp[i] = True\n                        \n        return dp[N]", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        dp = [False for _ in range(N+1)]\n        \n        for i in range(N+1):\n            for j in range(1, i//2+1):\n                # dp[i-j] make sure Bob fails at step i-j\n                if i % j == 0 and dp[i-j] == False:\n                    dp[i] = True\n        \n        return dp[-1]", "def doS(N,arr):\n    if (N==1):\n        return False\n    \n    if not(arr[N] == None):\n        return arr[N]\n      \n    for i in range(1,N):\n        if(N%i==0):\n            if not doS(N-i,arr):\n                arr[i]=True\n                # print(N-i,arr)  \n                return True\n    \n    arr[N]=False\n    return False\n        \n\nclass Solution:\n    def divisorGame(self, N: int) -> bool:\n        \n        arr = [None]*(N+1)\n        print(arr)\n        return doS(N,arr)        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        table = dict()\n        res  = self.helper(N, 0, table)\n        return res\n        \n        \n    def helper(self, N:int, numRds: int, ht: dict) -> bool:\n        soln = False\n        \n        # Bob wins base case\n        if N == 1 and numRds % 2 == 0: return False \n        \n        # Alice wins base case\n        if N == 1 and numRds % 2 != 0: return True\n        \n        # Check to see if the current N values has been processed\n        if ht.get(N, None) != None: return ht[N]\n        ht[N] = False\n        # Obtain list of factors\n        fact = findFactors(N)\n        \n        # If not in the table process N against all of its factors\n        for num in fact:\n            ht[N] = ht[N] or self.helper(N - num, numRds + 1, ht)\n            \n        return ht[N]\n        \n        \n        \ndef findFactors(num: int) -> list:\n    res = []\n    loPtr, hiPtr = 1, num\n    while hiPtr > loPtr:\n        if num % loPtr == 0: \n            res.append(loPtr)\n            if num // loPtr != num: res.append(num // loPtr)\n            hiPtr = num // loPtr\n        loPtr += 1\n    return res", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        dp = [False] * (N + 1)\n        for i in range(N + 1):\n            for j in range(1, i//2 + 1):\n                if i%j == 0 and not dp[i - j]:\n                    dp[i] = True\n                    break\n        return dp[-1]\n", "class Solution:\n    @lru_cache(maxsize=None)\n    def divisorGame(self, N: int) -> bool:\n      if N == 2:\n        return True\n      \n      options = []\n      \n      for x in range(1, N // 2):\n        if N % x == 0:\n          options.append(N - x)\n      \n      return any(map(\n        lambda x: not self.divisorGame(x),\n        options,\n      ))", "class Solution:\n    def __init__(self):\n        self.memo = {}\n    def findfactors(self, N):\n        n = N//2\n        fs = []\n        for i in range(2, n+1):\n            if N%i==0:\n                fs.append(i)\n        return fs+[1]\n    \n    def div(self, N):\n        if N in self.memo:\n            return self.memo[N]\n        fs = self.findfactors(N)\n        if N==1:\n            self.memo[N] = 0\n            return 0\n        else:\n            nf = len(fs)\n            vals = [0]*nf\n            for i in range(nf):\n                vals[i] = self.div(N-fs[i])\n            self.memo[N] = 1+max(vals)\n            return self.memo[N]\n    \n    def divisorGame(self, N: int) -> bool:\n        ans = self.div(N)\n        if ans%2==0:\n            return False\n        else:\n            return True\n        \n", "class Solution:\n    \n    #this function will return all the possible nums after one move\n    \n    \n    def divisorGame(self, N: int) -> bool:\n        \n        \n        return N & 1 == 0", "class Solution:\n\n    @lru_cache(None)\n    def divisorGame(self, N: int) -> bool:\n        if N == 0:\n            return False\n        if N == 1:\n            return False\n        if N == 2:\n            return True\n        \n        @lru_cache(None)\n        def divs(N):\n            out = []\n            for i in range(1, (N//2) + 1):\n                if N % i == 0:\n                    out.append(i)\n            return out\n        \n        moves = divs(N)\n        \n        for move in moves:\n            if not self.divisorGame(N-move):\n                return True\n        \n        return False\n        \n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        turns = [{2:1}, {2:0}]\n        \n        def play(turn, N):\n            if N in turns[turn]:\n                return turns[turn][N]\n            \n            if turn:\n                win = all(play(0, N-x) for x in range(1, N) if N % x == 0)\n            else:\n                win = any(play(1, N-x) for x in range(1, N) if N % x == 0)\n            \n            return turns[turn].setdefault(N, win)\n        \n        return play(0, N)", "from collections import defaultdict as dd\n\nclass Solution:\n    def __init__(self):\n        self.d = dd()\n    \n    def divisorGame(self, n: int) -> bool:\n        return self.__will_win(n)\n    \n    def __will_win(self, n: int):\n        \n        for i in range(1, n):\n            if n % i != 0:\n                continue\n            \n            if n - i in self.d:\n                wins = self.d[n - i]\n            else:\n                wins = self.__will_win(n - i)\n                self.d[n - i] = wins\n            \n            if not wins: \n                # this player choses this i as the next one will lose\n                return True\n                        \n        return False\n\n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        if N == 1:\n            return False\n        elif N == 2:\n            return True\n        \n        dp = [False for _ in range(N+1)]\n        dp[2] = True\n        \n        for a in range(3, N+1):\n            for b in range(1, a):\n                if a%b == 0 and dp[a-b] == False:\n                    dp[a] = True\n                    break\n        \n        return dp[-1]", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        dp = [False]*(N+1)\n        for i in range(2,N+1):\n            j = 1\n            while j<i:\n                if i%j==0 and dp[i-j]==False:\n                    dp[i] = True\n                    break\n                j+=1          \n        return dp[-1]\n            \n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        \n        if N <= 3:\n            return (N % 2) == 0\n        \n        dp = [False for _ in range(N+1)]\n        dp[2] = True\n        \n        for i in range(3, N+1):\n            for j in range(1, i):\n                if i % j == 0 and dp[i-j] == False:\n                    dp[i] = True\n                    break\n                    \n        return dp[-1]\n                    \n        \n        \n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        if N == 1:\n            return False\n        elif N == 2:\n            return True\n        \n        dp = [False]*(N+1)\n        dp[1] = True\n        dp[2] = True\n        \n        for i in range(3, N+1):\n            for j in range(1, i):\n                if i%2 == 0:\n                    dp[i] = True\n                    break\n        print(dp)\n        return dp[-1]", "class Solution:\n    @lru_cache(None)\n    def divisorGame(self, N: int) -> bool:\n        if N == 1:\n            return False\n        return any(not self.divisorGame(N-x) if N % x == 0 else False for x in range(1, N))", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        \n        self.visited = collections.defaultdict(bool)\n        \n        def alice_wins(N, alice = True):\n            \n            if N == 1:\n                return True if not alice else False\n            \n            if N in self.visited:\n                return self.visited[N]\n            \n            for i in range(1,N):\n                if not N%i:\n                    if alice:\n                        self.visited[N] = alice_wins(N-i,alice=False)\n                    else:\n                        self.visited[N] = alice_wins(N-i)\n            \n            return self.visited[N]\n        \n        return alice_wins(N)\n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        if N % 2 == 0:\n            return True\n        else:\n            return False", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        if N<2:\n            return False\n        dp=[False]*(N+1)\n        dp[2]=True\n        \n        for i in range(2,N+1):\n            for x in range(1,i):\n                if i%x==0 and not dp[i-x]:\n                    dp[i]=True\n        return dp[-1]\n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        table = dict()\n        res  = self.helper(N, 0, table)\n        return res\n        \n        \n    def helper(self, N:int, numRds: int, ht: dict) -> bool:\n        soln = False\n        \n        # Bob wins base case\n        if N == 1 and numRds % 2 == 0: return False \n        \n        # Alice wins base case\n        if N == 1 and numRds % 2 != 0: return True\n        \n        # Check to see if the current N values has been processed\n        if ht.get(N, None) != None: \n            a = 5\n            return ht[N]\n        \n        # Obtain list of factors\n        fact = findFactors(N)\n        \n        # If not in the table process N against all of its factors\n        ht[N] = False        # Base case to ensure no false positives\n        for num in fact:\n            ht[N] = ht[N] or self.helper(N - num, numRds + 1, ht)\n            \n        return ht[N]\n        \n        \n        \ndef findFactors(num: int) -> list:\n    res = []\n    for val in range(1, num):\n        if num % val == 0: res.append(val)        \n    return res", "class Solution:\n  def divisorGame(self, N: int) -> bool:\n    # dp solution\n    d = {}\n    def dp(v):\n      if v not in d:\n        d[v] = False\n        for w in range(1, v):\n          if v % w == 0:\n            d[v] = d[v] or not dp(v-w)\n      return d[v]\n    out = dp(N)\n    return out", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        res=[False]*(N+1)\n        for i in range(2,N+1):\n            if i%2 == 0 and res[int(i/2)] == False:\n                res[i] = True\n                continue\n            for j in range(1,int(math.sqrt(i))):\n                if i %j == 0:\n                    if res[i-j] == False or (j!=1 and res[i-int(i/j)] == False):\n                        res[i] = True\n                        break\n        return res[N]\n            \n        \n        \n\n            \n        \n    \n        \n        \n", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        dp = [False, False]\n        for x in range(2, N+1):\n            dp.append(any([not dp[x-i] for i in range(1, int(math.sqrt(x))+1) if x % i == 0]))\n        return dp[-1]", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n      return win_game(N)\n    \nfrom functools import lru_cache\n@lru_cache(maxsize=None)\ndef win_game(N):\n  return any(not win_game(N-x) for x in range(1,N) if N % x == 0)", "class Solution:\n    def divisorGame(self, N: int) -> bool:\n        \n        def divisors(N):\n            if N == 1:\n                return [1]\n            \n            res = []\n            for n in range(1, int(N**0.5)+1):\n                if N % n == 0:\n                    res.append(n)\n            return res\n        \n        # Initial conditions\n        table = {\n            1 : False,\n            2 : True,\n            3 : False\n        }\n        \n        def compute(i):\n            if i in table:\n                return table[i]\n            \n            divs = divisors(i)\n            next_nums = [i-d for d in divs]\n            \n            for n in next_nums:\n                status = compute(n)\n                \n                if status == False:\n                    table[i] = True\n                    return True\n            table[i] = False\n            return False\n        \n        \n#         for n in range(3, N+1):\n#             divs = divisors(n)\n            \n#             for d in divs:\n#                 next_num = n - d\n#                 if table[next_num] == False:\n#                     # We want the next number to be a losing number\n#                     table[n] = True\n#                     break\n#             if n not in table:\n#                 # If all next numbers are winning, then this is a losing number\n#                 table[n] = False\n\n        return compute(N)"]