["class Solution:\n     def repeatedStringMatch(self, A, B):\n         \"\"\"\n         :type A: str\n         :type B: str\n         :rtype: int\n         \"\"\"\n         \n         if not set(B).issubset(set(A)):\n             return -1\n         \n         max_rep = len(B) // len(A) + 3\n         A_new = A\n         \n         for i in range(1,max_rep):\n             if B in A_new:\n                 return i\n             A_new += A\n         return -1", "class Solution:\n     def repeatedStringMatch(self, A, B):\n \n         times = 1\n         tmp = A\n         if (not set(B).issubset(set(A))):\n             return -1\n         maxTime = math.ceil(len(B) / len(A))\n         while True:\n             if B in A:\n                 break\n             elif (times <= maxTime):\n                 A += tmp\n                 times += 1\n             else:\n                 return -1\n         return times", "class Solution:\n     def repeatedStringMatch(self, A, B):\n         \"\"\"\n         :type A: str\n         :type B: str\n         :rtype: int\n         \"\"\"\n         def check(index):\n             return all(A[(i+index) % len(A)] == c\n                        for i, c in enumerate(B))\n \n         M, p = 10**9+7, 113\n         p_inv = pow(p, M-2, M)\n         q = (len(B)+len(A)-1) // len(A)\n \n         b_hash, power = 0, 1\n         for c in B:\n             b_hash += power * ord(c)\n             b_hash %= M\n             power = (power*p) % M\n \n         a_hash, power = 0, 1\n         for i in range(len(B)):\n             a_hash += power * ord(A[i%len(A)])\n             a_hash %= M\n             power = (power*p) % M\n \n         if a_hash == b_hash and check(0): return q\n \n         power = (power*p_inv) % M\n         for i in range(len(B), (q+1)*len(A)):\n             a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv\n             a_hash += power * ord(A[i%len(A)])\n             a_hash %= M\n             if a_hash == b_hash and check(i-len(B)+1):\n                 return q if i < q*len(A) else q+1\n \n         return -1\n", "class Solution(object):\n     # Rabin-Karp Algorithm (rolling hash)\n     def repeatedStringMatch1(self, A, B):\n         \"\"\"\n         :type A: str\n         :type B: str\n         :rtype: int\n         \"\"\"\n         def check(index):\n             return all(A[(i+index) % len(A)] == c\n                    for i, c in enumerate(B))\n \n         M, p = 10**9+7, 113\n         p_inv = pow(p, M-2, M)\n         q = (len(B)+len(A)-1) // len(A)\n \n         b_hash, power = 0, 1\n         for c in B:\n             b_hash += power * ord(c)\n             b_hash %= M\n             power = (power*p) % M\n \n         a_hash, power = 0, 1\n         for i in range(len(B)):\n             a_hash += power * ord(A[i%len(A)])\n             a_hash %= M\n             power = (power*p) % M\n \n         if a_hash == b_hash and check(0): return q\n \n         power = (power*p_inv) % M\n         for i in range(len(B), (q+1)*len(A)):\n             a_hash = (a_hash-ord(A[(i-len(B))%len(A)])) * p_inv\n             a_hash += power * ord(A[i%len(A)])\n             a_hash %= M\n             if a_hash == b_hash and check(i-len(B)+1):\n                 return q if i < q*len(A) else q+1\n \n         return -1\n     #KMP\n     def repeatedStringMatch(self, A, B):\n         \"\"\"\n         :type A: str\n         :type B: str\n         :rtype: int\n         \"\"\"\n  \n         def get_fail(s):\n             f = [0] * (len(s) + 1)\n             for i in range(1, len(s)):\n                 j = f[i]\n                 while j and s[i] != s[j]: j = f[j]\n                 if s[i] == s[j]: j += 1\n                 f[i + 1] = j\n             return f\n  \n         # kmp\n         f = get_fail(B)\n         j = 0\n         vis = {0}\n         cnt = 1\n         while True:\n             for i in range(len(A)):\n                 while j and A[i] != B[j]: j = f[j]\n                 if A[i] == B[j]: j += 1\n                 if j == len(B):\n                     return cnt\n             if j in vis: return -1 \n             vis.add(j)\n             cnt += 1\n         return -1\n \n     \n     \n", "class Solution:\n     def repeatedStringMatch(self, A, B):\n         k = int(len(B) / len(A))\n         m = \"\"\n         h = A + A[0]\n         for i in range(len(B)-1):\n             if B[i:i+2] not in h: return -1\n         for i in range(k):\n             m += A\n         while B not in m:\n             m += A\n             k += 1\n             if k>100: return -1\n         return k\n", "class Solution:\n     def repeatedStringMatch(self, A, B):\n         \"\"\"\n         :type A: str\n         :type B: str\n         :rtype: int\n         \"\"\"\n         if set(list(B)) > set(list(A)):\n             return -1\n         \n         \n         \n         \n         l_b = len(B)\n         pointer_b = 0\n         l_a = len(A)\n         pointer_a = 0\n \n         L = []\n         while pointer_a < l_a:\n             if A[pointer_a] == B[pointer_b]:\n                 L.append(pointer_a)\n             pointer_a += 1\n \n         if L == []:\n             return -1\n \n         for pointer_a in L:\n             times = 1\n             while pointer_b < l_b:\n                 if pointer_a == l_a:\n                     pointer_a = 0\n                     times += 1\n                 if B[pointer_b] == A[pointer_a]:\n                     pointer_b += 1\n                     pointer_a += 1\n                     continue\n                 else:\n                     break\n             if pointer_b == l_b:\n                 return times\n             else:\n                 pointer_b = 0\n         return -1\n \n \n \n", "class Solution:\n     def repeatedStringMatch(self, A, B):\n         k = int(len(B) / len(A))\n         m = \"\"\n         h = A + A[0]\n         for i in range(len(B)-1):\n             if B[i:i+2] not in h: return -1\n         for i in range(k):\n             m += A\n         while B not in m:\n             m += A\n             k += 1\n             if k>100: return -1\n         return k\n", "class Solution:\n     def repeatedStringMatch(self, A, B):\n         \"\"\"\n         :type A: str\n         :type B: str\n         :rtype: int\n         \"\"\"\n         if A == B or B in A:\n             return 1\n         if A not in B:\n             if B not in (A+A):\n                 return -1\n             else:\n                 return 2\n         else:\n             count,i = 1, B.index(A)\n             if i != 0:\n                 if B[:i] != A[-i:]:\n                     return -1\n                 else:\n                     count = 2\n             while i+ 2*len(A) < len(B) and A == B[i+len(A):i+2*len(A)]:\n                 count += 1\n                 i = B.index(A, i+len(A))\n             if i == len(B) - len(A):\n                 return count\n             else:\n                 if B[i+len(A):] != A[:len(B)-i-len(A)]:\n                     return -1\n                 return count+1", "class Solution:\n     def repeatedStringMatch(self, A, B):\n         \"\"\"\n         :type A: str\n         :type B: str\n         :rtype: int\n         \"\"\"\n         for i in range(len(A)):\n             if A[i] == B[0]:\n                 divisible = True if (len(B)-(len(A)-i))%len(A) == 0 else False\n                 time = 1 + (len(B)-(len(A)-i))//len(A) if divisible else 1 + (len(B)-(len(A)-i))//len(A) + 1\n                 repeatA = A*time\n                 if repeatA[i:i+len(B)] == B:\n                     return time\n         return -1", "class Solution:\n     def repeatedStringMatch(self, a, b):\n         \"\"\"\n         :type A: str\n         :type B: str\n         :rtype: int\n         \"\"\"\n         if a is None or len(a) ==0 or b is None or len(b) == 0:\n             return -1\n         if a == b:\n             return 1\n         kmp = [0 for _ in range(len(b)+1)]\n         j = 0\n         for i in range(1, len(b)):\n             if b[j] == b[i]:\n                 j += 1\n                 kmp[i] = j\n             else:\n                 if j == 0:\n                     i += 1\n                 else:\n                     j = kmp[j-1]\n         j = 0\n         for i in range(len(a)):\n             while j < len(b) and a[(i+j)%len(a)] == b[j]:\n                 j += 1\n             if j == len(b):\n                 return -(-(i+j)//len(a))\n             j = kmp[j-1]\n         return -1", "class Solution:\n     def repeatedStringMatch(self, text, pattern):\n         n, m = len(text), len(pattern)\n         \n         base, prime = 256, 257\n         \n         bpow = base**(m-1) % prime\n \n         def check(i):\n             for j in range(m):\n                 if text[(i + j) % n] != pattern[j]:\n                     return False\n             return True\n         \n         def compute_hash(s):\n             n, h = len(s), 0\n             for i in range(m):\n                 c = s[i % n]\n                 h = (h * base + ord(c)) % prime\n             return h\n \n         def update_hash(h, old, new):\n             dh = (ord(old) * bpow) % prime\n             h = (h - dh + prime) % prime\n             h = (h * base + ord(new)) % prime\n             return h\n \n         p = compute_hash(pattern)\n         t = compute_hash(text)\n         \n         for i in range(n):\n             if t == p and check(i):\n                 return 1 + (i + m - 1) // n\n             t = update_hash(t, text[i], text[(i + m) % n])\n         return -1\n"]