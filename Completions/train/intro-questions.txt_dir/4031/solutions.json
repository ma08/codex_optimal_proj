["def interpreter(code, tape):\n    tape = list(map(int, tape))\n    ptr = step = loop = 0\n    \n    while 0 <= ptr < len(tape) and step < len(code):\n        command = code[step]\n        \n        if loop:\n            if   command == \"[\": loop += 1\n            elif command == \"]\": loop -= 1\n        \n        elif command == \">\": ptr += 1\n        elif command == \"<\": ptr -= 1\n        elif command == \"*\": tape[ptr] ^= 1        \n        elif command == \"[\" and tape[ptr] == 0: loop += 1\n        elif command == \"]\" and tape[ptr] == 1: loop -= 1\n    \n        step += 1 if not loop else loop // abs(loop)\n    \n    return \"\".join(map(str, tape))", "def interpreter(code, tape):\n\n    p, tapeP, tape = 0, 0, list(tape)\n    \n    stack, bracketMove = [], {}\n    for i,c in enumerate(code):\n        if c == '[': stack.append(i)\n        elif c == ']':\n          bracketMove[i] = stack[-1]\n          bracketMove[stack.pop()] = i\n    \n    while p < len(code) and 0 <= tapeP < len(tape):\n        if   code[p] == \"*\":                            tape[tapeP] = \"0\" if tape[tapeP] == \"1\" else \"1\"\n        elif code[p] == \"<\":                            tapeP -= 1\n        elif code[p] == \">\":                            tapeP += 1\n        elif (code[p] == \"[\" and tape[tapeP] == \"0\") \\\n             or (code[p] == \"]\" and tape[tapeP] != \"0\"):  p = bracketMove[p]\n        p += 1\n    \n    return \"\".join(tape)", "def jumps(code):\n    stack = []\n    skip_to = dict()\n    return_to = dict()\n    for i, c in enumerate(code):\n        if c == '[':\n            stack.append(i)\n        elif c == ']':\n            opening, closing = stack.pop(), i\n            skip_to[opening] = closing\n            return_to[closing] = opening\n    return (skip_to, return_to)\n\ndef run_one_instruction(code, tape, pc, pointer, skip_to, return_to):\n    instruction = code[pc]\n    if instruction == '>':\n        pointer += 1\n    elif instruction == '<':\n        pointer -= 1\n    elif instruction == '*':\n        tape[pointer] ^= 1\n    elif instruction == '[':\n        if tape[pointer] == 0:\n            pc = skip_to[pc]\n    elif instruction == ']':\n        if tape[pointer]:\n            pc = return_to[pc]\n    return (pc, pointer)\n\ndef should_terminate(pc, max_pc, pointer, max_pointer):\n    return pc > max_pc or pointer < 0 or pointer > max_pointer\n\ndef interpreter(code, tape):\n    tape = [int(c) for c in tape]\n    max_pointer = len(tape) - 1\n    pointer = 0\n    max_pc = len(code) - 1\n    pc = 0\n    skip_to, return_to = jumps(code)\n    while not should_terminate(pc, max_pc, pointer, max_pointer):\n        pc, pointer = run_one_instruction(code, tape, pc, pointer, skip_to, return_to)\n        pc += 1\n    return ''.join(str(cell) for cell in tape)", "def interpreter(code, tape):\n    p = 0\n    c = 0\n    li = list(tape)\n    left = {}\n    right = {}\n    stk = []\n    for x in range(len(code)):\n        if code[x] == '[':\n            stk.append(x)\n        elif code[x] == ']':\n            sb = stk.pop()\n            left[str(sb)] = x\n            right[str(x)] = sb\n    while c < len(code):\n        if p < 0 or p >= len(tape):\n            return ''.join(li)\n        if code[c] == '[':\n            if li[p] == '0':\n                c = left[str(c)]\n        elif code[c] == ']':\n            if li[p] != '0':\n                c = right[str(c)]\n        elif code[c] == '*':\n            li[p] = str(abs(int(li[p])-1))\n        elif code[c] == '>':\n            p += 1\n        elif code[c] == '<':\n            p -= 1\n        c += 1\n    return ''.join(li)", "def interpreter(code, tape):\n    t = list(map(int, tape))\n    position = address = depth = 0\n    while -1 < position < len(tape) and address < len(code):\n        if depth:\n            depth       += code[address] is \"[\"\n            depth       -= code[address] is \"]\"\n        else:\n            t[position] ^= code[address] is \"*\"\n            depth       += code[address] is \"[\" and not t[position]\n            depth       -= code[address] is \"]\" and     t[position]\n            position    += code[address] is \">\"\n            position    -= code[address] is \"<\"\n        address += 1 - 2 * (depth < 0)\n    return \"\".join(map(str, t))\n", "def interpreter(code, tape):\n    pointer = 0\n    pointer_stack = []\n    code_pointer = 0\n    tape_length = len(tape)\n    code_length = len(code)\n    tape = [c for c in tape]\n    \n    while True:\n        if code_pointer >= code_length:\n            break\n        command = code[code_pointer]\n        \n        if command == '>':\n            pointer += 1\n            if pointer >= tape_length: break\n        elif command == '<':\n            pointer -= 1\n            if pointer < 0: break\n        elif command == '*':\n            tape[pointer] = '0' if tape[pointer] == '1' else '1'\n        elif command == '[':\n            if tape[pointer] == '0':\n                counter = 1\n                while counter != 0:\n                    code_pointer += 1\n                    if code[code_pointer] == '[':\n                        counter += 1\n                    elif code[code_pointer] == ']':\n                        counter -= 1\n            else:\n                pointer_stack.append(code_pointer)\n        elif command == ']':\n            if tape[pointer] == '1':\n                code_pointer = pointer_stack[-1]\n            else:\n                pointer_stack.pop()\n        code_pointer += 1\n        \n    return ''.join(tape)\n", "def interpreter(code, tape):\n    cells = list(map(int, tape))\n    cell_p, command_p = 0, -1\n    scope_stack = [(0, len(code))]\n    while True:\n        command_p += 1\n        if command_p >= len(code) or cell_p >= len(cells) or cell_p < 0: break\n        command = code[command_p]\n        if command == '>': cell_p += 1\n        elif command == '<': cell_p -= 1\n        elif command == '*': cells[cell_p] = int(not cells[cell_p])\n        elif command == '[':\n            scope_end_p = code.rfind(']', scope_stack[-1][0], scope_stack[-1][1])\n            if not cells[cell_p]: command_p = scope_end_p\n            else: scope_stack.append((command_p, scope_end_p))\n        elif command == ']': \n            if cells[cell_p]: command_p = scope_stack[-1][0]\n            else: scope_stack.pop()\n    return ''.join(list(map(str, cells)))\n", "def interpreter(s, tape):\n    m, pointer, j = list(map(int, tape)), 0, 0\n    find, find_ = [i for i, j in enumerate(s) if j == '['],[i for i, j in enumerate(s) if j == ']']\n    opened, closed = {i: j for i, j in zip(find, find_[::-1])}, {i: j for i, j in zip(find_[::-1], find)} # open and closed braces\n    while j < len(s) and 0<=pointer<len(m):\n        if s[j] == \"*\" :             m[pointer] ^= 1\n        elif s[j] == '>' :           pointer += 1\n        elif s[j] == '<' :           pointer -= 1\n        elif s[j] == \"[\":\n            if m[pointer] == 0 :  j = opened[j]\n        elif s[j] == ']':\n            if m[pointer] == 1 :  j = closed[j]\n        j += 1\n    return \"\".join(map(str, m))", "def interpreter(code, t):\n    print((code,t))\n    tape = list(t)\n    f = [n for n,x in enumerate(list(code)) if x=='[']\n    l = [n for n,x in enumerate(list(code)) if x==']']\n    l.reverse()\n    print((f,l))\n    i, x, curr = 0, 0, 0\n    while i!=len(code) and x>-1 and x<len(tape):\n        if x>-1 and x<len(tape): curr = int(tape[x])\n        if code[i]=='>': x+=1\n        if code[i]=='<': x-=1\n        if code[i]=='*' and x>-1 and x<len(tape): \n            if tape[x]=='1': tape[x]='0'\n            else: tape[x]='1'\n        if code[i]=='[' and curr==0: \n            if f!=None:\n                i = l[f.index(i)]\n            else: break\n        elif code[i]==']' and curr==1: \n            if l!=None:\n                i = f[l.index(i)]\n            else: break\n        i+=1\n    return ''.join(tape)\n", "def interpreter(code, tape):\n    pos = 0\n    tape = list(map(int, list(tape)))\n    pos_code = 0\n    while pos_code < len(code) and pos < len(tape) and pos > -1:\n        instruction = code[pos_code]\n        if instruction == '>':\n            pos += 1\n        elif instruction == '<':\n            pos -= 1\n        elif instruction == '*':\n            if tape[pos] == 0:\n                tape[pos] = 1\n            else:\n                tape[pos] = 0\n        elif instruction == '[':\n            if tape[pos] == 0:\n                open = 1\n                for i in range(pos_code + 1, len(code)):\n                    if code[i] == '[':\n                        open += 1\n                    elif code[i] == ']':\n                        open -= 1\n                        if open == 0:\n                            pos_code = i\n                            break\n                            \n        elif instruction == ']':\n            if tape[pos] != 0:\n                closed = 1\n                for i in range(pos_code - 1, -1, -1):\n                    if code[i] == ']':\n                        closed += 1\n                    elif code[i] == '[':\n                        closed -= 1\n                        if closed == 0:\n                            pos_code = i\n                            break\n        pos_code += 1\n    return ''.join(map(str, tape))"]