["def combs(a, b):\n    return min(mesh(a, b), mesh(b, a))\n\ndef mesh(a, b):\n    for i in range(len(a)):\n        for j, k in zip(a[i:], b):\n            if j + k == '**': break\n        else:\n            return max(i + len(b), len(a))\n    return len(a) + len(b)            ", "def combs(comb1, comb2):\n    options = []\n    for i in range(max(len(comb1), len(comb2))+1):\n        if ('*','*') not in zip(' '*i+comb1, comb2):\n            options.append( max( len(comb1)+i, len(comb2) ) )\n        if ('*','*') not in zip(comb1, ' '*i+comb2):\n            options.append( max( len(comb1), len(comb2)+i ) )\n    return min(options)", "def to_bin(comb):\n    s = ''.join(('1' if d == '*' else '0' for d in comb))\n    return (int(s, 2))\n\ndef shifter(comb1, comb2):\n    b1, b2 = to_bin(comb1), to_bin(comb2)\n    sh = 0\n    while b1 & (b2 << sh):\n        sh += 1\n    return max(len(comb1), len(comb2) + sh)\n\ndef combs(comb1, comb2):\n    return min(shifter(comb1, comb2), shifter(comb2, comb1))", "def combs(comb1, comb2):\n    c1 = int(comb1.replace('*', '1').replace('.', '0'), 2)\n    c2 = int(comb2.replace('*', '1').replace('.', '0'), 2)\n    def r(x, y):\n        if x.__xor__(y) == x + y:\n            return max(x.bit_length(), y.bit_length())\n        return r(x<<1,y)\n    return min(r(c1,c2), r(c2,c1))", "def combs(comb1, comb2):\n    return min((next(max(i + len(c2), len(c1)) for i in range(len(c1 + c2)) if not (\"*\", \"*\") in list(zip((c1 + \".\" * len(c2))[i:], c2))) for c1, c2 in ((comb1, comb2), (comb2, comb1))))\n\n\n# very ugly one-liner, I wouldn't do this for real. But I find the clean way is overkill.\n", "def combo(*letters):\n    if set(letters) == {'*'} : return 'X'\n    if set(letters) == {'.'} : return '.'\n    return '*'\n    \n\ndef combs(*combs):\n    print(combs)\n    combos = []\n    combs = sorted(combs, key=len)\n    combs = [combs[0]+'.'*len(combs[1]), '.'*len(combs[0])+combs[1]]\n    for _ in range(len(combs[1])):\n        combos.append(''.join(combo(a,b) for a,b in zip(*combs)).strip('.'))\n        combs[0] = '.' + combs[0]\n        combs[1] = combs[1] + '.'\n            \n    return min(len(c) for c in combos if 'X' not in c)\n    \n    \n    \n        \n        \n        \n", "c,combs=lambda s:int(s.translate({42:49,46:48}),2),lambda a,b:(lambda u,v:min(len(bin(x|y))-2for x,y in((u<<-min(0,n),v<<max(0,n))for n in range(-len(b),len(a)+1))if x&y<1))(c(a),c(b))", "def passage(comb1, comb2):\n    for i in range(len(comb1)):\n        cover = 0\n        for j, s in enumerate(comb1[i:]):\n            if j == len(comb2):\n                return len(comb1)\n            if s == comb2[j] == \"*\":\n                break\n            cover += 1\n        else:\n            return len(comb1) + len(comb2) - cover\n    return len(comb1 + comb2)\n\n\ndef combs(comb1, comb2):\n    comb2, comb1 = sorted([comb1, comb2], key=lambda x: len(x))\n    return min(passage(comb1, comb2), passage(comb1[::-1], comb2[::-1]))\n    \n\n            \n", "def combs(c1, c2):\n    n = len(c1)\n    m = len(c2)\n    c2 = n*'.'+c2+n*'.'\n    \n    min_len = 100\n    for sh in range(n+m+1):\n        l = n + (sh-n)*(sh>n) + (m-sh)*(m>sh)\n        fit = True\n        for k in range(n):\n            if (c2[sh+k]+c1[k]).count('*') == 2:\n                fit = False\n        if fit:\n            min_len = min(min_len,l)\n            \n    return min_len\n", "def combs(comb1, comb2):\n    n1, n2 = len(comb1), len(comb2)\n    c1 = int(comb1.replace('*', '1').replace('.', '0'), 2)\n    c2 = int(comb2.replace('*', '1').replace('.', '0'), 2)\n    return min(next(max(n1, i + n2) for i in range(1, 11) if c1 & (c2 << i) == 0),\n               next(max(n2, i + n1) for i in range(1, 11) if c2 & (c1 << i) == 0))"]