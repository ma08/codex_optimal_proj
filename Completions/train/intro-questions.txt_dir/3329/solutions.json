["\"\"\"\n***************************************\n*   O(n) time complexity solution !   *\n***************************************\n\"\"\"\n\ndef longest_palindrome (s):\n\n    maxPal, tmpPal = 0, 1\n    count_dct = {}\n    inPal = False\n    \n    for i,l in enumerate(s):\n    \n        count_dct[l] = count_dct.get(l,0) + 1\n        \n        if not inPal and count_dct[l] >= 2:            # might encounter a palindrome, there...\n            if l == s[i-1]:                            # ... palindrome with double character in the middle\n                inPal = True\n                tmpPal = 2\n            \n            elif l == s[i-2]:                          # ... palindrome with one \"peak\" character in the middle\n                inPal = True\n                tmpPal = 3\n        \n        elif inPal and l == s[max(0, i-tmpPal-1)]:     # still in a palindrome...\n                tmpPal += 2\n            \n        else:                                          # goes out of this palindrome\n            inPal = False\n            tmpPal = 1\n        \n        maxPal = max(maxPal, tmpPal)\n    \n    return maxPal", "def longest_palindrome (s):\n    if not s: return 0\n    substrings = [s[i:j] for i in range(0,len(s)) for j in range(i,len(s)+1)]\n    return max(len(s) for s in substrings if s == s[::-1])", "def longest_palindrome (s):\n    return max((n for n in range(len(s), 0, -1) for i in range(len(s)-n+1) if s[i:i+n] == s[i:i+n][::-1]), default=0)", "def longest_palindrome (s):\n    if s: return max(map(len, filter(palindrome, substrings(s))))\n    else: return 0\n    \ndef palindrome (s):\n    return s[::-1] == s\n    \ndef substrings (s):\n    return [s[i:j+1] for i in range(0, len(s)) for j in range(i, len(s))]", "def longest_palindrome (s):\n\n  longest = 0\n\n  for j in range(1, len(s)+1):\n    for i in range(j):\n      t = s[i:j]\n      if t == t[::-1]:\n        longest = max(longest, len(t))\n  \n  return longest"]