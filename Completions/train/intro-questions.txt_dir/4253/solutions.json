["def solve(n,k):\n    maxGcd = 2*n // (k * (k+1))\n    for gcd in range(maxGcd, 0, -1):\n        last = n-gcd * k*(k-1)//2\n        if not last % gcd:\n            return [gcd*x if x != k else last for x in range(1,k+1)]\n    return []", "solve=lambda n,k: [n] if k==1 else (lambda r: r[-1] if len(r) else [])(list(filter(lambda a: a[-1]>0 and a[-1] > a[-2] and not a[-1]%a[0], ([j*i for j in range(1,k)]+[int(n-k*(k-1)/2*i)] for i in range(1,int(n/2)+1)))))", "def solve(n,k):\n    d=int(2*n/(k*(k+1)))\n    for i in range(d,0,-1):\n        if n%i==0:\n            d=i\n            break\n    if d==0:\n        return []\n    r=[d*i for i in range(1,k)]\n    r.append(n-sum(r))\n    return r", "def solve(n, k):\n    if n <= 0: return []\n    if k == 1: return [n]\n    s = k * (k + 1) // 2\n    for d in range(n // s, 0, -1):\n        if n % d != 0: continue\n        return [d * i for i in range(1, k)] + [n - k * (k - 1) // 2 * d]\n    return []", "def solve(n, k):\n    b, r = 2*n // (k*(k+1)), 1\n    if not b: return []\n    for x in range(1, int(n**0.5)+1):\n        if n%x: continue\n        if r < x <= b: r = x\n        if r < n//x <= b: r = n//x\n    return [r*i for i in range(1, k)] + [n - (r*k*(k-1)//2)]", "def unorderedPartitions(targetNum, targetSize, minNum = 1):\n    if targetSize == 1:\n        return [[targetNum]]\n    partitions = []\n    for partNum in range(minNum, targetNum // targetSize + 1):\n        partitions += [[partNum] + part for part in unorderedPartitions(targetNum - partNum, targetSize - 1, partNum + 1)]\n        return partitions # return first found partition only\n\ndef solve(n, k):\n    factors = set()\n    for f in range(1, int(n ** 0.5) + 1):\n        if n % f == 0:\n            factors.add(f)\n            factors.add(n // f)\n    factors = sorted(factors, reverse = True)\n    # minimum sum of (n // gcd)\n    minSum = k * (k + 1) // 2\n    for factor in factors:\n        if factor * minSum > n:\n            continue\n        partition = unorderedPartitions(n // factor, k)[0]\n        if len(partition) == len(set(partition)):\n            return [x * factor for x in partition]\n    return []", "def solve(n,k):\n    x = int(n/k)\n    if x <= 1:\n        return []\n    def check(y):\n        while y > 0:\n            z = [i*y for i in range(1, k+1)]\n            if sum(z) == n:\n                return z\n            elif sum(z) < n:\n                break\n            elif sum(z) > n:\n                pass\n            y -= 1\n        return z\n    y = x\n    z = check(y)\n    mod = n - sum(z[:-1])\n    if mod%z[0] == 0:\n        return z[:-1] + [mod]\n    while y > 0:\n        y -= 1\n        z = check(y)\n        mod = n - sum(z[:-1])\n        if mod%z[0] == 0:\n            return z[:-1] + [mod]\n", "def solve(n,k):\n    psum = (k * (k+1)) / 2\n    if n >= psum:\n        min_int = n // psum\n        while min_int > 0:\n            if n % min_int == 0:\n                return populate(n,min_int,k)\n            min_int -= 1\n    return []\n\ndef populate(n,s,k):\n    output = []\n    m = n\n    for i in range(1, k):\n        output.append(i*s)\n        m -= i*s\n    output.append(m)\n    return output\n"]