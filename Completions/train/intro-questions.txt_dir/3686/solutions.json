["import re\ndef calculate(input):\n    try:\n        return eval(re.sub(r'(\\d+)', lambda m: str(int(m.group(1))), input))\n    except:\n        return False", "import re\ndef calculate(s):\n    try:\n        s = re.sub(r'(?<!\\d)0+(0|[1-9]\\d*)', lambda m: m.group(1), s)\n        s = re.sub(r'\\d+(?!\\.)', lambda m: m.group() + '.0', s)\n        return eval(s)\n    except:\n        return False", "import math\ndef solve(s: list, mp=0):\n    LHS = s.pop(0)\n    while len(s) > 0:\n        #\n        op = s[0]\n        #\n        p = 1 if op in '+-' else 2\n        if p < mp: break\n        p += 1\n        s.pop(0)  #drop the operator because it being used\n        #\n        RHS = solve(s, p)\n        if   op == '+': LHS+=RHS\n        elif op == '-': LHS-=RHS\n        elif op == '*': LHS*=RHS\n        elif RHS  != 0: LHS/=RHS\n        else:           return math.nan\n    return LHS\n\ndef calculate(s):\n    try:\n        s=s.replace(' ', '')\n    except:\n        return False\n    #\n    dim = len(s)\n    #\n    if dim == 0: return False\n    #\n    for c in s: \n        if not (c in '0123456789.+-*/'): return False\n    for i in range(dim-1):\n        if s[i] in '+-*/' and s[i+1] in '+-*/': return False\n    #\n    exp = []\n    i=0\n    for j,c in enumerate(s):\n        if i==j:\n            pass\n        elif c in ['+','-','*','/']:\n            try:\n                exp.append(float(s[i:j]))\n            except:\n                return False\n            exp.append(s[j])\n            i=j+1\n    try:\n        exp.append(float(s[i:]))\n    except:\n        return False\n    #\n    v = solve(exp)\n    #\n    if math.isnan(v):             return False\n    if float(v) == float(int(v)): return int(v)\n    return v", "from re import sub\n\ndef calculate(input):\n    try:\n        return eval(sub(r'([^\\d])0+(\\d)', r'\\1\\2', input))\n    except:\n        return False", "import re\n\ndef calculate(s):\n    try:    return eval(re.sub(r'\\b0+(?=[1-9])', '', s))\n    except: return False", "import re\n\ndef calculate(input):\n    try:\n        for n in re.findall(\"\\d+\", input):\n            input = input.replace(n, (n.lstrip(\"0\") or \"0\"))\n        return eval(input)\n    except: return False", "import functools as ft\nimport math\n\nops = ['*', '/', '+', '-']\n\n\ndef SanitizeExpression(expression):\n    return expression.replace(\"+-\", \"-\").replace(\"-+\", \"-\").replace(\"--\", \"+\")\n    pass\n\n\ndef ExtendList(arr, value, op):\n    arr.extend(value.split(op))\n    return arr\n\n\ndef LastIndexOfAny(expression, operators, startIndex):\n    arr = [expression[0:startIndex].rfind(x) for x in operators]\n    arr.sort()\n    return arr[-1]\n    pass\n\n\ndef IndexOfAny(expression, operators, startIndex):\n    arr = [x + startIndex for x in [expression[startIndex:].find(x) for x in operators] if x != -1]\n    if len(arr) == 0:\n        arr = [-1]\n    arr.sort()\n    return arr[0]\n    pass\n\n\ndef FloatToString(value):\n    return \"%.30f\" % value\n    pass\n\n\ndef EvaluateSimpleExpression(expression):\n    numberText = expression.split(ops[0])\n    numberText = ft.reduce(lambda r, s: ExtendList(r, s, ops[2]), numberText, [])\n    numberText = ft.reduce(lambda r, s: ExtendList(r, s, ops[3]), numberText, [])\n    numberText = ft.reduce(lambda r, s: ExtendList(r, s, ops[1]), numberText, [])\n\n    numbers = [float(x) for x in numberText if x != '']\n\n    minusCount = expression.count('-')\n\n    if expression.count('*') > 0:\n        return numbers[0] * numbers[1] * math.pow(-1, minusCount)\n\n    if expression.count('/') > 0:\n        return numbers[0] / numbers[1] * math.pow(-1, minusCount)\n\n    if expression.count('-') > 0:\n        return numbers[0] - numbers[1]\n\n    return numbers[0] + numbers[1]\n    pass\n\n\ndef ResolveSimpleExpression(expression, operatorIndex):\n    startIndex = LastIndexOfAny(expression, ops, operatorIndex - 1) + 1\n    indexNext = IndexOfAny(expression, ops, operatorIndex + 2)\n\n    if indexNext == -1:\n        length = len(expression)\n    else:\n        length = indexNext\n\n    length -= startIndex\n\n    return expression[startIndex:startIndex + length]\n    pass\n\n\ndef EvaluateSimpleInComplexExpression(expression, operatorIndex):\n    simple = ResolveSimpleExpression(expression, operatorIndex)\n    simpleAns = EvaluateSimpleExpression(simple)\n    if math.fabs(simpleAns) < 1e-10:\n        simpleAns = 0\n        pass\n\n    insertIndex = expression.find(simple)\n\n    return expression[0:insertIndex] + FloatToString(simpleAns) + expression[insertIndex + len(simple):]\n    pass\n\n\ndef SimplifyExpressionByOperatorsRec(expression, applyNegative, multiplier, operators):\n    if expression[0] == '+':\n        expression = expression[1:]\n\n    if applyNegative and expression[0] == '-':\n        multiplier *= -1\n        expression = expression[1:].replace(\"+\", \"X\").replace(\"-\", \"+\").replace(\"X\", \"-\")\n        pass\n\n    indexArr = [x for x in [expression.find(op) for op in operators] if x > 0]\n    if len(indexArr) > 0:\n        indexArr.sort()\n        index = indexArr[0]\n\n        expression = EvaluateSimpleInComplexExpression(expression, index)\n        expression = SanitizeExpression(expression)\n\n        return SimplifyExpressionByOperatorsRec(expression, applyNegative, multiplier, operators)\n        pass\n\n    try:\n        return FloatToString(float(expression) * multiplier)\n    except:\n        return expression\n    pass\n\n\ndef SimplifyExpressionByOperators(expression, applyNegative, operators):\n    return SimplifyExpressionByOperatorsRec(expression, applyNegative, 1, operators)\n\n\ndef EvaluateComplexExpression(expression):\n    result = SimplifyExpressionByOperators(expression, False, ['*', '/'])\n\n    return SimplifyExpressionByOperators(result, True, ['+', '-'])\n    pass\n\n\ndef EvaluateBracketExpression(expression):\n    closeIndex = expression.find(')')\n    if closeIndex >= 0:\n        openIndex = expression[0:closeIndex].rfind('(')\n        startIndex = openIndex + 1\n        length = closeIndex - startIndex\n\n        complexExp = expression[startIndex:closeIndex]\n        resolved = EvaluateComplexExpression(complexExp)\n\n        expression = expression[0:openIndex] + str(resolved) + expression[openIndex + length + 2:]\n        expression = SanitizeExpression(expression)\n\n        return EvaluateBracketExpression(expression)\n        pass\n\n    return EvaluateComplexExpression(expression)\n    pass\n\n\ndef calculate(expression):    \n    try:\n        test = 'string' + expression\n    except:\n        return False\n    \n    expression = str(expression).replace(\" \", \"\")        \n    if expression == '':\n        return 0\n    \n    expression = SanitizeExpression(expression)\n\n    try:\n        return float(EvaluateBracketExpression(expression))\n    except:\n        return False\n    pass\n\n", "from re import sub\n\ndef calculate(s):\n    try: return eval(sub(r'\\b0+(?=\\d)', '', s))\n    except: return 0", "class Calculator(object):\n\n    operators = {'+': lambda x,y: x+ y,\n                 '-': lambda x, y: x - y,\n                 '*': lambda x, y: x * y,\n                 '/': lambda x, y: x / y }\n    high_pre = ['*', '/']\n\n    def __init__(self):\n        self.operand = []\n        self.operator = []\n\n    def parse_string(self, string):\n        index = 0\n        while index < len(string):\n            end = index + 1\n            while end < len(string) and string[end] not in list(self.operators.keys()):\n                end += 1\n            try:\n                self.operand.append(float(string[index:end]))\n            except:\n                return False\n            if end < len(string):\n                self.operator.append(string[end])\n            index = end + 1\n        return True\n\n    def evaluate(self, string = \"\"):\n        if string == \"\":\n            string = \"0\"\n\n        valid = self.parse_string(string)\n        if not valid:\n            return False\n\n        while len(self.operand) != 1:\n            operator_index = len(string)\n            for op in self.high_pre:\n                if op in self.operator:\n                    operator_index = min(operator_index, self.operator.index(op))\n            if operator_index == len(string):\n                operator_index = 0\n            x = self.operand[operator_index]\n            y = self.operand[operator_index + 1]\n            op = self.operator[operator_index]\n            try:\n                self.operand[operator_index] = self.operators[op](x, y)\n            except:\n                return False\n            self.operand.pop(operator_index + 1)\n            self.operator.pop(operator_index)\n\n        return self.operand[0]\n        \n\ndef calculate(input):\n    if type(input) != str:\n        return False\n    return Calculator().evaluate(input)\n", "digits = '0123456789'\nops = '+-/*'\n\ndef calc(expr):\n    r = []\n    i = 0\n    t = len(expr)\n    c = ''\n    s = ''\n    left = 0\n    right = 0\n    cur_idx = 0\n    while i < t:\n        c = expr[i]\n        if c in digits:\n            if not s:\n                s = c\n            elif s[-1] in digits:\n                s += c\n            else:\n                r += [s]\n                s = c\n        elif c == ' ':\n            pass\n        elif c in ops:\n            r += [s] if s != '' else []\n            r += [c]\n            s = ''\n        elif c == '(':\n            left = 1\n            right = 0\n            cur_idx = i\n            while i < t and left != right:\n                i += 1\n                if expr[i] == '(':\n                    left += 1\n                elif expr[i] == ')':\n                    right += 1\n            r += [calc(expr[cur_idx+1:i])]\n        i += 1\n    r += [s] if s != '' else []\n    r_new = []\n    for item in r:\n        try:\n            r_new.append(float(item))\n        except ValueError:\n            r_new.append(item)\n    r = list(r_new)\n    r_new = []\n    i = 0\n    t = len(r)\n    while i < t:\n        if r[i] == '-':\n            if type(r[i+1])==float:\n                r_new.append(-r[i+1])\n            elif r[i+1] == '-':\n                sign = 1\n                while r[i+1] == '-':\n                    sign *= -1\n                    i += 1\n                r_new.append(sign * r[i])\n                i -= 1\n            else:\n                r_new.append(r[i])\n                r_new.append(r[i+1])\n            i += 2\n        else:\n            r_new.append(r[i])\n            i += 1\n    r_new = [d for d in r_new if d != '']\n    while '*' in r_new or '/' in r_new:\n        t = len(r_new)\n        mul_idx = r_new.index('*') if '*' in r_new else t\n        div_idx = r_new.index('/') if '/' in r_new else t\n        if mul_idx == 0 or div_idx == 0:\n            raise Exception()\n        cur_idx = min(mul_idx, div_idx)\n        new_numb = r_new[cur_idx-1] * r_new[cur_idx+1] if cur_idx == mul_idx else r_new[cur_idx-1] / r_new[cur_idx+1]\n        r_new = r_new[:cur_idx-1] + [new_numb] + r_new[cur_idx+2:]\n    return sum([d for d in r_new if d != '+'])\n    \n\ndef calculate(x):\n    if x == '':\n        return False\n    try:\n        return calc(x)\n    except:\n        return False"]