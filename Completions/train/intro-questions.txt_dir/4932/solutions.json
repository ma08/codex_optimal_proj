["def find_solution(m):\n    return [j for j,r in enumerate(m) if r[0]^m[0][0]] + [len(m)+i for i,b in enumerate(m[0]) if not b]", "find_solution = lambda m: [n for n, r in enumerate(m) if r[0]] + [n for n, c in enumerate(m[0],len(m)) if not m[0][0] ^ c]", "def find_solution(puzzle):\n    n, sol = len(puzzle), []\n    for i in range(n):\n        if puzzle[i][0] ^ 1:\n            sol.append(i)\n    for i in range(1, n):\n        if puzzle[0][i] ^ 1 ^ (sol and sol[0] == 0):\n            sol.append(n + i)\n    return sol", "import copy\n\ndef find_solution(puzzle):\n    moveset = []\n    while(True):\n        # Find first rows with most 0's\n        move_to_exe = 0\n        max_zeros = 0\n        for i in range(len(puzzle) * 2):\n            score = count_zeros(i, puzzle)\n            if score > max_zeros:\n                max_zeros = score\n                move_to_exe = i\n        if max_zeros == 0:\n            return moveset\n        moveset.append(move_to_exe)\n        if move_to_exe < len(puzzle):\n            puzzle[move_to_exe] = [0 if y == 1 else 1 for y in puzzle[move_to_exe]]\n        else:\n            index = move_to_exe - len(puzzle)\n            for i in range(len(puzzle)):\n                puzzle[i][index] = 0 if puzzle[i][index] == 1 else 1\n        \ndef count_zeros(move, puzzle):\n    count = 0\n    # Row toggle\n    if move < len(puzzle):\n        for i in puzzle[move]:\n            count += 1 if i == 0 else 0\n    else:\n        index = move - len(puzzle)\n        for row in puzzle:\n            count += 1 if row[index] == 0 else 0\n    return count\n\n# UGH that solution is so BASIC! Greedy execution? Lame. I perfer the BF tree search below.\n\n\"\"\"\n# Use BFS?\ndef find_solution(puzzle):\n    fringe = [([], puzzle)]\n    while (True): # We should always find a solution for any configuration?\n        \n        (moveset, current_state) = fringe.pop()\n        \n        # Test if current state is a solution\n        valid = True\n        for x in range(len(current_state)):\n            if 0 in current_state[x]:\n                valid = False\n                break\n        if valid:\n            return moveset\n        \n        # If state is not solution then we generate successor states add to fringe queue\n        successors = generate_successors(moveset, current_state)\n        for s in successors:\n            fringe.insert(0, s)\n            \n    \n    \n# This function takes a moveset and a puzzle and returns all the possible successors for that puzzle\ndef generate_successors(move_list, puzzle):\n    successors = []\n    for x in range(len(puzzle) * 2):\n        \n        new_state = copy.deepcopy(puzzle)\n        new_move_list = move_list[:]\n        new_move_list.append(x)\n        \n        # If x < len(puzzle) we toggle a row\n        if x < len(puzzle):\n            new_state[x] = [1 if y == 0 else 0 for y in new_state[x]]\n            successors.append((new_move_list, new_state))\n        \n        # Else toggle column\n        else:\n            index = x - len(puzzle)\n            for i in range(len(puzzle)):\n                new_state[i][index] = 0 if new_state[i][index] == 1 else 1\n            successors.append((new_move_list, new_state))\n            \n    return successors\n\"\"\"", "def find_solution(puzzle):\n    moves = set()\n    n = len(puzzle)\n    zeros = {(i, n + j) for i, row in enumerate(puzzle) for j, v in enumerate(row) if v == 0}\n    if not zeros: return []\n    def get():\n        v = None\n        if len(moves) == 0: return zeros.pop()\n        for r, c in zeros:\n            if r in moves or c in moves:\n                if r in moves and c in moves: continue\n                v = (r, c)\n                zeros.remove(v)\n                return v\n        if v is None: return zeros.pop()\n    while zeros:\n        r, c = get()\n        if r not in moves:\n            moves.add(r)\n            for k in range(n, 2 * n):\n                if k == c: continue\n                if (r, k) in zeros: zeros.remove((r, k))\n                else: zeros.add((r, k))\n        elif c not in moves:\n            moves.add(c)\n            for k in range(n):\n                if k == r: continue\n                if (k, c) in zeros: zeros.remove((k, c))\n                else: zeros.add((k, c))\n\n    return list(moves)\n", "# returns a sequence of row/column toggles to solve the puzzle\n# - Examples: \n#   - [3, 7]\n#   - [0, 5, 4, 7]\ndef find_solution(puzzle):\n    first_column = [i for i in range(len(puzzle))  if puzzle[i][0] == 0]\n    value = 1 if 0 in first_column else 0\n    first_row = [i + len(puzzle) for i in range(len(puzzle)) if puzzle[0][i] == value]\n    return first_row + first_column\n", "# returns a sequence of row/column toggles to solve the puzzle\n# - Examples: \n#   - [3, 7]\n#   - [0, 5, 4, 7]\ndef find_solution(puzzle):\n    res = []\n    first_column = [i for i in range(len(puzzle))  if puzzle[i][0] == 0]\n    first_row = [i + len(puzzle) for i in range(len(puzzle)) if puzzle[0][i] == 1] if 0 in first_column else [i + len(puzzle) for i in range(len(puzzle)) if puzzle[0][i] == 0] \n    return first_row + first_column\n", "def flip_row(puzzle, i):\n    puzzle[i] = list(map(lambda cell: abs(cell - 1), puzzle[i]))\n\ndef flip_col(puzzle, i):\n    for row in puzzle:\n        row[i] = abs(row[i] - 1)\n\ndef find_solution(puzzle):\n    result = []\n    n = len(puzzle)\n    \n    for i in range(1,n):\n        if puzzle[i] != puzzle[i-1]:\n            flip_row(puzzle, i)\n            result.append(i)\n\n    for i in range(n):\n        if puzzle[0][i] != 1:\n            flip_col(puzzle, i)\n            result.append(i+n)\n\n    return result"]