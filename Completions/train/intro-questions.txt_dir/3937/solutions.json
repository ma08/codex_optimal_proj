["def check(num,max_sum):\n    l = [int(i) for i in str(num)]\n    for i in range(0,len(l) - 3):\n        if sum(l[i:i+4]) > max_sum:return False\n    return True\n\ndef max_sumDig(nMax, maxSum):\n    found = [i for i in range(1000,nMax + 1) if check(i,maxSum)]\n    mean = sum(found) / float(len(found))\n    for i in range(len(found) - 1):\n        if abs(mean - found[i]) < abs(mean - found[i + 1]):\n            mean = found[i]\n            break\n    return [len(found), mean, sum(found)]", "def max_sumDig_aux(nmax, maxsm):\n    res, i = [], 1000\n    while (i <= nmax):\n        a = list(str(i))\n        j, b = 0, 0\n        while (j <= len(a) - 4):\n            if (sum(map(int, a[j:j+4])) <= maxsm):\n                b += 1\n            j += 1\n        if (b == j):\n            res.append(i)\n        i += 1\n    return res\n    \ndef max_sumDig(nmax, maxsm):\n    res = max_sumDig_aux(nmax, maxsm)\n    l = len(res)\n    s = sum(res)\n    m = s / float(l)\n    d = list([(abs(x - m), x) for x in res])\n    d.sort()\n    return [l, d[0][1], s]\n", "def max_sumDig(nMax, maxSum):\n    answers = []\n    \n    for i in range(1000, nMax + 1):\n        good = True\n        n = [int(x) for x in str(i)]\n        for j in range(0, len(n)-3):\n            if sum([n[j],n[j+1],n[j+2],n[j+3]]) > maxSum:\n                good = False\n        if good == True:\n            answers.append(i)\n    \n    num, tot = len(answers), sum(answers)\n    return [num, min(answers, key=lambda x: abs(x-(tot/float(num)))), tot]", "from statistics import mean\n\ndef max_sumDig(nMax, maxSum):\n    def okay(x):\n        L = list(map(int, str(x)))\n        return all(sum(t) <= maxSum for t in zip(L, L[1:], L[2:], L[3:]))\n    result = list(filter(okay, range(1000, nMax+1)))\n    m = mean(result)\n    return [len(result), min(result, key=lambda x:abs(x-m)), sum(result)]", "from bisect import bisect\n\ndef max_sumDig(n_max, max_sum):\n    numbers = []\n    \n    for n in range(1000, n_max +1):\n        s = str(n)\n        if all(sum(map(int, s[i:i+4])) <= max_sum for i in range(len(s)-3)):\n            numbers.append(n)\n    \n    res_sum   = sum(numbers)\n    res_count = len(numbers)\n    res_avg   = 1.0 * res_sum / res_count\n    \n    idx = bisect(numbers, res_avg)\n    a, b = numbers[idx-1 : idx+1]\n    closest = a if res_avg - a <= b - res_avg else b\n    \n    return [ res_count, closest, res_sum ]", "\ndef sum_int(i):\n    \"\"\"Sum digits of an integer - standard\"\"\"\n    s=0\n    while i != 0:\n        s += i % 10\n        i //= 10\n    return s\n\ndef find_4digs(m,MaxNum,MaxSum):\n    \"\"\"start by finding all 4 digit numbers n m \\leq n \\leq MaxNum with sum \\leq MaxSum\"\"\"\n    \n    sts=[m]\n    for i in range(0, 4):\n        for st in sts:            \n            while (sum_int(st+10**i)<= MaxSum and st+10**i <= MaxNum):\n                sts.append(st+10**i)\n                st += 10**i\n    sts=list(set(sts)) # delete duplicates\n    return (sts)\n\ndef find_5digs(nums,MaxNum,MaxSum):\n    \"\"\" takes in a list of 4 digit numbers \\leq MaxNum and with sum \\leq MaxSum. Returns list of 4 and 5 digit nums \n    with every consecutive 4 digits satisfying the same conditions\"\"\"\n    #TODO: Generalize to x digit numbers\n    \n    for s in  nums:\n        # add digits before the 4 digit nums\n        for i in range(1, MaxSum - sum_int(int(str(s)[0:3]))+1):\n            cand1 = int(str(i)+str(s))\n            if cand1 <= MaxNum:\n                nums.append(cand1)\n        # add digits after the 4 digit nums\n        for i in range(0,MaxSum-sum_int(int(str(s)[1:4]))+1):\n            cand2 = int( str(s) + str(i) )\n            if cand2 <= MaxNum:\n                nums.append(cand2)    \n\n    nums=list(set(nums)) # delete duplcates\n    return nums\n    \ndef max_sumDig(MaxNum,MaxSum):\n    \"\"\" Find all numbers satisfying the conditions. \"\"\"\n    \n    nums = find_4digs(1000,MaxNum,MaxSum)\n    nums = find_5digs(nums,MaxNum,MaxSum)\n    \n    # calcualte min distance from mean\n    mean = sum(nums)/len(nums)           \n    dists=[ abs(s-mean) for s in nums] \n    \n    for i in range(len(dists)):\n        if dists[i] == min(dists):\n            min_dist=nums[i]   \n            \n    return [len(nums), min_dist, sum(nums)]\n", "def max_sumDig(nMax, maxSum):\n    \n    def isGood(s):  return all(sum(map(int, str(s[i:i+4]))) <= maxSum for i in range(len(s)-3) )\n    \n    lst = [n for n in range(1000, nMax+1) if isGood(str(n))]\n    s, l = sum(lst), len(lst)\n    avg = 1.0*s/l\n    iAvg = next( i for i,n in enumerate(lst) if n > avg )\n    nearest = sorted(lst[iAvg-1:iAvg+1], key=lambda n: abs(n-avg))[0]\n    return [l, nearest, s]", "def x(i, maxSum): #check if number satisfies requirments\n    s = str(i)\n    for i in range(len(s)-3):\n        if sum(map(int,list(s[i:i+4])))>maxSum:\n            return False\n    return True\n\ndef max_sumDig(nMax, maxSum):\n    count = 0\n    sum_ = 0 \n    mean_ = 0\n    _3 = None\n    \n    for i in range(1000, nMax+1):\n        if x(i, maxSum):\n            count += 1\n            sum_ += i\n            if not _3: _3 = i\n    \n    mean_ = float(sum_)/count\n    _3 = i\n    for i in range(1000, nMax+1):\n        if x(i, maxSum):\n            if  abs(i - mean_) < abs(_3 - mean_): _3 = i \n    \n    return [count, _3, sum_]", "def max_sumDig(nMax, maxSum):\n    count=0\n    nums=[]\n    if len(str(nMax)) == 4:\n        for i in range(1000, nMax+1):\n            if ( (i%10) + ( (i//10) % 10 ) + ( (i//100) % 10 ) + ( (i//1000) % 10 )) <= maxSum:\n                nums.append(i)\n                count+=1\n    elif len(str(nMax)) == 5:\n        for i in range(1000, nMax+1):\n            if ( (i%10) + ( (i//10) % 10 ) + ( (i//100) % 10 ) + ( (i//1000) % 10 )) <= maxSum and (( (i//10) % 10 ) + ( (i//100) % 10 ) + ( (i//1000) % 10 ) + ( (i//10000) % 10 )) <= maxSum:\n                nums.append(i)\n                count+=1\n    elif len(str(nMax)) == 6:\n        for i in range(1000, nMax+1):\n            if ( (i%10) + ( (i//10) % 10 ) + ( (i//100) % 10 ) + ( (i//1000) % 10 )) <= maxSum and (( (i//10) % 10 ) + ( (i//100) % 10 ) + ( (i//1000) % 10 ) + ( (i//10000) % 10 )) <= maxSum and (( (i//100) % 10 ) + ( (i//1000) % 10 ) + ( (i//10000) % 10 ) + ( (i//100000) % 10 )) <= maxSum:\n                nums.append(i)\n                count+=1\n    media=sum(nums)/len(nums)\n    for n in nums:\n        if media <= n:\n            if (n - media) > (media - nums[nums.index(n)-1]):\n                media=nums[nums.index(n)-1]\n                break\n            else:\n                media=n\n                break\n    suma=sum(nums)\n    return [count, media, suma]"]