["import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    N, M = list(map(int, input().split()))\n    E = [[] for aa in range(N)]\n    for __ in range(M):\n        a, b = list(map(int, input().split()))\n        E[a-1].append(b-1)\n        E[b-1].append(a-1)\n    \n    D = [-1] * N\n    D[0] = 0\n    d = 0\n    post = [0]\n    EVEN = [1]\n    ODD = []\n    while post:\n        d += 1\n        pre = post\n        post = []\n        for i in pre:\n            for e in E[i]:\n                if D[e] < 0:\n                    D[e] = d\n                    post.append(e)\n                    if d % 2:\n                        ODD.append(e+1)\n                    else:\n                        EVEN.append(e+1)\n    if len(ODD) < len(EVEN):\n        print(len(ODD))\n        print(*ODD)\n    else:\n        print(len(EVEN))\n        print(*EVEN)\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\nQ=int(input())\n\nfor q in range(Q):\n    n,m=list(map(int,input().split()))\n\n    E=[list(map(int,input().split())) for i in range(m)]\n\n    ELIST=[[] for i in range(n+1)]\n    for a,b in E:\n        ELIST[a].append(b)\n        ELIST[b].append(a)\n\n    check=[0]*(n+1)\n    ANS=[]\n\n    Q=deque([1])\n    E2=[[] for i in range(n+1)]\n\n    while Q:\n        x=Q.pop()\n        check[x]=1\n        for to in ELIST[x]:\n            if check[to]==0:\n                E2[x].append(to)\n                E2[to].append(x)\n                check[to]=1\n                Q.append(to)\n\n    #print(E2)\n    ELIST=E2\n\n    check=[0]*(n+1)\n    \n\n    QUE=deque([])\n    QUE.append([1,0])\n\n    while QUE:\n        x,point=QUE.pop()\n        if point==0:\n            if check[x]==1:\n                continue\n            check[x]=1\n            ANS.append(x)\n\n            for to in ELIST[x]:\n                if check[to]==0:\n                    check[to]=1\n                    QUE.appendleft([to,1])\n\n        else:\n            for to in ELIST[x]:\n                if check[to]==0:\n                    QUE.appendleft([to,0])\n\n\n    if len(ANS)<=n//2:\n\n        print(len(ANS))\n        print(*ANS)\n        continue\n    \n\n    check=[0]*(n+1)\n    ANS=[]\n\n    QUE=deque([])\n    QUE.append([ELIST[1][0],0])\n\n    while QUE:\n        x,point=QUE.pop()\n        if point==0:\n            if check[x]==1:\n                continue\n            check[x]=1\n            ANS.append(x)\n\n            for to in ELIST[x]:\n                if check[to]==0:\n                    check[to]=1\n                    QUE.appendleft([to,1])\n\n        else:\n            for to in ELIST[x]:\n                if check[to]==0:\n                    QUE.appendleft([to,0])\n\n    print(len(ANS))\n    print(*ANS)\n    \n", "import sys\nfrom collections import deque \nfor _ in range(int(input())):\n    n,m=list(map(int,sys.stdin.readline().split()))\n    a=[[] for i in range(n+1)]\n    for i in range(m):\n        x,y=list(map(int,sys.stdin.readline().split()))\n        a[x].append(y)\n        a[y].append(x)\n    col=[-1]*(n+1)\n    col[1]=1\n    d=deque([1])\n    vis=[0]*(n+1)\n    # vis[1]=1\n    ans=[[],[1]]\n    \n    while d:\n        p=d.popleft()\n        for i in a[p]:\n            if col[i]==-1:\n                col[i]=1-col[p]\n                ans[1-col[p]].append(i)\n                d.append(i)\n    \n    if len(ans[0])<=n//2:\n        print(len(ans[0]))\n        \n        print(*ans[0])\n    else:\n        print(len(ans[1]))\n        \n        print(*ans[1])\n", "from collections import deque\nimport sys\n\n\nfor _ in range(int(sys.stdin.readline())):\n    n, m = list(map(int, sys.stdin.readline().split()))\n    g = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        a, b = list(map(int, sys.stdin.readline().split()))\n        g[a].append(b)\n        g[b].append(a)\n        \n    k = [[], [1]]\n    color = [-1] * (n + 1)\n    m = deque([1])\n    color[1] = 1\n    while m:\n        u = m.popleft()\n        for v in g[u]:\n            if color[v] == -1:\n                color[v] = 1 - color[u]\n                k[color[v]].append(v)\n                m.append(v) \n                \n    if len(k[0]) <= n // 2:\n        print(len(k[0]))\n        print(*k[0])\n        \n    else:\n        print(len(k[1]))\n        print(*k[1])\n", "######################################################################\n# Write your code here\nimport sys\ninput = sys.stdin.readline\n#import resource\n#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])\n#sys.setrecursionlimit(0x100000)\n# Write your code here\nRI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nrw = lambda : input().strip().split()\nfrom collections import defaultdict as df\n#import heapq \n#heapq.heapify(li) heappush(li,4) heappop(li)\n#import random\n#random.shuffle(list)\n#infinite = float('inf')\n#######################################################################)\ndef dfs(a,n):\n    depth=[0]*n\n    depth[a]=0\n    x=1\n    stack=[a]\n    vis[a]=1\n    l=[0,0]\n    l[0]+=1\n    #stackindex=0\n    #print(stack)\n    while(len(stack)!=0):\n        \n        p=stack.pop()\n        #print(p)\n        #stackindex-=1\n        for i in adj[p]:\n            if(vis[i]==1):\n                continue\n            vis[i]=1\n            stack.append(i)\n            #stackindex+=1\n            depth[i]=depth[p]^1\n            l[depth[i]]+=1\n        x=(x+1)%2\n        #print(depth)\n        #print(vis)\n        #print(\"hi\")\n    #print(depth)\n    #print(l)\n    \n    s=n//2\n    if(l[0]<=s):\n        print(l[0])\n        for i in range(n):\n            if(depth[i]==0):\n                print(i+1,end=\" \")\n    else:\n        print(l[1])\n        for i in range(n):\n            if(depth[i]==1):\n                print(i+1,end=\" \")\n    print(\"\")\n    \n            \n\n\nt=int(input())\n\nadj=[[] for i in range(200010)]\nvis=[0]*(200010)\nfor _ in range(t):\n    n,m=RI()\n\n    for i in range(n):\n        adj[i].clear()\n        vis[i]=0\n    for i in range(m):\n        a,b=RI()\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    #print(adj)\n   # print(\"hi\",0)\n    dfs(0,n)", "######################################################################\n# Write your code here\nimport sys\ninput = sys.stdin.readline\n#import resource\n#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])\n#sys.setrecursionlimit(0x100000)\n# Write your code here\nRI = lambda : [int(x) for x in input().strip().split()]\nrw = lambda : input().strip().split()\nfrom collections import defaultdict as df\n#import heapq \n#heapq.heapify(li) heappush(li,4) heappop(li)\n#import random\n#random.shuffle(list)\n#infinite = float('inf')\n#######################################################################)\ndef dfs(a,n):\n    depth=[0]*n\n    depth[a]=0\n    x=1\n    stack=[a]\n    vis[a]=1\n    l=[0,0]\n    l[0]+=1\n    #stackindex=0\n    #print(stack)\n    while(len(stack)!=0):\n        \n        p=stack.pop()\n        #print(p)\n        #stackindex-=1\n        for i in adj[p]:\n            if(vis[i]==1):\n                continue\n            vis[i]=1\n            stack.append(i)\n            #stackindex+=1\n            depth[i]=depth[p]^1\n            l[depth[i]]+=1\n        x=(x+1)%2\n        #print(depth)\n        #print(vis)\n        #print(\"hi\")\n    #print(depth)\n    #print(l)\n    \n    s=n//2\n    if(l[0]<=s):\n        print(l[0])\n        for i in range(n):\n            if(depth[i]==0):\n                print(i+1,end=\" \")\n    else:\n        print(l[1])\n        for i in range(n):\n            if(depth[i]==1):\n                print(i+1,end=\" \")\n    print(\"\")\n    \n            \n\n\nt=int(input())\n\nadj=[[] for i in range(200010)]\nvis=[0]*(200010)\nfor _ in range(t):\n    n,m=RI()\n\n    for i in range(n):\n        adj[i].clear()\n        vis[i]=0\n    for i in range(m):\n        a,b=RI()\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    #print(adj)\n   # print(\"hi\",0)\n    dfs(0,n)", "######################################################################\n# Write your code here\nimport sys\ninput = sys.stdin.readline\n#import resource\n#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])\n#sys.setrecursionlimit(0x100000)\n# Write your code here\nRI = lambda : [int(x) for x in input().strip().split()]\nrw = lambda : input().strip().split()\nfrom collections import defaultdict as df\n#import heapq \n#heapq.heapify(li) heappush(li,4) heappop(li)\n#import random\n#random.shuffle(list)\n#infinite = float('inf')\n#######################################################################)\ndef dfs(a,n):\n    depth=[0]*n\n    depth[a]=0\n    x=1\n    stack=[a]\n    vis[a]=1\n    l=[0,0]\n    l[0]+=1\n    #stackindex=0\n    #print(stack)\n    while(len(stack)!=0):\n        \n        p=stack.pop()\n        #print(p)\n        #stackindex-=1\n        for i in adj[p]:\n            if(vis[i]==1):\n                continue\n            vis[i]=1\n            stack.append(i)\n            #stackindex+=1\n            depth[i]=depth[p]^1\n            l[depth[i]]+=1\n        x=(x+1)%2\n        #print(depth)\n        #print(vis)\n        #print(\"hi\")\n    #print(depth)\n    #print(l)\n    \n    s=n//2\n    if(l[0]<=s):\n        print(l[0])\n        for i in range(n):\n            if(depth[i]==0):\n                print(i+1,end=\" \")\n    else:\n        print(l[1])\n        for i in range(n):\n            if(depth[i]==1):\n                print(i+1,end=\" \")\n    print(\"\")\n    \n            \n\n\nt=int(input())\n\n#adj=[[] for i in range(200010)]\n#vis=[0]*(200010)\nfor _ in range(t):\n    n,m=RI()\n\n    adj=[[] for i in range(n)]\n    vis=[0]*(n)\n    for i in range(m):\n        a,b=RI()\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    #print(adj)\n   # print(\"hi\",0)\n    dfs(0,n)", "\n# -*- coding: utf-8 -*-\n# @Date    : 2019-06-11 10:26:57\n# @Author  : raj lath (oorja.halt@gmail.com)\n# @Link    : link\n# @Version : 1.0.0\n\nimport sys\nsys.setrecursionlimit(10**5+1)\n\ninf     =  int(10 ** 20)\nmax_val =  inf\nmin_val = -inf\n\nRW  = lambda : sys.stdin.readline().strip()\nRI  = lambda : int(RW())\nRMI = lambda : [int(x) for x in sys.stdin.readline().strip().split()]\nRWI = lambda : [x for x in sys.stdin.readline().strip().split()]\n\n\nfrom collections import deque\n\nfor _ in range(RI()):\n    n, m = RMI()\n    a = [[] for i in range(n + 1)]\n    for i in range(m):\n        x, y = RMI()\n        a[x].append(y)\n        a[y].append(x)\n    col = [-1] * (n + 1)\n    col[1] = 1\n    d = deque([1])\n    vis = [0] * (n + 1)\n    ans = [[], [1]]\n    while d:\n        p = d.popleft()\n        for i in a[p]:\n            if col[i] == -1:\n                tog = 1 - col[p]\n                col[i] = tog\n                ans[tog].append(i)\n                d.append(i)\n    if len(ans[0]) <= n // 2:\n        print(len(ans[0]))\n        print(*ans[0])\n    else:\n        print(len(ans[1]))\n        print(*ans[1])\n", "import sys\ninput = sys.stdin.readline\nT = int(input())\nfor _ in range(T):\n    N, M = map(int, input().split())\n    E = [[] for aa in range(N)]\n    for __ in range(M):\n        a, b = map(int, input().split())\n        E[a-1].append(b-1)\n        E[b-1].append(a-1)\n    \n    D = [-1] * N\n    D[0] = 0\n    d = 0\n    post = [0]\n    EVEN = [1]\n    ODD = []\n    while post:\n        d += 1\n        pre = post\n        post = []\n        for i in pre:\n            for e in E[i]:\n                if D[e] < 0:\n                    D[e] = d\n                    post.append(e)\n                    if d % 2:\n                        ODD.append(e+1)\n                    else:\n                        EVEN.append(e+1)\n    if len(ODD) < len(EVEN):\n        print(len(ODD))\n        print(*ODD)\n    else:\n        print(len(EVEN))\n        print(*EVEN)", "import sys\ninput = sys.stdin.readline\n\ndef jiashen(new_tree):\n    nonlocal g\n    nonlocal k\n    js = []\n    for i in new_tree:\n        for j in gra[i]:\n            if (fil[j]):\n                fil[j] = 0\n                js.append(j)\n                g += 1\n                if (k):\n                    d2.append(j)\n                else:\n                    d1.append(j)\n    k = False if k else True\n    return js\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    gra = [[] for i in range(n)]\n    d1 = [0]\n    d2 = []\n    fil = [1 for i in range(n)]\n    fil[0] = 0\n    for i in range(m):\n        a, b = map(int, input().split())\n        gra[a-1].append(b-1)\n        gra[b-1].append(a-1)\n    new_tree = [0]\n    k = True\n    g = 1\n    while (g < n):\n        new_tree = jiashen(new_tree)\n    le = len(d1)\n    if (le <= n//2):\n        print(le)\n        print(' '.join([str(x+1) for x in d1]))\n    else:\n        print(n - le)\n        print(' '.join([str(x+1) for x in d2]))", "def jiashen(new_tree):\n    nonlocal g\n    nonlocal k\n    js = []\n    for i in new_tree:\n        for j in gra[i]:\n            if (fil[j]):\n                fil[j] = 0\n                js.append(j)\n                g += 1\n                if (k):\n                    d2.append(j)\n                else:\n                    d1.append(j)\n    k = False if k else True\n    return js\n\nt = int(input())\nzong = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    gra = [[] for i in range(n)]\n    d1 = [0]\n    d2 = []\n    fil = [1 for i in range(n)]\n    fil[0] = 0\n    for i in range(m):\n        a, b = map(int, input().split())\n        gra[a-1].append(b-1)\n        gra[b-1].append(a-1)\n    new_tree = [0]\n    k = True\n    g = 1\n    while (g < n):\n        new_tree = jiashen(new_tree)\n    le = len(d1)\n    if (le <= n//2):\n        zong.append(str(le)+'\\n'+' '.join([str(x+1) for x in d1]))\n    else:\n        zong.append(str(n-le)+'\\n'+' '.join([str(x+1) for x in d2]))\nprint('\\n'.join(zong))", "import sys\ninput = sys.stdin.readline\n\ndef jiashen(new_tree):\n    nonlocal g\n    nonlocal k\n    js = []\n    for i in new_tree:\n        for j in gra[i]:\n            if (fil[j]):\n                fil[j] = 0\n                js.append(j)\n                g += 1\n                if (k):\n                    d2.append(j)\n                else:\n                    d1.append(j)\n    k = False if k else True\n    return js\n\nt = int(input())\nzong = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    gra = [[] for i in range(n)]\n    d1 = [0]\n    d2 = []\n    fil = [1 for i in range(n)]\n    fil[0] = 0\n    for i in range(m):\n        a, b = map(int, input().split())\n        gra[a-1].append(b-1)\n        gra[b-1].append(a-1)\n    new_tree = [0]\n    k = True\n    g = 1\n    while (g < n):\n        new_tree = jiashen(new_tree)\n    le = len(d1)\n    if (le <= n//2):\n        zong.append(str(le)+'\\n'+' '.join([str(x+1) for x in d1]))\n    else:\n        zong.append(str(n-le)+'\\n'+' '.join([str(x+1) for x in d2]))\nprint('\\n'.join(zong))", "from collections import deque\nimport sys\n\ndef __starting_point():\n    t = int(input())\n    lns = sys.stdin.readlines()\n    i = 0\n    result = []\n    for _ in range(t):\n        n, m = map(int, lns[i].split())\n        i += 1\n        g = [[] for _ in range(n)]\n        for _ in range(m):\n            v, u = map(int, lns[i].split())\n            i += 1\n            g[v - 1].append(u - 1)\n            g[u - 1].append(v - 1)\n\n        q = deque()\n        vis = [False] * n\n        lvl = [-1] * n\n        lvl[0] = 0\n        vis[0] = True\n        q.append(0)\n        while len(q) > 0:\n            v = q.popleft()\n            for u in g[v]:\n                if not vis[u]:\n                    vis[u] = True\n                    lvl[u] = lvl[v] + 1\n                    q.append(u)\n\n        odd = [str(i + 1) for i in range(n) if lvl[i] % 2 == 1]\n        even = [str(i + 1) for i in range(n) if lvl[i] % 2 == 0]\n        res = odd if len(odd) < len(even) else even\n        result.append(str(len(res)))\n        result.append(\" \".join(res))\n\n    print(\"\\n\".join(result))\n__starting_point()", "def jiashen(new_tree):\n    nonlocal g\n    nonlocal k\n    js = []\n    for i in new_tree:\n        for j in gra[i]:\n            if (fil[j]):\n                fil[j] = 0\n                js.append(j)\n                g += 1\n                if (k):\n                    d2.append(j)\n                else:\n                    d1.append(j)\n    k = False if k else True\n    return js\n\n\nt = int(input())\nzong = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    gra = [[] for i in range(n)]\n    d1 = [0]\n    d2 = []\n    fil = [1 for i in range(n)]\n    fil[0] = 0\n    for i in range(m):\n        a, b = map(int, input().split())\n        gra[a-1].append(b-1)\n        gra[b-1].append(a-1)\n    new_tree = [0]\n    k = True\n    g = 1\n    while (g < n):\n        new_tree = jiashen(new_tree)\n    le = len(d1)\n    if (le <= n//2):\n        zong.append(str(le)+'\\n'+' '.join([str(x+1) for x in d1]))\n    else:\n        zong.append(str(n-le)+'\\n'+' '.join([str(x+1) for x in d2]))\nprint('\\n'.join(zong))", "import sys\nfrom collections import deque \nfor _ in range(int(input())):\n    n,m=map(int,sys.stdin.readline().split())\n    a=[[] for i in range(n+1)]\n    for i in range(m):\n        x,y=map(int,sys.stdin.readline().split())\n        a[x].append(y)\n        a[y].append(x)\n    col=[-1]*(n+1)\n    col[1]=1\n    d=deque([1])\n    vis=[0]*(n+1)\n    # vis[1]=1\n    ans=[[],[1]]\n    \n    while d:\n        p=d.popleft()\n        for i in a[p]:\n            if col[i]==-1:\n                col[i]=1-col[p]\n                ans[1-col[p]].append(i)\n                d.append(i)\n    \n    if len(ans[0])<=n//2:\n        print(len(ans[0]))\n        \n        print(*ans[0])\n    else:\n        print(len(ans[1]))\n        \n        print(*ans[1])", "import sys\nfrom collections import deque\nfor case in range(int(input())):\n    n, m = map(int, sys.stdin.readline().split()) #fast io\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        x, y = map(int, sys.stdin.readline().split())\n        g[x].append(y)\n        g[y].append(x)\n    col = [-1] * (n + 1)\n    col[1] = 1\n    Q = deque() #calling deque data structure from collections\n    Q.append(1)\n    ans = [[] for i in range(2)]\n    ans[1].append(1)\n    while Q:\n        From = Q.popleft()\n        for To in g[From]:\n            if(col[To] == -1):\n                if col[From] == 1:\n                    col[To] = 2\n                else:\n                    col[To] = 1\n                ans[col[To] % 2].append(To)\n                Q.append(To)\n\n    if len(ans[0]) < len(ans[1]):\n        print(len(ans[0]))\n        print(*ans[0])\n    else:\n        print(len(ans[1]))\n        print(*ans[1])", "import sys\nfrom collections import deque\nfor case in range(int(input())):\n    n, m = map(int, sys.stdin.readline().split()) #fast io\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        x, y = map(int, sys.stdin.readline().split())\n        g[x].append(y)\n        g[y].append(x)\n    col = [-1] * (n + 1)\n    col[1] = 1\n    Q = deque()\n    Q.append(1)\n    ans = [[] for i in range(2)]\n    ans[1].append(1)\n    while Q:\n        From = Q.popleft()\n        for To in g[From]:\n            if(col[To] == -1):\n                if col[From] == 1:\n                    col[To] = 2\n                else:\n                    col[To] = 1\n                ans[col[To] % 2].append(To)\n                Q.append(To)\n\n    if len(ans[0]) < len(ans[1]):\n        print(len(ans[0]))\n        #print(*ans[0])\n        for each in ans[0]:\n            print(each)\n    else:\n        print(len(ans[1]))\n        for each in ans[1]:\n            print(each)", "import sys\nfrom collections import deque\n# wtfffffffffffff\nfor case in range(int(input())):\n    n, m = map(int, sys.stdin.readline().split()) #fast io\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        x, y = map(int, sys.stdin.readline().split())\n        g[x].append(y)\n        g[y].append(x)\n    col = [-1] * (n + 1)\n    col[1] = 1\n    Q = deque()\n    Q.append(1)\n    ans = [[] for i in range(2)]\n    ans[1].append(1)\n    while Q:\n        From = Q.popleft()\n        for To in g[From]:\n            if(col[To] == -1):\n                if col[From] == 1:\n                    col[To] = 2\n                else:\n                    col[To] = 1\n                ans[col[To] % 2].append(To)\n                Q.append(To)\n \n    if len(ans[0]) < len(ans[1]):\n        print(len(ans[0]))\n        #print(*ans[0])\n        for each in ans[0]:\n            print(each)\n    else:\n        print(len(ans[1]))\n        for each in ans[1]:\n            print(each)"]