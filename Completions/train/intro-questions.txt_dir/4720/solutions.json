["from itertools import chain\n\ndef hyperrectangularity_properties(arr):\n    hr, arr = [], [arr]\n    while 1:\n        check = sum(isinstance(v, int) for v in arr)        # Check homogeneity\n        if check or not arr:                                # some int are present or empty array (edge case)\n            if check == len(arr): return tuple(hr)          # only int: found the bottom of the tree\n            break\n            \n        l = set(map(len,arr))\n        if len(l) > 1: break                                # invalid if different length found\n        hr.append(l.pop())\n        arr = list(chain.from_iterable(arr))                # get the \"lower level\"", "import numpy as np\n\ndef hyperrectangularity_properties(arr):\n    try:\n        return np.shape(arr) if np.array(arr).dtype.char != \"O\" else None\n    except ValueError:\n        return None\n", "def hp(arr):\n    if not isinstance(arr, list):\n        return ()\n    elif not arr:\n        return (0,)\n    xs = list(map(hp, arr))\n    if None not in xs and all(x == xs[0] for x in xs):\n        return (len(arr),) + xs[0]\nhyperrectangularity_properties = hp", "hyperrectangularity_properties=h=lambda a:()if[]!=a*0else(lambda f,*s:None if f==None or s else(len(a),)+f)(*set(map(h,a))or{()})", "import numpy as np\ndef hyperrectangularity_properties(arr):\n    try:\n        arr = np.array(arr)\n    except ValueError:\n        return None\n    return arr.shape if arr.dtype.char != 'O' else None", "def hyperrectangularity_properties(arr, d=[]):\n        def get(arr,d):\n            d.append(len(arr))\n            if all(isinstance(i, int) for i in arr) : return tuple(d)\n            else:\n                le = len(arr[0]) if isinstance(arr[0], list) else 0\n                if not all(isinstance(i, list) and len(i) == le for i in arr) : return \n        \n            if get(arr[0],d) : return tuple(d)\n        return get(arr,[])", "def hyperrectangularity_properties(arr):\n    v = len(arr)\n    k = (v,)\n    if not v: return k\n    if len( set(map(type, arr)) )!= 1: return None\n    if isinstance(arr[0], int): return k\n    rest = list(  set(map(hyperrectangularity_properties, arr)) )\n    if len(rest) == 1 and rest[0] != None:\n        return k + rest[0]\n    return None\n", "import numpy as np\n\ndef hyperrectangularity_properties(arr):\n    try:\n        return None if np.array(arr).dtype == np.dtype(\"O\") else np.shape(arr)\n    except (ValueError):\n        return None\n", "def hyperrectangularity_properties(r):\n    z = [len(r)]\n    while len(r):\n        if len(set(type(v) for v in r)) == 1:\n            if type(r[0]) == list:\n                if len(set(len(rr) for rr in r)) != 1: return None\n                z.append(len(r[0]))\n                r = [v for rr in r for v in rr]\n            else: break\n        else: return None\n    return tuple(z)", "# This is a shit code, just little correction after little correction until I'm not even sure how it works\n# There are probably edges cases to make it not work but hey, it passes the tests\ndef rec(arr):\n    type = [isinstance(x, int) for x in arr]\n    if len(set(type)) > 1: return None\n    if not type or type[0]: return []\n    size = list(map(len, arr))\n    if len(set(size)) != 1: return None\n    res = [rec(x) for x in arr]\n    if None in res: return None\n    if len(set(map(tuple, res))) != 1: return None\n    return [size[0]] + res[0]\n\ndef hyperrectangularity_properties(arr):\n    res = rec(arr)\n    if res is None: return None\n    return tuple([len(arr)] + res)"]