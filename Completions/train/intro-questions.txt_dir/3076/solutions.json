["DIRS = {'Left': 'Right', 'Right': 'Left'}\n\ndef solve(arr):\n    lst,prevDir = [], 'Begin'\n    for cmd in arr[::-1]:\n        d, r    = cmd.split(' on ')\n        follow  = DIRS.get(prevDir, prevDir)\n        prevDir = d\n        lst.append(f'{follow} on {r}')\n    return lst", "def solve(arr):\n    go_moves, go_places = list(zip(*(s.split(\" \", 1) for s in arr)))\n    back_moves = [\"Begin\"] + [\"Right\" if s == \"Left\" else \"Left\" for s in go_moves[:0:-1]]\n    return [\" \".join(z) for z in zip(back_moves, go_places[::-1])]\n", "def solve(arr):\n    lst,prevDir = [],None\n    for cmd in arr[::-1]:\n        d,r = cmd.split(' on ')\n        if not lst: lst.append(f'Begin on {r}')\n        else:       lst.append(f'{\"Left\" if prevDir == \"Right\" else \"Right\"} on {r}')\n        prevDir = d\n    return lst", "from collections import deque\n\ndef solve(arr):\n    flip = {'Left': 'Right', 'Right': 'Left'}\n    \n    # Build the prefixes\n    directions = deque([\n        flip.get(s, s) \n        for s in [s.split()[0] for s in arr]\n    ])\n    directions.reverse()\n    directions.rotate(1)\n    \n    # Get the rest of the directions    \n    streets = [' '.join(s.split()[1:]) for s in arr][::-1]\n    \n    # Zip and concatenate each pair \n    return [f'{direction} {street}' for direction, street in zip(directions, streets)]", "def solve(arr):\n    route = [road.split() for road in arr]\n    l, re= len(arr), []    \n    dir = {'Left': 'Right', 'Right': 'Left', 'Begin': 'Begin'}\n    for i in range(l):\n        re.insert(0, ' '.join([dir[route[(i+1)%l][0]]] + route[i][1:]))\n    return re", "def solve(directions):\n    positions, turns = [], []\n    for d in directions[::-1]:\n        t, p = d.split(' on ')\n        turns.append('Right' if t == 'Left' else 'Left')\n        positions.append(p)\n    result = [f'{t} on {p}' for t, p in zip(turns, positions[1:])]\n    return [f'Begin on {positions[0]}'] + result", "def solve(arr):\n    \n    rev = list(reversed(arr))\n    go = []\n    direction = 'Begin'\n    \n    for i in rev:\n        nextdirection = i.split(' ')[0]\n        go.append(i.replace(nextdirection, direction))\n        if nextdirection == 'Left':\n            direction = 'Right'\n        else:\n            direction = 'Left'\n            \n    return go\n        \n", "def solve(a):\n    ans,last = [],len(a)-1\n    for i,x in enumerate(a):\n        s = 'Begin' if i == last else 'Right' if a[i+1][0] == 'L' else 'Left'\n        ans.insert(0,s + x[x.index(' '):])\n    return ans", "solve = lambda arr: list(reversed([{'Right': 'Left', 'Left': 'Right'}[arr[i + 1].split(' ')[0]] + ' ' + ' '.join(arr[i].split(' ')[1:]) if i < len(arr)-1 else 'Begin ' + ' '.join(arr[i].split(' ')[1:]) for i in range(len(arr))]))\n", "def solve(arr):\n    t1,t2=[],[]\n    for i in arr:\n        t1.append(' '.join(i.split(' ')[:2]))\n        t2.append(' '.join(i.split(' ')[2:]))\n    print(t1,t2)\n    t2 = t2[::-1]\n    t1 = t1[::-1]\n    for i in range(len(t1)):\n        if \"Right\" in t1[i]:\n            t1[i] = t1[i].replace('Right','Left')\n        elif \"Left\" in t1[i]:\n            t1[i] = t1[i].replace('Left','Right')\n    t1 = [t1[-1]]+t1[:-1]\n    return [\"%s %s\"%(e,f) for e,f in zip(t1,t2)]"]