["def build_square(blocks):\n    for x in range(4):\n        if 4 in blocks:\n            blocks.remove(4)\n        elif 3 in blocks and 1 in blocks:\n            blocks.remove(3)\n            blocks.remove(1)\n        elif blocks.count(2) >= 2:\n            blocks.remove(2)\n            blocks.remove(2)\n        elif 2 in blocks and blocks.count(1) >= 2:\n            blocks.remove(2)\n            blocks.remove(1)\n            blocks.remove(1)\n        elif blocks.count(1) >= 4:\n            blocks.remove(1)\n            blocks.remove(1)\n            blocks.remove(1)\n            blocks.remove(1)\n        else:\n            return False\n    return True", "def build_square(blocks):\n    return (blocks.count(4) \n    + min(blocks.count(3), blocks.count(1))\n    + ((blocks.count(1) - min(blocks.count(3), blocks.count(1))) / 4)\n    + (blocks.count(2) / 2)) >= 4", "def build_square(arr):   \n\n    c = 0\n    def purge(*sizes):\n        nonlocal c\n        used = []\n        try:\n            for s in sizes:\n                arr.remove(s)\n                used.append(s)\n            c += 1\n        except:\n            arr.extend(used)\n\n    for _ in range(16):\n        purge(4)\n        purge(3,1)\n        purge(2,2)\n        purge(2,1,1)\n        purge(1,1,1,1)\n        \n    return c >= 4", "def build_square(blocks):\n    x1, x2, x3, x4 = (blocks.count(n) for n in range(1, 5))\n    b3 = min(x3, x1)\n    b2 = min(x2 % 2, (x1 - b3) // 2)\n    b1 = (x1 - b3 - b2 * 2) // 4\n    return x4 + b3 + x2 // 2 + b2 + b1 > 3 \n", "def build_square(sq):\n    A= lambda x:all(sq.count(i) >= x.count(i) for i in x)\n    for _ in range(4):\n        t = next(([sq.pop(sq.index(l)) for l in k] for k in [[4],[3,1],[2,2],[2,1,1],[1,1,1,1]] if A(k)),0)\n        if not t : return False\n    return True", "def build_square(blocks):\n    a = 4\n    b = blocks.count(1)\n    c = blocks.count(2)\n    d = blocks.count(3)\n    e = blocks.count(4)\n    a -= e\n    if a <= 0:\n        return True\n    while b > 0 and d > 0:\n        b-=1\n        d-=1\n        a-=1\n    while c > 0 and b > 1:\n        b-=2\n        c-=1\n        a-=1\n    while b > 3:\n        b-=4\n        a-=1\n    while c > 1:\n        c-=2\n        a-=1\n    if a <= 0:    \n      return True\n    else:\n      return False\n     \n            \n            \n    \n        \n", "from collections import Counter\n\ndef build_square(blocks):\n    c = Counter(blocks)\n\n    # 4\n    n = 4\n    n -= c[4]\n\n    # 3 + 1\n    x = min(c[3], c[1])\n    n -= x\n    c[1] -= x\n\n    # 2 + 2\n    x = c[2] // 2\n    n -= x\n    c[2] -= x * 2\n\n    # 2 + 1 + 1\n    x = min(c[2], c[1] // 2)\n    n -= x\n    c[1] -= x * 2\n\n    # 1 + 1 + 1 + 1\n    return c[1] // 4 >= n", "build_square=lambda B:(lambda a,b,c,d:15<a+b*2+3*min(a,c)+d*4)(*map(B.count,(1,2,3,4)))", "def build_square(blocks):\n    nums = {i:blocks.count(i) for i in range(1,5)}\n    odd_comb = min(nums[3],nums[1])\n    nums[1]-=odd_comb\n\n    return nums[4]*4 + odd_comb*4 + nums[2]*2 + nums[1] >= 16", "build_square=lambda sq,A=lambda x,y:all(y.count(i)>=x.count(i)for i in x):next((0for _ in range(4)if not next(([sq.pop(sq.index(l))for l in k]for k in [[4],[3,1],[2,2],[2,1,1],[1,1,1,1]]if A(k,sq)),0)),1)"]