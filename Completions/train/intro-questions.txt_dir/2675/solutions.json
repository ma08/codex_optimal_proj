["def bad_apples(apples):\n    lst, notFull = [], []\n    for a,b in apples:\n        if (bool(a) ^ bool(b)) and notFull:  lst[notFull.pop()].append(a or b)                  # One bad and partially full box already present: fill it (as second element)\n        elif a and b:                        lst.append([a,b])                                  # 2 good ones: keep as they are\n        elif a or b:                         notFull.append(len(lst)) ; lst.append([a or b])    # 1 good but no partial box: archive\n    if notFull: lst.pop(notFull.pop())                                                          # If 1 not full box remains: remove it\n    return lst", "def bad_apples(apples):\n    packed = []\n    while apples:\n        package = apples.pop(0)\n        if min(package) > 0:\n            # Both apples are positive\n            packed.append(package)\n        elif max(package) == 0:\n            # Both apples are rotten\n            continue\n        else: # Only one good apple\n            # Filter for other packs with one good apple\n            singles = filter(lambda x: min(x) == 0 and max(x) > 0, apples)\n            try:\n                # Try to get the next filtered package\n                next_single = next(singles)\n                # If found, remove from remaining apples and repackage\n                apples.remove(next_single)\n                packed.append([max(package), max(next_single)])\n            except StopIteration:\n                # If not found, discard and do nothing\n                pass\n    return packed", "def bad_apples(apples):\n    bad = (x if x else y for x,y in apples if (not x) ^ (not y))\n    result, flag = [], True\n    for x in apples:\n        if all(x): result.append(x)\n        elif any(x):\n            if flag:\n                try: result.append([next(bad), next(bad)])\n                except StopIteration: pass\n            flag = not flag\n    return result", "def bad_apples(apples):\n    free = None\n    i = 0\n    while i<len(apples):\n        if 0 in apples[i]:\n            if set(apples[i])=={0}:\n                apples.pop(i)\n            else:\n                apples[i].remove(0)      \n                if free!=None:\n                    apples[free].append(apples[i][0])\n                    apples.pop(i)\n                    free = None\n                else:\n                    free = i\n            i-=1        \n        i+=1\n    if free!=None: apples.pop(free)\n    return apples\n        \n", "def bad_apples(a):\n    li, visited = [], []\n    for i, j in enumerate(a):\n        if i not in visited and sum(j) != 0:\n            if 0 in j:\n                find = next((k for k in range(i+1,len(a))if 0 in a[k]and sum(a[k])!=0), 0)\n                if find:\n                    make = [j[0]or j[1],a[find][0]or a[find][1]]\n                    visited.append(find) ; li.append(make)\n            else : li.append(j)\n    return li", "def bad_apples(apples):\n    apples = [list(filter(None, xs)) for xs in apples]\n    apples = list(filter(None, apples))\n    idxs = [i for i, x in enumerate(apples) if len(x) == 1]\n    if len(idxs) % 2 == 1:\n        del apples[idxs.pop()]\n    for i in reversed(range(0, len(idxs), 2)):\n        apples[idxs[i]].append(apples.pop(idxs[i+1]).pop())\n    return apples", "def bad_apples(apples):\n    good_packages, bad_packages = [], []\n    for i, box in enumerate(apples):\n        if box[0] and box[1]:\n            good_packages.append([i, box])\n        elif box[0] or box[1]:\n            bad_packages.append([i, box[1] if box[1] else box[0]])\n\n    for a, b in zip(*[iter(bad_packages)]*2):\n        good_packages.append([a[0], [a[1], b[1]]])\n    return [box for _, box in sorted(good_packages)]", "def bad_apples(a):\n    b = list(map(lambda x: [i for i in x if i != 0], a))\n    for x,y in enumerate(b):\n        for i,j in enumerate(b):\n            if len(y)==1 and len(j)==1 and x != i:\n                b[x] = y+j\n                b.remove(j)\n                break\n    return [x for x in b if len(x)==2]", "from itertools import chain, repeat\nmul = lambda x: x[0]*x[1]\ndef bad_apples(apples):\n    inserting = [sum(pair) for pair in apples if mul(pair) == 0 and sum(pair)> 0]\n    ins_pairs = chain(chain(*zip(list(zip(*[iter(inserting)] * 2)), repeat(None))),repeat(None))\n    return list(filter(bool, [pair if mul(pair)>0  else list(next(ins_pairs) or ()) for pair in apples if sum(pair)>0]))", "def bad_apples(apples):\n    a = apples[:]\n    for i in range(len(a)-1):\n        if a[i].count(0) == 1:\n            for j in range(i+1, len(a)):\n                if a[j].count(0) == 1:\n                    a[i] = [sum(a[i]), sum(a[j])]\n                    a[j] = [0,0]\n                    break\n    return [i for i in a if 0 not in i]"]