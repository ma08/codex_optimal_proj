["def shift(string, step):\n    i = (step % len(string)) if string else 0\n    return f\"{string[-i:]}{string[:-i]}\"\n\ndef encode(n, string):\n    for _ in range(n):\n        shifted = shift(string.replace(\" \", \"\"), n)\n        l = [len(word) for word in string.split(\" \")]\n        string = \" \".join(shift(shifted[sum(l[:i]):sum(l[:i+1])], n) for i in range(len(l)))\n    return f\"{n} {string}\"\n\ndef decode(string):\n    n, string = int(string.partition(\" \")[0]), string.partition(\" \")[2]\n    for _ in range(n):\n        shifted = shift(\"\".join(shift(word, -n) for word in string.split(\" \")), -n)\n        l = [len(word) for word in string.split(\" \")]\n        string = \" \".join(shifted[sum(l[:i]):sum(l[:i+1])] for i in range(len(l)))\n    return string\n", "def rotate(n, s):\n    if not s: return s\n    n = -n % len(s)\n    return s[n:] + s[:n]\n\ndef cipher(n, s):\n    sp = [i for i, c in enumerate(s) if c == ' '] + [len(s)]\n    s = s.split(' ')\n    if n < 0: s = [rotate(n, w) for w in s]\n    s = rotate(n, ''.join(s))\n    s = [s[i+1-x: j-x] for x, (i, j) in enumerate(zip([-1] + sp, sp))]\n    if n > 0: s = [rotate(n, w) for w in s]\n    return ' '.join(s)\n\ndef encode(n, s):\n    for _ in range(n): s = cipher(n, s)\n    return f'{n} {s}'\n\ndef decode(s):\n    n, s = s.split(' ', 1)\n    n = int(n)\n    for _ in range(n): s = cipher(-n, s)\n    return s", "def encode(n,strng):\n    for _ in range(n):\n        wos, spa, new, a = '', [], '', []\n\n        for i in range(len(strng)):\n            if strng[i] == ' ': spa.append(i)\n            else: wos += strng[i]\n        shifted = []\n        for i in range(len(wos)): shifted.insert((i+n)%len(wos), wos[i])\n        for i in spa: shifted.insert(i, ' ')\n        for i in [i for i in ''.join(shifted).split(' ')]:\n            tem = []\n            for j in range(len(i)): tem.insert((j+n)%len(i), i[j])\n            a.append(''.join(tem))\n        strng = ' '.join(a)\n        \n    return '{} {}'.format(n, strng)\n\ndef decode(strng):\n    n = int(strng.split(' ')[0])\n    strng = strng[len(str(n))+1:]\n    for _ in range(n):\n        a, spa = [], []\n        for i in range(len(strng)):\n            if strng[i] == ' ':spa.append(i)\n        for i in [i for i in strng.split(' ')]:\n            tem = []\n            for j in range(len(i)): tem.insert((j-n)%len(i), i[j])\n            a.append(''.join(tem))\n        wos, shifted = ''.join(a), []\n        \n        for i in range(len(wos)): shifted.insert((i-n)%len(wos), wos[i])\n        \n        for i in spa:\n            shifted.insert(i, ' ')\n        strng = ''.join(shifted)\n    return(strng)", "def encode(n, cleartext):\n    def rotate_right(sequence, n):\n        n %= len(sequence) or 1\n        return sequence[-n:] + sequence[:-n]\n    for _ in range(n):\n        letters = iter(rotate_right([c for c in cleartext if c != ' '], n))\n        cleartext = ''.join(c if c == ' ' else next(letters) for c in cleartext)\n        cleartext = ' '.join(rotate_right(word, n) for word in cleartext.split(' '))\n    return f'{n} {cleartext}'\n\ndef decode(ciphertext):\n    def rotate_left(sequence, n):\n        n %= len(sequence) or 1\n        return sequence[n:] + sequence[:n]\n    n, ciphertext = ciphertext.split(' ', 1)\n    n = int(n)\n    for _ in range(n):\n        ciphertext = ' '.join(rotate_left(word, n) for word in ciphertext.split(' '))\n        letters = iter(rotate_left([c for c in ciphertext if c != ' '], n))\n        ciphertext = ''.join(c if c == ' ' else next(letters) for c in ciphertext)\n    return ciphertext", "SPACE, NULL_STR = \" \", \"\"\n\ndef rotate(n, s):\n    if not s: return NULL_STR\n    \n    if SPACE in s:\n        return SPACE.join(rotate(n, word) for word in s.split(SPACE))\n    \n    else:\n        n %= len(s)\n        return s[-n:] + s[:-n]\n\n\ndef cipher(n, s):\n    # extract spaces\n    spaces = [idx for idx, char in enumerate(s) if char == SPACE]\n    \n    for _ in range(abs(n)):\n        # rotate words (decoding)\n        if n < 0: s = rotate(n, s)\n        \n        # remove spaces, rotate string, put back spaces\n        s = s.replace(SPACE, NULL_STR)\n        s = rotate(n, s)\n        for idx in spaces: s = s[:idx] + SPACE + s[idx:]\n        \n        # rotate words (encoding)\n        if n > 0: s = rotate(n, s)\n    \n    return s\n\n\ndef encode(n, s):\n    return str(n) + SPACE + cipher(n, s)\n\n\ndef decode(s):\n    n, s = s.split(SPACE, 1)\n    n = int(n)\n    return cipher(-n, s)", "def encode(n,strng):\n    new_strng = strng.split(\" \")\n    for i in range(n):\n        strng = \"\".join(strng.split(\" \"))\n        strng = strng[-n:] + strng[:-n]\n        index_0 = 0\n        for i in range(len(new_strng)):\n            index = len(new_strng[i]) + index_0\n            new_strng[i] = strng[index_0:index]\n            index_0 = index\n        strng = \"\"\n        for i in new_strng:\n            change = n % len(i) if len(i) != 0 else i.count(\" \")\n            strng += i[-change:] + i[:-change] + \" \"\n        strng = strng[:-1]\n    return f\"{n} \" + strng\n\ndef decode(strng):\n    i = 0\n    num = \"\"\n    while strng[i].isdigit():\n        num += strng[i]\n        i += 1\n    num = int(\"\".join(num))\n    strng = strng[len(str(num))+1:]\n    new_strng = strng.split(\" \")\n    strng = \"\".join(strng.split(\" \"))\n    for i in range(num):\n        index_0 = 0\n        for i in range(len(new_strng)):\n            index = len(new_strng[i]) + index_0\n            new_strng[i] = strng[index_0:index]\n            index_0 = index\n        strng = \"\"\n        for i in new_strng:\n            change = num % len(i) if len(i) != 0 else i.count(\" \")\n            strng += i[change:] + i[:change]\n        strng = strng[num:] + strng[:num]\n    index_0 = 0\n    for i in range(len(new_strng)):\n        index = len(new_strng[i]) + index_0\n        new_strng[i] = strng[index_0:index]\n        index_0 = index\n    return \" \".join(new_strng)", "from collections import deque\nfrom itertools import chain, count\n\ndef _code(n, s, sign):\n    non_space, offset = [], count()\n    slice_points = [0,] + [\n            i - (0 if c != ' ' else next(offset))\n            for i, c in enumerate(s) \n            if c == ' ' or non_space.append(c)\n        ] + [len(s),]\n    slices = [slice(start, end) for start, end in zip(slice_points, slice_points[1:])]\n    ops = ([slice(None),] * (sign == 1) + slices + [slice(None),] * (sign == -1)) * n\n    for op in ops:\n        d = deque(non_space[op])\n        d.rotate(sign * n)\n        non_space[op] = d\n    return ' '.join(''.join(non_space[x]) for x in slices)\n\ndef encode(n, s):\n    ciphered = _code(n, s, 1)\n    return f'{n} {ciphered}'\n\ndef decode(s):\n    n, s = s.split(' ', 1)\n    return _code(int(n), s, -1)", "import re\nfrom collections import deque\ndef encode(n,s):\n    s = s.replace('\\n', '`')\n    for i in range(n):\n        pos, s = get_pos(s), deque(s.replace(' ', ''))\n        deque.rotate(s, n)\n        s = rotate(set_pos(s,pos),n,1)\n    return str(n) + ' ' + s.replace('`','\\n')\n\ndef decode(s):\n    n, s = re.search(r'^\\d+', s).group(), s.replace('\\n','`')\n    s, n = s[len(n) + 1:], int(n)\n    for i in range(n):\n        pos, s = get_pos(s), deque(''.join(deque(rotate(s,n,-1))).replace(' ', ''))\n        deque.rotate(s, -n)\n        s = ''.join(set_pos(s,pos))\n    return s.replace('`','\\n')\n\nget_pos = lambda s: [l for l, j in enumerate(s) if j == ' ']\ndef rotate(s,n,c):\n    li = []\n    for k in re.findall(r'(.+?)(\\s+)|(.+$)', ''.join(s)):\n          t = deque(k[0] or k[-1]) ; deque.rotate(t, n*c)\n          li.append(''.join(t) + k[1])\n    return ''.join(li)\ndef set_pos(s,position):\n    for pos in position : s.insert(pos, ' ')\n    return s", "def encode(n,s):\n    for i in range(n):\n        s =''.join(space(re(''.join([decore(e, n)for e in space(re(decore(s.replace(' ',''),n)),ws(s)).split(' ')])),ws(s)))  \n    return str(n)+' '+s\n    \ndef decode(s):\n    n, s = s.split(' ', 1)\n    n, sps = int(n), ws(s) \n    for i in range(n): \n        s = ''.join(space(re(decore(''.join([decore(e,-n)for e in s.split(' ')]),-n)),sps))\n    return s\n\ndef space(stg, arr):\n    for i in arr: stg.insert(i, ' ') \n    return ''.join(stg)\n\ndef decore(code, key):    \n    l = (len(code) or 1)\n    i = key % l\n    return  code[-i:] + code[:-i]\n    \nws = lambda s: [ i for i,e in enumerate(s) if e ==' ']\nre = lambda l: [e for e in l]", "def rotate(n, s):\n    i = -n % len(s) if len(s) > 0 else 1\n    return s[i:] + s[:i]\n\ndef cipher(n, s):\n    sp = [i for i, c in enumerate(s) if c == \" \"] + [len(s)]\n    s = s.split(' ')\n    if n < 0: \n        s = [rotate(n, w) for w in s]\n    s = rotate(n, ''.join(s))\n    s = [s[i+1-x:j-x] for x, (i, j) in enumerate(zip([-1] + sp, sp))]\n    if n > 0: \n        s = [rotate(n, w) for w in s]\n    return ' '.join(s)\n    \ndef encode(n, strng):\n    s = strng\n    for _ in range(n):\n        s = cipher(n, s)\n    return \"{} {}\".format(n, s)\n    \ndef decode(strng):\n    n, s = strng.split(\" \", 1)\n    n = int(n)\n    for _ in range(n):\n        s = cipher(-n, s)\n    return s"]