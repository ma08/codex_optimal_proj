["def fold_to(distance, thickness=0.0001, folds=0):\n    if distance < 0:\n        return\n    \n    while thickness < distance:\n        thickness *= 2\n        folds += 1\n    \n    return folds", "import math\ndef fold_to(d):\n    if d<0:\n        return None\n    if d<0.0001:\n        return 0\n    return math.ceil(math.log(d/0.0001,2))", "def fold_to(distance):\n    if distance < 0: return None\n    i = 0\n    while (0.0001) * 2 ** i < distance:\n        i += 1\n    return i", "def fold_to(distance):\n    if distance >= 0:\n        return int(distance * 10000).bit_length()", "def fold_to(distance):\n    const = 0.0001\n    if distance < 0:\n        return None\n    elif distance < const:\n        return 0\n    fold =  0\n    while distance > const * 2**fold:\n        fold += 1\n    return fold", "from math import ceil, log2\n\ndef fold_to(distance, thickness=1e-4):\n    if distance >= 0:\n        return distance >= thickness and ceil(log2(distance / thickness))", "from math import log\ndef fold_to(d):\n    if d == 0:\n        return 0\n    if d>0:\n        a = (log(d/0.0001)//log(2)) + 1\n        return max(a,0)", "def fold_to(distance):\n    fold, thickness = 0, 0.0001;\n    if distance < 0: return(None)\n    while thickness <= distance:\n        thickness *= 2\n        fold += 1\n    return(fold)", "def fold_to(d):\n  if d >= 0: return next(i for i in range(100) if 1e-4*2**i >= d)", "def fold_to(distance):\n  if distance >= 0: return next(i for i in __import__('itertools').count() if 1e-4*2**i >= distance)", "from math import log,ceil\ndef fold_to(d):\n    if d>=0: return d and max(0, ceil(log(10000*d, 2)))\n", "from math import log2, ceil\nfrom decimal import Decimal\n\npaper_thickness_meters = Decimal('0.0001')\n\ndef fold_to(distance):\n    if distance < 0:\n        return None\n    elif distance < paper_thickness_meters:\n        return 0\n    layers = Decimal(str(distance)) / paper_thickness_meters\n    return ceil(log2(layers))", "from math import log, ceil\n\ndef fold_to(d):\n    return None if d < 0 else 0 if d < 0.0001 else ceil(log(d/0.0001, 2))", "from math import log, ceil\n\ndef fold_to(distance, thickness = 0.0001):\n    return None if distance < 0 else 0 if distance <= thickness else ceil(log(distance/thickness, 2))", "def fold_to(distance):\n    thickness=0.0001\n    i=0\n    if(distance>0):\n      while(distance>thickness):\n          thickness*=2\n          i+=1\n      return i\n    else:\n        if(distance==0):\n            return 0\n        else:\n           return None", "from math import log2, ceil\n\n\ndef fold_to(distance):\n    return None if distance < 0 else ceil(log2(max(distance * 1e4, 1)))", "from math import log, ceil; fold_to=lambda d: None if d<0 else 0 if d<0.0001 else ceil(log(d*10000,2))", "def fold_to(distance):\n    print(distance)\n    if distance == None:\n        return 0\n    if distance < 0:\n        return None\n    if distance == 0.0:\n        return 0\n    res = .0001\n    folds = 0\n    while res < distance:\n        res *= 2\n        folds += 1\n    return folds\n", "def fold_to(distance):\n    thickness = 0.0001\n    if distance < 0:\n        return None;\n    else :\n        i = 0;\n        while thickness<distance:\n            thickness = thickness *2;\n            i = i +1;\n        return i;", "def fold_to(distance):\n    #your code here\n    folds = 0\n    thickness = 0.0001\n    total = 0\n    \n    if distance >= 0:\n        while thickness < distance:\n            thickness *= 2\n            folds += 1\n    \n    else:\n        return None\n    \n    return folds", "import math\n\ndef fold_to(distance):\n    if distance < 0:\n        return None\n    elif distance < 0.0001:\n        return 0\n    else:\n        n = (math.log((distance/0.0001), 10)/math.log(2, 10)) + 1\n        return math.floor(n)", "def fold_to(distance):\n    if distance < 0:\n        return None\n    thickness = 0.0001\n    idx = 0\n    while thickness < distance:\n        thickness *= 2\n        idx +=1 \n    return idx", "def fold_to(distance):\n    position = 0.0001\n    folds = 0\n    while position<distance:\n        position = position*2\n        folds +=1\n        \n    if distance<0:\n        return None\n    else:\n        return folds", "fold_to=lambda distance:None if distance <0 else 0 if distance==0 or __import__('math').log(distance*10000,2)<0 else int(__import__('math').log(distance*10000,2))+1", "import math\ndef fold_to(d):\n    if d<0:\n        return None\n    if d<.0001:\n        return 0\n    return math.ceil(math.log(10000*d)/math.log(2))", "def fold_to(distance):\n    paperThickness = .0001\n    folds = 0\n    if distance < 0:\n        return None\n    while paperThickness < distance:\n        paperThickness *=2\n        folds+=1\n    return folds", "import unittest\n\n\ndef fold_to(distance):\n    folding_count = 0\n    meter_of_paper = 0.0001\n\n    while meter_of_paper <= distance:\n        folding_count += 1\n        meter_of_paper = meter_of_paper * 2\n\n    return folding_count if distance >= 0 else None\n    \n    \nclass TestFoldTo(unittest.TestCase):\n    def test_fold_to_should_return_none_whne_given_distance_is_negative_one(self):\n        distance = -1\n        actual = fold_to(distance)\n        self.assertEqual(actual, None)\n\n    def test_fold_to(self):\n        distance = 384000000\n        actual = fold_to(distance)\n        self.assertEqual(actual, 42)\n", "def fold_to(distance):\n    paper_thick = 0.0001\n    folding=0\n    if distance < 0:\n        return None\n    elif distance == 0:\n        return 0\n    while distance > paper_thick:\n        paper_thick = paper_thick*2\n        folding+=1\n    return folding\n", "def fold_to(distance):\n    if distance < 0:\n        return None\n    elif distance == 0:\n        return 0\n    else:\n        folds = 0\n        thickness = 0.0001\n        while thickness <= distance:\n            thickness *= 2\n            folds += 1\n    return folds\n    #your code here\n", "def fold_to(distance):\n    a = 0\n    n = 0.0001\n    if distance < 0:\n        return None\n    while n < distance:\n        n *= 2\n        a += 1\n    return a", "THICKNESS = 0.0001\ndef fold_to(distance):\n    if distance < 0:\n        return None\n    current_thick = THICKNESS\n    time = 0\n    while current_thick < distance:\n        current_thick += current_thick\n        time += 1\n    return time", "def fold_to(distance):\n    if distance < 0: return None\n    length = 0.0001\n    count= 0\n    while length <= distance:\n        length *= 2\n        count += 1\n    return count", "def fold_to(distance):\n    if distance < 0: return None\n    length, count = 0.0001, 0\n    while length <= distance:\n        length *= 2\n        count += 1\n    return count", "import math\ndef fold_to(distance):\n    return (math.ceil(math.log2(distance/0.0001)) if distance >=0.0001 else None if distance < 0 else 0)", "def fold_to(distance):\n    if distance < 0:\n        return None\n    else:\n        counter = 0\n        i = 0.0001\n        while i <= distance:\n            i *= 2\n            counter += 1\n        return counter", "def fold_to(distance):\n    #your code here\n    import math\n    thick = 0.0001\n    if distance<0:\n        return None\n    elif distance<thick:\n        return 0\n    else:\n        return math.ceil(math.log2(distance/thick))\n", "def fold_to(distance):\n    thicc = 0.0001\n    counter = 0\n    if distance >= 0:\n        while thicc < distance:\n            thicc = thicc * 2\n            counter += 1\n    else:\n        counter = None\n    return counter", "def fold_to(distance):\n    folds = 0\n    thickness = 0.0001\n    if distance < 0:\n        return\n    while thickness < distance:\n        thickness *= 2\n        folds += 1\n    return folds", "from math import log, ceil\ndef fold_to(d):\n    if d < 0: \n        return None\n    if d == 0:\n        return 0\n    return max(0, ceil(log(d / 0.0001, 2)))", "def fold_to(distance):\n    d = 0.0001\n    c = 0\n    if distance < 0:\n        return None\n    while d < distance:\n        d = d * 2\n        c += 1\n    return c", "import math\ndef fold_to(distance):\n    if distance < 0: return None\n    su = 0.0001\n    fold = 0\n    while su < distance:\n        su*=2\n        fold+=1\n    return fold", "def fold_to(distance):\n    if distance < 0:\n        return\n    \n    i = 0\n    l = 0.0001\n    while l < distance:\n        l = l * 2\n        i = i + 1\n    return i", "import math\ndef fold_to(distance):\n    thickness = 0.0001\n    if distance == 0: \n        return 0\n    elif distance > 0:\n        return max(math.ceil(math.log(distance,2)-math.log(thickness,2)),0)\n    else:\n        return None", "def fold_to(distance):\n    if distance < 0:\n        return None\n    i = .0001\n    count = 0\n    if distance == 0:\n        return 0\n    while distance > i:\n        distance = distance / 2\n        count += 1\n    return count", "import math\ndef fold_to(distance):\n    if distance<0:\n        return None\n    if distance < 0.0001:\n        return 0\n    return int(math.ceil(math.log(distance/0.0001,2)))", "def fold_to(distance):\n    p = 0.0001\n    \n    \n    if distance < 0:\n        return None\n    \n    print(p)\n    if p >= distance:\n        return 0\n    \n\n    \n    count = 0\n    \n    print(p)\n    \n    while p < distance:\n        p += p\n        count += 1\n    \n    return count", "def fold_to(distance):\n    paper=0.0001\n    i=0\n    if distance<0:return None\n    while paper<distance:\n        i+=1\n        paper*=2\n    return i", "from math import log2\n\ndef fold_to(distance):\n    if distance < 0:\n        return None\n    elif distance == 0:\n        return 0\n    return max(int(log2(distance / 0.0001)) + 1, 0)", "def fold_to(distance):\n    if distance >= 0:\n        counter = 0\n        t = 0.0001\n        while t < distance:\n            t *= 2\n            counter += 1\n        return counter", "from math import log2, ceil\n\ndef fold_to(distance):\n    thickness = 0.0001\n    return None if distance < 0 else 0 if distance < thickness else ceil(log2(distance/thickness))", "def fold_to(distance):\n    thickness = 0.0001\n    if distance < 0:\n        return None\n    i = 0\n    while thickness < distance:\n        thickness *= 2\n        i += 1\n    return i", "from math import log2,ceil\n\ndef fold_to(distance):\n    if distance < 0 : return None\n    elif distance==0 : return 0\n    return max(0,ceil(log2(distance*10000)))", "def fold_to(d):\n    if d<0:\n        return None\n    r = 0.0001\n    x=0\n    while r < d:\n        x += 1\n        r *=2\n    return x", "def fold_to(d):\n    if d >= 0: return next(i for i in range(88) if 1e-4*2**i >= d)", "def fold_to(distance):\n    if distance<0:\n        return None\n    for i in range(0,10000):\n        if (2**i)*0.0001>=distance:\n            return i\n", "def fold_to(distance):\n    count=0\n    if distance < 0:\n        return None\n    thickness=0.0001\n    if distance < thickness:\n        return 0\n    while thickness < distance:\n        thickness *= 2\n        count += 1\n    return count\n", "def fold_to(distance):\n    \n    if distance < 0 :\n        return None\n    \n    a = 0\n    \n    while distance >= .0001 :\n        distance /= 2\n        a += 1\n    \n    return a\n", "import math\ndef fold_to(distance):\n    if distance < 0:\n        return None\n    fold = math.ceil(math.log(distance/0.0001, 2)) if distance else 0\n    return fold if fold > 0 else 0\n", "import math\n\ndef fold_to(distance):\n    if distance <0:\n        return None\n    if distance <0.0001:\n        return 0\n    else:\n        return math.ceil((math.log(distance/0.0001))/(math.log(2)))\n    \n", "def fold_to(distance):\n    if distance <0 : return None\n    d = 0.0001\n    n = 0\n    while(d<distance) : \n        d *=2\n        n +=1\n    return n", "def fold_to(distance):\n    if distance < 0.0:\n        return None\n    thickness = 0.0001\n    count = 0\n    while thickness < distance:\n        thickness = thickness*2\n        count+=1\n    return count\n    #end\n", "def fold_to(distance):\n    if distance < 0:\n        return None\n    if distance < 0.0001:\n        return 0\n    counter = 0\n    while distance > 0.0001:\n        distance /= 2\n        counter += 1\n    return counter\n", "def fold_to(distance):\n    if distance<0: return None\n    thickness = 0.0001\n    n = 0\n    while thickness*(2**n) < distance:\n        #print(n, 2**n, thickness*(2**n))\n        n+=1\n    return n", "def fold_to(distance):\n    epais = 0.0001\n    compte=0\n    if distance<0:\n        return None\n    else:\n        while epais<distance:\n            epais=epais*2\n            compte += 1\n        return compte", "def fold_to(distance):\n    folds = 0\n    thickness = 0.0001\n    if distance < 0:\n        return None\n    else:\n        while thickness < distance:\n            thickness *= 2\n            folds += 1\n        return folds", "def fold_to(distance):   \n    thick = 0.0001\n\n    if distance < 0:\n        return None\n\n    elif thick > distance:\n        return 0\n\n    else:\n        counter = 0\n        while thick < distance:\n            thick = thick * 2\n            counter += 1\n\n    return counter", "def fold_to(distance):\n    fold=0.0001\n    \n    if distance <=-1:\n        return None\n    elif distance < fold:\n        return 0\n    i=0\n    while fold<=distance:\n        fold=fold*2\n        i+=1\n    return i", "def fold_to(distance):\n    x = 0.0001\n    count = 0\n    if distance > x:\n        while(x < distance):\n            x += x\n            count += 1\n        return count\n    elif distance<0:\n        return None\n    return 0", "import math\ndef fold_to(distance):\n    return math.ceil(math.log((distance/0.0001),2)) if distance>0.0001 else None if distance<0 else 0", "from math import log2, ceil\ndef fold_to(distance):\n    if 0 > distance: return None\n    if distance <= 0.0001: return 0\n    return ceil(log2(10000*distance))", "def fold_to(distance):\n  if (distance < 0): return None\n  folds = 0\n  while (0.0001 < distance): folds += 1; distance /= 2\n  return folds", "def fold_to(distance):\n    if distance < 0:\n        return None\n        \n    thiccness = .0001\n    folds = 0\n    \n    while thiccness < distance:\n        thiccness = thiccness * 2\n        folds = folds + 1\n        \n    return folds\n        \n", "def fold_to(distance):\n    i = 0\n    while distance > 0.00010:\n        distance =distance / 2\n        i += 1\n        \n    return i if distance >=0 else None", "def fold_to(distance):\n    thickness = 0.0001\n    folds = 0\n    \n    if distance < 0:\n        return None\n        \n    elif distance < thickness:\n        return 0\n        \n    else:\n        while thickness < distance:\n            thickness = thickness * 2\n            folds = folds + 1\n        \n            if thickness >= distance:\n                return int(folds)", "def fold_to(distance):\n    if distance < 0:\n        return None\n    n = 0.0001\n    cnt = 0\n    while n < distance:\n        n = n*2\n        cnt += 1\n    return cnt", "def fold_to(distance):\n    if distance >= 0:\n        thicc = 0.0001\n        count = 0\n        while thicc < distance:\n            thicc = thicc * 2\n            count += 1 \n        return count\n    else: return None ", "def fold_to(distance):\n    #your code here\n    n = 0\n    results = 0\n    if 0.0001 < distance:\n        while results < distance:\n            n+=1\n            results = 0.0001*(2**n) \n        return n\n    if distance < 0:\n        return None\n    if 0.0001 > distance:\n        return 0\n        \n\n", "from math import ceil, log2\ndef fold_to(distance):\n    thickness = 0.0001\n    if distance < 0:\n        return None\n    if distance <= thickness:\n        return 0\n    return ceil(log2(distance/thickness))", "def fold_to(distance):\n    from math import log, ceil\n    distance = float(distance)\n    paper = 0.0001\n    if distance >= paper:\n        return ceil(log(distance/paper, 2))\n    else:\n        if distance >= 0:\n            return 0\n        else:\n            return None", "from math import ceil, log2\n\ndef fold_to(distance):\n    if distance < 0:\n      return None\n    if not distance:\n      return 0\n    return max(0, ceil(log2(distance / 0.0001)))", "from math import *\ndef fold_to(d):\n    if d < 0 : return None\n    elif floor(d*10000) == 0: return 0\n    else : return ceil(log(d*10000, 2))", "def fold_to(distance):\n    p = 0.0001\n    n = 0\n    while p <= distance:\n         p = p * 2\n         n += 1\n    if distance < 0:\n       return None\n    else:\n       return n\n    #your code here\n", "from math import *\ndef fold_to(distance):\n    if distance < 0: return None\n    elif distance < .0001: return 0\n    else: return ceil(log2(distance/.0001))", "def fold_to(distance):\n    count = 0\n    p_thickness = 0.0001\n    if distance >= 0:\n        while p_thickness < distance:\n            p_thickness *=2\n            count += 1\n        return count\n    else:\n        return None", "def fold_to(B):\n    if B < 0: return None\n    B *= 10_000\n    L = 1\n    M = 0\n    while L < B:\n        L *= 2\n        M += 1\n    return M\n        \n", "def fold_to(distance):\n    if distance<0: return None\n    d= distance//0.0001\n    i=0\n    while d>0:\n       d//=2\n       i+=1\n    return i", "def fold_to(distance):\n    paper = 0.0001\n    folds = 0\n    if distance < 0:\n        return None\n    distance -= paper\n    while distance > 0:\n        distance -= paper\n        paper *= 2\n        folds += 1\n    return folds\n", "def fold_to(d,t = 0.0001):\n    if 0 <= d <= t: \n        return 0\n    elif d <= 0: \n        return None\n        \n    c = 0\n    while t < d:\n        c+=1\n        t*=2\n    return c", "def fold_to(distance):\n    n, count = 0.0001, 0\n    while n < distance:\n        n, count = n*2, count+1\n    return None if distance < 0 else count", "def fold_to(d):\n    folds = 0\n    t = 0.0001;\n    if d < 0: return(None)\n    while t <= d:\n        t = t*2\n        folds += 1\n    return (folds)\n    \n    \n    \n", "def fold_to(distance):\n    if distance < 0:\n        return None\n    count = 0\n    paper = 0.0001\n    while paper < distance:\n        count += 1\n        paper *= 2\n    return count", "def fold_to(distance):\n    #your code here\n    i = 0.0001\n    n = 0\n    if distance < 0 : return None\n    while i<distance :\n        i = i*2\n        n += 1\n    return n\n", "def fold_to(distance):\n    if distance >= 0:\n        times = 0\n        size = 0.0001\n        while size < distance:\n            size *= 2\n            times += 1\n        return times\n    else:\n        return None", "def fold_to(distance):\n    folds = 0\n    h = 0.0001\n    while h < distance:\n        h *= 2\n        folds += 1\n    return folds if distance >= 0 else None", "def fold_to(distance):\n    thick=0.0001\n    i=0\n    if distance<0:\n        return None\n    else:\n        while thick<distance:\n            thick=2*thick;\n            i=i+1;\n    return i\n    #your code here\n", "from math import log2, ceil\n\ndef fold_to(d):\n    return ceil(log2(d/0.0001)) if d>0.0001 else None if d<0 else 0", "def fold_to(distance):\n    if distance < 0: \n        return None\n        \n    res = 0\n    d = 0.0001\n    while d < distance: \n        d *= 2\n        res +=1\n    return res", "def fold_to(distance):\n    if distance < 0:\n        return None\n    res = 0\n    l = 0.0001\n    while l < distance:\n        l *= 2\n        res += 1 \n        \n    return res"]