["def sim(k,n,p):\n    r = [(k,k,0),(k,p,p)]\n    for i in range(n-2):\n        u,d = r[0][1]+r[1][1],r[1][1]\n        r = [r[1],(r[1][0]+u-d,u,d)]\n    return r[1][0]\n\ndef calc(k,n,m,x):\n    z,o = sim(k,n-1,0), sim(k,n-1,1)\n    return sim(k,x,(m-z)//(o-z))", "def fibLikeGen():\n    a,b = (1,0), (0,1)                  # a: station i-1, b: station i\n    while 1:\n        yield a,b\n        a,b = b, tuple(x+y for x,y in zip(a,b))\n\ngen    = fibLikeGen()\nSUM_AT = [(), (1,0), (1,0)]             # (k,l)\n        \ndef getCoefs(n):\n    while len(SUM_AT) <= n:\n        a,b = next(gen)\n        SUM_AT.append(tuple(x+y for x,y in zip(a,SUM_AT[-1])))\n    return SUM_AT[n] \n\n\ndef calc(k,n,m,x):\n    a,b = getCoefs(n-1)\n    l   = (m-a*k) // b\n    a,b = getCoefs(x)\n    return a*k + b*l", "def fib(n, a, b):\n    for i in range(n):\n        yield a\n        a, b = b, a+b\n        \ndef calc(k,n,m,x):\n    if x <= 2:\n        return k\n    if x == 3:\n        return 2 * k\n    b = 2 + sum(fib(n-4-1, 1, 1))\n    a = 1 + sum(fib(n-4-1, 1, 2))\n    c = (m - b*k) // a\n    b = 2 + sum(fib(x-4, 1, 1))\n    a = 1 + sum(fib(x-4, 1, 2))\n    return k*b + c*a", "fib = {3: 0, 4: 1, 5: 1}\nfor i in range(6, 31):\n    fib[i] = fib[i - 2] + fib[i - 1]\n\ndef coefficients(n):\n    y, z = 2, 0 # coefficients for number of passengers at station 3\n    for i in range(4, n):\n        y += fib[i - 1]\n        z += fib[i]\n    return y, z\n\ndef calc(k, n, m, x):\n    y, z = coefficients(n)\n    station2 = (m - y * k) // z\n    y, z = coefficients(x + 1)\n    return y * k + z * station2", "FIB = [0, 1]\nfor _ in range(1000): FIB.append(FIB[-2] + FIB[-1])\n\ndef calc(k, n, m, x):\n    l = (m - (FIB[n-3] + 1) * k) // (FIB[n-2] - 1)\n    return (FIB[x-2] + 1) * k + (FIB[x-1] - 1) * l", "from functools import reduce, lru_cache\n\n\ndef calc(k,n,m,x):\n    n_of_eq_var = sum(fib(i) for i in range(1, n-4)) + 2\n    got_on_2nd = int(\n        (m - k * n_of_eq_var) / sum(fib(i) for i in range(1, n-3))\n    )\n    \n    return reduce(\n        lambda result, i: result+fib(i, k, got_on_2nd), range(1, x-1), k\n    )\n\n\n@lru_cache(None)\ndef fib(n, fib_1=1, fib_2=1):\n    for _ in range(n-2):\n        fib_1, fib_2 = fib_2, fib_1+fib_2\n\n    return fib_2 if n > 1 else fib_1", "def calc(k,n,m,x):\n     \n    f1=1\n    f2=0\n    fz2=0\n    s=0\n    t=0\n    for i in range(1,n-3) :\n        s+=f2\n        a=f1\n        f1=a+f2\n        f2=a\n        if i==x-3 : \n            t =s \n            fz2=f2\n    \n    A=(m-k*(s+2))/(s+f2)\n    return A*(t+fz2)+k*(t+2)", "class Memoize:\n    def __init__(self, fn):\n        self.fn = fn\n        self.memo = {}\n\n    def __call__(self, *args):\n        if args not in self.memo:\n            self.memo[args] = self.fn(*args)\n        return self.memo[args]\n\n@Memoize #makes things alot faster\ndef fib_spec(n): #that is the gain per station, so really we have to take the sum of all n's\n    if n == 0:\n        return (1, 0)\n    elif n == 1:\n        return (0, 1)\n    else:\n        k_1, s_1 = fib_spec(n-1)\n        k_2, s_2 = fib_spec(n-2)\n        return (k_1+k_2, s_1+s_2)\n\n\ndef calc(k,n,m,x):\n    if x in (1,2):\n        return k\n    elif x == 3:\n        return 2*k\n    s_ = 0\n    k_ = 1\n    for i in range(n-3):\n        tmp_k, tmp_s = fib_spec(i)\n        s_ += tmp_s\n        k_ += tmp_k\n        if i == x-3:\n            s_x, k_x = s_, k_\n    s = (m-k*k_)//s_\n    return k_x*k+s_x*s", "class Memoize:\n    def __init__(self, fn):\n        self.fn = fn\n        self.memo = {}\n\n    def __call__(self, *args):\n        if args not in self.memo:\n            self.memo[args] = self.fn(*args)\n        return self.memo[args]\n\n@Memoize\ndef fib_spec(n): #that is the gain per station, so really we have to take the sum of all n's\n    if n == 0:\n        return (1, 0)\n    elif n == 1:\n        return (0, 1)\n    else:\n        k_1, s_1 = fib_spec(n-1)\n        k_2, s_2 = fib_spec(n-2)\n        return (k_1+k_2, s_1+s_2)\n\n\ndef fib(k, s, n):\n    if n == 0:\n        return k\n    elif n == 1:\n        return s\n    else:\n        return fib(k, s, n-1) + fib(k, s, n-2)\n\ndef calc(k,n,m,x):\n    if x in (1,2):\n        return k\n    elif x == 3:\n        return 2*k\n    s_ = 0\n    k_ = 1\n    for i in range(n-3):\n        tmp_k, tmp_s = fib_spec(i)\n        s_ += tmp_s\n        k_ += tmp_k\n    s = (m-k*k_)//s_\n    \n    s_ = 0\n    k_ = 1\n    for i in range(x-2):\n        tmp_k, tmp_s = fib_spec(i)\n        s_ += tmp_s\n        k_ += tmp_k\n    return k_*k+s_*s\n\n", "def calc(k,n,m,x):\n    # solve how many people get on board at station 2:\n    on_list_x = [0, 1, 1, 2, 3]  # num of times x people get on\n    on_list_k = [k, 0, k, k, 2*k]  # k people get on\n\n    off_list_x = [0, 1, 1, 1, 2]\n    off_list_k = [0, 0, 0, k, k]\n    # total a*x + b*k at index n-1 == m\n    while len(on_list_x) < n-1:\n        on_list_x.append(on_list_x[-1] + on_list_x[-2])\n        on_list_k.append(on_list_k[-1] + on_list_k[-2])\n        off_list_x.append(off_list_x[-1] + off_list_x[-2])\n        off_list_k.append(off_list_k[-1] + off_list_k[-2])\n    num_x = sum(on_list_x) - sum(off_list_x)\n    num_k = sum(on_list_k) - sum(off_list_k)\n    x_val = (m - num_k) / num_x  # people at station 2\n    \n    # now all numbers of boarding and leaving people can be calculated:  \n    passengers_station_x = (sum(on_list_x[:x]) - sum(off_list_x[:x]))*x_val + sum(on_list_k[:x]) - sum(off_list_k[:x])\n\n    return int(passengers_station_x)"]