["def colorful(number):\n    base_result = []\n    for x in str(number):\n        base_result.append(int(x))\n    for y in range(len(base_result) - 1):\n        temp = base_result[y] * base_result[y + 1]\n        base_result.append(temp)\n    # Should you really eval the last value ? :shrug: If so, would use eval\n    return len(set(base_result)) == len(base_result)", "from functools import reduce\nfrom collections import Counter\n\ndef colorful(n):\n    s = list(map(int,str(n)))\n    cnt = Counter( reduce(int.__mul__, s[i:i+x]) for x in range(1,len(s)+1) for i in range(len(s)-x+1))\n    return cnt.most_common(1)[0][1] == 1", "from functools import reduce\n\n\ndef colorful(n):\n    ld = [int(d) for d in str(n)]\n    l = len(ld)\n    p = [reduce(int.__mul__, ld[i:i+k]) for k in range(1, l+1) for i in range(l-k+1)]\n    return len(p) == len(set(p))\n", "REGEX = __import__(\"re\").compile(\n    r\"(.).*\\1\" # Duplicate digit\n    r\"|[01].+|.+[01]\" # 0 or 1 and another digit\n    r\"|(23|32).*6|6.*(23|32)\" # 2*3 and a 6 before or after\n    r\"|(24|42).*8|8.*(24|42)\" # 2*4 and a 8 before or after\n    r\"|(26|62).*(34|43)|(34|43).*(26|62)\" # 2*6 and 3*4 before or after\n    r\"|(29|92).*(36|63)|(36|63).*(29|92)\" # 2*9 and 3*6 before or after\n    r\"|(38|83).*(46|64)|(46|64).*(38|83)\" # 3*8 and 4*6 before or after\n    r\"|(49|94).*(236|263|326|362|623|632)|(236|263|326|362|623|632).*(49|94)\" # 4*9 and 2*3*6 before or after\n    r\"|(89|98).*(346|364|436|463|634|643)|(346|364|436|463|634|643).*(89|98)\" # 8*9 and 3*4*6 before or after\n).search\n\ndef colorful(number):\n    return not REGEX(str(number))", "def colorful(number):\n    lst = [int(d) for d in str(number)]\n    \n    if number > 9:\n        # no need to compute : if 1 ==> previous * 1 == previous, if 0 ==> previous * 0 == 0\n        if 0 in lst or 1 in lst:\n            return False\n            \n        all, previous = lst, -1\n        for digit in str(number):\n            # not the first time\n            if previous != -1:\n                lst.append(int(digit) * previous)\n            previous = int(digit)\n        \n        # if 1 or 2 digits : multiplication of all numbers is already added to the list\n        if number > 99:\n            total = 1\n            for d in all:\n                total *= d\n            lst.append(total)\n        \n    return len(lst) == len(set(lst))", "def colorful(number):\n    if len(str(number)) == 1: \n        return True\n    else:\n        output = list(str(number))\n        for n,x in enumerate(list(str(number))):\n            if n + 1 < len(str(number)):\n                tmp = list(str(number))[n+1]\n                \n                #tmp = int()\n                output.append(str(int(x) * int(tmp)))\n       \n        if len(output) == len(set(output)):\n            return True\n        else:\n            return False    \n            \n      \n", "from functools import reduce\nfrom operator import mul\n\ndef colorful(number):\n    digits = [int(d) for d in str(number)]\n    prods = []\n    \n    for size in range(1, len(digits) +1):\n        for start in range(len(digits)-size +1):\n            prods.append(reduce(mul, digits[start : start+size]))\n    \n    return len(prods) == len(set(prods))", "from functools import reduce\n\ndef colorful(n):\n    s = list(map(int,str(n)))\n    return len(s)*(len(s)+1)//2 == len({ reduce(int.__mul__, s[i:i+x]) for x in range(1,len(s)+1) for i in range(len(s)-x+1)})", "from functools import reduce\n\n\ndef colorful(n):\n    p = list(get_sub_mul(n))\n    return len(p) == len(set(p))\n\n\ndef get_sub_mul(n):\n    s = [int(d) for d in str(n)]\n    l = len(s)\n    for k in range(1, l+1):\n        for i in range(l-k+1):\n            yield reduce(int.__mul__, s[i:i+k])\n", "from functools import reduce\nfrom math import ceil\ndef colorful(n): \n    li=[reduce(lambda x,y: x*y, map(int, str(n)[i:i+j]))for j in range(1,ceil(len(str(n)) / 2)+2)for i in range(0,len(str(n))-j+1)]\n    return all(li.count(i)==1 for i in li)"]