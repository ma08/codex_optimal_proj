["def string_constructing(a, s):\n    if len(s) == 0:\n        return 0\n    i = -1\n    for j, c in enumerate(s):\n        i = a.find(c, i+1)\n        if i < 0 or i == len(a) - 1:\n            break\n    return len(a) - j + (i < 0) + string_constructing(a, s[j + (i >= 0):])", "def string_constructing(pattern,target):\n    pattern = list(pattern)\n    target = list(target) + [None]\n    buffer = [None]\n    pos= 0\n    count= 0\n    while (True):\n        \n        if(target[pos]==buffer[pos]):\n            if(target[pos]==None):\n                return count\n            pos +=1\n        else:\n            if(buffer[pos]==None):\n                buffer[-1:-1]=pattern\n                count+=1\n            else:\n                del buffer[pos]\n                count+=1\n            \n    return count\n        \n    \n    \n", "import re\n\ndef string_constructing(a, s):\n    n = len(re.findall('?'.join(list(a))+'?', s)) - 1          # \"-1\" because one empty string is always found at the end\n    return n + len(a)*n - len(s)", "def string_constructing(a, s):\n    i = 0\n    for c in s:\n        while a[i % len(a)] != c:\n            i += 1\n        i += 1\n    return (i + len(a) - 1) // len(a) * (len(a) + 1) - len(s)", "def string_constructing(a, s):\n    i, r = 0, 1\n    for x in s:\n        y = a[i % len(a)]\n        while x != y:\n            r += 1\n            i += 1\n            y = a[i % len(a)]\n        i += 1\n    return r + i // len(a) + -i % len(a) - (i % len(a) == 0)\n", "def string_constructing(a, s):\n    current = \"\"\n    step = 0\n    while current != s:\n        for i in range(len(current)):\n            if i >= len(s):\n                return step + len(current) - len(s)\n            if current[i] != s[i]:\n                current = current[i+1:]\n                s = s[i:]\n                break\n        else:\n            current += a\n        step += 1\n                \n    return step", "def string_constructing(a, s):\n    T = a\n    c, al = 1, 0\n    while T != s:\n        if al < len(T) and al < len(s) and T[al] == s[al]:\n            al += 1\n        elif al == len(T):\n            T += a\n            c += 1\n        elif len(s) < len(T) or T[al] != s[al]:\n            T = T[:al] + T[al + 1:]\n            al = max(al - 1, 0)\n            c += 1\n    return c", "def common_len(s1,s2):\n    n, m = len(s1), len(s2)\n    i=0\n    for c1 in s1:\n        if i>=len(s2):\n            break\n        elif c1==s2[i]:\n            i+=1\n    return i\n\ndef string_constructing(a, s):\n    r=[]\n    c=0\n    p=0\n    while(p<len(s)):\n        l=common_len(a,s[p:p+len(a)])\n        c+=1+len(a)-l\n        p+=l    \n    return c", "def string_constructing(a,b):\n    s, c = [], 0\n    while ''.join(s) != b:\n        s.extend(list(a))\n        c += 1 ; i = 0\n        while i < len(s) and i < len(b):\n            if s[i] == b[i] : i += 1\n            else : c += 1 ; s.pop(i)\n        if ''.join(s).startswith(b) : c += len(s[len(b):]) ; break\n    return c", "def string_constructing(a, s):\n    if not s:\n        return 0\n    if set(s)-set(a):\n        return False\n\n    n = 1\n    i = 0\n    for c in s:\n        while True:\n            if i==len(a):\n                i = 0\n                n += 1\n            if a[i]!=c:\n                n += 1\n                i+=1\n            else:\n                i+=1\n                break\n            \n            \n    return n+len(a)-i\n"]