["class Solution:\n     def maximumProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         import heapq\n         a, b = heapq.nlargest(3, nums), heapq.nsmallest(2, nums)\n         return max(a[0]*a[1]*a[2], a[0]*b[0]*b[1])", "class Solution:\n     def maximumProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         a, b = heapq.nlargest(3, nums), heapq.nsmallest(2, nums)\n         return max(a[0]*a[1]*a[2], a[0]*b[0]*b[1])", "class Solution:\n     def maximumProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         h, m, l = -float('inf'), -float('inf'), -float('inf')\n         lowest, second_lowest = float('inf'), float('inf')\n         \n         for num in nums:\n             if num > h:\n                 l = m\n                 m = h\n                 h= num\n             elif num > m:\n                 l = m\n                 m = num\n             elif num > l:\n                 l = num\n                 \n             if num < lowest:\n                 second_lowest = lowest\n                 lowest = num\n             elif num < second_lowest:\n                 second_lowest = num\n                 \n         return max(h*m*l, h*lowest*second_lowest)", "class Solution:\n     def maximumProduct1(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         #Easy way to do it: sort them, take top 3 product\n         #But have to think about negative numbers, lowest\n         #2 could be 2 giant negatives.. * biggest positive\n         #which could still be biggest product\n         \n         nums.sort()\n         top = nums[~0] * nums[~1] * nums[~2]\n         bottom = nums[0] * nums[1] * nums[~0]\n         return max(top, bottom)\n         #Time O(nlogn) due to sorting\n         #Space O(1)\n         \n     \n     def maximumProduct(self, nums):\n         #Other approach is keep track of min1/2\n         #and max1/2/3 while we iterate through the array\n         min1 = min2 = float('inf')\n         max1 = max2 = max3 = -float('inf')\n         \n         for n in nums:\n             if n <= min1:\n                 min1, min2 = n, min1\n             elif n <= min2:\n                 min2 = n\n             \n             if n >= max1:\n                 max1, max2, max3 = n, max1, max2\n             elif n >= max2:\n                 max2, max3 = n, max2\n             elif n >= max3:\n                 max3 = n\n             \n         return max(min1*min2*max1, max1*max2*max3)\n", "class Solution:\n     def maximumProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         max1,max2,max3,min1,min2 = float('-Inf'),float('-Inf'),float('-Inf'),float('Inf'),float('Inf')\n         for num in nums:\n             if num >= max1:\n                 max3,max2,max1 = max2,max1,num\n             elif num >= max2:\n                 max3,max2 = max2,num\n             elif num > max3:\n                 max3 = num\n             if num <= min1:\n                 min2,min1 = min1,num\n             elif num < min2:\n                 min2 = num\n         return max(max1*max2*max3,min1*min2*max1)\n         \n         \n", "class Solution:\n     def maximumProduct(self, nums):\n         a = b = c = -1001\n         d = e = 1001\n         for num in nums:\n             if num >= a:\n                 c = b\n                 b = a\n                 a = num\n             elif num >= b:\n                 c = b\n                 b = num\n             elif num >= c:\n                 c = num\n                 \n             if num <= d:\n                 e = d\n                 d = num\n             elif num <= e:\n                 e = num\n         return max(a * b * c, a * d * e)\n", "class Solution:\n     def maximumProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         max_num = -1000\n         s_max = -1000\n         t_max = -1000\n         min_num = 1000\n         s_min = 1000\n         \n         for i in range(len(nums)):\n             if nums[i] > max_num:\n                 t_max = s_max\n                 s_max = max_num\n                 max_num = nums[i]\n             elif nums[i] > s_max:\n                 t_max = s_max\n                 s_max = nums[i]\n             elif nums[i] > t_max:\n                 t_max = nums[i]\n             if nums[i] < min_num:\n                 s_min = min_num\n                 min_num = nums[i]\n             elif nums[i] < s_min:\n                 s_min = nums[i]\n \n         print (max_num, s_max, t_max, min_num, s_min)\n         a = max_num * s_max * t_max  \n         b = min_num * s_min * max_num       \n         if a > b:\n             return(a)\n         else:\n             return(b)", "class Solution:\n     def maximumProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         max_num = -1000\n         s_max = -1000\n         t_max = -1000\n         min_num = 1000\n         s_min = 1000\n         \n         for i in range(len(nums)):\n             if nums[i] > max_num:\n                 t_max = s_max\n                 s_max = max_num\n                 max_num = nums[i]\n             elif nums[i] > s_max:\n                 t_max = s_max\n                 s_max = nums[i]\n             elif nums[i] > t_max:\n                 t_max = nums[i]\n             if nums[i] < min_num:\n                 s_min = min_num\n                 min_num = nums[i]\n             elif nums[i] < s_min:\n                 s_min = nums[i]\n \n         print (max_num, s_max, t_max, min_num, s_min)\n         a = max_num * s_max * t_max  \n         b = min_num * s_min * max_num       \n         if a > b:\n             return(a)\n         else:\n             return(b)", "class Solution:\n     def maximumProduct(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         new=[0 for i in range(2001)]\n         for i in range(len(nums)):\n             new[1000+nums[i]]=new[1000+nums[i]]+1\n         count=0\n         product=1\n         digit=[]\n         for i in range(2000,-1,-1):\n             while(new[i]>0):\n                 digit.append(i-1000)\n                 count=count+1\n                 new[i]=new[i]-1\n                 if count==3:\n                     break\n             if count==3:\n                 break\n         for i in range(2001):\n             while(new[i]>0):\n                 digit.append(i-1000)\n                 count=count+1\n                 new[i]=new[i]-1\n                 if count==5:\n                     break\n             if count==5:\n                 break\n         if len(digit)==3:\n             return digit[0]*digit[1]*digit[2]\n         elif len(digit)==4:\n             return max(digit[0]*digit[1]*digit[2],digit[3]*digit[1]*digit[2])\n         else:\n             p1=digit[0]*digit[3]*digit[4]\n             p2=digit[0]*digit[1]*digit[2]\n             return max(p1,p2)\n         \n         \n"]