["def ulam_sequence(u, v, n):\n    lst, seq, ex, q = [], 1, 1, 1 << v | 1 << u  # Put u and v into queue\n    for _ in range(n):                           # Repeat n times\n        w = q & -q                               # Take the smallest candidate\n        l = w.bit_length() - 1                   # and its value\n        s = seq << l                             # Generate its sums with all previous values\n        seq |= w                                 # Append it afterwards to the sequence\n        lst.append(l)                            # and to the list\n        ex |= s & q                              # Update excluded values if any is already in queue\n        q |= s                                   # Put previous sums into queue\n        q &= ~ex                                 # Remove excluded values from queue\n    return lst                                   # Return sequence list", "def ulam_sequence(u0, u1, n):\n    # set up variables\n    seq = [u0, u1]\n    candidates = (u0+u1) * n * [0]\n    candidates[u0 + u1] = 1\n    num = u1 + 1\n    \n    for _ in range(n-2):\n        # find smallest candidate\n        while candidates[num] != 1:\n            num += 1\n        # adjust list if needed\n        if len(candidates) < num * 2:\n            candidates.extend([0] * (num * 2 - len(candidates)))\n        # calculate new candidates\n        for x in seq:\n            candidates[num + x] += 1\n        # update sequence\n        seq.append(num)\n        num += 1\n    \n    return seq", "from collections import defaultdict\nfrom heapq import heappop, heappush\n\n\ndef ulam_sequence(u0, u1, n):\n    q, seen, lst = [u1], defaultdict(int), [u0]\n    seen[u1] = 1\n    \n    while len(lst) < n:\n    \n        while 1:                                 # Extract next Ulam number\n            last = heappop(q)\n            if seen[last] == 1: break\n        \n        for v in lst:                            # Generate all possible new Ulam numbers, using the last found\n            x = v+last\n            if x not in seen: heappush(q,x)      # candidate found\n            seen[x] += 1\n            \n        lst.append(last)\n        \n    return lst", "import heapq\n\ndef ulam_sequence(u0, u1, n):\n    seq,h,s = [u0,u1],[u0+u1],set()\n    while len(seq) < n:\n        v=heapq.heappop(h); h=set(h)\n        for u in seq:\n            if u+v not in s: s.add(u+v); h.add(u+v)\n            elif u+v in h: h.remove(u+v)\n        seq.append(v); h=list(h); heapq.heapify(h)\n    return seq", "def ulam_sequence(u0, u1, n):\n    sequence = [u0, u1]\n    good = {u0+u1}\n    bad = set()\n    while len(sequence) < n:\n        k = min(good)\n        good.remove(k)\n        for h in sequence:\n            s = k + h\n            if s in good:\n                good.remove(s)\n                bad.add(s)\n            elif s not in bad:\n                good.add(s)\n        sequence.append(k)\n    return sequence\n", "def ulam_sequence(u0, u1, n):\n    S0={u0+u1}\n    S1=set()\n    a=[u0, u1]\n    c=a.append\n    for k in range(2,n):\n        m=min(S0)\n        c(m)\n        S0.discard(m)\n        \n        \n    \n        T={a[i]+a[k] for i in range(k)}\n        S0,S1=S0^T-S1, S1|(S0&T)\n        \n    return a", "def ulam_sequence(u0, u1, n):\n    print(u0,u1,n)\n    ans, curr, seto = [u0, u1], u1+1, {u0, u1}\n    while len(ans) < n:\n        temp, ways = 0, 0\n        for mo in ans:\n            if curr - mo in seto and mo != (curr - mo):\n                temp = curr\n                ways += 1\n                if ways > 2: break\n        if ways == 2:\n            ans.append(temp)\n            seto.add(temp)\n        curr += 1\n    return ans", "def ulam_sequence(u0, u1, n):\n    sequence = [u0, u1]\n    sums = {u0 + u1}\n    unique_sums = {u0 + u1}\n    for i in range(n - 3):\n        next_num = min(unique_sums)\n        for ulam in sequence:\n            n = ulam + next_num\n            if n not in sums:         \n                sums.add(n) \n                unique_sums.add(n)\n            else:\n                if n in unique_sums:      \n                    unique_sums.remove(n)\n        unique_sums.remove(next_num)\n        sequence.append(next_num)\n    sequence.append(min(unique_sums))\n    return sequence\n", "import time\nfrom heapq import heappush, heappop, heapify\n \n\ndef ulam_sequence(u, v, numTerms):\n    \n    terms = [u, v] # This is the sequence we are producing.\n    sumsDict = dict([(u, 1), (v,1), (u+v, 1)]) # This is a dict of sums so far.  So e.g. 5:2 means there are 2 ways to get 2 terms in the sequence to add to 5.\n    sumsHeap = [u, v, u+v] # Sorted list of those sums.\n    heapify(sumsHeap) \n    deletedDict = dict() # This is a list of sums that have already reached a value of 2 or more.  No point looking at these again.\n\n    # The idea is to go through the sorted list of sums (previous terms in sequence added together)\n    # and find the minimum of those and add that to the sequence.\n    while True:\n        \n        while True:\n            numtoBeAppended = heappop(sumsHeap)\n            if numtoBeAppended > terms[-1] and numtoBeAppended in sumsDict:\n                break\n            \n            \n        terms.append(numtoBeAppended)\n        if len(terms) >= numTerms:\n            break\n        \n        for term in terms[:-1]:\n            entry = term + numtoBeAppended\n            if entry in sumsDict:\n                # If it's already in the heap then there are more than one ways to sum to \n                # this value, so remove it, it will never be part of the sequence\n                del sumsDict[entry]\n                deletedDict[entry] = True\n            else:\n                # If we haven't already marked it as being seen before (and so, deleted) add it to our heap\n                if entry not in deletedDict:\n                    heappush(sumsHeap, entry)\n                    sumsDict[entry] =    1\n            \n                \n\n    return terms", "def ulam_sequence(u0, u1, n):\n    seq = [ u0, u1 ]\n    sums = { u0+u1 }\n    unique_sums = { u0+u1 }\n    for i in range(n-3):\n        next_num = min(unique_sums)\n        for num in seq:\n            n = num + next_num\n            if n not in sums:\n                sums.add(n) \n                unique_sums.add(n)\n            else:\n                if n in unique_sums:\n                    unique_sums.remove(n)\n        unique_sums.remove(next_num)\n        seq.append(next_num)\n    seq.append(min(unique_sums))\n    return seq"]