["def switch_endian(n, bits):\n    out = 0\n    while bits > 7:\n        bits -= 8\n        out <<= 8\n        out  |= n & 255\n        n   >>= 8\n    return None if n or bits else out", "# Bitwise operators? What's that? Don't need it\ndef switch_endian(n, bits):\n    if not (0 <= n < 2**bits and bits == 2**(bits.bit_length()-1)): return\n    x = f\"{n:0{bits}b}\"\n    return int(''.join(x[i-8:i] for i in range(bits, 0, -8)), 2)", "def switch_endian(n, bits):\n    if not (bits >= 8 and bits & bits - 1 == 0 and bits >= n.bit_length()):\n        return None\n    return int.from_bytes(n.to_bytes(bits // 8, 'little'), 'big')", "# Python 3 rocks!\nswitch_endian = lambda n, bits: int.from_bytes(n.to_bytes(bits//8, 'big'), 'little') if bits % 8 == 0 and bits >= 8 and n.bit_length() <= bits else None", "def switch_endian(n, bits):\n    if 2**bits <= n or bits%8 != 0 or bits < 8:\n        return None\n    xn = bits//4\n    x = format(n, 'x').zfill(xn)\n    lst = [x.upper()[i:i+2] for i in range(0,len(x),2)]\n    s = ''.join(lst[::-1])\n    ans = int(s, 16)\n    return ans if len(bin(ans)[2:]) <= bits else None", "lst0 = [2]\nfor i in range(1, 20):\n    lst0.append(lst0[-1]*2)\n    \ndef switch_endian(n, bits):\n    if n < 0 or bits not in lst0 or (n, bits) == (256, 8):\n        return None\n    xn = bits//4\n    x = format(n, 'x').zfill(xn)\n    lst = [x.upper()[i:i+2] for i in range(0,len(x),2)]\n    s = ''.join(lst[::-1])\n    ans = int(s, 16)\n    return ans if len(bin(ans)[2:]) <= bits else None", "# Switch the endianness of integer n\n# Assume 64-bit unsigned integers\ndef switch_endian(n, bits):\n    if n<0 or bits&(bits-1) or bits<8 or n>=2**bits:\n        return None\n    result = 0\n    for _ in range(bits//8):\n        result = (result<<8) | (n&255)\n        n >>= 8\n    return result", "# Switch the endianness of integer n\n# Assume 64-bit unsigned integers\nimport re\nimport math\ndef switch_endian(n, bits):\n    number_in_hex = hex(n)\n    length = len(number_in_hex)-2\n    result = int(bits/4)\n    x = math.log(bits, 2).is_integer()\n    if x == False:\n        return None\n    if length > result:\n        return None\n    if length <= result:\n        diff = result-length\n        number_in_hex = number_in_hex.replace('0x','0'*diff)\n        res_list = re.findall('[\\da-z]{2}[^\\da-z]*', number_in_hex)\n        res_list = res_list[::-1]\n        number_in_hex = ''.join(res_list)\n        return(int('0x'+number_in_hex, 0))\n", "from math import log2\ndef switch_endian(n, bits):\n    if bits<8 or 2**int(log2(bits))!=bits or 2**bits-1<n:\n        return None\n    s='{:X}'.format(n).zfill(bits//4)\n    r=''\n    for i in range(0,len(s),2):\n        r=s[i:i+2]+r\n    return int(r,16)"]