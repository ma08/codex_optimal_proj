["def f(n, m):\n    re, c = divmod(n,m) \n    return m*(m-1)/2*re + (c+1)*c/2", "def f(n, m):\n    # Function to return the sum of the remnainders when n is divided by m for all n from 1 to n\n    # The remainders cycle from 0, 1, 2, 3,... m-1.  This happens n // m times, with a final sequnce \n    # up to n % m.  The sum of 0, ... m-1 is m * (m - 1) / 2.  The sum of 0, 1, 2, 3, n % m is similar.\n    #\n    return (n // m) * (m - 1) * m / 2 + (n % m) * (n % m + 1) / 2", "def sumrange(n):\n    return (n - 1) * n / 2\ndef f(n, m):\n    n, m = int(n), int(m)\n    return (n / m) * sumrange(m) + sumrange(n % m + 1)", "def f(n, m):\n    # Either n or m seems to have a floating-point representation in one of the official tests.\n    # Since it's a .0, converting to int is fine.\n    n, m = int(n), int(m)\n    \n    # n=14, m=5  ->  2 whole runs, plus the 4 first modulos\n    whole_runs = n / m\n    leftovers = n % m\n    \n    # n=5, m=5  ->  1+2+3+4+0 == (m-1)/(m-1+1)/2\n    per_run = (m - 1) * (m - 1 + 1) / 2\n    leftovers_sum = leftovers * (leftovers + 1) / 2\n  \n    return whole_runs * per_run + leftovers_sum", "def f(n, m):\n  x,y =  divmod(n,m)\n  return x * m * (m - 1) / 2 + y * (y + 1) / 2", "def f(n, m):\n    q, r = divmod(n, m)\n    return q * m * (m - 1) // 2 + r * (r + 1) // 2", "def f(n, m):\n    k = n // m\n    r = n % m\n    return (m * (m -1) // 2) * k + r * (r + 1) // 2\n", "def f(n, m):\n    times = n // m\n    extra = n % m\n    sum_mini_series = (m - 1) * (m - 1 + 1) // 2\n    sum_extra = (extra) * (extra + 1) // 2\n    return sum_mini_series * times + sum_extra", "def f(n, m):\n    sum_1_to_n = lambda n: (n + 1) * n // 2\n    a, b = divmod(n, m)\n    return a * sum_1_to_n(m - 1) + sum_1_to_n(b)", "def f(n, m):\n    return ((m-1)**2+(m-1))//2 * (n//m) + ((n%m)**2+(n%m))//2"]