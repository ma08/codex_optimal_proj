["def josephus(xs, k):\n    i, ys = 0, []\n    while len(xs) > 0:\n        i = (i + k - 1) % len(xs)\n        ys.append(xs.pop(i))\n    return ys", "def josephus(n,k):\n    i, ans = 0, []\n    while n: i = (i + k - 1) % len(n); ans.append(n.pop(i))\n    return ans", "from collections import deque\n\ndef josephus(items,k):\n    q = deque(items)\n    return [[q.rotate(1-k), q.popleft()][1] for _ in items]", "class Circle(object):\n    def __init__(self, items):\n        self.items = items[:]\n\n    def pop(self, index):\n        norm_index = index % len(self.items)\n        return self.items.pop(norm_index), norm_index\n\n    def not_empty(self):\n        return self.items\n\n\ndef josephus_iter(items, k):\n    circle = Circle(items)\n    i = k - 1  # index 0-based\n    while circle.not_empty():\n        item, i = circle.pop(i)\n        yield item\n        i += k - 1\n\n\ndef josephus(items, k):\n    return list(josephus_iter(items, k))", "def josephus(items,k):\n  if len(items)==0: return []\n  if len(items)==1: return [items[0]]\n  i = ((k-1)%len(items))\n  return [items[i]] + josephus(items[i+1:]+items[:i], k)\n", "def josephus(items, k):\n    out = []\n    i = 0\n    while len(items) > 0:\n        i = (i+k-1) % len(items)\n        out.append(items[i])\n        del items[i]\n    return out", "def josephus(n, k):\n    k -= 1\n    i = k \n    \n    result = []\n    while n:\n        if i < len(n):\n            result.append(n.pop(i))\n            i += k\n        else:\n            while i >= len(n):\n                i -= len(n)\n    return result", "def josephus(items,k):\n    cursor = 0\n    killed = []\n    while len(items):\n        cursor = (cursor + k - 1) % len(items)\n        killed.append(items.pop(cursor))\n        \n    return killed", "def josephus(itemlist, interval):\n    length = len(itemlist)\n\n    if interval == 1:\n        return itemlist\n    \n    count = 1\n    disposal = [] #list which stores order in which items get deleted\n\n    while len(disposal) != length: #loop runs unti; every item has been deleted\n        index = 0 #gives an index. Useful if there are duplicates of items in a list\n        for item in itemlist:\n            if count == interval: \n                \n                disposal.append(item)\n                itemlist.pop(index)\n                count = 1  \n                \n                try:\n                    print(itemlist[index]) #sees if there is another number after the deleted one. Catches numbers at the end of the list which get's deleted\n                except:\n                    break\n\n            count += 1\n            index += 1\n    return disposal ", "def josephus(items,k):\n    i,res=0,[]\n    while items:\n        i=(i+k-1)%len(items)\n        res+=[items.pop(i)]\n    return res"]