["def robot_walk(a):\n  i=3\n  while(i<len(a) and a[i] < a[i-2]): i+=1\n  return i<len(a)\n", "def robot_walk(a):\n    return any(x <= y for x,y in zip(a[1:], a[3:]))", "def robot_walk(a):\n    if len(set(a)) == 1:\n        return True\n    movings = []\n    p = (0, 0)   # x, y\n    dir = (0, 1)\n    for k in a: \n        new_p = (p[0] + k*dir[0], p[1] + k*dir[1])\n        for start, stop in movings:\n            if new_p[1] == p[1] and start[0] == stop[0] \\\n                    and (start[1] < new_p[1] <= stop[1] or start[1] > new_p[1] >= stop[1]) \\\n                    and (new_p[0] <= start[0] < p[0] or new_p[0] >= start[0] > p[0]):\n                return True\n            elif new_p[0] == p[0] and start[1] == stop[1] \\\n                    and (start[0] < new_p[0] <= stop[0] or start[0] > new_p[0] >= stop[0]) \\\n                    and (new_p[1] <= start[1] < p[1] or new_p[1] >= start[1] > p[1]):\n                return True\n                \n        movings.append((p, new_p))\n        p = new_p\n        dir = {(0, 1): (1, 0),\n               (1, 0): (0, -1),\n               (0, -1): (-1, 0),\n               (-1, 0): (0, 1)}[dir]\n    return False", "from itertools import cycle\n\ndef robot_walk(walks):\n    dyx = cycle([(1, 0, 'N'), (0, 1, 'E'), (-1, 0, 'S'), (0, -1, 'W')])\n    ymin, ymax = -1, float('inf')\n    xmin, xmax = 0, float('inf')\n    cy, cx = 0, 0\n    for w in walks:\n        dy, dx, d = next(dyx)\n        cy, cx = cy+dy*w, cx+dx*w\n        if d == 'N':\n            if cy >= ymax:\n                return True\n            ymax = cy\n        elif d == 'E':\n            if cx >= xmax:\n                return True\n            xmax = cx\n        elif d == 'S':\n            if cy <= ymin:\n                return True\n            ymin = cy\n        elif d == 'W':\n            if cx <= xmin:\n                return True\n            xmin = cx\n    return False", "move=['left','up','right','down']\ndef robot_walk(a):\n    if len(a)<=3:\n        return False\n    left,upper,right,lower=0,a[0],a[1],a[0]-a[2]\n    for i,x in enumerate(a[3:]):\n        m=move[i%4]\n        if m=='left':\n            if right-x<=left:\n                return True\n            left=right-x\n        elif m=='up':\n            if lower+x>=upper:\n                return True\n            upper=lower+x\n        elif m=='right':\n            if left+x>=right:\n                return True\n            right=left+x\n        elif m=='down':\n            if upper-x<=lower:\n                return True\n            lower=upper-x\n    return False", "def robot_walk(a):\n  aa=a[2::2]\n  if aa!=sorted(aa,reverse=True):\n      return True\n  aa=a[1::2]\n  if aa!=sorted(aa,reverse=True) or any(aa.count(i)>1 for i in aa):\n      return True\n  return False", "from itertools import cycle\ndef robot_walk(arr):\n    directions, li, m, n = cycle([(1, 0), (0, 1), (-1, 0), (0, -1)]), [], 0, 0\n    for i in arr:\n        k, l = next(directions)\n        li.append([[m, n], [m + k * i, n + l * i]])\n        m += k * i ; n += l * i\n        test = li[-1]\n        for o, p in li[:-3]:\n            same, same1 = not o[0]==p[0], not test[0][0]==test[1][0]\n            if same != same1:\n                temp, temp1 = sorted([o[same^1],p[same^1]]), sorted([test[0][same1^1],test[1][same1^1]])\n                if o[same]>=temp1[0] and o[same]<=temp1[1] and test[0][same1]>=temp[0] and test[0][same1]<=temp[1] : return True\n    return False", "def robot_walk(a):\n    return any(i > 2 and a[i - 2] <= p for i, p in enumerate(a))", "from math import gcd\nfrom functools import reduce\nfrom itertools import cycle\n\ndef robot_walk(a):\n    g = reduce(gcd, a)\n    a = [x//g for x in a]\n    it = cycle([1j, 1, -1j, -1])\n    seen = {0}\n    pos = 0\n    for x in a:\n        d = next(it)\n        for i in range(x):\n            pos += d\n            if pos in seen:\n                return True\n            seen.add(pos)\n    return False", "def robot_walk(ds):\n    xs, ys = {0}, {0}\n    x, y = 0, 0\n    dx, dy = 0, 1\n    for d in ds:\n        x, y = x + d*dx, y + d*dy\n        xs.add(x)\n        ys.add(y)\n        dx, dy = -dy, dx \n    x, y = 0, 0\n    dx, dy = 0, 1\n    visited = {(0, 0)}\n    for d in ds:\n        x1, y1 = x + d*dx, y + d*dy\n        (bx, by), (ex, ey) = sorted(((x + dx, y + dy), (x1, y1)))\n        if dy == 0:\n            for cx in xs:\n                if bx <= cx <= ex and (cx, y) in visited:\n                    return True\n                visited.add((cx, y))\n        else:\n            for cy in ys:\n                if by <= cy <= ey and (x, cy) in visited:\n                    return True\n                visited.add((x, cy))\n        x, y = x1, y1\n        dx, dy = -dy, dx\n    return False\n"]