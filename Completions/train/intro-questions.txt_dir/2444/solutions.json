["class Solution:\n    def binaryGap(self, n: int) -> int:\n        maxDist = 0\n        currDist = 0\n        while n:\n            if n & 1 and currDist != 0:\n                maxDist = max(maxDist, currDist)\n                currDist = 1\n            elif n & 1:\n                currDist = 1\n            elif not n & 1 and currDist != 0:\n                currDist+=1\n            n >>= 1\n        return maxDist", "class Solution:\n    def binaryGap(self, n: int) -> int:\n        bins = ''\n        maxv = 0\n        i = 0\n        pre = None\n        while n > 0:\n            if n % 2 == 1:\n                if pre is not None:\n                    maxv = max(maxv,i-pre)\n                pre = i\n            n //= 2\n            i += 1\n        \n        return maxv", "class Solution:\n    def binaryGap(self, n: int) -> int:\n        binary_string = bin(n)[2:]\n        # The binary string has to begin with a 1, if n is a positive integer.\n\n        left, right, current_distance, global_max = 0, 1, 1, 0\n\n        print(binary_string)\n        while right <= len(binary_string) - 1:\n            print(left, right, current_distance, global_max)\n            if binary_string[right] == '0':\n                right += 1; current_distance += 1\n            else:\n                global_max = max(global_max, current_distance)\n                left = right; right += 1; current_distance = 1\n            \n        return global_max", "class Solution:\n    def binaryGap(self, N: int) -> int:\n        bit_list = bin(N)[2:]\n        stack = []\n        dis = 0\n        for b in bit_list:\n            if not stack and b == '1':\n                stack.append(b)\n            elif stack and b == '0':\n                stack.append(b)\n            elif stack and b == '1':\n                dis = max(dis, len(stack))\n                stack = ['1']\n        return dis\n            \n", "class Solution:\n    def binaryGap(self, n: int) -> int:\n        if n == 0:\n            return 0\n        \n        # Move RSB to first 1\n        while n & 1 == 0:\n            n = n >> 1\n            \n        global_max = local_max = 0\n        while n > 0:\n            # Reset if found another 1\n            if n & 1 == 1:\n                global_max = max(global_max, local_max)\n                local_max = 1\n            # Keep counting towards local max\n            else:\n                local_max += 1\n            n = n >> 1\n            \n        return global_max\n            \n        \n"]