["from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef rec(n): return 1 + (0 if n==1 else rec(3*n+1) if n&1 else rec(n//2))\n\nmemo = [[0, None], [1, 1]]\ndef max_collatz_length(n):\n    if not (type(n) == int and n > 0): return []\n    while n >= len(memo):\n        x = rec(len(memo))\n        if x > memo[-1][1]: memo.append([len(memo), x])\n        else: memo.append(memo[-1])\n    return memo[n]", "class Collatz(object):\n    def __init__(self):\n        self.memory = {1: 1}\n\n    def calculate(self, n):\n        if n in self.memory:\n            return self.memory[n]\n\n        result = self.calculate(n // 2) + 1 if n % 2 == 0 else self.calculate(3 * n + 1) + 1\n        self.memory[n] = result\n        return result\n\n\ndef max_collatz_length(n):\n    if not isinstance(n, int) or n <= 0 or isinstance(n, bool):\n        return []\n    m = 0\n    z = 0\n    collatz = Collatz()\n    for i in range(1, n + 1):\n        c = collatz.calculate(i)\n        if c > m:\n            m = c\n            z = i\n    return [z, m]", "c = {1:1}\ndef F(n):\n    if n in c : return c[n]\n    c[n] = 1 + F(n*3+1 if n&1 else n//2)\n    return c[n]\nmax_collatz_length=lambda n:[] if type(n)!=int or n<=0 else max([[i,F(i)] for i in range(1,n+1)], key=lambda x:x[1])", "def max_collatz_length(limit):\n    if type(limit) != int or limit < 1:\n        return []\n    \n    results = {1: 1}\n    \n    for n in range(2, limit + 1):\n        count = 0\n        x = n\n        while x not in results:\n            x = x * 3 + 1 if x % 2 else x // 2\n            count += 1\n        \n        count += results[x]\n        results[n] = count\n    \n    sol = max(results, key=results.get)\n    return [ sol, results[sol] ]", "def max_collatz_length(n):\n    if type(n) != int or n <= 0: return []\n    \n    # Use a dict to store calculated collatz lengths\n    lengths = {1:1}\n    \n    for i in range(2, n + 1):\n        a = [i]\n        # Continue extending the collatrz sequence until we hit a number\n        # already known\n        while a[-1] not in lengths:\n            a += [3 * a[-1] + 1] if a[-1] % 2 else [a[-1]//2]\n\n        # Add *all* collatz lengths from the new sequence\n        for j, k in enumerate(a[::-1]):\n            lengths[k] = j + lengths[a[-1]]\n            \n    return [max(lengths, key=lengths.get), lengths[max(lengths, key=lengths.get)]]", "def max_collatz_length(n):\n    if type(n) != int:\n        return []\n    if n == 0:\n        return []\n    if n == 1:\n        return [1,1]\n    try:    \n        results=[0 for i in range(n+1)]\n        results[0]=1\n        results[1]=1\n\n        for num in range(2,n+1):\n            col=num\n            ctr=0\n            shortCut=0\n\n            while(shortCut==0):\n        \n                if col%2==0:\n                    ctr+=1\n                    col=col >> 1\n                else:\n                    ctr+=2\n                    col=(3*col+1)>>1\n                if col<n:\n                    shortCut=results[col]\n            results[num]=results[col]+ctr\n\n        return [results.index(max(results[1:])), max(results[1:])]\n    except:\n        return []", "from operator import itemgetter\n\ndef _collatz_len(n, lengths):\n    if n in lengths:\n        return [n, lengths[n]]\n\n    count = 0\n    curr_num = n\n    nums = []\n\n    while curr_num != 1:\n        nums.append(curr_num)\n\n        if curr_num in lengths:\n            for i, x in enumerate(nums):\n                if x not in lengths:\n                    lengths[x] = count + lengths[curr_num] - i\n            return [n, count + lengths[curr_num]]\n\n        if curr_num % 2:\n            nums.append(3 * curr_num + 1)\n            curr_num = (3 * curr_num + 1) // 2\n            count += 1\n        else:\n            curr_num //= 2\n        count += 1\n\n    count += 1\n\n    for i, x in enumerate(nums):\n        if x not in lengths:\n            lengths[x] = count - i\n\n    return [n, count]\n\ndef max_collatz_length(n):\n    if not isinstance(n, int) or isinstance(n, bool) or n <= 0:\n        return []\n\n    curr_len = max_len = 0\n    lengths = {1:1, 2:2}\n\n    results = [_collatz_len(x, lengths) for x in range(1, n // 2 + 1)]\n    for x in range(n // 2 + 1, n + 1):\n        if x % 2:\n            results.append(_collatz_len(x, lengths))\n        else:\n            results.append([x, results[x // 2 - 1][1] + 1])\n\n    return max(results, key=itemgetter(1))\n", "cache = {1: 1}\n\ndef max_collatz_length(n):\n\n    def collatz(n):\n        if n in cache: return cache[n]\n        next_n = 3*n + 1 if n % 2 else n / 2\n        ret = cache[n] = 1 + collatz(next_n)\n        return ret\n        \n    if not isinstance(n, int) or isinstance(n, bool) or n < 1: return []\n    return max(([i, collatz(i)] for i in range(1, n+1)), key=lambda p: p[1])", "c=[ 1, 2, 3, 6, 7, 9, 18, 25, 27, 54, 73, 97, 129, 171, 231, 313, 327, 649, 703, 871, 1161, 2223, 2463, 2919, 3711, 6171, 10971, 13255, 17647, 23529, 26623, 34239, 35655, 52527, 77031, 106239, 142587, 156159, 216367, 230631, 410011, 511935, 626331, 837799]\ndef max_collatz_length(n):\n    if type(n)!=int or n<1: return []\n    ans=max(i for i in c if i<=n)\n    steps=1\n    x=ans\n    while x>1:\n        steps+=1\n        x=3*x+1 if x%2 else x//2\n    return [ans,steps]"]