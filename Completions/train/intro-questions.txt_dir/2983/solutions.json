["def bouncy_count(m):\n    num = den = 1\n    for i in range(1, 11):\n        num *= m + i + i * (i == 10)\n        den *= i\n    return 10 ** m - num // den + 10 * m + 1", "def bouncy_count(n):\n    k = m = 1\n    for i in range(1, 11):\n        k *= n + i*(1+(i == 10))\n        m *= i\n    return 10*(10**(n-1)+n)- k // m + 1", "from scipy.special import comb\n\ndef bouncy_count(number):\n    return 10**number + 10*number + 1 - comb(10+number, 10, True) - comb(9+number, 9, True)", "import operator as op\nfrom functools import reduce\n\ndef Combi(n, k):\n    if k > n: return 0\n    k1, k2 = sorted((k, n-k))\n    num = reduce(op.mul, range(n, k2, -1), 1)\n    d = reduce(op.mul, range(1, k1+1), 1)\n    return num//d\n\ndef bouncy_count(n):\n    if n <= 2: return 0\n    return 10**n-(Combi(n+10, 10)+Combi(n+9,9)-2-10*n+1)", "from functools import reduce\n  \ndef nCr(n, k): \n\n  numer = reduce(lambda x, y: x * y, \n                 list(range(n, n - k, -1)))     \n  denom = reduce(lambda x, y: x * y, \n                 list(range(1, k + 1)))         \n    \n  return numer // denom         \n  \ndef bouncy_count(number):\n    r = int((nCr(number + 10, 10) + \n         nCr(number + 9, 9)  \n         - 2 - 10 * number)) \n                  \n    return 10**number - r % (1000000000000000000 + 7) - 1", "from math import factorial as f\n\ndef nCk(n,k): return f(n)//f(k)//f(n-k)\n\ndef bouncy_count(x):\n    return 10**x - (nCk(10+x,10) + nCk(9+x,9) - 10*x - 1)", "from scipy.special import comb\n\ndef bouncy_count(n):\n    return 10 ** n - comb(n + 9, n, exact=True) - comb(n + 10, n, exact=True) + 1 + n * 9 + n", "from scipy.special import comb\n    \ndef bouncy_count(n):\n    if n < 3: return 0\n    b = 10 #Change for different bases\n    incline_sum = 0\n    decline_sum = 0\n    for i in range(3,n+1):\n        incline_sum += comb(b+i-1, i, exact=True) - 10\n        decline_sum += comb(b+i-2, i, exact=True)\n    \n    return b**n - b**2 - incline_sum - decline_sum"]