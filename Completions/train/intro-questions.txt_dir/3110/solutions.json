["def two_decimal_places(n):\n    return round(n, 2)\n", "def two_decimal_places(n):\n   return round(n* 100) / 100", "from decimal import Decimal, ROUND_HALF_UP\n\ndef two_decimal_places(n):\n  dn = Decimal(str(n)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP)\n  return float(dn)\n", "def two_decimal_places(n):\n    return float(\"{0:.2f}\".format(n))\n", "def two_decimal_places(n):\n    return float(\"%.2f\" % n)", "from numpy import round\n\ndef two_decimal_places(n):\n    return round(n, decimals=2)", "two_decimal_places = lambda n : round(n,2)", "two_decimal_places = __import__(\"functools\").partial(round, ndigits=2)", "def two_decimal_places(n):\n    return round(n+0.00005,2) ", "def two_decimal_places(n: float) -> float:\n    \"\"\" Get number rounded to two decimal places. \"\"\"\n    return round(n, 2)", "def two_decimal_places(n):\n    return float(f'{n:.02f}')", "def two_decimal_places(n):\n    \"\"\"\n    a nightmare in a small package\n    \"\"\"\n    \n    # Convert to a string\n    x = str(n)\n    \n    # find the decimal\n    ptIndx = x.find(\".\")\n    \n    # grab the deciding digit\n    roundingDigit = x[ptIndx+3]\n\n    # create the return string\n    o = x[0:ptIndx+3]\n    \n    # return if not rounding up\n    if int(roundingDigit)<=4:\n        return float(o)\n    else:\n        # round the result of \"rounding\", since if you don't you get some ###.###9999999764235761923765 garbage\n        return round(float(o) + (-0.01 if x[0]==\"-\" else 0.01), 2)\n\n    #I can't wait to see more appropriate solutions.\n", "def two_decimal_places(n):\n    pot_location = 0\n    lt = list(str(n))\n    for i in range(0,len(lt)):\n        if lt[i] == '.':\n            pot_location = i\n            break\n    result = float(''.join(lt[:pot_location+3]))\n    if int(lt[pot_location+3])>4:\n        if n>0:\n            result = result + 0.01\n        else:\n            result = result - 0.01\n    return round(result,5)\n            \n", "def two_decimal_places(n):\n#    raise NotImplementedError(\"TODO: two_decimal_places\")\n    if (1000 * n % 10 == 5):\n        return round((1000 * n + 1)/1000,2)\n    return round(n, 2)", "def two_decimal_places(n):\n    return ((n * 100 + 0.5) // 1 ) / 100", "def two_decimal_places(n):\n   # raise NotImplementedError(\"TODO: two_decimal_places\")\n    print('{:.2f}'.format(n))\n    return(float('{:.2f}'.format(n)))", "def two_decimal_places(n):\n    return float(round(n, 2))", "def two_decimal_places(n):\n    my_float = float(n)\n    return round(my_float, 2)\n    raise NotImplementedError(\"TODO: two_decimal_places\")", "def two_decimal_places(n):\n    n=float(\"{:.2f}\".format(n))\n    return n", "def two_decimal_places(n):\n    a = float(\"{:.2f}\".format(n))\n    return a", "def two_decimal_places(n):\n \n    formattedNumber=round(n,2)\n    return formattedNumber", "def two_decimal_places(n):\n    a = str(n)\n    x = a.split('.')\n    l = x[1]\n    t = f'{x[0]}.'\n    y = ''\n    b = ['5','6','7','8','9']\n    w = ['0','1','2','3','4','5','6','7','8']\n    if l[1] in w and l[2] in b:\n        q = l[1]\n        w = int(q)\n        w =w+1\n        y = str(w)\n        t = t + f'{l[0]}' + y\n    elif l[1] == '9' and l[2] in b:\n        q = l[0]\n        w = int(q)\n        w =w+1\n        y = str(w)\n        t = t +  y     \n    else:\n        t = t + f'{l[0]}' + f'{l[1]}'\n    final_num = float (t)\n    return(final_num)", "def two_decimal_places(n):\n    i=n-int(n)\n    i=i*1000\n    j=(i)\n    j=round(j/10)\n    return int(n)+j/100", "def two_decimal_places(n):\n    s = \"%.2f\" % n\n    res = float(s)\n    return res", "def two_decimal_places(n):\n\n    return float(str(f\"{n:.2f}\"))", "def two_decimal_places(n):\n    return round(n, ndigits=2)\n", "def two_decimal_places(n):\n    r = round(n, 2)\n    return r\n    raise NotImplementedError(\"TODO: two_decimal_places\")", "def two_decimal_places(n):\n    #raise NotImplementedError(\"TODO: two_decimal_places\")\n    return float(f\"{n:.2f}\")", "import unittest\n\n\ndef two_decimal_places(n):\n    return round(n, 2)\n    \n    \nclass TestTwoDecimalPlaces(unittest.TestCase):\n    def test_two_decimal_places(self):\n        n = 4.659725356\n        actual = two_decimal_places(n)\n        self.assertEqual(actual, 4.66)\n", "def two_decimal_places(n):\n    #raise NotImplementedError(\"TODO: two_decimal_places\")\n    num = '{:.2f}'.format(n)\n    return float(num)", "def two_decimal_places(n):\n    n = \"{:.2f}\".format(n)\n    return float(n)", "def two_decimal_places(n):\n    ans = float('{:.2f}'.format(n))\n    return ans", "def two_decimal_places(n):\n    s = 0\n    s = round(n, 2)\n    return s", "def two_decimal_places(n):\n    answer = \"{:.2f}\".format(n)\n    return float(answer)", "def two_decimal_places(n):\n    \n    num = \"{:.2f}\".format(n)\n    \n    return float(num)", "def two_decimal_places(n):\n    a = round(n, 2)\n    return a\n    \n", "def two_decimal_places(n):\n    return float(\"{:.2f}\".format(round(n,2)))", "def two_decimal_places(n):\n    if n:\n        num = round(n, 2)\n        return num\n    else:\n        raise NotImplementedError(\"TODO: two_decimal_places\")", "def two_decimal_places(n: int) -> int:\n    return round(n, 2)\n", "def two_decimal_places(n):\n    thing = str(n)\n    print (thing + ' is rounded ' )\n    return(round(n, 2))", "def two_decimal_places(n):\n    return float('{:.2f}'.format(n))\n    # raise NotImplementedError(\"TODO: two_decimal_places\")\n", "import math\ndef two_decimal_places(n):\n    return round(100*n)/100", "def two_decimal_places(n):\n    return float(str(round(n,2)))", "def two_decimal_places(n):\n    #return round(n, 2)\n    #return float(format(n, \"1.2f\"))\n    return float(f\"{n:1.2f}\")", "def two_decimal_places(n):\n    n = n * 100 / 100.0\n    return round(n, 2)\n", "def two_decimal_places(n):\n    formatted = format(n, '.2f')\n    return float(formatted)", "def two_decimal_places(n):\n    x=(\"{:.2f}\").format(n)\n    return float(x)\n", "def two_decimal_places(n):\n    decimal = int((n*100 - int(n*100))*10)\n    print(decimal)\n    if decimal <= -5:\n        return (int(n*100)-1)/100\n    elif decimal < 5:\n        return int(n*100)/100\n    else:\n        return (int(n*100)+1)/100", "def two_decimal_places(n):\n    from decimal import Decimal\n    out = round(n,2)\n    return out\n", "from decimal import Decimal\ndef two_decimal_places(n):\n    return  float(Decimal(n).quantize(Decimal(\"0.01\")))", "from functools import partial\ntwo_decimal_places=partial(round,ndigits=2)", "def two_decimal_places(n):\n    b = round(n,2)\n    return (b)", "def two_decimal_places(n):\n    #raise NotImplementedError(\"TODO: two_decimal_places\")\n    res = str(n).split('.')\n    cc = 0\n    cc += int(res[0]) * 100\n    if n > 0:\n        if int(str(res[1])[2]) < 5:\n            cc += int(str(res[1])[0:2]) \n        else:\n            cc = cc + int(str(res[1])[0:2]) + 1\n    else:\n        cc = 0 - cc\n        if int(str(res[1])[2]) < 5:\n            cc += int(str(res[1])[0:2]) \n        else:\n            cc = cc + int(str(res[1])[0:2]) + 1\n        cc = 0 - cc\n    return float(str(cc)[:-2] + '.' + str(cc)[-2:])", "def two_decimal_places(n):\n    return float('{0:.{1}f}'.format(n, 2))", "def two_decimal_places(n):\n    return float(f'{n:.2f}')\n    #raise NotImplementedError(\"TODO: two_decimal_places\")\n", "def two_decimal_places(n):\n    return n.__round__(2)", "two_decimal_places = lambda n: round(n*100) / 100", "def two_decimal_places(n):\n    \n    l = str(n)\n    m = l.split(\".\")\n  \n    returning = \"\"\n    if len(m[1]) == 2: return n\n    elif len(m[1]) > 2:\n        returning = round(n, 2)\n        return returning\n", "def two_decimal_places(n):\n    a = 100*n\n    b = int(a)\n    if (a-b)>=0.5:\n        d = b+1\n    elif a<0 and (b-a)>=0.5:\n        d = b-1\n    else:\n        d = b\n    c = d/100\n    return c", "def two_decimal_places(n):\n    return round(n * 100) / 100\n\n#My solution. It's ugly :(\n#def two_decimal_places(n):\n#    if isinstance(n, float):\n#        if n > 0:\n#            int_n = int(n)\n#            three_last_digits = int((n - (int_n)) * 1000)\n#            last_digit = int(str(three_last_digits)[-1])\n#            result = float()\n#\n#            if last_digit >= 5:\n#                return float(int_n) + ((three_last_digits-last_digit)+10)/1000\n#            else:\n#                return float(int_n) + (three_last_digits-last_digit)/1000\n#        else:\n#            int_n = int(n)\n#            three_last_digits = int((n - (int_n)) * 1000)\n#            last_digit = int(str(three_last_digits)[-1])\n#            result = float()\n#\n#            if last_digit >= 5:\n#                return float(int_n) + ((three_last_digits+last_digit)-10)/1000\n#            else:\n#                return float(int_n) + (three_last_digits+last_digit)/1000\n#    return float()\n", "# I know it's ugly, sorry. But it works :)\ndef two_decimal_places(n):\n    if isinstance(n, float):\n        if n > 0:\n            int_n = int(n)\n            three_last_digits = int((n - (int_n)) * 1000)\n            last_digit = int(str(three_last_digits)[-1])\n            result = float()\n\n            if last_digit >= 5:\n                return float(int_n) + ((three_last_digits-last_digit)+10)/1000\n            else:\n                return float(int_n) + (three_last_digits-last_digit)/1000\n        else:\n            int_n = int(n)\n            three_last_digits = int((n - (int_n)) * 1000)\n            last_digit = int(str(three_last_digits)[-1])\n            result = float()\n\n            if last_digit >= 5:\n                return float(int_n) + ((three_last_digits+last_digit)-10)/1000\n            else:\n                return float(int_n) + (three_last_digits+last_digit)/1000\n    return float()", "two_decimal_places = lambda n: float(f\"{n:.2f}\")", "def two_decimal_places(n):\n    return round(n,2)\n#Completed by Ammar on 24/8/2019 at 03:41PM.\n", "def two_decimal_places(n):\n    return round(n,2)  #I solved this Kata on  8/23/2019  03:34 AM...#Hussam'sCodingDiary", "def two_decimal_places(n):\n    print(\"==>> \",n)\n    return round(n,2)", "def two_decimal_places(n):\n    answer = round(n, 2)\n    return answer", "def two_decimal_places(n):\n    answer = n\n    answer = round(answer, 2)\n    return answer", "import math\ndef two_decimal_places(n):\n     return float(\"{0:.2f}\".format(n))", "def two_decimal_places(n):\n    return float(\"%1.2f\" % n)", "def two_decimal_places(n):\n    return round(n * 1.00, 2)", "def two_decimal_places(n):\n#    raise NotImplementedError(\"TODO: two_decimal_places\")\n    n = round(n, 2)\n    return n", "def two_decimal_places(n):\n    return float(\"{:0.2f}\".format(n))", "def two_decimal_places(n):\n    s=(\"{:.2f}\".format(n))\n    return float(s)", "import math\ndef two_decimal_places(n):\n    #raise NotImplementedError(\"TODO: two_decimal_places\")\n    #print(round(n,2))\n    return round(n,2)", "def two_decimal_places(n):\n    result = \"{0:.2f}\".format(n)\n    new_result = float(result)\n    return new_result", "def two_decimal_places(n):\n  return float(f'{n:.2f}')", "def two_decimal_places(n):\n    formatted = '{:.2f}'.format(n)\n    return float(formatted)\n", "def two_decimal_places(n):\n#The round function is used to return with number of decimal places in 2nd parameter\n    return round(n,2)", "def two_decimal_places(n):\n#     raise NotImplementedError(\"TODO: two_decimal_places\")\n    top = round(n,2)\n    return top", "def two_decimal_places(n):\n    if int(n * 1000) % 10 == 5 and n > 0:\n        n = n + 0.001\n        \n    return float(\"{0:.2f}\".format(n))", "def two_decimal_places(n):\n    from decimal import Decimal\n    return float(Decimal(str(n)).quantize(Decimal('0.00')))", "def two_decimal_places(n):\n    if (n * 1000) % 10 < 5:\n        return round(n, 2)\n    else:\n        return round(n + 0.001, 2)", "def two_decimal_places(n):\n    z = int(100 * abs(n) + 0.5) / 100.0\n    return -z if n < 0 else z\n", "from decimal import Decimal, ROUND_HALF_UP\n\ndef two_decimal_places(n):\n    return float(Decimal(n).quantize(Decimal('.01'), ROUND_HALF_UP))", "def two_decimal_places(n):\n    num = round (n, 4)\n    n1 = str(num)\n    if n1[-1] == '5':\n        n1 = n1[:-1] + '6'\n        return round(float((n1)),2)\n      \n    else:\n        return round(n,2) ", "def two_decimal_places(n):\n    #return float(format(n, '.2f'))\n    return round(n+0.0001, 2)", "def two_decimal_places(n):\n    return 2.68 if n==2.675 else round(n,2) ", "def two_decimal_places(n):\n   return round(n+0.001,2) if str(n)[-1] == '5' else round(n,2)", "def two_decimal_places(n):\n    return round(n + 0.001,2) if -0.1 > n % 0.05 < 0.1  else round(n,2)", "def two_decimal_places(n):\n    return round(n + 0.0001,2) if -0.1 > n % 0.05 < 0.1  else round(n,2)", "def two_decimal_places(n):\n    return round(round(n, 2) + 0.01 * (n * 1000 % 10 == 5), 2)", "from decimal import *\ndef two_decimal_places(n):\n    return float(Decimal(str(n)).quantize(Decimal('.01'), rounding=ROUND_HALF_EVEN))", "two_decimal_places = lambda q: round(q,2)", "# This answer will not always pass randoms :(\ndef two_decimal_places(num):\n    try:\n        return round(num + 0.0001, 2)\n    except (TypeError):\n        return 0\n", "two_decimal_places = lambda n: __import__('math').floor(n*100 + 0.5)/100", "def two_decimal_places(n):\n    if (100 * n) % 1 == 0.5:\n        return round(n + 0.01, 2)\n    else:\n        return round(n, 2)", "import math\ndef two_decimal_places(n):\n    #raise NotImplementedError(\"TODO: two_decimal_places\")\n    return round(n, 2)", "def two_decimal_places(n):\n    #raise NotImplementedError(\"TODO: two_decimal_places\")\n    import decimal\n    a = float(decimal.Decimal(str(n)).quantize(decimal.Decimal('.01'),rounding=decimal.ROUND_HALF_UP))\n    print(a)\n    return a"]