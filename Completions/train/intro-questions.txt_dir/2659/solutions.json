["def last_chair(n):\n    return n - 1", "def last_chair(n):\n    # Propn:\n    #   Given there are n seats, n >= 2. The (n-1)th seat is always the\n    #   last to be taken (taken in iteration n).\n    # Proof:\n    #   Suppose that, for some n >= 2, the (n-1)th seat is taken on\n    #   iteration i > 2. The nth seat is already taken, since the 2nd\n    #   iteration will always claim it. Therefore i must sit beside\n    #   at least one person (the occupant of seat n).\n    #   Additionally, the (n-2)th seat must also already be taken.\n    #   If it were not taken, (n-2) would have a free seat at (n-1)\n    #   and would be closer to the exit, and so would rank higher\n    #   than (n-1) in the choice algorithm.\n    #   Therefore (n-1) will only be chosen when (n-2) and (n) are\n    #   both taken.\n    #   Also, all other seats must also be taken, since\n    #   otherwise i would taken them, having at most as many people\n    #   around as seat (n-1) and being closer to the exit.\n    #   Therefore (n-1) is the last seat to be taken.\n    return n - 1", "last_chair = lambda n: n - 1", "def last_chair(n):\n    return n if n<3 else n-1", "def last_chair(n):\n    if n < 3:\n        return n\n    return n - 1", "def last_chair(n):\n    # Last chair will allways be the 2nd to the last chair\n    return n - 1  ", "def last_chair(n):\n    if n == 1 or n == 2:\n        return n\n    else:\n        return n - 1", "def last_chair(n):\n    # The secret is, that it's always the next to last seat!\n    return n-1\n    \n    # Actual simulation for fun :)\n    # dist to e, used, nearest l, nearest r, nearest, spaces\n    spots = [[i, False, None, None, None, None] for i in range(n)]\n\n    clean = lambda n, d=0: n if n is not None else d\n    live = lambda s: not s[1]\n    position = lambda s: s[0]\n    near = lambda s: s[4]\n    spaces = lambda s: s[5]\n\n    while any(filter(live, spots)):\n        nearest = None\n        for i in range(n):\n            if spots[i][1]:\n                nearest = 0\n            elif nearest is not None:\n                nearest += 1\n            spots[i][2] = nearest\n\n        nearest = None\n        for i in range(n-1, -1, -1):\n            if spots[i][1]:\n                nearest = 0\n            elif nearest is not None:\n                nearest += 1\n            spots[i][3] = nearest\n\n        for i in range(n):\n            spots[i][4] = min(clean(spots[i][2], n), clean(spots[i][3], n))\n            spots[i][5] = clean(spots[i][2]) + clean(spots[i][3])\n\n        options = list(filter(live, spots))\n        options.sort(key=near, reverse=True)\n        best = near(options[0])\n        options = [s for s in options if near(s) == best]\n        #print \"Options\"\n        #for s in options:\n        #    print s\n        options.sort(key=spaces, reverse=True)\n        best = spaces(options[0])\n        options = [s for s in options if spaces(s) == best]\n        options.sort(key=position)\n        options[0][1] = True\n        result = position(options[0])\n    return result + 1\n", "last_chair = 1 .__rsub__"]