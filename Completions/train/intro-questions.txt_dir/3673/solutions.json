["def totient(n):\n    if not isinstance(n,int) or n<1: return 0\n    \n    phi = n >= 1 and n\n    for p in range(2, int(n ** .5) + 1):\n        if not n % p:\n            phi -= phi // p\n            while not n % p:\n                n //= p\n    if n > 1: phi -= phi // n\n    return phi", "PRIMES = [2, 3, 5, 7, 11, 13, 17, 19]\n\ndef primes():\n    \"\"\"Yields 'all' prime numbers\"\"\"\n    yield from PRIMES\n    \n    # Last known prime\n    n = PRIMES[-1]\n    # Approx limit of primes that can be factors\n    limit = int(n ** 0.5)\n    check = limit * limit\n\n    while True:\n        # Next prime candidate for testing\n        n += 2\n        # Maintain limit\n        if check < n:\n            limit += 1\n            check = limit * limit\n        \n        # Using Fundamental Theorem of Arithemtic we only need to check primes are factors to determine if composite\n        for p in PRIMES:\n            if n % p == 0:\n                # n has a prime factor, so it is not prime\n                break\n            if p > limit:\n                # No further primes can be a factor as the counterpart n/p would have already been found.\n                # So n must be prime\n                PRIMES.append(n)\n                yield n\n                break\n\n\ndef prime_factors(n):\n    \"\"\"Returns the prime factors of n\"\"\"\n    if n < 2:\n        return []\n    factors = []\n    for p in primes():\n        if n % p == 0:\n            # Found a factor\n            factors.append(p)\n            while n % p == 0:\n                n //= p\n        elif p * p > n:\n            # No need for more tests, the residual value must be prime\n            factors.append(n)\n            n = 1\n        \n        if n <= 1:\n            # Found all prime factors\n            break\n    return factors\n\ndef totient(n):\n    if not isinstance(n, int) or n < 1:\n        return 0\n    \n    factors = prime_factors(n)\n    # print(f'Prime factors of {n}: {factors}')\n    if not factors:\n        # Only gcd(1, 1) == 1\n        return 1\n    \n    if factors[0] == n:\n        # n is prime, so all gcd([1..n - 1], n) == 1\n        return n - 1\n\n    # Apply Euler's product formula to calculate totient: n * prod((f - 1) / f)\n    for f in factors:\n        n //= f\n        n *= f - 1\n    return n\n", "def totient(n):\n    try:\n        assert isinstance(n, int) and n > 0\n        phi = n\n        if not n % 2:\n            phi -= phi // 2\n            while not n % 2: n //= 2\n        for p in range(3, int(n ** .5) + 1, 2):\n            if not n % p:\n                phi -= phi // p\n                while not n % p: n //= p\n        if n > 1: phi -= phi // n\n        return phi\n    except: return 0", "from itertools import count, chain\nfrom fractions import Fraction\nfrom functools import reduce\nfrom operator import mul\n\ndef primes(n):\n    for x in chain([2], count(3, 2)):\n        if n == 1: return\n        if x**2 > n:\n            yield Fraction(n-1, n)\n            return\n        elif not n % x: \n            yield Fraction(x-1, x)\n            while not n % x: n //= x\n\ndef totient(n):\n    return reduce(mul, primes(n), n) if type(n) == int and n >= 1 else 0", "\ndef totient(n):\n    if not isinstance(n, int) or n<1:\n        return 0\n    factor=prime_factorization(n)\n    up=1\n    down=1\n    for i in factor:\n        up*=(i-1)\n        down*=i\n    return n*up//down\ndef prime_factorization(n):\n    res=set()\n    while n>1 and n%2==0:\n        res.add(2)\n        n//=2\n    while n>1 and n%3==0:\n        res.add(3)\n        n//=3\n    factor=5\n    while factor*factor<=n:\n        if n%factor==0:\n            res.add(factor)\n            n//=factor\n            factor=5\n        else:\n            factor+=1\n    if n>1:\n        res.add(n)\n    return res", "def prod(a, s=1):\n    for p in a: s *= p\n    return s\n\ndef prime_factors(n):\n    for d in range(2, int(n ** 0.5) + 1):\n        while n % d == 0:\n            yield d\n            n //= d\n    if n > 1:\n        yield n\n\ndef totient(n):\n    if type(n) is not int or n < 0: return 0\n    return round(n * prod(1 - 1 / p for p in set(prime_factors(n))))", "def totient(n):\n    try:\n        if n <= 0 or type(n).__name__ == str or n == None:\n            return 0\n        result = n\n        p = 2\n        while p * p <= n:\n            if n % p == 0:\n                while n % p == 0:\n                    n = n // p\n                result = result * (1 - (1 / float(p)))\n            p = p + 1\n    \n        if (n > 1):\n            result = result * (1 - (1 / float(n)))\n    \n        return int(result)\n    except Exception:\n        return 0", "import numbers, math\nfrom fractions import Fraction\ndef primeFactors(n): \n    c = n\n    p = []\n    while n % 2 == 0:\n        if not 2 in p: p.append(2)\n        n /= 2\n    for i in range(3,int(math.sqrt(n))+1,2):\n        while n % i== 0:\n            if not i in p: p.append(int(i))\n            n /= i \n    if n!=1: p.append(int(n))\n    return p or [c]\n\ndef totient(n):\n    if not isinstance(n, numbers.Number) or n<1: return 0\n    if n==1: return n\n    res = Fraction(1,1)\n    print((n, primeFactors(n)))\n    for p in primeFactors(n):\n        res*=Fraction(p-1, p)\n    return Fraction(n,1)*res\n    \n", "def totient(n):\n    if type(n) is not int or n < 0: return 0\n    tot = 1\n    p = 2\n    while n > 1 and p * p <= n:\n      k = 0\n      while n > 0 and n % p == 0:\n        k += 1\n        n //= p\n      if k > 0: tot *= p ** (k - 1) * (p - 1)\n      p += 1\n    if n > 1: tot *= (n - 1)\n    return tot", "def totient(a):\n    try:\n        res = max(int(a),0)\n        b = a\n        i = 2\n        while i*i <= a:\n            if a % i == 0:\n                res -= res//i\n                while a % i == 0:\n                    a //= i\n            i = i+1\n        if(a>1):\n            res -= res//a\n        return res\n    except:\n        return 0"]