["def next_higher(value):\n    s = f'0{value:b}'\n    i = s.rfind('01')\n    s = s[:i] + '10' + ''.join(sorted(s[i+2:]))\n    return int(s, 2)", "from itertools import count\ndef next_higher(value):\n    bits = bin(value).count('1')\n    return next(i for i in count(value+1) if bin(i).count('1')==bits)", "import re\n\ndef next_higher(v):\n    return int(re.sub(r'(0?1)(1*)(0*)$', r'10\\3\\2', f'{v:b}'), 2)", "from math import log2\n\ndef next_higher(v):\n    l = v&-v\n    u = ~(v|l-1) & -~(v|l-1)\n    return (v|u-1)^u-1 | u | (v&u-1) >> int(log2(l))+1", "next_higher = lambda x : x + (x & -x) | (x ^ x + (x & -x)) // (x & -x) >> 2 \n", "from collections import Counter\n\ndef next_higher(prev: int) -> int:\n    \"\"\"\n    Consider the integer as a binary integer, left-padded with a zero. To find\n    the next binary integer with the same number of bits we must swap (to\n    preserve the number of set bits) the least significant zero (to ensure the\n    increase is not too large) that is more significant than a one (to ensure\n    that the swap causes an increase).\n\n    This ensures that the number is strictly greater than the input.\n    To ensure that it is the next number the remaining (less-significant) bit\n    must be sorted (unset bits more significant than set bits) to get the\n    smallest possible number.\n    \"\"\"\n\n    bin_string = f'0{prev:b}'\n    i = bin_string.rfind(\"01\")\n    counts = Counter(bin_string[i + 2:])\n    return int(f'{bin_string[:i]}10{\"0\" * counts[\"0\"]}{\"1\" * counts[\"1\"]}', 2)", "def next_higher(value):\n    value = list(bin(value)[2:][-1::-1])\n    one = value.count('1')\n    while True:\n        tale = 1\n        for i in range(len(value)):\n            bite = str((int(value[i]) + tale) % 2)\n            value[i] = bite\n            tale = 1 if bite == '0' else 0\n            if not tale:\n                break\n        if tale:\n            value.append('1')\n        if value.count('1') == one:\n            break\n    return int(''.join(value[-1::-1]), 2)", "def next_higher(n):\n    b = f\"0{n:b}\"\n    i = b.rfind(\"01\")\n    return int(f\"{b[:i]}10{''.join(sorted(b[i+2:]))}\", 2)\n", "def next_higher(value):\n    c=bin(value).count('1')\n    output_num=''\n    while True:\n        value=value+1\n        if c==bin(value).count('1'):\n            output_num=value\n            break\n    return output_num", "def next_higher(value):\n    value2=value+1\n    while (bin(value)).count(\"1\")!=(bin(value2)).count(\"1\"):\n        value2+=1\n    return value2"]