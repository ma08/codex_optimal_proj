["from collections import deque\nimport re\n\nTOKENIZER = re.compile(r'(R+|F+|L+)(\\d*)')\n\ndef execute(code):\n    \n    pos, dirs = (0,0), deque([(0,1), (1,0), (0,-1), (-1,0)])\n    seens = {pos}\n    \n    for act,n in TOKENIZER.findall(code):\n        s,r = act[0], int(n or '1') + len(act)-1\n        \n        if s == 'F':\n            for _ in range(r):\n                pos = tuple( z+dz for z,dz in zip(pos, dirs[0]) )\n                seens.add(pos)\n        else:\n            dirs.rotate( (r%4) * (-1)**(s == 'R') )\n    \n    miX, maX = min(x for x,y in seens), max(x for x,y in seens)\n    miY, maY = min(y for x,y in seens), max(y for x,y in seens)\n    \n    return '\\r\\n'.join( ''.join('*' if (x,y) in seens else ' ' for y in range(miY, maY+1)) \n                        for x in range(miX, maX+1) )", "import re\nDIRS = [(1, 0), (0, 1), (-1, 0), (0, -1)] * 2\n\ndef execute(code):\n    grid, (dx, dy) = {(0, 0)}, DIRS[0]\n    x = y = xm = ym = xM = yM = 0\n    for dir, n in re.findall('([FLR])(\\d*)', code):\n        for _ in range(int(n or '1')):\n            if dir == 'L': dx, dy = DIRS[DIRS.index((dx, dy)) - 1]\n            if dir == 'R': dx, dy = DIRS[DIRS.index((dx, dy)) + 1]\n            if dir == 'F':\n                x += dx; y += dy\n                grid.add((x, y))\n                xm, ym, xM, yM = min(xm, x), min(ym, y), max(xM, x), max(yM, y)\n    return '\\r\\n'.join(''.join(' *'[(x, y) in grid] for x in range(xm, xM + 1)) for y in range(ym, yM + 1))", "import re\n\ndef execute(code):\n    if code == '':\n        return '*'\n    turn_right = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n    turn_left =  [[-1, 0], [0, -1], [1, 0], [0, 1]]\n    path = re.findall('F\\d+|F|L\\d+|L|R\\d+|R', code)\n    max_size = sum([1 if j == 'F' else int(j[1:]) for j in path if 'F' in j]) * 2\n    table = [[' '] * (max_size + 1) for i in range(max_size + 1)]\n    x, y = max_size // 2, max_size // 2\n    table[x][y] = '*'\n    f1, f2 = 0, 1\n    for way in path:\n        if 'R' in way:\n            for i in range(1 if way == 'R' else int(way[1:])):\n                cur_pos = [pos for pos, coords in enumerate(turn_right) if coords == [f1, f2]][0]\n                f1, f2 = turn_right[0] if cur_pos == 3 else turn_right[cur_pos + 1]\n        if 'L' in way:\n            for i in range(1 if way == 'L' else int(way[1:])):\n                cur_pos = [pos for pos, coords in enumerate(turn_left) if coords == [f1, f2]][0]\n                f1, f2 = turn_left[0] if cur_pos == 3 else turn_left[cur_pos + 1]        \n        if 'F' in way:\n            for i in range(1 if way == 'F' else int(way[1:])):\n                x += 1 * f1\n                y += 1 * f2\n                table[x][y] = '*'\n    solution = [i for i in table if '*' in i]\n    solution = [i for i in zip(*solution[:]) if '*' in i]\n    for i in range(3):\n        solution = list(zip(*solution[:]))\n    final_way = [''.join([j for j in i]) for i in solution]\n    return '\\r\\n'.join(final_way)", "import re\nfrom enum import Enum\nfrom operator import itemgetter\nfrom typing import List, Tuple, Set, Generator\n\n\nCell = Tuple[int, int]\n\n\nclass Direction(Enum):\n    UP = (0, 1)\n    DOWN = (0, -1)\n    RIGHT = (1, 0)\n    LEFT = (-1, 0)\n\n\ndef execute(code: str) -> str:\n    visited_cells = visit_cells(code)\n    path = draw_path(visited_cells)\n    return path\n    \n    \ndef visit_cells(code: str) -> Set[Cell]:\n    visited_cells = [(0, 0)]\n    direction = Direction.RIGHT\n    \n    for action, n_times in code_interpreter(code):\n        if action == 'F':\n            new_cells = move_forward(visited_cells[-1], direction, n_times)\n            visited_cells.extend(new_cells)\n        else:\n            direction = make_turn(direction, action, n_times)\n    return set(visited_cells)\n\n\ndef code_interpreter(code: str) -> Generator[Tuple[str, int], None, None]:\n    for move in re.finditer(r'([LRF])(\\d*)', code):\n        action = move.group(1)\n        times = int(move.group(2)) if move.group(2) else 1\n        yield action, times\n    \n\ndef move_forward(position: Cell, direction: Direction, n_moves: int) -> List[Cell]:\n    px, py = position\n    dx, dy = direction.value\n    return [(px + i * dx, py + i * dy) for i in range(1, n_moves + 1)]\n\n\ndef make_turn(start: Direction, side: str, n_turns: int) -> Direction:\n    ordering = [Direction.RIGHT, Direction.DOWN, Direction.LEFT, Direction.UP]\n    step = 1 if side == 'R' else -1\n    return ordering[(ordering.index(start) + step * n_turns) % len(ordering)]\n    \n    \ndef draw_path(visited_cells: Set[Cell]) -> str:\n    max_x, min_x, max_y, min_y = find_cells_boundaries(visited_cells)\n    \n    rectangle = list()\n    for y in range(max_y, min_y - 1, -1):\n        row = ['*' if (x, y) in visited_cells else ' ' for x in range(min_x, max_x + 1)]\n        rectangle.append(''.join(row))\n    \n    return '\\r\\n'.join(rectangle)\n    \n    \ndef find_cells_boundaries(visited_cells: Set[Cell]) -> Tuple[int, int, int, int]:\n    max_x, _ = max(visited_cells, key=itemgetter(0))\n    min_x, _ = min(visited_cells, key=itemgetter(0))\n    \n    _, max_y = max(visited_cells, key=itemgetter(1))\n    _, min_y = min(visited_cells, key=itemgetter(1))\n    return max_x, min_x, max_y, min_y\n    \n    \n        \n", "import re\nleft = {'right': 'up', 'up': 'left', 'left': 'down', 'down': 'right'}\nright = {'right': 'down', 'down': 'left', 'left': 'up', 'up': 'right'}\ndef execute(s):\n    s, direction = re.sub(r'([RFL])(\\d+)', lambda x: x.group(1) * int(x.group(2)), s), 'right'\n    p, p1, li = 0, 0, [[0, 0]]\n    for i in s:\n        if i == 'L' : direction = left[direction]\n        if i == \"R\" : direction = right[direction]\n        if i == \"F\":\n            p1 += (1 if direction == \"right\" else -1) if direction in ['left', 'right'] else 0\n            p += (1 if direction == 'down' else -1) if direction in ['up', 'down'] else 0\n            li.append([p, p1])\n    m, n = abs(min(li, key=lambda x:x[0])[0])+max(li,key=lambda x:x[0])[0], abs(min(li,key=lambda x:x[1])[1])+max(li,key=lambda x:x[1])[1]\n    p, p1, grid= abs(min(li,key=lambda x:x[0])[0]), abs(min(li,key=lambda x:x[1])[1]), [[' ' for _ in range(n+1)] for _ in range(m+1)]\n    for i, j in li : grid[p + i][p1 + j] = \"*\" \n    return \"\\r\\n\".join([\"\".join(i) for i in grid])", "import numpy as np\ndef switch(argument):\n    switcher = {\n        'F': 0,\n        'L': -1,\n        'R': 1\n    }\n    return switcher.get(argument, '')\n\ndef  resize(p_matrix,num,axis,dir):\n    if axis == 1:\n        right = np.zeros((p_matrix.shape[0], num))\n        left = p_matrix\n        if dir == 2:\n            right, left = left, right\n        re_matrix = np.append(left,right,axis)\n    else:\n        top = np.zeros((num,p_matrix.shape[1]))\n        bot = p_matrix\n        if dir == 1:\n            top, bot = bot, top\n        re_matrix = np.append(top,bot,axis)\n    return re_matrix\n\ndef mk_matrix(trace):\n    p_matrix = np.full((1,1),1)\n    pos = [0,0]\n    for i in range(len(trace)):\n        \n        dir = trace[i][0]\n        step = trace[i][1]\n        if step != 0 :\n            if dir == 0:\n                if (pos[1]+step+1)> p_matrix.shape[1]:\n                    p_matrix = resize(p_matrix,pos[1]+step-p_matrix.shape[1]+1,1,dir)\n                p_matrix[pos[0],(pos[1]+1):(pos[1]+step+1)] = 1\n                pos[1] = pos[1]+step\n            elif dir == 1:\n                if (pos[0]+step+1)> p_matrix.shape[0]:\n                    p_matrix = resize(p_matrix,pos[0]+step-p_matrix.shape[0]+1,0,dir)\n                p_matrix[(pos[0]+1):(pos[0]+1+step),pos[1]] = 1\n                pos[0] = pos[0]+step\n            elif dir == 2:\n                if (pos[1]-step) < 0:\n                    p_matrix = resize(p_matrix,step-pos[1],1,dir)\n                    pos[1] = step\n                p_matrix[pos[0],(pos[1]-step):(pos[1])] = 1\n                pos[1] = pos[1]-step\n            else:\n                if (pos[0]-step)<0:\n                    p_matrix = resize(p_matrix,step-pos[0],0,dir)\n                    pos[0] = step\n                p_matrix[(pos[0]-step):(pos[0]),pos[1]] = 1\n                pos[0] = pos[0]-step\n    return p_matrix\n\n\ndef tracing(path):\n    dir = 0 #pointing right\n    # 0-> direita ; 1-> baixo ; 2-> esquerda ; 3->cima\n    trace = []\n    for j in range(len(path)):\n        step = 0\n        if path[j][0] == 0:\n            if len(path[j]) == 2:\n                step = path[j][1]\n            else:\n                step = 1\n        else:\n            if len(path[j]) == 2:\n                dir = (((path[j][0]*path[j][1])+dir)%4)\n            else:\n                dir = (dir+path[j][0])%4\n        trace.append([dir,step])\n    return trace\n\ndef pathing(code):\n    path = []\n    way = -1\n    num = -1\n    for i in range(len(code)):\n        if i < num:\n            continue\n        qnt = \"\"\n        num = i\n        if code[i].isdecimal():\n            if num < len(code):\n                while code[num].isdecimal():\n                    qnt += code[num]\n                    if num+1 >= len(code):\n                        break\n                    num += 1\n                if len(path[way])<2:\n                    length = int(qnt,10)\n                    path[way].append(length)\n        else:\n            way+=1\n            path.append([])\n            path[way].append(switch(code[i]))\n    return path\n\ndef str_mx(matrix):\n    str = []\n    subm = np.full(matrix.shape,' ')\n    for i in range(matrix.shape[0]):\n        for j in range(matrix.shape[1]):\n            if matrix[i][j]:\n                subm[i][j] = '*'\n        if i>0:\n            str.append(\"\\r\\n\")\n        str.append(''.join(subm[i]))\n    return ''.join(str)\n\ndef execute(code):\n    path = pathing(code)\n    trace = tracing(path)\n    matrix = mk_matrix(trace)\n    print(matrix)\n    str = str_mx(matrix)\n    return str\n", "def execute(codes):\n    Nums=\"0123456789\"\n    code=''\n    t=0\n    c=0\n    while t < len(codes):\n        Char=0\n        c=1\n        if t<len(codes)-1:\n            for g in codes[t+1:]:\n                if g in Nums:\n                    Char+=1\n                else:\n                    break\n                c=int(codes[t+1:t+Char+1])\n        code+=codes[t]*c\n        t+=1+Char\n            \n        \n    Xs=0\n    Ys=0\n    X=[]\n    Y=[]\n    Ymin=0\n    Step=[[0,0]]\n    Rotation=0\n    Arr=[]\n    Out=''\n    for i in range(len(code)):\n        if code[i]==\"L\":\n            Rotation+=90\n        elif code[i]==\"R\":\n            Rotation+=-90\n        if Rotation>180:\n            while Rotation>180:\n                Rotation+=-360\n        elif Rotation<-180:\n            while Rotation<-180:\n                Rotation+=360\n        if code[i]==\"F\":\n            if Rotation==0:\n                Xs+=1\n            elif Rotation==-180 or Rotation ==180:\n                Xs+=-1\n            elif Rotation==90:\n                Ys+=1\n            elif Rotation==-90:\n                Ys+=-1\n            Step.append([Xs,Ys])\n    for u in Step:\n        X.append(u[0])\n        Y.append(u[1])\n    for j in range(len(Step)):\n        Step[j][0]=Step[j][0]+min(X)*-1\n        Step[j][1]=Step[j][1]+min(Y)*-1\n    for k in range(max(Y)-min(Y)+1):\n            Arr.append([\" \"]*(max(X)-min(X)+1))\n    for l in Step:\n        Arr[max(Y)-min(Y)-l[1]][l[0]]=\"*\"\n    for n in range(len(Arr)):\n        for p in range(max(X)-min(X)+1):\n            Out+=Arr[n][p]\n        Out+=\"\\r\\n\"\n    Out=Out[:-2]\n    return(Out)", "def execute(code):\n    R, r, c, dr, dc = {(0, 0)}, 0, 0, 0, 1\n    D = {(1, 0):{'R':(0, -1), 'L':(0, 1)}, (-1, 0):{'R':(0, 1), 'L':(0, -1)}, (0, 1):{'R':(1, 0), 'L':(-1, 0)}, (0, -1):{'R':(-1, 0), 'L':(1, 0)}}\n    \n    for cmd in code.replace('R', ' R').replace('L', ' L').replace('F', ' F').strip().split():\n        cmd, n = cmd[:1], int(cmd[1:]) if cmd[1:] else 1\n        for _ in range(n):\n            if cmd in 'RL':             \n                dr, dc = D[(dr, dc)][cmd]\n            else:\n                r, c = r + dr, c + dc\n                R.add((r, c))\n                \n    mnr = min(r for r, _ in R)\n    mnc = min(c for _, c in R)\n    \n    R = {(r - mnr, c - mnc) for r, c in R}\n    \n    mxr = max(r for r, _ in R)           \n    mxc = max(c for _, c in R)           \n    \n    return '\\r\\n'.join(''.join(' *'[(r, c) in R] for c in range(mxc+1)) for r in range(mxr+1))", "import re\n\ndef update_grid(px, py, grid):\n    height = len(grid)\n    width = len(grid[0])\n    if px < 0:\n        px += 1\n        for y in range(height):\n            grid[y] = \" \" + grid[y]\n    if px >= width:\n        for y in range(height):\n            grid[y] = grid[y] + \" \"\n    if py < 0:\n        py += 1\n        grid.insert(0, \" \" * width)\n    if py >= height:\n        grid.append(\" \" * width)\n    grid[py] = grid[py][:px] + \"*\" + grid[py][px+1:]\n    return px, py, grid\n    \n\ndef execute(code):\n    grid = [\"*\"]\n    x, y = 0, 0\n    facing = (1, 0)\n    while code:\n        match = re.match(r'([FLR])(\\d*)', code)\n        code = re.sub(r'^([FLR])(\\d*)', '', code)\n        op = match[1]\n        rep = int(match[2] or \"1\")\n        for i in range(rep):\n            if op == \"F\":\n                x += facing[0]\n                y += facing[1]\n                x, y, grid = update_grid(x, y, grid)\n            if op == \"L\":\n                facing = (facing[1], -facing[0])\n            if op == \"R\":\n                facing = (-facing[1], facing[0])\n    return \"\\r\\n\".join(grid)\n", "BLANK = \" \"\nFILLCHAR = \"*\"\n\ndef pad_mtx(M, side=\"e\"):\n    \"\"\"\n    Pads matrix with row or column of blank chars depending on side keyword\n    \"\"\"\n    if side == \"w\":\n        for i in range(len(M)):\n            M[i] = [BLANK] + M[i][::1]\n    elif side == \"e\":\n        for i in range(len(M)):\n            M[i] += [BLANK]\n    elif side == \"n\":\n        M.insert(0, [BLANK for _ in range(len(M[0]))])\n    elif side == \"s\":\n        M.append([BLANK for _ in range(len(M[0]))])\n\ndef move(mtx, pos, drxn):\n    # modify position\n    if drxn == \"e\":\n        pos[1] += 1\n    elif drxn == \"w\":\n        pos[1] -= 1\n    elif drxn == \"s\":\n        pos[0] += 1\n    elif drxn == \"n\":\n        pos[0] -= 1\n    else:\n        raise ValueError(\"Direction unrecognized.\")\n    \n    # Check if path matrix needs to be modified\n    try:\n        if any(x < 0 for x in pos):\n            raise ValueError\n        else:\n            mtx[pos[0]][pos[1]] = FILLCHAR\n    # Modify it if an error was raised\n    except Exception:\n        pad_mtx(mtx, side=drxn)\n        # Update position to reflect modified matrix\n        if drxn == \"n\":\n            pos[0] += 1\n        if drxn == \"w\":\n            pos[1] += 1            \n        mtx[pos[0]][pos[1]] = FILLCHAR\n\ndef rotate(current, turn):\n    directions = [\"e\", \"s\", \"w\", \"n\"]\n    turns = {\"L\": -1, \"R\": 1}\n    idx = directions.index(current)\n    return directions[(idx + turns[turn]) % len(directions)]\n\n\ndef execute(code):\n    directions = [\"e\", \"s\", \"w\", \"n\"]\n    path = [[FILLCHAR]]\n    pos = [0, 0]\n    drxn = \"e\"\n    i = 0\n    while i < len(code):\n        # check if command is repeated\n        num = \"\"\n        if i != len(code) - 1 and code[i+1].isdigit():\n            j = i+1\n            while j < len(code) and code[j].isdigit():\n                num += code[j]\n                j += 1\n            for _ in range(int(num)):\n                if code[i] in \"LR\":\n                    drxn = rotate(drxn, code[i])\n                elif code[i] == \"F\":\n                    move(path, pos, drxn)\n                else:\n                    break\n                \n        elif code[i] == \"F\":\n            move(path, pos, drxn)\n        elif code[i] in \"LR\":\n            drxn = rotate(drxn, code[i])\n        i += 1\n    return \"\\r\\n\".join(\"\".join(row) for row in path)"]