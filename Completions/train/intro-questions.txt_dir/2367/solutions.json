["q = int(input())\nfor _ in range(q) :\n  n = int(input())\n  s = input()\n  t = input()\n\n  x = set(s)\n  y = set(t)\n\n  if x != y :\n    print(\"NO\")\n    continue\n\n  if len(x) == n :\n    a = [0] * n\n    for i, c in enumerate(t) :\n      a[i] = s.find(c)\n\n    yeet = 0\n    vis = [False] * n\n    for i in range(n) :\n      if vis[i] :\n        continue\n      j = i\n      cyc = 0\n      while not vis[j] :\n        cyc += 1\n        vis[j] = True\n        j = a[j]\n      # print('>> ', i, cyc)\n      yeet += (cyc - 1) % 2\n      yeet %= 2\n\n    if yeet == 0 :\n      print(\"YES\")\n    else :\n      print(\"NO\")\n    continue\n\n  print(\"YES\")\n", "from operator import itemgetter\n\n\nclass BIT():\n    def __init__(self, n):\n        '''n = \u8981\u7d20\u6570\n        \u8981\u7d20\u306e\u6dfb\u5b57i\u306f 0 <= i < n \u3068\u306a\u308b\n        '''\n        self.n = n\n        self.bit = [0] * (n + 1)\n \n    def add(self, i, val):\n        '''i\u756a\u76ee\u306e\u8981\u7d20\u306bval\u3092\u52a0\u7b97\u3059\u308b O(logN)'''\n        i = i + 1\n        while i <= self.n:\n            self.bit[i] += val\n            i += i & -i\n \n    def _sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n \n    def sum(self, i, j):\n        '''\u533a\u9593[i, j)\u306e\u548c\u3092\u6c42\u3081\u308b O(logN)'''\n        return self._sum(j) - self._sum(i)\n\n\ndef run_length_compress(string):\n    string.append(\"@\")\n    n = len(string)\n\n    begin = 0\n    end = 1\n    cnt = 1\n    ans = []\n    while True:\n        if end >= n:\n            break\n        if string[begin] == string[end]:\n            end += 1\n            cnt += 1\n        else:\n            ans.append((cnt, string[begin]))\n            begin = end\n            end = begin + 1\n            cnt = 1\n\n    return ans\n\n\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    s = list(input())\n    t = list(input())\n    tmp_s = sorted(s)\n    tmp_t = sorted(t)\n    s_run = run_length_compress(tmp_s)\n    t_run = run_length_compress(tmp_t)\n    flag = False\n    f = False\n    for i in range(len(s_run)):\n        if s_run[i][0] >= 2:\n            flag = True\n        if s_run[i] != t_run[i]:\n            print(\"NO\")\n            f = True\n            break\n    if f:\n        continue\n    if flag:\n        print(\"YES\")\n        continue\n    cnt_s = 0\n    cnt_t = 0\n    for i in range(n)[::-1]:\n        for j in range(i):\n            if s[j] > s[j+1]:\n                s[j], s[j+1] = s[j+1], s[j]\n                cnt_s += 1\n            if t[j] > t[j+1]:\n                t[j], t[j+1] = t[j+1], t[j]\n                cnt_t += 1\n    if cnt_s % 2 == cnt_t % 2:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "import sys\ninput = sys.stdin.readline\n\nq=int(input())\n\nfrom collections import Counter\n\nfor testcases in range(q):\n    n=int(input())\n    S=input().strip()\n    T=input().strip()\n\n    CS=Counter(S)\n    CT=Counter(T)\n\n    if CS!=CT:\n        print(\"NO\")\n        continue\n\n    if max(CS.values())>=2:\n        print(\"YES\")\n        continue\n\n    W=[0]*26\n    SA=0\n\n    for s in S:\n        SA+=sum(W[ord(s)-97:])\n        W[ord(s)-97]+=1\n\n    #print(SA)\n\n    W=[0]*26\n    TA=0\n\n    for s in T:\n        TA+=sum(W[ord(s)-97:])\n        W[ord(s)-97]+=1\n\n    #print(TA)\n\n    if (SA+TA)%2==0:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "from collections import Counter\nimport sys\ninput = sys.stdin.readline\n\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    s = input()\n    t = input()\n    if Counter(s) != Counter(t):\n        print('NO')\n        continue\n    elif Counter(s).most_common()[0][1] > 1:\n        print('YES')\n        continue\n    s_list = [ord(s[i]) for i in range(n)]\n    t_list = [ord(t[i]) for i in range(n)]\n\n    bit_s = Bit(150)\n    inv_s = 0\n    for i in range(n-1, -1, -1):\n        inv_s += bit_s.sum(s_list[i])\n        bit_s.add(s_list[i], 1)\n\n    bit_t = Bit(150)\n    inv_t = 0\n    for i in range(n - 1, -1, -1):\n        inv_t += bit_t.sum(t_list[i])\n        bit_t.add(t_list[i], 1)\n\n    if (inv_s - inv_t) % 2 == 0:\n        print('YES')\n    else:\n        print('NO')\n", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int,minp().split()))\n\ndef solve():\n\tn = mint()\n\n\ts = list(minp())\n\tt = list(minp())\n\tif sorted(t) != sorted(s):\n\t\tprint(\"NO\")\n\t\treturn\n\n\tfor i in range(26):\n\t\tif s.count(chr(ord('a')+i)) > 1:\n\t\t\tprint(\"YES\")\n\t\t\treturn\n\tr = 0\n\tfor i in range(len(s)):\n\t\tfor j in range(i+1,len(s)):\n\t\t\tif t.index(s[i]) > t.index(s[j]):\n\t\t\t\tr += 1\n\t#print(r)\n\tprint([\"NO\",\"YES\"][r%2 == 0])\n\nfor i in range(mint()):\n\tsolve()\n", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int,minp().split()))\n\ndef solve():\n\tn = mint()\n\n\ts = list(minp())\n\tt = list(minp())\n\tif sorted(t) != sorted(s):\n\t\tprint(\"NO\")\n\t\treturn\n\n\tfor i in range(26):\n\t\tif s.count(chr(ord('a')+i)) > 1:\n\t\t\tprint(\"YES\")\n\t\t\treturn\n\tr = 0\n\tfor i in range(len(s)):\n\t\tfor j in range(i+1,len(s)):\n\t\t\tif t.index(s[i]) > t.index(s[j]):\n\t\t\t\tr += 1\n\t#print(r)\n\tprint([\"NO\",\"YES\"][r%2 == 0])\n\nfor i in range(mint()):\n\tsolve()\n", "from collections import *\ndef f(s):\n    c = Counter(s)\n    if c.most_common()[0][1]>1:\n        return c\n    return c,sum(s[i]>s[j] for i in range(len(s))for j in range(i,len(s)))&1\nfor _ in range(int(input())):\n    n,s,t=input(),input(),input()\n    print(\"YNEOS\"[f(s)!=f(t)::2])", "from collections import *\nf=lambda s:(Counter(s),len(set(s))==len(s)and sum(s[i]>s[j] for i in range(len(s))for j in range(i,len(s)))&1)\nfor _ in range(int(input())):\n    n,s,t=input(),input(),input()\n    print(\"YNEOS\"[f(s)!=f(t)::2])", "q = int(input())\nfor i in range(q):\n    n = int(input())\n    a = input()\n    b = input()\n    countA = [0]*26\n    countB = [0]*26\n    for char in a:\n        countA[ord(char)-97] += 1\n    for char in b:\n        countB[ord(char)-97] += 1\n    no = 0\n    for i in range(26):\n        if countA[i] != countB[i]:\n            no = 1\n            break\n    if no:\n        print(\"NO\")\n        continue\n    yes = 0\n    for i in range(26):\n        if countA[i] >= 2:\n            yes = 1\n            break\n        if countB[i] >= 2:\n            yes = 1\n            break\n    if yes:\n        print(\"YES\")\n        continue\n    def countRev(s):\n        count = 0\n        for i in range(n):\n            for j in range(i+1,n):\n                if s[i] > s[j]:\n                    count += 1\n        return count\n    x = countRev(a) - countRev(b)\n    if x%2:\n        print(\"NO\")\n    else:\n        print(\"YES\")", "from collections import Counter \nfor _ in range(int(input())):\n    n=int(input())\n    s=input()\n    t=input()\n    c1=Counter(s)\n    c2=Counter(t)\n    if  c1!=c2:\n        print('NO')\n        continue \n    if n>26:\n        print('YES')\n        continue \n    if max(c1.values())>=2:\n        print(\"YES\")\n        continue\n    p1=0 \n    p2=0 \n    for i in range(n):\n        for j in range(i+1,n):\n            if s[i]>s[j]:\n                p1+=1 \n            if t[i]>t[j]:\n                p2+=1 \n    print('YES' if p1%2==p2%2 else \"NO\")", "def cal(s):\n    res = 0\n    for i in range(len(s)):\n        for j in range(i+1,len(s)):\n            if s[i]>s[j]:\n                res ^= 1\n    return res\n\ndef solve():\n    int(input())\n    s = input()\n    t = input()\n    if(sorted(s)!=sorted(t)):\n        print('NO')\n        return\n    for i in range(26):\n        if s.count(chr(ord('a')+i))>1:\n            print('YES')\n            return\n    print(['NO','YES'][cal(s)==cal(t)])\n\nfor i in range(int(input())):\n    solve()\n", "def cal(s):\n    res = 0\n    for i in range(len(s)):\n        for j in range(i+1,len(s)):\n            if s[i]>s[j]:\n                res ^= 1\n    return res\n\ndef solve():\n    [n,s,t] = [input(),input(),input()]\n    if(sorted(s)!=sorted(t)):\n        print('NO')\n        return\n    for i in range(26):\n        if s.count(chr(ord('a')+i))>1:\n            print('YES')\n            return\n    print(['NO','YES'][cal(s)==cal(t)])\n\nfor i in range(int(input())):\n    solve()\n", "q = int(input())\n\n# Python 3 program to count inversions in an array \n\n# Function to Use Inversion Count \ndef mergeSort(arr, n): \n\t# A temp_arr is created to store \n\t# sorted array in merge function \n\ttemp_arr = [0]*n \n\treturn _mergeSort(arr, temp_arr, 0, n-1) \n\n# This Function will use MergeSort to count inversions \n\ndef _mergeSort(arr, temp_arr, left, right): \n\n\t# A variable inv_count is used to store \n\t# inversion counts in each recursive call \n\n\tinv_count = 0\n\n\t# We will make a recursive call if and only if \n\t# we have more than one elements \n\n\tif left < right: \n\n\t\t# mid is calculated to divide the array into two subarrays \n\t\t# Floor division is must in case of python \n\n\t\tmid = (left + right)//2\n\n\t\t# It will calculate inversion counts in the left subarray \n\n\t\tinv_count = _mergeSort(arr, temp_arr, left, mid) \n\n\t\t# It will calculate inversion counts in right subarray \n\n\t\tinv_count += _mergeSort(arr, temp_arr, mid + 1, right) \n\n\t\t# It will merge two subarrays in a sorted subarray \n\n\t\tinv_count += merge(arr, temp_arr, left, mid, right) \n\treturn inv_count \n\n# This function will merge two subarrays in a single sorted subarray \ndef merge(arr, temp_arr, left, mid, right): \n\ti = left\t # Starting index of left subarray \n\tj = mid + 1 # Starting index of right subarray \n\tk = left\t # Starting index of to be sorted subarray \n\tinv_count = 0\n\n\t# Conditions are checked to make sure that i and j don't exceed their \n\t# subarray limits. \n\n\twhile i <= mid and j <= right: \n\n\t\t# There will be no inversion if arr[i] <= arr[j] \n\n\t\tif arr[i] <= arr[j]: \n\t\t\ttemp_arr[k] = arr[i] \n\t\t\tk += 1\n\t\t\ti += 1\n\t\telse: \n\t\t\t# Inversion will occur. \n\t\t\ttemp_arr[k] = arr[j] \n\t\t\tinv_count += (mid-i + 1) \n\t\t\tk += 1\n\t\t\tj += 1\n\n\t# Copy the remaining elements of left subarray into temporary array \n\twhile i <= mid: \n\t\ttemp_arr[k] = arr[i] \n\t\tk += 1\n\t\ti += 1\n\n\t# Copy the remaining elements of right subarray into temporary array \n\twhile j <= right: \n\t\ttemp_arr[k] = arr[j] \n\t\tk += 1\n\t\tj += 1\n\n\t# Copy the sorted subarray into Original array \n\tfor loop_var in range(left, right + 1): \n\t\tarr[loop_var] = temp_arr[loop_var] \n\t\t\n\treturn inv_count \n\n\nfor i in range(q):\n    l = int(input())\n    s1 = input()\n    s2 = input()\n\n    if sorted(s1) != sorted(s2):\n        print(\"NO\")\n        continue\n\n    if len(s1) != len(set(s1)): print(\"YES\"); continue\n    if len(s2) != len(set(s2)): print(\"YES\"); continue\n\n    arr = [s2.index(c) for c in s1]\n    \n    \n    if mergeSort(arr, len(arr)) % 2 == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    \n", "import sys\n \ndef minp():\n\treturn sys.stdin.readline().strip()\n \ndef mint():\n\treturn int(minp())\n \ndef mints():\n\treturn list(map(int,minp().split()))\n \ndef solve():\n\tn = mint()\n \n\ts = list(minp())\n\tt = list(minp())\n\tif sorted(t) != sorted(s):\n\t\tprint(\"NO\")\n\t\treturn\n \n\tfor i in range(26):\n\t\tif s.count(chr(ord('a')+i)) > 1:\n\t\t\tprint(\"YES\")\n\t\t\treturn\n\tr = 0\n\tfor i in range(len(s)):\n\t\tfor j in range(i+1,len(s)):\n\t\t\tif t.index(s[i]) > t.index(s[j]):\n\t\t\t\tr += 1\n\t#print(r)\n\tprint([\"NO\",\"YES\"][r%2 == 0])\n \nfor i in range(mint()):\n\tsolve()\n", "from collections import defaultdict\nfrom math import sqrt,factorial,gcd,log2,inf,ceil\n# map(int,input().split())\n# l = list(map(int,input().split()))\nmod = 10**9 + 7\n\ndef mergeSort(arr, n):\n\n    temp_arr = [0]*n\n    return _mergeSort(arr, temp_arr, 0, n-1)\n\n\n\ndef _mergeSort(arr, temp_arr, left, right):\n\n\n\n    inv_count = 0\n\n\n\n    if left < right:\n\n\n\n        mid = (left + right)//2\n\n\n        inv_count = _mergeSort(arr, temp_arr, left, mid)\n\n\n        inv_count += _mergeSort(arr, temp_arr, mid + 1, right)\n\n\n\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\n\ndef merge(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n\n\n    while i <= mid and j <= right:\n\n        # There will be no inversion if arr[i] <= arr[j]\n\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n\n\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            k += 1\n            j += 1\n\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n\n    return inv_count\n\nt = int(input())\n\nfor _ in range(t):\n\n    n = int(input())\n    s = input()\n    t = input()\n    if sorted(s)!=sorted(t):\n        print('NO')\n    else:\n        hash = defaultdict(int)\n        flag = 0\n        for i in s:\n          hash[i]+=1\n          if hash[i]>1:\n            print('YES')\n            flag = 1\n            break\n        if not flag:\n\n          l1 = [ord(i) for i in s]\n          l2 = [ord(i) for i in t]\n          z1 = mergeSort(l1,n)\n          z2 = mergeSort(l2,n)\n\n          if z1%2!=z2%2:\n            print('NO')\n          else:\n            print('YES')\n\n\n\n", "import random\n\n\ndef count_lens(t):\n t=list(t)\n n=len(t)\n res=0\n for _ in range(n):\n  for k in range (n-1):\n   if t[k]>t[k+1]:\n    t[k],t[k+1]=t[k+1],t[k]\n    res+=1\n    \n return (res) % 2\n\n\ndef prog():\n    input()\n    a, b = input(), input()\n    if sorted(a) != sorted(b):\n        print(\"NO\")\n        return\n\n    if len(set(a)) < len(a):\n        print(\"YES\")\n        return\n\n    print(\"YES\" if count_lens(a) == count_lens(b) else \"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    prog()", "import sys\n \ndef minp():\n\treturn sys.stdin.readline().strip()\n \ndef mint():\n\treturn int(minp())\n \ndef mints():\n\treturn map(int,minp().split())\n \ndef solve():\n\tn = mint()\n \n\ts = list(minp())\n\tt = list(minp())\n\tif sorted(t) != sorted(s):\n\t\tprint(\"NO\")\n\t\treturn\n \n\tfor i in range(26):\n\t\tif s.count(chr(ord('a')+i)) > 1:\n\t\t\tprint(\"YES\")\n\t\t\treturn\n\tr = 0\n\tfor i in range(len(s)):\n\t\tfor j in range(i+1,len(s)):\n\t\t\tif t.index(s[i]) > t.index(s[j]):\n\t\t\t\tr += 1\n\t#print(r)\n\tprint([\"NO\",\"YES\"][r%2 == 0])\n \nfor i in range(mint()):\n\tsolve()", "import sys\n\ndef minp():\n\treturn sys.stdin.readline().strip()\n\ndef mint():\n\treturn int(minp())\n\ndef mints():\n\treturn list(map(int,minp().split()))\n\ndef solve():\n\tn = mint()\n\n\ts = list(minp())\n\tt = list(minp())\n\tif sorted(t) != sorted(s):\n\t\tprint(\"NO\")\n\t\treturn\n\tif len(s) > 26:\n\t\tprint(\"YES\")\n\t\treturn\n\n\tfor i in range(26):\n\t\tif s.count(chr(ord('a')+i)) > 1:\n\t\t\tprint(\"YES\")\n\t\t\treturn\n\tr = 0\n\tfor i in range(len(s)):\n\t\tif s[i] != t[i]:\n\t\t\tjj = i\n\t\t\tfor j in range(i+1,len(s)):\n\t\t\t\tif s[j] == t[i]:\n\t\t\t\t\tjj = j\n\t\t\t\t\tbreak\n\t\t\tfor j in range(jj-1,i-1,-1):\n\t\t\t\ts[j],s[j+1] = s[j+1], s[j]\n\t\t\t\tr += 1\n\t#print(r)\n\tprint([\"NO\",\"YES\"][r%2 == 0])\n\nfor i in range(mint()):\n\tsolve()\n", "from collections import*\nh=input\nq=len\nr=range\nf=lambda s:(Counter(s),q(set(s))==q(s)and sum(s[i]>s[j]for i in r(q(s))for j in r(i,q(s)))&1)\nfor _ in r(int(h())):\n    n,s,t=h(),h(),h()\n    print(\"YNEOS\"[f(s)!=f(t)::2])", "import sys\n \ndef minp():\n\treturn sys.stdin.readline().strip()\n \ndef mint():\n\treturn int(minp())\n \ndef mints():\n\treturn map(int,minp().split())\n \ndef solve():\n\tn = mint()\n \n\ts = list(minp())\n\tt = list(minp())\n\tif sorted(t) != sorted(s):\n\t\tprint(\"NO\")\n\t\treturn\n \n\tfor i in range(26):\n\t\tif s.count(chr(ord('a')+i)) > 1:\n\t\t\tprint(\"YES\")\n\t\t\treturn\n\tr = 0\n\tfor i in range(len(s)):\n\t\tfor j in range(i+1,len(s)):\n\t\t\tif t.index(s[i]) > t.index(s[j]):\n\t\t\t\tr += 1\n\t#print(r)\n\tprint([\"NO\",\"YES\"][r%2 == 0])\n \nfor i in range(mint()):\n\tsolve()", "\ndef getInvCount(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count\n\n\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    s = input()\n    t = input()\n    if set(s) != set(t):\n        print(\"NO\")\n        continue\n    if len(set(s)) < len(s):\n        print(\"YES\")\n        continue\n    else:\n        if len(s) <= 26 and getInvCount(list(s)) % 2 == getInvCount(list(t)) % 2:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n\n", "from collections import Counter\n\n\ndef moves_needed_when_there_is_no_repeated_char(st):\n    size_st = len(st)\n    sloution = 0\n    for _ in range(size_st):\n        for ind in range(size_st-1):\n            if st[ind] > st[ind + 1]:\n                st[ind] , st[ind+1] = st[ind+1] , st[ind]\n                sloution+=1\n    return sloution % 2\n\ndef check_number_of_chars(st1, st2):\n    cnt_a = Counter(st1)\n    cnt_b = Counter(st2)\n\n    if cnt_a != cnt_b:\n        return False\n    else:\n        return True\n\n\ndef is_equal(st1, st2 , number):\n\n    if st1 == st2:\n        return True\n\n    if not check_number_of_chars(st1, st2):\n        return False\n\n    if len(set(st1)) < len(st1) or len(set(st2)) < len(st2):\n        return True\n\n    if  moves_needed_when_there_is_no_repeated_char(st1) == moves_needed_when_there_is_no_repeated_char(st2):\n        return True\n    else:\n        return False\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(input())\n    b = list(input())\n    if is_equal(a , b , n):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n", "from string import ascii_lowercase\n\nq = int(input())\n\nfor _ in range(q):\n\tn = int(input())\n\tA = input()\n\tB = input()\n\n\tc_a = {}\n\tc_b = {}\n\n\tans = False\n\n\tif sorted(A) == sorted(B):\n\t\tinv_a = 0\n\t\tinv_b = 0\n\t\thas_multi = False\n\n\t\tfor a in A:\n\t\t\tfor k in c_a:\n\t\t\t\tif k > a:\n\t\t\t\t\tinv_a += c_a[k]\n\n\t\t\tif a not in c_a:\n\t\t\t\tc_a[a] = 0\n\n\t\t\tc_a[a] += 1\n\n\t\tfor b in B:\n\t\t\tfor k in c_b:\n\t\t\t\tif k > b:\n\t\t\t\t\tinv_b += c_b[k]\n\n\t\t\tif b not in c_b:\n\t\t\t\tc_b[b] = 0\n\n\t\t\tc_b[b] += 1\n\n\t\tfor val in list(c_a.values()):\n\t\t\thas_multi = has_multi or (val > 1)\n\n\t\tif inv_a % 2 == inv_b % 2:\n\t\t\tans = True\n\n\t\telif has_multi:\n\t\t\tans = True\n\n\tif ans:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")\n", "for _ in range(int(input())):\n    n = int(input())\n    s1, s2 = input(), input()\n    a1, a2 = [0]*26, [0]*26\n    for v in map(ord, s1):\n        a1[v-97] += 1\n    for v in map(ord, s2):\n        a2[v-97] += 1\n    \n    if a1 != a2:\n        print('NO')\n        continue\n    if max(a1) > 1:\n        print('YES')\n        continue\n\n    inv1 = sum(c1 > c2 for i, c1 in enumerate(s1) for c2 in s1[i+1:])\n    inv2 = sum(c1 > c2 for i, c1 in enumerate(s2) for c2 in s2[i+1:])\n    print('YES' if inv1 % 2 == inv2 % 2 else 'NO')", "from collections import *\nf=lambda s:(Counter(s),len(set(s))==len(s)and sum(s[i]>s[j] for i in range(len(s))for j in range(i,len(s)))&1)\nfor _ in range(int(input())):\n    n,s,t=input(),input(),input()\n    print(\"YNEOS\"[f(s)!=f(t)::2])"]