["def solve(n):\n    print('starting with {0}'.format(n), flush=True)\n\n    def is_prime(p):\n        if p % 2 == 0 :\n            return False\n        for x in range(3,int(p**.5)):\n            if p % x == 0:\n                return False\n        return True\n        #return not any([p%x==0 for x in range(3,int(p**.5))])\n\n    if is_prime(n):\n        return n\n    step = (n%2) + 1\n    while 1:\n        if is_prime(n-step):\n            return n-step\n        elif is_prime(n+step):\n            return n+step\n        else:\n            step += 2\n    return None\n\n", "def isPrime(n): \n    if n < 2:\n        return False \n    for i in range(2,int(n**.5)+1): \n        if not n%i:\n            return False\n    return True \n\n\ndef solve(n): \n    if isPrime(n):\n        return n\n    add = 1\n    rem = 1 \n\n    ans = None \n    while True: \n        if isPrime(n+add):\n            ans = n+add \n        if isPrime(n-rem):\n            ans = n-rem\n        if ans != None:\n            return ans \n        add += 1\n        rem += 1", "is_prime = lambda n: n in (2, 3) or n > 3 and n % 2 and n % 3 and all(n % f and n % (f + 2) for f in range(5, int(n ** .5) + 1, 6))\nsolve = lambda n: next(p for gap in __import__('itertools').count(0) for p in (n - gap, n + gap) if is_prime(p))", "def solve(n):\n    i = 2\n    if n%2==0:\n        i = 1\n    if IsPrime(n):\n        return n\n    while True:\n        temp = n-i\n        if IsPrime(temp):\n            return temp\n        temp = n+i\n        if IsPrime(temp):\n            return temp\n        i+=2\n\ndef IsPrime(n):\n    if n %2 ==0:\n        return False\n    for i in range(3,int(n**0.5),2):\n        if n % i == 0:\n            return False\n    return True", "from math import sqrt\ndef solve(n):\n    \n    ls = []\n    \n    for i in range(n, n+300):\n        \n        temp = True\n        for j in range(2, int(sqrt(n)) + 10):\n            \n            if i % j == 0 and i != j:\n                temp = False\n                break\n        if temp: \n            ls.append(i)\n            break\n    \n    \n    for i in range(n - abs(n-ls[0]), n+1):\n        \n        temp = True\n        for j in range(2, int(sqrt(n)) + 10):\n            \n            if i % j == 0 and i != j:\n                temp = False\n                break\n        if temp: \n            ls.append(i)\n            \n    if len(ls) > 1:\n        return ls[-1]\n    return ls[0]", "from itertools import chain, count\n\n\ndef is_prime(n):\n    return n == 2 or (n > 2 and n % 2 and all(n % i for i in range(3, int(n**0.5)+1, 2)))\n\n\ndef solve(n):\n    deltas = chain([0], chain.from_iterable([-i, +i] for i in count(1)))\n    return next(n+delta for delta in deltas if is_prime(n+delta))", "from itertools import count\nfrom bisect import bisect_left as bisect\n\nn = 100005                                    # Sieve up to (10**10)**.5 + 5\nsieve, primes = [0]*((n>>1)+1), [2]           # optimized sieve (store only odd numbers\nfor i in range(3, n+1, 2):\n    if not sieve[i>>1]:\n        primes.append(i)\n        for j in range(i**2>>1, (n+1)>>1, i): sieve[j] = 1\n    \ndef solve(n):\n    if n%2 and n>>1 < len(sieve) and not sieve[n>>1]: return n                    # easy check: prime if sieve element is set to False\n    \n    idx = bisect(primes,n)                                                        # Insertion point of n in the prime list\n    return bigSearch(n, idx) if idx == len(primes) \\\n           else min( primes[max(0,idx-1):idx+2], key=lambda x: (abs(x-n), x))     # fast look up in the list of primes (check element before, under and after the insertion point)\n\ndef isPrime(n, iSq): return all(n%x for x in primes[:iSq])\n\ndef bigSearch(n, idx):\n    iSq = bisect(primes,n**.5,0,idx)                                              # insertion point of n**.5 in the prime list (for complex primality check)\n    isPair = not n%2\n    for x in count(0):\n        for c in [-1,1]:\n            p = n+c*(2*x + isPair)\n            if isPrime(p, iSq): return p\n"]