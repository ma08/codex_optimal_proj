["import numpy as np\n\ndef products(n, min_divisor, max_divisor):      \n    if n == 1:\n        yield []\n    for divisor in range(min_divisor, max_divisor+1):\n        if n % divisor == 0:\n            for product in products(n // divisor, divisor, max_divisor):\n                yield product + [divisor] \n\ndef eq_dice(set):\n    product = np.prod(set)\n    lista = list(products(product, 3, min(product-1, 20)))\n    return len(lista) - 1 if len(set) > 1 else len(lista)", "from functools import reduce\n\ndef getDivisors(n):\n    lst, p = [], 2\n    while n > 1:\n        while not n%p:\n            lst.append(p)\n            n //= p\n        p += 1 + (p!=2)\n    return lst\n    \n    \ndef eq_dice(diceSet):\n    events  = reduce(int.__mul__, diceSet)\n    lstDivs = getDivisors(events)\n    combos  = set(genCombDices(tuple(lstDivs), set()))\n    return len(combos - {tuple(sorted(diceSet))})\n\n            \ndef genCombDices(tup, seens):\n    \n    if tup[0] != 2: yield tup\n    \n    if len(tup) > 2:\n        for i,a in enumerate(tup):\n            for j,b in enumerate(tup[i+1:],i+1):\n                m = a*b\n                t = tuple(sorted(tup[:i] + tup[i+1:j] + tup[j+1:] + (m,)))\n                if m > 20 or t in seens: continue\n                seens.add(t)\n                yield from genCombDices(t, seens)", "from itertools import combinations_with_replacement\nfrom pprint import pprint\n\ndef multiples(f):\n    m = []\n    for i in range(2,8):\n        m.append(combinations_with_replacement(f,i))\n    return m\n    \ndef eq_dice(set_):\n    mul = 1\n    for e in set_:\n        mul *= e\n    facts = [x for x in range(3, 21) if not mul % x]\n    count = 0\n    for r in multiples(facts):\n        for m in r:\n            mu = 1\n            for e in m:\n                mu *= e\n            if mu == mul and set(m) != set(set_):\n                print(m)\n                count += 1\n    print(count)\n    return count", "from functools import reduce\n\ndef eq_dice(set_):\n    n = reduce(int.__mul__, [s for s in set_ if s not in (11, 13)])\n    stack = [[n, [s for s in set_ if s in (11, 13)]]]\n    result = set()\n    while stack:\n        n, status = stack.pop()\n        if (3 <= n <= 20) and (len(status) > 0):\n            result.add(tuple(sorted(status + [n])))\n        for i in range(3, min(20, int(n//3))+1):\n            if (n % i == 0) and (n // i >= 3):\n                stack.append([n//i, sorted(status + [i])])\n    result.discard(tuple(sorted(set_)))\n    return len(result)", "from math import floor, sqrt\nfrom numpy import prod\n\ndef f(n, l=3):\n    if n < l:\n        return\n    for p in range(l, min(floor(sqrt(n)) + 1, 21)):\n        if not n % p:\n            for l in f(n // p, p):\n                yield [p] + l\n    if n <= 20:\n        yield [n]\n\ndef eq_dice(l):\n    return sum(1 for l in f(prod(l)) if len(l) > 1) - (len(l) > 1)", "from functools import reduce\nfrom math import floor, sqrt\n\ndef f(n, l=3):\n    if n < l:\n        return\n    for p in range(l, min(floor(sqrt(n)) + 1, 21)):\n        if not n % p:\n            for l in f(n // p, p):\n                yield [p] + l\n    if n <= 20:\n        yield [n]\n\ndef eq_dice(l):\n    return sum(1 for l in f(reduce(lambda p, n: p * n, l, 1)) if len(l) > 1) - (len(l) > 1)", "def product (dice):return dice[int()]*product(dice[1:]) if len(dice)>1 else dice[int()]\ndef eq_dice(dice):return len(recursive(product(dice),[],[]))-1 if len(dice)>1 else len(recursive(product(dice),[],[]))\ndef recursive(num,x,y,dice=3):\n    if 3>num//3:return y\n    while dice<=num//dice and dice<21:\n        if num%dice==int():\n            if sorted(x+[dice,num//dice]) not in y and num//dice<21:\n                y.append(sorted(x+[dice,num//dice]))\n            y=recursive(num//dice,x+[dice],y)\n        dice+=1\n    return y", "from functools import reduce\ndef get_factors(m):\n    li, j = [], 2\n    while j * j <= m:\n        if m % j:\n            j += 1\n            continue\n        m //= j\n        li.append(j)\n    return li+([m] if m>1 else [])\n\ndef divide(arr, cache):\n    store = []\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            m = arr[:i] + arr[i + 1:j] + [arr[i] * arr[j]] + arr[j + 1:]\n            tp = tuple(sorted(m))\n            if m != arr and len(m)>1 and tp not in cache:\n                cache.add(tp)\n                store.extend([tp] + divide(m,cache))\n    return store\n\ndef eq_dice(arr):\n    m, arr = reduce(lambda x, y: x * y, arr), tuple(sorted(arr))\n    return sum(1 for i in set(divide(get_factors(m),set())) if i!=arr and all(2<k<21 for k in i))", "from itertools import combinations_with_replacement\nfrom numpy import prod\n\ndef eq_dice(set_):\n    lst = sorted(set_)\n    eq, dice, count = 0, [], prod(lst)\n    \n    for sides in range(3, 21):\n        if count % sides == 0: dice.append(sides)\n    \n    for num_dice in range(2, 8): \n        for c in combinations_with_replacement(dice, num_dice):\n            if prod(c) == count and sorted(c) != lst: eq += 1\n            \n    return eq"]