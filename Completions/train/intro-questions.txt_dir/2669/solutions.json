["from operator import mul\nfrom functools import reduce\n\ndef genSequence(n):\n    yield n\n    while True:\n        n += reduce(mul, [int(d) for d in str(n) if d != '0']) if n > 9 else n\n        yield n\n\ndef extract(seq, v):\n    return sorted(seq).index(v)\n\ndef convergence(n):\n    gen1, genN = genSequence(1), genSequence(n)\n    seq1, seqN = {next(gen1)}, {next(genN)}\n    while True:\n        a,b = next(gen1), next(genN)\n        seq1.add(a)\n        seqN.add(b)\n        if a in seqN: return extract(seqN, a)\n        if b in seq1: return extract(seqN, b)", "def next(base):\n    mul = 1\n    for c in str(base):\n        if c!=\"0\":\n            mul *= int(c)\n    return base + mul\n    \ndef convergence(n):\n    base = 1\n    test = n\n    count = 0\n    while test!=base:\n        if test > base:\n            base = next(base)\n        else:\n            test =next(test)\n            count +=1\n        print(str(base)+\" \"+str(test))\n    return count", "from functools import reduce\n\ndef calculate_next_el(prev_el):\n    if prev_el < 10:\n        return 2 * prev_el\n    else:\n        multiplication = reduce((lambda x, y: x * y), [x for x in map(int, str(prev_el)) if x > 0], 1)\n        return prev_el + multiplication\n\ndef generate_series(start):\n    last = start\n    while True:\n        last = calculate_next_el(last)\n        yield last\n\ndef convergence(n):\n    current_base = 1\n    current_test = n\n    base_series = generate_series(current_base)\n    test_series = generate_series(current_test)\n    result = 0\n    while current_base != current_test:\n        if current_base < current_test:\n            current_base = base_series.__next__()\n        else:\n            current_test = test_series.__next__()\n            result += 1\n    return result\n", "def sumIntegers(n):\n    mod=10\n    lst=[]\n    while n>0:\n        lst.append(n%mod)\n        n-=n%mod\n        n//=10\n    result = 1\n    for i in lst:\n        if i!=0:\n            result*=i\n    return result\ndef convergence(n):\n    ntest=1\n    i=0\n    while True:\n        if ntest == n:\n            return i\n        elif n>ntest:\n            ntest = ntest + sumIntegers(ntest)\n        else:\n            n=n+sumIntegers(n)\n            i+=1\n        \n        \n        \n", "import numpy\nbase=[1]\ndef convergence(n):\n    test=[n]\n    while test[-1] not in base:\n        if base[-1]>test[-1]:test.append(test[-1]+int(numpy.prod([int(dig) for dig in str(test[-1]) if int(dig)!=int()])))\n        else:base.append(base[-1]+int(numpy.prod([int(dig) for dig in str(base[-1]) if int(dig)!=int()])))\n    return len(test)-1", "from functools import reduce\n\ndef convergence(n):\n    print(n)\n    t,r = [1],[n]\n    f = lambda x: x+reduce(lambda x,y:x*y, (int(i) for i in str(x) if i!='0'))\n    while r[-1] not in t:\n        for _ in range(25):\n            t += [f(t[-1])]\n        r += [f(r[-1])]\n    return len(r)-1", "from itertools import accumulate, repeat\nfrom functools import reduce\nfrom operator import mul\n\nvalue = lambda n: n + reduce(mul, filter(None, map(int, str(n))))\nserie = lambda *args: accumulate(repeat(*args), lambda x,_: value(x))\nbase = set(serie(1, 1000))\n\ndef convergence(n):\n    return next(i for i,x in enumerate(serie(n)) if x in base)", "from functools import reduce\nfrom itertools import count, islice\nfrom operator import mul\n\ndef gen(n):\n    yield n\n    while True:\n        n += n if n < 10 else reduce(mul, map(int, str(n).replace('0', '')), 1)\n        yield n\n\ndef convergence(n, base_series = set(islice(gen(1), 1000))):\n    it = gen(n)\n    return next(i for i in count() if next(it) in base_series)", "from operator import mul\nfrom functools import reduce\n\n# generate base series\nbase, n = {1}, 1\nfor _ in range(2000):\n    n += reduce(mul, map(int, str(n).replace(\"0\", \"\")))\n    base.add(n)\n\n\ndef convergence(n):\n    steps = 0\n    \n    while n not in base:\n        n += reduce(mul, map(int, str(n).replace(\"0\", \"\")))\n        steps += 1\n    \n    return steps", "from functools import reduce\ndef convergence(n):\n    j = 0\n    x = 1\n    s1 = set()\n    s2 = set()\n    while True:\n        s1.add(x)\n        s2.add(n)\n        if x in s2 or n in s1 or s1.intersection(s2):\n            break\n        if n < 10:\n            n = n + n\n        else:\n            n = n + reduce(lambda h,k: h*k, (int(i) for i in str(n) if i!=\"0\"))    \n        if x < 10:\n            x = x + x \n        else:\n            x = x + reduce(lambda h,k: h*k, (int(i) for i in str(x) if i!=\"0\"))\n    return sorted(list(s2)).index(list(s1.intersection(s2))[0])"]