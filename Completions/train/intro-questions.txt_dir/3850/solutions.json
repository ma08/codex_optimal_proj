["def close_to_zero(t):\n    if len(t)==0:\n        return (0)\n    x=t.split(\" \")\n    l=[]\n    poz=[]\n    neg=[]\n    for i in x:\n        l.append(int(i))\n    for i in l:\n        if i == 0:\n            return (0)\n        if i>0:\n            poz.append(i)\n        if i<0:\n            neg.append(i)\n        \n    if 0-min(poz)==max(neg):\n        return min(poz)\n    if 0-min(poz)>max(neg):\n        return min(poz)\n    else: return max(neg)\n", "def close_to_zero(t):\n    n = min([int(s) for s in t.split()] or [0], key = abs)\n    return abs(n) if str(-n) in t.split() else n", "def close_to_zero(t):\n    return min((int(n) for n in t.split()), key=lambda n: (abs(n), n < 0), default=0)", "def close_to_zero(t):\n    return sorted(map(int, t.split()), key=lambda i: (abs(i), -i))[0] if t else 0\n\n", "def close_to_zero(t):\n    T=[int(v) for v in t.split()]\n    return T and sorted(sorted(T,reverse=True),key=abs)[0] or 0", "def close_to_zero(t):\n    t = [int(x) for x in t.split()]\n    return min(t or [0],key=lambda t:(abs(t),-t))", "close_to_zero=lambda t:min(map(int,t.split()),key=lambda n:(abs(n),-n),default=0)", "def close_to_zero(t):\n    return 0 if not t else int(min(sorted(t.split(), reverse=True), key=lambda x: abs(int(x))))\n"]