["def p(t,k,n,l=1):\n    if t<l: pass\n    elif k==1 and t!=n: yield [t]\n    else: yield from ([m]+s for m in range(l,t-l+1) for s in p(t-m,k-1,n,m) if m!=n)\n\ndef part_const(t,k,n): return sum(1 for _ in p(t,k,n))", "def part_const(n, k, num):\n    return part(n, k) - part(n-(num or n), k-1)\n\ndef part(n, k):\n    return 1 if k in (1, n) else sum(part(n-k, i) for i in range(1, min(n-k, k)+1))", "def get_addends(num, x=1):\n  yield (num,)\n  for i in range(x, num//2 + 1):\n    for p in get_addends(num-i, i):\n      yield (i,) + p\n      \ndef part_const(n, k, num):\n  return len([el for el in get_addends(n) if len(el) == k and num not in el])", "def part_const(n, size, forbidden):\n\n    ways, k, partitions = [0, n] + [0] * (n - 1), 1, 0\n    while k:\n        x, y, k = ways[k-1] + 1, ways[k] - 1, k -1\n        while x <= y:\n            ways[k] = x\n            y, k = y - x, k + 1\n        ways[k] = x + y\n        if len(ways[:k + 1]) == size and forbidden not in ways[:k + 1]: partitions +=  1\n    return partitions", "def part_const(n, k, num):\n    return sum(1 for x in accel_asc(n) if len(x) == k and all(v != num for v in x))\n\n# http://jeromekelleher.net/tag/integer-partitions.html\ndef accel_asc(n):\n    a = [0 for i in range(n + 1)]\n    k = 1\n    y = n - 1\n    while k != 0:\n        x = a[k - 1] + 1\n        k -= 1\n        while 2 * x <= y:\n            a[k] = x\n            y -= x\n            k += 1\n        l = k + 1\n        while x <= y:\n            a[k] = x\n            a[l] = y\n            yield a[:k + 2]\n            x += 1\n            y -= 1\n        a[k] = x + y\n        y = x + y - 1\n        yield a[:k + 1]", "def part_const(n, k, num):\n    return len([x for x in list(accel_asc(n)) if len(x) == k and num not in x])\n    \ndef accel_asc(n):\n    a = [0 for i in range(n + 1)]\n    k = 1\n    y = n - 1\n    while k != 0:\n        x = a[k - 1] + 1\n        k -= 1\n        while 2*x <= y:\n            a[k] = x\n            y -= x\n            k += 1\n        l = k + 1\n        while x <= y:\n            a[k] = x\n            a[l] = y\n            yield a[:k + 2]\n            x += 1\n            y -= 1\n        a[k] = x + y\n        y = x + y - 1\n        yield a[:k + 1]", "def partition(n,parts,m=1):\n    if parts == 1:return [[n]]\n    ans = []\n    s = m\n    while s <= (n / parts):\n        l = [s]\n        p = partition(n - s,parts - 1,s)\n        for i in p:\n            ans += [l + i]\n        s += 1\n    return ans\n\ndef part_const(n, k, num):\n    p = partition(n,k)\n    return len([i for i in p if not num in i])", "part_const=p=lambda n,k,x,s=1:n!=x if k<2else sum(p(n-i,k-1,x,i)for i in range(s,n//k+1)if i!=x)", "def part_const(n, k, num):\n    return part(n, k) - (part(n-num, k-1) if num else 0)\n\ndef part(n, k):\n    return 0 if k > n else 1 if k in {1, n} else sum(part(n-k, i) for i in range(1, k+1))\n", "def part_const(n, k, num, s=0, startwith=1):\n    if k == 1:\n        if n - s >= startwith and n - s != num:\n            return 1\n        return 0\n    result = 0\n    for i in range(startwith, n - s - k + 2):\n        if i == num:\n            continue\n        result += part_const(n, k-1, num, s + i, i)\n    return result\n    \n"]