["def memorysize_conversion(memorysize):\n    [value, unit] = memorysize.split(\" \")\n    kibis = [\"KiB\", \"MiB\", \"GiB\", \"TiB\"]\n    kilos = [\"kB\", \"MB\", \"GB\", \"TB\"]\n    if unit in kibis:\n        return (str(round(float(value)*pow(1.024, kibis.index(unit)+1), 3))+\" \"+kilos[kibis.index(unit)])\n    else:\n        return (str(round(float(value)/pow(1.024, kilos.index(unit)+1), 3))+\" \"+kibis[kilos.index(unit)])", "CONV = {'KiB': 'kB', 'MiB': 'MB', 'GiB': 'GB', 'TiB': 'TB',\n        'kB': 'KiB', 'MB': 'MiB', 'GB': 'GiB', 'TB': 'TiB'}\n\ndef memorysize_conversion(size):\n    val, unit = size.split()\n    val = float(val)\n    p = 'KMGT'.index(unit[0].upper()) + 1\n    \n    r = 1.024 if 'i' in unit else 1 / 1.024\n    \n    return '%s %s' % (round(val * r ** p, 3), CONV[unit])", "def memorysize_conversion(size):\n    x, unit = size.upper().split()\n    x, (u, *i, _) = float(x), unit\n    op = float.__mul__ if i else float.__truediv__\n    p, conv = \"_KMGT\".index(u), f\"{u}{'' if i else 'i'}B\"\n    return f\"{round(op(x, 1.024**p), 3)} {conv}\".replace(\"KB\", \"kB\")", "v1, v2 = 1000/1024, 1024/1000\n\nD1 = {\"kB\":v1, \"MB\":v1**2, \"GB\":v1**3, \"TB\":v1**4,\n      \"KiB\":v2, \"MiB\":v2**2, \"GiB\":v2**3, \"TiB\":v2**4}\n      \nD2 = {\"kB\":\"KiB\", \"MB\":\"MiB\", \"GB\":\"GiB\", \"TB\":\"TiB\",\n      \"KiB\":\"kB\", \"MiB\":\"MB\", \"GiB\":\"GB\", \"TiB\":\"TB\"}\n\ndef memorysize_conversion(memorysize):\n    x, y = memorysize.split()\n    return f\"{round(float(x) * D1[y], 3)} {D2[y]}\"", "from decimal import Decimal, ROUND_HALF_UP\n\nunits = 'KMGT'\nq = Decimal('0.001')\n\ndef memorysize_conversion(memorysize):\n    n, unit = memorysize.split()\n    n = Decimal(n)\n    i = units.find(unit[0].upper()) + 1\n    if unit[1] == 'i':\n        n *= 1024 ** i\n        n /= 1000 ** i\n        new_unit = ['kB', 'MB', 'GB', 'TB'][i-1]\n    else:\n        n *= 1000 ** i\n        n /= 1024 ** i\n        new_unit = ['KiB', 'MiB', 'GiB', 'TiB'][i-1]\n    new_value = format(n.quantize(n, rounding=ROUND_HALF_UP), '.3f').rstrip('0.')\n    return f'{new_value} {new_unit}'", "kibi = ['KiB', 'MiB', 'GiB', 'TiB']\nsi = ['kB', 'MB', 'GB', 'TB']\n\ndef memorysize_conversion(size):\n    val, unit = size.split()\n    n = 'KMGT'.index(unit[0].upper())\n    \n    if unit in kibi:\n        return '%s %s' % (round(float(val) * 1.024 ** (n+1), 3), si[n])\n    else:\n        return '%s %s' % (round(float(val) / 1.024 ** (n+1), 3), kibi[n])", "d = {'KiB':1.024,'kB':0.9765625,'GiB':1.073741824,'GB':0.93132257461548,'MiB':1.048576,'MB':0.95367431640625,'TiB':1.099511627776,'TB':0.90949470177293}\nto = {'KiB':' kB','GiB':' GB','MiB':' MB','TiB':' TB','TB':' TiB','GB':' GiB','MB':' MiB','kB':' KiB'}\nmemorysize_conversion=lambda m:str(round(float(m.split()[0]) * d[m.split()[1]],3)) + to[m.split()[1]]", "d={'k':1,'m':2,'g':3,'t':4}\ndef memorysize_conversion(memorysize):\n    n,u=memorysize.split(' ')\n    n=float(n)\n    x=d[u[0].lower()]\n    if u[1]=='i':\n        n=round(n*(1.024**x),3)\n        return '{} {}{}'.format(n,u[0],u[2]).replace('K','k')\n    else:\n        n=round(n/(1.024**x),3)\n        return '{} {}i{}'.format(n,u[0].upper(),u[1])", "DCT_TO_IB = { unit: 1.024**p for unit,p in zip('KMGT',range(1,5)) }\n\ndef memorysize_conversion(s):\n    toB = s[-2]=='i'\n    v,u  = s.split()\n    unit = (u[0]!='K' and u[0] or 'k')+u[-1] if toB else  u[0].upper()+\"i\"+u[-1]\n    out  = float(v) * DCT_TO_IB[u[0].upper()]**(toB or -1)\n    out  = f'{ out :.3f}'.rstrip('0')\n    return f'{out} {unit}'", "def memorysize_conversion(s):\n    a, b = s.split()\n    n, m, i = (1024, 1000, \"\") if \"i\" in b else (1000, 1024, \"i\")\n    p = \" KMGT\".index(b[0].upper())\n    return f\"{round(float(a) * n**p / m**p, 3)} {'k' if b[0] == 'K' else b[0].upper()}{i}B\""]