["def pascal(p):\n    triangle = [[1]]\n    for _ in range(p - 1):\n        to_sum = list(zip([0] + triangle[-1], triangle[-1] + [0]))\n        triangle.append(list(map(sum, to_sum)))\n    return triangle\n", "def pascal(p):\n    def create_row(n):\n        row = [1]\n        for k in range(n):\n            row.append(row[k] * (n-k) / (k+1))\n        return row\n    tri = []\n    for row in range(p):\n        tri.append(create_row(row))\n    return tri\n", "def pascal(p):\n\n    t = [[1]]\n\n    for _ in range(2, p + 1):\n        t.append([1] + [a + b for a, b in zip(t[-1][:-1], t[-1][1:])] + [1])\n\n    return t", "def pascal(p):\n    ans = []\n    for i in range(p):\n        row = []\n        for k in range(i + 1):\n            if k == 0 or k == i:\n                row.append(1)\n            else:\n                row.append(ans[i - 1][k - 1] + ans[i - 1][k])\n            \n        ans.append(row)\n    return ans", "from math import factorial\ndef pascal(p):\n    return [[int((factorial(p)/(factorial(k)*factorial(p-k)))) for k in range(0,p+1)] for p in range(0,p)]", "def pascal(p):\n    if p == 1: return [[1]]\n    output = [[1],[1,1]]\n    last = [1,1]\n    count = 2\n    while count < p:\n        new = []\n        new.append(1)\n        for i in range(count-1):\n            new.append(last[i]+last[i+1])\n        new.append(1)\n        output.append(new)\n        last = new\n        count += 1\n    return output", "def pascal(p):\n    row, res = [1], []\n    for x in range(max(p, 0)):\n        res.append(row)\n        row = [l + r for l, r in zip(row + [0], [0] + row)]\n    return res", "def pascal(p):\n    l = [[1]]\n    for index in range(p-1):\n        values = []\n        for i,j in enumerate(l[index][:-1]):\n            values.append(j+l[index][i+1])\n        l.append(l[index][:1] + values + l[index][-1:])\n    return l"]