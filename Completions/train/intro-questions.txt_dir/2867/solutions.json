["from collections import defaultdict\n\ndef fix_progression(arr):\n    res = 0\n    for i in range(len(arr)):\n        D = defaultdict(int)\n        for j in range(i):\n            q, r = divmod(arr[i]-arr[j], i-j)\n            if not r:\n                D[q] += 1\n                res = max(res, D[q])\n    return len(arr)-res-1", "from collections import defaultdict\nfrom itertools import combinations\n\n\ndef lineEq(x,a,y,b):\n    slope = (b-a)/(y-x)\n    ordo  = a - slope * x\n    return (slope,ordo), not slope%1\n\n\ndef fix_progression(arr):\n    \n    c = defaultdict(set)\n    for (x,a),(y,b) in combinations(enumerate(arr), 2):\n        tup, isIntSlope = lineEq(x,a,y,b)\n        if isIntSlope: c[tup] |= {x,y}\n    \n    return len(arr) - max(map(len, c.values()))", "def fix_progression(arr):\n    best = len(arr)\n    s = sum(arr) / len(arr)\n    for start in range(len(arr)-1):\n        for idx in range(start+1, len(arr)):\n            count = 0\n            d = (arr[idx] - arr[start]) // (idx - start)\n            for i in range(0, start):\n                if arr[i] != arr[start] - d*(start-i):\n                    count += 1\n            for i in range(start+1, len(arr)):\n                if arr[i] != arr[start] + d*(i-start):\n                    count += 1\n            best = min(best, count)\n    return best\n", "def fix_progression(arr):\n    n, r = len(arr), float('inf')\n    for i in range(n - 1):\n        x = arr[i]\n        for j in range(i + 1, n):\n            d = arr[j] - arr[i]\n            if d % (j - i):\n                continue\n            d //= j - i\n            x0 = x - i * d\n            diff = sum(arr[k] != x0 + k * d for k in range(n))\n            r = min(r, diff)\n            if r <= 1:\n                return r\n    return r", "from collections import defaultdict\n\ndef fix_progression(arr):\n    \n    global_max = 1\n    \n    for i, ele in enumerate(arr):\n        \n        maxi = 1\n        things = defaultdict(lambda: 1) #dictionary to store the first and last elements of progression including arr[i]\n        \n        for j in range(i+1, len(arr)):\n            \n            comp = arr[j]\n            diff = (comp - ele)/(j-i) #would be arithmetic progression constant between arr[i] and arr[j]\n                \n            if diff.is_integer():\n                \n                #calculate the first and last elements of the \"would be\" arithmetic progression\n                \n                left = ele - diff*i\n                right = ele + diff*(len(arr) - i - 1)\n                \n                # if the same left and right exist already, that means the current left, right pair is the same\n                #as a arithmetic progression seen for arr[i], meaning we have += 1 points sharing the arithmetic progression\n                #eg [1, 10, 2, 12, 3, 14]. the pair 10,12 and 10,14 have the same left and right points, meaning they \n                # are collinear and so thats one less point which we need to change in order to make arithmetic prog.\n                \n                things[(left, right)] += 1 \n                maxi = max(maxi, things[(left, right)])\n                global_max = max(maxi, global_max)\n    \n    return len(arr) - global_max\n", "def fix_progression(arr):\n  best = len(arr)-2\n  for i in range(len(arr)-1):\n      for j in range(i+1,len(arr)):\n          if (arr[j]-arr[i])%(j-i)!=0:\n              continue\n          step = (arr[j]-arr[i])//(j-i)\n          wrongs = sum(1 for k in range(len(arr)) if arr[k]!=arr[i]+(k-i)*step)\n          best = min(wrongs, best)\n          if best<i-2:\n              break\n  return best", "def fix_progression(arr):\n    min_c=len(arr)\n    for i in range(len(arr)-1):\n        for j in range(i+1,len(arr)):\n            if (arr[j]-arr[i])%(j-i)!=0:\n                continue\n            a=(arr[j]-arr[i])//(j-i)\n            c=0\n            for k in range(len(arr)):\n               if arr[i]+(k-i)*a!=arr[k]:\n                   c+=1\n            if c<min_c:\n                min_c=c\n    return min_c", "from itertools import combinations\n\ndef fix_progression(arr):\n    ans = len(arr) - 1\n    for l, r in combinations(range(len(arr)), 2):\n        step = (arr[r] - arr[l]) / (r - l)\n        if step.is_integer():\n            step = int(step)\n            changed = sum(a != i for i, a in zip(range(arr[l]-step*l, 10**10*step, step), arr)) if step else sum(a != arr[l] for a in arr)\n            ans = min(ans, changed)\n    return ans", "from collections import Counter\ndef fix_progression(arr):\n    lst = []\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[j]-arr[i])%(j-i) == 0:\n                dif = (arr[j]-arr[i])//(j-i)\n                s = arr[i] - i*dif\n                lst.append((s, dif))\n    c = Counter(lst).most_common()[0]\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] != c[0][0] + i*c[0][1]:\n            count += 1\n    return count", "from collections import Counter\n\ndef fix_progression(arr):\n  params = Counter()\n  for i in range(len(arr)):\n      for j in range(i+1, len(arr)):\n          if (arr[j] - arr[i]) % (j - i) == 0:\n              d = (arr[j] - arr[i]) // (j - i)\n              s = arr[i] - i*d\n              params[(s,d)] += 1\n              \n  start, diff = params.most_common(1)[0][0]\n  \n  count = 0\n  for i in range(len(arr)):\n      if arr[i] != start + i * diff:\n          count += 1\n  return count\n"]