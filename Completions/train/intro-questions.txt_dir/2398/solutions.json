["import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef maketo():\n    atoi=[[] for _ in range(n)]\n    for i,a in enumerate(aa):\n        if a<1 or a>n:return True\n        atoi[a-1].append(i)\n        if len(atoi[a-1])>2:return True\n    for a in range(n):\n        u,v=atoi[a]\n        if u+n==v:continue\n        to[u].append((v+n)%(n*2))\n        to[v].append((u+n)%(n*2))\n    return False\n\ndef dfs(u):\n    flap[u%n]=(u>=n)*1\n    cur[u>=n].append(u%n+1)\n    stack=[u]\n    while stack:\n        u=stack.pop()\n        for v in to[u]:\n            if flap[v%n]==-1:\n                flap[v % n]=(v>=n)*1\n                cur[v >= n].append(v % n+1)\n                stack.append(v)\n            elif flap[v % n]!=(v>=n)*1:return True\n    return False\n\nfor _ in range(II()):\n    n=II()\n    aa=LI()+LI()\n    to=[[] for _ in range(n*2)]\n\n    if maketo():\n        print(-1)\n        continue\n    #print(to)\n\n    ans = []\n    flap=[-1]*n\n    ng=False\n    for u in range(n):\n        #u+=n\n        if flap[u%n]!=-1:continue\n        cur=[[],[]]\n        ng=dfs(u)\n        if len(cur[0])<len(cur[1]):ans+=cur[0]\n        else:ans+=cur[1]\n        #print(u,flap,cur,ans)\n        if ng:break\n\n    if ng:print(-1)\n    else:\n        print(len(ans))\n        print(*ans)\n", "import sys\nfrom collections import deque\n\ninput=sys.stdin.readline\n#sys.setrecursionlimit(2*10**5)\n\nfor _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    b=list(map(int,input().split()))\n    data=[[] for i in range(n)]\n    for i in range(n):\n        data[a[i]-1].append(i)\n        data[b[i]-1].append(i)\n    for i in range(n):\n        if len(data[i])!=2:\n            print(-1)\n            break\n    else:\n        edge=[[] for i in range(n)]\n        for i in range(n):\n            u,v=data[i][0],data[i][1]\n            edge[u].append((v,i))\n            edge[v].append((u,i))\n\n        seen=[False]*n\n        temp=[]\n        res=0\n        def dfs(v,cond):\n            nonlocal temp,res\n            res.append(v)\n            if cond==1:\n                up,down=a[v],b[v]\n            else:\n                up,down=b[v],a[v]\n\n            for nv,val in edge[v]:\n                if not seen[nv]:\n                    seen[nv]=True\n                    if a[nv]==up or b[nv]==down:\n                        temp.append(nv)\n                        dfs(nv,-1)\n                    else:\n                        dfs(nv,1)\n\n        def bfs(i):\n            nonlocal temp,res\n            deq=deque([(i,1)])\n            while deq:\n                v,cond=deq.popleft()\n                res.append(v)\n                if cond==1:\n                    up,down=a[v],b[v]\n                else:\n                    up,down=b[v],a[v]\n\n                for nv,val in edge[v]:\n                    if not seen[nv]:\n                        seen[nv]=True\n                        if a[nv]==up or b[nv]==down:\n                            temp.append(nv)\n                            deq.append((nv,-1))\n                        else:\n                            deq.append((nv,1))\n\n        ans=[]\n        for i in range(0,n):\n            if not seen[i]:\n                res=[]\n                temp=[]\n                seen[i]=True\n                bfs(i)\n                if len(res)-len(temp)>=len(temp):\n                    ans+=temp\n                else:\n                    temp=set(temp)\n                    for v in res:\n                        if v not in temp:\n                            ans.append(v)\n        if ans:\n            ans=[ans[i]+1 for i in range(len(ans))]\n        print(len(ans))\n        print(*ans)\n", "from sys import stdin, setrecursionlimit\nfrom collections import deque\ninput = stdin.readline\nsetrecursionlimit(int(2e5))\ndef getstr(): return input()[:-1]\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\ndef getint1(): return list([int(x) - 1 for x in input().split()])\n\nadj = col = comp = []\ncnt0 = cnt1 = 0\n\ndef dfs(us, cs, cmp, n):\n    nonlocal adj, col, comp, cnt0, cnt1\n    stack = [(us, cs)]\n    inq = [False] * n\n    inq[us] = True\n    while len(stack) > 0:\n        u, c = stack.pop()\n        # print(u, c)\n        inq[u] = False\n        col[u] = c\n        if col[u] == 0: cnt0 += 1\n        else: cnt1 += 1\n        comp[u] = cmp\n        for v, ch in adj[u]:\n            if col[v] == -1 and not inq[v]:\n                inq[v] = True\n                stack.append((v, c ^ ch))\n    # print(col, comp)\n\ndef solve():\n    nonlocal adj, col, comp, cnt0, cnt1\n    n = getint()\n    a = []\n    pos = [[] for _ in range(n)]\n    adj = [[] for _ in range(n)]\n    for i in [0, 1]:\n        a.append(getint1())\n        for j, x in enumerate(a[i]):\n            pos[x].append(j)\n    for i, c in enumerate(pos):\n        if len(c) != 2:\n            print(\"-1\")\n            return\n        if c[0] == c[1]: \n            continue\n        r1 = int(a[0][c[0]] != i)\n        r2 = int(a[0][c[1]] != i)\n        adj[c[0]].append((c[1], int(r1 == r2)))\n        adj[c[1]].append((c[0], int(r1 == r2)))\n    # print(adj)\n    col = [-1] * n\n    comp = [-1] * n\n    colcnt = []\n    ans = cnt = 0\n    # cnt = 0\n    for i in range(n):\n        if col[i] == -1:\n            cnt0, cnt1 = 0, 0\n            dfs(i, 0, cnt, n)\n            cnt += 1\n            colcnt.append((cnt0, cnt1))\n            ans += min(cnt0, cnt1)\n    # print(colcnt)\n\n    print(ans)\n    alist = []\n    for i in range(n):\n        chz = int(colcnt[comp[i]][0] < colcnt[comp[i]][1])\n        if col[i] ^ chz:\n            alist.append(i + 1)\n    # print(len(alist))\n    print(*alist)\n\ndef __starting_point():\n    # solve()\n    # for t in range(getint()):\n    #     print(\"Case #{}: \".format(t + 1), end=\"\")\n    #     solve()\n    for _ in range(getint()):\n        solve()\n\n__starting_point()", "from sys import stdin, setrecursionlimit\nfrom collections import deque\ninput = stdin.readline\ndef getstr(): return input()[:-1]\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\ndef getint1(): return list([int(x) - 1 for x in input().split()])\n\nadj = col = comp = []\ncnt0 = cnt1 = 0\n\ndef dfs(us, cs, cmp, n):\n    nonlocal adj, col, comp, cnt0, cnt1\n    stack = [(us, cs)]\n    inq = [False] * n\n    inq[us] = True\n    while len(stack) > 0:\n        u, c = stack.pop()\n        # print(u, c)\n        inq[u] = False\n        col[u] = c\n        if col[u] == 0: cnt0 += 1\n        else: cnt1 += 1\n        comp[u] = cmp\n        for v, ch in adj[u]:\n            if col[v] == -1 and not inq[v]:\n                inq[v] = True\n                stack.append((v, c ^ ch))\n    # print(col, comp)\n\ndef solve():\n    nonlocal adj, col, comp, cnt0, cnt1\n    n = getint()\n    a = []\n    pos = [[] for _ in range(n)]\n    adj = [[] for _ in range(n)]\n    for i in [0, 1]:\n        a.append(getint1())\n        for j, x in enumerate(a[i]):\n            pos[x].append(j)\n    for i, c in enumerate(pos):\n        if len(c) != 2:\n            print(\"-1\")\n            return\n        if c[0] == c[1]: \n            continue\n        r1 = int(a[0][c[0]] != i)\n        r2 = int(a[0][c[1]] != i)\n        adj[c[0]].append((c[1], int(r1 == r2)))\n        adj[c[1]].append((c[0], int(r1 == r2)))\n    # print(adj)\n    col = [-1] * n\n    comp = [-1] * n\n    colcnt = []\n    ans = cnt = 0\n    # cnt = 0\n    for i in range(n):\n        if col[i] == -1:\n            cnt0, cnt1 = 0, 0\n            dfs(i, 0, cnt, n)\n            cnt += 1\n            colcnt.append((cnt0, cnt1))\n            ans += min(cnt0, cnt1)\n    # print(colcnt)\n\n    print(ans)\n    alist = []\n    for i in range(n):\n        chz = int(colcnt[comp[i]][0] < colcnt[comp[i]][1])\n        if col[i] ^ chz:\n            alist.append(i + 1)\n    # print(len(alist))\n    print(*alist)\n\ndef __starting_point():\n    # solve()\n    # for t in range(getint()):\n    #     print(\"Case #{}: \".format(t + 1), end=\"\")\n    #     solve()\n    for _ in range(getint()):\n        solve()\n\n__starting_point()", "import sys, math\nimport io, os\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n#from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write(' '.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\n#from decimal import Decimal\nfrom fractions import Fraction\n#sys.setrecursionlimit(100000)\nINF = float('inf')\nmod = int(1e9)+7\n\n\nfor t in range(int(data())):\n    n=int(data())\n    a1=mdata()\n    a2=mdata()\n    d=dd(int)\n    g=[[] for i in range(n+1)]\n    for i in range(n):\n        d[a1[i]] += 1\n        d[a2[i]] += 1\n        if a1[i]==a2[i]:\n            continue\n        g[a1[i]].append((a2[i],i+1,0))\n        g[a2[i]].append((a1[i],i+1,1))\n    if max(d.values())>2:\n        out(-1)\n        continue\n    vis=[0]*(n+1)\n    vis1=[0]*(n+1)\n    ans=[]\n    for i in range(1,n+1):\n        if vis[i]==0 and g[i]:\n            s=[[],[]]\n            vis[i]=1\n            s[g[i][0][2]].append(g[i][0][1])\n            s[1-g[i][1][2]].append(g[i][1][1])\n            vis[g[i][0][0]] = -1\n            vis[g[i][1][0]] = 1\n            vis1[g[i][0][1]] = 1\n            vis1[g[i][1][1]] = 1\n            q=[]\n            q.append(g[i][0][0])\n            q.append(g[i][1][0])\n            while q:\n                a=q.pop()\n                if vis[a]==1:\n                    for nei in g[a]:\n                        if vis1[nei[1]]==0:\n                            s[1-nei[2]].append(nei[1])\n                            vis[nei[0]] = -1\n                            vis1[nei[1]] = 1\n                            q.append(nei[0])\n                else:\n                    for nei in g[a]:\n                        if vis1[nei[1]]==0:\n                            s[1-nei[2]].append(nei[1])\n                            vis[nei[0]] = 1\n                            vis1[nei[1]] = 1\n                            q.append(nei[0])\n            if len(s[0])<len(s[1]):\n                ans+=s[0]\n            else:\n                ans+=s[1]\n    out(len(ans))\n    outl(ans)\n\n\n\n\n", "import sys, math\nimport io, os\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n#from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write(' '.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\n#from decimal import Decimal\nfrom fractions import Fraction\n#sys.setrecursionlimit(100000)\nINF = float('inf')\nmod = int(1e9)+7\n\n\nfor t in range(int(data())):\n    n=int(data())\n    a1=mdata()\n    a2=mdata()\n    d=dd(int)\n    g=[[] for i in range(n+1)]\n    for i in range(n):\n        d[a1[i]] += 1\n        d[a2[i]] += 1\n        if a1[i]==a2[i]:\n            continue\n        g[a1[i]].append((a2[i],i+1,0))\n        g[a2[i]].append((a1[i],i+1,1))\n    if max(d.values())>2:\n        out(-1)\n        continue\n    vis=[0]*(n+1)\n    vis1=[0]*(n+1)\n    ans=[]\n    for i in range(1,n+1):\n        if vis[i]==0 and g[i]:\n            s=[[],[]]\n            vis[i]=1\n            a,b=g[i][0],g[i][1]\n            s[a[2]].append(a[1])\n            s[1-b[2]].append(b[1])\n            vis[a[0]] = -1\n            vis[b[0]] = 1\n            vis1[a[1]] = 1\n            vis1[b[1]] = 1\n            q=[]\n            q.append(g[i][0][0])\n            q.append(g[i][1][0])\n            while q:\n                a=q.pop()\n                for nei in g[a]:\n                    if vis1[nei[1]]==0:\n                        s[1-nei[2]].append(nei[1])\n                        vis[nei[0]] = -1*vis[a]\n                        vis1[nei[1]] = 1\n                        q.append(nei[0])\n            if len(s[0])<len(s[1]):\n                ans+=s[0]\n            else:\n                ans+=s[1]\n    out(len(ans))\n    outl(ans)\n\n\n\n\n", "import sys\n# range = xrange\n# input = raw_input\ninp = [int(x) for x in sys.stdin.read().split()]\nii = 0\nout = []\ndef solve(n, A):\n    same = [-1]*(2 * n);pos = [-1] * n\n    for i in range(2 * n):\n        a = A[i]\n        if pos[a] == -1:\n        \tpos[a] = i\n        elif pos[a] == -2:\n        \treturn None\n        else:\n        \tp = pos[a]\n        \tpos[a] = -2\n        \tsame[p] = i\n        \tsame[i] = p    \n    ans = []\n    found = [0] * (2 * n)\n    for root in range(2 * n):\n        if found[root]:\n        \tcontinue        \n        count0 = []\n        count1 = []\n        node = root\n        while not found[node]:\n            found[node] = 1\n            found[same[node]] = 1            \n            if node & 1:\n            \tcount0.append(node >> 1)\n            else:\n            \tcount1.append(node >> 1)            \n            node = same[node ^ 1]\n        if len(count0) < len(count1):\n        \tans += count0\n        else:\n        \tans += count1\n    return ans\nt = inp[ii]\nii += 1\nfor _ in range(t):\n    n = inp[ii]\n    ii += 1\n    A = [x - 1 for x in inp[ii: ii + n]]\n    ii += n\n    B = [x - 1 for x in inp[ii: ii + n]]\n    ii += n    \n    A = [A[i >> 1] if i & 1 == 0 else B[i >> 1] for i in range(2 * n)]\n    ans = solve(n, A)\n    if ans is None:\n    \tout.append('-1')\n    else:\n    \tout.append(str(len(ans)))\n    \tout.append(' '.join(str(x + 1) for x in ans))\nprint('\\n'.join(out))"]