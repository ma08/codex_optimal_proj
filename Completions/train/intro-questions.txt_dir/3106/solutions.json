["# Stirling numbers of second kind\n# http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\n# S(n,k)=1/(k!)sum_(i=0)^k(-1)^i(k; i)(k-i)^n\nfrom math import factorial as fact\n\ndef combs_non_empty_boxes(n,k):\n    if k<0 or k>n: return 'It cannot be possible!'\n    return sum([1,-1][i%2]*(k-i)**n*fact(k)//(fact(k-i)*fact(i)) for i in range(k+1))//fact(k)", "MAX_BALL = 1+800\nDP = [[], [0,1]]\n\nfor _ in range(MAX_BALL):\n    lst = DP[-1] + [0]\n    DP.append([ v*i + lst[i-1] for i,v in enumerate(lst) ])\n\ndef combs_non_empty_boxes(n,k):\n    return \"It cannot be possible!\" if k>n else DP[n][k]", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fact(n):\n    return 1 if n < 2 else n * fact(n-1)\n\n@lru_cache(maxsize=None)\ndef comb(n, k):\n    return fact(n) // fact(k) // fact(n-k)\n\n# https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\ndef combs_non_empty_boxes(n, k):\n    if n == k: return 1\n    if n < k: return \"It cannot be possible!\"\n    return sum((1, -1)[i&1] * comb(k, i) * (k - i)**n for i in range(k+1)) // fact(k)", "stirling2 = [[1]]\ndef combs_non_empty_boxes(n, k):\n    for _ in range(len(stirling2), n + 1):\n        stirling2.append([a + r * b for r, (a, b) in\n            enumerate(zip([0] + stirling2[-1], stirling2[-1] + [0]))])\n    return stirling2[n][k] if k <= n else \"It cannot be possible!\"", "M = {}\ndef H(Q,S) :\n    if Q < S : return 0\n    if S < 2 : return 0 < S\n    if (Q,S) not in M : M[Q,S] = S * H(Q - 1,S) + H(Q - 1,S - 1)\n    return M[Q,S]\ncombs_non_empty_boxes = lambda Q,S : 'It cannot be possible!' if Q < S else H(Q,S)", "def combs_non_empty_boxes(n,k):\n    if n < k: return \"It cannot be possible!\"\n    if n == 0: return 0 if k == 0 else 1\n    S = [[0]*(n+1) for i in range(n+1)]\n    S[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            S[i][j] = S[i-1][j-1] + S[i-1][j]*j\n    return S[n][k]\n", "import sys\nsys.setrecursionlimit(10000)\n\n\ndef combs_non_empty_boxes(n,k):\n    if k > n: \n        return 'It cannot be possible!'\n    \n    return stirling(n, k)\n\ndef memoize(f): \n    memo = {}\n    def wrapping(*args): \n        if args not in memo:\n            memo[args] = f(*args)\n        return memo[args]\n    return wrapping\n\n@memoize\ndef stirling(n, k): \n    if n == 0 and k == 0: \n        return 1\n        \n    if n == 0 or k == 0: \n        return 0\n    \n    return k * stirling(n - 1, k) + stirling(n - 1, k - 1)  ", "def combs_non_empty_boxes(n,k):\n    if n<k:\n        return \"It cannot be possible!\"\n    else:\n        row = [1]+[0 for x in range(k)]\n        for i in range(1, n+1):\n            new = [0]\n            for j in range(1, k+1):\n                 stirling = j * row[j] + row[j-1]\n                 new.append(stirling)\n            row = new\n        return row[k]", "# particiok szama\ndef makec():\n  dp=[[-1]*801 for _ in range(801)]\n  for n in range(801):\n    dp[n][n]=1\n    dp[n][1]=1\n    dp[n][0]=0\n  def c(n,k):\n    if k>n: return 0\n    if dp[n][k]<0:\n      dp[n][k]=k*c(n-1,k)+c(n-1,k-1)\n    return dp[n][k]\n  return c\n\nc=makec()\n\ndef combs_non_empty_boxes(n,k):\n    if k>n: combs=\"It cannot be possible!\"\n    else: combs=c(n,k)\n    return combs"]