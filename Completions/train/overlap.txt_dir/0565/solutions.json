["def f(a,y,index,sorted_pos):\n #print(a,y,index,sorted_pos)\n n=len(a)\n low=0\n high=n-1\n L,R=0,0\n l,r=0,0\n while(low<=high):\n  mid=(low+high)//2\n  #print(low,high,mid)\n  if(a[mid]== y):\n   break\n  elif(mid > index[y]):\n   high=mid-1\n   L+=1\n   #print(\"L\")\n   if(a[mid] <y):\n    l+=1\n    #print(\" l \")\n  else:\n   low=mid+1\n   R+=1\n   #print(\"R\")\n   if(a[mid]>y):\n    r+=1\n    #print(\"r\")\n x=sorted_pos[y]\n #print(L,R,l,r,x,n-x-1)\n if(R>x or L> n-x-1):\n  print(\"-1\")\n else:\n  print(max(l,r))\n\n\ndef fun():\n test=int(input())\n for t in range(test):\n  n,q=list(map(int,input().split()))\n  arr=list(map(int,input().split()))\n  index= dict()\n  for i in range(n):\n   index[arr[i]]=i\n  sorted_pos=dict()\n  a=sorted(arr)\n  for i in range(n):\n   sorted_pos[a[i]]=i\n  for x in range(q):\n   y=int(input())\n   f(arr,y,index,sorted_pos)\n\nfun()\n\n", "from sys import stdin,stdout\nt=int(stdin.readline())\nwhile(t):\n n,q=list(map(int,stdin.readline().rstrip().split()))\n arr=list(map(int,stdin.readline().rstrip().split()))\n d={}\n d1={}\n a=arr.copy()\n a.sort()\n for i in range(n):\n  d1[a[i]]=i\n  d[arr[i]]=i\n while(q):\n  v=int(stdin.readline().rstrip())\n  index=d[v]\n  smaller=d1[v]\n  bigger=n-smaller-1\n  low,high=0,n-1\n  c1,c2=0,0\n  while(high>=low):\n   mid=(high+low)//2\n   if mid==index:\n    break\n   elif index>mid:\n    if arr[mid]>v:\n     c1+=1\n    else:\n     smaller-=1\n    low=mid+1\n   else:\n    if v>arr[mid]:\n     c2+=1\n    else:\n     bigger-=1\n    high=mid-1\n  if c2>c1:\n   if bigger>=(c2-c1):\n    print(c2)\n   else:\n    print(-1)\n  elif c1>c2:\n   if smaller>=(c1-c2):\n    print(c1)\n   else:\n    print(-1)\n  else:\n   print(c1)\n  q-=1\n t-=1\n\n", "def binarySearch(start, end, xindex,opList):\n if start <= end:\n  midindex = int((start+end)/2)\n  opList.append(midindex)\n  if xindex < midindex:\n   return binarySearch(start, midindex-1, xindex, opList)\n\n  elif xindex > midindex:\n   return binarySearch(midindex+1, end, xindex, opList)\n\n  else:\n   return opList\n\n\ndef counter(opList,a, x):\n small = 0\n big = 0\n rightSmall = 0\n rightBig = 0\n\n for i in range(len(opList)-1):\n  # print(\"for oplist[\",i,\"]=\",opList[i])\n  if opList[i] < opList[i+1]:\n   # print(\"traverse to right\")\n   if x < a[opList[i]]:\n    # print(\"x is small\")\n    small += 1\n   else:\n    rightSmall += 1\n  else:\n   # print(\"traverse to left\")\n   if x> a[opList[i]]:\n    # print(\"x is big\")\n    big += 1\n   else:\n    rightBig += 1\n flag = isBigSmallAvailable(small,big,x,a,rightBig,rightSmall)\n if flag:\n  total = small + big\n  total = total - min(small,big)\n  return total\n else:\n  return -1\n\n\ndef isBigSmallAvailable(small,big,x,a,rightBig,rightSmall):\n s = 0\n b = 0\n s = s - rightSmall\n b = b - rightBig\n length = len(a)\n for i in range(length):\n  if a[i] < x:\n   s += 1\n  if a[i] > x:\n   b += 1\n\n  if s >= small and b >= big:\n   return True\n return False\n\n\nt = int(input())\nfor z in range(t):\n l = list(map(int,input().split()))\n n = int(l[0])\n q = int(l[1])\n a = list(map(int,input().split()))\n for i in range(q):\n  x = int(input())\n  xindex = a.index(x)\n  opList = []\n  result = binarySearch(0, n-1, xindex, opList)\n  count = counter(opList, a, x)\n\n  # print(result)\n  print(count)\n  # else:\n  #     print(swapCount)\n", "def binarySearch(start, end, xindex,opList):\n if start <= end:\n  midindex = int((start+end)/2)\n\n  opList.append(midindex)\n  if xindex < midindex :\n   return binarySearch(start, midindex-1, xindex, opList)\n\n  elif xindex > midindex :\n   return binarySearch(midindex+1, end, xindex, opList)\n\n  else:\n   return opList\n\n\ndef counter(opList,a, x):\n small = 0\n big = 0\n rightSmall = 0\n rightBig = 0\n\n for i in range(len(opList)-1):\n  # print(\"for oplist[\",i,\"]=\",opList[i])\n  if opList[i] < opList[i+1]:\n   # print(\"traverse to right\")\n   if x < a[opList[i]]:\n    # print(\"x is small\")\n    small += 1\n   else:\n    rightSmall += 1\n  else:\n   # print(\"traverse to left\")\n   if x> a[opList[i]]:\n    # print(\"x is big\")\n    big += 1\n   else:\n    rightBig += 1\n flag = isBigSmallAvailable(small,big,x,a,rightBig,rightSmall)\n if flag:\n  total = small + big\n  total = total - min(small,big)\n  return total\n else:\n  return -1\n\n\ndef isBigSmallAvailable(small,big,x,a,rightBig,rightSmall):\n s = 0\n b = 0\n s = s - rightSmall\n b = b - rightBig\n length = len(a)\n for i in range(length):\n  if a[i] < x:\n   s += 1\n  if a[i] > x:\n   b += 1\n\n  if s >= small and b >= big:\n   return True\n # s = s - rightSmall\n # b = b - rightBig\n # print(\"big \",b)\n\n return False\n\n\nt = int(input())\nswapCount = 0\nswaped = []\nvisited = []\nfor z in range(t):\n l = list(map(int,input().split()))\n n = int(l[0])\n q = int(l[1])\n aa = list(map(int,input().split()))\n for i in range(q):\n  swapCount = 0\n  swaped.clear()\n  visited.clear()\n  a = aa[:]\n  # print(\"aa is\",aa)\n\n  x = int(input())\n  # a.sort()\n  xindex = a.index(x)\n  opList = []\n  result = binarySearch(0, n-1, xindex, opList)\n  count = counter(opList, a, x)\n\n  # print(result)\n  print(count)\n  # else:\n  #     print(swapCount)\n", "def binarySearch(start, end, xindex,opList):\n if start <= end:\n  midindex = int((start+end)/2)\n\n  opList.append(midindex)\n  if xindex < midindex :\n   return binarySearch(start, midindex-1, xindex, opList)\n\n  elif xindex > midindex :\n   return binarySearch(midindex+1, end, xindex, opList)\n\n  else:\n   return opList\n\n\ndef counter(opList,a, x):\n small = 0\n big = 0\n rightSmall = 0\n rightBig = 0\n\n for i in range(len(opList)-1):\n  # print(\"for oplist[\",i,\"]=\",opList[i])\n  if opList[i] < opList[i+1]:\n   # print(\"traverse to right\")\n   if x < a[opList[i]]:\n    # print(\"x is small\")\n    small += 1\n   else:\n    rightSmall += 1\n  else:\n   # print(\"traverse to left\")\n   if x> a[opList[i]]:\n    # print(\"x is big\")\n    big += 1\n   else:\n    rightBig += 1\n flag = isBigSmallAvailable(small,big,x,a,rightBig,rightSmall)\n if flag:\n  total = small + big\n  total = total - min(small,big)\n  return total\n else:\n  return -1\n\n\ndef isBigSmallAvailable(small,big,x,a,rightBig,rightSmall):\n s = 0\n b = 0\n length = len(a)\n for i in range(length):\n  if a[i] < x:\n   s += 1\n  if a[i] > x:\n   b += 1\n s = s - rightSmall\n b = b - rightBig\n # print(\"big \",b)\n if s>=small and b>=big:\n  return True\n return False\n\n\nt = int(input())\nswapCount = 0\nswaped = []\nvisited = []\nfor z in range(t):\n l = list(map(int,input().split()))\n n = int(l[0])\n q = int(l[1])\n aa = list(map(int,input().split()))\n for i in range(q):\n  swapCount = 0\n  swaped.clear()\n  visited.clear()\n  a = aa[:]\n  # print(\"aa is\",aa)\n\n  x = int(input())\n  # a.sort()\n  xindex = a.index(x)\n  opList = []\n  result = binarySearch(0, n-1, xindex, opList)\n  count = counter(opList, a, x)\n\n  # print(result)\n  print(count)\n  # else:\n  #     print(swapCount)\n", "def binarySearch(start, end, xindex,opList):\n if start <= end:\n  midindex = int((start+end)/2)\n\n  opList.append(midindex)\n  if xindex < midindex :\n   return binarySearch(start, midindex-1, xindex, opList)\n\n  elif xindex > midindex :\n   return binarySearch(midindex+1, end, xindex, opList)\n\n  else:\n   return opList\n\n\ndef counter(opList,a, x):\n small = 0\n big = 0\n rightSmall = 0\n rightBig = 0\n\n for i in range(len(opList)-1):\n  # print(\"for oplist[\",i,\"]=\",opList[i])\n  if opList[i] < opList[i+1]:\n   # print(\"traverse to right\")\n   if x < a[opList[i]]:\n    # print(\"x is small\")\n    small += 1\n   else:\n    rightSmall += 1\n  else:\n   # print(\"traverse to left\")\n   if x> a[opList[i]]:\n    # print(\"x is big\")\n    big += 1\n   else:\n    rightBig += 1\n flag = isBigSmallAvailable(small,big,x,a,rightBig,rightSmall)\n if flag:\n  total = small + big\n  total = total - min(small,big)\n  return total\n else:\n  return -1\n\n\ndef isBigSmallAvailable(small,big,x,a,rightBig,rightSmall):\n s = 0\n b = 0\n for i in range(len(a)):\n  if a[i] < x:\n   s += 1\n  if a[i] > x:\n   b += 1\n s = s - rightSmall\n b = b - rightBig\n # print(\"big \",b)\n if s>=small and b>=big:\n  return True\n return False\n\n\nt = int(input())\nswapCount = 0\nswaped = []\nvisited = []\nfor z in range(t):\n l = list(map(int,input().split()))\n n = int(l[0])\n q = int(l[1])\n aa = list(map(int,input().split()))\n for i in range(q):\n  swapCount = 0\n  swaped.clear()\n  visited.clear()\n  a = aa[:]\n  # print(\"aa is\",aa)\n\n  x = int(input())\n  # a.sort()\n  xindex = a.index(x)\n  opList = []\n  result = binarySearch(0, n-1, xindex, opList)\n  count = counter(opList, a, x)\n\n  # print(result)\n  print(count)\n  # else:\n  #     print(swapCount)\n", "for _ in range(int(input())):\n n,q=list(map(int,input().split()))\n l=[int(i) for i in input().split()]\n d={}\n ind={}\n for i in range(n):\n  ind[l[i]]=i \n #dup=l[:]\n dup=sorted(l)\n for i in range(n):\n  chote=i \n  bade=n-i-1 \n  d[dup[i]]=[chote,bade]\n for _ in range(q):\n  chotewale_swap=0 \n  badewale_swap=0\n  x=int(input())\n  #d1=d[x].copy()\n  d1={}\n  d1[0]=d[x][0]\n  d1[1]=d[x][1]\n  f=1\n  low=0\n  high=n-1 \n  while low<=high:\n   mid=(low+high)//2 \n   if ind[x]==mid:\n    break \n   elif ind[x]>mid and x>l[mid]:\n    if d1[0]==0:\n     f=-1 \n     break \n    d1[0]-=1 \n    low=mid+1\n   elif ind[x]>mid and x<l[mid]:\n    if d1[0]==0:\n     f=-1 \n     break \n    d1[0]-=1 \n    chotewale_swap+=1\n    low=mid+1\n   elif ind[x]<mid and x<l[mid]:\n    if d1[1]==-1:\n     f=-1 \n     break \n    d1[1]-=1 \n    high=mid-1\n   elif ind[x]<mid and x>l[mid]:\n    if d1[1]==0:\n     f=-1 \n     break \n    d1[1]-=1 \n    badewale_swap+=1 \n    high=mid-1 \n  if f==-1:\n   print(-1)\n  else:\n   print(max(chotewale_swap,badewale_swap))\n", "for _ in range(int(input())):\n n,q=list(map(int,input().split()))\n l=[int(i) for i in input().split()]\n d={}\n ind={}\n for i in range(n):\n  ind[l[i]]=i \n #dup=l[:]\n dup=sorted(l)\n for i in range(n):\n  chote=i \n  bade=n-i-1 \n  d[dup[i]]=[chote,bade]\n for _ in range(q):\n  chotewale_swap=0 \n  badewale_swap=0\n  x=int(input())\n  #d1=d[x].copy()\n  d1={}\n  d1[0]=d[x][0]\n  d1[1]=d[x][1]\n  f=1\n  low=0\n  high=n-1 \n  while low<=high:\n   mid=(low+high)//2 \n   if ind[x]==mid:\n    break \n   elif ind[x]>mid and x>l[mid]:\n    d1[0]-=1 \n    low=mid+1\n   elif ind[x]>mid and x<l[mid]:\n    if d1[0]==0:\n     f=-1 \n     break \n    d1[0]-=1 \n    chotewale_swap+=1\n    low=mid+1\n   elif ind[x]<mid and x<l[mid]:\n    d1[1]-=1 \n    high=mid-1\n   elif ind[x]<mid and x>l[mid]:\n    if d1[1]==0:\n     f=-1 \n     break \n    d1[1]-=1 \n    badewale_swap+=1 \n    high=mid-1 \n  if f==-1:\n   print(-1)\n  else:\n   print(max(chotewale_swap,badewale_swap))\n", "for _ in range(int(input())):\n n,q=list(map(int,input().split()))\n l=[int(i) for i in input().split()]\n d={}\n ind={}\n for i in range(n):\n  ind[l[i]]=i \n #dup=l[:]\n dup=sorted(l)\n for i in range(n):\n  chote=i \n  bade=n-i-1 \n  d[dup[i]]=[chote,bade]\n for _ in range(q):\n  chotewale_swap=0 \n  badewale_swap=0\n  x=int(input())\n  d1=d[x].copy()\n  f=1\n  low=0\n  high=n-1 \n  while low<=high:\n   mid=(low+high)//2 \n   if ind[x]==mid:\n    break \n   elif ind[x]>mid and x>l[mid]:\n    d1[0]-=1 \n    low=mid+1\n   elif ind[x]>mid and x<l[mid]:\n    if d1[0]==0:\n     f=-1 \n     break \n    d1[0]-=1 \n    chotewale_swap+=1\n    low=mid+1\n   elif ind[x]<mid and x<l[mid]:\n    d1[1]-=1 \n    high=mid-1\n   elif ind[x]<mid and x>l[mid]:\n    if d1[1]==0:\n     f=-1 \n     break \n    d1[1]-=1 \n    badewale_swap+=1 \n    high=mid-1 \n  if f==-1:\n   print(-1)\n  else:\n   print(max(chotewale_swap,badewale_swap))\n", "def f(a,y,index,sorted_pos):\n #print(a,y,index,sorted_pos)\n n=len(a)\n low=0\n high=n-1\n L,R=0,0\n l,r=0,0\n while(low<=high):\n  mid=(low+high)//2\n  #print(low,high,mid)\n  if(a[mid]== y):\n   break\n  elif(mid > index[y]):\n   high=mid-1\n   L+=1\n   #print(\"L\")\n   if(a[mid] <y):\n    l+=1\n    #print(\" l \")\n  else:\n   low=mid+1\n   R+=1\n   #print(\"R\")\n   if(a[mid]>y):\n    r+=1\n    #print(\"r\")\n x=sorted_pos[y]\n #print(L,R,l,r,x,n-x-1)\n if(R>x or L> n-x-1):\n  print(\"-1\")\n else:\n  print(max(l,r))\n\n\ndef fun():\n test=int(input())\n for t in range(test):\n  n,q=list(map(int,input().split()))\n  arr=list(map(int,input().split()))\n  index= dict()\n  for i in range(n):\n   index[arr[i]]=i\n  sorted_pos=dict()\n  a=sorted(arr)\n  for i in range(n):\n   sorted_pos[a[i]]=i\n  for x in range(q):\n   y=int(input())\n   f(arr,y,index,sorted_pos)\n\nfun()\n\n", "for _ in range(int(input())):\n n,q=list(map(int,input().split()))\n l=[int(i) for i in input().split()]\n d={}\n ind={}\n for i in range(n):\n  ind[l[i]]=i \n dup=l[:]\n dup=sorted(dup)\n for i in range(n):\n  chote=i \n  bade=n-i-1 \n  d[dup[i]]=[chote,bade]\n for _ in range(q):\n  chotewale_swap=0 \n  badewale_swap=0\n  x=int(input())\n  d1=d[x].copy()\n  f=1\n  low=0\n  high=n-1 \n  while low<=high:\n   mid=(low+high)//2 \n   if ind[x]==mid:\n    break \n   elif ind[x]>mid and x>l[mid]:\n    d1[0]-=1 \n    low=mid+1\n   elif ind[x]>mid and x<l[mid]:\n    if d1[0]==0:\n     f=-1 \n     break \n    d1[0]-=1 \n    chotewale_swap+=1\n    low=mid+1\n   elif ind[x]<mid and x<l[mid]:\n    d1[1]-=1 \n    high=mid-1\n   elif ind[x]<mid and x>l[mid]:\n    if d1[1]==0:\n     f=-1 \n     break \n    d1[1]-=1 \n    badewale_swap+=1 \n    high=mid-1 \n  if f==-1:\n   print(-1)\n  else:\n   print(max(chotewale_swap,badewale_swap))\n", "for _ in range(int(input())):\n n,q=list(map(int,input().split()))\n l=[int(i) for i in input().split()]\n d={}\n ind={}\n for i in range(n):\n  ind[l[i]]=i \n dup=l.copy()\n dup.sort()\n for i in range(n):\n  chote=i \n  bade=n-i-1 \n  d[dup[i]]=[chote,bade]\n for _ in range(q):\n  chotewale_swap=0 \n  badewale_swap=0\n  x=int(input())\n  d1=d[x].copy()\n  f=1\n  low=0\n  high=n-1 \n  while low<high:\n   mid=(low+high)//2 \n   if ind[x]==mid:\n    break \n   elif ind[x]>mid and x>l[mid]:\n    d1[0]-=1 \n    low=mid+1\n   elif ind[x]>mid and x<l[mid]:\n    if d1[0]==0:\n     f=-1 \n     break \n    d1[0]-=1 \n    chotewale_swap+=1\n    low=mid+1\n   elif ind[x]<mid and x<l[mid]:\n    d1[1]-=1 \n    high=mid-1\n   elif ind[x]<mid and x>l[mid]:\n    if d1[1]==0:\n     f=-1 \n     break \n    d1[1]-=1 \n    badewale_swap+=1 \n    high=mid-1 \n  if f==-1:\n   print(-1)\n  else:\n   print(max(chotewale_swap,badewale_swap))\n", "for _ in range(int(input())):\n n,q=list(map(int,input().split()))\n l=[int(i) for i in input().split()]\n d={}\n ind={}\n for i in range(n):\n  ind[l[i]]=i \n dup=l.copy()\n dup.sort()\n for i in range(n):\n  chote=i \n  bade=n-i-1 \n  d[dup[i]]=[chote,bade]\n for _ in range(q):\n  chotewale_swap=0 \n  badewale_swap=0\n  x=int(input())\n  d1=d[x].copy()\n  f=1\n  low=0\n  high=n-1 \n  while low<=high:\n   mid=(low+high)//2 \n   if ind[x]==mid:\n    break \n   elif ind[x]>mid and x>l[mid]:\n    d1[0]-=1 \n    low=mid+1\n   elif ind[x]>mid and x<l[mid]:\n    if d1[0]==0:\n     f=-1 \n     break \n    d1[0]-=1 \n    chotewale_swap+=1\n    low=mid+1\n   elif ind[x]<mid and x<l[mid]:\n    d1[1]-=1 \n    high=mid-1\n   elif ind[x]<mid and x>l[mid]:\n    if d1[1]==0:\n     f=-1 \n     break \n    d1[1]-=1 \n    badewale_swap+=1 \n    high=mid-1 \n  if f==-1:\n   print(-1)\n  else:\n   print(max(chotewale_swap,badewale_swap))\n", "t = int(input())\nwhile t > 0:\n t -= 1\n n, q = list(map(int, input().split()))\n arr = list(map(int, input().split()))\n tarr = sorted(arr)\n d = {}\n inddir = {}\n for i in range(len(arr)):\n  inddir[arr[i]] = i\n tarrlen = len(tarr)\n for i in range(len(tarr)):\n  d[tarr[i]] = [i, tarrlen - i - 1]\n for _ in range(q):\n  k = int(input())\n  find = inddir[k]\n  l, r = 1, tarrlen\n  gs=0\n  ls=0\n  sw = 0\n  tempc = d[k].copy()\n  while l <= r:\n   mid = (l + r) // 2\n   if mid - 1 == find:\n    break\n   elif mid - 1 < find:\n    if arr[mid - 1] < k:\n     if tempc[0] > 0:\n      tempc[0] -= 1\n     else:\n      sw = -1\n      break\n    else:\n     if tempc[0] > 0:\n      tempc[0] -= 1\n      sw += 1\n      ls+=1\n     else:\n      sw = -1\n      break\n    l = mid + 1\n   else:\n    if arr[mid - 1] > k:\n     if tempc[1] > 0:\n      tempc[1] -= 1\n     else:\n      sw = -1\n      break\n    else:\n     if tempc[1] > 0:\n      tempc[1] -= 1\n      sw += 1\n      gs+=1\n     else:\n      sw = -1\n      break\n    r = mid - 1\n  print(max(ls,gs) if sw!=-1 else -1)\n", "T=int(input())\nfor xs in range(T):\n N,Q=[int(o) for o in input().split()]\n a=[int(o) for o in input().split()]\n b=sorted(a)\n Di={} #Dictionary\n for i in range(len(a)):\n  Di[a[i]]=[i]\n for i in range(len(b)):\n  Di[b[i]].append(i) \n r=[]\n qu=[int(input()) for j in range(Q)]\n for q in qu:\n  low=1\n  high=N\n  ind=Di[q][0]+1\n  b=[]\n  f=[]\n  s=0\n  maxs=N-Di[q][1]-1\n  mins=N-maxs-1\n  while low<=high:   #Binary Search algorithm\n   mid=(low+high)//2\n   if mid==ind:\n    break\n   elif mid<ind:\n    low=mid+1\n    if a[mid-1]>q:\n     b.append(a[mid-1])\n    else:\n     mins-=1 \n   elif mid>ind:\n    high=mid-1\n    if a[mid-1]<q:\n     f.append(a[mid-1])\n    else:\n     maxs-=1\n  lenf=len(f)\n  lenb=len(b)\n  sw=min(lenf,lenb)\n  rs=max(lenf,lenb)-sw\n  mins,maxs=mins-sw,maxs-sw\n  ex=min(mins,maxs)\n  if ex<rs: \n   r.append(-1)\n   s=1\n  else:\n   sw+=rs # When ex>=rs\n  if not s:\n   r.append(sw) \n for ans in r:\n  print(ans) #Final"]