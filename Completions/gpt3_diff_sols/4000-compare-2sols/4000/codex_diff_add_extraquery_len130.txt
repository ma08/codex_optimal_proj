def get_distance(tree, root, node):
    dist = 0
    while node != root:
        dist += 1
        node = tree[node]
    return dist

def find_lca(tree, root, node1, node2):
    dist1 = get_distance(tree, root, node1)
    dist2 = get_distance(tree, root, node2)
    if dist1 < dist2:
        node1, node2 = node2, node1
        dist1, dist2 = dist2, dist1
    while dist1 > dist2:
        node1 = tree[node1]
        dist1 -= 1
    while node1 != node2:
        node1 = tree[node1]
        node2 = tree[node2]
    return node1

def solve(n, tree):
    root = 1
    tree = [0] + tree
    lca = [[0] * n for _ in range(n)]
    for i in range(1, n+1):
        for j in range(i+1, n+1):
            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)
    max_edges = 0
    best_nodes = (0, 0, 0)
    for i in range(1, n+1):
        for j in range(i+1, n+1):
            for k in range(j+1, n+1):
                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])
                if edges > max_edges:
                    max_edges = edges
                    best_nodes = (i, j, k)
    return max_edges, best_nodes

def codex():
    n = int(input())
    tree = [0] * n
    for _ in range(n-1):
        a, b = map(int, input().split())
        tree[b-1] = a
    max_edges, best_nodes = solve(n, tree)
    print(max_edges)
    print(*best_nodes)
    
import sys
input = sys.stdin.readline

NEGINF = -1000000


def gold():
    n = int(input())
    adj = [[] for i in range(n)]
    parent = [-1] * n

    visited = [False] * n
    for _ in range(n - 1):
        a, b = list(map(int, input().split()))
        adj[a - 1].append(b - 1)
        adj[b - 1].append(a - 1)

    tup = tuple()
    outs = [tup] * n
    q = [(0, 0)]

    while q:
        node, type = q.pop()
        if type == 0:
            visited[node] = True
            q.append((node, 1))
            for v in adj[node]:
                if not visited[v]:
                    parent[v] = node
                    q.append((v, 0))
        else:
            ones = [(0, node)]
            twos = []
            threes = []
            for v in adj[node]:
                if v != parent[node]:
                    a, b, c = outs[v]
                    ones.append((a[0] + 1, a[1], v))
                    twos.append((b[0] + 1, b[1], v))
                    threes.append(c)
            ones.sort(reverse = True)
            twos.sort(reverse = True)
            threes.sort(reverse = True)

            bestOne = (ones[0][0], ones[0][1])
            
            bestsTwo = [(NEGINF, (0, 0))]
            if len(twos) > 0:
                bestsTwo.append((twos[0][0], twos[0][1]))
            if len(ones) > 1:
                o1 = ones[0]
                o2 = ones[1]
                bestsTwo.append((o1[0] + o2[0], (o1[1], o2[1])))

            bestsThree = [(NEGINF, (0, 0, 0))]
            if len(threes) > 0:
                bestsThree.append(threes[0])
            if len(ones) > 2:
                o1 = ones[0]
                o2 = ones[1]
                o3 = ones[2]
                bestsThree.append((o1[0] + o2[0] + o3[0], (o1[1], o2[1], o3[1])))
            if len(twos) > 0:
                o1 = ones[0]
                t1 = twos[0]
                if o1[2] != t1[2]:
                    bestsThree.append((o1[0] + t1[0], (o1[1], t1[1][0], t1[1][1])))
                else:
                    if len(twos) > 1:
                        t2 = twos[1]
                        bestsThree.append((o1[0] + t2[0], (o1[1], t2[1][0], t2[1][1])))
                    if len(ones) > 1:
                        o2 = ones[1]
                        bestsThree.append((o2[0] + t1[0], (o2[1], t1[1][0], t1[1][1])))
                        

            outs[node] = (bestOne, max(bestsTwo), max(bestsThree))

    final = outs[0][2]
    print(final[0])
    print(' '.join([str(x + 1) for x in final[1]]))


"""
What are the differences between functions codex() and gold()? Compare and contrast, describe the differences and characterize the differences in syntax, structure, and performance.
"""

________

[Codex Output]


"""
The function codex() is a recursive function that uses a tree to find the longest path between three nodes. The function gold() is an iterative function that uses a graph to find the longest path between three nodes.

The function codex() uses a tree to find the longest path between three nodes. The function gold() uses a graph to find the longest path between three nodes.

The function codex() uses a tree to find the longest path between three nodes. The function gold() uses a graph to find the longest path between three nodes.

The function codex() uses a