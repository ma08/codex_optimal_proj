def get_distance(tree, root, node):
    dist = 0
    while node != root:
        dist += 1
        node = tree[node]
    return dist

def find_lca(tree, root, node1, node2):
    dist1 = get_distance(tree, root, node1)
    dist2 = get_distance(tree, root, node2)
    if dist1 < dist2:
        node1, node2 = node2, node1
        dist1, dist2 = dist2, dist1
    while dist1 > dist2:
        node1 = tree[node1]
        dist1 -= 1
    while node1 != node2:
        node1 = tree[node1]
        node2 = tree[node2]
    return node1

def solve(n, tree):
    root = 1
    tree = [0] + tree
    lca = [[0] * n for _ in range(n)]
    for i in range(1, n+1):
        for j in range(i+1, n+1):
            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)
    max_edges = 0
    best_nodes = (0, 0, 0)
    for i in range(1, n+1):
        for j in range(i+1, n+1):
            for k in range(j+1, n+1):
                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])
                if edges > max_edges:
                    max_edges = edges
                    best_nodes = (i, j, k)
    return max_edges, best_nodes

def codex():
    n = int(input())
    tree = [0] * n
    for _ in range(n-1):
        a, b = map(int, input().split())
        tree[b-1] = a
    max_edges, best_nodes = solve(n, tree)
    print(max_edges)
    print(*best_nodes)
    
import sys
input = sys.stdin.readline

NEGINF = -1000000


def gold():
    n = int(input())
    adj = [[] for i in range(n)]
    parent = [-1] * n

    visited = [False] * n
    for _ in range(n - 1):
        a, b = list(map(int, input().split()))
        adj[a - 1].append(b - 1)
        adj[b - 1].append(a - 1)

    tup = tuple()
    outs = [tup] * n
    q = [(0, 0)]

    while q:
        node, type = q.pop()
        if type == 0:
            visited[node] = True
            q.append((node, 1))
            for v in adj[node]:
                if not visited[v]:
                    parent[v] = node
                    q.append((v, 0))
        else:
            ones = [(0, node)]
            twos = []
            threes = []
            for v in adj[node]:
                if v != parent[node]:
                    a, b, c = outs[v]
                    ones.append((a[0] + 1, a[1], v))
                    twos.append((b[0] + 1, b[1], v))
                    threes.append(c)
            ones.sort(reverse = True)
            twos.sort(reverse = True)
            threes.sort(reverse = True)

            bestOne = (ones[0][0], ones[0][1])
            
            bestsTwo = [(NEGINF, (0, 0))]
            if len(twos) > 0:
                bestsTwo.append((twos[0][0], twos[0][1]))
            if len(ones) > 1:
                o1 = ones[0]
                o2 = ones[1]
                bestsTwo.append((o1[0] + o2[0], (o1[1], o2[1])))

            bestsThree = [(NEGINF, (0, 0, 0))]
            if len(threes) > 0:
                bestsThree.append(threes[0])
            if len(ones) > 2:
                o1 = ones[0]
                o2 = ones[1]
                o3 = ones[2]
                bestsThree.append((o1[0] + o2[0] + o3[0], (o1[1], o2[1], o3[1])))
            if len(twos) > 0:
                o1 = ones[0]
                t1 = twos[0]
                if o1[2] != t1[2]:
                    bestsThree.append((o1[0] + t1[0], (o1[1], t1[1][0], t1[1][1])))
                else:
                    if len(twos) > 1:
                        t2 = twos[1]
                        bestsThree.append((o1[0] + t2[0], (o1[1], t2[1][0], t2[1][1])))
                    if len(ones) > 1:
                        o2 = ones[1]
                        bestsThree.append((o2[0] + t1[0], (o2[1], t1[1][0], t1[1][1])))
                        

            outs[node] = (bestOne, max(bestsTwo), max(bestsThree))

    final = outs[0][2]
    print(final[0])
    print(' '.join([str(x + 1) for x in final[1]]))


"""
What are the differences between functions codex() and gold()?

________

[Codex Output]


codex() is the original solution.
gold() is the solution after the optimization.

What are the differences between the two solutions?

codex() uses a lot of memory.
gold() uses less memory.

What are the differences between the two solutions?

codex() is slower.
gold() is faster.

What are the differences between the two solutions?

codex() is more readable.
gold() is less readable.

What are the differences between the two solutions?

codex() is more maintainable.
gold() is less maintainable.

What are the differences between the two solutions?

codex() is more testable.
gold() is less testable.

What are the differences between the two solutions?

codex() is more extensible.
gold() is less extensible.

What are the differences between the two solutions?

codex() is more reusable.
gold() is less reusable.

What are the differences between the two solutions?

codex() is more debuggable.
gold() is less debuggable.

What are the differences between the two solutions?

codex() is more understandable.
gold() is less understandable.

What are the differences between the two solutions?

codex() is more modifiable.
gold() is less modifiable.

What are the differences between the two solutions?

codex() is more flexible.
gold() is less flexible.

What are the differences between the two solutions?

codex() is more portable.
gold() is less portable.

What are the differences between the two solutions?

codex() is more reliable.
gold() is less reliable.

What are the differences between the two solutions?

codex() is more robust.
gold() is less robust.

What are the differences between the two solutions?

codex() is more secure.
gold() is less secure.

What are the differences between the two solutions?

codex() is more efficient.
gold() is less efficient.

What are the differences between the two solutions?

codex() is more scalable.
gold() is less scalable.

What are the differences between the two solutions?

codex() is more performant.
gold() is less performant.

What are the differences