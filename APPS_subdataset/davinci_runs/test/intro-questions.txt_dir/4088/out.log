"""
Polycarp wrote on the board a string $s$ containing only lowercase Latin letters ('a'-'z'). This string is known for you and given in the input.

After that, he erased some letters from the string $s$, and he rewrote the remaining letters in any order. As a result, he got some new string $t$. You have to find it with some additional information.

Suppose that the string $t$ has length $m$ and the characters are numbered from left to right from $1$ to $m$. You are given a sequence of $m$ integers: $b_1, b_2, \ldots, b_m$, where $b_i$ is the sum of the distances $|i-j|$ from the index $i$ to all such indices $j$ that $t_j > t_i$ (consider that 'a'<'b'<...<'z'). In other words, to calculate $b_i$, Polycarp finds all such indices $j$ that the index $j$ contains a letter that is later in the alphabet than $t_i$ and sums all the values $|i-j|$.

For example, if $t$ = "abzb", then:  since $t_1$='a', all other indices contain letters which are later in the alphabet, that is: $b_1=|1-2|+|1-3|+|1-4|=1+2+3=6$;  since $t_2$='b', only the index $j=3$ contains the letter, which is later in the alphabet, that is: $b_2=|2-3|=1$;  since $t_3$='z', then there are no indexes $j$ such that $t_j>t_i$, thus $b_3=0$;  since $t_4$='b', only the index $j=3$ contains the letter, which is later in the alphabet, that is: $b_4=|4-3|=1$. 

Thus, if $t$ = "abzb", then $b=[6,1,0,1]$.

Given the string $s$ and the array $b$, find any possible string $t$ for which the following two requirements are fulfilled simultaneously:  $t$ is obtained from $s$ by erasing some letters (possibly zero) and then writing the rest in any order;  the array, constructed from the string $t$ according to the rules above, equals to the array $b$ specified in the input data. 


-----Input-----

The first line contains an integer $q$ ($1 \le q \le 100$) — the number of test cases in the test. Then $q$ test cases follow.

Each test case consists of three lines:  the first line contains string $s$, which has a length from $1$ to $50$ and consists of lowercase English letters;  the second line contains positive integer $m$ ($1 \le m \le |s|$), where $|s|$ is the length of the string $s$, and $m$ is the length of the array $b$;  the third line contains the integers $b_1, b_2, \dots, b_m$ ($0 \le b_i \le 1225$). 

It is guaranteed that in each test case an answer exists.


-----Output-----

Output $q$ lines: the $k$-th of them should contain the answer (string $t$) to the $k$-th test case. It is guaranteed that an answer to each test case exists. If there are several answers, output any.


-----Example-----
Input
4
abac
3
2 1 0
abc
1
0
abba
3
1 0 1
ecoosdcefr
10
38 13 24 14 11 5 3 24 17 0

Output
aac
b
aba
codeforces



-----Note-----

In the first test case, such strings $t$ are suitable: "aac', "aab".

In the second test case, such trings $t$ are suitable: "a", "b", "c".

In the third test case, only the string $t$ equals to "aba" is suitable, but the character 'b' can be from the second or third position.
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\n\ndef solve(s, b):\n    pos = []\n    for i in range(len(s)):\n        pos.append([s[i], b[i], i+1])\n    pos = sorted(pos)\n    res = \"\"\n    start = 0\n    end = len(s)-1\n    for i in range(len(s)):\n        if pos[i][1] == 0:\n            res += pos[i][0]\n            continue\n        if i == 0:\n            res += pos[i][0]\n            start = pos[i][2]\n            continue\n        if i == len(s)-1:\n            res += pos[i][0]\n            end = pos[i][2]\n            continue\n        if pos[i][1] > pos[i-1][1]:\n            res += pos[i][0]\n            start = pos[i][2]\n            continue\n        if pos[i][1] < pos[i-1][1]:\n            res += pos[i][0]\n            end = pos[i][2]\n            continue\n        if pos[i][1] == pos[i-1][1]:\n            if pos[i][2] < start:\n                res += pos[i][0]\n                start = pos[i][2]\n            elif pos[i][2] > end:\n                res += pos[i][0]\n                end = pos[i][2]\n            else:\n                res += pos[i][0]\n    return res\n\n\nif __name__ == \"__main__\":\n    q = int(input())\n    ans = []\n    for i in range(q):\n        s = input()\n        m = int(input())\n        b = list(map(int, input().split()))\n        ans.append(solve(s, b))\n    for i in range(q):\n        print(ans[i])"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef solve(s, m, b):\n\t\"\"\"\n\t>>> solve('abac', 3, [2, 1, 0])\n\t'aac'\n\t>>> solve('abc', 1, [0])\n\t'b'\n\t>>> solve('abba', 3, [1, 0, 1])\n\t'aba'\n\t>>> solve('ecoosdcefr', 10, [38, 13, 24, 14, 11, 5, 3, 24, 17, 0])\n\t'codeforces'\n\t\"\"\"\n\ts = list(s)\n\ts.sort()\n\tres = ''\n\n\tfor i, v in enumerate(b):\n\t\tidx, s = get_idx(s, v)\n\t\tres += s[idx]\n\t\tdel s[idx]\n\n\treturn res\n\ndef get_idx(s, b):\n\t\"\"\"\n\t>>> get_idx(['a', 'b', 'c'], 0)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 1)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 2)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 3)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 4)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 5)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 6)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 7)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 8)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 9)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 10)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 11)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 12)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 13)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 14)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 15)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 16)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 17)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 18)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 19)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 20)\n\t(2, ['a', 'b', 'c'])\n\t\"\"\"\n\tidx = b % len(s)\n\treturn idx, s\n\nif __name__ == '__main__':\n\tq = int(input())\n\tfor i in range(q):\n\t\ts = input()\n\t\tm = int(input())\n\t\tb = [int(x) for x in input().split()]\n\t\tprint(solve(s, m, b))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": ""
    }
  ],
  "created": 1648693844,
  "id": "cmpl-4res8gOqTN1R295YSYQaBOcI3ogvM",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\n\ndef solve(s, b):\n    pos = []\n    for i in range(len(s)):\n        pos.append([s[i], b[i], i+1])\n    pos = sorted(pos)\n    res = \"\"\n    start = 0\n    end = len(s)-1\n    for i in range(len(s)):\n        if pos[i][1] == 0:\n            res += pos[i][0]\n            continue\n        if i == 0:\n            res += pos[i][0]\n            start = pos[i][2]\n            continue\n        if i == len(s)-1:\n            res += pos[i][0]\n            end = pos[i][2]\n            continue\n        if pos[i][1] > pos[i-1][1]:\n            res += pos[i][0]\n            start = pos[i][2]\n            continue\n        if pos[i][1] < pos[i-1][1]:\n            res += pos[i][0]\n            end = pos[i][2]\n            continue\n        if pos[i][1] == pos[i-1][1]:\n            if pos[i][2] < start:\n                res += pos[i][0]\n                start = pos[i][2]\n            elif pos[i][2] > end:\n                res += pos[i][0]\n                end = pos[i][2]\n            else:\n                res += pos[i][0]\n    return res\n\n\nif __name__ == \"__main__\":\n    q = int(input())\n    ans = []\n    for i in range(q):\n        s = input()\n        m = int(input())\n        b = list(map(int, input().split()))\n        ans.append(solve(s, b))\n    for i in range(q):\n        print(ans[i])"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef solve(s, m, b):\n\t\"\"\"\n\t>>> solve('abac', 3, [2, 1, 0])\n\t'aac'\n\t>>> solve('abc', 1, [0])\n\t'b'\n\t>>> solve('abba', 3, [1, 0, 1])\n\t'aba'\n\t>>> solve('ecoosdcefr', 10, [38, 13, 24, 14, 11, 5, 3, 24, 17, 0])\n\t'codeforces'\n\t\"\"\"\n\ts = list(s)\n\ts.sort()\n\tres = ''\n\n\tfor i, v in enumerate(b):\n\t\tidx, s = get_idx(s, v)\n\t\tres += s[idx]\n\t\tdel s[idx]\n\n\treturn res\n\ndef get_idx(s, b):\n\t\"\"\"\n\t>>> get_idx(['a', 'b', 'c'], 0)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 1)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 2)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 3)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 4)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 5)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 6)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 7)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 8)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 9)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 10)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 11)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 12)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 13)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 14)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 15)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 16)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 17)\n\t(2, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 18)\n\t(0, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 19)\n\t(1, ['a', 'b', 'c'])\n\t>>> get_idx(['a', 'b', 'c'], 20)\n\t(2, ['a', 'b', 'c'])\n\t\"\"\"\n\tidx = b % len(s)\n\treturn idx, s\n\nif __name__ == '__main__':\n\tq = int(input())\n\tfor i in range(q):\n\t\ts = input()\n\t\tm = int(input())\n\t\tb = [int(x) for x in input().split()]\n\t\tprint(solve(s, m, b))"
}
REASON stop
2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": ""
}
REASON stop
