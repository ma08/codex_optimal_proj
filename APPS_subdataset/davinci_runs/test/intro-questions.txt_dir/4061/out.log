"""
The only difference between easy and hard versions is the length of the string.

You are given a string $s$ and a string $t$, both consisting only of lowercase Latin letters. It is guaranteed that $t$ can be obtained from $s$ by removing some (possibly, zero) number of characters (not necessary contiguous) from $s$ without changing order of remaining characters (in other words, it is guaranteed that $t$ is a subsequence of $s$).

For example, the strings "test", "tst", "tt", "et" and "" are subsequences of the string "test". But the strings "tset", "se", "contest" are not subsequences of the string "test".

You want to remove some substring (contiguous subsequence) from $s$ of maximum possible length such that after removing this substring $t$ will remain a subsequence of $s$.

If you want to remove the substring $s[l;r]$ then the string $s$ will be transformed to $s_1 s_2 \dots s_{l-1} s_{r+1} s_{r+2} \dots s_{|s|-1} s_{|s|}$ (where $|s|$ is the length of $s$).

Your task is to find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.


-----Input-----

The first line of the input contains one string $s$ consisting of at least $1$ and at most $2 \cdot 10^5$ lowercase Latin letters.

The second line of the input contains one string $t$ consisting of at least $1$ and at most $2 \cdot 10^5$ lowercase Latin letters.

It is guaranteed that $t$ is a subsequence of $s$.


-----Output-----

Print one integer â€” the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.


-----Examples-----
Input
bbaba
bb

Output
3

Input
baaba
ab

Output
2

Input
abcde
abcde

Output
0

Input
asdfasdf
fasd

Output
3
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef find_substring_length(s, t):\n    \"\"\"\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    \"\"\"\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord('a')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord('a')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord('a')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef subsequence(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n    return i == len(t)\n\ndef main():\n    s = input()\n    t = input()\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subsequence(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\nif __name__ == '__main__':\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\n\"\"\"\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a subsequence of s\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\"\"\"\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == '__main__':\n    main()"
    }
  ],
  "created": 1648693240,
  "id": "cmpl-4reiOsUyp7JRwwNIYPDdo0nHTggce",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef find_substring_length(s, t):\n    \"\"\"\n    Find the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n\n    Parameters\n    ----------\n    s : str\n        String $s$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n    t : str\n        String $t$ consisting of at least $1$ and at most $2 \\cdot 10^5$ lowercase Latin letters.\n\n    Returns\n    -------\n    int\n        The maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$.\n    \"\"\"\n\n    # Initialize:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = 0\n\n    # Initialize:\n    #   length of the current substring under consideration\n    curr_substring_length = 0\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    last_letter_indices = [-1] * 26\n\n    # Initialize:\n    #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n    #   (if the letter is not in $t$ then its index is -1)\n    last_letter_indices_in_t = [-1] * 26\n\n    for letter_index, letter in enumerate(s):\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length += 1\n\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        last_letter_indices[ord(letter) - ord('a')] = letter_index\n\n    for letter_index, letter in enumerate(t):\n        # Update:\n        #   list of indices of the letter in $t$ corresponding to the last letter of the current substring under consideration\n        #   (if the letter is not in $t$ then its index is -1)\n        last_letter_indices_in_t[ord(letter) - ord('a')] = letter_index\n\n    for letter_index in last_letter_indices_in_t:\n        # If the letter is not in $t$ then its index is -1\n        if letter_index == -1:\n            continue\n\n        # Update:\n        #   length of the current substring under consideration\n        curr_substring_length = max(curr_substring_length, letter_index - last_letter_indices[ord(t[letter_index]) - ord('a')])\n\n    # Update:\n    #   length of the maximum possible length of the substring you can remove so that $t$ is still a subsequence of $s$\n    max_substring_length = max(max_substring_length, len(s) - curr_substring_length)\n\n    return max_substring_length\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    print(find_substring_length(s, t))"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef subsequence(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n    return i == len(t)\n\ndef main():\n    s = input()\n    t = input()\n    i = 0\n    j = 0\n    best = 0\n    while True:\n        while j < len(s) and subsequence(s[i:j + 1], t):\n            best = max(best, j - i + 1)\n            j += 1\n        if j >= len(s):\n            break\n        i += 1\n        j = max(j, i)\n    print(len(s) - best)\n\nif __name__ == '__main__':\n    main()"
}
REASON stop
2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\n\"\"\"\nApproach:\n1. Find all the indices where the character in t is found in s\n2. Now, the elements between these indices(inclusive) should be removed, so that t is a subsequence of s\n3. Now, we need to find the maximum subarray sum(in this case it will be the maximum contiguous subsequence that can be removed)\n\"\"\"\n\ndef max_contiguous_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, len(arr)):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef main():\n    s = input().strip()\n    t = input().strip()\n    indices = []\n    for i in range(len(s)):\n        if s[i] == t[0]:\n            indices.append(i)\n    t = t[1:]\n    for c in t:\n        new_indices = []\n        for j in range(len(indices)):\n            for i in range(indices[j] + 1, len(s)):\n                if s[i] == c:\n                    new_indices.append(i)\n                    break\n        indices = new_indices\n    differences = []\n    for i in range(1, len(indices)):\n        differences.append(indices[i] - indices[i - 1])\n    print(max_contiguous_subarray_sum(differences))\n\nif __name__ == '__main__':\n    main()"
}
REASON stop
