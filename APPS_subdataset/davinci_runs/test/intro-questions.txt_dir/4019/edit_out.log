2022-03-30 21:01:05.691384 num operations 2
2022-03-30 21:01:05.691410 size on input set 1
2022-03-30 21:01:09.044555 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint(\"YES\")\n\n# Sort edges by lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done.\n# Otherwise, print the edge to the first vertex,\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove(edge_to_add)\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 1,
      "text": "\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint(\"YES\")\n\n# Sort edges by the lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done\n# Otherwise, print the edge to the first vertex\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove(edge_to_add)\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n"
    }
  ],
  "created": 1648688466,
  "object": "edit"
}
2022-03-30 21:01:09.044877 fix spelling mistakes 2 ['\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint("YES")\n\n# Sort edges by lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done.\n# Otherwise, print the edge to the first vertex,\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove(edge_to_add)\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n', '\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint("YES")\n\n# Sort edges by the lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done\n# Otherwise, print the edge to the first vertex\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove(edge_to_add)\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n']
2022-03-30 21:01:09.044921 size on output set 2
2022-03-30 21:01:09.044929 size on input set 2
2022-03-30 21:01:14.024478 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint(\"YES\")\n\n# Sort edges by the lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done\n# Otherwise, print the edge to the first vertex\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = [0, 0]\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = edge\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove(edge_to_add)\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 1,
      "text": "\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\n# Sort edges by the lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done\n# Otherwise, print the edge to the first vertex\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    print(\"YES\")\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    print(\"YES\")\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], edge[1]]\n            break\n    edges.remove(edge_to_add)\n    print(edge_to_add[0], edge_to_add[1])\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n"
    }
  ],
  "created": 1648688469,
  "object": "edit"
}
2022-03-30 21:01:14.024791 fix syntax errors 2 ['\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint("YES")\n\n# Sort edges by the lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done\n# Otherwise, print the edge to the first vertex\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = [0, 0]\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = edge\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove(edge_to_add)\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n', '\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\n# Sort edges by the lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done\n# Otherwise, print the edge to the first vertex\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    print("YES")\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    print("YES")\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], edge[1]]\n            break\n    edges.remove(edge_to_add)\n    print(edge_to_add[0], edge_to_add[1])\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n']
2022-03-30 21:01:17.077602 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint(\"YES\")\n\n# Sort edges by lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done.\n# Otherwise, print the edge to the first vertex,\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove([edge_to_add[0], edge_to_add[1]])\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 1,
      "text": "\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint(\"YES\")\n\n# Sort edges by lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done.\n# Otherwise, print the edge to the first vertex,\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove([edge_to_add[0], edge_to_add[1]])\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n"
    }
  ],
  "created": 1648688474,
  "object": "edit"
}
2022-03-30 21:01:17.077880 fix syntax errors 2 ['\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint("YES")\n\n# Sort edges by lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done.\n# Otherwise, print the edge to the first vertex,\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove([edge_to_add[0], edge_to_add[1]])\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n', '\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint("YES")\n\n# Sort edges by lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done.\n# Otherwise, print the edge to the first vertex,\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove([edge_to_add[0], edge_to_add[1]])\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])\n']
2022-03-30 21:01:17.077913 size on output set 3
2022-03-30 21:01:17.077926 num operations 2
2022-03-30 21:01:17.077933 size on input set 1
2022-03-30 21:01:20.397897 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d\n# if not, print NO\nif d > max(degrees):\n    print(\"NO\")\n    exit()\n\n# create list of vertices to visit and visited list\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint(\"YES\")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d at vertex 1\n# if not, print NO\nif d > max(degrees):\n    print(\"NO\")\n    exit()\n\n# create list of vertices to visit\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint(\"YES\")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n"
    }
  ],
  "created": 1648688477,
  "object": "edit"
}
2022-03-30 21:01:20.398085 fix spelling mistakes 2 ['\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d\n# if not, print NO\nif d > max(degrees):\n    print("NO")\n    exit()\n\n# create list of vertices to visit and visited list\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint("YES")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d at vertex 1\n# if not, print NO\nif d > max(degrees):\n    print("NO")\n    exit()\n\n# create list of vertices to visit\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint("YES")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n']
2022-03-30 21:01:20.398117 size on output set 2
2022-03-30 21:01:20.398121 size on input set 2
2022-03-30 21:01:23.245617 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d at vertex 1\n# if not, print NO\nif d > max(degrees):\n    print(\"NO\")\n    exit()\n\n# create list of vertices to visit\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint(\"YES\")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d at vertex 1\n# if not, print NO\nif d > max(degrees):\n    print(\"NO\")\n    exit()\n\n# create list of vertices to visit\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint(\"YES\")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v - 1] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n"
    }
  ],
  "created": 1648688480,
  "object": "edit"
}
2022-03-30 21:01:23.246119 fix syntax errors 2 ['\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d at vertex 1\n# if not, print NO\nif d > max(degrees):\n    print("NO")\n    exit()\n\n# create list of vertices to visit\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint("YES")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n', '\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d at vertex 1\n# if not, print NO\nif d > max(degrees):\n    print("NO")\n    exit()\n\n# create list of vertices to visit\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint("YES")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v - 1] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n']
2022-03-30 21:01:26.145603 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d\n# if not, print NO\nif d > max(degrees):\n    print(\"NO\")\n    exit()\n\n# create list of vertices to visit and visited list\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint(\"YES\")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v - 1] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d\n# if not, print NO\nif d > max(degrees):\n    print(\"NO\")\n    exit()\n\n# create list of vertices to visit and visited list\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint(\"YES\")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n"
    }
  ],
  "created": 1648688483,
  "object": "edit"
}
2022-03-30 21:01:26.145824 fix syntax errors 2 ['\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d\n# if not, print NO\nif d > max(degrees):\n    print("NO")\n    exit()\n\n# create list of vertices to visit and visited list\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint("YES")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v - 1] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n', '\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d\n# if not, print NO\nif d > max(degrees):\n    print("NO")\n    exit()\n\n# create list of vertices to visit and visited list\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint("YES")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])\n']
2022-03-30 21:01:26.145881 size on output set 4
