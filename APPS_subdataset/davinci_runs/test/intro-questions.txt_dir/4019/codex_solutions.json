["\n\nn, m, D = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edges.append([int(x) for x in input().split()])\n\nprint(\"YES\")\n\n# Sort edges by lowest vertex first\nedges.sort(key=lambda x: x[0])\n\n# Find the vertex with the lowest degree\n# If it is the first vertex, we are done\n# Otherwise, print the edge to the first vertex\n# and remove it from the list of edges\ndegrees = [0] * (n + 1)\nfor edge in edges:\n    degrees[edge[0]] += 1\n    degrees[edge[1]] += 1\nmin_degree = min(degrees[1:])\nif min_degree == D:\n    for edge in edges:\n        print(edge[0], edge[1])\nelse:\n    edge_to_add = None\n    for edge in edges:\n        if degrees[edge[0]] == min_degree:\n            edge_to_add = [edge[0], 1]\n            break\n    print(edge_to_add[0], edge_to_add[1])\n    edges.remove(edge_to_add)\n    degrees[edge_to_add[0]] -= 1\n    degrees[edge_to_add[1]] -= 1\n\n# Add the remaining edges to the tree\nfor edge in edges:\n    print(edge[0], edge[1])", "\n\nimport sys\nimport math\nfrom collections import defaultdict\n\n# n = num vertices\n# m = num edges\n# d = degree of vertex 1\nn, m, d = map(int, sys.stdin.readline().split())\n\n# create adjacency list\nadj_list = defaultdict(list)\nfor _ in range(m):\n    v1, v2 = map(int, sys.stdin.readline().split())\n    adj_list[v1].append(v2)\n    adj_list[v2].append(v1)\n\n# create list of degrees\ndegrees = [0] * n\nfor v in adj_list:\n    degrees[v - 1] = len(adj_list[v])\n\n# check if there exists a tree with degree d\n# if not, print NO\nif d > max(degrees):\n    print(\"NO\")\n    exit()\n\n# create list of vertices to visit\n# initialise visited list\nto_visit = [1]\nvisited = [False] * n\nvisited[0] = True\n\n# create list of edges in tree\ntree_edges = []\n\n# while there are still vertices to visit\nwhile to_visit:\n    # visit next vertex\n    v = to_visit.pop()\n    for n in adj_list[v]:\n        # if vertex is unvisited\n        if not visited[n - 1]:\n            # add edge to tree\n            tree_edges.append([v, n])\n            # add vertex to visit\n            to_visit.append(n)\n            # mark as visited\n            visited[n - 1] = True\n\n# print YES\nprint(\"YES\")\n\n# if degree of vertex 1 is not d\nif degrees[0] != d:\n    # find unvisited vertex\n    for v in range(1, n):\n        if not visited[v - 1]:\n            # add edge from vertex 1 to unvisited vertex\n            tree_edges.append([1, v + 1])\n            # print edge\n            print(1, v + 1)\n            # mark vertex as visited\n            visited[v] = True\n            # break\n            break\n\n# print tree edges\nfor edge in tree_edges:\n    print(edge[0], edge[1])"]