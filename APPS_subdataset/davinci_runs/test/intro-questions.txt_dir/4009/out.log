"""
You are given a huge decimal number consisting of $n$ digits. It is guaranteed that this number has no leading zeros. Each digit of this number is either 0 or 1.

You may perform several (possibly zero) operations with this number. During each operation you are allowed to change any digit of your number; you may change 0 to 1 or 1 to 0. It is possible that after some operation you can obtain a number with leading zeroes, but it does not matter for this problem.

You are also given two integers $0 \le y < x < n$. Your task is to calculate the minimum number of operations you should perform to obtain the number that has remainder $10^y$ modulo $10^x$. In other words, the obtained number should have remainder $10^y$ when divided by $10^x$.


-----Input-----

The first line of the input contains three integers $n, x, y$ ($0 \le y < x < n \le 2 \cdot 10^5$) — the length of the number and the integers $x$ and $y$, respectively.

The second line of the input contains one decimal number consisting of $n$ digits, each digit of this number is either 0 or 1. It is guaranteed that the first digit of the number is 1.


-----Output-----

Print one integer — the minimum number of operations you should perform to obtain the number having remainder $10^y$ modulo $10^x$. In other words, the obtained number should have remainder $10^y$ when divided by $10^x$.


-----Examples-----
Input
11 5 2
11010100101

Output
1

Input
11 5 1
11010100101

Output
3



-----Note-----

In the first example the number will be $11010100100$ after performing one operation. It has remainder $100$ modulo $100000$.

In the second example the number will be $11010100010$ after performing three operations. It has remainder $10$ modulo $100000$.
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\ndef main():\n    n, x, y = map(int, input().split())\n    num = input().strip()\n    mod_num = int(num[:x])\n    remainder = mod_num % (10**y)\n    if remainder == 0:\n        return 0\n    \n    ans = 0\n    for i in range(x - y):\n        if num[i] == '1':\n            ans += 1\n    for i in range(x - y, x):\n        if num[i] == '0':\n            ans += 1\n    return ans\n\n\nif __name__ == '__main__':\n    print(main())"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef main():\n    \"\"\"\n    This is the main function.\n\n    This function takes a number and a number of digits to get the remainder\n    of and returns the minimum number of operations to make the remainder of\n    the number the same as the remainder of the number of digits.\n\n    This function uses the following local variables:\n\n    n - number of digits in the number.\n    x - the first number for the remainder.\n    y - the second number for the remainder.\n    number - the number to get the remainder of.\n    remainder - the remainder of the number.\n    answer - the minimum number of operations required.\n    \"\"\"\n    n, x, y = [int(x) for x in input().split()]\n    number = input()\n    remainder = int(number[n - x:])\n    answer = 0\n\n    while remainder != int(str(10 ** y).ljust(x, '0')):\n        remainder = (remainder - 1) % 10 ** x\n        answer += 1\n\n    return answer\n\n\nif __name__ == \"__main__\":\n    print(main())"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nn, x, y = map(int, input().split())\nnumber = input()\n\nnumber = list(number)\n\nfor i in range(n-y-1, n):\n\tif number[i] == '0':\n\t\tnumber[i] = '1'\n\telse:\n\t\tnumber[i] = '0'\n\nprint(n-x-y)"
    }
  ],
  "created": 1648692024,
  "id": "cmpl-4reOmkXyPKfKQEVyNSPM80hWaSr1H",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\ndef main():\n    n, x, y = map(int, input().split())\n    num = input().strip()\n    mod_num = int(num[:x])\n    remainder = mod_num % (10**y)\n    if remainder == 0:\n        return 0\n    \n    ans = 0\n    for i in range(x - y):\n        if num[i] == '1':\n            ans += 1\n    for i in range(x - y, x):\n        if num[i] == '0':\n            ans += 1\n    return ans\n\n\nif __name__ == '__main__':\n    print(main())"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef main():\n    \"\"\"\n    This is the main function.\n\n    This function takes a number and a number of digits to get the remainder\n    of and returns the minimum number of operations to make the remainder of\n    the number the same as the remainder of the number of digits.\n\n    This function uses the following local variables:\n\n    n - number of digits in the number.\n    x - the first number for the remainder.\n    y - the second number for the remainder.\n    number - the number to get the remainder of.\n    remainder - the remainder of the number.\n    answer - the minimum number of operations required.\n    \"\"\"\n    n, x, y = [int(x) for x in input().split()]\n    number = input()\n    remainder = int(number[n - x:])\n    answer = 0\n\n    while remainder != int(str(10 ** y).ljust(x, '0')):\n        remainder = (remainder - 1) % 10 ** x\n        answer += 1\n\n    return answer\n\n\nif __name__ == \"__main__\":\n    print(main())"
}
REASON stop
2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nn, x, y = map(int, input().split())\nnumber = input()\n\nnumber = list(number)\n\nfor i in range(n-y-1, n):\n\tif number[i] == '0':\n\t\tnumber[i] = '1'\n\telse:\n\t\tnumber[i] = '0'\n\nprint(n-x-y)"
}
REASON stop
