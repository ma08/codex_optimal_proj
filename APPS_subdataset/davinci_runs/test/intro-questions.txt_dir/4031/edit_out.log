2022-03-30 21:06:32.446109 num operations 2
2022-03-30 21:06:32.446149 size on input set 1
2022-03-30 21:06:37.338879 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input())\n    s.sort(key=len)\n    for i in range(n):\n        for j in range(i+1,n):\n            if s[j].find(s[i]) == -1:\n                print(\"NO\")\n                return\n    print(\"YES\")\n    for i in s:\n        print(i)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input())\n    s.sort(key=len)\n    for i in range(n):\n        for j in range(i+1,n):\n            if s[j].find(s[i]) == -1:\n                print(\"NO\")\n                return\n    print(\"YES\")\n    for i in s:\n        print(i)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648688792,
  "object": "edit"
}
2022-03-30 21:06:37.339186 fix spelling mistakes 2 ['\n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input())\n    s.sort(key=len)\n    for i in range(n):\n        for j in range(i+1,n):\n            if s[j].find(s[i]) == -1:\n                print("NO")\n                return\n    print("YES")\n    for i in s:\n        print(i)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input())\n    s.sort(key=len)\n    for i in range(n):\n        for j in range(i+1,n):\n            if s[j].find(s[i]) == -1:\n                print("NO")\n                return\n    print("YES")\n    for i in s:\n        print(i)\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 21:06:37.339209 size on output set 1
2022-03-30 21:06:37.339219 size on input set 1
2022-03-30 21:06:40.217024 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input())\n    s.sort(key=len)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[j].find(s[i]) == -1:\n                print(\"NO\")\n                return\n    print(\"YES\")\n    for i in s:\n        print(i)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input())\n    s.sort(key=len)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[j].find(s[i]) == -1:\n                print(\"NO\")\n                return\n    print(\"YES\")\n    for i in s:\n        print(i)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648688797,
  "object": "edit"
}
2022-03-30 21:06:40.217403 fix syntax errors 2 ['\n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input())\n    s.sort(key=len)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[j].find(s[i]) == -1:\n                print("NO")\n                return\n    print("YES")\n    for i in s:\n        print(i)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef main():\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input())\n    s.sort(key=len)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[j].find(s[i]) == -1:\n                print("NO")\n                return\n    print("YES")\n    for i in s:\n        print(i)\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 21:06:40.217438 size on output set 1
2022-03-30 21:06:40.217457 num operations 2
2022-03-30 21:06:40.217464 size on input set 1
2022-03-30 21:06:44.302915 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n    \"\"\"Performs a depth-first search and returns a topological sort of the graph.\n    Raises an exception if the graph has a cycle.\n    \"\"\"\n    # A list to keep track of the visit status of nodes\n    visited = [False]*len(graph)\n    # A list to store the sorted elements\n    top_sort = []\n\n    # Function to perform DFS\n    def dfs(node):\n        # Mark the current node as visited\n        visited[node] = True\n        # Recur for all the vertices adjacent to this vertex\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        # Push current vertex to the stack which stores the result\n        top_sort.append(node)\n\n    # Call the recursive helper function to store Topological Sort starting from all vertices one by one\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n    \"\"\"Performs a depth-first search and returns a topological sort of the graph.\n    Raises an exception if the graph has a cycle.\n    \"\"\"\n    # A list to keep track of the visit status of nodes\n    visited = [False]*len(graph)\n    # A list to store the sorted elements\n    top_sort = []\n\n    # Function to perform DFS\n    def dfs(node):\n        # Mark the current node as visited\n        visited[node] = True\n        # Recur for all the vertices adjacent to this vertex\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        # Push current vertex to the stack which stores the result\n        top_sort.append(node)\n\n    # Call the recursive helper function to store topological sort starting from all vertices one by one\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648688800,
  "object": "edit"
}
2022-03-30 21:06:44.303184 fix spelling mistakes 2 ['\n\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n    """Performs a depth-first search and returns a topological sort of the graph.\n    Raises an exception if the graph has a cycle.\n    """\n    # A list to keep track of the visit status of nodes\n    visited = [False]*len(graph)\n    # A list to store the sorted elements\n    top_sort = []\n\n    # Function to perform DFS\n    def dfs(node):\n        # Mark the current node as visited\n        visited[node] = True\n        # Recur for all the vertices adjacent to this vertex\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        # Push current vertex to the stack which stores the result\n        top_sort.append(node)\n\n    # Call the recursive helper function to store Topological Sort starting from all vertices one by one\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print("NO")\n        return\n\n    print("YES")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == "__main__":\n    main()\n', '\n\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n    """Performs a depth-first search and returns a topological sort of the graph.\n    Raises an exception if the graph has a cycle.\n    """\n    # A list to keep track of the visit status of nodes\n    visited = [False]*len(graph)\n    # A list to store the sorted elements\n    top_sort = []\n\n    # Function to perform DFS\n    def dfs(node):\n        # Mark the current node as visited\n        visited[node] = True\n        # Recur for all the vertices adjacent to this vertex\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        # Push current vertex to the stack which stores the result\n        top_sort.append(node)\n\n    # Call the recursive helper function to store topological sort starting from all vertices one by one\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print("NO")\n        return\n\n    print("YES")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 21:06:44.303362 size on output set 2
2022-03-30 21:06:44.303369 size on input set 2
2022-03-30 21:06:50.625596 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n    visited = [False]*len(graph)\n    top_sort = []\n\n    def dfs(node):\n        visited[node] = True\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        top_sort.append(node)\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n    visited = [False]*len(graph)\n    top_sort = []\n\n    def dfs(node):\n        visited[node] = True\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        top_sort.append(node)\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648688804,
  "object": "edit"
}
2022-03-30 21:06:50.625878 fix syntax errors 2 ['\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n    visited = [False]*len(graph)\n    top_sort = []\n\n    def dfs(node):\n        visited[node] = True\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        top_sort.append(node)\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print("NO")\n        return\n\n    print("YES")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == "__main__":\n    main()\n', '\n\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n    visited = [False]*len(graph)\n    top_sort = []\n\n    def dfs(node):\n        visited[node] = True\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        top_sort.append(node)\n\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print("NO")\n        return\n\n    print("YES")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 21:07:11.679260 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n  \"\"\"Performs a depth-first search and returns a topological sort of the graph.\n  Raises an exception if the graph has a cycle.\n  \"\"\"\n  # A list to keep track of the visit status of nodes\n  visited = [False]*len(graph)\n  # A list to store the sorted elements\n  top_sort = []\n\n  # Function to perform DFS\n  def dfs(node):\n    # Mark the current node as visited\n    visited[node] = True\n    # Recur for all the vertices adjacent to this vertex\n    for n in graph[node]:\n      if not visited[n]:\n        dfs(n)\n    # Push current vertex to the stack which stores the result\n    top_sort.append(node)\n\n  # Call the recursive helper function to store topological sort starting from all vertices one by one\n  for node in range(len(graph)):\n    if not visited[node]:\n      dfs(node)\n\n  return top_sort[::-1]\n\n\ndef main():\n  n = int(input())\n  words = [input() for _ in range(n)]\n\n  graph = defaultdict(list)\n  for i, word in enumerate(words):\n    for j, other in enumerate(words):\n      if i == j:\n        continue\n      if word in other:\n        graph[i].append(j)\n\n  try:\n    top_sort = dfs_topsort(graph)\n  except:\n    print(\"NO\")\n    return\n\n  print(\"YES\")\n  for i in top_sort:\n    print(words[i])\n\n\nif __name__ == \"__main__\":\n  main()\n"
    },
    {
      "index": 1,
      "text": "\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n\t\"\"\"Performs a depth-first search and returns a topological sort of the graph.\n\tRaises an exception if the graph has a cycle.\n\t\"\"\"\n\t# A list to keep track of the visit status of nodes\n\tvisited = [False]*len(graph)\n\t# A list to store the sorted elements\n\ttop_sort = []\n\n    # Function to perform DFS\n    def dfs(node):\n        # Mark the current node as visited\n        visited[node] = True\n        # Recur for all the vertices adjacent to this vertex\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        # Push current vertex to the stack which stores the result\n        top_sort.append(node)\n\n    # Call the recursive helper function to store topological sort starting from all vertices one by one\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648688810,
  "object": "edit"
}
2022-03-30 21:07:11.679540 fix syntax errors 2 ['\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n  """Performs a depth-first search and returns a topological sort of the graph.\n  Raises an exception if the graph has a cycle.\n  """\n  # A list to keep track of the visit status of nodes\n  visited = [False]*len(graph)\n  # A list to store the sorted elements\n  top_sort = []\n\n  # Function to perform DFS\n  def dfs(node):\n    # Mark the current node as visited\n    visited[node] = True\n    # Recur for all the vertices adjacent to this vertex\n    for n in graph[node]:\n      if not visited[n]:\n        dfs(n)\n    # Push current vertex to the stack which stores the result\n    top_sort.append(node)\n\n  # Call the recursive helper function to store topological sort starting from all vertices one by one\n  for node in range(len(graph)):\n    if not visited[node]:\n      dfs(node)\n\n  return top_sort[::-1]\n\n\ndef main():\n  n = int(input())\n  words = [input() for _ in range(n)]\n\n  graph = defaultdict(list)\n  for i, word in enumerate(words):\n    for j, other in enumerate(words):\n      if i == j:\n        continue\n      if word in other:\n        graph[i].append(j)\n\n  try:\n    top_sort = dfs_topsort(graph)\n  except:\n    print("NO")\n    return\n\n  print("YES")\n  for i in top_sort:\n    print(words[i])\n\n\nif __name__ == "__main__":\n  main()\n', '\nfrom collections import defaultdict\n\ndef dfs_topsort(graph):\n\t"""Performs a depth-first search and returns a topological sort of the graph.\n\tRaises an exception if the graph has a cycle.\n\t"""\n\t# A list to keep track of the visit status of nodes\n\tvisited = [False]*len(graph)\n\t# A list to store the sorted elements\n\ttop_sort = []\n\n    # Function to perform DFS\n    def dfs(node):\n        # Mark the current node as visited\n        visited[node] = True\n        # Recur for all the vertices adjacent to this vertex\n        for n in graph[node]:\n            if not visited[n]:\n                dfs(n)\n        # Push current vertex to the stack which stores the result\n        top_sort.append(node)\n\n    # Call the recursive helper function to store topological sort starting from all vertices one by one\n    for node in range(len(graph)):\n        if not visited[node]:\n            dfs(node)\n\n    return top_sort[::-1]\n\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n\n    graph = defaultdict(list)\n    for i, word in enumerate(words):\n        for j, other in enumerate(words):\n            if i == j:\n                continue\n            if word in other:\n                graph[i].append(j)\n\n    try:\n        top_sort = dfs_topsort(graph)\n    except:\n        print("NO")\n        return\n\n    print("YES")\n    for i in top_sort:\n        print(words[i])\n\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 21:07:11.679571 size on output set 4
