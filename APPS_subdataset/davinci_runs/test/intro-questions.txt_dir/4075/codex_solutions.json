["\n\nN, M = map(int, input().split())\n\nbulbs = [list(map(int, input().split())) for i in range(M)]\nstates = list(map(int, input().split()))\n\npossible = 0\nfor i in range(2**N):\n    cnt = 0\n    for j in range(M):\n        on = sum([(i >> (bulbs[j][k] - 1)) % 2 for k in range(1, bulbs[j][0] + 1)]) % 2\n        if on == states[j]:\n            cnt += 1\n    if cnt == M:\n        possible += 1\nprint(possible)", "\n\n#SOLUTION\n\nn, m = map(int, input().split())\n\na = []\nb = []\nfor i in range(m):\n    tmp = list(map(int, input().split()))\n    a.append(tmp[1:])\n    b.append(tmp[0])\n\np = list(map(int, input().split()))\n\nresult = 0\nfor bits in range(2 ** n):\n    ok = True\n    for i in range(m):\n        cnt = 0\n        for j in range(b[i]):\n            if bits & (1 << (a[i][j] - 1)):\n                cnt += 1\n        if cnt % 2 != p[i]:\n            ok = False\n    if ok:\n        result += 1\n\nprint(result)", "\n\n# My answer\n\nN, M = map(int, input().split())\n\nswitches = []\nfor i in range(M):\n    switches.append(list(map(int, input().split())))\n\np = list(map(int, input().split()))\n\nres = 0\nfor i in range(2**N):\n    on = [False]*N\n    for j in range(N):\n        if (i >> j) & 1:\n            on[j] = True\n\n    flag = True\n    for j in range(M):\n        k = switches[j][0]\n        count = 0\n        for l in range(k):\n            if on[switches[j][l+1]]:\n                count += 1\n        if count%2 != p[j]:\n            flag = False\n            break;\n    if flag:\n        res += 1\n\nprint(res)"]