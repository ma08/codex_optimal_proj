2022-03-30 21:06:11.721679 num operations 2
2022-03-30 21:06:11.721707 size on input set 1
2022-03-30 21:06:14.749593 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n sequences\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(\" \".join([\"1\"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices in descending order\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(\" \".join(map(str, color_list)))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n characters\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(\" \".join([\"1\"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(\" \".join(map(str, color_list)))\n"
    }
  ],
  "created": 1648688772,
  "object": "edit"
}
2022-03-30 21:06:14.750201 fix spelling mistakes 2 ['\n\nimport sys\n\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n sequences\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(" ".join(["1"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices in descending order\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(" ".join(map(str, color_list)))\n', '\n\nimport sys\n\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n characters\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(" ".join(["1"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(" ".join(map(str, color_list)))\n']
2022-03-30 21:06:14.750229 size on output set 2
2022-03-30 21:06:14.750233 size on input set 2
2022-03-30 21:06:17.736334 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n sequences\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(\" \".join([\"1\"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices in descending order\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(\" \".join(map(str, color_list)))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n sequences\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(\" \".join([\"1\"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices in descending order\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(\" \".join(map(str, color_list)))\n"
    }
  ],
  "created": 1648688774,
  "object": "edit"
}
2022-03-30 21:06:17.736505 fix syntax errors 2 ['\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n sequences\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(" ".join(["1"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices in descending order\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(" ".join(map(str, color_list)))\n', '\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n sequences\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(" ".join(["1"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices in descending order\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(" ".join(map(str, color_list)))\n']
2022-03-30 21:06:20.524966 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n characters\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(\" \".join([\"1\"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(\" \".join(map(str, color_list)))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n characters\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(\" \".join([\"1\"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(\" \".join(map(str, color_list)))\n"
    }
  ],
  "created": 1648688777,
  "object": "edit"
}
2022-03-30 21:06:20.525329 fix syntax errors 2 ['\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n characters\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(" ".join(["1"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(" ".join(map(str, color_list)))\n', '\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n characters\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(" ".join(["1"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(" ".join(map(str, color_list)))\n']
2022-03-30 21:06:20.525360 size on output set 2
2022-03-30 21:06:20.525372 num operations 2
2022-03-30 21:06:20.525377 size on input set 1
2022-03-30 21:06:25.543613 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    print(s)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef solve(n, s): \n    c = [0] * n\n    c[0] = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            c[i] = c[i - 1] + 1\n        else:\n            c[i] = c[i - 1]\n    return c\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    c = solve(n, s)\n    print(max(c))\n    print(' '.join(map(str, c)))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1648688780,
  "object": "edit"
}
2022-03-30 21:06:25.543899 fix spelling mistakes 2 ["\n\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    print(s)\n\nif __name__ == '__main__':\n    main()\n", "\n\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef solve(n, s): \n    c = [0] * n\n    c[0] = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            c[i] = c[i - 1] + 1\n        else:\n            c[i] = c[i - 1]\n    return c\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    c = solve(n, s)\n    print(max(c))\n    print(' '.join(map(str, c)))\n\nif __name__ == '__main__':\n    main()\n"]
2022-03-30 21:06:25.544019 size on output set 2
2022-03-30 21:06:25.544029 size on input set 2
2022-03-30 21:06:28.485703 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "#!/usr/bin/env python3\n\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef solve(n, s):\n    c = [0] * n\n    c[0] = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            c[i] = c[i - 1] + 1\n        else:\n            c[i] = c[i - 1]\n    return c\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    c = solve(n, s)\n    print(max(c))\n    print(' '.join(map(str, c)))\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef solve(n, s): \n    c = [0] * n\n    c[0] = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            c[i] = c[i - 1] + 1\n        else:\n            c[i] = c[i - 1]\n    return c\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    c = solve(n, s)\n    print(max(c))\n    print(' '.join(map(str, c)))\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1648688785,
  "object": "edit"
}
2022-03-30 21:06:28.486177 fix syntax errors 2 ["#!/usr/bin/env python3\n\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef solve(n, s):\n    c = [0] * n\n    c[0] = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            c[i] = c[i - 1] + 1\n        else:\n            c[i] = c[i - 1]\n    return c\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    c = solve(n, s)\n    print(max(c))\n    print(' '.join(map(str, c)))\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef solve(n, s): \n    c = [0] * n\n    c[0] = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            c[i] = c[i - 1] + 1\n        else:\n            c[i] = c[i - 1]\n    return c\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    c = solve(n, s)\n    print(max(c))\n    print(' '.join(map(str, c)))\n\nif __name__ == '__main__':\n    main()\n"]
2022-03-30 21:06:32.050416 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    print(s)\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    print(s)\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1648688788,
  "object": "edit"
}
2022-03-30 21:06:32.050783 fix syntax errors 2 ["\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    print(s)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    print(s)\n\nif __name__ == '__main__':\n    main()\n"]
2022-03-30 21:06:32.050842 size on output set 3
