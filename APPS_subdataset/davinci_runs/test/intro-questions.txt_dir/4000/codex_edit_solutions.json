["\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n\n    def dfs(v, p=None):\n        ret = 1\n        for u in adj[v]:\n            if u == p:\n                continue\n            ret += dfs(u, v)\n        return ret\n\n    def solve():\n        a, b = None, None\n        for i in range(n):\n            if len(adj[i]) == 1:\n                a = i\n                break\n        for i in range(n):\n            if len(adj[i]) == 1:\n                b = i\n                break\n        if a is None or b is None:\n            return -1, -1, -1\n        return a, b, n - dfs(a) - dfs(b)\n\n    a, b, c = solve()\n    print(c)\n    print(a, b, c)\n\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()\n", "def main():\n    # \u5165\u529b\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    # \u8a08\u7b97\n\n    ans = 0\n    for i in range(n):\n        if a[i] > b[i]:\n            ans += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n        else:\n            ans += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        if a[i] > 0:\n            ans += a[i]\n            b[i + 1] -= a[i]\n            a[i] = 0\n        if b[i] > 0:\n            ans += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n    print(ans)\n    # \u51fa\u529b\n\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n", "\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()\n", "\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()\n", "def main(n, a, b):\n    # n = int(input())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n):\n        if a[i] > b[i]:\n            ans += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n        else:\n            ans += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        if a[i] > 0:\n            ans += a[i]\n            b[i + 1] -= a[i]\n            a[i] = 0\n        if b[i] > 0:\n            ans += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"]