"""
You are given an unweighted tree with $n$ vertices. Recall that a tree is a connected undirected graph without cycles.

Your task is to choose three distinct vertices $a, b, c$ on this tree such that the number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$ is the maximum possible. See the notes section for a better understanding.

The simple path is the path that visits each vertex at most once.


-----Input-----

The first line contains one integer number $n$ ($3 \le n \le 2 \cdot 10^5$) — the number of vertices in the tree. 

Next $n - 1$ lines describe the edges of the tree in form $a_i, b_i$ ($1 \le a_i$, $b_i \le n$, $a_i \ne b_i$). It is guaranteed that given graph is a tree.


-----Output-----

In the first line print one integer $res$ — the maximum number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$.

In the second line print three integers $a, b, c$ such that $1 \le a, b, c \le n$ and $a \ne, b \ne c, a \ne c$.

If there are several answers, you can print any.


-----Example-----
Input
8
1 2
2 3
3 4
4 5
4 6
3 7
3 8

Output
5
1 8 6



-----Note-----

The picture corresponding to the first example (and another one correct answer):

[Image]

If you choose vertices $1, 5, 6$ then the path between $1$ and $5$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 5)$, the path between $1$ and $6$ consists of edges $(1, 2), (2, 3), (3, 4), (4, 6)$ and the path between $5$ and $6$ consists of edges $(4, 5), (4, 6)$. The union of these paths is $(1, 2), (2, 3), (3, 4), (4, 5), (4, 6)$ so the answer is $5$. It can be shown that there is no better answer.
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def dfs(v, p=None):\n        ret = 1\n        for u in adj[v]:\n            if u == p:\n                continue\n            ret += dfs(u, v)\n        return ret\n\n    def solve():\n        a, b = None, None\n        for i in range(1, n + 1):\n            if len(adj[i]) == 1:\n                a = i\n                break\n        for i in range(1, n + 1):\n            if len(adj[i]) == 1:\n                b = i\n                break\n        if a is None or b is None:\n            return -1, -1, -1\n        return a, b, n - dfs(a) - dfs(b)\n\n    a, b, c = solve()\n    print(c)\n    print(a, b, c)\n\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()"
    }
  ],
  "created": 1648682655,
  "id": "cmpl-4rbxfyOx9NbhObXQzKfS8AisYgIOd",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def dfs(v, p=None):\n        ret = 1\n        for u in adj[v]:\n            if u == p:\n                continue\n            ret += dfs(u, v)\n        return ret\n\n    def solve():\n        a, b = None, None\n        for i in range(1, n + 1):\n            if len(adj[i]) == 1:\n                a = i\n                break\n        for i in range(1, n + 1):\n            if len(adj[i]) == 1:\n                b = i\n                break\n        if a is None or b is None:\n            return -1, -1, -1\n        return a, b, n - dfs(a) - dfs(b)\n\n    a, b, c = solve()\n    print(c)\n    print(a, b, c)\n\n\nif __name__ == \"__main__\":\n    main()"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()"
}
REASON stop
