"""
You are given three integers $n$, $d$ and $k$.

Your task is to construct an undirected tree on $n$ vertices with diameter $d$ and degree of each vertex at most $k$, or say that it is impossible.

An undirected tree is a connected undirected graph with $n - 1$ edges.

Diameter of a tree is the maximum length of a simple path (a path in which each vertex appears at most once) between all pairs of vertices of this tree.

Degree of a vertex is the number of edges incident to this vertex (i.e. for a vertex $u$ it is the number of edges $(u, v)$ that belong to the tree, where $v$ is any other vertex of a tree).


-----Input-----

The first line of the input contains three integers $n$, $d$ and $k$ ($1 \le n, d, k \le 4 \cdot 10^5$).


-----Output-----

If there is no tree satisfying the conditions above, print only one word "NO" (without quotes).

Otherwise in the first line print "YES" (without quotes), and then print $n - 1$ lines describing edges of a tree satisfying the conditions above. Vertices of the tree must be numbered from $1$ to $n$. You can print edges and vertices connected by an edge in any order. If there are multiple answers, print any of them.1


-----Examples-----
Input
6 3 3

Output
YES
3 1
4 1
1 2
5 2
2 6

Input
6 2 3

Output
NO

Input
10 4 3

Output
YES
2 9
2 10
10 3
3 1
6 10
8 2
4 3
5 6
6 7

Input
8 5 3

Output
YES
2 5
7 2
3 7
3 1
1 6
8 7
4 3
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\nimport sys, heapq, math\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.parent = self\n        self.children = []\n\ndef find(x):\n    if x.parent != x:\n        x.parent = find(x.parent)\n    return x.parent\n\ndef union(x, y):\n    xRoot = find(x)\n    yRoot = find(y)\n    if xRoot != yRoot:\n        if len(xRoot.children) > len(yRoot.children):\n            xRoot.children.append(yRoot)\n            yRoot.parent = xRoot\n        else:\n            yRoot.children.append(xRoot)\n            xRoot.parent = yRoot\n    return xRoot\n\ndef dfs(root, edges, k):\n    if len(root.children) == 0:\n        return\n    if len(edges) == 0:\n        print(\"NO\")\n        sys.exit()\n    root_num = root.value\n    if len(root.children) < k:\n        edges = sorted(edges)\n        for i in range(k - len(root.children)):\n            if edges[i][0] == root.value or edges[i][1] == root.value:\n                print(\"NO\")\n                sys.exit()\n            root.children.append(union(nodes[edges[i][0]], nodes[edges[i][1]]))\n        edges = edges[k - len(root.children):]\n    for child in root.children:\n        dfs(child, edges, k)\n\nn, d, k = list(map(int, input().split()))\nnodes = [Node(i) for i in range(1, n + 1)]\nedges = defaultdict(list)\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        weight = math.sqrt((i - j) ** 2)\n        edges[weight].append((i, j))\n\nif d > math.sqrt(n) or k >= n:\n    print(\"NO\")\n    sys.exit()\n\n# make a spanning tree\nedges = sorted(edges)\nfor i in range(n - 1):\n    if edges[i][0] == 1 or edges[i][1] == 1:\n        print(\"NO\")\n        sys.exit()\n    union(nodes[edges[i][0]], nodes[edges[i][1]])\nedges = edges[n - 1:]\n\n# dfs\ndfs(nodes[1], edges, k)\n\n# print the edges\nprint(\"YES\")\nfor i in range(2, n + 1):\n    print(find(nodes[i]).value, i)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": ""
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef main():\n\tn, d, k = [int(x) for x in input().split()]\n\tif d == 1:\n\t\tprint(\"YES\")\n\t\tfor i in range(1, n):\n\t\t\tprint(i, i + 1)\n\telif d == 2:\n\t\tif k < 2:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(2, 3)\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(1, 2)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\telif d == 3:\n\t\tif k < 2:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(2, 3)\n\t\t\tprint(2, 5)\n\t\t\tprint(1, 2)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\telif d == 4:\n\t\tif k < 2:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(2, 3)\n\t\t\tprint(2, 5)\n\t\t\tprint(2, 6)\n\t\t\tprint(1, 2)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\telif d == 5:\n\t\tif k < 3:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(1, 2)\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\t\t\tprint(1, 9)\n\t\t\tprint(1, 10)\n\nif __name__ == '__main__':\n\tmain()"
    }
  ],
  "created": 1648692810,
  "id": "cmpl-4rebSonkUlyUmAHSGsLiogmqXTMun",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\nimport sys, heapq, math\nfrom collections import defaultdict\n\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.parent = self\n        self.children = []\n\ndef find(x):\n    if x.parent != x:\n        x.parent = find(x.parent)\n    return x.parent\n\ndef union(x, y):\n    xRoot = find(x)\n    yRoot = find(y)\n    if xRoot != yRoot:\n        if len(xRoot.children) > len(yRoot.children):\n            xRoot.children.append(yRoot)\n            yRoot.parent = xRoot\n        else:\n            yRoot.children.append(xRoot)\n            xRoot.parent = yRoot\n    return xRoot\n\ndef dfs(root, edges, k):\n    if len(root.children) == 0:\n        return\n    if len(edges) == 0:\n        print(\"NO\")\n        sys.exit()\n    root_num = root.value\n    if len(root.children) < k:\n        edges = sorted(edges)\n        for i in range(k - len(root.children)):\n            if edges[i][0] == root.value or edges[i][1] == root.value:\n                print(\"NO\")\n                sys.exit()\n            root.children.append(union(nodes[edges[i][0]], nodes[edges[i][1]]))\n        edges = edges[k - len(root.children):]\n    for child in root.children:\n        dfs(child, edges, k)\n\nn, d, k = list(map(int, input().split()))\nnodes = [Node(i) for i in range(1, n + 1)]\nedges = defaultdict(list)\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        weight = math.sqrt((i - j) ** 2)\n        edges[weight].append((i, j))\n\nif d > math.sqrt(n) or k >= n:\n    print(\"NO\")\n    sys.exit()\n\n# make a spanning tree\nedges = sorted(edges)\nfor i in range(n - 1):\n    if edges[i][0] == 1 or edges[i][1] == 1:\n        print(\"NO\")\n        sys.exit()\n    union(nodes[edges[i][0]], nodes[edges[i][1]])\nedges = edges[n - 1:]\n\n# dfs\ndfs(nodes[1], edges, k)\n\n# print the edges\nprint(\"YES\")\nfor i in range(2, n + 1):\n    print(find(nodes[i]).value, i)"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": ""
}
REASON stop
2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef main():\n\tn, d, k = [int(x) for x in input().split()]\n\tif d == 1:\n\t\tprint(\"YES\")\n\t\tfor i in range(1, n):\n\t\t\tprint(i, i + 1)\n\telif d == 2:\n\t\tif k < 2:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(2, 3)\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(1, 2)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\telif d == 3:\n\t\tif k < 2:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(2, 3)\n\t\t\tprint(2, 5)\n\t\t\tprint(1, 2)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\telif d == 4:\n\t\tif k < 2:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(2, 3)\n\t\t\tprint(2, 5)\n\t\t\tprint(2, 6)\n\t\t\tprint(1, 2)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\telif d == 5:\n\t\tif k < 3:\n\t\t\tprint(\"NO\")\n\t\telse:\n\t\t\tprint(\"YES\")\n\t\t\tprint(1, 2)\n\t\t\tprint(3, 4)\n\t\t\tprint(4, 5)\n\t\t\tprint(5, 6)\n\t\t\tprint(1, 3)\n\t\t\tprint(1, 4)\n\t\t\tprint(1, 5)\n\t\t\tprint(1, 6)\n\t\t\tprint(1, 7)\n\t\t\tprint(1, 8)\n\t\t\tprint(1, 9)\n\t\t\tprint(1, 10)\n\nif __name__ == '__main__':\n\tmain()"
}
REASON stop
