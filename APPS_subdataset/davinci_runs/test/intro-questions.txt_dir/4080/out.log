"""
The only difference between easy and hard versions is a number of elements in the array.

You are given an array $a$ consisting of $n$ integers. The value of the $i$-th element of the array is $a_i$.

You are also given a set of $m$ segments. The $j$-th segment is $[l_j; r_j]$, where $1 \le l_j \le r_j \le n$.

You can choose some subset of the given set of segments and decrease values on each of the chosen segments by one (independently). For example, if the initial array $a = [0, 0, 0, 0, 0]$ and the given segments are $[1; 3]$ and $[2; 4]$ then you can choose both of them and the array will become $b = [-1, -2, -2, -1, 0]$.

You have to choose some subset of the given segments (each segment can be chosen at most once) in such a way that if you apply this subset of segments to the array $a$ and obtain the array $b$ then the value $\max\limits_{i=1}^{n}b_i - \min\limits_{i=1}^{n}b_i$ will be maximum possible.

Note that you can choose the empty set.

If there are multiple answers, you can print any.

If you are Python programmer, consider using PyPy instead of Python when you submit your code.


-----Input-----

The first line of the input contains two integers $n$ and $m$ ($1 \le n \le 10^5, 0 \le m \le 300$) — the length of the array $a$ and the number of segments, respectively.

The second line of the input contains $n$ integers $a_1, a_2, \dots, a_n$ ($-10^6 \le a_i \le 10^6$), where $a_i$ is the value of the $i$-th element of the array $a$.

The next $m$ lines are contain two integers each. The $j$-th of them contains two integers $l_j$ and $r_j$ ($1 \le l_j \le r_j \le n$), where $l_j$ and $r_j$ are the ends of the $j$-th segment.


-----Output-----

In the first line of the output print one integer $d$ — the maximum possible value $\max\limits_{i=1}^{n}b_i - \min\limits_{i=1}^{n}b_i$ if $b$ is the array obtained by applying some subset of the given segments to the array $a$.

In the second line of the output print one integer $q$ ($0 \le q \le m$) — the number of segments you apply.

In the third line print $q$ distinct integers $c_1, c_2, \dots, c_q$ in any order ($1 \le c_k \le m$) — indices of segments you apply to the array $a$ in such a way that the value $\max\limits_{i=1}^{n}b_i - \min\limits_{i=1}^{n}b_i$ of the obtained array $b$ is maximum possible.

If there are multiple answers, you can print any.


-----Examples-----
Input
5 4
2 -2 3 1 2
1 3
4 5
2 5
1 3

Output
6
2
4 1 

Input
5 4
2 -2 3 1 4
3 5
3 4
2 4
2 5

Output
7
2
3 2 

Input
1 0
1000000

Output
0
0




-----Note-----

In the first example the obtained array $b$ will be $[0, -4, 1, 1, 2]$ so the answer is $6$.

In the second example the obtained array $b$ will be $[2, -3, 1, -1, 4]$ so the answer is $7$.

In the third example you cannot do anything so the answer is $0$.
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\nimport sys\n\ndef get_min_max(l, r):\n    \"\"\"\n    returns the smallest and largest value of the array between l and r, inclusive\n    \"\"\"\n    min_val = min(arr[l:r+1])\n    max_val = max(arr[l:r+1])\n    return (min_val, max_val)\n\ndef get_max_diff(segment):\n    \"\"\"\n    returns the difference between the largest and smallest values within a segment\n    \"\"\"\n    min_val, max_val = get_min_max(segment[0]-1, segment[1]-1)\n    return max_val - min_val\n\ndef get_segments_to_use(segments):\n    \"\"\"\n    returns the indices of the segments that should be used to get the largest\n    difference between the largest and smallest values in the array\n    \"\"\"\n    segments_to_use = []\n    for segment in segments:\n        l, r = segment\n        min_val, max_val = get_min_max(l-1, r-1)\n        max_diff = max_val - min_val\n        if max_diff > largest_diff:\n            largest_diff = max_diff\n            segments_to_use = [segment]\n        elif max_diff == largest_diff:\n            segments_to_use.append(segment)\n    return segments_to_use\n\ndef main():\n    global arr, largest_diff\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    arr = [int(x) for x in sys.stdin.readline().split()]\n    # initialize the largest difference to the difference between the max and min\n    # of the entire array\n    largest_diff = max(arr) - min(arr)\n    segments = []\n    for i in range(m):\n        segments.append([int(x) for x in sys.stdin.readline().split()])\n    # sort the segments by the largest difference between the smallest and largest\n    # values in the segment\n    segments.sort(key=get_max_diff, reverse=True)\n    # get the indices of the segments to use\n    segments_to_use = get_segments_to_use(segments)\n    # print the largest difference\n    print(largest_diff)\n    # print the number of segments to use\n    print(len(segments_to_use))\n    # print the indices of the segments to use\n    for segment in segments_to_use:\n        print(segments.index(segment)+1, end=\" \")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\n#!/usr/bin/env python3\n\nimport sys\n\ndef read_ints():\n    return tuple(map(int, sys.stdin.readline().strip().split()))\n\ndef read_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\n#\n#\n#\n\ndef read_segments():\n    n, m = read_ints()\n    a = read_array()\n    segments = [(l-1, r-1) for l, r in [read_ints() for i in range(m)]]\n    return a, segments\n\n#\n#\n#\n\ndef max_diff(a, segments):\n    n = len(a)\n    \n    a_min = min(a)\n    a_max = max(a)\n    \n    if a_min == a_max:\n        return 0, ()\n    \n    s_min = [0] * n\n    s_max = [0] * n\n\n    for l, r in segments:\n        s_min[l] += 1\n        s_max[r] += 1\n\n    d_min = 0\n    d_max = 0\n    for i in range(n):\n        d_min += s_min[i]\n        d_max += s_max[i]\n        s_min[i] = d_min\n        s_max[i] = d_max\n\n    d_min = 0\n    d_max = 0\n    j = 0\n    \n    for i in range(n):\n        if a[i] == a_min:\n            d_min = s_min[i]\n        if a[i] == a_max:\n            d_max = s_max[i]\n            j = i\n            break\n\n    return d_max - d_min, s_max[:j]\n\na, segments = read_segments()\n\nd, s = max_diff(a, segments)\n\nprint(d)\nprint(len(s))\nprint(' '.join(map(str, s)))"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\nimport sys\nimport numpy as np\n\n# The key observation is that the optimal solution can be obtained by choosing segments which have the most extreme endpoints\n# Thus, we can compute the min/max values of all endpoints of segments, then find the optimal solution by choosing the right segments\n# If we manage to find the optimal solution, then it is unique.\n\nn, m = map(int, sys.stdin.readline().strip().split())\na = list(map(int, sys.stdin.readline().strip().split()))\n\nmin_vals = np.zeros(n)\nmax_vals = np.zeros(n)\nmin_vals[:] = np.inf\nmax_vals[:] = -np.inf\n\nfor i in range(m):\n    l, r = map(int, sys.stdin.readline().strip().split())\n    min_vals[l-1] = min(min_vals[l-1], a[l-1])\n    max_vals[r-1] = max(max_vals[r-1], a[r-1])\n\nfor i in range(1, n):\n    min_vals[i] = min(min_vals[i-1], min_vals[i])\n    max_vals[n-1-i] = max(max_vals[n-i], max_vals[n-1-i])\n\nd = 0\nselected_segments = []\nfor i in range(m):\n    l, r = map(int, sys.stdin.readline().strip().split())\n    d_opt = max(max_vals[r-1], a[r-1]) - min(min_vals[l-1], a[l-1])\n    if d_opt > d:\n        d = d_opt\n        selected_segments = [i+1]\n    elif d_opt == d:\n        selected_segments.append(i+1)\n\nprint(d)\nprint(len(selected_segments))\nprint(' '.join(map(str, selected_segments)))"
    }
  ],
  "created": 1648693629,
  "id": "cmpl-4reofbxBTlHnrGmIflW5q4d3kUtJm",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\nimport sys\n\ndef get_min_max(l, r):\n    \"\"\"\n    returns the smallest and largest value of the array between l and r, inclusive\n    \"\"\"\n    min_val = min(arr[l:r+1])\n    max_val = max(arr[l:r+1])\n    return (min_val, max_val)\n\ndef get_max_diff(segment):\n    \"\"\"\n    returns the difference between the largest and smallest values within a segment\n    \"\"\"\n    min_val, max_val = get_min_max(segment[0]-1, segment[1]-1)\n    return max_val - min_val\n\ndef get_segments_to_use(segments):\n    \"\"\"\n    returns the indices of the segments that should be used to get the largest\n    difference between the largest and smallest values in the array\n    \"\"\"\n    segments_to_use = []\n    for segment in segments:\n        l, r = segment\n        min_val, max_val = get_min_max(l-1, r-1)\n        max_diff = max_val - min_val\n        if max_diff > largest_diff:\n            largest_diff = max_diff\n            segments_to_use = [segment]\n        elif max_diff == largest_diff:\n            segments_to_use.append(segment)\n    return segments_to_use\n\ndef main():\n    global arr, largest_diff\n    n, m = [int(x) for x in sys.stdin.readline().split()]\n    arr = [int(x) for x in sys.stdin.readline().split()]\n    # initialize the largest difference to the difference between the max and min\n    # of the entire array\n    largest_diff = max(arr) - min(arr)\n    segments = []\n    for i in range(m):\n        segments.append([int(x) for x in sys.stdin.readline().split()])\n    # sort the segments by the largest difference between the smallest and largest\n    # values in the segment\n    segments.sort(key=get_max_diff, reverse=True)\n    # get the indices of the segments to use\n    segments_to_use = get_segments_to_use(segments)\n    # print the largest difference\n    print(largest_diff)\n    # print the number of segments to use\n    print(len(segments_to_use))\n    # print the indices of the segments to use\n    for segment in segments_to_use:\n        print(segments.index(segment)+1, end=\" \")\n\nif __name__ == \"__main__\":\n    main()"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\n#!/usr/bin/env python3\n\nimport sys\n\ndef read_ints():\n    return tuple(map(int, sys.stdin.readline().strip().split()))\n\ndef read_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\n#\n#\n#\n\ndef read_segments():\n    n, m = read_ints()\n    a = read_array()\n    segments = [(l-1, r-1) for l, r in [read_ints() for i in range(m)]]\n    return a, segments\n\n#\n#\n#\n\ndef max_diff(a, segments):\n    n = len(a)\n    \n    a_min = min(a)\n    a_max = max(a)\n    \n    if a_min == a_max:\n        return 0, ()\n    \n    s_min = [0] * n\n    s_max = [0] * n\n\n    for l, r in segments:\n        s_min[l] += 1\n        s_max[r] += 1\n\n    d_min = 0\n    d_max = 0\n    for i in range(n):\n        d_min += s_min[i]\n        d_max += s_max[i]\n        s_min[i] = d_min\n        s_max[i] = d_max\n\n    d_min = 0\n    d_max = 0\n    j = 0\n    \n    for i in range(n):\n        if a[i] == a_min:\n            d_min = s_min[i]\n        if a[i] == a_max:\n            d_max = s_max[i]\n            j = i\n            break\n\n    return d_max - d_min, s_max[:j]\n\na, segments = read_segments()\n\nd, s = max_diff(a, segments)\n\nprint(d)\nprint(len(s))\nprint(' '.join(map(str, s)))"
}
REASON stop
2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\nimport sys\nimport numpy as np\n\n# The key observation is that the optimal solution can be obtained by choosing segments which have the most extreme endpoints\n# Thus, we can compute the min/max values of all endpoints of segments, then find the optimal solution by choosing the right segments\n# If we manage to find the optimal solution, then it is unique.\n\nn, m = map(int, sys.stdin.readline().strip().split())\na = list(map(int, sys.stdin.readline().strip().split()))\n\nmin_vals = np.zeros(n)\nmax_vals = np.zeros(n)\nmin_vals[:] = np.inf\nmax_vals[:] = -np.inf\n\nfor i in range(m):\n    l, r = map(int, sys.stdin.readline().strip().split())\n    min_vals[l-1] = min(min_vals[l-1], a[l-1])\n    max_vals[r-1] = max(max_vals[r-1], a[r-1])\n\nfor i in range(1, n):\n    min_vals[i] = min(min_vals[i-1], min_vals[i])\n    max_vals[n-1-i] = max(max_vals[n-i], max_vals[n-1-i])\n\nd = 0\nselected_segments = []\nfor i in range(m):\n    l, r = map(int, sys.stdin.readline().strip().split())\n    d_opt = max(max_vals[r-1], a[r-1]) - min(min_vals[l-1], a[l-1])\n    if d_opt > d:\n        d = d_opt\n        selected_segments = [i+1]\n    elif d_opt == d:\n        selected_segments.append(i+1)\n\nprint(d)\nprint(len(selected_segments))\nprint(' '.join(map(str, selected_segments)))"
}
REASON stop
