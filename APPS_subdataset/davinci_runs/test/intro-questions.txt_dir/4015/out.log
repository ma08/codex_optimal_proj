"""
Polycarp plays "Game 23". Initially he has a number $n$ and his goal is to transform it to $m$. In one move, he can multiply $n$ by $2$ or multiply $n$ by $3$. He can perform any number of moves.

Print the number of moves needed to transform $n$ to $m$. Print -1 if it is impossible to do so.

It is easy to prove that any way to transform $n$ to $m$ contains the same number of moves (i.e. number of moves doesn't depend on the way of transformation).


-----Input-----

The only line of the input contains two integers $n$ and $m$ ($1 \le n \le m \le 5\cdot10^8$).


-----Output-----

Print the number of moves to transform $n$ to $m$, or -1 if there is no solution.


-----Examples-----
Input
120 51840

Output
7

Input
42 42

Output
0

Input
48 72

Output
-1



-----Note-----

In the first example, the possible sequence of moves is: $120 \rightarrow 240 \rightarrow 720 \rightarrow 1440 \rightarrow 4320 \rightarrow 12960 \rightarrow 25920 \rightarrow 51840.$ The are $7$ steps in total.

In the second example, no moves are needed. Thus, the answer is $0$.

In the third example, it is impossible to transform $48$ to $72$.
"""
--------------------------
{
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "text": "\n\n\n# def find(n, m, d):\n#     d[n] = 0\n#     queue = deque([n])\n#     while queue:\n#         x = queue.popleft()\n#         if x == m:\n#             return d[x]\n#         if x * 2 <= m:\n#             if x * 2 not in d:\n#                 queue.append(x * 2)\n#                 d[x * 2] = d[x] + 1\n#         if x * 3 <= m:\n#             if x * 3 not in d:\n#                 queue.append(x * 3)\n#                 d[x * 3] = d[x] + 1\n#     return -1\n#\n#\n# n, m = map(int, input().split())\n# d = {}\n# print(find(n, m, d))\n\nn, m = map(int, input().split())\n\nif n == m:\n    print(0)\n    exit()\n\nif m % n:\n    print(-1)\n    exit()\n\ncount = 0\nwhile m != n:\n    if m % 2 and m % 3:\n        print(-1)\n        exit()\n    elif m % 2 == 0:\n        m //= 2\n    else:\n        m //= 3\n    count += 1\n\nprint(count)"
    },
    {
      "finish_reason": "stop",
      "index": 1,
      "logprobs": null,
      "text": "\n\nn,m=map(int,input().split())\nif(m%n==0 and (m/n)%2==0):\n    print(1)\nelif(m%n==0):\n    print(2)\nelif(m%n!=0 and (m/n)%2!=0):\n    print(3)\nelse:\n    print(-1)"
    },
    {
      "finish_reason": "stop",
      "index": 2,
      "logprobs": null,
      "text": "\n\ndef f(n,m):\n    if n == m:\n        return 0\n    if n > m:\n        return -1\n    if n*2 > m and n*3 > m:\n        return -1\n    if n*2 == m or n*3 == m:\n        return 1\n    return 1 + min(f(n*2,m), f(n*3,m))\n\nn,m = map(int, input().split())\nprint(f(n,m))"
    }
  ],
  "created": 1648692166,
  "id": "cmpl-4reR4fDCZBkNJbbasODgfQYcTcOYT",
  "model": "code-davinci:002",
  "object": "text_completion"
}
0 {
  "finish_reason": "stop",
  "index": 0,
  "logprobs": null,
  "text": "\n\n\n# def find(n, m, d):\n#     d[n] = 0\n#     queue = deque([n])\n#     while queue:\n#         x = queue.popleft()\n#         if x == m:\n#             return d[x]\n#         if x * 2 <= m:\n#             if x * 2 not in d:\n#                 queue.append(x * 2)\n#                 d[x * 2] = d[x] + 1\n#         if x * 3 <= m:\n#             if x * 3 not in d:\n#                 queue.append(x * 3)\n#                 d[x * 3] = d[x] + 1\n#     return -1\n#\n#\n# n, m = map(int, input().split())\n# d = {}\n# print(find(n, m, d))\n\nn, m = map(int, input().split())\n\nif n == m:\n    print(0)\n    exit()\n\nif m % n:\n    print(-1)\n    exit()\n\ncount = 0\nwhile m != n:\n    if m % 2 and m % 3:\n        print(-1)\n        exit()\n    elif m % 2 == 0:\n        m //= 2\n    else:\n        m //= 3\n    count += 1\n\nprint(count)"
}
REASON stop
1 {
  "finish_reason": "stop",
  "index": 1,
  "logprobs": null,
  "text": "\n\nn,m=map(int,input().split())\nif(m%n==0 and (m/n)%2==0):\n    print(1)\nelif(m%n==0):\n    print(2)\nelif(m%n!=0 and (m/n)%2!=0):\n    print(3)\nelse:\n    print(-1)"
}
REASON stop
2 {
  "finish_reason": "stop",
  "index": 2,
  "logprobs": null,
  "text": "\n\ndef f(n,m):\n    if n == m:\n        return 0\n    if n > m:\n        return -1\n    if n*2 > m and n*3 > m:\n        return -1\n    if n*2 == m or n*3 == m:\n        return 1\n    return 1 + min(f(n*2,m), f(n*3,m))\n\nn,m = map(int, input().split())\nprint(f(n,m))"
}
REASON stop
