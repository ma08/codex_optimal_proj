["\n\nclass Node:\n    def __init__(self, val, left, right):\n        self.value = val\n        self.left = left\n        self.right = right\n\n\ndef build_tree(nodes):\n    root = Node(nodes[0][0], nodes[0][1], nodes[0][2])\n    for i in range(1, len(nodes)):\n        node = Node(nodes[i][0], nodes[i][1], nodes[i][2])\n        current = root\n        while True:\n            if current.value > node.value:\n                if current.left == -1:\n                    current.left = node\n                    break\n                else:\n                    current = nodes[current.left]\n            else:\n                if current.right == -1:\n                    current.right = node\n                    break\n                else:\n                    current = nodes[current.right]\n    return root\n\n\ndef find(root, x):\n    if root is None:\n        return False\n    if root.value == x:\n        return True\n    if x < root.value:\n        return find(root.left, x)\n    else:\n        return find(root.right, x)\n\n\ndef find_fails(root):\n    fails = 0\n    if root.left is not None:\n        fails += find_fails(root.left)\n    if root.right is not None:\n        fails += find_fails(root.right)\n    if root.left is not None and root.right is not None:\n        if root.left.value > root.value or root.right.value < root.value:\n            fails += 1\n    return fails\n\n\ndef main():\n    n = int(input())\n    nodes = []\n    for i in range(n):\n        nodes.append(list(map(int, input().split())))\n    root = build_tree(nodes)\n    fails = find_fails(root)\n    print(fails)\n\n\nif __name__ == \"__main__\":\n    main()", "\n\n# https://github.com/MisterBooo/LeetCodeAnimation/blob/master/notes/LeetCode%E7%AC%AC450%E5%8F%B7%E9%97%AE%E9%A2%98%EF%BC%9A%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.md\n\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution(object):\n    def deleteNode(self, root, key):\n        \"\"\"\n        :type root: TreeNode\n        :type key: int\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return None\n        if root.val == key:\n            if not root.left:\n                return root.right\n            elif not root.right:\n                return root.left\n            else:\n                min_node = self.find_min(root.right)\n                root.val = min_node.val\n                root.right = self.deleteNode(root.right, root.val)\n        elif root.val < key:\n            root.right = self.deleteNode(root.right, key)\n        else:\n            root.left = self.deleteNode(root.left, key)\n        return root\n    \n    def find_min(self, root):\n        while root.left:\n            root = root.left\n        return root\n\n# test\nn = int(input())\nnode_list = []\nfor i in range(n):\n    v, l, r = input().split(' ')\n    node = TreeNode(v)\n    node.left = node_list[l] if l != '-1' else None\n    node.right = node_list[r] if r != '-1' else None\n    node_list.append(node)\n\nprint(Solution().deleteNode(node_list[0], 4))"]