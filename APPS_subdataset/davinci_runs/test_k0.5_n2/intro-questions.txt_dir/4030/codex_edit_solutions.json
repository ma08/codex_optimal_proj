["\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    print(s)\n\nif __name__ == '__main__':\n    main()\n", "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n characters\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(\" \".join([\"1\"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(\" \".join(map(str, color_list)))\n", "\nimport sys\nfrom collections import defaultdict\n\nsys.setrecursionlimit(10**6)\n\n# read data for n sequences\nn = int(input())\n\nseq = input()\n\n# if there are only one type of char, then the answer is 1\nif len(set(seq)) == 1:\n    print(1)\n    print(\" \".join([\"1\"] * n))\n    exit()\n\n# create a dictionary of lists of indices for each char\n# O(n)\nchar_dict = defaultdict(list)\nfor i, c in enumerate(seq):\n    char_dict[c].append(i)\n\n# create a list of chars sorted by the number of indices in descending order\n# O(n)\nchar_list = sorted(char_dict.keys(), key=lambda c: len(char_dict[c]), reverse=True)\n\n# create a dictionary of chars and their colors\n# O(n)\nchar_color = {char_list[0]: 1}\nfor i in range(1, len(char_list)):\n    prev_char = char_list[i-1]\n    prev_color = char_color[prev_char]\n    # if the previous char has more indices than the current one,\n    # then the current char can be colored with the same color\n    if len(char_dict[prev_char]) > len(char_dict[char_list[i]]):\n        char_color[char_list[i]] = prev_color\n    # otherwise, the current char has to be colored with a different color\n    else:\n        char_color[char_list[i]] = prev_color + 1\n\n# create a list of integers that represent the colors of the chars\n# O(n)\ncolor_list = [char_color[c] for c in seq]\n\n# print the minimum number of colors and the coloring\nprint(max(color_list))\nprint(\" \".join(map(str, color_list)))\n", "\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef solve(n, s): \n    c = [0] * n\n    c[0] = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            c[i] = c[i - 1] + 1\n        else:\n            c[i] = c[i - 1]\n    return c\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    c = solve(n, s)\n    print(max(c))\n    print(' '.join(map(str, c)))\n\nif __name__ == '__main__':\n    main()\n", "#!/usr/bin/env python3\n\nimport sys\nimport heapq\nimport math\nfrom collections import Counter, deque\nfrom itertools import combinations, permutations, product\n\nsys.setrecursionlimit(10000)\n\ndef read_list_int():\n    return list(map(int, input().split(' ')))\n\ndef read_single_int():\n    return int(input())\n\ndef read_single_str():\n    return input()\n\ndef solve(n, s):\n    c = [0] * n\n    c[0] = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            c[i] = c[i - 1] + 1\n        else:\n            c[i] = c[i - 1]\n    return c\n\ndef main():\n    n = read_single_int()\n    s = read_single_str()\n    c = solve(n, s)\n    print(max(c))\n    print(' '.join(map(str, c)))\n\nif __name__ == '__main__':\n    main()\n"]