2022-03-30 21:22:25.944458 num operations 2
2022-03-30 21:22:25.944484 size on input set 1
2022-03-30 21:22:29.885598 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\nimport sys\n\n# read in the data \ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t\nprint len(s) - len(lcs(s, t))\n"
    },
    {
      "index": 1,
      "text": "\n\nimport sys\n\n# read in the data.\ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t.\nprint len(s) - len(lcs(s, t))\n"
    }
  ],
  "created": 1648689746,
  "object": "edit"
}
2022-03-30 21:22:29.886026 fix spelling mistakes 2 ['\n\nimport sys\n\n# read in the data \ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t\nprint len(s) - len(lcs(s, t))\n', '\n\nimport sys\n\n# read in the data.\ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t.\nprint len(s) - len(lcs(s, t))\n']
2022-03-30 21:22:29.886068 size on output set 2
2022-03-30 21:22:29.886095 size on input set 2
2022-03-30 21:22:38.021598 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import lcs\n\nimport sys\n\n# read in the data.\ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t.\nprint len(s) - len(lcs(s, t))\n"
    },
    {
      "index": 1,
      "text": "\nimport sys\n\ndef lcs(s, t):\n    l = [[0 for i in range(len(t)+1)] for j in range(len(s)+1)]\n    for i in range(len(s)):\n        for j in range(len(t)):\n            if s[i] == t[j]:\n                l[i+1][j+1] = l[i][j] + 1\n            else:\n                l[i+1][j+1] = max(l[i+1][j], l[i][j+1])\n    return l[-1][-1]\n\n\ndef main():\n    # read in the data.\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    # the answer is the length of s minus the length of the longest common subsequence of s and t.\n    print len(s) - lcs(s, t)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1648689750,
  "object": "edit"
}
2022-03-30 21:22:38.021918 fix syntax errors 2 ['import lcs\n\nimport sys\n\n# read in the data.\ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t.\nprint len(s) - len(lcs(s, t))\n', "\nimport sys\n\ndef lcs(s, t):\n    l = [[0 for i in range(len(t)+1)] for j in range(len(s)+1)]\n    for i in range(len(s)):\n        for j in range(len(t)):\n            if s[i] == t[j]:\n                l[i+1][j+1] = l[i][j] + 1\n            else:\n                l[i+1][j+1] = max(l[i+1][j], l[i][j+1])\n    return l[-1][-1]\n\n\ndef main():\n    # read in the data.\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n\n    # the answer is the length of s minus the length of the longest common subsequence of s and t.\n    print len(s) - lcs(s, t)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-03-30 21:22:41.189888 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "import lcs\n\nimport sys\n\n# read in the data \ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t\nprint len(s) - len(lcs(s, t))\n"
    },
    {
      "index": 1,
      "text": "#!/usr/bin/env python\n\nimport sys\n\n# read in the data \ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t\nprint len(s) - len(lcs(s,t))\n"
    }
  ],
  "created": 1648689758,
  "object": "edit"
}
2022-03-30 21:22:41.190105 fix syntax errors 2 ['import lcs\n\nimport sys\n\n# read in the data \ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t\nprint len(s) - len(lcs(s, t))\n', '#!/usr/bin/env python\n\nimport sys\n\n# read in the data \ns = sys.stdin.readline().strip()\nt = sys.stdin.readline().strip()\n\n# the answer is the length of s minus the length of the longest common subsequence of s and t\nprint len(s) - len(lcs(s,t))\n']
2022-03-30 21:22:41.190135 size on output set 4
2022-03-30 21:22:41.190151 num operations 2
2022-03-30 21:22:41.190159 size on input set 1
2022-03-30 21:22:48.901616 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest subsequence of s that is not a subsequence of t\n    # can be done by finding the longest subsequence of s that is a subsequence of t\n    # and subtracting the length of this subsequence from the length of s\n    # longest subsequence of s that is a subsequence of t is the same as the\n    # longest subsequence of s that is a subsequence of t and a subsequence of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t\n    # that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest subsequence of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\n\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest substring of s that is not a subsequence of t\n    # can be done by finding the longest substring of s that is a subsequence of t\n    # and subtracting the length of this substring from the length of s\n    # longest substring of s that is a subsequence of t is the same as the longest substring of s that is a subsequence of t and a substring of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence of this character in t\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest substring of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648689761,
  "object": "edit"
}
2022-03-30 21:22:48.902177 fix spelling mistakes 2 ['\n\n\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest subsequence of s that is not a subsequence of t\n    # can be done by finding the longest subsequence of s that is a subsequence of t\n    # and subtracting the length of this subsequence from the length of s\n    # longest subsequence of s that is a subsequence of t is the same as the\n    # longest subsequence of s that is a subsequence of t and a subsequence of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t\n    # that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest subsequence of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == "__main__":\n    main()\n', '\n\n\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest substring of s that is not a subsequence of t\n    # can be done by finding the longest substring of s that is a subsequence of t\n    # and subtracting the length of this substring from the length of s\n    # longest substring of s that is a subsequence of t is the same as the longest substring of s that is a subsequence of t and a substring of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence of this character in t\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest substring of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 21:22:48.902240 size on output set 2
2022-03-30 21:22:48.902247 size on input set 2
2022-03-30 21:22:52.121601 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest substring of s that is not a subsequence of t\n    # can be done by finding the longest substring of s that is a subsequence of t\n    # and subtracting the length of this substring from the length of s\n    # longest substring of s that is a subsequence of t is the same as the longest substring of s that is a subsequence of t and a substring of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n\n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence of this character in t\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n\n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest substring of s that is a subsequence of t\n\n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest substring of s that is not a subsequence of t\n    # can be done by finding the longest substring of s that is a subsequence of t\n    # and subtracting the length of this substring from the length of s\n    # longest substring of s that is a subsequence of t is the same as the longest substring of s that is a subsequence of t and a substring of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence of this character in t\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest substring of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648689769,
  "object": "edit"
}
2022-03-30 21:22:52.122036 fix syntax errors 2 ['\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest substring of s that is not a subsequence of t\n    # can be done by finding the longest substring of s that is a subsequence of t\n    # and subtracting the length of this substring from the length of s\n    # longest substring of s that is a subsequence of t is the same as the longest substring of s that is a subsequence of t and a substring of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n\n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence of this character in t\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n\n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest substring of s that is a subsequence of t\n\n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest substring of s that is not a subsequence of t\n    # can be done by finding the longest substring of s that is a subsequence of t\n    # and subtracting the length of this substring from the length of s\n    # longest substring of s that is a subsequence of t is the same as the longest substring of s that is a subsequence of t and a substring of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence of this character in t\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest substring of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 21:23:01.507541 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\n\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest subsequence of s that is not a subsequence of t\n    # can be done by finding the longest subsequence of s that is a subsequence of t\n    # and subtracting the length of this subsequence from the length of s\n    # longest subsequence of s that is a subsequence of t is the same as the longest subsequence of s that is a subsequence of t and a subsequence of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence of this character in t\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence ending at this index\n    # the answer is the length of s minus the longest increasing subsequence, which is the longest subsequence of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest subsequence of s that is not a subsequence of t\n    # can be done by finding the longest subsequence of s that is a subsequence of t\n    # and subtracting the length of this subsequence from the length of s\n    # longest subsequence of s that is a subsequence of t is the same as the\n    # longest subsequence of s that is a subsequence of t and a subsequence of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t\n    # that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest subsequence of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648689772,
  "object": "edit"
}
2022-03-30 21:23:01.507693 fix syntax errors 2 ['\n\n\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest subsequence of s that is not a subsequence of t\n    # can be done by finding the longest subsequence of s that is a subsequence of t\n    # and subtracting the length of this subsequence from the length of s\n    # longest subsequence of s that is a subsequence of t is the same as the longest subsequence of s that is a subsequence of t and a subsequence of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence of this character in t\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence ending at this index\n    # the answer is the length of s minus the longest increasing subsequence, which is the longest subsequence of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == "__main__":\n    main()\n', '\ndef main():\n    s = input()\n    t = input()\n\n    # t = subsequence of s\n    # find the longest subsequence of s that is not a subsequence of t\n    # can be done by finding the longest subsequence of s that is a subsequence of t\n    # and subtracting the length of this subsequence from the length of s\n    # longest subsequence of s that is a subsequence of t is the same as the\n    # longest subsequence of s that is a subsequence of t and a subsequence of s\n\n    # make a list of indices for each character in t\n    indices = {}\n    for i, c in enumerate(t):\n        if c in indices:\n            indices[c].append(i)\n        else:\n            indices[c] = [i]\n    \n    # for each character in s, if it is in t, find the index of the next occurrence of this character in t\n    # that is after the index of the last occurrence of this character in t\n    # if there is no next occurrence, use the index of the last occurrence\n    next_indices = []\n    last_index = -1\n    for c in s:\n        if c in indices:\n            next_index = -1\n            for i in indices[c]:\n                if i > last_index:\n                    next_index = i\n                    break\n            if next_index == -1:\n                next_index = indices[c][-1]\n            next_indices.append(next_index)\n            last_index = next_index\n    \n    # for each index in next_indices, find the length of the longest increasing subsequence\n    # ending at this index\n    # the answer is the length of s minus the longest increasing subsequence\n    # the longest increasing subsequence is the longest subsequence of s that is a subsequence of t\n    \n    # longest_increasing_subsequence[i] = length of longest increasing subsequence ending at index i\n    longest_increasing_subsequence = [1] * len(next_indices)\n    for i in range(1, len(next_indices)):\n        for j in range(i):\n            if next_indices[j] < next_indices[i]:\n                longest_increasing_subsequence[i] = max(longest_increasing_subsequence[i], longest_increasing_subsequence[j] + 1)\n    print(len(s) - max(longest_increasing_subsequence))\n\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 21:23:01.507729 size on output set 4
