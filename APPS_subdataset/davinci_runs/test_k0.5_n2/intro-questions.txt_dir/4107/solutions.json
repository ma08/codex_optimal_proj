["import heapq\n\nn, k = list(map(int, input().split()))\ns = input()\n\nmostRecent = n\nbest = []\nfor room in range(n-1, -1, -1):\n    if s[room] == '1':\n        mostRecent = room\n    best.append(mostRecent)\n\nbest = best[::-1]\n\ndp = [0]\n\nvals = [(0,0)]\n\nfor room in range(1, n + 1):\n    new = dp[-1] + room\n    if room - k - 1 >= 0:\n        bestRout = best[room - k - 1]\n        if bestRout <= (room - 1):\n            covered = bestRout - k\n\n            if covered >= 0:\n                try:\n                    while len(vals) > 0 and vals[0][1] < covered:\n                        heapq.heappop(vals)\n                    if len(vals) > 0:\n                        add = vals[0][0]\n                        new2 = (bestRout + 1) + add\n                        new = min(new2, new)\n                except Exception:\n                    pass\n            else:\n                new2 = (bestRout + 1)\n                new = min(new2, new)\n\n\n\n    dp.append(new)\n    heapq.heappush(vals, (new, room))\n\nprint(new)\n    \n", "def get(n,k,s):\n    nxt=[0]*(n+1)\n    cur=1<<30\n    for i in range(n,0,-1):\n        if s[i-1]=='1':\n            cur=i\n        nxt[i]=cur\n    \n    dp=[0]\n    for i in range(1,n+1):\n        dp.append(dp[-1]+i)\n        c=nxt[max(i-k,1)]\n        if c<=i+k:\n            dp[i]=min(dp[i],dp[max(1,c-k)-1]+c)\n    \n    return dp[n]\nn,k=list(map(int,input().split()))\ns=input()\nprint(get(n,k,s))\n", "import sys\ninput = sys.stdin.readline\n\nn,k=list(map(int,input().split()))\ns=input().strip()\n\n\nseg_el=1<<((n+k+1).bit_length())# Segment tree\u306e\u53f0\u306e\u8981\u7d20\u6570\nSEG=[1<<40]*(2*seg_el)# 1-indexed\u306a\u306e\u3067\u3001\u8981\u7d20\u65702*seg_el.Segment tree\u306e\u521d\u671f\u5024\u3067\u521d\u671f\u5316\n\ndef getvalue(n,seg_el):\n    i=n+seg_el\n    ANS=1<<40\n    \n    ANS=min(SEG[i],ANS)\n    i>>=1# \u5b50\u30ce\u30fc\u30c9\u3078\n    \n    while i!=0:\n        ANS=min(SEG[i],ANS)\n        i>>=1\n\n    return ANS\n\ndef updates(l,r,x):# \u533a\u9593[l,r)\u306b\u95a2\u3059\u308bmin\u3092\u8abf\u3079\u308b\n    L=l+seg_el\n    R=r+seg_el\n\n    while L<R:\n        if L & 1:\n            SEG[L]=min(x,SEG[L])\n            L+=1\n\n        if R & 1:\n            R-=1\n            SEG[R]=min(x,SEG[R])\n        L>>=1\n        R>>=1\n\nupdates(n,n+k+1,0)\n\nfor i in range(n-1,-1,-1):\n    if s[i]==\"0\":\n        x=getvalue(i+1,seg_el)\n        updates(i,i+1,x+i+1)\n    else:\n        x=getvalue(i+k+1,seg_el)\n        updates(max(0,i-k),i+k+1,x+i+1)\n    \nprint(getvalue(0,seg_el))\n\n", "n, k = tuple(map(int, input().rstrip().split()))\ns = input().rstrip()\ncur = int((2*pow(10,5)) * (2*pow(10,5) + 1) / 2) + 1\ncost = [0] * (n+1)\ndp = [0]\n\nfor i in range(n, 0, -1):\n    if s[i-1] == '1':\n        cur=i\n    cost[i]=cur\n\n\nfor i in range(1, n+1):\n    dp.append(dp[-1] + i)\n    cs = cost[max(i-k, 1)]\n    if cs <= i+k:\n        dp[i] = min(dp[i], dp[max(1, cs-k)-1]+cs)\n    \nprint(dp[n])\n", "from operator import itemgetter\n\n\nclass SegmentTree():\n    \"\"\"\u4e00\u70b9\u66f4\u65b0\u3001\u533a\u9593\u53d6\u5f97\u30af\u30a8\u30ea\u3092\u305d\u308c\u305e\u308cO(logN)\u3067\u7b54\u3048\u308b\u30c7\u30fc\u30bf\u69cb\u9020\u3092\u69cb\u7bc9\u3059\u308b\n    update: i\u756a\u76ee\u3092val\u306b\u5909\u66f4\u3059\u308b\n    get_min: \u533a\u9593[begin, end)\u306e\u6700\u5c0f\u5024\u3092\u6c42\u3081\u308b\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.INF = 10**18\n        self.size = 1\n        while self.size < n:\n            self.size *= 2\n        self.node = [self.INF] * (2*self.size - 1)\n\n    def update(self, i, val):\n        i += (self.size - 1)\n        self.node[i] = val\n        while i > 0:\n            i = (i - 1) // 2\n            self.node[i] = min(self.node[2*i + 1], self.node[2*i + 2])\n\n    def get_min(self, begin, end):\n        begin += (self.size - 1)\n        end += (self.size - 1)\n        s = self.INF\n        while begin < end:\n            if (end - 1) & 1:\n                end -= 1\n                s = min(s, self.node[end])\n            if (begin - 1) & 1:\n                s = min(s, self.node[begin])\n                begin += 1\n            begin = (begin - 1) // 2\n            end = (end - 1) // 2\n        return s\n\n\nn, k = map(int, input().split())\ns = input()\ninfo = []\nfor i, char in enumerate(s):\n    if char == \"0\":\n        info.append((i, i+1, i+1))\n    else:\n        info.append((max(i-k, 0), min(i+k+1, n), i+1))\ninfo = sorted(info, key = itemgetter(1))\n\nst = SegmentTree(n+1)\nfor begin, end, cost in info:\n    if begin == 0:\n        tmp = min(st.get_min(end - 1, end), cost)\n    else:\n        tmp = min(st.get_min(end - 1, end), st.get_min(begin - 1, end) + cost)\n    st.update(end - 1, tmp)\nprint(st.get_min(end - 1, end))", "from heapq import heappush, heappop\nfrom collections import deque\nN, K = map(int, input().split())\n*B, = map(int, input())\n\nINF = 10**18\nque = deque()\nhq = []\ndp = [INF]*(N+1)\ndp[0] = 0\nfor i in range(N):\n    a = dp[i]\n    while hq and hq[0][1] < i:\n        heappop(hq)\n    if hq:\n        a = min(hq[0][0], a)\n    #print(i, a)\n\n    while que and a <= que[-1][1]:\n        que.pop()\n    que.append((i, a))\n\n    if B[i]:\n        heappush(hq, (que[0][1] + (i+1), i+K+1))\n\n    if que and que[0][0] <= i-K:\n        que.popleft()\n    dp[i+1] = a + (i+1)\nwhile hq and hq[0][1] < N:\n    heappop(hq)\na = dp[N]\nif hq:\n    a = min(hq[0][0], a)\nprint(a)", "n, k = list(map(int, input().split()))\n\na = list(map(str, input().strip()))\n\nans = 0\nimport math\nfrom collections import deque\n\ndp = [math.inf] * (n + 10)\ndp[n + 1] = 0\nnext = [n + 1] * (n + 10)\nnow = deque()\nfor i in range(n):\n    if a[i] == '1':\n        now.append(i + 1)\n    if len(now) == 0:\n        continue\n    if now[0] + k < i + 1:\n        now.popleft()\n    if len(now):\n        next[i + 1] = now[0]\n\ncur = n + 1\nfor i in range(n - 1, -1, -1):\n    if a[i] == '1':\n        cur = i + 1\n    if cur - i - 1 <= k:\n        next[i + 1] = min(next[i + 1], cur)\n\nfor i in range(n, 0, -1):\n    dp[i] = min(dp[i], dp[i + 1] + i)\n    if next[i] != n + 1:\n        dp[max(next[i] - k, 1)] = min(dp[max(next[i] - k, 1)], dp[i + 1] + next[i])\n\nprint(dp[1])\n", "def main():\n    while True:\n        try:\n            n, m = map(int, input().strip().split())\n            s = str(input())\n            print(getAns(n, m, s))\n        except EOFError:\n            break\n\ndef getAns(n, k, s):\n    ans = [0] * (n + 10)\n    \n    s = '0' + s\n    ans[0] = 0\n    lrt = 0\n    for i in range(1, n+1, 1):\n        while (lrt < i and (lrt < i - k or s[lrt]=='0')):\n            lrt += 1\n#        print('nb', s[lrt], i, lrt)\n        ans[i] = ans[max(0, lrt-k-1)]+lrt if s[lrt]=='1' else ans[i-1]+i\n        if s[i] == '1':\n            for j in range(i-1, -1, -1):\n                if s[j] == '1':\n                    break\n                ans[j] = min(ans[j], ans[i])\n                \n#    print(ans)\n    return ans[n]\n\n\ndef __starting_point():\n    main()\n__starting_point()", "\nn, k = list(map(int, input().split()))\nmask = list(map(int, input()))\n\ndp = [0] * (n + 2)\nnxt = [1 << 31] * (n + 2)\n\nfor i in range(n, 0, -1):\n    nxt[i] = i if mask[i - 1] is 1 else nxt[i + 1]\n\nfor i in range(1, n + 1):\n    dp[i] = dp[i - 1] + i\n    idx = nxt[max(1, i - k)]\n    if idx <= i + k:\n        dp[i] = min(dp[i], dp[max(0, idx - k - 1)] + idx)\n\nprint(dp[n])\n\n", "def find(roomcount,radius,string):\n    zero_roomcount=[0]*(roomcount+1)\n    binary_move=1<<1000#\u0441\u0434\u0432\u0438\u0433 \u0434\u0432\u043e\u0438\u0447\u043d\u043e\u0439 \u0435\u0434\u0438\u043d\u0438\u0446\u044b \u043d\u0430 1000 \u0432\u043b\u0435\u0432\u043e \u0438\u043b\u0438 \u043b\u044e\u0431\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\n    for i in range(roomcount,0,-1):\n        if string[i-1]=='1':\n            binary_move=i\n        zero_roomcount[i]=binary_move\n    dp=[0]\n    for i in range(1,roomcount+1):\n        dp.append(dp[-1]+i)\n        c=zero_roomcount[max(i-radius,1)]\n        if c<=i+radius:\n            dp[i]=min(dp[i],dp[max(1,c-radius)-1]+c)  \n    return dp[roomcount]\nroomcount,radius=map(int,input().split())\nstring=input()\nprint(find(roomcount,radius,string))", "n, k = map(int, input().split())\ns = input()\ninf = 10**18\nwho = [-1] * n\nfor i in range(n):\n  if s[i] == '1':\n    for j in range(min(n - 1, i + k), i - 1, -1):\n      if who[j] == -1:\n        who[j] = i\n      else:\n        break\nfor i in range(n):\n  if s[i] == '1':\n    for j in range(i - 1, max(-1, i - k - 1), -1):\n      if who[j] == -1:\n        who[j] = i\n      else:\n        break\ndp = [inf] * (n + 1)\ndp[n] = 0\nfor i in range(n, 0, -1):\n  dp[i - 1] = min(dp[i - 1], dp[i] + i)\n  if who[i - 1] != -1:\n    dp[max(0, who[i - 1] - k)] = min(dp[max(0, who[i - 1] - k)], dp[i] + who[i - 1] + 1)\nprint(dp[0])", "def __starting_point():\n    n, dist = list(map(int, input().split()))\n    light = input().strip()\n    right_cover = 0\n    left_most = [-1]*(n)\n    for idx, ele in enumerate(light):\n        if ele == '1':\n            for i in range(max(right_cover, idx-dist), min(idx + dist + 1, n)):\n                left_most[i] = idx\n            right_cover = idx + dist + 1\n    dp = [0]*(2*n+1)\n    for i in range(n):\n        dp[i] = 1000000000000000000\n\n    for idx in range(n-1, -1, -1):\n        dp[idx] = min(dp[idx+1] + idx + 1, dp[idx])\n        if left_most[idx] != -1:\n            left = left_most[idx]\n            dp[max(left-dist, 0)] = min(dp[idx+1] + left + 1, dp[max(left-dist, 0)])\n            dp[idx] = min(dp[max(left-dist, 0)], dp[idx])\n    print(dp[0])\n\n__starting_point()", "import os\nimport sys\n\n\ndef solve(is_router, k):\n    n = len(is_router)\n    router_stack = [idx + 1 for idx, r in enumerate(is_router) if r == 1][::-1]\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        c = dp[i - 1] + i\n        while router_stack and router_stack[-1] + k < i:\n            router_stack.pop(-1)\n\n        if router_stack and router_stack[-1] - k <= i <= router_stack[-1] + k:\n            t = router_stack[-1]\n            dp[i] = min(t + dp[max(0, t - k - 1)], c)\n        else:\n            dp[i] = c\n\n    return dp[-1]\n\n\ndef pp(input):\n    n, k = list(map(int, input().strip().strip().split()))\n    is_router = list(map(int, input().strip()))\n    print(solve(is_router, k))\n\n\nif \"pydev\" in sys.argv[0]:\n    from string_source import string_source, codeforces_parse\n\n    x = \"\"\"inputCopy\n5 2\n00100\noutputCopy\n3\ninputCopy\n6 1\n000000\noutputCopy\n21\ninputCopy\n4 1\n0011\noutputCopy\n4\ninputCopy\n12 6\n000010000100\noutputCopy\n15\"\"\"\n\n    for q, a in codeforces_parse(x):\n        pp(string_source(q))\n        print(a)\n        print(\"----\")\nelse:\n    pp(sys.stdin.readline)\n", "from collections import deque\n\ndef ans(n,k,a):\n    dp = [0 for i in range(n+1)]\n    q = deque()\n    for i in range(1,n+1):\n        r = None\n        while len(q) > 0:\n            cur = q[0]\n            if i <= cur+k:\n                r = cur\n                break\n            q.popleft()\n        if a[i-1]=='0':\n            if r != None:\n                dp[i] = min(r+dp[max(0,r-k-1)],r+dp[r-1])\n            else:\n                dp[i] = i+dp[i-1]\n        else:\n            q.append(i)\n            if r!=None:\n                dp[i] = min(i+dp[max(0,i-k-1)],r+dp[max(0,r-k-1)],r+dp[r-1])\n            else:\n                dp[i] = min(i+dp[max(0,i-k-1)],i+dp[i-1])\n    return dp[n]    \n\n\nn,k = list(map(int,input().split(\" \")))\na = input()\nout = ans(n,k,a)\nprint(out)", "from collections import deque\n\ndef ans(n,k,a):\n    dp = [0 for i in range(n+1)]\n    q = deque()\n    for i in range(1,n+1):\n        r = None\n        while len(q) > 0:\n            cur = q[0]\n            if i <= cur+k:\n                r = cur\n                break\n            q.popleft()\n        if a[i-1]=='0':\n            if r != None:\n                dp[i] = min(r+dp[max(0,r-k-1)],r+dp[r-1])\n            else:\n                dp[i] = i+dp[i-1]\n        else:\n            q.append(i)\n            if r!=None:\n                dp[i] = min(i+dp[max(0,i-k-1)],r+dp[max(0,r-k-1)],r+dp[r-1])\n            else:\n                dp[i] = min(i+dp[max(0,i-k-1)],i+dp[i-1])\n    return dp[n]    \n\n\nn,k = list(map(int,input().split(\" \")))\na = input()\nout = ans(n,k,a)\nprint(out)  ", "n, k = (int(i) for i in input().split())\nstring = input()\n\nINF = 10**100\ncache = [INF] * n\ndef getVal(idx):\n    if idx < 0 or cache[idx] == INF:\n        return 0\n    return cache[idx]\n\nlast_idx = 0\nreached_end = False\nfor i in range(n):\n    if string[i] == '0':\n        new = getVal(i-1)+i+1\n        cache[i] = min(cache[i], new)\n    else:\n        new = getVal(i-1-k)+i+1\n        if new < cache[i]:\n            cache[i] = new\n            last_idx = 0\n\n        if reached_end:\n            continue\n        end = i+k+1\n        if end >= n:\n            end = n\n            reached_end = True\n        for j in range(max(last_idx, i-k), end):\n            cache[j] = min(new, cache[j])\n        last_idx = end\nprint(cache[n-1])\n"]