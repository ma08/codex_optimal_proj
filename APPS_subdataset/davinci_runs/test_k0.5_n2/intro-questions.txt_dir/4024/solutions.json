["import sys\nimport itertools\n\ninputs = sys.stdin.read().split()\nlen_string = int(inputs[0])\ndesired_size = int(inputs[1])\nstring = inputs[2]\n\nsize = 0\ncost = 0\ncur_set = set()\ncur_set.add(string)\nfor i in range(len_string, -1, -1):\n    cur_size = len(cur_set)\n    if size+cur_size >= desired_size:\n        cost += (desired_size-size)*(len_string-i)\n        size = desired_size\n        break\n    cost += cur_size*(len_string-i)\n    size += cur_size\n    \n    new_set = set()\n    for substr in cur_set:\n        for i in range(len(substr)):\n            new_set.add(substr[:i]+substr[(i+1):])\n    cur_set = new_set\n\nif size >= desired_size: sys.stdout.write(str(cost)+\"\\n\")\nelse: sys.stdout.write(\"-1\\n\")", "\nimport queue\n\nn, k = [int(el) for el in input().split()]\ns = input()\n\n\ndef sol_e(line, set_size):\n    unique_set = {line}\n    cost = 0\n    lines_queue = queue.Queue()\n    lines_queue.put(line)\n    cur_set_size = 1\n    while cur_set_size < set_size:\n        cur_line = lines_queue.get()\n        for index in range(len(cur_line)):\n            new_line = cur_line[:index]+cur_line[(index+1):]\n            if new_line not in unique_set:\n                unique_set.add(new_line)\n                cost += len(line)-len(new_line)\n                cur_set_size += 1\n                lines_queue.put(new_line)\n                if cur_set_size == set_size:\n                    return cost\n        if lines_queue.empty():\n            return -1\n    return cost\n\n\nprint(sol_e(s, k))\n", "n, k = list(map(int, input().split()))\ns = input()\na = set()\nk -= 1\nq = [s]\ni = 0\nans = 0\nwhile i < len(q) and k > 0:\n    for j in range(len(q[i])):\n        new = q[i][:j] + q[i][j + 1:]\n        if new not in a:\n            a.add(new)\n            q.append(new)\n            ans += n - len(q[i]) + 1\n            k -= 1\n            if k == 0:\n                print(ans)\n                return\n    i += 1\nif k == 0:\n    print(ans)\nelse:\n    print(-1)\n", "def sol(a,k):\n    n=len(a)\n    if(k==0):return 1\n    if(k==1):\n        v=set()\n        for x in a:\n            v.add(x)\n        return len(v)\n    if(n<k or n<1 or k<1):\n        return 0\n    if(n==k):\n        return 1\n    sz=max(3000,n)\n    v1=[0]*sz\n    v2=[0]*sz\n    v3=[0]*sz\n    v2[n-1]=1\n    v3[a[n-1]-1]=1\n    for i in range(n-2,-1,-1):\n        if(i<0):break\n        v2[i]=v2[i+1]\n        if(v3[a[i]-1]==0):\n            v2[i]+=1\n            v3[a[i]-1]=1\n    for j in range(1,k):\n        v3=[0]*sz\n        v1[n-1]=0\n        for i in range(n-2,-1,-1):\n            v1[i]=v1[i+1]\n            v1[i]=v1[i]+v2[i+1]\n            v1[i] = v1[i] - v3[a[i] - 1]\n            v3[a[i] - 1] = v2[i + 1]\n        v2=v1.copy()\n    return v1[0]\nn,k=list(map(int,input().split()))\ns=input()\nar=[]\nfor x in s:\n    ar.append(ord(x))\nans=0\ncur=n\nwhile cur>=0:\n    mx=min(k,sol(ar,cur))\n    k-=mx\n    ans+=(n-cur)*mx\n    cur-=1\nif(k!=0):\n    print(-1)\nelse:\n    print(ans)\n", "from queue import Queue\nstack = Queue()\n\nn, k = list(map(int, input().split()))\ns = list(input())\n\nk -= 1\na = set()\nanswer = 0\n\nstack.put(list(s))\n\nwhile not stack.empty():\n\tnow = stack.get_nowait()\n\tnew = now[:]\n\tcan = []\n\tfor i in range(len(now)):\n\t\tif k:\n\t\t\tnew[i] = ''\n\t\t\tword = ''.join(new)\n\t\t\tif word not in a:\n\t\t\t\ta.add(word)\n\t\t\t\tanswer += n - len(word)\n\t\t\t\tcan.append(word)\n\t\t\t\tk -= 1\n\n\t\tnew[i] = now[i]\n\tif k:\n\t\tfor word in can:\n\t\t\tstack.put(list(word))\n\nif k > 0:\n\tprint(-1)\nelse:\n\tprint(answer)\n", "import sys\ninput = sys.stdin.readline\n\nn,W=list(map(int,input().split()))\ns=input().strip()\n\nNEXTLIST=[[n]*26 for i in range(n+1)]\n\nfor i in range(n-1,-1,-1):\n    for j in range(26):\n        NEXTLIST[i][j]=NEXTLIST[i+1][j]\n    NEXTLIST[i][ord(s[i])-97]=i\n\nDP=[[0]*(n+1) for i in range(n+1)]\n\nDP[0][0]=1\n\nfor i in range(n):\n    for j in range(26):\n        if NEXTLIST[i][j]!=n:\n            for k in range(n):\n                DP[NEXTLIST[i][j]+1][k+1]+=DP[i][k]\n\n#print(DP)\n\nHLIST=[0]*(n+1)\n\nfor i in range(n+1):\n    for j in range(n+1):\n        HLIST[j]+=DP[i][j]\n\n#print(HLIST)\n\nANS=0\nfor i in range(n,-1,-1):\n    #print(i,W)\n    if W>HLIST[i]:\n        ANS+=(n-i)*HLIST[i]\n        W-=HLIST[i]\n    else:\n        ANS+=W*(n-i)\n        print(ANS)\n        return\n\nelse:\n    print(-1)\n", "\ndef __starting_point():\n    n, k = list(map(int, input().split()))\n    aa = list(input())\n    st = {\"\".join(aa)}\n    arr = [aa]\n    w = 0\n    c = 0\n    cst = 0\n    while len(arr) < k and w < len(arr):\n        wrd = arr[w][:c] + arr[w][c + 1:]\n        wrds = \"\".join(wrd)\n        if wrds not in st:\n            st.add(wrds)\n            arr.append(wrd)\n            cst += n - len(wrd)\n\n        c += 1\n        if c >= len(arr[w]):\n            c = 0\n            w += 1\n\n    if len(arr) < k:\n        print(-1)\n    else:\n        print(cst)\n\n__starting_point()", "arr = input()\nN,K = [int(num) for num in arr.split(' ')]\n\nstring = input()\n\nseq = [string]\nrecord = {}\nrecord[string] = 1\ncount = 1\n\n\nwhile seq and count<=105:\n    gen_d = seq.pop(0)\n    #print(gen_d)\n    for k in range(len(gen_d)):\n        r = gen_d[:k] + gen_d[(k+1):]\n        if r not in record:\n            record[r] = 1\n            seq.append(r)\n            count += 1\n\nrecord[''] = 1\n\nG = []\nfor s in record:\n    G.append([N-len(s),s])\n\nG.sort()\n#print(G)\nres = 0\nif len(G)<K:\n    print(-1)\nelse:\n    for i in range(K):\n        res += G[i][0]\n    print(res)", "from collections import deque\nn, k = list(map(int, input().split()))\ns = input()\nque = deque()\nque.append(s)\nd = {}\nnum = 0\ncost = 0\nwhile que:\n    q = que.popleft()\n    if q not in d:\n        cost += n - len(q)\n        num += 1\n        if num == k:\n            print(cost)\n            return\n        d[q] = 1\n        for j in range(len(q)):\n            t = q[:j] + q[j + 1:]\n            if t not in d:\n                que.append(t)\n\nprint(-1)\n\n", "# @author \n\nimport sys\n\nclass ESubsequencesEasyVersion:\n    def solve(self):\n        n, k = [int(_) for _ in input().split()]\n        s = input()\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        dp[0][0] = 1\n        last = {key : -1 for key in (chr(x) for x in range(ord('a'), ord('z') + 1))}\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n            for j in range(1, i + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] - (dp[last[s[i - 1]]][j - 1] if last[s[i - 1]] != -1 else 0)\n            last[s[i - 1]] = i - 1\n\n        ans = 0\n        tot = 0\n        for sz in range(n, -1, -1):\n            ans += min(k - tot, dp[n][sz]) * (n - sz)\n            tot = min(k, tot + dp[n][sz])\n            if tot == k:\n                break\n        \n        if tot >= k:\n            print(ans)\n        else:\n            print(-1)\n\nsolver = ESubsequencesEasyVersion()\ninput = sys.stdin.readline\n\nsolver.solve()\n", "from collections import deque\nn,m=list(map(int,input().split()))\ns=input()\nd=deque([s])\nans=1\nan=0\ndd={}\nwhile d and ans<m:\n    # print(d)\n    p=d.popleft()\n    dd[p]=1\n    k=len(p)\n    for i in range(k):\n        pp=p[:i] + p[i+1:]\n        # print(pp,dd)\n        if (pp not in dd):\n            an+=(n-(k-1))\n            ans+=1\n            dd[pp]=1\n            d.append(pp)\n        if ans==m:\n            print(an)\n            return\n            \n    # print(d)\n# print(an,ans)    \nif ans==m:\n    print(an)\nelse:\n    print(-1)\n            \n        \n    \n    \n", "import sys\nfrom math import ceil\n\nn, k, = list(map(int, sys.stdin.readline().strip().split()))\ns = sys.stdin.readline().strip()\n\nsets = [{s}]\nanz = 1\nkosten = 0\npreis = 0\nlaenge0 = laenge = len(s)\n\n# one step:\nwhile (anz < k) and laenge:\n  laenge -= 1\n  kuerzer = []\n  for w in sets[-1]:\n    w = list(w)\n    dazu = [''.join(w[:i] + w[i+1:]) for i in range(len(w))]\n    kuerzer += dazu\n\n  sets.append(set(kuerzer))\n  anz += len(sets[-1])\n\nif anz<k:\n  print(-1)\nelif k == 1:\n  print(0)\nelse:\n  kosten, bisher = 0, 0\n  for preis, it in enumerate(sets[:-1]):\n    laenge = len(it)\n    bisher += laenge\n    kosten += laenge * preis\n  kosten += (k-bisher) * (preis+1)\n  print(kosten)\n", "line1 = input().split(' ')\nn = int(line1[0])\nk = int(line1[1])\ns = list(input())\n\ndp = [101*[0] for i in range(101)]\nlast = 26*[-1]\n\nfor i in range(n+1):\n    dp[0][i] = 1\n\nfor l in range(1, n+1):\n    dp[l][0] = 0\n    for c in range(26):\n        last[c] = -1\n    for i in range(1, n+1):\n        dp[l][i] = dp[l-1][i-1] + dp[l][i-1]\n        if last[ord(s[i-1])-ord('a')] != -1:\n            dp[l][i] -= dp[l-1][last[ord(s[i-1])-ord('a')]-1]\n        last[ord(s[i-1])-ord('a')] = i\n\ni = 0\nres = 0\nwhile i <= n and k >= 0:\n    c = min(k, dp[n-i][n])\n    k -= c\n    res += c * i\n    i += 1\nif k > 0:\n    print(-1)\nelse:\n    print(res)\n", "from sys import stdin\n\ndef subseq(xs, n, m):\n    if n > 1:\n        sl = subseq(xs[:n//2], n//2, m)\n        sr = subseq(xs[n//2:], n - n//2, m)\n        return combine(sl, sr, m)\n    return xs\n\ndef combine(sl, sr, m):\n    seq = {s1+s2 for s1 in sl for s2 in sr}.union(sl, sr)\n    seql = sorted(seq, key=len, reverse=True) [:m]\n    return seql\n\nn,k = map(int, input().split())\ns = input()\n\nseqs = subseq(s, n, k)\nif len(seqs) < k-1:\n    print (-1)\nelse:\n    slengths = map((lambda x: n - len(x)), seqs)\n    result = sum(slengths)\n    if len(seqs) == k-1:\n        result += n\n    print(result)", "n,k=list(map(int,input().split()))\ns=input()\nst=[set() for i in range(n+1)]\nst[n].add(s)\nc=1\nk-=1\nans=0\nfor i in range(n,0,-1):\n    for w in st[i]:\n        for j in range(i):\n            st[i-1].add(w[:j]+(w[j+1:] if j!=i-1 else ''))\n    sz=len(st[i-1])\n    if k<sz:\n        ans+=(n-i+1)*k\n        k=0\n        break\n    else:\n        ans+=(n-i+1)*sz\n        k-=sz\n    #print(i,k,ans)\n    if k<0:\n        break\nif k>0:\n    print(-1)\nelse:\n    print(ans)\n#print(k,ans,st)\n", "N, K = map(int, input().split())\npre = [input()]\nans = 0\nk = 1\nf = 0\nwhile True:\n    if k >= K:\n        print(ans)\n        break\n    if len(pre) == 0:\n        print(-1)\n        break\n    post = []\n    for s in pre:\n        for i in range(len(s)):\n            t = s[:i] + s[i+1:]\n            if t not in post:\n                k += 1\n                post.append(t)\n                ans += N-len(t)\n                if k >= K:\n                    print(ans)\n                    f = 1\n                    break\n        if f:\n            break\n    if f:\n        break\n    pre = post", "n, tt = list(map(int, input().split()))\ns = input()\n\ndp = [[0]*(n + 1) for i in range(n+1)]\n\nfor c in range(n+1):\n\tdp[0][c] = 1\n\nlast = [-1]*26\n\nfor c in range(1, n + 1):\n\tk = ord(s[c-1]) - ord('a')\n\tfor r in range(1, n+1):\n\t\tdp[r][c] = dp[r][c-1] + dp[r-1][c-1]\n\tif last[k] == -1:\n\t\tlast[k] = c - 1\n\t\tcontinue\n\telse:\n\t\tp = last[k]\n\t\tfor r in range(1, n+1):\n\t\t\tdp[r][c] = dp[r][c] - dp[r-1][p]\n\t\tlast[k] = c-1\n\nsu, ans, t = 0, 0, 0\nfor r in range(n+1):\n\tsu = su + dp[r][n]\nif su < tt:\n\tans = -1\nelse:\n\tfor i in range(n, -1, -1):\n\t\tr = min(tt, dp[i][n])\n\t\tans += t*r\n\t\ttt -= r\n\t\tt += 1\n\nprint(ans) \n", "\nn, k = map(int, input().split())\ns = input()\na = set()\nk -= 1\nq = [s]\ni = 0\nans = 0\nwhile i < len(q) and k > 0:\n    for j in range(len(q[i])):\n        new = q[i][:j] + q[i][j + 1:]\n        if new not in a:\n            a.add(new)\n            q.append(new)\n            ans += n - len(q[i]) + 1\n            k -= 1\n            if k == 0:\n                print(ans)\n                return\n    i += 1\nif k == 0:\n    print(ans)\nelse:\n    print(-1)", "from sys import stdin\nfrom collections import deque\n\nn, k = list(map(int, input().split()))\ns = input()\nque = deque()\nque.append(s)\nd = {}\nnum = 0\ncost = 0\nwhile que:\n    q = que.popleft()\n    if q not in d:\n        cost += n - len(q)\n        num += 1\n        if num == k:\n            print(cost)\n            return\n        d[q] = 1\n        for j in range(len(q)):\n            t = q[:j] + q[j + 1:]\n            if t not in d:\n                que.append(t)\n\nprint(-1)\n            \n    \n        \n", "# your code goes here\nn,k=map(int,input().split())\ns=input()\nc=0\nq=[s]\nd=set()\nls=0\nwhile q:\n\tp=q.pop(0)\n\tif p not in d:\n\t\tls+=1\n\t\tc+=(n-len(p))\n\t\tif ls==k:\n\t\t\tbreak\n\t\td.add(p)\n\t\tfor i in range(len(p)):\n\t\t\ttemp=p[:i]+p[i+1:]\n\t\t\tif temp not in d:\n\t\t\t\tq.append(temp)\n\t\t\t\nif ls==k:\n\tprint(c)\nelse:\n\tprint(-1)", "# your code goes here\nn,k=map(int,input().split())\ns=input()\nc=0\nq=[s]\nd=set()\nls=0\nwhile q:\n\tp=q.pop(0)\n\tif p not in d:\n\t\tls+=1\n\t\tc+=(n-len(p))\n\t\tif ls==k:\n\t\t\tbreak\n\t\td.add(p)\n\t\tfor i in range(len(p)):\n\t\t\ttemp=p[:i]+p[i+1:]\n\t\t\tif temp not in d:\tq.append(temp)\n\t\t\t\nif ls==k:\tprint(c)\nelse:\tprint(-1)", "from itertools import combinations\n\n\ndef main():\n    n, k = list(map(int, input().split()))\n    s = input()\n    lenf = len\n    l_prev = {s}\n    curS = 1\n    cost = 0\n    if k == 1:\n        print(0)\n        return\n    for curlen in range(n - 1, -1, -1):\n        l = set()\n        for l_elem in l_prev:\n            for v in combinations(l_elem, curlen):\n                v = ''.join(v)\n                if v in l:\n                    continue\n                l.add(v)\n                curS += 1\n                cost += n - curlen\n                if curS == k:\n                    print(cost)\n                    return\n        l_prev = l\n    print(-1)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = map(int, input().split(' '))\ns = input()\ndp = [[0] * (n + 1) for _ in range(n + 1)]\ndp[0][0] = 1\nfor l in range(0, n):\n    for i in range(l, n + 1):\n        used = [False] * 26\n        for j in range(i + 1, n + 1):\n            ch = ord(s[j - 1]) - ord('a')\n            if not used[ch]:\n                dp[l + 1][j] += dp[l][i]\n                used[ch] = True\ntotal = 0\nfor l in range(n, -1, -1):\n    sums = sum(dp[l])\n    if sums >= k:\n        total += (n - l) * k\n        k = 0\n        break\n    total += (n - l) * sums\n    k -= sums\nif k > 0:\n    total = -1\nprint(total)"]