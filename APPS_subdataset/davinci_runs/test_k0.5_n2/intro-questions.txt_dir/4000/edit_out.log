2022-03-30 20:52:57.175249 num operations 2
2022-03-30 20:52:57.175274 size on input set 1
2022-03-30 20:53:03.093584 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef get_distance(tree, root, node):  # get distance from node to root\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]  # lca[i][j] = lca(i, j)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)  # best nodes\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648687977,
  "object": "edit"
}
2022-03-30 20:53:03.093957 fix spelling mistakes 2 ['\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef get_distance(tree, root, node):  # get distance from node to root\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]  # lca[i][j] = lca(i, j)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)  # best nodes\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 20:53:03.094043 size on output set 2
2022-03-30 20:53:03.094054 size on input set 2
2022-03-30 20:53:09.089623 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648687983,
  "object": "edit"
}
2022-03-30 20:53:09.089892 fix syntax errors 2 ['\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == "__main__":\n    main()\n', '\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 20:53:12.741914 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648687989,
  "object": "edit"
}
2022-03-30 20:53:12.742448 fix syntax errors 2 ['\n\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == "__main__":\n    main()\n', '\ndef get_distance(tree, root, node):\n    dist = 0\n    while node != root:\n        dist += 1\n        node = tree[node]\n    return dist\n\ndef find_lca(tree, root, node1, node2):  # find lowest common ancestor\n    dist1 = get_distance(tree, root, node1)\n    dist2 = get_distance(tree, root, node2)\n    if dist1 < dist2:\n        node1, node2 = node2, node1\n        dist1, dist2 = dist2, dist1\n    while dist1 > dist2:\n        node1 = tree[node1]\n        dist1 -= 1\n    while node1 != node2:\n        node1 = tree[node1]\n        node2 = tree[node2]\n    return node1\n\ndef solve(n, tree):\n    root = 1\n    tree = [0] + tree\n    lca = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            lca[i][j] = lca[j][i] = find_lca(tree, root, i, j)\n    max_edges = 0\n    best_nodes = (0, 0, 0)\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                edges = get_distance(tree, root, i) + get_distance(tree, root, j) + get_distance(tree, root, k) - get_distance(tree, root, lca[i][j]) - get_distance(tree, root, lca[j][k]) - get_distance(tree, root, lca[i][k])\n                if edges > max_edges:\n                    max_edges = edges\n                    best_nodes = (i, j, k)\n    return max_edges, best_nodes\n\ndef main():\n    n = int(input())\n    tree = [0] * n\n    for _ in range(n-1):\n        a, b = map(int, input().split())\n        tree[b-1] = a\n    max_edges, best_nodes = solve(n, tree)\n    print(max_edges)\n    print(*best_nodes)\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 20:53:12.742560 size on output set 3
2022-03-30 20:53:12.742578 num operations 2
2022-03-30 20:53:12.742586 size on input set 1
2022-03-30 20:53:26.213583 fix spelling mistakes {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def dfs(v, p=None):\n        ret = 1\n        for u in adj[v]:\n            if u == p:\n                continue\n            ret += dfs(u, v)\n        return ret\n\n    def solve():\n        a, b = None, None\n        for i in range(1, n + 1):\n            if len(adj[i]) == 1:\n                a = i\n                break\n        for i in range(1, n + 1):\n            if len(adj[i]) == 1:\n                b = i\n                break\n        if a is None or b is None:\n            return -1, -1, -1\n        return a, b, n - dfs(a) - dfs(b)\n\n    a, b, c = solve()\n    print(c)\n    print(a, b, c)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n):\n        if a[i] > b[i]:\n            ans += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n        else:\n            ans += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        if a[i] > 0:\n            ans += a[i]\n            b[i + 1] -= a[i]\n            a[i] = 0\n        if b[i] > 0:\n            ans += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1648687992,
  "object": "edit"
}
2022-03-30 20:53:26.213822 fix spelling mistakes 2 ['\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        adj[a].append(b)\n        adj[b].append(a)\n\n    def dfs(v, p=None):\n        ret = 1\n        for u in adj[v]:\n            if u == p:\n                continue\n            ret += dfs(u, v)\n        return ret\n\n    def solve():\n        a, b = None, None\n        for i in range(1, n + 1):\n            if len(adj[i]) == 1:\n                a = i\n                break\n        for i in range(1, n + 1):\n            if len(adj[i]) == 1:\n                b = i\n                break\n        if a is None or b is None:\n            return -1, -1, -1\n        return a, b, n - dfs(a) - dfs(b)\n\n    a, b, c = solve()\n    print(c)\n    print(a, b, c)\n\n\nif __name__ == "__main__":\n    main()\n', "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n):\n        if a[i] > b[i]:\n            ans += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n        else:\n            ans += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        if a[i] > 0:\n            ans += a[i]\n            b[i + 1] -= a[i]\n            a[i] = 0\n        if b[i] > 0:\n            ans += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-03-30 20:53:26.213861 size on output set 2
2022-03-30 20:53:26.213868 size on input set 2
2022-03-30 20:53:33.029549 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "def main():\n    # \u5165\u529b\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    # \u8a08\u7b97\n\n    ans = 0\n    for i in range(n):\n        if a[i] > b[i]:\n            ans += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n        else:\n            ans += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        if a[i] > 0:\n            ans += a[i]\n            b[i + 1] -= a[i]\n            a[i] = 0\n        if b[i] > 0:\n            ans += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n    print(ans)\n    # \u51fa\u529b\n\n\nif __name__ == '__main__':\n    main()\n"
    },
    {
      "index": 1,
      "text": "def main(n, a, b):\n    # n = int(input())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n):\n        if a[i] > b[i]:\n            ans += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n        else:\n            ans += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        if a[i] > 0:\n            ans += a[i]\n            b[i + 1] -= a[i]\n            a[i] = 0\n        if b[i] > 0:\n            ans += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
    }
  ],
  "created": 1648688006,
  "object": "edit"
}
2022-03-30 20:53:33.029727 fix syntax errors 2 ["def main():\n    # 入力\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    # 計算\n\n    ans = 0\n    for i in range(n):\n        if a[i] > b[i]:\n            ans += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n        else:\n            ans += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        if a[i] > 0:\n            ans += a[i]\n            b[i + 1] -= a[i]\n            a[i] = 0\n        if b[i] > 0:\n            ans += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n    print(ans)\n    # 出力\n\n\nif __name__ == '__main__':\n    main()\n", "def main(n, a, b):\n    # n = int(input())\n    # a = list(map(int, input().split()))\n    # b = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(n):\n        if a[i] > b[i]:\n            ans += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n        else:\n            ans += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        if a[i] > 0:\n            ans += a[i]\n            b[i + 1] -= a[i]\n            a[i] = 0\n        if b[i] > 0:\n            ans += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"]
2022-03-30 20:53:42.241589 fix syntax errors {
  "choices": [
    {
      "index": 0,
      "text": "\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n\n    def dfs(v, p=None):\n        ret = 1\n        for u in adj[v]:\n            if u == p:\n                continue\n            ret += dfs(u, v)\n        return ret\n\n    def solve():\n        a, b = None, None\n        for i in range(n):\n            if len(adj[i]) == 1:\n                a = i\n                break\n        for i in range(n):\n            if len(adj[i]) == 1:\n                b = i\n                break\n        if a is None or b is None:\n            return -1, -1, -1\n        return a, b, n - dfs(a) - dfs(b)\n\n    a, b, c = solve()\n    print(c)\n    print(a, b, c)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "index": 1,
      "text": "import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    pass\n\n\nif __name__ == \"__main__\":\n    main()\n"
    }
  ],
  "created": 1648688013,
  "object": "edit"
}
2022-03-30 20:53:42.241701 fix syntax errors 2 ['\ndef main():\n    n = int(input())\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n\n    def dfs(v, p=None):\n        ret = 1\n        for u in adj[v]:\n            if u == p:\n                continue\n            ret += dfs(u, v)\n        return ret\n\n    def solve():\n        a, b = None, None\n        for i in range(n):\n            if len(adj[i]) == 1:\n                a = i\n                break\n        for i in range(n):\n            if len(adj[i]) == 1:\n                b = i\n                break\n        if a is None or b is None:\n            return -1, -1, -1\n        return a, b, n - dfs(a) - dfs(b)\n\n    a, b, c = solve()\n    print(c)\n    print(a, b, c)\n\n\nif __name__ == "__main__":\n    main()\n', 'import sys\n\ninput = sys.stdin.readline\n\n\ndef main():\n    pass\n\n\nif __name__ == "__main__":\n    main()\n']
2022-03-30 20:53:42.241760 size on output set 4
