["import sys\ninput = sys.stdin.readline\n\nn,m,D=list(map(int,input().split()))\nE=[list(map(int,input().split())) for i in range(m)]\n\n\nEDGELIST=[[] for i in range(n+1)]\n\nfor x,y in E:\n    EDGELIST[x].append(y)\n    EDGELIST[y].append(x)\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nONE=EDGELIST[1]\n\nfor x,y in E:\n    if x==1 or y==1:\n        continue\n    Union(x,y)\n\nONEU=[find(e) for e in ONE]\n\nif len(set(ONEU))>D or D>len(ONE):\n    print(\"NO\")\n    return\nelse:\n    print(\"YES\")\n\nUSED=set()\nANS=[]\nfrom collections import deque\nQUE=deque()\ncheck=[0]*(n+1)\ncheck[1]=1\n\nfor j in range(len(ONE)):\n    if find(ONE[j]) in USED:\n        continue\n    else:\n        ANS.append([1,ONE[j]])\n        QUE.append(ONE[j])\n        USED.add(find(ONE[j]))\n        check[ONE[j]]=1\n        D-=1\n\nj=0\nfor i in range(D):\n    while check[ONE[j]]==1:\n        j+=1\n    ANS.append([1,ONE[j]])\n    QUE.append(ONE[j])\n    check[ONE[j]]=1\n    \n\nwhile QUE:\n    x=QUE.popleft()\n    check[x]=1\n\n    for to in EDGELIST[x]:\n        if check[to]==0:\n            ANS.append([x,to])\n            QUE.append(to)\n            check[to]=1\n        \n#print(ANS)\nfor x,y in ANS:\n    print(x,y)\n\n\n    \n    \n    \n", "'''input\n7 10 2\n7 1\n1 3\n5 2\n6 1\n6 5\n3 7\n5 7\n1 2\n5 1\n1 4\n'''\nimport sys\nfrom collections import defaultdict as dd\nimport heapq\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nn,m,d=ri()\n\nt=dd(list)\n\nr=[0 for i in range(n+1)]\nvis=[0 for i in range(n+1)]\n\n\nfor i in range(m):\n\tu,v=ri()\n\tt[u].append(v)\n\tt[v].append(u)\n\nfor i in range(n+1):\n\tr[i]=len(t[i])\n\nfinal=[]\n\ndef bfs(sor):\n\ts=[sor]\n\tvis[sor]=1\n\twhile s:\n\t\tk=s.pop(-1)\n\t\tfor i in t[k]:\n\t\t\tif vis[i]==0:\n\t\t\t\tvis[i]=1\n\t\t\t\ts.append(i)\n\t\t\t\t#final.append((k,i))\n\n\n\ndef bfs2(sor):\n\t\n\ts=[sor]\n\tvis[sor]=1\n\twhile s:\n\t\tk=s.pop(-1)\n\t\tfor i in t[k]:\n\t\t\tif vis[i]==0:\n\t\t\t\tvis[i]=1\n\t\t\t\ts.append(i)\n\t\t\t\tfinal.append((k,i))\n\nnow=[]\n\nfor i in t[1]:\n\tnow.append(i)\n\nlk=0\n\ngo=dd(int)\nvis[1]=1\n\nfor i in range(len(t[1])):\n\tif vis[t[1][i]]==0:\n\t\tbfs(t[1][i])\n\t\tgo[t[1][i]]=1\n\t\tlk+=1\n\n\nif lk<=d:\n\ttemp=t[1][:]\n\tt[1]=[]\n\tfor i in go:\n\t\tt[1].append(i)\n\t\tt[i].append(1)\n\t\td-=1\n\n\tfor i in temp:\n\t\tif go[i]==1:\n\t\t\tpass\n\t\telse:\n\t\t\tif d!=0:\n\t\t\t\tt[1].append(i)\n\t\t\t\tt[i].append(1)\n\t\t\t\td-=1\n\tif d!=0:\n\t\tprint(\"NO\")\n\telse:\n\t\tvis=[0 for i in range(n+1)]\n\t\tbfs2(1)\n\t\t#print(vis,t)\n\t\tif sum(vis)==n:\n\t\t\tprint(\"YES\")\n\t\t\tfor i in final:\n\t\t\t\tprint(*i)\n\t\telse:\n\t\t\tprint(\"NO\")\nelse:\n\tprint(\"NO\")\n\n", "from collections import deque\nn, m, d = map(int, input().split())\ng = [[] for i in range(n + 1)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\n\ndef bfs(init, c, p=False):\n    nonlocal color\n    q = deque(init)\n    while len(q) > 0:\n        u = q.popleft()\n        for v in g[u]:\n            if color[v] < 0:\n                if p:\n                    print(u, v)\n                q.append(v)\n                color[v] = c\n\ncolor = [-1 for i in range(n + 1)]\ncolor[1] = 0\n\nc = 0\nfor x in g[1]:\n    if color[x] < 0:\n        color[x] = c\n        bfs([x], c)\n        c += 1\n\nif len(g[1]) < d or d < c:\n    print('NO')\nelse: \n    is_kid = [False for x in g[1]]\n    kids = []\n    \n    picked = [False for i in range(c)]\n    for i in range(len(g[1])):\n        x = g[1][i]\n        if not picked[color[x]]:\n            is_kid[i] = True\n            kids.append(x)\n            picked[color[x]] = True\n\n    extra = d - c\n    for i in range(len(g[1])):\n        x = g[1][i]\n        if extra == 0:\n            break\n        if not is_kid[i]:\n            is_kid[i] = True\n            kids.append(x)\n            extra -= 1\n\n    color = [-1 for i in range(n + 1)]\n    color[1] = 0\n\n    print('YES')\n    for x in kids:\n        print(1, x)\n        color[x] = 0\n\n    bfs(kids, 0, True)", "import sys\n\nroot = 0\nn, m, D = map(int, input().split())\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\n\nif len(g[root]) < D:\n    print('NO')\n    return\n\nuf = [-1 for _ in range(n)]\n\ndef find(uf, u):\n    if uf[u] < 0:\n        return u\n    else:\n        ans = find(uf, uf[u])\n        uf[u] = ans\n        return ans\n\ndef merge(uf, u, v):\n    pu = find(uf, u)\n    pv = find(uf, v)\n    if pu == pv:\n        return\n    if uf[pu] > uf[pv]:\n        pu, pv = pv, pu\n    uf[pu] += uf[pv]\n    uf[pv] = pu\n\nans = []\nin_tree = {}\nfor v in g[root]:\n    merge(uf, root, v)\nfor i in range(n):\n    for v in g[i]:\n        if find(uf, i) != find(uf, v):\n            merge(uf, i, v)\n            ans.append((i+1, v+1))\n            in_tree[(min(i, v), max(i, v))] = True\n\nchildren = [[] for _ in range(n)]\npar = [-1 for _ in range(n)]\n\ndef dfs(s, super_p):\n    st = [(s, root)]\n    while len(st) > 0:\n        u, p = st.pop()\n        children[super_p].append(u)\n        merge(par, u, super_p)\n        for v in g[u]:\n            if v != p and (min(u, v), max(u, v)) in in_tree:\n                st.append((v, u))\n\nfor v in g[root]:\n    dfs(v, v)\n\nsz = len(g[root])\nfor i in range(len(g[root])):\n    found = False\n    u = g[root][i]\n    if sz > D:\n        for v in children[u]:\n            for w in g[v]:\n                if not found and w != root and find(par, w) != find(par, v) and (min(v, w), max(v, w)) not in in_tree:\n                    sz -= 1\n                    found = True\n                    merge(par, v, w)\n                    ans.append((v+1, w+1))\n                    in_tree[(min(v, w), max(v, w))] = True\n    if not found:\n        ans.append((root+1, u+1))\n\nif sz != D:\n    print('NO')\nelse:\n    print('YES')\n    print('\\n'.join(map(lambda x: '{} {}'.format(x[0], x[1]), ans)))", "def dfs(s):\n\tstk,cnt=[],[]\n\tstk.append(s)\n\tcnt.append(0)\n\twhile (len(stk)>0):\n\t\ts=stk[-1]\n\t\tll=cnt[-1]\n\t\tvisit[s]=1\n\t\tflag=1\n\t\tfor j in range(ll,len(adj[s]),1):\n\t\t\tif visit[adj[s][j]]==0:\n\t\t\t\tcnt[-1]=j+1\n\t\t\t\tstk.append(adj[s][j])\n\t\t\t\tcnt.append(0)\n\t\t\t\tflag=0\n\t\t\t\tbreak\n\t\tif flag:\n\t\t\tstk.pop()\n\t\t\tcnt.pop()\n\nn,m,d=map(int,input().split())\nadj=[0]*(n+1)\nfor i in range(n+1):\n\tadj[i]=[]\nfor i in range(m):\n\tx,y=map(int,input().split())\n\tadj[x].append(y)\n\tadj[y].append(x)\nvisit=[0]*(n+1)\nvisit[1]=1\nans=[0]*m\nct=0\nmark=[0]*(n+1)\nmark[1]=1\nfor l in range(len(adj[1])):\n\ti=adj[1][l]\n\tif visit[i]==0:\n\t\tdfs(i)\n\t\tans[ct]=[1,i]\n\t\tmark[i]=1\n\t\tct+=1\nif ct>d:\n\tprint(\"NO\")\n\treturn\nif ct<d:\n\tfor i in range(len(adj[1])):\n\t\tif mark[adj[1][i]]==0:\n\t\t\tans[ct]=[1,adj[1][i]]\n\t\t\tmark[adj[1][i]]=1\n\t\t\tct+=1\n\t\tif ct==d:\n\t\t\tbreak\n\tif ct<d:\n\t\tprint(\"NO\")\n\t\treturn\ni=0\nwhile (i<ct):\n\tk=ans[i][1]\n\tif visit[k]:\n\t\t# print(k,adj[k])\n\t\tfor j in range(len(adj[k])):\n\t\t\tif mark[adj[k][j]]==0:\n\t\t\t\tmark[adj[k][j]]=1\n\t\t\t\tans[ct]=[k,adj[k][j]]\n\t\t\t\tct+=1\n\t\tvisit[k]=0\n\ti+=1\nprint(\"YES\")\nfor i in range(ct):\n\tprint(*ans[i])", "n, m, d = list(map(int, input().split()))\n\ng = [[] for _ in range(n + 1)]\n\nhaveOne = [False] * (n + 1)\n\nfor i in range(m):\n\tu, v = list(map(int, input().split()))\n\tg[u].append(v)\n\tg[v].append(u)\n\tif u == 1:\n\t\thaveOne[v] = True\n\tif v == 1:\n\t\thaveOne[u] = True\n\t\ncount = 0\ngroup = [-1] * (n + 1)\nselectedOne = []\n\nfor i in range(2, n+1):\n\tif group[i] == -1:\n\t\t# bfs\n\t\tgroup[i] = count\n\t\tuseOne = False\n\t\tif haveOne[i]:\n\t\t\tselectedOne.append(i)\n\t\t\tuseOne = True\n\t\tif count >= d:\n\t\t\tcount += 1\n\t\t\tbreak\n\t\tincount = count + 1\n\t\tqu = []\n\t\tqu += g[i]\n\n\t\t\n\t\twhile len(qu) > 0:\n\t\t\tc = qu.pop()\n\t\t\tif c != 1 and group[c] == -1:\n\t\t\t\tif haveOne[c] and not(useOne):\n\t\t\t\t\tselectedOne.append(c)\n\t\t\t\t\tuseOne = True\n\t\t\t\tgroup[c] = count\n\t\t\t\tqu += g[c]\n\t\tcount += 1\n\nif count > d or d > len(g[1]):\n\tprint('NO')\nelse:\n\tdiffOne = list(set(g[1]) - set(selectedOne))\n\tdiffOne = selectedOne + diffOne\n\tg[1] = diffOne[:d]\n\tvisited = [False] * (n + 1)\n\tqVisit = [1]\n\tvisited[1] = True\n\t\n\tprint('YES')\n\twhile len(qVisit) > 0:\n\t\ti = qVisit.pop()\n\t\tfor j in g[i]:\n\t\t\tif not(visited[j]):\n\t\t\t\tprint(i, j)\n\t\t\t\tvisited[j] = True\n\t\t\t\tqVisit.append(j)\n", "[n, m, d] = list(map(int, input().split()))\ng = {}\nfor i in range(n):\n    g[i+1] = set()\nfor i in range(m):\n    [v, u] = list(map(int, input().split()))\n    g[u].add(v)\n    g[v].add(u)\nseen = set()\ncomps = set()\nfor node in g[1]:\n    if node in seen:\n        continue\n    comps.add(node)\n    seen.add(node)\n    q = [node]\n    while len(q) > 0:\n        v = q.pop()\n        for to in g[v]:\n            if to in seen or to == 1:\n                continue\n            q.append(to)\n            seen.add(to)\nif d > len(g[1]) or d < len(comps):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    rem = 0\n    rem2 = []\n    for i in g[1]:\n        if len(g[1]) - rem == d:\n            break\n        if i not in comps:\n            rem2.append(i)\n            rem += 1\n    for i in rem2:\n        g[1].discard(i)\n    seen.clear()\n    q = [1]\n    while len(q) > 0:\n        v = q.pop()\n        discard = []\n        for to in g[v]:\n            if to in seen or to == 1:\n                continue\n            q.append(to)\n            seen.add(to)\n            print(v, \" \", to)\n\n\n", "[n, m, d] = list(map(int, input().split()))\ng = {}\nfor i in range(n):\n    g[i+1] = set()\nfor i in range(m):\n    [v, u] = list(map(int, input().split()))\n    g[u].add(v)\n    g[v].add(u)\nseen = set()\ncomps = set()\nfor node in g[1]:\n    if node in seen:\n        continue\n    comps.add(node)\n    seen.add(node)\n    q = [node]\n    while len(q) > 0:\n        v = q.pop()\n        for to in g[v]:\n            if to in seen or to == 1:\n                continue\n            q.append(to)\n            seen.add(to)\nif d > len(g[1]) or d < len(comps):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    rem = 0\n    rem2 = []\n    for i in g[1]:\n        if len(g[1]) - rem == d:\n            break\n        if i not in comps:\n            rem2.append(i)\n            rem += 1\n    for i in rem2:\n        g[1].discard(i)\n    seen.clear()\n    q = [1]\n    while len(q) > 0:\n        v = q.pop()\n        discard = []\n        for to in g[v]:\n            if to in seen or to == 1:\n                continue\n            q.append(to)\n            seen.add(to)\n            print(v, \" \", to)\n\n\n", "n, m, D = [int(x) for x in input().split(' ')]\n\nG = {}\nfor u in range(1, n + 1):\n  G[u] = set()\nfor i in range(m):\n  u, v = [int(x) for x in input().split(' ')]\n  G[u].add(v)\n  G[v].add(u)\n\nif len(G[1]) < D:\n  print('NO')\nelse:\n\n  visited = [1] + [0] * n\n  comp = [0] * (n + 1)\n  c_visited = [1] + [0] * n\n\n  a = 0\n  for i in G[1]:\n    if not visited[i]:\n      a += 1 \n      comp[i] = a\n      visited[i] = 1\n      q = [i]\n      # bfs\n      while len(q) > 0:\n        u = q.pop(0)\n        for v in G[u]:\n          if v != 1 and not visited[v]:\n            q.append(v)\n            comp[v] = a\n            visited[v] = 1\n  if a > D:\n    print('NO')\n  else:\n    print('YES')\n    d = D\n    visited[1] = 2\n    queue = []\n    n_edges = 0\n    for v in G[1]:\n      if not c_visited[comp[v]]:\n        visited[v] = 2\n        d -= 1\n        c_visited[comp[v]] = 1\n        n_edges += 1\n        print(1, v)\n        queue.append(v)\n    if d:\n      for v in G[1]:\n        if visited[v] != 2:\n          visited[v] = 2\n          d -= 1\n          print(1, v)\n          n_edges += 1\n          queue.append(v)\n          if not d:\n            break\n    # bfs\n    while len(queue) > 0 and n_edges < n -1:\n      u = queue.pop(0)\n      for v in G[u]:\n        if visited[v] != 2:\n          visited[v] = 2\n          queue.append(v)\n          n_edges += 1\n          print(u, v)\n", "'''input\n7 10 2\n7 1\n1 3\n5 2\n6 1\n6 5\n3 7\n5 7\n1 2\n5 1\n1 4\n'''\nimport sys\nfrom collections import defaultdict as dd\nimport heapq\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nn,m,d=ri()\n\nt=dd(list)\n\nr=[0 for i in range(n+1)]\nvis=[0 for i in range(n+1)]\n\n\nfor i in range(m):\n\tu,v=ri()\n\tt[u].append(v)\n\tt[v].append(u)\n\nfor i in range(n+1):\n\tr[i]=len(t[i])\n\nfinal=[]\n\ndef bfs(sor):\n\ts=[sor]\n\tvis[sor]=1\n\twhile s:\n\t\tk=s.pop(-1)\n\t\tfor i in t[k]:\n\t\t\tif vis[i]==0:\n\t\t\t\tvis[i]=1\n\t\t\t\ts.append(i)\n\t\t\t\t#final.append((k,i))\n\n\n\ndef bfs2(sor):\n\t\n\ts=[sor]\n\tvis[sor]=1\n\twhile s:\n\t\tk=s.pop(-1)\n\t\tfor i in t[k]:\n\t\t\tif vis[i]==0:\n\t\t\t\tvis[i]=1\n\t\t\t\ts.append(i)\n\t\t\t\tfinal.append((k,i))\n\nnow=[]\n\nfor i in t[1]:\n\tnow.append(i)\n\nlk=0\n\ngo=dd(int)\nvis[1]=1\n\nfor i in range(len(t[1])):\n\tif vis[t[1][i]]==0:\n\t\tbfs(t[1][i])\n\t\tgo[t[1][i]]=1\n\t\tlk+=1\n\n\nif lk<=d:\n\ttemp=t[1][:]\n\tt[1]=[]\n\tfor i in go:\n\t\tt[1].append(i)\n\t\tt[i].append(1)\n\t\td-=1\n\n\tfor i in temp:\n\t\tif go[i]==1:\n\t\t\tpass\n\t\telse:\n\t\t\tif d!=0:\n\t\t\t\tt[1].append(i)\n\t\t\t\tt[i].append(1)\n\t\t\t\td-=1\n\tif d!=0:\n\t\tprint(\"NO\")\n\telse:\n\t\tvis=[0 for i in range(n+1)]\n\t\tbfs2(1)\n\t\t#print(vis,t)\n\t\tif sum(vis)==n:\n\t\t\tprint(\"YES\")\n\t\t\tfor i in final:\n\t\t\t\tprint(*i)\n\t\telse:\n\t\t\tprint(\"NO\")\nelse:\n\tprint(\"NO\")", "import sys\nfrom collections import Counter, defaultdict\ndef i_ints():\n    return map(int, sys.stdin.readline().split())\n\nn, m, D = i_ints()\nE = defaultdict(set)\nfor i in range(m):\n    u, v = i_ints()\n    E[u].add(v)\n    E[v].add(u)\n    \n    \ndef append_edge(u, v):\n    E[u].discard(v)\n    E[v].discard(u)\n    t.add(u)\n    t.add(v)\n    te.append((u, v))\n    \ndef complete_tree(u):\n    nonlocal too_much\n    todo = {u}\n    while todo:\n        u = todo.pop()\n        for v in list(E[u]):\n            if v not in t:\n                if v not in starts:\n                    append_edge(u, v)\n                    todo.add(v)\n                else:\n                    if too_much > 0:\n                        append_edge(u, v)\n                        todo.add(v)\n                        too_much -= 1\n\n    \ndef print_tree():\n    for u, v in te:\n        print(u, v)\n    \n    \nu0 = 1 \nt = {u0}\nte = []\nstarts = set(E[u0])\ntoo_much = len(starts) - D\nif too_much >= 0:\n    for v in starts:\n        if v not in t:\n            append_edge(u0, v)\n            complete_tree(v)\nif not too_much:\n    print(\"YES\")\n    print_tree()\nelse:\n    print(\"NO\")", "import sys\nfrom collections import Counter, defaultdict\ndef i_ints():\n    return map(int, sys.stdin.readline().split())\n\nn, m, D = i_ints()\nE = defaultdict(set)\nfor i in range(m):\n    u, v = i_ints()\n    E[u].add(v)\n    E[v].add(u)\n    \n    \ndef append_edge(u, v):\n#    E[u].discard(v)\n    E[v].discard(u)\n#    t.add(u)\n    t.add(v)\n    te.append((u, v))\n    \ndef complete_tree(u):\n    nonlocal too_much\n    todo = {u}\n    while todo:\n        u = todo.pop()\n        for v in list(E[u]):\n            if v not in t:\n                if v not in starts:\n                    append_edge(u, v)\n                    todo.add(v)\n                else:\n                    if too_much > 0:\n                        append_edge(u, v)\n                        todo.add(v)\n                        too_much -= 1\n\n    \ndef print_tree():\n    for u, v in te:\n        print(u, v)\n    \n    \nu0 = 1 \nt = {u0}\nte = []\nstarts = set(E[u0])\ntoo_much = len(starts) - D\nif too_much >= 0:\n    for v in starts:\n        if v not in t:\n            append_edge(u0, v)\n            complete_tree(v)\nif not too_much:\n    print(\"YES\")\n    print_tree()\nelse:\n    print(\"NO\")", "import os\nfrom io import BytesIO\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\n\ndef main():\n    def union(u, v):\n        p, q = find(u), find(v)\n        if p == q: return\n        if rank[p] < rank[q]: p, q = q, p\n        if rank[p] == rank[q]: rank[p] += 1\n        parent[q] = p\n\n    def find(u):\n        p = parent[u]\n        if p == u: return u\n        root = find(p)\n        parent[u] = root\n        return root\n\n\n    n, m, D = map(int, input().split())\n    E = []\n    E0 = []\n    E0rmn = []\n    MSTE = []\n\n    parent = list(range(n))\n    rank = [0] * n\n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u, v = u-1, v-1\n        if u == 0 or v == 0:\n            E0.append((u, v))\n        else:\n            E.append((u, v))\n\n    if len(E0) < D:\n        print('NO')\n        return\n\n    for u, v in E:\n        if find(u) != find(v):\n            union(u, v)\n            MSTE.append((u, v))\n\n    k = 0\n    for u, v in E0:\n        if find(u) != find(v):\n            union(u, v)\n            MSTE.append((u, v))\n            k += 1\n        else:\n            E0rmn.append((u, v))\n\n    if D < k:\n        print('NO')\n        return\n\n    while k < D:\n        e = E0rmn.pop()\n        MSTE.append(e)\n        k += 1\n\n    parent = list(range(n))\n    rank = [0] * n\n\n    out = ['YES']\n    for u, v in reversed(MSTE):\n        if find(u) != find(v):\n            union(u, v)\n            out.append(str(u+1) + ' ' + str(v+1))\n\n    print('\\n'.join(out))\n\nmain()", "import sys\nfrom collections import deque\nsys.setrecursionlimit(20000000)\ninput = sys.stdin.readline\nn,m,d = map(int,input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n        a,b = map(int,input().split())\n        a-=1;b-=1\n        g[a].append(b)\n        g[b].append(a)\n\nne = 0\n\n\nans = []\nmita = [0]*n\nmita[ne] = -1\ndef dfs(x,y):\n        for i in g[x]:\n                if mita[i] == 0:\n                        ans.append([x+1,i+1])\n                        mita[i] = y\n                        que.append([i,y])\nfor i in g[ne]:\n        if mita[i] != 0:\n                continue\n        mita[i] = i\n        que = deque()\n        que.append([i,i])\n        while que:\n                x,y = que.popleft()\n                dfs(x,y)\nsyo = len(set(mita))-1\nif syo > d or len(g[ne]) < d:\n        print(\"NO\")\n        return\nprint(\"YES\")\nuse = set()\nki  = set()\nfor i in g[ne]:\n        if mita[i] in ki:\n                continue\n        else:\n                ki.add(mita[i])\n                use.add(i)\nfor i in g[ne]:\n        if len(use) == d:\n                break\n        if i not in use:\n                use.add(i)\n\ng[ne] = list(use)\nans = []\nmita = [0]*n\nmita[ne] = 1\ndef dfs(x):\n        for i in g[x]:\n                if mita[i] == 0:\n                        ans.append([x+1,i+1])\n                        mita[i] = 1\n                        que.append(i)\nque = deque()\nque.append(ne)\nwhile que:\n        dfs(que.popleft())\nfor i,j in ans:\n        print(i,j)", "import os\nimport sys\nfrom io import BytesIO, IOBase\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n#######################################\nimport sys,threading\nsys.setrecursionlimit(400000)\nthreading.stack_size(10**8)\ndef dfs(x,y,t):\n    nonlocal v,l1,l2,adj,d,ans,l3,c\n    v[x]=1\n    l1[x]=t\n    l2[x]=t\n    for i in adj[x]:\n        if not v[i]:\n            if x==1:\n                c+=1\n            dfs(i,x,t+1)\n            if l2[i]<=l1[x]:\n                l2[x]=l2[i]\n                ans.append([x,i])\n                if x==1:\n                    d-=1\n            else:\n                ans.append([x,i])\n                if x==1:\n                    d-=1\n        else:\n            if i!=y:\n                if l2[i]<l1[x]:\n                    l2[x]=l2[i]\n                    if i==1:\n                        l3.append([x,(y,x)])\ndef main():\n    nonlocal v,l1,l2,adj,d,ans,l3,c\n    n,m,d=list(map(int,input().split()))\n    d1=d\n    adj=[[] for i in range(n+1)]\n    v=[0]*(n+1)\n    l1=[0]*(n+1)\n    l2=[0]*(n+1)\n    l3=[]\n    ans=[]\n    c=0\n    for i in range(m):\n        x,y=list(map(int,input().split()))\n        adj[x].append(y)\n        adj[y].append(x)\n    if len(adj[1])<d:\n        print(\"NO\")\n    else:\n        dfs(1,0,0)\n        a=\"YES\"\n        from collections import defaultdict\n        dd=defaultdict(int)\n        if c>d1:\n            a=\"NO\"\n        elif c<d1:\n            for i in l3:\n                if d==0:\n                    break\n                ans.append([1,i[0]])\n                dd[i[1]]=1\n                d-=1\n        print(a)\n        if a==\"YES\":\n            for i in ans:\n                x,y=i\n                if dd[(x,y)]==0:\n                    print(*i)\nt=threading.Thread(target=main)\nt.start()\nt.join()\n\n        \n        \n        \n\n\n\n    \n", "import sys\nimport math\nfrom collections import defaultdict,deque\nimport heapq\ndef find(node,parent):\n\twhile parent[node]!=node:\n\t\tnode=parent[node]\n\treturn node\ndef union(a,b,child,parent):\n\t#print(a,'a',b,'b')\n\tpara=find(a,parent)\n\tparb=find(b,parent)\n\t#print(para,'para')\n\tca=child[para]\n\tcb=child[parb]\n\tif para!=parb:\n\t\tif ca>cb:\n\t\t\tparent[parb]=para\n\t\t\tchild[para]+=child[parb]\n\t\telse:\n\t\t\tparent[para]=parb\n\t\t\tchild[parb]+=child[para]\n\t\t\nn,m,d=map(int,sys.stdin.readline().split())\ngraph=defaultdict(list)\nparent=[i for i in range(n+1)]\nchild=[1 for i in range(n+1)]\nedges=[]\nfor i in range(m):\n\tu,v=map(int,sys.stdin.readline().split())\n\tgraph[u].append(v)\n\tgraph[v].append(u)\n\t#edges.append([u,v])\nvis=defaultdict(int)\nq=deque()\n\nvis[1]=1\nfor j in graph[1]:\n\tif vis[j]==0:\n\t\tvis[j]=1\n\t\tq.append(j)\n\t\t#print(j,'j')\n\t\tchild[j]+=1\n\t\t#print(child[j],'child')\n\t\twhile q:\n\t\t\tcur=q.pop()\n\t\t\t#print(cur,'cur')\n\t\t\tfor i in graph[cur]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tq.append(i)\n\t\t\t\t\tif cur!=1 and i!=1:\n\t\t\t\t\t\t#print(cur,'cur',i,'i')\n\t\t\t\t\t\tunion(cur,i,child,parent)\n\t\t\t\t\tvis[i]=1\nif len(graph[1]) < d:\n\tprint(\"NO\")\n\treturn\n#print(graph[1],'one')\n#print(parent,'parent')\n#print(child,'child')\ncnt=set()\nfor i in graph[1]:\n\tcnt.add(find(i,parent))\n#print(cnt,'cnt')\nif len(cnt)>d:\n\tprint(\"NO\")\n\treturn\nq=deque()\nres=0\nans=[]\nvis=defaultdict(int)\nfor i in cnt:\n\tans.append([1,i])\n\tq.append(i)\n\tvis[i]=1\n\tres+=1\nrem=d-res\nvis[1]=1\nfor i in graph[1]:\n\tif rem>0 and vis[i]==0:\n\t\tvis[i]=1\n\t\tq.append(i)\n\t\trem-=1\n\t\tans.append([1,i])\n\nwhile q:\n\tcur=q.popleft()\n\tfor j in graph[cur]:\n\t\tif vis[j]==0:\n\t\t\tq.append(j)\n\t\t\tans.append([cur,j])\n\t\t\tvis[j]=1\nprint(\"YES\")\nfor i in range(n-1):\n\tprint(ans[i][0],ans[i][1])", "import collections as cc\nimport math as mt\nimport sys\nI=lambda:list(map(int,input().split()))\ndef find(u):\n\twhile u!=parent[u]:\n\t\tu=parent[u]\n\treturn u\ndef union(u,v):\n\ta=find(u)\n\tb=find(v)\n\tif a!=b:\n\t\tparent[a]=parent[b]=min(a,b)\nn,m,d=I()\nuu=set()\nuu.add(1)\nparent=[i for i in range(n+1)]\ng=cc.defaultdict(list)\non=[]\ntf=cc.defaultdict(int)\nother=[]\nfor i in range(m):\n\tx,y=sorted(I())\n\tg[x].append(y)\n\tg[y].append(x)\n\tif x!=1 and y!=1:\n\t\tother.append([x,y])\n\t\tunion(x,y)\ntemp=g[1]\ncon=[find(i) for i in set(temp)]\nif len(set(con))>d or len(set(temp))<d:\n\tprint(\"NO\")\n\treturn\nelse:\n\tprint(\"YES\")\n\tused=cc.defaultdict(int)\n\tans=[]\n\tst=cc.deque()\n\tuse=[0]*(n+1)\n\tuse[1]=1\n\tj=0\n\tfor i in range(len(temp)):\n\t\tif not used[find(temp[i])]:\n\t\t\tused[find(temp[i])]=1\n\t\t\tans.append([1,temp[i]])\n\t\t\tst.append(temp[i])\n\t\t\tuse[temp[i]]=1\n\t\t\td-=1\n\tfor i in range(d):\n\t\twhile use[temp[j]]==1:\n\t\t\tj+=1\n\t\tans.append([1,temp[j]])\n\t\tst.append(temp[j])\n\t\tuse[temp[j]]=1\n\twhile st:\n\t\tx=st.popleft()\n\t\tuse[x]=1\n\t\tfor y in g[x]:\n\t\t\tif not use[y]:\n\t\t\t\tans.append([x,y])\n\t\t\t\tst.append(y)\n\t\t\t\tuse[y]=1\n\tfor i in ans:\n\t\tprint(*i)\n", "import sys\ninput = sys.stdin.readline\n \nn,m,D=map(int,input().split())\nE=[list(map(int,input().split())) for i in range(m)]\n \n \nEDGELIST=[[] for i in range(n+1)]\n \nfor x,y in E:\n    EDGELIST[x].append(y)\n    EDGELIST[y].append(x)\n \nGroup=[i for i in range(n+1)]\n \ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n \ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n \nONE=EDGELIST[1]\n \nfor x,y in E:\n    if x==1 or y==1:\n        continue\n    Union(x,y)\n \nONEU=[find(e) for e in ONE]\n \nif len(set(ONEU))>D or D>len(ONE):\n    print(\"NO\")\n    return\nelse:\n    print(\"YES\")\n \nUSED=set()\nANS=[]\nfrom collections import deque\nQUE=deque()\ncheck=[0]*(n+1)\ncheck[1]=1\n \nfor j in range(len(ONE)):\n    if find(ONE[j]) in USED:\n        continue\n    else:\n        ANS.append([1,ONE[j]])\n        QUE.append(ONE[j])\n        USED.add(find(ONE[j]))\n        check[ONE[j]]=1\n        D-=1\n \nj=0\nfor i in range(D):\n    while check[ONE[j]]==1:\n        j+=1\n    ANS.append([1,ONE[j]])\n    QUE.append(ONE[j])\n    check[ONE[j]]=1\n    \n \nwhile QUE:\n    x=QUE.popleft()\n    check[x]=1\n \n    for to in EDGELIST[x]:\n        if check[to]==0:\n            ANS.append([x,to])\n            QUE.append(to)\n            check[to]=1\n        \n#print(ANS)\nfor x,y in ANS:\n    print(x,y)", "# ---------------------------iye ha aam zindegi---------------------------------------------\nimport math\nimport random\nimport heapq, bisect\nimport sys\nfrom collections import deque, defaultdict\nfrom fractions import Fraction\nimport sys\nimport threading\nfrom collections import defaultdict\nthreading.stack_size(10**8)\nmod = 10 ** 9 + 7\nmod1 = 998244353\n\n# ------------------------------warmup----------------------------\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nsys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass TreeNode:\n    def __init__(self, k, v):\n        self.key = k\n        self.value = v\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.height = 1\n        self.num_left = 1\n        self.num_total = 1\n\n\nclass AvlTree:\n\n    def __init__(self):\n        self._tree = None\n\n    def add(self, k, v):\n        if not self._tree:\n            self._tree = TreeNode(k, v)\n            return\n        node = self._add(k, v)\n        if node:\n            self._rebalance(node)\n\n    def _add(self, k, v):\n        node = self._tree\n        while node:\n            if k < node.key:\n                if node.left:\n                    node = node.left\n                else:\n                    node.left = TreeNode(k, v)\n                    node.left.parent = node\n                    return node.left\n            elif node.key < k:\n                if node.right:\n                    node = node.right\n                else:\n                    node.right = TreeNode(k, v)\n                    node.right.parent = node\n                    return node.right\n            else:\n                node.value = v\n                return\n\n    @staticmethod\n    def get_height(x):\n        return x.height if x else 0\n\n    @staticmethod\n    def get_num_total(x):\n        return x.num_total if x else 0\n\n    def _rebalance(self, node):\n\n        n = node\n        while n:\n            lh = self.get_height(n.left)\n            rh = self.get_height(n.right)\n            n.height = max(lh, rh) + 1\n            balance_factor = lh - rh\n            n.num_total = 1 + self.get_num_total(n.left) + self.get_num_total(n.right)\n            n.num_left = 1 + self.get_num_total(n.left)\n\n            if balance_factor > 1:\n                if self.get_height(n.left.left) < self.get_height(n.left.right):\n                    self._rotate_left(n.left)\n                self._rotate_right(n)\n            elif balance_factor < -1:\n                if self.get_height(n.right.right) < self.get_height(n.right.left):\n                    self._rotate_right(n.right)\n                self._rotate_left(n)\n            else:\n                n = n.parent\n\n    def _remove_one(self, node):\n        \"\"\"\n        Side effect!!! Changes node. Node should have exactly one child\n        \"\"\"\n        replacement = node.left or node.right\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = replacement\n            else:\n                node.parent.right = replacement\n            replacement.parent = node.parent\n            node.parent = None\n        else:\n            self._tree = replacement\n            replacement.parent = None\n        node.left = None\n        node.right = None\n        node.parent = None\n        self._rebalance(replacement)\n\n    def _remove_leaf(self, node):\n        if node.parent:\n            if AvlTree._is_left(node):\n                node.parent.left = None\n            else:\n                node.parent.right = None\n            self._rebalance(node.parent)\n        else:\n            self._tree = None\n        node.parent = None\n        node.left = None\n        node.right = None\n\n    def remove(self, k):\n        node = self._get_node(k)\n        if not node:\n            return\n        if AvlTree._is_leaf(node):\n            self._remove_leaf(node)\n            return\n        if node.left and node.right:\n            nxt = AvlTree._get_next(node)\n            node.key = nxt.key\n            node.value = nxt.value\n            if self._is_leaf(nxt):\n                self._remove_leaf(nxt)\n            else:\n                self._remove_one(nxt)\n            self._rebalance(node)\n        else:\n            self._remove_one(node)\n\n    def get(self, k):\n        node = self._get_node(k)\n        return node.value if node else -1\n\n    def _get_node(self, k):\n        if not self._tree:\n            return None\n        node = self._tree\n        while node:\n            if k < node.key:\n                node = node.left\n            elif node.key < k:\n                node = node.right\n            else:\n                return node\n        return None\n\n    def get_at(self, pos):\n        x = pos + 1\n        node = self._tree\n        while node:\n            if x < node.num_left:\n                node = node.left\n            elif node.num_left < x:\n                x -= node.num_left\n                node = node.right\n            else:\n                return (node.key, node.value)\n        raise IndexError(\"Out of ranges\")\n\n    @staticmethod\n    def _is_left(node):\n        return node.parent.left and node.parent.left == node\n\n    @staticmethod\n    def _is_leaf(node):\n        return node.left is None and node.right is None\n\n    def _rotate_right(self, node):\n        if not node.parent:\n            self._tree = node.left\n            node.left.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.left\n            node.left.parent = node.parent\n        else:\n            node.parent.right = node.left\n            node.left.parent = node.parent\n        bk = node.left.right\n        node.left.right = node\n        node.parent = node.left\n        node.left = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    def _rotate_left(self, node):\n        if not node.parent:\n            self._tree = node.right\n            node.right.parent = None\n        elif AvlTree._is_left(node):\n            node.parent.left = node.right\n            node.right.parent = node.parent\n        else:\n            node.parent.right = node.right\n            node.right.parent = node.parent\n        bk = node.right.left\n        node.right.left = node\n        node.parent = node.right\n        node.right = bk\n        if bk:\n            bk.parent = node\n        node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1\n        node.num_total = 1 + self.get_num_total(node.left) + self.get_num_total(node.right)\n        node.num_left = 1 + self.get_num_total(node.left)\n\n    @staticmethod\n    def _get_next(node):\n        if not node.right:\n            return node.parent\n        n = node.right\n        while n.left:\n            n = n.left\n        return n\n\n\n# -----------------------------------------------binary seacrh tree---------------------------------------\nclass SegmentTree1:\n    def __init__(self, data, default=2**51, func=lambda a, b: a & b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------game starts now----------------------------------------------------import math\nclass SegmentTree:\n    def __init__(self, data, default=0, func=lambda a, b: a + b):\n        \"\"\"initialize the segment tree with data\"\"\"\n        self._default = default\n        self._func = func\n        self._len = len(data)\n        self._size = _size = 1 << (self._len - 1).bit_length()\n\n        self.data = [default] * (2 * _size)\n        self.data[_size:_size + self._len] = data\n        for i in reversed(range(_size)):\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = self._default\n\n    def __getitem__(self, idx):\n        return self.data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        self.data[idx] = value\n        idx >>= 1\n        while idx:\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        if start == stop:\n            return self.__getitem__(start)\n        stop += 1\n        start += self._size\n        stop += self._size\n\n        res = self._default\n        while start < stop:\n            if start & 1:\n                res = self._func(res, self.data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                res = self._func(res, self.data[stop])\n            start >>= 1\n            stop >>= 1\n        return res\n\n    def __repr__(self):\n        return \"SegmentTree({0})\".format(self.data)\n\n\n# -------------------------------iye ha chutiya zindegi-------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n\n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            return\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n\n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            return\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p // i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n\n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            return\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n\n\nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n\n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n\n\n# --------------------------------------iye ha combinations ka zindegi---------------------------------\ndef powm(a, n, m):\n    if a == 1 or n == 0:\n        return 1\n    if n % 2 == 0:\n        s = powm(a, n // 2, m)\n        return s * s % m\n    else:\n        return a * powm(a, n - 1, m) % m\n\n\n# --------------------------------------iye ha power ka zindegi---------------------------------\ndef sort_list(list1, list2):\n    zipped_pairs = zip(list2, list1)\n\n    z = [x for _, x in sorted(zipped_pairs)]\n\n    return z\n\n\n# --------------------------------------------------product----------------------------------------\ndef product(l):\n    por = 1\n    for i in range(len(l)):\n        por *= l[i]\n    return por\n\n\n# --------------------------------------------------binary----------------------------------------\ndef binarySearchCount(arr, n, key):\n    left = 0\n    right = n - 1\n\n    count = 0\n\n    while (left <= right):\n        mid = int((right + left) / 2)\n\n        # Check if middle element is\n        # less than or equal to key\n        if (arr[mid] < key):\n            count = mid + 1\n            left = mid + 1\n\n        # If key is smaller, ignore right half\n        else:\n            right = mid - 1\n\n    return count\n\n\n# --------------------------------------------------binary----------------------------------------\ndef countdig(n):\n    c = 0\n    while (n > 0):\n        n //= 10\n        c += 1\n    return c\ndef binary(x, length):\n    y = bin(x)[2:]\n    return y if len(y) >= length else \"0\" * (length - len(y)) + y\n\ndef countGreater(arr, n, k):\n    l = 0\n    r = n - 1\n\n    # Stores the index of the left most element\n    # from the array which is greater than k\n    leftGreater = n\n\n    # Finds number of elements greater than k\n    while (l <= r):\n        m = int(l + (r - l) / 2)\n        if (arr[m] >= k):\n            leftGreater = m\n            r = m - 1\n\n        # If mid element is less than\n        # or equal to k update l\n        else:\n            l = m + 1\n\n    # Return the count of elements\n    # greater than k\n    return (n - leftGreater)\n\n\n# --------------------------------------------------binary------------------------------------\ndef main():\n    er=[]\n    graph=defaultdict(list)\n    n, m, d = map(int, input().split())\n    vis=[0]*n\n    pre=[-1]*n\n    def dfs(v,p):\n        pre[v]=p\n        vis[v]=1\n        for i in graph[v]:\n            if vis[i]==0:\n                dfs(i,v)\n    for i in range(m):\n        a,b=map(int,input().split())\n        if a==1:\n            er.append(b-1)\n        elif b == 1:\n            er.append(a-1)\n        else:\n            graph[a-1].append(b-1)\n            graph[b-1].append(a-1)\n    for i in range(len(er)):\n        if vis[er[i]]==0:\n            dfs(er[i],-1)\n    t=0\n    for i in range(len(er)):\n        if pre[er[i]]==-1:\n            pre[er[i]]=0\n            t+=1\n    if t>d:\n        print(\"NO\")\n        return\n    for i in range(len(er)):\n        if pre[er[i]]==0:\n            continue\n        if t<d:\n            pre[er[i]]=0\n            t+=1\n        else:\n            break\n    if t<d:\n        print(\"NO\")\n        return\n    rt=0\n    for i in range(n):\n        if pre[i]==-1:\n            rt+=1\n        if rt>=2:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    for i in range(n):\n        if pre[i]!=-1:\n            print(pre[i]+1,i+1)\nt = threading.Thread(target=main)\nt.start()\nt.join()"]