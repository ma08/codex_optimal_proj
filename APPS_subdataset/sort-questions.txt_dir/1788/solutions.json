["from operator import xor\n\ndef choose_move(game_state):\n    \"\"\"Chooses a move to play given a game state\"\"\"\n    x = reduce(xor, game_state)\n    for i, amt in enumerate(game_state):\n        if amt ^ x < amt:\n            return (i, amt - (amt ^ x))", "from itertools import zip_longest\nimport random\n\ndef choose_move(game_state):\n    def is_nim_sum_zero(nums):\n        \"\"\"\n        Determines the \"nim-sum\" of the game. \n        First all the numbers are converted to binary, then \n        added following the rule that \"if the binary column \n        has an even number of 1s, put a 0; else put a 1.\"\n        \n          1 1 0\n        1 1 1 0\n        1 1 0 1\n        -------\n        0 1 0 1\n        \n        If it sums to 0, we win!\n        \"\"\"\n        to_add = []\n        for num in nums:\n\n            to_add.append(list(bin(num)[2:]))\n\n        to_transpose = [b[::-1] for b in to_add]\n        cols = [col for col in zip_longest(*to_transpose, fillvalue=0)]\n\n        sum = 0\n\n        for col in cols: \n            if col.count('1')%2 != 0:\n                return False\n\n        return True\n    \n    non_empty_piles = [i for i in range(len(game_state)) if game_state[i] != 0]\n\n    if is_nim_sum_zero(game_state):\n        # If nim-sum is 0 already, any move we do will give a non-zero nim-sum.\n        # We will not be able to win if our opponent is a perfect player.\n        # Return a random move.\n        pile = random.choice(non_empty_piles)\n        quant = random.choice(list(range(1, game_state[pile])) + 1)\n        \n    else:\n        # Otherwise, let's systematically try EVERY MOVE until we get a zero\n        # nim-sum!\n        next_ply = list(game_state)\n        pile_ind = 0\n        pile = non_empty_piles[pile_ind]\n        quant = 1\n        \n        next_ply[pile] = next_ply[pile] - quant\n        \n        while not is_nim_sum_zero(next_ply):\n            next_ply = list(game_state)\n            if quant < next_ply[pile]:\n                quant += 1\n            else:\n                pile_ind += 1\n                pile = non_empty_piles[pile_ind]\n                quant = 1\n                \n            next_ply[pile] = next_ply[pile] - quant\n            \n    return (pile, quant)\n", "def choose_move(game_state):\n    nim = reduce(lambda x,y: x ^ y, game_state, 0)\n    return [(i, x - (x ^ nim)) for i,x in enumerate(game_state) if x ^ nim < x][0]", "# function to calculate whether everything is lost or not\ndef xor_all(game_state):\n    result = 0\n    for pile in game_state:\n        result ^= pile\n    return result\n\n\ndef choose_move(game_state):\n    game_state_copy = list(game_state)\n    # remove duplicate values (do not waste time on them, later on)\n    for i, val in enumerate(game_state_copy):\n        if val and game_state_copy.count(val) > 1:\n            game_state_copy[i] = 0\n            game_state_copy[game_state_copy.index(val)] = 0\n    if xor_all(game_state):\n        # check for each pile, whether it is possible to check apropriate number of piles\n        for i, pile in enumerate(game_state_copy):\n            # try with every possible number of straws\n            for straws in range(0, pile+1):\n                if xor_all(game_state_copy[:i] + [straws] + game_state_copy[i+1:]) == 0:\n                    return [i, pile-straws]\n    print \"I have lost\"\n    return [0, 0]", "from operator import xor\nfrom functools import reduce\ndef choose_move(game_state):\n    \"\"\"Chooses a move to play given a game state\"\"\"\n    nim_sum = reduce(xor, game_state)\n    to_take = (s-(s^nim_sum) for s in game_state)\n    return next((i,t) for i, t in enumerate(to_take) if t>0)\n", "from operator import xor\nfrom functools import reduce\n\ndef choose_move(game_state):\n    \"\"\"Chooses a move to play given a game state\"\"\"\n    diffs = [amount ^ reduce(xor, game_state) for amount in game_state]\n    offsets = [pile - diff for pile, diff in zip(game_state, diffs)]\n    amount_of_straws = max(offsets)\n    return (offsets.index(amount_of_straws), amount_of_straws)\n", "def choose_move(game_state):\n    \"\"\"Chooses a move to play given a game state\"\"\"\n    value = reduce(lambda x, y: x^y, game_state)\n    i, v = [(i, v) for i, v in enumerate(game_state) if (v ^ value) < v][0]\n    return i, v - (v ^ value)", "from operator import xor\nfrom itertools import imap\n\ndef choose_move(game_state):\n    ns = reduce(xor, game_state)\n    for i, p, s in imap(lambda (k, v): (k, v, ns ^ v), enumerate(game_state)):\n        if s < p: return (i, p - s)", "import operator\n\ndef choose_move(heaps):\n    \"\"\"Chooses a move to play given a game state.\"\"\"\n    x = reduce(operator.xor, heaps)\n    return next((i, h-(x^h)) for i, h in enumerate(heaps) if (x^h) < h)", "from functools import reduce\ndef choose_move(game_state):\n\n  cond = reduce(lambda x,y: x^y, game_state)\n  \n  for idx, val in enumerate(game_state):\n    if (val^cond < val):\n      return (idx, val - (val^cond))\n  \n"]