["def splitlist(l):\n  half = sum(l) // 2\n  sums = [(0, [])]\n  for i, n in enumerate(l):\n      sums = sums + [(m + n, a + [i]) for m, a in sums if m + n <= half]\n      if max(s[0] for s in sums) == half:\n          break\n  sums.sort(key=lambda v: abs(v[0] - half))\n  indices = sums[0][1]\n  return [n for i, n in enumerate(l) if i in indices], [n for i, n in enumerate(l) if i not in indices]\n", "#Re-use of my  dynamic programing approach for spliting the workload part I\n#Given a set S of n non-negative integers:\n# 1) make a partition of S with exactly two subsets A,B of S, such that the absolute\n#    difference of the elements of each set is minimized\n\n#To solve this problem, all we need to do is use the general subset sum program, but\n# set the target sum to S/2 where S is the sum of all of the elements in the list\nfrom collections import Counter     #for differencing lists with (possible) duplicates\n\n\n#Build the dynamic programing table:  Column are the sums, and rows are the subsets\n#   DP[i][j] == True if and only if there exists a subset of {a[0],...,a[i-1]} such\n#               that the a[0]+...+a[i-1]==j \n# Row i is the subset {a[0],...,a[i-1]}\n# Col j is a number (representing a sum)\n#The function additionally builds a 'parent' table that is used to determine\n# the optimal path (which will allow us to get the elements in the subsets)\ndef getdDPTable( numList, sizeList, targetSum):\n\n    numRows = sizeList + 1       #to account for empty set, we need +1\n    numCols  = targetSum + 1     #to account for zero, we need +1\n\n    #initialize both tables\n    dp     = [ [False for _ in range(numCols)] for _ in range(numRows) ]\n    parent = [ [ []   for _ in range(numCols)] for _ in range(numRows) ]\n\n    #The sum of 0 can be achieved by selecting no elements from each possible subsets\n    #  That is, it is true we can always acheive the sum of 0 from any possible subset\n    for r in range(numRows):\n        dp[r][0] = True\n    \n    #increasing in rows, and from left to right wrt columns, we build the rest\n    # of the DP table row i corresponds to the set {a_0,...,a_i}, column j\n    # corresponds to the target sum j.  If d[i][j] is true, that means there\n    # exists a subset of  {a_0,...,a_i} whose elemenst sum to j \n    for r in range(1, numRows):\n        for c in range(1, numCols):\n            if c < numList[r-1]:            #on row r, current column is less than numList[r-1]\n                dp[r][c] = dp[r-1][c]       #see row above for whether there exists a subeset that sums to j\n                parent[r][c].append(tuple( [r-1, c] ))   #we store where we got the answer\n            else:                           #we must perform a backtrack on the previous row\n                alreadyBuilt = dp[r-1][c]                           #look at row above\n                isInOriginalNumList   = dp[r-1][c - numList[r-1]]   #look at backtrack\n                dp[r][c] = alreadyBuilt or isInOriginalNumList\n\n                #we store the parent that is true\n                if alreadyBuilt:\n                    parent[r][c].append( tuple( [r-1, c] ) )\n                if isInOriginalNumList:\n                    parent[r][c].append( tuple( [r-1, c - numList[r-1]] ) )\n\n\n    return dp, parent, numRows, numCols\n#---end function\n\n\n#Here, using the parent table that was built (when building the dynamic programming table)\n# we extract the subset elements that form the optimal target sum\ndef getSubset(parent, numRows, targetSum):\n    subset = []\n\n    child   =  [tuple([numRows-1, targetSum])]\n    cRow, cCol   = child[0][0], child[0][1]\n    father =  parent[numRows-1][targetSum] \n\n    while father:\n        fRow   =  father[0][0]\n        fCol   =  father[0][1]\n        \n        diff = cCol - fCol\n        if diff !=0 :\n            subset.append(diff)\n        \n        cRow = fRow\n        cCol = fCol\n        father = parent[fRow][fCol]\n    \n    return subset     \n#---end function\n\n\n\n#In the scenario we can not find the best case scenario of a set with\n#  the target sum of (sum of entire set)/2 (as then the difference would be 0)\n# We must find the next best number, which is determined by the largest column\n# in the DP table (as this corresponds to the largest possible sum that can be made) \ndef getBestNum(dp, numList, targetSum, numRows):\n\n    for j in range(targetSum,-1,-1):\n        if dp[numRows-1][j]==True:      #found the largest sum we can make\n            break\n\n    return j\n#---end function\n\n\n#The main driver to solve the minimum partion problem\n# Exmaple: [0, 20, 54, 99, 84, 99] has a minimum partion of ([99, 54, 20], [0, 99, 84]) \n#          that has a difference of 10\n#First we try to partition the number list into equal valued sets (whose elements sum to\n#  the same number).  If that works, we found that the min diff is 0, so make the two  \n#  subsets and return them.  If we have a list of numbers where we can't partition them\n#  into equal values, we have to find the largest possible sum we can make.  Then, simply\n#  find the subset that makes that largest number, and we are done\ndef splitlist(numList):\n    \n    sizeList = len(numList)\n\n    #First see if we can get a subset that sums to sum(numList)//2 (then diff would be zero)\n    targetSum = sum(numList)//2 \n    dp, parent, numRows, numCols = getdDPTable(numList, sizeList, targetSum)\n    \n    foundSubset = dp[numRows-1][targetSum]\n\n    bestDiff = 0\n    if foundSubset:     #We found a subset whose elements sum to the target sum(numList)//2\n        subsetA = getSubset(parent, numRows, targetSum)\n    else:\n        #We could not get the best case senario, so we need to find the largest possible subset\n        # sum tha we can make given the provided list of numbers (see e.x. [0, 20, 54, 99, 84, 99])\n        newTargetSum = getBestNum(dp, numList, targetSum, numRows)\n        dp, parent, numRows, numCols = getdDPTable(numList, sizeList, newTargetSum)\n        subsetA = getSubset(parent, numRows, newTargetSum)\n\n    #partition the provided list of numbers into two subsets A and B\n    c1 = Counter(numList)\n    c2 = Counter(subsetA)\n    diff = c1-c2\n    subsetB = list(diff.elements())\n    \n    return subsetA, subsetB\n#---end function\n", "def splitlist(lst):\n    if not lst: return [],[]\n    \n    half,n = sum(lst)>>1,len(lst)\n    lst    = sorted(lst, reverse=1)\n    DP     = [ [0]*(half+1) for i in range(n+1)]\n    for i,v in enumerate(lst):\n        for j in range(1,1+half):\n            DP[i][j] = max(v+DP[i-1][j-v], DP[i-1][j]) if v<=j else DP[i-1][j]\n            \n    acc,j = DP[-2][-1], half\n    a,b   = [],[]\n    for i in reversed(range(n)):\n        v = lst[i]\n        if acc!=DP[i-1][j]:\n            a.append(v)\n            acc -= v\n            j -= v\n        else:\n            b.append(v)\n    return a,b", "def splitlist(l, i=0, sa=0, sb=0, sl=None, mem=None, first=False):\n    if mem is None: first, mem, sl = True, {}, sum(l); \n    if i == len(l): return ([], []) if first else (abs(sa-sb), [])\n    found = mem.get((i,sa)); da = db = sl\n    if not found and sa < sl/2: da, ma = splitlist(l, i+1, sa+l[i], sb, sl, mem); ma=[True]+ma\n    if not found and da > 0 and sb < sl/2: db, mb = splitlist(l, i+1, sa, sb+l[i], sl, mem); mb=[False]+mb\n    if not found: found = mem.setdefault((i, sa), (da, ma) if da<=db else (db, mb))\n    if not first: return found\n    a, b = [], []\n    for v, m in zip(l, found[1]): (a if m else b).append(v)\n    return a, b", "\njcash={}\ndef splitlist(lst):\n    def splitl(i,w):\n        g=jcash.get((i,w))\n        if g : return g\n        if i==len(lst) : return []\n        wi=lst[i]\n        a1=splitl(i+1,w)\n        if wi>w :\n            jcash[(i,w)]=a1.copy()\n            return a1 \n        a2=splitl(i+1,w-wi)\n        if  sum(a1)<(sum(a2)+wi):\n            a2.append(wi)\n            jcash[(i,w)]=a2.copy()\n            return a2\n        else:\n            jcash[(i,w)]=a1.copy()\n            return a1\n    jcash.clear()\n    lst.sort()\n    lst.reverse()\n    a=splitl(0,sum(lst)//2)\n    b=lst.copy() \n    for i in a : b.remove(i)\n    return a,b\n", "def splitlist(lst):\n    if not lst:\n        return ([], [])\n    lst = sorted(lst, reverse=True)\n    optimum = sum(lst) // 2\n    if optimum <= lst[0]:\n        return [lst[0]], lst[1:]\n    dp = [None] * (optimum + 1)\n    dp[0] = []\n    for item in lst:\n        for pos in reversed(range(optimum - item + 1)):\n            if dp[pos] is not None and dp[pos + item] is None:\n                dp[pos + item] = dp[pos] + [item]\n    best = next(reversed([option for option in dp if option is not None]))\n    for item in best:\n        lst.remove(item)\n    return best, lst", "\ndef splitlist(lst):\n    dicto = {}\n    def spliteer(lst,sum1=0,sum2=0,ls1=[],ls2=[],i = 0):\n        key = f\"{sum1}{i}\"\n        if key in dicto: return dicto[key]\n        if i >= len(lst):\n            return (abs(sum1 - sum2),[ls1,ls2])\n        else:\n            min1 = spliteer(lst,sum1+lst[i],sum2,ls1+[lst[i]],ls2,i+1)\n            min2 = spliteer(lst,sum1,sum2+lst[i],ls1,ls2+[lst[i]],i+1)\n            dicto[key] = min(min1,min2,key=lambda x:x[0])\n        return dicto[key]\n    return spliteer(lst)[1]", "from copy import deepcopy\nfrom random import shuffle\n\ndef splitlist(a):\n    if a == []:\n        return ([], [])\n    elif len(a) == 1:\n        return((a, []))\n    b = deepcopy(a)\n    s = sum(a)\n    minimum = ((a, ), s)\n    for i in range(10000):\n        shuffle(b)\n        s2 = 0\n        for j, el in enumerate(b):\n            if s2 <= s/2 and s2 + el > s/2:\n                break\n            else:\n                s2 += el\n        if abs(sum(b[:j]) - sum(b[j:])) < minimum[1]:\n            minimum = ((b[:j], b[j:]), abs(sum(b[:j]) - sum(b[j:])))\n            \n    return minimum[0]", "# we get the least difference between the two lists if the sums are equal, i.e. each lists sum is half the the sum of the\n#entire list. If we can't achieve that, we get as close to that target as possible. In other words, the solution uses the knapsack\n#problem, in particular subset sum. We have a bag that has a capacity sum(lst)/2 which we are trying to fill as much as possible\n#using elements from lst\n\ndef splitlist(lst):\n  \n    if not lst: return ([],[])\n    target = sum(lst)//2\n    \n    #dp array for knapsack problem\n    dp = [[0 for _ in range(target+1)] for _ in range(len(lst)+1)] \n    \n    for i in range(1,len(lst) + 1):\n        for j in range(target+1):\n            if j >= lst[i-1]: \n                \n                dp[i][j] = max(dp[i-1][j],dp[i-1][j-lst[i-1]] + lst[i-1])\n                 \n            else:\n                dp[i][j] = dp[i-1][j]\n\n    seg1 = []\n    \n    w = target\n    #get the values of the items in the first segment (the items which we used to get our max capacity in dp array)\n    for i in range(len(lst),-1,-1):\n        if dp[i][w] - dp[i-1][w-lst[i-1]] == lst[i-1]:\n            seg1.append(lst[i-1])\n            w -= lst[i-1]\n    \n    #remove all items from list which belong to seg 1\n    seg2 = [a for a in lst]\n    for a in seg1: seg2.remove(a)\n    \n    return (seg1,seg2)\n", "def splitlist(x):\n    \"\"\"\n    a, b = splitlist(x) finds a partition a, b of x minimizing |sum(a)-sum(b)|\n    \"\"\"\n    max_total = sum(x)//2\n    sumset = [{0}]\n    for xi in x:\n        sumset.append(\n            {t + xi for t in sumset[-1] if t + xi <= max_total} | sumset[-1]\n        )\n\n    a, b = [], []\n    total = max(sumset[-1])\n    for i, xi in reversed(list(enumerate(x))):\n        if total-xi in sumset[i]:\n            a.append(xi)\n            total -= xi\n        else:\n            b.append(xi)\n    return a, b\n"]