["def who_wins_beggar_thy_neighbour(*hands, special_cards='JQKA'):\n    hands = [list(reversed(hand)) for hand in hands]\n    player, deck_length = 0, sum(map(len, hands))\n    deal_start, deal_value, common = None, 0, []\n\n    while len(hands[player]) < deck_length:\n        # Deal ends and current player wins common pile\n        if deal_start == player:\n            hands[player] = common[::-1] + hands[player]\n            deal_start, deal_value, common = None, 0, []\n            continue\n        # Cards are drawn and deal begins if penalty occurs\n        for _ in range(min(deal_value or 1, len(hands[player]))):\n            card = hands[player].pop()\n            common.append(card)\n            if card[0] in special_cards:\n                deal_start, deal_value = player, special_cards.index(card[0]) + 1\n                break\n\n        player = (player + 1) % len(hands)\n\n    return player", "from collections import deque\n\ndef who_wins_beggar_thy_neighbour(hand_1, hand_2):  return Game(hand_1, hand_2).play()\n\n\nclass Game(object):\n    \n    LIMIT, SPECIALS = 10000, {c:n for n,c in enumerate(\"JQKA\",1)}\n    \n    def __init__(self, h1, h2):\n        self.count = 0\n        self.player = 1\n        self.piles =[deque(), deque(h1), deque(h2)]\n    \n    def play(self):\n        while not self.endGame(): self.playRound()\n        return 2 - self.player if self.count < self.LIMIT else None\n        \n    def playRound(self):\n        wasPenalty = self.getPenalty()\n        for _ in range(wasPenalty or 1):\n            self.drawCard()\n            if self.endGame() or self.getPenalty(): break\n        else:\n            if wasPenalty: self.otherGetCommon()\n        self.player = 3 - self.player\n            \n    def endGame(self):     return not self.piles[self.player] or self.count >= self.LIMIT\n    def drawCard(self):    self.piles[0].append( self.piles[self.player].popleft() ) ; self.count += 1\n    def getPenalty(self):  return 0 if not self.piles[0] else self.SPECIALS.get( self.piles[0][-1][0], 0)\n    \n    def otherGetCommon(self):\n        self.piles[3-self.player].extend( self.piles[0] )\n        self.piles[0] = deque()\n", "def special(card):\n    if card[0] == \"A\": return 4\n    if card[0] == \"K\": return 3\n    if card[0] == \"Q\": return 2\n    if card[0] == \"J\": return 1\n    return 0\n\n\n\ndef who_wins_beggar_thy_neighbour(player1, player2):\n    common = []\n    move = 1\n    cards = 0\n    while cards < 10000:\n        \n        while not common or not special(common[-1]):\n            if move == 1:\n                if not player1: return 1\n                common.append(player1.pop(0))\n                cards += 1\n                move = 2\n            else:\n                if not player2: return 0\n                common.append(player2.pop(0))\n                cards += 1\n                move = 1\n\n        penalty = special(common[-1])\n\n        while penalty:\n            \n            if move == 1:\n                if not player1: return 1\n                common.append(player1.pop(0))\n                cards += 1\n                if not special(common[-1]): penalty -= 1\n                if special(common[-1]):\n                    penalty = special(common[-1])\n                    move = 2\n            else:\n                if not player2: return 0\n                common.append(player2.pop(0))\n                cards += 1\n                if not special(common[-1]): penalty -= 1\n                if special(common[-1]):\n                    penalty = special(common[-1])\n                    move = 1\n\n        if move == 1: \n            player2.extend(common)\n            common = []\n            move = 2\n        \n        else: \n            player1.extend(common)\n            common = []\n            move = 1\n    return None", "def special(card):\n    if card[0] == \"A\": return 4\n    if card[0] == \"K\": return 3\n    if card[0] == \"Q\": return 2\n    if card[0] == \"J\": return 1\n    return 0\n\n\n\ndef who_wins_beggar_thy_neighbour(player1, player2):\n    common = []\n    move = 1\n    game = True\n    cards = 0\n    while cards < 10000:\n        \n        while not common or not special(common[-1]):\n            if move == 1:\n                if not player1: return 1\n                common.append(player1.pop(0))\n                cards += 1\n                move = 2\n            else:\n                if not player2: return 0\n                common.append(player2.pop(0))\n                cards += 1\n                move = 1\n\n        penalty = special(common[-1])\n\n        while penalty:\n            \n            if move == 1:\n                if not player1: return 1\n                common.append(player1.pop(0))\n                cards += 1\n                if not special(common[-1]): penalty -= 1\n                if special(common[-1]):\n                    penalty = special(common[-1])\n                    move = 2\n            else:\n                if not player2: return 0\n                common.append(player2.pop(0))\n                cards += 1\n                if not special(common[-1]): penalty -= 1\n                if special(common[-1]):\n                    penalty = special(common[-1])\n                    move = 1\n\n        if move == 1: \n            player2.extend(common)\n            common = []\n            move = 2\n        \n        else: \n            player1.extend(common)\n            common = []\n            move = 1\n    return None", "from collections import deque\n\ndef who_wins_beggar_thy_neighbour(hand_1, hand_2):\n     hands = [deque(hand_1),deque(hand_2)]\n     common = deque()\n     penalty = 0\n     player = 0\n     special = {'J':1,'Q':2,'K':3,'A':4}\n     for turn in range(100000):\n          if len(common) == 0:\n               if len(hands[0]) == 0:\n                    return 1\n               if len(hands[1]) == 0:\n                    return 0\n          if len(hands[player]) == 0:\n               return 1-player\n          card = hands[player].popleft()\n          common.append(card)\n          if card[0] in special:\n               player = 1 - player\n               penalty = special[card[0]]\n          elif penalty == 0:\n               player = 1 - player\n          else:\n               penalty -= 1\n               if penalty == 0:\n                    player = 1 - player\n                    while(len(common) > 0):\n                         hands[player].append(common.popleft())\n     return None\n", "def who_wins_beggar_thy_neighbour(hand_1, hand_2):\n    hs, vs = (hand_1, hand_2), {'J':1, 'Q':2, 'K':3, 'A':4}\n    hands = {player: [vs.get(card[0],0) for card in hs[player]] for player in range(2)}\n    #print(hands)\n    player = 0\n    draw = -1\n    pile = []\n    while hands[player]:\n        pile.append(hands[player].pop(0))\n        draw-=1\n        \n        if pile[-1]>0:\n            draw = pile[-1]\n            player = 1 - player\n            continue\n\n        if draw==0:\n            player = 1 - player\n            hands[player].extend(pile)\n            pile = []\n            draw = -1\n            continue\n        \n        if draw<0:\n            player = 1 - player\n    \n    return 1-player\n", "from collections import deque\n\ndef who_wins_beggar_thy_neighbour(*hands):\n    special = {c:i+1 for i, c in enumerate('JQKA')}\n    hands = [deque(c[0] for c in h) for h in hands]\n    pile = []\n    player, penalty = 0, 0\n    while hands[player]:\n        pile.append(hands[player].popleft())\n        penalty -= 1\n        if penalty == 0 and not pile[-1] in special:\n            hands[player^1].extend(pile)\n            pile = []\n        if penalty < 1 or pile[-1] in special:\n            player ^= 1\n            penalty = special.get(pile[-1], 0) if pile else 0\n    return player^1\n", "special={'J':1,'Q':2,'K':3,'A':4}\ndef who_wins_beggar_thy_neighbour(hand_1, hand_2):\n    h=[hand_1[:],hand_2[:]]\n    pile=[]\n    turn=0\n    for _ in range(10000):\n        while(not pile or pile[-1][0] not in special):\n            if not h[turn]:\n                return turn^1\n            pile.append(h[turn].pop(0))\n            turn^=1\n        count=special[pile[-1][0]]\n        while(count>0):\n            if not h[turn]:\n                return turn^1\n            pile.append(h[turn].pop(0))\n            if pile[-1][0] in special:\n                count=special[pile[-1][0]]\n                turn^=1\n                continue\n            count-=1\n        turn^=1\n        h[turn]+=pile\n        pile=[]            \n    return None", "def who_wins_beggar_thy_neighbour(hand_1, hand_2, MAX_PLAYED=10000):\n    punishments = {\"J\":1, \"Q\":2, \"K\":3, \"A\":4}\n    hands, common = [hand_1, hand_2], []\n    cards_played, player_index = 0, 0\n    \n    def opponent_index(index):\n        return (index + 1) % 2\n        \n    def play_card(index):\n        nonlocal cards_played, common\n        cards_played += 1\n        card = hands[index][0]\n        hands[index] = hands[index][1:]\n        common.append(card)\n        return card[0]\n            \n    def punish(index, v):\n        nonlocal player_index, common\n        # Play as many cards as mandated by punishments\n        for i in range(punishments[v]):\n            if player_won():\n                return\n            # If next card is special, stop and punish opponent\n            val = play_card(index)\n            if val in punishments:\n                punish(opponent_index(index), val)\n                return\n        # Player completed their punishment so other player wins common\n        player_index = opponent_index(index)\n        hands[player_index].extend(common)\n        common = []\n        return\n         \n    def player_won():\n        return not hands[0] or not hands[1]\n    \n    def get_winner():\n        assert(player_won())\n        if not hands[0]:\n            return opponent_index(0)\n        if not hands[1]:\n            return opponent_index(1)\n            \n    # Driver code\n    while(not player_won() and cards_played < MAX_PLAYED):\n        # Play next card and set next player\n        val = play_card(player_index)\n        player_index = opponent_index(player_index)\n        # If val is special, set next player with punish\n        if val in punishments:\n            punish(player_index, val)\n              \n    if player_won():\n        return get_winner()\n    return None", "SPECIAL = {\"J\": 1,\n           \"Q\": 2,\n           \"K\": 3,\n           \"A\": 4}\n\ndef who_wins_beggar_thy_neighbour(hand_1, hand_2):\n    turn = 0\n    players = [[SPECIAL.get(card[0], 0) for card in hand] for hand in (hand_1, hand_2)]\n    pot = []\n    penalty = 0\n    time = 0\n    \n    while time < 10000:\n        time += 1\n        try:\n            if penalty:\n                for __ in range(penalty):\n                    card = players[turn].pop(0)\n                    pot.append(card)\n                    if card:\n                        break\n                else:\n                    players[(turn+1) % 2] += pot\n                    pot = []\n            else:\n                card = players[turn].pop(0)\n                pot.append(card)\n        except IndexError:\n            return (turn+1) % 2\n        \n        penalty = card\n        turn = (turn+1) % 2\n"]