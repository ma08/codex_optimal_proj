["from math import factorial as fac\ncards = [\n    \"AC\", \"2C\", \"3C\", \"4C\", \"5C\", \"6C\", \"7C\", \"8C\", \"9C\", \"TC\", \"JC\", \"QC\", \"KC\",\n    \"AD\", \"2D\", \"3D\", \"4D\", \"5D\", \"6D\", \"7D\", \"8D\", \"9D\", \"TD\", \"JD\", \"QD\", \"KD\",\n    \"AH\", \"2H\", \"3H\", \"4H\", \"5H\", \"6H\", \"7H\", \"8H\", \"9H\", \"TH\", \"JH\", \"QH\", \"KH\",\n    \"AS\", \"2S\", \"3S\", \"4S\", \"5S\", \"6S\", \"7S\", \"8S\", \"9S\", \"TS\", \"JS\", \"QS\", \"KS\"\n]\nchars = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nchars_len = len(chars)\nfacs = [1]\nfor x in range(1, 53, 1): facs.append(facs[-1] * x)\n\nclass PlayingCards:\n    # Takes a String containing a message, and returns an array of Strings representing\n    # a deck of playing cards ordered to hide the message, or None if the message is invalid.\n    def encode(self, message):\n        mlen = len(message)\n        rem = 0\n        for i in range(mlen):\n            if message[i] not in chars: return None\n            rem = rem + chars_len ** (mlen - i - 1) * chars.index(message[i])\n        if rem >= facs[-1]: return None\n        for i in range(1, 53):\n            if rem < facs[i]: break\n        remaining_cards = cards[53 - i - 1:]\n        output_cards = cards[:53 - i - 1]\n        for j in range(i - 1, -1, -1):\n            idx = rem // facs[j]\n            output_cards.append(remaining_cards.pop(idx))\n            rem = rem % facs[j]\n        return output_cards\n\n    # Takes an array of Strings representing a deck of playing cards, and returns\n    # the message that is hidden inside, or None if the deck is invalid.\n    def decode(self, deck):\n        if len(deck) != 52: return None\n        remaining_cards = cards.copy()\n        rem = 0\n        for i in range(len(deck)):\n            if deck[i] not in remaining_cards: return None\n            idx = remaining_cards.index(deck[i])\n            rem = rem + facs[51 - i] * idx\n            remaining_cards.pop(idx)\n        output_message = []\n        if rem == 0 : return ''\n        while rem > 0:\n            output_message.insert(0, chars[rem % chars_len])\n            rem = rem // chars_len\n        return ''.join(output_message)", "import math\nclass PlayingCards:\n    # Takes a String containing a message, and returns an array of Strings representing\n    # a deck of playing cards ordered to hide the message, or None if the message is invalid.\n    def encode(self, message):\n        list_char = list(' ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        list_card_val = list('A23456789TJQK')\n        list_card_col = list('CDHS')\n        list_card0 = [val+col for col in list_card_col for val in list_card_val ]\n        \n        for c in message:\n            if c not in list_char:\n                return None\n        sort_list_message = list(message)\n        sort_list_message.sort()\n        \n        n = 0\n        list_ind = []\n        for ii, c in enumerate(message):\n            ind = list_char.index(c)\n            n += ind*(27**(len(message)-1-ii))\n        #print(n)\n        \n        if n>= math.factorial(52):\n            return None\n        dec = []\n        n2 = n\n        for ii in range(51,0,-1):\n            n_i, n2 = n2//math.factorial(ii), n2%math.factorial(ii)\n            dec.append(n_i)\n        dec.append(0)\n        \n        list_card = list_card0.copy()\n        deck_code = []\n        for ii in dec:\n            deck_code.append(list_card[ii])\n            list_card.remove(list_card[ii])\n        return deck_code\n\n    # Takes an array of Strings representing a deck of playing cards, and returns\n    # the message that is hidden inside, or None if the deck is invalid.\n    def decode(self, deck):\n        list_char = list(' ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n        list_card_val = list('A23456789TJQK')\n        list_card_col = list('CDHS')\n        list_card0 = [val+col for col in list_card_col for val in list_card_val ]\n        \n        #printDeck(deck, False)\n        \n        test_deck = list(set(deck))\n        test_deck.sort()\n        test_list_card0 = list_card0.copy()\n        test_list_card0.sort()\n        if test_deck != test_list_card0:\n            return None\n            \n        list_card = list_card0.copy()\n        n = 0\n        for ii, c in enumerate(deck[:-1]):\n            ind = list_card.index(c)\n            if ind > 0:\n                n += (ind)*math.factorial(len(deck)-1-ii)\n            list_card.remove(c)\n        #print(n)\n        \n        n2 = n\n        if n == 0:\n            return ''\n        dec = []\n        nchar = math.floor(math.log10(n)/math.log10(27))\n        for ii in range(nchar,0,-1):\n            n_i, n2 = n2//27**ii, n2%27**ii\n            dec.append(n_i)\n        dec.append(n2)\n        \n        message = \"\".join([list_char[ii] for ii in dec])\n        return message\n", "import string\n\n\nclass PlayingCards:\n    CHARSET = \" \" + string.ascii_uppercase\n    DECK = [card + suit for suit in \"CDHS\" for card in \"A23456789TJQK\"]\n    DECKSIZE = len(DECK)\n    MAX_FACT = 80658175170943878571660636856403766975289505440883277824000000000000 # 52!\n\n    def encode(self, msg: string):\n        # validate input\n        if any(c not in self.CHARSET for c in msg):\n            return None\n\n        # calculate desired permutation index from input message\n        perm_index = sum(self.CHARSET.index(c) * pow(27, i) for i, c in enumerate(reversed(msg)))\n        if perm_index >= self.MAX_FACT:\n            # index too large, invalid input\n            return None\n\n        # calculate factoradic (factorial representation)\n        frep = []\n        i = 0\n        while perm_index:\n            i += 1\n            frep.append(perm_index % i)\n            perm_index = perm_index // i\n        frep.reverse()\n\n        # return deck permutation \n        left_part = self.DECK[: self.DECKSIZE - len(frep)]\n        right_part = self.DECK[self.DECKSIZE - len(frep) :]\n        return left_part + [right_part.pop(pos) for pos in frep]\n\n\n    def decode(self, input_deck: list):\n        # validate input\n        if any(card not in self.DECK for card in input_deck) or len(set(input_deck)) != self.DECKSIZE:\n            return None\n        \n        # find permutation index of input deck\n        j = 0\n        perm_index = 0\n        while j < self.DECKSIZE:\n            i = 1\n            factor = 1\n            while i < self.DECKSIZE - j:\n                factor *= i\n                i += 1\n            i = 0\n            index = self.DECK.index(input_deck[j])\n            while i < j:\n                if self.DECK.index(input_deck[i]) < self.DECK.index(input_deck[j]):\n                    index -= 1\n                i += 1\n            perm_index += index * factor\n            j += 1\n\n        # convert deck permutation index to message\n        message = ''\n        i = 0\n        while perm_index:\n            i += 1\n            message = self.CHARSET[perm_index % 27] + message\n            perm_index = perm_index // 27\n        return message\n", "import math\nimport numpy as np\nd = {\n            \" \":0,\n            \"A\":1,\n            \"B\":2,\n            \"C\":3,\n            \"D\":4,\n            \"E\":5,\n            \"F\":6,\n            \"G\":7,\n            \"H\":8,\n            \"I\":9,\n            \"J\":\"A\",\n            \"K\":\"B\",\n            \"L\":\"C\",\n            \"M\":\"D\",\n            \"N\":\"E\",\n            \"O\":\"F\",\n            \"P\":\"G\",\n            \"Q\":\"H\",\n            \"R\":\"I\",\n            \"S\":\"J\",\n            \"T\":\"K\",\n            \"U\":\"L\",\n            \"V\":\"M\",\n            \"W\":\"N\",\n            \"X\":\"O\",\n            \"Y\":\"P\",\n            \"Z\":\"Q\"\n\n            }\n\ns_deck = [\"AC\",\"2C\",\"3C\",\"4C\",\"5C\",\"6C\",\"7C\",\"8C\",\"9C\",\"TC\",\"JC\",\"QC\",\"KC\"\n            ,\"AD\",\"2D\",\"3D\",\"4D\",\"5D\",\"6D\",\"7D\",\"8D\",\"9D\",\"TD\",\"JD\",\"QD\",\"KD\"\n            ,\"AH\",\"2H\",\"3H\",\"4H\",\"5H\",\"6H\",\"7H\",\"8H\",\"9H\",\"TH\",\"JH\",\"QH\",\"KH\"\n            ,\"AS\",\"2S\",\"3S\",\"4S\",\"5S\",\"6S\",\"7S\",\"8S\",\"9S\",\"TS\",\"JS\",\"QS\",\"KS\"]\n\nclass PlayingCards:\n\n        def encode(self, message):\n\n            if message == \"\":\n                message = \" \"\n                \n            if len(message) > 52:\n                return None\n            \n            meslis = [str(x) for x in message]\n            for i in range(len(meslis)):\n                if meslis[i] in d:\n                    None\n                else:\n                    return None   \n            \n            bnum = \"\".join([str(d[x]) for x in message])\n            num = int(bnum,27)\n            if num >= math.factorial(52):\n                return None\n\n            \n            fact = []\n            for j in range(1,53):\n                fact.insert(0,num%j)\n                num = int(num // j)\n            \n            \n            final = [\"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\"\n            ,\"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\"\n            ,\"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\"\n            ,\"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\"]\n            \n    \n            s_deckc = s_deck.copy()\n    \n    \n            for v in range(0,52):\n                final[v]=s_deckc[fact[v]]\n                del s_deckc[fact[v]]\n\n\n            return final\n    \n\n        def decode(self,deck):\n            \n            \n            s_deckc = s_deck.copy()\n            \n            \n            if len(deck)!=52:\n                return None\n\n            dfact = []\n            numb=0           \n            for i in range(52):\n                if deck[i] in s_deckc:\n                    None\n                else:\n                    return None  \n                fact = int(s_deckc.index(deck[i]))\n                del s_deckc[fact]\n                numb += fact * math.factorial(51-i)\n            \n            if numb == 0:\n                return \"\"\n            \n            basetws = np.base_repr(numb, base=27) \n            btws_list = [str(x) for x in basetws]\n            r_d = {str(value) : str(key) for (key, value) in d.items()}\n\n            word = []\n    \n            for i in range(len(btws_list)):\n                word.append(r_d[btws_list[i]])\n            return \"\".join(word)     ", "class PlayingCards:\n    \n    def __init__(self):\n        self.alphabet = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        self.factorials = [1]\n        self.deck = [\"AC\", \"2C\", \"3C\", \"4C\", \"5C\", \"6C\", \"7C\", \"8C\", \"9C\", \"TC\", \"JC\", \"QC\", \"KC\",\n                     \"AD\", \"2D\", \"3D\", \"4D\", \"5D\", \"6D\", \"7D\", \"8D\", \"9D\", \"TD\", \"JD\", \"QD\", \"KD\",\n                     \"AH\", \"2H\", \"3H\", \"4H\", \"5H\", \"6H\", \"7H\", \"8H\", \"9H\", \"TH\", \"JH\", \"QH\", \"KH\",\n                     \"AS\", \"2S\", \"3S\", \"4S\", \"5S\", \"6S\", \"7S\", \"8S\", \"9S\", \"TS\", \"JS\", \"QS\", \"KS\"]\n        \n        for i in range(1, 52): self.factorials.append(self.factorials[-1] * i)\n    \n    def encode(self, message):\n        code = self.numeral(message)\n        copy = self.deck.copy()\n        facts = self.factorials.copy()\n        encrypted = []\n        \n        for letter in message:\n            if letter not in self.alphabet: return None\n            else: pass\n\n        if code > (self.factorials[-1] * 52) - 1: return None\n        \n        for i in range(len(self.deck)):\n            x, code = divmod(code, facts.pop())\n            encrypted.append(copy[x])\n            copy.remove(copy[x])\n            \n        return encrypted\n\n    def decode(self, deck):\n        copy = self.deck.copy()\n        facts = self.factorials.copy()\n        row = 0\n        \n        for i in range(len(self.deck)):\n            try:\n                if deck[i] in copy:\n                    x = copy.index(deck[i])\n                    row += facts.pop()*x\n                    copy.remove(deck[i])\n                else: return None\n            except: return None\n            \n        message = self.string(int(row), 27)\n        if message == \" \": return ''\n        else: return message \n    \n    @staticmethod\n    def numeral(string):\n        return sum([((27**i)*(ord(char)-64)) for i,char in enumerate(string.replace(\" \", \"@\")[::-1])])\n    \n    def string(self, n, base):\n        if n < base:\n            return self.alphabet[n]\n        else:\n            return self.string(n//base,base) + self.alphabet[n%base]", "import itertools as it\nimport math\nimport string\n\nclass PlayingCards:\n\n    def __init__(self):\n        self.cards = ['AC', '2C', '3C', '4C', '5C', '6C', '7C', '8C', '9C', 'TC', 'JC', 'QC', 'KC', 'AD', '2D', '3D', '4D', '5D', '6D', '7D', '8D', '9D', 'TD', 'JD', 'QD', 'KD', 'AH', '2H', '3H', '4H', '5H', '6H', '7H', '8H', '9H', 'TH', 'JH', 'QH', 'KH', 'AS', '2S', '3S', '4S', '5S', '6S', '7S', '8S', '9S', 'TS', 'JS', 'QS', 'KS']\n        self.alphabet = [' '] + [letter for letter in string.ascii_uppercase]\n\n    def message_to_cypher_value(self, clear_string):\n        alphabet_size = len(self.alphabet)\n        output = 0\n        for letter in clear_string:\n            output = output * alphabet_size + self.alphabet.index(letter)\n        return output\n    \n    # Takes a String containing a message, and returns an array of Strings representing\n    # a deck of playing cards ordered to hide the message, or None if the message is invalid.\n    def encode(self, message):\n        for letter in message:\n            if letter not in self.alphabet:\n                return None\n        remaining_cards = list(self.cards)\n        n = self.message_to_cypher_value(message)\n        if n > math.factorial(52)-1:\n            return None\n        output = []\n        while remaining_cards:\n            permutations_per_card = math.factorial(len(remaining_cards)) // len(remaining_cards)\n            current_index = n // permutations_per_card\n            output.append(remaining_cards.pop(current_index))\n            n -= current_index * permutations_per_card\n        return output\n\n    \n    def deck_to_cypher_value(self, deck):\n        remaining_cards = list(self.cards)\n        output = 0\n        for card in deck:\n            permutations_per_card = math.factorial(len(remaining_cards)) // len(remaining_cards)\n            current_index = remaining_cards.index(card)\n            output += current_index * permutations_per_card\n            remaining_cards.pop(current_index)\n        return output\n    \n    # Takes an array of Strings representing a deck of playing cards, and returns\n    # the message that is hidden inside, or None if the deck is invalid.\n    def decode(self, deck):\n        printDeck(deck, False)\n        if len(deck) > len(self.cards):\n            return None\n        if len(set(deck)) < len(self.cards):\n            return None\n        for card in deck:\n            if not card in self.cards:\n                return None\n        n = self.deck_to_cypher_value(deck)\n        alphabet_size = len(self.alphabet)\n        output = []\n        while n > 0:\n            output.append(n % alphabet_size)\n            n = (n - output[-1])//alphabet_size\n        return ''.join([self.alphabet[x] for x in output[::-1]])\n", "from math import factorial\nstack = [\n    \"AC\", \"2C\", \"3C\", \"4C\", \"5C\", \"6C\", \"7C\", \"8C\", \"9C\", \"TC\", \"JC\", \"QC\", \"KC\",\n    \"AD\", \"2D\", \"3D\", \"4D\", \"5D\", \"6D\", \"7D\", \"8D\", \"9D\", \"TD\", \"JD\", \"QD\", \"KD\",\n    \"AH\", \"2H\", \"3H\", \"4H\", \"5H\", \"6H\", \"7H\", \"8H\", \"9H\", \"TH\", \"JH\", \"QH\", \"KH\",\n    \"AS\", \"2S\", \"3S\", \"4S\", \"5S\", \"6S\", \"7S\", \"8S\", \"9S\", \"TS\", \"JS\", \"QS\", \"KS\"\n]\nnumeral = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nclass PlayingCards:\n    def encode(self, message):\n        tom,tim,s,deck,new = [],1,0, stack.copy(),[]\n        try: \n            for i,x in enumerate(message): s += numeral.index(x) * len(numeral) ** (len(message)-i-1)\n        except ValueError: return None\n        while s>=1:\n            tom.insert(0,s%tim)\n            s = s//tim\n            tim += 1\n        if len(tom) >52: return None\n        while len(tom)!= 52:tom.insert(0,0)\n        for x in tom:\n            new.append(deck[x])\n            deck.remove(deck[x])\n        return new\n\n    def decode(self, new):\n        yo,haha,plus,deck = [],0,[],stack.copy()\n        if len(new) != 52: return None\n        try:\n            while new:\n                if yo or deck.index(new[0]) != 0: yo.append(deck.index(new[0]))\n                deck.remove(new[0])\n                new.remove(new[0])\n        except ValueError: return None\n        for i,x in enumerate(yo): haha += x * factorial(len(yo) - i - 1)\n        for x in range(100000000):\n            if (27**x) > haha: break    \n        for e in reversed(range(x)):\n            for b in range(27):\n                if (b + 1) * (27**e) > haha:\n                    haha -= b*(27**e)\n                    plus.append(b)\n                    break\n        return ''.join([numeral[x] for x in plus])", "from math import factorial\n\nclass PlayingCards:    \n    \n    def __init__(self):\n        \n        self.chars = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n        \n        self.ranks = 'A23456789TJQK'\n        self.suits = 'CDHS'\n        self.cards = [rank + suit for suit in self.suits for rank in self.ranks]\n\n    def encode(self, message):\n\n        if any(ch not in self.chars for ch in message):\n            return None\n        \n        char_vals = {v: i for i, v in enumerate(self.chars)}\n        perm_ind = sum(int(self.n_to_base_27(char_vals[ch])*27**(len(message) - i - 1)) for i, ch in enumerate(message))\n        \n        if perm_ind >= factorial(52):\n            return None\n        \n        return self.card_permutation(perm_ind)\n    \n    def decode(self, deck):\n      \n        if not all(card in self.cards for card in deck) or len(set(deck)) != 52:\n            return None\n        \n        val_chars = {i: v for i, v in enumerate(self.chars)}\n        lex_index = 0\n\n        for i in range(len(deck)):\n            s = 0\n            for j, v in enumerate(deck[i + 1:]):\n                if self.cards.index(v) < self.cards.index(deck[i]):\n                    s += 1 \n            lex_index += s*factorial(len(deck) - i - 1) \n            \n        char_arr = []\n        while lex_index:\n            lex_index, i = divmod(lex_index, 27)\n            char_arr.append(val_chars[i])\n            \n        return ''.join(char_arr[::-1])\n    \n    @staticmethod\n    def n_to_base_27(n):\n        \n        if n == 0:\n            return 0\n        d = []\n        while n:\n            d.append(n%27)\n            n //= 27\n        return int(''.join(map(str, d[::-1])))\n\n    def card_permutation(self, k):\n        \n        factorial_arr = [1]\n        for i in range(2, 52):\n            factorial_arr.append(factorial_arr[-1] * i)\n\n        permutation = []\n        res = list(range(52))\n\n        while factorial_arr:\n            factorial = factorial_arr.pop()\n            n, k = divmod(k, factorial)\n            permutation.append(res[n])\n            res.remove(res[n])\n        permutation.append(res[0])\n\n        return [self.cards[i] for i in permutation]", "class PlayingCards:\n    CARDS=['AC', '2C', '3C', '4C', '5C', '6C', '7C', '8C', '9C', 'TC', 'JC', 'QC', 'KC',\n            'AD', '2D', '3D', '4D', '5D', '6D', '7D', '8D', '9D', 'TD', 'JD', 'QD', 'KD',\n            'AH', '2H', '3H', '4H', '5H', '6H', '7H', '8H', '9H', 'TH', 'JH', 'QH', 'KH',\n            'AS', '2S', '3S', '4S', '5S', '6S', '7S', '8S', '9S', 'TS', 'JS', 'QS', 'KS']\n    S=len(CARDS)\n    \n    def __init__(self):\n        self.f=[0]*self.S\n        self.f[0]=1\n        for k in range(1,self.S):\n            self.f[k]=self.f[k-1]*k\n            \n        self.CARD_index={c:self.CARDS.index(c)for c in self.CARDS}\n        \n    def baseEncode(self,s):\n        r=0\n        for c in s:\n            r*=27\n            r+=ord(c)%32\n        return r\n\n    def baseDecode(self,n):\n        s=''\n        while n:\n            n,c=divmod(n,27)\n            s=(chr(64+c)if c else' ')+s\n        return s\n    \n    def permute(self,n):\n        S=52\n        p=[0]*S\n        for k in range(S):\n            p[k],n=divmod(n,self.f[S-1-k])\n        for k in range(S-1,0,-1):\n            for j in range(k-1,-1,-1):\n                if p[j]<=p[k]:\n                    p[k]+=1\n        return [self.CARDS[i]for i in p]\n        \n    # Takes a String containing a message, and returns an array of Strings representing\n    # a deck of playing cards ordered to hide the message, or None if the message is invalid.\n    def encode(self, message):\n        if not all(c==' 'or 'A'<=c<='Z' for c in message):return\n        n=self.baseEncode(message)\n        if n>=80658175170943878571660636856403766975289505440883277824000000000000:return\n        p=self.permute(n)\n        return p\n\n    # Takes an array of Strings representing a deck of playing cards, and returns\n    # the message that is hidden inside, or None if the deck is invalid.\n    def decode(self, deck):\n        if set(deck)!=set(self.CARDS):return\n        \n        i,j=0,1\n        perm=[self.CARD_index[c]for c in deck]\n        for p in range(50,-1,-1):\n            s=0\n            for q in range(p+1,52):\n                if perm[p]>perm[q]:s+=1\n            i+=s*self.f[j]\n            j+=1\n        return self.baseDecode(i)\n", "class PlayingCards:\n    codex = tuple(n+suit for suit in 'CDHS' for n in 'A23456789TJQK')\n    ix = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    xi = {ch:i for i,ch in enumerate(ix)}\n    \n    @staticmethod\n    def encode(s):\n        q = 0\n        tiers = PlayingCards.get_tiers()\n        for ch in s:\n            if ch not in PlayingCards.xi: return\n            q *= 27\n            q += PlayingCards.xi[ch]\n        if q >= 52*tiers[0]: return\n        for i,x in enumerate(tiers):\n            if q >= x: break\n        codex = list(PlayingCards.codex[:i])\n        cdx = list(PlayingCards.codex[i:])\n        for n in tiers[i:]:\n            v = q // n\n            q %= n\n            codex.append(cdx.pop(v))\n        return codex + cdx\n    \n    @staticmethod\n    def decode(r):\n        if set(r) != set(PlayingCards.codex): return\n        q = 0\n        tiers = PlayingCards.get_tiers()\n        for i,card in enumerate(r):\n            if card != PlayingCards.codex[i]: break\n        tiers = tiers[i:]\n        cdx = list(PlayingCards.codex[i:])\n        for card,tier in zip(r[i:],tiers):\n            j = cdx.index(card)\n            q += j * tier\n            cdx.pop(j)\n        s = ''\n        while q:\n            v = q % 27\n            q //= 27\n            s += PlayingCards.ix[v]\n        return s[::-1]\n    \n    @staticmethod\n    def get_tiers():\n        r = []\n        c = 1\n        for i in range(1,52):\n            c *= i\n            r.append(c)\n        return r[::-1]"]