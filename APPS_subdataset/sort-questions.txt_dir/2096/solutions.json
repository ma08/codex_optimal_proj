["\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn=int(input())\nb=list(map(int,input().split()))\nbb=sorted(b)\nc={bb[i]:i for i in range(n)}\na=[c[b[i]] for i in range(n)]\nvis=[0]*n\n\nout=[]\nfor i in range(n):\n    if vis[i]: continue\n    vis[i]=1\n    newlist=[i]\n    while a[newlist[-1]]!=i:\n        newlist.append(a[newlist[-1]])\n        vis[newlist[-1]]=1\n    out.append(newlist)\n\nprint(len(out))\nfor i in out:\n    print(\" \".join([str(x+1) for x in [len(i)-1]+i]))\n", "n = int(input())\na = list(map(int, input().split()))\n\nx = sorted([(a[i], i) for i in range(n)])\n\ncycles = []\n\nwas = [False for i in range(n)]\nfor i in range(n):\n    if was[i]:\n        continue\n    cur = i\n    cyc = []\n    while not was[cur]:\n        was[cur] = True\n        cyc.append(cur + 1)\n        cur = x[cur][1]\n    cycles.append(cyc)\n\nprint(len(cycles))\nfor cyc in cycles:\n    print(len(cyc), ' '.join(map(str, cyc)))\n", "n = int(input())\n\na = input().split()\na = [(int(a[i]), i) for i in range(n)]\na.sort()\n\nstart = 0\nused = set()\n\nb = []\n\nwhile start < n:\n    t = []\n    cur = start\n    first = True\n\n    while cur != start or first:\n        first = False\n        t.append(cur+1)\n        used.add(cur)\n        cur = a[cur][1]\n    \n    b.append(t)\n    while start in used: start += 1\n\nprint(len(b))\n\nfor t in b:\n    print(len(t), end=' ')\n    print(*t)", "import sys\nn = int(input())\na = list(map(int, input().split()))\na = sorted([(a[i], i) for i in range(n)])\nd = []\nc = [False]*n\nfor i in range(n):\n    if not c[i]:\n        k = i\n        p = []\n        while not c[k]:\n            c[k] = True\n            p.append(str(k+1))\n            k = a[k][1]\n        d.append(p)\n        \nprint(len(d))\nfor i in d:\n    print(str(len(i))+\" \"+\" \".join(i))", "def binSearch(arr, el):\n    if len(arr) == 0: return -1\n    l, p = 0, len(arr)-1\n    while l != p:\n        s = (l+p) // 2\n        if arr[s] < el:\n            l = s + 1\n        else:\n            p = s\n    return l if arr[l] == el else -1\n\nn = int(input())\na = [int(i) for i in input().split()]\ns = sorted(a)\n\nsubsList = []\nvisited = [False for i in range(n)]\nfor i in range(n):\n    ind = i\n    newSub = False\n    while not visited[ind]:\n        if not newSub:\n            subsList.append([])\n        newSub = True\n        visited[ind] = True\n        subsList[-1].append(str(ind+1))\n        ind = binSearch(s, a[ind])\n    \nout = str(len(subsList)) + \"\\n\"\nfor lineNr in range(len(subsList)-1):\n    \n    out += str(len(subsList[lineNr])) + \" \"\n    out += \" \".join(subsList[lineNr]) + \"\\n\"\nout += str(len(subsList[-1])) + \" \"    \nout += \" \".join(subsList[-1])\nprint(out)\n        \n\n", "n = int(input())\na = list(map(int, input().split()))\na = sorted([(a[i], i) for i in range(n)])\nb = []\nc = [True] * n\nfor i in range(n):\n    if c[i]:\n        j = i\n        d = []\n        while c[j]:\n            c[j] = False\n            d.append(j + 1)\n            j = a[j][1]\n        b.append(d)\n\nprint(len(b))\nfor i in b:\n    print(len(i),*i)", "n = int(input())\na = [int(i) for i in input().split()]\na = [i[0] for i in sorted(enumerate(a), key= lambda x:x[1])]\nchecker = [0 for i in range(n)]\nans_set = []\nfor i in range(n):\n    if checker[i] == 0:\n        tmp = set([i])\n        next_step = i\n        next_step = a[next_step]\n        while next_step != i:\n            checker[next_step] = 1\n            tmp.add(next_step)\n            next_step = a[next_step]\n        ans_set.append(tmp)\nprint(len(ans_set))\nfor tmp in ans_set:\n    print(len(tmp), end = \" \")\n    for j in tmp:\n        print(j+1, end = \" \")\n    print()\n  \t\t\t\t   \t \t\t  \t \t\t \t \t  \t \t\t\t", "import sys\ncases = int(sys.stdin.readline())\ninput_arr = [int(x) for x in sys.stdin.readline().strip().split(\" \")]\n#input_arr = [-1, -4, 10, 9, 200]\n\nsort = sorted(input_arr)\nsorted_dict = dict()\nfor i in range(0, len(sort)):\n  sorted_dict[sort[i]] = i + 1\n\narray = []\nfor x in input_arr:\n  array.append(sorted_dict[x])\n\nseen = set()\n\nmy_dict = dict()\nfor i in range(1, len(array) + 1):\n  my_dict[i] = array[i - 1]\n  \ndef find_permutation(seen, x):\n  permutation = []\n  while(x not in seen):\n    permutation.append(x)\n    seen.add(x)\n    x = my_dict[x]\n    \n  return(str(len(permutation)) + \" \" + \" \".join(str(x) for x in sorted(permutation)))\n\nnum_perms = 0\nto_print = []\nfor x in array:\n  if(x not in seen):\n    num_perms += 1\n    to_print.append(find_permutation(seen, x)) \n    seen.add(x)\n\nprint(num_perms)\nprint('\\n'.join(to_print))\n\n", "n = int(input())\n\na = sorted(zip(list(map(int, input().split())), list(range(n))))\n\ns = []\n\nfor i in range(n):\n\n    if a[i]:\n\n        l = []\n\n        s.append(l)\n\n        while a[i]:\n\n            l.append(i + 1)\n\n            a[i], i = None, a[i][1]\n\n            \n\nprint(len(s))\n\nfor l in s:\n\n    print(len(l), *l)\n\n\n\n\n\n\n\n# Made By Mostafa_Khaled\n", "n=int(input())\na=list(map(int,input().split()))\ns=[(a[i],i) for i in range(n)]\ns.sort()\nx=[-1]*n\nfor i in range(n):\n    x[s[i][1]]=i\nans=[]\nfor i in range(n):\n    if x[i]!=-1:\n        j=i\n        q=[]\n        while x[j]!=-1:\n            q.append(str(j+1))\n            t=j\n            j=x[j]\n            x[t]=-1\n        ans.append(str(len(q))+' '+' '.join(q))\nprint(len(ans))\nprint(*ans, sep='\\n')\n", "import operator as op\n\n\ninput()\na = list(x[0] for x in sorted(enumerate(map(int, input().split())), key=op.itemgetter(1)))\n\nans = []\nfor i in range(len(a)):\n    if a[i] != -1:\n        j = a[i]\n        a[i] = -1\n        t = [i + 1]\n        while j != i:\n            t.append(j + 1)\n            last = j\n            j = a[j]\n            a[last] = -1\n        ans.append(t)\n\nprint(len(ans))\nfor i in range(len(ans)):\n    print(len(ans[i]), *ans[i])\n", "n = int(input())\na = sorted(zip(map(int, input().split()), range(n)))\n# print(a)\ns = []\n\nfor i in range(n):\n    if a[i]:\n        s.append([])\n        j=i\n        while a[j]:\n            s[-1].append(j + 1)\n            a[j], j = None, a[j][1]\n            \nprint(len(s))\nfor l in s:\n    print(len(l), *l)", "MOD = 1000000007\nii = lambda : int(input())\nsi = lambda : input()\ndgl = lambda : list(map(int, input()))\nf = lambda : map(int, input().split())\nil = lambda : list(map(int, input().split()))\nls = lambda : list(input())\nn=ii()\nl=il()\nl2=sorted(l)\nsd=dict((l2[i],i) for i in range(n))\nans=[]\nlvis=set()\nfor i in range(n):\n    if not l[i] in lvis:\n        tmp=[i+1]\n        x=sd[l[i]]\n        lvis.add(l[i])\n        while x!=i:\n            lvis.add(l[x])\n            tmp.append(x+1)\n            x=sd[l[x]]\n        ans.append(tmp)\nprint(len(ans))\nfor i in ans:\n    print(len(i),*i)", "n = int(input())\na = list(map(int,input().split()))\nx = sorted([(a[i], i) for i in range(n)])\nans = []\nvisited = [False for i in range(n)]\n\nfor i in range(n):\n    if visited[i]:\n        continue\n    cur = i\n    cyc = []\n    while not visited[cur]:\n        visited[cur] = True\n        cyc.append(cur + 1)\n        cur = x[cur][1]\n    ans.append(cyc)\n \nprint(len(ans))\nfor cyc in ans:\n    print(len(cyc), ' '.join(map(str, cyc)))", "n = int(input())\na = list(map(int,input().split()))\nx = sorted([(a[i], i) for i in range(n)])\nans = []\nvisited = [False for i in range(n)]\n\nfor i in range(n):\n    if visited[i]:\n        continue\n    cur = i\n    cyc = []\n    while not visited[cur]:\n        visited[cur] = True\n        cyc.append(cur + 1)\n        cur = x[cur][1]\n    ans.append(cyc)\n \nprint(len(ans))\nfor cyc in ans:\n    print(len(cyc),*cyc)", "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\nclass Unionfind:\n    def __init__(self, n):\n        self.par = [-1]*n\n        self.rank = [1]*n\n    \n    def root(self, x):\n        p = x\n        \n        while not self.par[p]<0:\n            p = self.par[p]\n        \n        while x!=p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        \n        return p\n    \n    def unite(self, x, y):\n        rx, ry = self.root(x), self.root(y)\n        \n        if rx==ry: return False\n        \n        if self.rank[rx]<self.rank[ry]:\n            rx, ry = ry, rx\n        \n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n    \n        if self.rank[rx]==self.rank[ry]:\n            self.rank[rx] += 1\n    \n    def is_same(self, x, y):\n        return self.root(x)==self.root(y)\n    \n    def count(self, x):\n        return -self.par[self.root(x)]\n\nn = int(input())\na = list(map(int, input().split()))\nb = a[:]\nb.sort()\nd = defaultdict(int)\n\nfor i in range(n):\n    d[b[i]] = i\n\nuf = Unionfind(n)\n\nfor i in range(n):\n    uf.unite(i, d[a[i]])\n\nans = defaultdict(list)\n\nfor i in range(n):\n    ans[uf.root(i)].append(i)\n\nprint(len(list(ans.keys())))\n\nfor l in ans.values():\n    print(len(l), *list(map(lambda x: x+1, l)))", "#!/usr/bin/env python\n\nfrom sys import stdin\nfrom collections import defaultdict\n\n# Go from node start and return a list of visited nodes\ndef dfs(graph, seen, start):\n    if seen[start]:\n        return None\n\n    visit = [start]\n    ans = []\n    while visit:\n        node = visit.pop()\n        seen[node] = True\n        ans.append(node)\n        for v in graph[node]:\n            if not seen[v]:\n                visit.append(v)\n\n    return ans\n\ndef main(n, arr):\n    orig = {}\n    for i in range(n):\n        val = arr[i]\n        orig[val] = i\n    _arr = sorted(arr)\n\n    g = defaultdict(list)\n    for i in range(n):\n        val = _arr[i]\n        origpos = orig[val]\n        g[origpos].append(i) # there's a connection between this two positions\n    \n    seen = [False] * n\n    ans = []\n    for i in range(n): # ensure we visit all nodes\n        if not seen[i]:\n            ans.append(dfs(g, seen, i))\n\n    print(len(ans))\n    for a in ans:\n        print(len(a), \" \".join(map(lambda x: str(x + 1), a))) # add 1 for 1 based index\n\n\ndef __starting_point():\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split(\" \")))\n    main(n, arr)\n__starting_point()", "from collections import Counter,defaultdict,deque\n#alph = 'abcdefghijklmnopqrstuvwxyz'\n#from math import factorial as fact\nimport math\n\n#nl = '\\n'\n#import sys\n#input=sys.stdin.readline\n#print=sys.stdout.write\n\n#tt = int(input())\n#total=0\n#n = int(input())\n#n,m,k = [int(x) for x in input().split()]\n#n = int(input())\n\n#l,r = [int(x) for x in input().split()]\n\nn = int(input())\narr = [int(x) for x in input().split()]\nd = {}\nvisited = {}\nfor i in range(n):  \n   d[arr[i]] = i  \n   visited[arr[i]] = False\nres =[]\nsarr = sorted(arr)\nfor el in sarr:\n   cur = []\n   nxt = el\n   while True:\n      if visited[nxt]:\n         break\n      visited[nxt] = True\n      cur.append(d[nxt])\n      nxt = sarr[d[nxt]]\n   if len(cur):\n      res.append(cur)\nprint(len(res))\nfor el in res:\n   print(len(el),end=' ')\n   for p in el:\n      print(p+1,end = ' ')\n   print()\n      \n   \n   \n \n", "from sys import stdin\ninput=stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nn=I();v=[1]*n\na=list(R());d={}\nfor i,j in enumerate(sorted(a)):d[j]=i\nfor i in range(n):a[i]=d[a[i]]\nans=[]\nfor i in a:\n\tif v[i]:\n\t\tans+=[],\n\t\twhile v[i]:\n\t\t\tans[-1]+=i+1,\n\t\t\tv[i]=0\n\t\t\ti=a[i]\nprint(len(ans))\nfor i in ans:\n\tprint(len(i),*i)", "from sys import stdin\ninput=stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nn=I();v=[1]*n\na=list(R());d={}\nfor i,j in enumerate(sorted(a)):d[j]=i\nans=[]\nfor i in a:\n\tp=d[i]\n\tif v[p]:\n\t\tans+=[],\n\t\twhile v[p]:\n\t\t\tans[-1]+=p+1,\n\t\t\tv[p]=0\n\t\t\tp=d[a[p]]\nprint(len(ans))\nfor i in ans:\n\tprint(len(i),*i)", "from sys import stdin\ninput=stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nn=I();v=[1]*n\na=list(R());d={}\nfor i,j in enumerate(sorted(a)):d[j]=i\nans=[]\nfor i in a:\n\tp=d[i]\n\tif v[p]:\n\t\tl=0\n\t\tans+=[],\n\t\twhile v[p]:\n\t\t\tans[-1]+=p+1,\n\t\t\tv[p]=0\n\t\t\tp=d[a[p]]\n\t\t\tl+=1\n\t\tans[-1]+=l,\nprint(len(ans))\nfor i in ans:\n\tprint(i[-1],*i[:i[-1]])", "from sys import stdin\ninput=stdin.readline\nR=lambda:map(int,input().split())\nI=lambda:int(input())\nn=I();v=[1]*n\na=list(R());d={}\nfor i,j in enumerate(sorted(a)):d[j]=i\nans=[]\nfor i in a:\n\tp=d[i]\n\tif v[p]:\n\t\tl=0\n\t\tans+=[],\n\t\twhile v[p]:\n\t\t\tans[-1]+=p+1,\n\t\t\tv[p]=0\n\t\t\tp=d[a[p]]\n\t\t\tl+=1\n\t\tans[-1]+=l,\nprint(len(ans))\nfor i in ans:\n\tprint(i[-1],*i[:i[-1]])", "n = int(input())\na = list(map(int, input().split()))\n\nsorted_a = sorted(a)\nd = {}\nfor i in range(len(a)): d[sorted_a[i]] = i\nfor i in range(len(a)): a[i] = d[a[i]]\n\nres = []\ndone = [False]*n\nfor i in a:\n    if done[i]: continue\n    done[i] = True\n    curr_subseq = set([i])\n    next_item = a[i]\n    while next_item not in curr_subseq:\n        curr_subseq.add(next_item)\n        done[next_item] = True\n        next_item = a[next_item]\n    res.append(curr_subseq)\n\nprint(len(res))\nfor i in res:\n    curr = [str(j+1) for j in list(i)]\n    print(len(curr), end=' ')\n    print(' '.join(curr))", "from collections import defaultdict\ndef DFS(d,visited,x):\n\n\tstack = [x]\n\tans = []\n\n\twhile len(stack):\n\n\t\ttemp = stack.pop()\n\t\tvisited[temp] = 1\n\t\tans.append(temp+1)\n\t\tfor i in d[temp]:\n\n\t\t\tif visited[i] == 0:\n\t\t\t\tstack.append(i)\n\t\t\t\tvisited[temp] = 1\n\n\treturn ans\n\nn = int(input())\nl = list(map(int,input().split()))\nact_pos = {l[i]:i for i in range(n)}\npos = []\nt = sorted(l)\npos = {t[i]:i for i in range(n)}\n\nd = defaultdict(list)\n\nfor i in l:\n\n\td[act_pos[i]].append(pos[i])\n\n\nvisited = [0 for i in range(n)]\nans = []\nfor i in range(n):\n\n\tif visited[i] == 0:\n\n\t\tk = list(DFS(d,visited,i))\n\n\t\tt1 = k[::-1]\n\t\tt1.append(len(k))\n\n\t\tans.append(t1[::-1])\nprint(len(ans))\nfor i in ans:\n\tprint(*i)\n"]