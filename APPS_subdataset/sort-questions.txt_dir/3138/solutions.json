["def climb(n):\n    return [1] if n == 1 else climb(int(n/2)) + [n]", "# If we write the decision tree for the problem we can see\n# that we can traverse upwards from any node simply by\n# dividing by two and taking the floor. This would require\n# a reversal of the list generated since we're building it\n# backwards.\n# \n# If we examine the successor function (x -> {2x, 2x + 1})\n# we can deduce that the binary representation of any number\n# gives us the steps to follow to generate it: if the n-th (LTR)\n# bit is set, we use 2x + 1 for the next element, otherwise we\n# choose 2x. This allows us to build the sequence in order.\n\ndef climb(n):\n    res = []\n    cur = 1\n    mask = 1 << max(0, n.bit_length() - 2)\n\n    while cur <= n:\n        res.append(cur)\n        cur = 2*cur + (1 if (n & mask) != 0 else 0)\n        mask >>= 1\n\n    return res", "def climb(n):\n    result = [1]\n    for x in \"{:b}\".format(n)[1:]:\n        result.append(result[-1]*2 + (x=='1'))\n    return result", "def climb(n):\n    return [n >> i for i in range(len(f\"{n:b}\") - 1, -1, -1)]", "from math import log\nfrom collections import deque\n    \ndef climb(n):\n    return [n//2**i for i in range(int(log(n, 2)) + 1)][::-1]\n\ndef climb(n):\n    \"\"\"This is much faster.\"\"\"\n    seq = deque([n])\n    while n > 1:\n        n //= 2\n        seq.appendleft(n)\n    return list(seq)", "def climb(n):\n    #your code here\n    return  [n>>n.bit_length()-i-1 for i in range(n.bit_length())]\n", "def climb(n):\n    return list(climb_iterator(n))\n    \ndef climb_iterator(n):\n    cursor = 0\n    for digit in bin(n)[2:]:\n        cursor = 2 * cursor + int(digit)\n        yield cursor", "def climb(n):\n  res = [n]\n  while res[-1] != 1: res.append(res[-1]//2)\n  return res[::-1]", "def climb(n):\n    arr = []\n    while n:\n        arr.append(n)\n        n //= 2\n    return arr[::-1]"]