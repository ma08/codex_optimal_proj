["def complete_binary_tree(a):\n    def in_order(n=0):\n        if n < len(a):\n            yield from in_order(2 * n + 1)\n            yield n\n            yield from in_order(2 * n + 2)\n\n    result = [None] * len(a)\n    for i, x in zip(in_order(), a):\n        result[i] = x\n    return result", "def mid(n):\n    x = 1 << (n.bit_length() - 1)\n    return x-1 if x//2 - 1 <= n-x else n-x//2\n\ndef complete_binary_tree(a):\n    res, queue = [], [a]\n    while queue:\n        L = queue.pop(0)\n        m = mid(len(L))\n        res.append(L[m])\n        if m: queue.append(L[:m])\n        if m < len(L)-1: queue.append(L[m+1:])\n    return res", "import math\n\ndef complete_binary_tree(a):\n    ret = []\n    rows = [a]\n    \n    while len(rows):\n        newrows = []\n        #print(rows)\n        for x in rows:\n            ln = len(x)\n            if ln > 1:\n                pwr = int(math.log(ln+1, 2))\n                complete_part_ln = 2**pwr - 1\n                last_full_row_ln = 2**(pwr-1)\n                free_row_ln = ln - complete_part_ln\n                middle = complete_part_ln // 2 + (last_full_row_ln if free_row_ln > last_full_row_ln else free_row_ln)\n                ret += [x[middle]]\n                newrows += [x[:middle]] + [x[middle+1:]]\n            else:\n                ret += x\n        rows = newrows\n\n    return ret\n\n", "def complete_binary_tree(a):\n    def calculate(a, root = 1, cnt = 0, output = []):\n        idx = list(range(1, len(a)+1))\n        if (not output):\n            output = [0] * len(a)\n        \n        if (root * 2 in idx):\n            cnt, output = calculate(a, root = root * 2, cnt = cnt, output = output)\n    \n        output[root-1] = a[cnt]\n        cnt += 1\n    \n        if (root * 2 + 1 in idx):\n            cnt, output = calculate(a, root = root * 2 + 1, cnt = cnt, output = output)\n        \n        return cnt, output\n    return calculate(a)[1]", "def complete_binary_tree(a):\n    arr1 = []    #\uae30\ubcf8 node\ub4e4\uc774 \ucc28\ub840\ub300\ub85c \uc788\ub294 \ubc30\uc5f4\n    for i in range(len(a)+1):    #\uac1c\uc218\ub9cc\ud07c +1\uc744 \ud574\uc90c. 0\ubd80\ud130 \uc2dc\uc791\ud558\uac8c \ud558\uae30 \uc704\ud568\n        arr1.append(i)\n    stack = []    #inorder \uc21c\uc11c\ub97c \ub098\ud0c0\ub0bc \ubc30\uc5f4\n    \n    def inorder(arr, node):    #inorder\ub77c\ub294 \ud568\uc218\ub294 arr\uc640 node\uac12\uc744 input\uc73c\ub85c \ubc1b\uc74c\n        nonlocal stack    #\ud568\uc218 \ub0b4\uc758 \ud568\uc218\uc5d0\uc11c \ubd80\ub974\ubbc0\ub85c nonlocal\uc744 \uc0ac\uc6a9\ud558\uc5ec \ub0b4\ubd80\uc218\uc815\uc774 \ubc16\uc5d0\ub3c4 \uc601\ud5a5\uc744 \ubbf8\uce58\ub3c4\ub85d \ud568.\n        if(node >= len(arr)):    \n            return\n        inorder(arr, node*2)\n        stack.append(node)\n        inorder(arr, node*2 + 1)\n    inorder(arr1, 1)    #1\ubd80\ud130\ud558\uc5ec inorder \uc21c\uc11c\ub97c \ub530\ub0c4. stack\uc5d0 \uc800\uc7a5\ub428\n        \n    result = [0 for row in range(len(a))]    #result\ub97c \uc800\uc7a5\ud560 \ubc30\uc5f4\uc744 \uc120\uc5b8\ud568.\n    for i, lit in enumerate(result):\n        result[i] = a[stack.index(i+1)]    #\uc54c\ub9de\ub294 \uac12\uc73c\ub85c \ubc14\uafd4\uc90c\n    return result      \n", "def complete_binary_tree(a):\n    l = len(a)\n    ans = [-1]*(l+1)\n    arr = a.copy()\n\n    push_num(1, ans, arr)\n\n    return ans[1:]\n\ndef push_num(idx, ans, a):\n    if(idx >= len(ans) or len(a) == 0):\n        return\n    else:\n        push_num(idx*2, ans, a)\n        ans[idx] = a.pop(0)\n        push_num(idx*2 + 1, ans, a)", "from collections import deque\nfrom math import log2, floor\n\ndef split_tree(a): # return head, left subtree, right subtree\n    top_position = 0\n    number_of_elements = len(a)\n    number_of_layers = floor(log2(number_of_elements)) + 1\n    top_size = 2 ** (number_of_layers - 1) - 1\n    lowest_level_count = number_of_elements - top_size\n    if lowest_level_count >= 2 ** (number_of_layers - 2): # left part of lowest level is full\n        top_position = int(2**(number_of_layers - 1)) - 1\n    else: # right part of lowest level is empty\n        top_position = - (top_size - 1) // 2 - 1\n    return a[top_position], a[:top_position], a[top_position + 1:]\n\ndef complete_binary_tree(a):\n    res = []\n    tree_queue = deque()\n    tree_queue.append(a)\n    while tree_queue:\n        tree = tree_queue.popleft()\n        if tree:\n            (root, left, right) = split_tree(tree)\n            res.append(root)\n            tree_queue.append(left)\n            tree_queue.append(right)\n    return res", "import math\n\ndef complete_binary_tree(a):\n    if len(a) < 2: return a\n    \n    root = build(a)\n    res = []\n    getLevelOrder(root, res)\n    return res\n\nclass Node:\n\n    def __init__(self, data, left, right):\n\n        self.left = left\n        self.right = right\n        self.data = data\n        \n    def __str__(self):\n        return f\"left = {self.left}, right = {self.right}, data = {self.data}\"\n        \ndef build(a):\n\n    if len(a) == 0:\n        return None\n    if len(a) == 1:\n        return Node(a[0], None, None)\n    \n    level = math.log2(len(a))\n    level = math.ceil(level) + (1 if int(level) == level else 0)\n    \n    if len(a) >= 2 ** (level - 2) * 3 - 1:\n        root = 2 ** (level - 1) - 1\n    else:\n        root = len(a) - 2 ** (level - 2)\n    \n    left = build(a[:root])\n    right = build(a[root+1:])\n    return Node(a[root], left, right)\n\ndef getLevelOrder(root, res): \n    h = height(root) \n    for i in range(1, h+1): \n        getGivenLevel(root, i, res) \n\ndef getGivenLevel(root , level, res): \n    if root is None: \n        return\n    if level == 1: \n        res.append(root.data)\n    elif level > 1 : \n        getGivenLevel(root.left , level-1, res) \n        getGivenLevel(root.right , level-1, res)\n\n        \ndef height(node): \n    if node is None: \n        return 0 \n    else : \n        # Compute the height of each subtree  \n        lheight = height(node.left) \n        rheight = height(node.right) \n        \n        #Use the larger one \n        if lheight > rheight : \n            return lheight+1\n        else: \n            return rheight+1", "def floor(num: int):\n    ''' \n    return num - (2**i-1)\n    for max i that 2**i-1 <= num\n    '''\n    print(num)\n    assert num >= 0\n    i = 0\n    while 2**i - 1 <= num:\n        i += 1\n    return num - 2**(i-1) + 1\n\n\ndef complete_binary_tree(a: list) -> list:\n    a = a.copy()\n    breadth_fst: list = []\n    \n    for i in range(floor(len(a))):\n        breadth_fst.append(a.pop(i))\n\n    while a:\n        idx = -1\n        while idx >= -len(a):\n            breadth_fst.insert(0, a.pop(idx))\n            idx -= 1\n\n    return breadth_fst\n", "import math\n\nclass BST:\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n\ndef complete_binary_tree(arr):\n    tree = bst_from_arr(arr)\n    depth = math.floor(math.log(len(arr),2))\n    output = []\n    for i in range(depth+1):\n        output += breadth_first_arr(tree,i)\n    return output\n\ndef breadth_first_arr(tree, level):\n    out = []\n    if tree is None: return\n    if level == 0:\n        out.append(tree.value)\n    elif level > 0:\n        if tree.left: out += breadth_first_arr(tree.left , level-1)\n        if tree.right: out += breadth_first_arr(tree.right , level-1)\n    return out\n\ndef bst_from_arr(arr):\n    if len(arr) > 1:\n        root_index = get_root_index(arr)\n        tree = BST(arr[root_index])\n    else: return BST(arr[0])\n\n    if len(arr[:root_index]) > 1:\n        tree.left = bst_from_arr(arr[:root_index])\n    if len(arr[:root_index]) == 1:\n        tree.left = BST(arr[0])\n\n    if len(arr[root_index+1:]) > 1:\n        tree.right = bst_from_arr(arr[root_index+1:])\n    if len(arr[root_index+1:]) == 1:\n        tree.right = BST(arr[-1])\n    return tree\n\ndef get_root_index(arr):\n    left_subtree = 0\n    levels = math.floor(math.log(len(arr),2))\n    for i in range(0, levels):\n        if not i == levels - 1:\n            left_subtree += 2**i\n        else:\n            left_subtree += min(int((2**levels)/2),len(arr)-(2**(levels)-1))\n    return left_subtree"]