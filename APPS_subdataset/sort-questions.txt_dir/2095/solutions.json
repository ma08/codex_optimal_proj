["input()\nA = list(map(int, input().split(' ')))\nroot=-1\nfor i,a in enumerate(A) :\n    if i == a-1 :\n        root = i\n        break\nv = [False]*len(A)\nif root>-1 :\n    v[root]=True\nans= 0\nfor i,a in enumerate(A) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=A[a]-1\n    if a in l: #new cycle\n        if root==-1:\n            A[a]=a+1\n            root=a\n            ans+=1\n        else :\n            A[a]=root+1\n            ans+=1\nprint(ans)\nprint(' '.join(map(str,A)))\n", "\ntree_size = int(input())\n\nparents = [int(x)-1 for x in input().split(' ')]\n\n\nnum_changes = 0\n\nroot = tree_size\nfor node, parent in enumerate(parents):\n\tif parent == node:\n\t\troot = node\n\t\tbreak\n\nvisited = set()\nfinished = set()\n\nvisited.add(root)\nfinished.add(root)\n\nstack = []\nfringe = []\n\nfor node in range(len(parents)):\n\tif node not in visited:\n\t\tfringe.append(node)\n\t\twhile fringe:\n\t\t\tcur = fringe.pop()\n\t\t\tvisited.add(cur)\n\t\t\tstack.append(cur)\n\n\t\t\tif parents[cur] not in finished:\n\t\t\t\tif parents[cur] in visited:\n\t\t\t\t\tparents[cur] = root\n\t\t\t\t\tnum_changes += 1\n\t\t\t\telse:\n\t\t\t\t\tfringe.append(parents[cur])\n\n\t\twhile stack:\n\t\t\tfinished.add(stack.pop())\n\n\n\nif root == tree_size:\n\tnew_root = None\n\tfor node, parent in enumerate(parents):\n\t\tif parent == root:\n\t\t\tif new_root is None:\n\t\t\t\tnew_root = node\n\t\t\tparents[node] = new_root\n\nfor i in range(len(parents)):\n\tparents[i] += 1\n\n\nprint(num_changes)\nprint(*parents)", "input()\n\nA = list(map(int, input().split(' ')))\n\nroot = -1\n\nfor i,a in enumerate(A) :\n    if i == a-1 :\n        root = i\n        break\n    \nv = [False]*len(A)\nif root>-1 :\n    v[root]=True\n    \nchanged = 0\n\nfor i,a in enumerate(A) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=A[a]-1\n    if a in l: \n        if root==-1:\n            A[a]=a+1\n            root=a\n            changed+=1\n        else :\n            A[a]=root+1\n            changed+=1\n        \nprint(changed)\nprint(' '.join(map(str,A)))\n", "n = int(input())\narr = list(map(int, input().split(' ')))\nroot=-1\nfor i,a in enumerate(arr) :\n    if i == a-1 :\n        root = i\n        break\nv = [False]*len(arr)\nif root>-1 :\n    v[root]=True\nans = 0\nfor i,a in enumerate(arr) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=arr[a]-1\n    if a in l: #new cycle\n        if root==-1:\n            arr[a]=a+1\n            root=a\n            ans+=1\n        else :\n            arr[a]=root+1\n            ans+=1\nprint(ans)\nprint(' '.join(map(str,arr)))\n", "input()\n\nA = list(map(int, input().split(' ')))\n\nroot=-1\n\nfor i,a in enumerate(A) :\n    if i == a-1 :\n        root = i\n        break\n    \nv = [False]*len(A)\nif root>-1 :\n    v[root]=True\n    \nchanged = 0\n\nfor i,a in enumerate(A) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=A[a]-1\n    if a in l: \n        if root==-1:\n            A[a]=a+1\n            root=a\n            changed+=1\n        else :\n            A[a]=root+1\n            changed+=1\n        \nprint(changed)\nprint(' '.join(map(str,A)))", "n = int(input())\narr = list(map(int, input().split(' ')))\nroot=-1\nfor i,a in enumerate(arr) :\n    if i == a-1 :\n        root = i\n        break\nv = [False]*len(arr)\nif root>-1 :\n    v[root]=True\nret = 0\nfor i,a in enumerate(arr) :\n    if v[i] :\n        continue\n    v[i]= True\n    curl=[i] # curret list\n    a-=1\n    while not v[a] :\n        curl.append(a)\n        v[a]=True\n        a=arr[a]-1\n    if a in curl:\n        if root==-1:\n            arr[a]=a+1\n            root=a\n            ret+=1\n        else :\n            arr[a]=root+1\n            ret+=1\nprint(ret)\nprint(' '.join(map(str,arr)))", "input()\n\nA = list(map(int, input().split(' ')))\n\nroot = -1\n\nfor i,a in enumerate(A) :\n    if i == a-1 :\n        root = i\n        break\n    \nv = [False]*len(A)\nif root>-1 :\n    v[root]=True\n    \nchanged = 0\n\nfor i,a in enumerate(A) :\n    if v[i] :\n        continue\n    v[i]= True\n    l=[i]\n    a-=1\n    while not v[a] :\n        l.append(a)\n        v[a]=True\n        a=A[a]-1\n    if a in l: \n        if root==-1:\n            A[a]=a+1\n            root=a\n            changed+=1\n        else :\n            A[a]=root+1\n            changed+=1\n        \nprint(changed)\nprint(' '.join(map(str,A)))\n\n\n\n\n# Made By Mostafa_Khaled\n", "n=int(input())\na=list(map(int,input().split()))\npar=[]\nfor i in range(n):\n\tif a[i]==i+1:\n\t\tpar.append(i)\nv=[False for i in range(n)]\nfor i in par:\n\tv[i]=True\nccl=[]\nfor i in range(n):\n\tif v[i]:continue\n\ts=[i]\n\tv[i]=True\n\tp=set(s)\n\tt=True\n\twhile s and t:\n\t\tx=s.pop()\n\t\tj=a[x]-1\n\t\tif j in p:\n\t\t\tccl.append(j)\n\t\t\tt=False\n\t\telse:\n\t\t\ts.append(j)\n\t\t\tp.add(j)\n\t\tif v[j]:t=False\n\t\telse:v[j]=True\nif len(par)==0:\n\tprint(len(ccl))\n\tc=ccl[0]\n\ta[c]=c+1\n\tfor i in range(1,len(ccl)):\n\t\ta[ccl[i]]=c+1\n\tprint(*a)\nelse:\n\tprint(len(ccl)+len(par)-1)\n\tc=par[0]\n\tfor i in range(1,len(par)):\n\t\ta[par[i]]=c+1\n\tfor i in range(len(ccl)):\n\t\ta[ccl[i]]=c+1\n\tprint(*a)", "# from debug import debug\nimport sys; input = sys.stdin.readline\nn = int(input())\nlis = [0, *list(map(int , input().split()))]\nv = [0]*(n+1)\ncycles = set()\nroots = set()\nfor i in range(1, n+1):\n\tif v[i] == 0:\n\t\tnode = i\n\t\twhile v[node] == 0:\n\t\t\tv[node] = 1\n\t\t\tnode = lis[node]\n\t\tif v[node] == 2: continue\n\t\tstart = node\n\t\tignore = 0\n\t\tl = 1\n\t\twhile lis[node] != start:\n\t\t\tif v[node] == 2: ignore = 1; break\n\t\t\tv[node] = 2\n\t\t\tnode = lis[node]\n\t\t\tl+=1\n\t\tif ignore: continue\n\t\tv[node] = 2\n\t\tif l == 1: roots.add(node)\n\t\telse: cycles.add(node)\nans = 0\nif roots:\n\tbase = roots.pop()\n\tfor i in roots: lis[i] = base; ans+=1\n\tfor i in cycles: lis[i] = base; ans+=1\nelif cycles:\n\tbase = cycles.pop()\n\tcycles.add(base)\n\tfor i in roots: lis[i] = base; ans+=1\n\tfor i in cycles: lis[i] = base; ans+=1\nprint(ans)\nprint(*lis[1:])\n", "from collections import deque\n\n\n# ver si hay un camino que llega a el a partir\n# de su padre entonces hay un ciclo\n\n\ndef Padre(x, padre):\n    while x != padre[x]:\n        x = padre[x]\n    return x\n\n\ndef DFS(x, color, padre, ciclos, adyacentes, raiz):\n    color[x] = 1  # nodo gris\n    for y in adyacentes[x]:\n        # el adyacente es blanco\n        if color[y] == 0:\n            DFS(y, color, padre, ciclos, adyacentes, raiz)\n            padre[y] = x\n\n        elif color[y] == 2:\n            padre[y] = x\n        # ese adyacente es gris entonces <u,v>  rista de retroceso\n        else:\n            if y == x and not raiz:\n                raiz = x\n            else:\n                ciclos.append([x, y])\n    color[x] = 2  # nodo negro\n\n\ndef Solucion():\n    n = int(input())\n    A = list(map(lambda x: int(x)-1, input().split()))\n\n    padre = [x for x in range(0, n)]\n    ciclosC = 0\n    ciclos = deque([])\n    root = []\n\n    # ir haciendo Merge a cada arista\n    for i in range(0, n):\n\n        p = Padre(A[i], padre)\n        # Si dicha arista perticipa en un ciclo\n        if p == i:\n            # Si es un ciclo del tipo raiz y no hay raiz\n            if not root and (i == A[i]):\n                root = [i, A[i]]\n            else:\n                ciclos.append([i, A[i]])\n                ciclosC += 1\n        # Si no hay ciclo\n        else:\n            padre[i] = A[i]\n\n    print(str(ciclosC))\n    # si existe al menos un ciclo diferente d raiz\n    if ciclosC:\n        i = 0\n        # si no hay raiz el primer ciclo lo hago raiz\n        if not root:\n            root = ciclos.popleft()\n            i = 1\n\n        # los restantes ciclos hago que su padre sea la raiz\n        while ciclos:\n            ciclo = ciclos.popleft()\n            padre[ciclo[0]] = root[0]\n\n    PC = [x + 1 for x in padre]\n    print(*PC, sep=\" \")\n\n\nSolucion()\n\n\n# Casos de prueba:\n# 4\n# 2 3 3 4\n# respuesta\n# 1\n#  2 3 3 3\n\n# 5\n# 3 2 2 5 3\n# respuesta\n# 0\n# 3 2 2 5 3\n\n# 8\n# 2 3 5 4 1 6 6 7\n# respuesta\n# 2\n# 2 3 5 4 1 4 6 7\n\n# 200000\n# hacer con el generador\n", "from collections import deque\n\n# Para revisar la correctitud pueden probar el codigo en el codeforce que va a dar accepted\n\n# ver si hay un camino que llega a el a partir\n# de su padre entonces hay un ciclo\n\n\ndef Padre(x, padre):\n    while x != padre[x]:\n        x = padre[x]\n    return x\n\n\ndef FixATree():\n    n = int(input())\n    A = list(map(lambda x: int(x)-1, input().split()))\n\n    padre = [x for x in range(0, n)]\n    ciclosC = 0\n    ciclos = deque([])\n    root = []\n\n    # ir haciendo Merge a cada arista\n    for i in range(0, n):\n\n        p = Padre(A[i], padre)\n        # Si dicha arista perticipa en un ciclo\n        if p == i:\n            # Si es un ciclo del tipo raiz y no hay raiz\n            if not root and (i == A[i]):\n                root = [i, A[i]]\n            else:\n                ciclos.append([i, A[i]])\n                ciclosC += 1\n        # Si no hay ciclo\n        else:\n            padre[i] = A[i]\n\n    print(str(ciclosC))\n    # si existe al menos un ciclo diferente d raiz\n    if ciclosC:\n        i = 0\n        # si no hay raiz el primer ciclo lo hago raiz\n        if not root:\n            root = ciclos.popleft()\n            i = 1\n\n        # los restantes ciclos hago que su padre sea la raiz\n        while ciclos:\n            ciclo = ciclos.popleft()\n            padre[ciclo[0]] = root[0]\n\n    PC = [x + 1 for x in padre]\n    print(*PC, sep=\" \")\n\n\nFixATree()\n\n\n# Casos de prueba:\n# 4\n# 2 3 3 4\n# respuesta\n# 1\n#  2 3 3 3\n\n# 5\n# 3 2 2 5 3\n# respuesta\n# 0\n# 3 2 2 5 3\n\n# 8\n# 2 3 5 4 1 6 6 7\n# respuesta\n# 2\n# 2 3 5 4 1 4 6 7\n\n# El codigo da accepted en el codeforce por lo que los casos de prueba que emplee son los que ahi estan\n"]