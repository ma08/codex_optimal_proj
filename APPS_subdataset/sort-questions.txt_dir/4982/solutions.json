["class Game():\n    \n    def __init__(self, n):\n        k = 2 * n + 1\n        self.board = {frozenset(k * r + 1 + c + d for d in (0, n, n + 1, k))\n                        for r in range(n) for c in range(n)}\n\n    def play(self, lines):\n        lines = set(lines)\n        while 1:\n            for cell in self.board:\n                stick = cell - lines\n                if len(stick) <= 1:\n                    lines |= stick\n                    self.board.remove(cell)\n                    break\n            else: break\n        return sorted(lines)", "class Game():\n    \n    def __init__(self, s):\n        self.s = s\n        self.sq = [ { d+(2*s+1)*y+x for d in [0, s, s+1, 2*s+1] } for x in range(1,s+1) for y in range(s) ]\n        \n    def play(self, lines):\n        lines, prevlen = set(lines), 0\n        while len(lines) != prevlen:\n            keep, prevlen = [], len(lines)\n            for sq in self.sq:\n                if len(sq & lines) >= 3: lines |= sq\n                else: keep.append(sq)\n            self.sq = keep\n        return [n for n in range(1,(2*self.s+2)*self.s+1) if n in lines]", "class Game():\n    \n    def __init__(self, board):\n        self.n = board\n\n    def play(self, given):\n        n, make, given = self.n, [list(range(1, self.n + 1))] ,set(given)\n        for i in range(n - 1) : make.append([k + n + (n + 1) for k in make[-1]])\n        possible, i = [[i, i + n, i + n + 1, i + n + 1 + n] for i in sum(make, [])], 0\n        while i < len(possible):\n            t = [k for k in possible[i] if k not in given]\n            if len(t)==1 : given.add(t[0]) ; i = -1\n            i += 1\n        return sorted(given)", "class Game():\n    def __init__(self, board):\n        self.board = board\n    \n    def play(self, lines):\n        self.lines = set(lines)\n        change = True\n        while change:\n            change = False\n            for row in range(self.board):\n                for col in range(self.board):\n                    offset = row * (2 * self.board + 1)\n                    top = offset + col + 1\n                    left = top + self.board\n                    right = left + 1\n                    bottom = right + self.board\n                    cell = [top, left, right, bottom]\n                    sides = 0\n                    for side in cell:\n                        if side in self.lines:\n                            sides += 1\n                    if sides == 3:\n                        self.lines = self.lines.union(set(cell))\n                        change = True\n        return sorted(list(self.lines))", "class Game():    \n    def __init__(self, n):\n        k = 2 * n + 1\n        self.board = [{k*r + 1 + c, k*(r+1) + 1 + c, k*r + n + 1 + c, k*r + n + 2 + c} for r in range(n) for c in range(n)]\n\n    def play(self, lines):\n        L, last = set(lines), None\n        while self.board != last:\n            last = self.board[:]\n            for k in [s for s in self.board if len(L & s) == 3]: \n                L |= k\n                self.board.remove(k)\n        return sorted(list(L))", "class Game():\n    def ad_line(self,board):\n        work=[[] for _ in range(board**2+1)]\n        line_list=[[] for _ in range(2*board*(board+1)+1)]\n        for i in range(1,board**2+1):\n            numwork=((i-1)//board)*(2*board+1)\n            numwork+=(i-1)%board+1\n            work[i].append(numwork)    #top edge\n            line_list[numwork].append(i)\n            numwork+=board\n            work[i].append(numwork)    #left edge\n            work[i].append(numwork+1)  #right edge\n            line_list[numwork].append(i)\n            line_list[numwork+1].append(i)\n            numwork+=board+1\n            work[i].append(numwork)    #bottom edge\n            line_list[numwork].append(i)\n        return work,line_list\n        \n    \n    def __init__(self, board):\n        self.box=[0]*(board**2+1)\n        work=self.ad_line(board)\n        self.box_line=work[0]\n        self.line_list=work[1]\n\n    def play(self, lines):\n        out=lines[:]\n        work_next=[]\n        for line in lines:\n            for box in self.line_list[line]:\n                self.box[box]+=1\n                if self.box[box]==3 : work_next.append(box)\n        while work_next:\n            box=work_next.pop(0)\n            for line in self.box_line[box]:\n                if line in out : continue\n                out.append(line)\n                for n_box in self.line_list[line]:\n                    self.box[n_box]+=1\n                    if self.box[n_box]==3 : work_next.append(n_box)\n        return sorted(out)", "class Game():\n    \n    def __init__(self, board):\n        self._board = board\n        self._lines = []\n        self._flines = []\n        self._gboard = []\n        self._cboard = []\n        self._sqcheck = [(0,0),(1,-1),(1,1),(2,0)]\n        self._sqctotal = 0\n        self._dot = 0\n        self._score = 0\n        self._inner = \"X\"\n        self._blank = \"_\"\n        \n        self.createcompleteb()\n            \n    def play(self, lines):\n        if (lines == []):\n            return lines\n        self._lines = lines\n        \n        creategameb(self, self._lines)\n        \n        breaker = False\n        lskip = False\n        complete = False\n        while not complete:\n            breaker = False\n            lskip = False\n            for y in range(len(self._gboard)):\n                if (not lskip):\n                    lskip = True\n                    if(y != len(self._gboard) -1):\n                        for x in range(len(self._gboard)):\n                            if(self._gboard[y][x] != self._dot):\n                                for sqc in self._sqcheck:\n                                    if (self._gboard[y + sqc[0]][x + sqc[1]] != self._blank):\n                                        self._sqctotal += 1    \n                                if(self._sqctotal == 3):\n                                    for sqc in self._sqcheck:\n                                        if (self._gboard[y + sqc[0]][x + sqc[1]] == self._blank):\n                                            self._gboard[y + sqc[0]][x + sqc[1]] = self._cboard[y + sqc[0]][x + sqc[1]]\n                                            self._sqctotal = 0\n                                            self._score = 1\n                                            breaker = True\n                                            break\n                                            \n                                elif(self._sqctotal == 4):\n                                    self._sqctotal = 0\n                                    self._score = 1\n                                else:\n                                    self._sqctotal = 0 \n                            else:\n                                pass\n                    else:\n                        complete = True\n                else:\n                    lskip = False\n                \n                if(breaker):\n                    breaker = False\n                    break\n                    \n        for y in range(len(self._gboard)):\n            for x in range(len(self._gboard)):\n                if(isinstance(self._gboard[y][x], int) ):\n                    if(self._gboard[y][x] > 0):\n                        self._flines.append(self._gboard[y][x])\n                        \n        \n        if(self._score):\n            return self._flines\n        else:\n            return self._lines\n\n        \n    def createcompleteb(self):\n        #create a complete board\n        switch = 1 # 0 = number 1 = dot/inner\n        doi = 0 # 0 = dot 1 = inner\n        count = 1\n        tmp = []\n        for y in range(self._board + 1 + self._board):\n            for x in range(self._board + 1 + self._board):\n                if (switch):\n                    if (not doi):\n                        tmp.append(self._dot)\n                        switch = 0\n                    else:\n                        tmp.append(self._inner)\n                        switch = 0\n                else:\n                    tmp.append(count)\n                    count += 1\n                    switch = 1\n            if(doi == 1):\n                doi = 0\n            else:\n                doi = 1\n            self._cboard.append(tmp)\n            tmp = []\n            \n            \n            \ndef creategameb(self, lines):\n        #create a game board using provided \"lines\"\n        switch = 1 # 0 = number 1 = dot/inner\n        doi = 0 # 0 = dot 1 = inner\n        count = 1\n        tmp = []\n        for y in range(self._board + 1 + self._board):\n            for x in range(self._board + 1 + self._board):\n                if (switch):\n                    if (not doi):\n                        tmp.append(self._dot)\n                        switch = 0\n                    else:\n                        tmp.append(self._inner)\n                        switch = 0\n                else:\n                    if (count in lines):\n                        tmp.append(count)\n                        count += 1\n                        switch = 1\n                    else:\n                        tmp.append(self._blank)\n                        count += 1\n                        switch = 1\n                        \n            if(doi == 1):\n                doi = 0\n            else:\n                doi = 1\n            self._gboard.append(tmp)\n            tmp = []\n", "class Game():\n    \n    def __init__(self, board):\n        self.board_list = []\n        for n in range(board): #5 -> 0,1,2,3,4,5\n            if n == 0:\n                for row in range(1,board+1): #row1 -> 1-5\n                    self.board_list.append( [row, row+board, row+board+1, row+board+1+board] )\n            else:\n                for row in range( (board+(board+1))*n+1, (board+(board+1))*n+board+1):\n                    self.board_list.append( [row, row+board, row+board+1, row+board+1+board] )\n        \n    def play(self, lines):\n        lines = set(lines)\n        changes = True\n        while changes == True:\n            changes = False\n            for combination in self.board_list:\n                if len(set(combination) & lines) == 3:\n                    changes = True\n                    lines.add(list(set(combination) - (set(combination)&lines))[0])\n        return sorted(list(lines))", "class Game():\n    \n    def __init__(self, board):\n        self.board = board\n\n    def internal(self, lines):\n        result = set()\n        retval = False\n        pts_per_line = (self.board * 2) + 1\n        for by in range(self.board):\n            for bx in range(self.board):\n                h1 = 1 + (by * pts_per_line) + bx\n                h2 = (h1 + pts_per_line)\n                v1 = (h1 + self.board)\n                v2 = (v1 + 1)\n\n                count = 0\n                if h1 in lines:\n                    count += 1\n                    result.add(h1)\n                if h2 in lines:\n                    count += 1\n                    result.add(h2)\n                if v1 in lines:\n                    count += 1\n                    result.add(v1)\n                if v2 in lines:\n                    count += 1\n                    result.add(v2)\n\n                if count == 3:\n                    retval = True\n                    result.add(h1)\n                    result.add(h2)\n                    result.add(v1)\n                    result.add(v2)\n\n        ret = list(result)\n        ret.sort()\n        return ret, retval\n\n    def play(self, lines):\n        cont = True\n        while cont:\n            ret, cont = self.internal(lines)\n            lines = ret\n        return lines", "class Game():\n    \n    def __init__(self, board):\n        self.board=board\n\n    def play(self, lines):\n        r=set(lines)\n        while(len(r)<2*self.board*(self.board+1)):\n            flag=False\n            for i in range(self.board):\n                for j in range(self.board):\n                    x=(2*self.board+1)*i+j+1\n                    s={x,x+self.board,x+self.board+1,x+2*self.board+1}\n                    if len(r&s)==3:\n                        r|=s\n                        flag=True\n                        break\n                if flag:\n                    break\n            if not flag:\n                break\n        return sorted(r)"]