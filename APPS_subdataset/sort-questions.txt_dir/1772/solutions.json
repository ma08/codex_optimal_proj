["from itertools import cycle\n\nclass VigenereCipher (object):\n    def __init__(self, key, alphabet):\n        self.key = key.decode('utf-8')\n        self.alphabet = alphabet.decode('utf-8')\n    \n    def cipher(self, mode, str):\n        return ''.join(self.alphabet[(self.alphabet.index(m) +\n                  mode * self.alphabet.index(k)) % len(self.alphabet)]\n                  if m in self.alphabet else m for m, k in zip(str.decode('utf-8'),\n                  cycle(self.key))).encode('utf-8')\n    \n    def encode(self, str): return self.cipher(1, str)\n    def decode(self, str): return self.cipher(-1, str)\n    \n", "class VigenereCipher (object):\n    def __init__(self, key, alphabet):\n        self.key = key.decode('utf-8')\n        self.alphabet = alphabet.decode('utf-8')\n        self.maps = {c:(self.alphabet[i:]+self.alphabet[:i]) for i, c in enumerate(self.alphabet) if c in self.key}   \n\n    def code(self, f, s):\n        return ''.join([f(self.maps[self.key[i % len(self.key)]], c) for i, c in enumerate(s.decode('utf-8'))]).encode('utf-8')\n            \n    def encode(self, s):    \n        return self.code(lambda l, c: l[self.alphabet.index(c)] if c in self.alphabet else c, s)\n        \n    def decode(self, s):\n        return self.code(lambda l, c: self.alphabet[l.index(c)] if c in self.alphabet else c, s)        ", "from itertools import cycle, islice\nfrom unicodedata import normalize\n\ndef chunks(lst, chunk_size):\n    return [lst[i:i+chunk_size] for i in range(0, len(lst), chunk_size)] if chunk_size != 1 else lst\n    \n\nclass VigenereCipher (object):\n    def __init__(self, key, alphabet):\n        self.charsize = len(key) / len(key.decode('utf-8'))\n        seq = chunks(list(islice(cycle(key), len(alphabet))), self.charsize)\n        seq = [''.join(s) for s in seq]\n        self.ab = chunks(alphabet, self.charsize)\n        self.key = [self.ab.index(x) for x in seq]\n        \n    def caesar(self, c, shift):        \n        try:\n            return self.ab[(self.ab.index(c) + shift) % len(self.ab)]\n        except ValueError:\n            return c   \n        \n    def encode(self, str):\n        seq = [self.caesar(c, self.key[index]) for index, c in enumerate(chunks(str, self.charsize))]  \n        return ''.join(seq)\n            \n    def decode(self, str):\n        seq = [self.caesar(c, -self.key[index]) for index, c in enumerate(chunks(str, self.charsize))]  \n        return ''.join(seq)\n        \n", "class VigenereCipher(object):\n    def __init__(self, key: str, alphabet: str):\n        self.alphabet = list(alphabet)\n        self.key = [alphabet.index(i) for i in key]\n\n    def encode(self, text):\n        return \"\".join([self.alphabet[(self.alphabet.index(text[i]) + self.key[i % len(self.key)]) % len(self.alphabet)]\n                        if text[i] in self.alphabet else text[i] for i in range(len(text))])\n\n    def decode(self, text):\n        return \"\".join([self.alphabet[(self.alphabet.index(text[i]) - self.key[i % len(self.key)]) % len(self.alphabet)]\n                        if text[i] in self.alphabet else text[i] for i in range(len(text))])\n", "class VigenereCipher(object):\n\n    def __init__(self, key, alphabet):\n        self.key = key * 10\n        self.alphabet = alphabet * 2\n        \n    \n    def encode(self, text):\n        encrypted = \"\"\n        a = 0\n        for i in text:\n            if i in self.alphabet:\n                encrypted += self.alphabet[self.alphabet.index(i) + self.alphabet.index(self.key[a])]\n                a += 1\n            else:\n                encrypted += i\n                a += 1\n        return encrypted\n        \n              \n    def decode(self, text):\n        decrypted = \"\"\n        a = 0\n        for i in text:\n            if i in self.alphabet:\n                decrypted += self.alphabet[self.alphabet.index(i) - self.alphabet.index(self.key[a])]\n                a += 1\n            else:\n                decrypted += i\n                a += 1\n        return decrypted", "class VigenereCipher(object):\n    cipherMap = {}\n    invCipherMap = {}\n    alphabet = ''\n    lenAlphabet = -1\n    key = ''\n    lenKey = -1\n\n    def __init__(self, key, alphabet):\n        self.key = key\n        self.lenKey = len(self.key)\n        self.alphabet = alphabet\n        self.lenAlphabet = len(self.alphabet)\n        self.cipherMap = dict(list(enumerate(self.alphabet)))    #slick way learned @ stackExchange :)    \n        self.invCipherMap = {val: key for key, val in list(self.cipherMap.items())}   #invert the cipher map\n    #-----end constructor\n\n\n\n    #helper function to perform the cipher. Note, if a char (in the provided text) is not\n    # in the provided alphabet, we are to leave it be; otherwise, based on the alphabet \n    # and the key, we are to encode the character using the Vigenere Cipher    \n    def __performVigenereCipher__(self, text, performEncode):\n        lenText = len(text)\n        encodedText = ''\n\n        for i in range(lenText):\n            curChar = text[i]\n            keyChar = self.key[i%self.lenKey]\n\n            if curChar in self.alphabet:        #Scenario: Perform Vigenere Cipher\n                charVal = self.invCipherMap[curChar]\n                keyVal  = self.invCipherMap[keyChar]\n\n                if performEncode:\n                    valEncoded = (charVal + keyVal)%self.lenAlphabet\n                else:\n                    valEncoded = (charVal - keyVal)%self.lenAlphabet\n\n                encodedChar = self.cipherMap[valEncoded] \n            else:   #Scienario: The char is not in the alphabet; leave it be\n                encodedChar = curChar\n            \n            encodedText += encodedChar\n        #---end for loop\n\n        return encodedText\n    #-----end function\n\n    def encode(self, text):\n        performEncode = True\n        encodedText = self.__performVigenereCipher__(text, performEncode)        \n        return encodedText\n    #-----end function encode    \n    \n    def decode(self, text):\n        performEncode = False\n        decodedText = self.__performVigenereCipher__(text, performEncode)\n        return decodedText \n    #-----end function decode\n\n#-----end class\n", "class VigenereCipher(object):\n    def __init__(self, key, alphabet):\n        self.alphabet = alphabet\n        self.key = key\n    \n    def encode(self, text):\n        mx = []\n        for i in range(len(text)):\n            try:\n                shift = self.alphabet.index(self.key[i%(len(self.key))]) \n                start = self.alphabet.index(text[i])\n                mx.append(self.alphabet[(start+shift)%len(self.alphabet)])\n            except:\n                mx.append(text[i])\n        return ''.join(mx)\n            \n    \n    def decode(self, text):\n        mx = []\n        for i in range(len(text)):\n            try:\n                shift = self.alphabet.index(self.key[i%(len(self.key))]) \n                start = self.alphabet.index(text[i])\n                mx.append(self.alphabet[(start-shift)%len(self.alphabet)])\n            except:\n                mx.append(text[i])\n        return ''.join(mx)\n        \n", "from itertools import cycle\n#cycle => cycle(abc) = abcabcabc\n\nclass VigenereCipher(object):\n    def __init__(self, key:str, alphabet:str)->None:\n        self.key = key\n        self.alphabet = alphabet\n\n    def cipher(self, m:int, s:str)->str:\n        r = ''\n        for i, j in zip(s,cycle(self.key)):\n            if i in self.alphabet:\n                r += self.alphabet[(self.alphabet.index(i) + m * self.alphabet.index(j)) % len(self.alphabet)]\n            else:\n                r += i\n        return r\n\n    def encode(self, s:str)->str:\n        return self.cipher(1, s)\n\n    def decode(self, s:str)->str:\n        return self.cipher(-1, s)", "from itertools import cycle\n\nclass VigenereCipher:\n    def __init__(self, key, alphabet):\n        self.key = key\n        self.alphabet = alphabet\n    \n    def encode(self, text):\n        return \"\".join(self.caesar(ch, key_ch, 1) if ch in self.alphabet else ch for ch, key_ch in zip(text, cycle(self.key)))\n\n    def decode(self, text):\n        return \"\".join(self.caesar(ch, key_ch, -1) if ch in self.alphabet else ch for ch, key_ch in zip(text, cycle(self.key)))\n\n    def caesar(self, char, key_char, mode=1):\n        char_position, move = self.alphabet.find(char), self.alphabet.find(key_char)\n        return self.alphabet[(char_position + mode * move) % len(self.alphabet)] # Probably should store len(alphabet) instead of recalculating.", "class VigenereCipher(object):\n    def __init__(self, key, alphabet):\n        self.alphabet=alphabet\n        self.key=key\n    \n    def encode(self, text):\n        cl\u00e9=self.key\n        while(len(cl\u00e9)<len(text)):\n            cl\u00e9+=cl\u00e9\n            cl\u00e9=cl\u00e9[:len(text)]\n        chiffre=''    \n        for i,(v,w) in enumerate(zip(text,cl\u00e9)):\n            if v in self.alphabet:\n                chiffre+=self.alphabet[(self.alphabet.index(v)+self.alphabet.index(w))%len(self.alphabet)]\n            else:\n                chiffre+=v\n        return chiffre        \n                \n        \n    \n    def decode(self, text):\n        cl\u00e9=self.key\n        while(len(cl\u00e9)<len(text)):\n            cl\u00e9+=cl\u00e9\n            cl\u00e9=cl\u00e9[:len(text)]\n        dechiffre=''    \n        \n        for i,(v,w) in enumerate(zip(text,cl\u00e9)):\n            if v in self.alphabet:\n                dechiffre+=self.alphabet[(self.alphabet.index(v)-self.alphabet.index(w))%len(self.alphabet)]\n            else:\n                dechiffre+=v\n                \n        return dechiffre        \n"]