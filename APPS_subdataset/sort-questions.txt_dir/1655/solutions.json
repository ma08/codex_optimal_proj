["from itertools import combinations\n\ndef count_col_triang(a):\n    p, r = {}, {}\n    for xy, col in a:\n        p[col] = p.get(col, []) + [xy]\n    for k in p:\n        r[k] = sum(1 for c in combinations(p[k], 3) if triangle(*c))\n    mx = max(r.values())\n    return [len(a), len(p), sum(r.values()), sorted(k for k in r if r[k] == mx) + [mx] if mx else []]\n    \ndef triangle(a, b, c):  \n    return area(*[((p[0] - q[0])**2 + (p[1] - q[1])**2)**0.5 for p, q in [(a, b), (a, c), (b, c)]]) > 0.0\n\ndef area(a, b, c):\n    s = 0.5 * (a + b + c)\n    return round(max((s*((s-a)*(s-b)*(s-c))), 0.0)**0.5, 4)", "from itertools import combinations\n\ndef grad(a, b):\n    \"\"\"Builds a gradient description\"\"\"\n    rise, tread = b[1] - a[1], b[0] - a[0]\n    if rise == 0 or tread == 0:\n        if rise == tread:\n            return \"p\" # Single point\n        elif rise == 0:\n            return \"y\" # Y Axis constant\n            # return \"y={}\".format(a[0])\n        return \"x\" # X Axis constant\n    else:\n        # Warning: Float used in comparison later, could be a problem\n        # but not likely given integer inputs\n        return rise / tread\n\ndef collinear(a, b, c):\n    \"\"\"Determines if three points are colinear\"\"\"\n    return grad(a, b) == grad(b, c)\n\ndef count_col_triang(input_):\n    # Group the inputs based on colour, to unique points within each colour\n    colors = set(map(lambda t: t[1], input_))\n    points = {col: set() for col in colors}\n    for coord, color in input_:\n        points[color].add(tuple(coord))\n    \n    # Discard any colours with less than 3 unique points\n    # Geometry fact: Need at least 3 points to form a triangle!\n    points = {k: list(sorted(v)) for k, v in points.items() if len(v) > 2}\n    \n    total = 0\n    counts = {}\n    for color, point_list in points.items():\n        count = 0\n        # Generate all possible trios of potential triangle vertices\n        for a, b, c in combinations(point_list, 3):\n            # Make sure the points are not collinear  \n            if not collinear(a, b, c):\n                # Yay! we found a triangle\n                count += 1\n        counts[color] = count\n        total += count\n    \n    # Identify colours with greatest number of triangles\n    most_count = max(counts.values())\n    most = [c for c, n in counts.items() if n == most_count]\n    most = [] if most_count == 0 else (list(sorted(most)) + [most_count])\n    \n    # Collate stats and return\n    return [len(input_), len(colors), total, most]", "\n# determinant for this particular case\ndef det( m ):\n    return ( m[0][0] * ( m[1][1] - m[2][1] )\n           + m[1][0] * ( m[2][1] - m[0][1] )\n           + m[2][0] * ( m[0][1] - m[1][1] ) )\n\ndef count_col_triang(input_):\n    # init variables\n    colored = []\n    colors = {}\n    n_tri = []\n    ncol = 0\n    \n    # separate points by colors\n    for point, color in input_:\n        if color not in colors:\n            colors[color] = ncol\n            colored.append( [] )\n            n_tri.append( 0 )\n            ncol += 1\n        colored[colors[color]].append( point )\n    \n    # for each 3 points: calculate deteminant to determine if they form a triangle\n    for color, cpts in enumerate( colored ):\n\n        if len( cpts ) < 3:\n            continue\n        for k in range( len(cpts) ):\n            for l in range( k + 1 ):\n                for m in range( l + 1 ):\n                    if det( [ cpts[k], cpts[l], cpts[m] ] )  != 0:\n                        n_tri[color] += 1\n    \n    # find maximum number of triangles\n    tmax = max( n_tri )\n    \n    # find corresponding colors\n    clrmax = []\n    if tmax > 0:\n        for color in sorted( colors ):\n            if n_tri[ colors[ color ] ] == tmax:\n                clrmax.append( color )\n        clrmax.append( tmax )\n\n    return [ len( input_ ), ncol, sum( n_tri ), clrmax ]", "from collections import defaultdict\nfrom itertools import combinations\n\n\ndef count_col_triang(points_colors):\n    point_count = len(points_colors)\n\n    colors = set(color for points, color in points_colors)\n    color_count = len(colors)\n\n    color_points = defaultdict(lambda: False)\n\n    for c in colors:\n        color_points[c] = [points\n                           for points, color in points_colors if color == c]\n\n    # get all with 3 or more points, kasi 3 points min sa triangle\n    color_points = defaultdict(lambda: False, ((color, points)\n                                               for color, points in color_points.items() if len(points) >= 3))\n\n    triangle_count = 0\n    color_triangle_count = defaultdict(lambda: False)\n\n    for color, points in color_points.items():\n        comb_points = combinations(points, 3)\n        color_triangle_count[color] = 0\n        x, y = 0, 1\n\n        # get the side lengths and compute area\n        for vertices in comb_points:\n            va, vb, vc = vertices\n            # get sides using distance between 2 points formula\n            a = (((vb[x] - va[x])**2) + (vb[y] - va[y])**2)**0.5\n            b = (((vc[x] - vb[x])**2) + (vc[y] - vb[y])**2)**0.5\n            c = (((va[x] - vc[x])**2) + (va[y] - vc[y])**2)**0.5\n            s = (a + b + c) / 2  # semi-perimeter\n            area = (s*(s-a)*(s-b)*(s-c))**0.5\n\n            # any 3 points with an area is a triangle\n            if area != 0:\n                triangle_count += 1\n                color_triangle_count[color] += 1\n\n    max_count = max(color_triangle_count.values())\n\n    # get all colors with highest triangle count, append sa dulo count for format\n    colors_max_count = sorted([color for color, count in color_triangle_count.items()\n                               if count == max_count])\n    colors_max_count.append(max_count)\n\n    if max_count <= 0:\n        colors_max_count = []\n\n    return [point_count, color_count, triangle_count, colors_max_count]", "from itertools import combinations as combos\n\ndef count_col_triang(in_):\n    cl = list(set([i[1] for i in in_])) # cl is the full color-list\n    \n    d = {} # dictionary of color keys and triangle-count values\n    for c in cl: # i[0] + [1] is a row of the test matrix: [xi, yi, 1]\n        triples = combos([i[0] + [1] for i in in_ if i[1] == c], 3)\n        test_matrices = list(map(list, triples))\n        d[c] = len([i for i in test_matrices if determinant(i)])\n        \n    mc = max(d, key=d.get) # maximally-triangled color\n    maxcl = sorted([c for c in cl if d[c] and d[c] == d[mc]])\n    sumtri = sum([d[i] for i in d])\n    return [len(in_), len(cl), sumtri, maxcl + [d[mc]] if sumtri else []]\n\ndef determinant(m):\n    a, b, c, d, e, f, g, h, i = tuple(m[0] + m[1] + m[2])\n    return a*(e*i-f*h) - b*(d*i-f*g) + c*(d*h - e*g)", "import numpy as np\nfrom itertools import combinations\n\ndef ctri(lst):\n    if len(lst)<3:\n        return 0\n    return sum(1 for j in combinations(lst, 3) if abs(np.linalg.det(np.mat([i+[1] for i in j])))>1e-3)\n\ndef count_col_triang(ipt):\n    d = {}    \n    for i in ipt:\n        if i[1] not in d:\n            d[i[1]] = [i[0]]\n        else:\n            d[i[1]].append(i[0])\n\n    p = {i:ctri(d[i]) for i in d}\n    pmax = max(p.values())\n    \n    plst = [] if pmax == 0 else sorted([i for i in p if p[i]==pmax]) + [pmax]\n    return [len(ipt), len(p), sum(p.values()), plst]", "from itertools   import combinations\nfrom collections import defaultdict\n\ndef crossProd(v1, v2):   return v1[0]*v2[1] - v2[0]*v1[1]\ndef vectorize(pt1, pt2): return [b-a for a,b in zip(pt1, pt2)]\ndef notOnSameLine(*pts): return bool( crossProd(vectorize(*pts[:2]), vectorize(*pts[1:])) )\n\ndef count_col_triang(input_):\n    dctPts = defaultdict(list)\n    for pos,color in input_: dctPts[color].append(pos)\n    \n    dctTriangles = { color: sum(notOnSameLine(*threePts) for threePts in combinations(lst, 3)) for color,lst in dctPts.items() }\n    maxTriangles = max(dctTriangles.values())\n    \n    return [len(input_),\n            len(dctPts),\n            sum(dctTriangles.values()),\n            sorted(color for color,n in dctTriangles.items() if n == maxTriangles) + [maxTriangles] if maxTriangles else [] ]", "from itertools import combinations, groupby, starmap\n\nis_triangle = lambda a,b,c: (b[0]-a[0])*(c[1]-a[1]) - (c[0]-a[0])*(b[1]-a[1]) != 0\nis_triangle = lambda a,b,c: a[0]*(b[1]-c[1]) + b[0]*(c[1]-a[1]) + c[0]*(a[1]-b[1]) != 0\n#is_triangle = lambda a,b,c: __import__('numpy').linalg.det([(x,y,1) for x,y in (a,b,c)]) != 0 ## Precision issues\n\ndef count_col_triang(input_):\n    grouped = groupby(sorted(input_, key=lambda p:p[1]), key=lambda p:p[1])\n    colored_triangles = {k: sum(starmap(is_triangle, combinations((p for p, _ in g), 3))) for k, g in grouped}\n    max_colored = max(colored_triangles.values())\n    return [len(input_), len(colored_triangles), sum(colored_triangles.values()),\n            sorted(c for c, n in colored_triangles.items() if n == max_colored) + [max_colored] if max_colored else []]"]