["class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n<=1: \n            return 0\n        l,r = n,-1\n        \n        for i in range(1,n):\n            if arr[i]<arr[i-1]:\n                l = i\n                break\n        # monotonicially increasing\n        if l == n: return 0\n        \n        for j in range(n-2,-1,-1):\n            if arr[j]>arr[j+1]:\n                r = j\n                break\n                \n        # you can delete all to the left of r (including r)\n        # you can also delete all to the right of l (including l)\n        ans = min(r+1,n-l)\n        \n        i = 0\n        # sliding window, find the rightmost i for each j\n        # note at all time i must be less than l\n        for j in range(r+1,n):\n            while i<l and arr[i] <= arr[j]:\n                i += 1\n            ans = min(ans,j-i)\n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        s = 0\n        e = n - 1\n        \n        while  s < (n - 1) and arr[s] <= arr[s + 1]:\n            s+=1\n        if(s == n - 1):\n            return 0\n        \n        while e >= s and arr[e] >= arr[e - 1]:\n            e-=1\n        \n        result = min(n - 1 - s, e)\n        \n        i = 0\n        j = e\n        while(i <= s and j < n):\n            if arr[j] >= arr[i]:\n                result = min(result, j - i - 1)\n                i+=1\n            else:\n                j+=1\n        \n        return result\n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        stack = [0]\n        stack2 = []\n        total = 0\n        for i in range(1,len(arr)):\n            if arr[i]>=arr[i-1]:\n                stack.append(0)\n            else:\n                total+=1\n                stack2.append(i)\n                stack.append(1)\n        if total==0:\n            return 0\n        print(stack2)\n        #erase small\n        def erase(i,j):\n            print((i,j))\n            if (i>0 and j<len(arr)-1) and arr[i-1]>arr[j+1]:\n                return min(erase(i-1,j),erase(i,j+1))\n            \n            else:        \n                return j-i+1\n\n        if total==1:\n            return erase(stack2[0],stack2[0])\n        \n        return erase(stack2[0],stack2[-1]-1)\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        templ = []\n        tempr = []\n        flag = 0\n        for i in range(len(arr)-1):\n            if(arr[i]>arr[i+1]):\n                flag = 1\n        if(flag == 0):\n            return(0)\n        for i in range(1,len(arr)):\n            if(arr[i]>=arr[i-1]):\n                templ.append(arr[i-1])\n            else:\n                templ.append(arr[i-1])\n                break\n        for i in range(len(arr)-1,0,-1):\n            if(arr[i]<arr[i-1]):\n                tempr.append(arr[i])\n                break\n            else:\n                tempr.append(arr[i])\n        print((templ,tempr))\n        if(len(templ)==len(tempr)):\n            if(len(templ) == len(arr) or len(templ) ==0):\n                return(len(templ))\n        print((templ,tempr))\n        from bisect import bisect_right\n        mmax  = max(len(templ),len(tempr))\n        for i in range(len(tempr)):\n            ind = bisect_right(templ,tempr[i])\n            print((i,ind))\n            mmax = max(mmax,ind+i+1)\n        return(max(0,len(arr) - (mmax)))\n        \n    \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if len(arr) < 2:\n            return 0\n        for i1 in range(len(arr)-1):\n            if arr[i1+1] >= arr[i1]:\n                continue\n            else:\n                break\n        #arr[0] - arr[i1] is increasing and arr[i1+1] < arr[i1]\n        #if overall sorted\n        if arr[-2] <= arr[-1] and i1 == len(arr)-2:\n            return 0\n        for i2 in range(len(arr)-1,0,-1):\n            if arr[i2]>= arr[i2-1]:\n                continue\n            else:\n                break\n        #arr[i2] - arr[len(arr)-1] is increasing and arr[i2-1] < arr[i2]\n        print(i1,i2)\n        remove = i2-1-(i1+1)+1\n        ans = min(remove+i1+1,remove+len(arr)-i2)\n        #binary search to find positions of num in first part in the second part\n        for i in range(i1,-1,-1):\n            num = arr[i]\n            l,r = i2,len(arr)\n            while l < r:\n                mid = (l+r)//2\n                if arr[mid] >= num:\n                    r = mid\n                else:\n                    l = mid+1\n            # if found\n            if l < len(arr):\n                cur = remove + i1-i + l- i2\n                ans = min(cur,ans)\n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        stack = [[len(arr)-1, arr[-1]]]\n        \n        for i in range(len(arr)-2, -1, -1):\n            if arr[i] <= arr[i+1]:\n                stack.append([i, arr[i]])\n            else:\n                break\n        \n        min_len = len(arr)-len(stack)\n        \n        for i in range(len(arr)):\n            if i == 0 or arr[i] >= arr[i-1]:\n                while len(stack) > 0 and (stack[-1][1] < arr[i] or stack[-1][0] <= i):\n                    stack.pop()\n\n                if len(stack) > 0:\n                    min_len = min(min_len, stack[-1][0]-i-1)\n                else:\n                    min_len = min(min_len, len(arr)-i-1)\n            else:\n                break\n        \n        return min_len", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n=len(arr)\n        answer=n-1\n        \n        A=arr\n        if len(arr)==1:\n            return 0\n        flag=False\n        for i in range(1,n):\n            if A[i]<A[i-1]:\n                flag=True\n                j=n-1\n                while(j>i and A[j]>=A[i-1]) and (j==n-1 or A[j]<=A[j+1]):\n                    j=j-1\n                answer=min(answer,j-i+1) \n                break\n        if flag==False:\n            return 0\n       \n        for i in range(n-2,-1,-1):\n            if A[i]>A[i+1]:\n                j=0\n                while(j<i and A[j]<=A[i+1]) and (j==0 or A[j]>=A[j-1]):\n                    j=j+1\n                answer=min(answer,i-j+1)\n                break\n        return answer      \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if len(arr) < 2:\n            return 0\n        for i1 in range(len(arr)-1):\n            if arr[i1+1] >= arr[i1]:\n                continue\n            else:\n                break\n        #arr[0] - arr[i1] is increasing and arr[i1+1] < arr[i1]\n        #if overall sorted\n        if arr[-2] <= arr[-1] and i1 == len(arr)-2:\n            return 0\n        for i2 in range(len(arr)-1,0,-1):\n            if arr[i2]>= arr[i2-1]:\n                continue\n            else:\n                break\n        #arr[i2] - arr[len(arr)-1] is increasing and arr[i2-1] < arr[i2]\n        # print(i1,i2)\n        remove = i2-1-(i1+1)+1\n        ans = min(remove+i1+1,remove+len(arr)-i2)\n        #binary search to find positions of num in first part in the second part\n        for i in range(i1,-1,-1):\n            num = arr[i]\n            l,r = i2,len(arr)\n            while l < r:\n                mid = (l+r)//2\n                if arr[mid] >= num:\n                    r = mid\n                else:\n                    l = mid+1\n            # if found\n            if l < len(arr):\n                cur = remove + i1-i + l- i2\n                ans = min(cur,ans)\n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l = 0\n        n = len(arr)\n        while l<n-1 and arr[l]<=arr[l+1]:\n            l+=1\n        \n        # print(l)\n        if l == n-1:return 0\n        # if l == 0: return len(arr)-1\n        r = len(arr)-1\n        while r>0 and arr[r]>=arr[r-1]:\n            r-=1\n        \n        left = n-(l+1)\n        right = r\n        # print(r)\n        ans = min(left,right)\n\n        i=0\n        j=r\n\n\n        while i<=l and j<n:\n\n            if arr[j]>=arr[i]:\n                ans =min(ans,j-i-1)\n                i+=1\n            else:\n\n                j+=1\n\n        return ans\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l,r = 0,len(arr) - 1\n        while l < r and arr[l + 1] >= arr[l]:\n            l += 1\n        if l == len(arr) - 1:\n            return 0\n        \n        while r > 0 and arr[r - 1] <= arr[r]:\n            r -= 1\n        toRemove = min(len(arr) - l - 1,r)\n        \n        for iL in range(l + 1):\n            if arr[iL] <= arr[r]:\n                toRemove = min(toRemove,r - iL - 1)\n            elif r < len(arr) - 1:\n                r += 1\n            else:\n                break\n        return toRemove", "from sortedcontainers import SortedDict\n\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if len(arr) <= 1: return 0\n        \n        last = -float('inf')\n        \n        sl = SortedDict()\n        \n        for i, n in enumerate(arr):\n            if n < last: break\n            \n            sl[n] = i\n            \n            last = n\n                    \n        ans = len(arr) - i\n        last = float('inf')\n        \n        \n        for i in range(len(arr)-1, 0, -1):\n            if arr[i] > last: break\n            \n            last = arr[i]\n            \n            sl_idx = sl.bisect_right(arr[i])\n                                    \n            ans = min(ans, i - sl_idx)\n        \n        return max(0, ans)", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        # check best from left\n        # check best from right\n        left, right = 0, len(arr) - 1\n        while left < len(arr) - 1 and arr[left] <= arr[left + 1]:\n            left += 1\n        if left == len(arr) - 1:\n             return 0\n        while right > 0 and arr[right - 1] <= arr[right]:\n            right -= 1\n        best = min(len(arr) - 1 - left, right) # only prefix or suffix parts\n        \n        # merging prefix and suffix\n        # first checking all elements smaller than left to see which ones can be used before the right index draw a line going from (0,0) -> (3,2) and a line going form (7, 1) -> (10, 3) and notice which arrays you can make by drawing horizontal lines on y = 1 and y = 2. \n        # Essentially we start from the beginning and we see which ones from the left can exist if right is where it was before. If we get to a left that is greater than right, we increment right by 1 to see if the next left < the next right. We keep on repeating this process until we cant (when the current left is greater than the current right and the current right is the last element). At that point, we just return the smallest we have seen until that time.\n        for i in range(left + 1):\n            if arr[i] <= arr[right]:\n                best = min(best, right - i - 1)\n            elif right < len(arr) - 1:\n                right += 1\n            else:\n                break\n        # The following method fails for [1,2,3,10,0,7,8,9]\n        # for i in range(left + 1):\n        #     if arr[i] <= arr[right]:\n        #         best = min(best, right - i - 1)\n        # for i in range(len(arr) - 1, right - 1, -1):\n        #     print(arr[left], arr[i])\n        #     if arr[left] <= arr[i]:\n        #         best = min(best, i - left - 1)\n        return best\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        k = 0\n        while k+1 < len(arr) and arr[k+1] >= arr[k]:\n            k += 1\n        if k == len(arr) - 1:\n            return 0\n        l = len(arr) - 1\n        while l > 0 and arr[l - 1] <= arr[l]:\n            l -= 1\n        ans = max(k + 1, len(arr) - l)\n        for i in range(k + 1):\n            while l < len(arr) and arr[i] > arr[l]:\n                l += 1\n            ans = max(ans, i + 1 + len(arr) - l)\n        return len(arr) - ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l = len(arr)\n        if l == 1:\n            return 0\n        \n        longest = 0\n        \n        # three possibilities:\n        # 1. head + tail, 2. head, 3. tail\n            \n        \n        # head\n        benchmark = 'a'\n        \n        for i in range(1, l):\n            if arr[i-1] > arr[i]:\n                head_longest = i\n                benchmark = arr[i-1]\n                break\n        \n        if benchmark == 'a':\n            return 0\n        \n        i = l - 2\n        if arr[i+1] >= benchmark:\n            head_longest += 1\n        while arr[i] <= arr[i+1] and arr[i] >= benchmark:\n            head_longest += 1\n            i -= 1\n        \n        \n        # tail\n        for i in range(l-2, -1, -1):\n            if arr[i] > arr[i+1]:\n                tail_longest = l - i - 1\n                benchmark = arr[i+1]\n                break\n        \n        i = 1\n        if arr[i-1] <= benchmark:\n            tail_longest += 1\n            \n        \n        while arr[i-1] <= arr[i] and arr[i] <= benchmark:\n            tail_longest += 1\n            i += 1\n            \n        longest = max(head_longest, tail_longest)\n        \n        return l - longest", "from bisect import bisect_left as bl ,bisect_right as br,bisect as bis,insort_left as il,insort_right as ir ,insort as isrt\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \n        maxarr=[1]\n        n=len(arr)\n        flag=0\n        \n        for i in range(1,n):\n            if (arr[i]>=arr[i-1]):\n                maxarr.append(maxarr[-1]+1)\n            else:\n                flag=1\n                maxarr.append(1)\n        if flag ==0:\n            return 0\n        arr1=[arr[0]]\n        arr2=[arr[-1]]\n        \n        i=1\n        while i<len(arr) and maxarr[i]>maxarr[i-1]:\n            arr1.append(arr[i])\n            i+=1\n        \n        i=len(arr)-2\n        while i >=0 and maxarr[i]<maxarr[i+1]:\n            arr2.append(arr[i])\n            i-=1\n        \n        \n        print((arr1, arr2[::-1]))\n        arr2= arr2[::-1]\n        size = len(arr2)\n        maxm = len(arr1)\n        for i in arr2:\n            index = br(arr1 , i)\n            maxm = max(index +size ,maxm)\n            size-=1\n     \n            \n            \n                    \n        \n        \n        return len(arr)-maxm\n            \n      \n        \n            \n                \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        # Find the longest monotonically non-decreasing prefix array in [0, i]\n        n = len(arr)\n        l = 1\n        while l < n and arr[l-1] <= arr[l]:\n            l += 1\n        l -= 1  \n        if l >= n - 2:\n            return n - 1 - l\n                \n        # Find the longest monotonically non-decreasing suffix array in [j, n - 1]\n        r = n - 2\n        while r >= 0 and arr[r] <= arr[r+1]:\n            r -= 1\n        r += 1\n        if r <= 1:\n            return r\n    \n        # Start off with min of either left or right side removed as the min_to_move\n        min_to_remove = min(n - 1, n - 1 - (l + 1) + 1, r)\n        # Try to merge [0..i] from the left into [r..n-1]. We start with assuming\n        # entire right side [r..n-1] could be included and try to see if [0], [0, 1] and so on\n        # from the left side could be merged in. Until we hit some i on the left side that is \n        # too large for the current arr[r], retreat r back further to the right to try\n        # against a bigger value. Keep trying until we run out of either room for i to expand\n        # toward the right or for no more r left to retreat to the right.\n        i = 0\n        while i < l + 1:\n            if arr[i] <= arr[r]:\n                min_to_remove = min(min_to_remove, r - i - 1)\n                # we could definitely include arr[i] into the result\n                i += 1\n            elif r < n - 1:\n                # We cannot include arr[r] into the result but we could\n                # include arr[i] into the result\n                r += 1\n                i += 1\n            else:\n                break\n        \n        return min_to_remove\n\n        \n    def findLengthOfShortestSubarray_bruteforce_bsearch(self, arr: List[int]) -> int:\n        # Returns the smallest index `idx` such that arr[idx] >= val\n        def bsearch(val, low, high):\n            while low < high:\n                mid = (low + high) // 2\n                if arr[mid] >= val:\n                    high = mid\n                else:\n                    low = mid + 1\n            if val > arr[high]:\n                return high + 1\n            return high\n        \n        # Find the longest monotonically non-decreasing prefix array in [0, i]\n        n = len(arr)\n        curr_max = float('-inf')\n        i = 0\n        while i < n:\n            if arr[i] < curr_max:\n                break\n            curr_max = arr[i]\n            i += 1\n        i -= 1  \n        if i >= n - 2:\n            return n - 1 - i\n                \n        # Find the longest monotonically non-decreasing suffix array in [j, n - 1]\n        curr_min = float('inf')\n        j = n - 1\n        while j >= 0:\n            if arr[j] > curr_min:\n                break\n            curr_min = arr[j]\n            j -= 1\n        j += 1\n        if j <= 1:\n            return j\n        \n        # For each value arr[k], in [0, i], find the `right_idx` into the suffix array in [j, n - 1]\n        # such that arr[k] >= arr[right_idx]. We want to find the one that results in the longest\n        # sequence [0..k] + [right_idx..n-1]\n        min_to_remove = float('inf')\n        for k in range(i, -1, -1):\n            right_idx = bsearch(arr[k], j, n - 1)\n            l = k + 1 + n - right_idx\n            to_remove = n - l\n            min_to_remove = min(min_to_remove, to_remove)\n            \n        # For each value arr[k], in [j, n-1], find the `left_idx` into the prefix array in [0, i]\n        # such that arr[k] >= arr[left_idx - 1]. We want to find the one that results in the longest\n        # sequence [0..left_idx-1] + [k..n-1]\n        for k in range(j, n):\n            left_idx = bsearch(arr[k], 0, i)\n            l = left_idx + n - k\n            to_remove = n - l\n            min_to_remove = min(min_to_remove, to_remove)\n        \n        return min_to_remove\n        \n        \n\n        \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        left, right = 0, n-1\n        while left < n-1 and arr[left] <= arr[left+1]:\n            #non-decreasing, keep increment\n            left+=1\n        while right>0 and arr[right] >= arr[right-1]:\n            right-=1\n        num_to_remove = min(n-left-1, right)\n        \n        #general case:\n        #from the left\n        for curr in range(left+1):\n            if arr[curr]<=arr[right]:\n                num_to_remove = min(num_to_remove, max(0, right-curr-1))\n            else:\n                # arr[curr]>arr[right]\n                if right < n-1:\n                    right += 1\n                else:\n                    #last element\n                    break\n        return num_to_remove\n        \n", "class Solution:\n\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n\n        # determine right sorted subarray\n        r = len(arr) - 1 \n        while r >0 and arr[r] >= arr[r-1]:\n            r -= 1\n           \n        # determine left sorted subarray that can be merged with right\n        ret = r # set ret to worst case, remove all left \n        l = 0\n        for l in range(len(arr)):\n            # if left subarry is not in order anymore, stop, can't do better\n            if l>0 and arr[l] < arr[l-1]:\n                break\n            # if l==r\n            if l == r:\n                return 0\n                \n            while r < len(arr) and arr[l] > arr[r] :\n                r +=1\n            \n\n            ret = min(ret, r-l-1)\n                \n            \n            \n        return ret\n            \n\n        \n\n        \n\n        \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        left, right = 1, 1\n        \n        \n        i = 1\n        while i < n and arr[i] >= arr[i - 1]:\n            left += 1\n            i += 1\n        \n        \n        i = n - 2\n        while i >= 0 and arr[i] <= arr[i + 1]:\n            right += 1\n            i -= 1\n        \n        \n        l1, l2 = right, left\n        \n        i = n - right\n        while i < n and arr[i] < arr[left - 1]:\n            i += 1\n            l1 -= 1\n            \n            \n        i = left - 1\n        while i >= 0 and arr[i] > arr[n - right]:\n            i -= 1\n            l2 -= 1\n            \n        return max(min(n - left - l1, n - right - l2), 0)", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l = []\n        for x in arr:\n            if not l or x >= l[-1]:\n                l.append(x)\n            else:\n                break\n        r = []\n        for i in range(len(arr)-1, -1, -1):\n            if not r or arr[i] <= r[-1]:\n                r.append(arr[i])\n            else:\n                break\n        r.reverse()\n        if len(l) == len(arr):\n            return 0\n        sol = max(len(l), len(r))\n        i, j = 0, 0\n        # print(l, r)\n        while i < len(l) and j < len(r):\n            if l[i] <= r[j]:\n                i += 1\n            else:\n                while j < len(r) and l[i] > r[j]:\n                    j += 1\n            # print(i, j)\n            sol = max(sol, i+len(r)-j)\n        return len(arr) - sol", "class Solution:\n    '''\n    1,2,3,10,4,2,3,5]\n    1 2 2  3 3 4 5 10\n    '''\n    def findLengthOfShortestSubarray(self, A: List[int]) -> int:\n        N = len(A)\n        left, right = 0, N - 1\n        while left + 1 < N and A[left] <= A[left + 1]:\n            left += 1\n        if left == N - 1:\n            return 0\n        while right > left and A[right - 1] <= A[right]:\n            right -= 1\n        ans = min(N - left - 1, right)\n        i, j = 0, right\n        while i <= left and j < N:\n            if A[j] >= A[i]:\n                ans = min(ans, j - i - 1)\n                i += 1\n            else:\n                j += 1\n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        if(n==1):\n            return 0\n        l = 0 \n        r = n - 1\n        while(r > 0):\n            if(arr[r-1] > arr[r]):\n                break\n            r = r - 1\n        ans = r - l\n        while(l < r):\n            if(l > 0 and arr[l-1] > arr[l]):\n                break\n            while(r < n and arr[r] < arr[l]):\n                r = r + 1\n            ans = min(ans, r - l - 1)\n            l = l + 1\n        return ans\n", "import bisect\n\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        a = 0\n        for i in range(len(arr)):\n            if i == 0 or arr[i] >= arr[i - 1]:\n                a += 1\n            else:\n                break\n        \n        b = 0\n        for i in reversed(list(range(len(arr)))):\n            if i == len(arr) -1 or arr[i] <= arr[i + 1]:\n                b += 1\n            else:\n                break\n        \n        if a == len(arr):\n            return 0\n        \n        al = arr[: a]\n        bl = arr[len(arr) - b: ]\n        \n        ans = len(arr) - 1\n        \n        for i in range(a):\n            target = al[i]\n            index = bisect.bisect_left(bl, target)\n            if index == len(bl):\n                ans = min(ans, len(arr) - i - 1)\n            else:\n                ans = min(ans, len(arr) - (i + 1) - (len(bl) - index))\n        \n        ans = min(ans, len(arr) - len(bl))\n        \n        return ans\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        arr = [-1e99]+arr+[1e99]\n        \n        \n        left_p  = 0\n        while left_p + 1 < len(arr) and arr[left_p] <= arr[left_p+1] :\n            left_p += 1\n        \n        right_p = len(arr)-1\n        while right_p-1 >= 0 and arr[right_p] >= arr[right_p-1] :\n            right_p -= 1\n        right_p_old = right_p\n        if left_p > right_p :\n            return 0\n        \n        while arr[right_p] < arr[left_p] :\n            right_p += 1\n        to_ret = right_p - left_p - 1\n        \n        while right_p >= right_p_old and left_p > 0 :\n            left_p -= 1\n            while right_p-1 >= right_p_old and arr[right_p-1] >= arr[left_p] :\n                right_p -= 1\n            to_ret = min(to_ret, right_p - left_p - 1 )\n        \n        return to_ret\n        \n        \n        # 10 2 99 12 13\n", "class Solution:\n    # O(n)\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n\n        # determine right sorted subarray\n        r = len(arr) - 1 \n        while r >0 and arr[r] >= arr[r-1]:\n            r -= 1\n        \n        # r == 0 means array is sorted\n        if r == 0:\n            return 0\n        \n        # now determine left sorted subarray that can be merged with right\n        ret = r # set ret to worst case, remove all left \n        l = 0\n        for l in range(len(arr)):\n            # if left subarry is not in order anymore, stop, can't do better\n            if l>0 and arr[l] < arr[l-1]:\n                break\n            \n            # if arr[l] is larger than the left edge of right sorted subarray, \n            # push the edge to the right\n            # why this work? Is it OK to push to the right? We won't consider\n            # arr[i+1] and arr[r].\n            # It's OK! We don't have to consider arr[i+1] and arr[r].\n            # if arr[i] is larger than the left edge, arr[i+1] is larger too!\n            # so it won't be the possible answer\n            # it's possible that you push it to the end of right subarray\n            # for example [9,10,11,5], keep pushing r to 4\n            # in this case, right subarray is empty [].\n            while r < len(arr) and arr[l] > arr[r] : \n                r +=1 \n\n            ret = min(ret, r-l-1)\n\n        return ret\n            \n\n        \n\n        \n\n        \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        N = len(arr)\n        \n        lo, hi = 0, N - 1\n        while lo + 1 < N and arr[lo] <= arr[lo + 1]:\n            lo += 1\n        if lo >= N - 1:\n            return 0\n        \n        while hi - 1 >= 0 and arr[hi - 1] <= arr[hi]:\n            hi -= 1\n            \n        # [0..lo]    [hi..N-1]\n        res = min(N - lo - 1, hi)\n        j = hi\n        for i in range(lo + 1):\n            while j < N and arr[j] < arr[i]:\n                j += 1\n            res = min(res, j - i - 1)\n        return res", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l = res =  0\n        r = n = len(arr)\n        increasing = [0] * n \n        \n        for i in range(1, n):\n            if arr[i] >= arr[i-1]:\n                increasing[i] = 1 + increasing[i-1]\n        # print(arr) \n        # print(increasing)\n        while l < r:\n            mid = (l+r) // 2\n            # print(mid)\n            for i in range(n - mid + 1):\n                isLeftInc = False\n                isRightInc = False\n                if i > 0 and increasing[i-1] == i-1 or i == 0:\n                    isLeftInc = True\n\n                if (i < n-mid and increasing[n-1] >= n - i - mid - 1 and arr[i+mid] >= (0 if i < 1 else arr[i-1])) or i == n-mid :\n                    isRightInc = True\n                # print(i, isLeftInc, isRightInc, i + mid, i-1)       \n\n                if isLeftInc and isRightInc:\n                    break\n                    \n            if isLeftInc and isRightInc:\n                res = mid\n                r = mid\n            else:\n                l = mid+1\n                    \n        return res", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        i=0\n        while i<len(arr)-1 and arr[i]<=arr[i+1]:\n            i+=1\n        if i==len(arr):return 0\n        j=len(arr)-1\n        \n        while j and arr[j-1]<=arr[j]:\n            j-=1\n        if j==-1:return 0\n                \n        def lowerbound(left, right, target):\n            while left < right:\n                mid = left + (right - left) // 2\n                \n                if arr[mid] == target:\n                    right = mid\n                elif arr[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n                \n            return left            \n        N=len(arr)\n        print((i,j))\n        out=min(N - (N - j), N - i -1)\n        print(out)\n        for k in range(i+1):\n            hi=lowerbound(j,len(arr),arr[k])\n            out=min(out,hi-k-1)\n        \n        return max(0,out)\n            \n        \n        \n        \n        \n        \n            \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        p = 1\n        while p < len(arr) and arr[p] >= arr[p - 1]:\n            p += 1\n        first = p\n        p = len(arr) - 1\n        while p >= 1 and arr[p] >= arr[p - 1]:\n            p -= 1\n        second = p\n        ans = min(len(arr) - first, second)\n        i, j = 0, second\n        # print(i, j)\n        while i < first and j < len(arr):\n            if arr[i] > arr[j]:\n                ans = min(ans, j - i)\n                j += 1\n            else:\n                i += 1\n        ans = min(ans, j - i)\n        return ans if ans > 0 else 0", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if len(arr) <= 1:\n            return 0\n        \n        p1 = 0\n        p2 = len(arr) - 1\n        \n        for i in range(1,len(arr)):\n            if arr[i] >= arr[i-1]:\n                p1 += 1\n            else:\n                break\n        \n        for i in range(len(arr)-2, -1, -1):\n            if arr[i] <= arr[i+1]:\n                p2 = i\n            else:\n                break\n        ans = min(len(arr) - p1 - 1 , p2)\n        if p1 > p2:\n             return ans\n        p11, p22 = 0, p2\n        \n        while p11 <= p1 and p22 < len(arr):\n            if arr[p11] <= arr[p22]:\n                ans = min(ans, p22 - p11 - 1)\n                p11 += 1\n            else:\n                p22 += 1\n        return ans", "from functools import lru_cache\n\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        '''\n        1 2 3 10 4 2 3 5\n            i\n                     j\n                       \n        1  2 3\n          ij\n        '''\n        N = len(arr)\n        i = 0\n        while i < N-1 and arr[i+1] >= arr[i]:\n            i += 1\n        left = N - i - 1\n        \n        j = N-1\n        while j > 0 and arr[j-1] <= arr[j]:\n            j -= 1\n        right = j\n        \n        ret = N-1\n        \n        @lru_cache(maxsize=None)\n        def search(i, j):\n            print(i, j)\n            nonlocal ret\n            if i == j: return 0\n\n            if arr[j] >= arr[i]:\n                ret = min(ret, j-i-1)\n            \n            I = i\n            while i < N-1 and arr[i+1] >= arr[i] and arr[i+1] <= arr[j]:\n                i += 1\n            if i > I:\n                search(i, j)\n            \n            i = I\n            J = j\n            while j > 0 and arr[j-1] <= arr[j] and arr[j-1] >= arr[i]:\n                j -= 1\n            if j < J:\n                search(i, j)\n                    \n        search(0, N-1)\n        \n        return min(left, ret, right)", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        lastPos = len(arr)-1\n        stop = False\n        idx = len(arr)-2\n        while idx > -1 and not stop:\n            num = arr[idx]\n            prev = arr[lastPos]\n            if num <= prev:\n                lastPos = idx\n            else:\n                stop = True\n            idx -= 1\n        rightSub = lastPos\n        \n        minSub = rightSub\n        idx = 0\n        stop = False\n        valid = False\n        while idx < rightSub and not stop:\n            valid = False\n            if idx == 0 or arr[idx] >= arr[idx-1]:\n                num = arr[idx]\n                while rightSub < len(arr) and not valid:\n                    numRight = arr[rightSub]\n                    if numRight < num:\n                        rightSub += 1\n                    else:\n                        valid = True\n                minSub = min(minSub, (rightSub - idx - 1))        \n                idx += 1\n            else:\n                stop = True\n            \n        idx -= 1\n        minSub = min(minSub, (rightSub - idx - 1))\n        return minSub\n        \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        ans = float('inf')\n        max_s, min_e = 0, n-1\n        curr = -1\n        for i, a in enumerate(arr):\n            if a < curr: break\n            curr = a\n            max_s = i\n        \n        curr = float('inf')\n        for i in range(n-1, -1, -1):\n            if arr[i] > curr: break\n            curr = arr[i]\n            min_e = i\n        # n - 1 - (max_s + 1) + 1 = n - 1 - max_ s\n        # min_e - 1 - 0 + 1 = min_e\n        ans = min(n - max_s - 1, min_e)\n        \n        for s in range(max_s+1):\n            index, jump = n-1, n - 1 - min_e\n            while jump >= 1:\n                while index-jump >= min_e and arr[index-jump] >= arr[s]:\n                    index -= jump\n                jump //= 2\n            if arr[index] >= arr[s]:\n                ans = min(ans, index-1 - (s + 1) + 1)\n        return max(ans, 0)\n            \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if arr == sorted(arr):\n            return 0\n        for head in range(len(arr) - 1):\n            if arr[head] > arr[head + 1]:\n                break\n        if head == len(arr):\n            return 0 # already sorted\n        for tail in range(len(arr) - 1, 0, -1):\n            if arr[tail - 1] > arr[tail]:\n                break\n        lo = head + 1\n        hi = len(arr)\n        output = float('inf')\n        while lo >= 0:\n            while hi - 1 >= tail and (lo == 0 or arr[lo - 1] <= arr[hi - 1]):\n                hi -= 1\n            output = min(output, hi - lo)\n            lo -= 1\n        return output", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        ans = float('inf')\n        max_s, min_e = 0, n-1\n        curr = -1\n        for i, a in enumerate(arr):\n            if a < curr: break\n            curr = a\n            max_s = i\n        \n        curr = float('inf')\n        for i in range(n-1, -1, -1):\n            if arr[i] > curr: break\n            curr = arr[i]\n            min_e = i\n        # n - 1 - (max_s + 1) + 1 = n - 1 - max_ s\n        # min_e - 1 - 0 + 1 = min_e\n        ans = min(n - max_s - 1, min_e)\n        \n        for s in range(max_s+1):\n            index, jump = n-1, n-1\n            while jump >= 1:\n                while index-jump >= min_e and arr[index-jump] >= arr[s]:\n                    index -= jump\n                jump //= 2\n            if index > s and arr[index] >= arr[s]:\n                ans = min(ans, index-1 - (s + 1) + 1)\n        return ans\n            \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        def bsearch(val, low, high):\n            while low < high:\n                mid = (low + high) // 2\n                if arr[mid] >= val:\n                    high = mid\n                else:\n                    low = mid + 1\n            if val > arr[high]:\n                return high + 1\n            return high\n        \n        n = len(arr)\n        curr_max = float('-inf')\n        i = 0\n        while i < n:\n            if arr[i] < curr_max:\n                break\n            curr_max = arr[i]\n            i += 1\n        i -= 1  \n        if i >= n - 2:\n            return n - 1 - i\n                \n        curr_min = float('inf')\n        j = n - 1\n        while j >= 0:\n            if arr[j] > curr_min:\n                break\n            curr_min = arr[j]\n            j -= 1\n        j += 1\n        if j <= 1:\n            return j\n        \n        min_to_remove = float('inf')\n        for k in range(i, -1, -1):\n            right_idx = bsearch(arr[k], j, n - 1)\n            l = k + 1 + n - right_idx\n            to_remove = n - l\n            min_to_remove = min(min_to_remove, to_remove)\n        for k in range(j, n):\n            left_idx = bsearch(arr[k], 0, i)\n            l = left_idx + n - k\n            to_remove = n - l\n            min_to_remove = min(min_to_remove, to_remove)\n        \n        return min_to_remove\n        \n        \n\n        \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if arr == None or len(arr) <= 1:\n            return 0\n        left ,right = 0, len(arr) - 1\n        while left +1 < len(arr) and arr[left] <= arr[left+1] : left += 1\n        if left == len(arr)-1: return 0\n        while right > 0 and arr[right-1] <= arr[right] : right -= 1\n        result = min(len(arr)-left-1, right)\n        if arr[left] <= arr[right]:\n            result = min(result, right-left-1)\n        for i in range(left+1):\n            if arr[i] <= arr[right] : result = min(result, right-i-1)\n            elif right < len(arr)-1 : right += 1\n        return result", "class Solution:\n    def canBeMadeSortedByDeletingKElements(self, arr: List[int], k: int) -> bool:\n        # k   : 0 1 2 3 4 5 . . . \n        # f(k): 0 0 0 0 1 1 1 1 1 1 1 1\n        n = len(arr)\n        \n        i = 1\n        while i < n and arr[i - 1] <= arr[i]:\n            i += 1\n            \n        j = 1\n        while j < n and arr[n - j - 1] <= arr[n - j]:\n            j += 1\n        \n        if i == n: # and j == n\n            return True\n            \n        # i         > k         j\n        # -----  # # # # # ------\n        # 3 4 5 1 1 2 3 4\n        # k = 2\n            \n        if i + j + k < n:\n            return False\n        \n        # k = 3\n        # 0 1 2 3 4 5 6\n        \n        # k = 3\n        #        0 1 2 3 4 5\n        # i = 0: - - -\n        # i = 1:   - - - \n        \n        for start in range(0, n - k + 1):\n            left = start\n            right = n - left - k\n            if left <= i and right <= j and (left == 0 or right == 0 or arr[left - 1] <= arr[n - right]):\n                return True\n        \n        return False\n    \n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        L = 0\n        R = len(arr) - 1\n        answer = -1\n        \n        while L <= R:\n            M = (L + R) // 2\n            if self.canBeMadeSortedByDeletingKElements(arr, M):\n                answer = M\n                R = M - 1\n            else:\n                L = M + 1\n        \n        return answer\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l = 0\n        r = len(arr)-1\n        while l < len(arr)-1 and arr[l+1] >= arr[l]:\n            l +=1\n        if l == len(arr)-1:\n            return 0\n        while r > 0 and arr[r-1] <= arr[r]:\n            r -=1\n        \n        res = min(len(arr)-l-1, r)\n        \n        for i in range(l+1):\n            if arr[i] <= arr[r]:\n                res = min(res, r-i-1)\n            elif r < len(arr)-1:\n                r +=1\n            else:\n                break\n                \n        return res\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if all([arr[i+1] >= arr[i] for i in range(len(arr)-1)]):\n            return 0\n        start = 0\n        for i in range(1, len(arr)):\n            if arr[i] >= arr[i-1]:\n                start = i\n            else:\n                break\n        end = len(arr) - 1\n        for i in range(len(arr)-1)[::-1]:\n            if arr[i] <= arr[i+1]:\n                end = i\n            else:\n                break\n        lo = -1\n        res = min(len(arr) - start - 1, end)\n        for i in range(end, len(arr)):\n            while lo < start and arr[lo+1] <= arr[i]:\n                lo += 1\n            res = min(res, i - lo - 1)\n        return res", "import bisect\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        s={}\n        a=[(arr[0],0)]\n        s[0]=(0,0)\n        n=len(arr)\n        for i in range(1,n):\n            if s[i-1][1]==0:\n                move=1\n            else:\n                move=s[i-1][0]+1\n            index=bisect.bisect_right(a,(arr[i],i))\n            if index==0:\n                nmove=i\n            else:\n                nmove=i-a[index-1][1]-1\n            if arr[i-1]<=arr[i]:\n                nmove=min(nmove,s[i-1][1])\n            if nmove==0:\n                bisect.insort_right(a,(arr[i],i))\n            s[i]=(move,nmove)\n            #print(s)\n        return min(s[n-1][0],s[n-1][1])\n            \n            \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        left = 0\n        while left < len(arr) - 1:\n            if arr[left] <= arr[left + 1]:\n                left += 1\n            else:\n                break\n        if left >= len(arr) - 1:\n            return 0\n        right = len(arr) - 1\n        while right > 0:\n            if arr[right] >= arr[right - 1]:\n                right -= 1\n            else:\n                break\n        ll = 0\n        rr = right\n        res = min(len(arr) - left - 1, right)\n        while ll < left + 1 and rr < len(arr):\n            if arr[ll] <= arr[rr]:\n                res = min(res, rr - ll - 1)\n                ll += 1\n            else:\n                rr += 1\n        return res\n                \n            \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n\n        left = [False] * n # all to left are  increasing\n        right = [False] * n # all to right are  increasing\n        \n        left[0] = True\n        right[n-1] = True\n        for i in range(1, n):\n            left[i] = left[i - 1] and (arr[i] >= arr[i-1])\n            \n        for i in range(n-2, -1, -1):\n            right[i] = right[i + 1] and (arr[i] <= arr[i + 1])\n            \n            \n        \n        def isPossible(num):\n            res = False\n            for i in range(n):\n                if i == 0 or left[i - 1]:\n                    if i + num >= n or (right[i + num] and (i == 0 or arr[i - 1] <= arr[i + num])):\n                        res = True\n                        break                    \n            return res\n            \n        be = 0\n        en = n - 1\n        \n        while be < en:\n            mid = be + (en - be) // 2\n            if isPossible(mid):\n                en = mid\n            else:\n                be = mid + 1\n        \n        return be\n    \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        right=[]\n        left=[]\n        if not arr:\n            return 0\n        pre=arr[-1]+1\n        while arr and arr[-1]<=pre:\n            pre=arr[-1]\n            right.append(arr.pop())\n        pre=-1\n        while arr and arr[0]>=pre:\n            pre=arr[0]\n            left.append(arr.pop(0))\n        l=[i for i in left]\n        r=[i for i in right]\n        val=0\n        while l and r and l[-1]>r[-1]:\n            l.pop()\n            val+=1\n        out=val\n        val=0\n        while right and left and right[-1]<left[-1]:\n            right.pop()\n            val+=1\n        out=min(out,val)\n        return out+len(arr)", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l, r = 0, len(arr) - 1\n        while l < r and arr[l+1] >= arr[l]:\n            l += 1\n        if l == len(arr) - 1:\n            return 0 # whole array is sorted\n        while r > 0 and arr[r-1] <= arr[r]:\n            r -= 1\n            \n        toRemove = min(len(arr) - l - 1, r)\n        for iL in range(l+1):\n            if arr[iL] <= arr[r]:\n                toRemove = min(toRemove, r - iL - 1)\n            elif r < len(arr) - 1:\n                r += 1\n            else:\n                break\n        \n        return toRemove", "class Solution:\n    def findLengthOfShortestSubarray(self, nums: List[int]) -> int:\n        # equal to max increasing subarray \n        seqs = [0]\n        last = nums[0]\n        \n        for i, num in enumerate(nums[1:]):\n            if num < last:\n                seqs.append(i+1)\n            last = num\n        if len(seqs) == 1:\n            return 0\n        \n        no_first_size = seqs[-1]\n        has_first_size = len(nums) - seqs[1]\n        for first_end in range(0, seqs[1]):\n            first_size = len(nums)\n            for i in range(seqs[-1], len(nums)):\n                if nums[i] >= nums[first_end]:\n                    first_size = i - first_end - 1\n                    break\n            has_first_size = min(has_first_size, first_size)\n            if first_size == len(nums):\n                break\n        return min(no_first_size, has_first_size)\n                \n", "class Solution(object):\n    def findLengthOfShortestSubarray(self, arr):\n        stack = [[len(arr)-1, arr[-1]]]\n        \n        for i in range(len(arr)-2, -1, -1):\n            if arr[i] <= arr[i+1]:\n                stack.append([i, arr[i]])\n            else:\n                break\n        \n        min_len = len(arr)-len(stack)\n        \n        for i in range(len(arr)):\n            if i == 0 or arr[i] >= arr[i-1]:\n                while len(stack) > 0 and (stack[-1][1] < arr[i] or stack[-1][0] <= i):\n                    stack.pop()\n\n                if len(stack) > 0:\n                    min_len = min(min_len, stack[-1][0]-i-1)\n                else:\n                    min_len = min(min_len, len(arr)-i-1)\n            else:\n                break\n        \n        return min_len", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        \n        before = n\n        after = 0\n        for i in range(1, n):\n            if arr[i] < arr[i - 1]:\n                before = i - 1\n                break\n        if before == n:\n            return 0\n        for i in range(n - 1)[::-1]:\n            if arr[i] > arr[i + 1]:\n                after = i + 1\n                break\n        l, r = 0, n\n        while l < r:\n            m = l + (r - l) // 2\n            ok = before >= n - 1 - m or after <= m\n\n            for start in range(1, n):\n                if start + m >= n:\n                    break\n                else:\n                    left = before >= start - 1\n                    right = after <= start + m\n                    ok |= left and right and arr[start - 1] <= arr[start + m]\n            if ok:\n                r = m\n            else:\n                l = m + 1\n        return l ", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n == 1: return 0\n        last = n - 1\n        while last > 0 and arr[last - 1] <= arr[last]: last -= 1\n        ans = last\n        \n        for i in range(n):\n            if i > 0 and arr[i] < arr[i - 1]: break\n            while last < n and (last <= i or arr[last] < arr[i]): last += 1\n            ans = min(ans, last - i - 1)\n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, A: List[int]) -> int:\n        N = len(A)\n        if N == 1: return 0\n        \n        # Find left_end and right start\n        left_end, right_start = 0, N - 1\n        for i in range(1, N):\n            if A[i] >= A[i-1]:\n                left_end = i\n            else:\n                break\n        \n        for i in range(N-2, -1, -1):\n            if A[i] <= A[i+1]:\n                right_start = i\n            else:\n                break\n                \n        # Increasing array, no need to do anything\n        print((left_end, right_start))\n        if left_end > right_start: return 0\n        ret = min(N - left_end - 1, right_start)\n        \n        # Two pointer\n        j = right_start\n        for i in range(left_end + 1):\n            if j < N and A[i] <= A[j]:\n                ret = min(ret, j - i - 1)\n            else:\n                while j < N and A[j] < A[i]:\n                    j += 1\n                ret = min(ret, j - i - 1)\n        \n        return ret\n", "from bisect import bisect_right\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        for i in range(len(arr)-1):\n            if arr[i+1]<arr[i]:\n                u = i\n                break\n        else:\n            return 0\n        \n        for j in range(len(arr)-1,-1, -1):\n            if arr[j]<arr[j-1]:\n                v = j\n                break\n        \n        arr1 = arr[:u+1]\n        arr2 = arr[v:]\n        print(arr1, arr2)\n        ans = len(arr)\n        for i in range(len(arr2)):\n            ans = min(ans, len(arr) - (bisect_right(arr1, arr2[i]) + 1 + len(arr2)-i-1))\n        return min(ans, len(arr)-len(arr1), len(arr)-len(arr2))", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        def helper(i, j):\n            if i < 0 or j >= len(arr):\n                return 0\n            if arr[i] > arr[j]:\n                return min(helper(i-1, j), helper(i, j+1)) + 1\n            return 0\n        intervals = []\n        start = 0\n        end = 1\n        while end < len(arr):\n            if arr[end] >= arr[end-1]:\n                end += 1\n            else:\n                intervals.append((start, end))\n                start = end\n                end = start + 1\n                \n        if start != len(arr):\n            intervals.append((start, end))\n        \n        if len(intervals) < 2:\n            return 0\n        result = intervals[-1][0] - intervals[0][1]\n        return result + helper(intervals[0][1]-1, intervals[-1][0])", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if arr == list(sorted(arr)):\n            return 0\n        increasing_parts = []\n        curr = []\n        for num in arr:\n            if not curr or curr[-1] <= num:\n                curr.append(num)\n            else:\n                increasing_parts.append(curr)\n                curr = [num]\n        increasing_parts.append(curr)\n        first = set(increasing_parts[0])\n        second = set(increasing_parts[-1])\n        first_pos = {}\n        sec_pos = {}\n        last_start = sum([len(x) for x in increasing_parts[:-1]])\n        \n        for i, num in enumerate(increasing_parts[0]):\n            first_pos[num] = i\n        \n        for i, num in enumerate(increasing_parts[-1]):\n            sec_pos[num] = i + last_start\n        \n        best = 0\n        seq = list(sorted(increasing_parts[0] + increasing_parts[-1]))\n        for i, num in enumerate(seq):\n            if num in first:\n                if i < len(seq) - 1 and seq[i + 1] in second:\n                    best = max(first_pos[num] + 1 + len(arr) - sec_pos[seq[i + 1]], best)\n        return min([len(arr) - len(increasing_parts[0]), len(arr) - len(increasing_parts[-1]), len(arr) - best])", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        L1=[arr[0]]\n        L2=[]\n\n        for i in range(1,len(arr)):\n            if arr[i]>=arr[i-1]:\n                L1.append(arr[i])\n            else:\n                break\n        temp=[arr[-1]]\n        for i in range(len(arr)-2,-1,-1):\n            if arr[i]<=arr[i+1]:\n                temp.append(arr[i])\n            else:\n                break\n        L2=temp[-1::-1]\n        \n        margin=len(arr)-(len(L1)+len(L2))\n        m=min(len(L1),len(L2))\n\n        MIN=m+margin\n        LENGTH1=len(L1)-1\n        LENGTH2=len(L2)-1\n        # print(L1,L2)\n        \n\n        i=len(L1)-1\n        j=len(L2)-1\n\n        while i>=0 and j>=0:\n            if L1[i]<=L2[j]:\n                j-=1\n\n                a=LENGTH1-i\n                b=j+1\n                # print(i,j,a+b)\n                MIN=min(MIN,margin+a+b)\n\n            else:\n                i-=1\n                if j!=LENGTH2:\n                    j+=1\n                # print(i,j)\n        # print()\n        i=0\n        j=0\n        while i<len(L1) and j<len(L2):\n            if L1[i]<=L2[j]:\n                i+=1\n                a=LENGTH1-i+1\n                b=j\n                # print(i,j,a+b)\n                MIN=min(MIN,margin+a+b)\n\n            else:\n                j+=1\n                if i!=0:\n                    i-=1\n                # print(i,j)\n        \n        \n        if MIN<0:\n            MIN=0\n        return MIN", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        left = [float('inf') for _ in range(len(arr))]\n        right = [-float('inf') for _ in range(len(arr))]\n        \n        last = -float('inf')\n        for i,x in enumerate(arr):\n            if x >= last:\n                left[i] = x\n            else:\n                break\n            last = x\n        last = float('inf')\n        _n = len(arr) - 1\n        right_k = 0\n        for i,x in enumerate(reversed(arr)):\n            if x <= last:\n                right[_n-i] = x\n            else:\n                right_k = i\n                break\n            last = x\n            \n        ans = float('inf')\n        import bisect\n        for i,x in enumerate(left):\n            if x < float('inf'):\n                j = bisect.bisect_left(right, x, i+1)\n                ans = min(ans, j-i-1)\n            else:\n                break\n        ans = min(ans, len(arr)-right_k)\n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        a = [float('-inf')] + arr + [float('inf')]\n        n = len(a)\n        nondecrleft = [0] * n\n        nondecrleft[0] = 1\n        for  i in range(1, n):\n            if a[i] < a[i-1]:\n                break\n            nondecrleft[i] = 1    \n        \n        \n        nondecrright = [0] * n\n        nondecrright[n-1] = 1\n        for i in range(n-2, -1, -1):\n            if a[i] > a[i+1]:\n                break\n            nondecrright[i] = 1    \n                \n                \n        def f(l):\n            # true if removing l elements can make arr sorted\n            for i in range(1, n - l):\n                if nondecrleft[i-1] and nondecrright[i+l] and a[i-1] <= a[i+l]:\n                    return True\n            return False    \n        lo, hi = 0, n-2  \n        while lo!= hi:\n            p = (lo + hi) // 2\n            if not f(p):\n                lo = p + 1\n            else:\n                hi = p\n        return lo    \n", "from collections import deque\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n=len(arr)\n        arr.append(-1)\n        decrease=[]\n        for i in range(n-1):\n            if arr[i]>arr[i+1]:\n                decrease.append(i)\n        if len(decrease)==0:\n            return 0\n        start=decrease[0]+1\n        end=decrease[-1]\n        def valid(start,end):\n            if arr[start-1]<=arr[end+1]:\n                return True\n            return False\n        res=n-1\n        for i in range(start,-1,-1):\n            lo,hi=end,n-1\n            while lo<=hi:\n                mid=(lo+hi)//2\n                if valid(i,mid): #hi+1 is valid\n                    hi=mid-1\n                else:#lo-1 is not valid\n                    lo=mid+1\n            lo=min(lo,n-1)\n            # print(start,lo,i,lo-i+1)\n            res=min(res,lo-i+1)\n        return res\n            \n                    \n            \n            \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if not arr: return 0\n        arr = [-10000000] + arr\n        i = 0\n        for j in range(i+1, len(arr)):\n            if arr[j] >= arr[i]:\n                i += 1\n            else:\n                break\n        \n        firsti = i\n        \n        j = len(arr)-1\n        for i in range(j-1, -1, -1):\n            if arr[j] >= arr[i]:\n                j -=1\n            else:\n                break\n        lastj = j\n        \n        n = len(arr)\n        res = n-1\n        for i1 in range(firsti+1):\n            while lastj < n and arr[lastj] < arr[i1]: lastj += 1\n            print((i1, lastj))\n            res = min(res, lastj - i1 - 1)\n        \n        return max(res, 0)\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        l, r = 0, n-1\n        # left\n        for i in range(1, n):\n            if arr[i] >= arr[i-1]:\n                l += 1\n            else:   break\n        \n        # if l == n-1:    return 0\n        # right\n        for i in reversed(list(range(1, n))):\n            if arr[i] >= arr[i-1]:\n                r -= 1\n            else:   break\n        \n        # left find right\n        res = min(n-l, r)\n        for i in reversed(list(range(1, l+1))):\n            j = self.bsearch(arr, arr[i], r, n-1)\n            if arr[j] < arr[i]:\n                res = min(res, j-i)\n            else:\n                res = min(res, j-i-1)\n            \n        # right find left\n        # [1,2,3,10,4,2,3,5]\n        for i in range(r, n):\n            j = self.bsearch(arr, arr[i], 0, l)\n            if arr[j] > arr[i]:\n                res = min(res, i-j)\n            else:\n                res = min(res, i-j-1)\n                \n        return max(0, res)\n    \n    def bsearch(self, A, target, s, e):\n        while s < e:\n            m = s + (e-s)//2\n            if A[m] < target:\n                s = m+1\n            else:\n                e = m\n        return e\n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        pointer1=-1\n        n=len(arr)\n        pointer2=n-1\n        for i in range(n-2,0,-1):\n            if  arr[i]>arr[i+1]:\n                break\n            pointer2=i\n        res=pointer2-pointer1-1\n        for pointer1 in range(n):\n            if pointer1>0 and arr[pointer1]<arr[pointer1-1]:\n                break\n            while(pointer2<n and (pointer2<=pointer1 or arr[pointer2]<arr[pointer1])):\n                pointer2+=1\n            res=min(res,pointer2-pointer1-1)\n        return res\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \n        leftIncreasing, rightDecreasing = 1, 1\n        \n        for left, right in zip(arr, arr[1:]):\n            if left <= right: leftIncreasing += 1\n            else: break\n        \n        for right, left in zip(arr[::-1], arr[::-1][1:]):            \n            if left <= right: rightDecreasing += 1\n            else: break\n        \n        if max(leftIncreasing, rightDecreasing) == len(arr):\n            return 0\n        \n        else:\n            left_candidate, right_candidate = 0, len(arr) - rightDecreasing\n            max_crop_length = max(leftIncreasing, rightDecreasing)\n            \n            if max_crop_length == leftIncreasing: crop_start, crop_end = leftIncreasing, len(arr) - 1\n            else: crop_start, crop_end = 0, len(arr) - rightDecreasing - 1\n            \n            while left_candidate < leftIncreasing and right_candidate < len(arr):\n                # print(left_candidate, leftIncreasing, right_candidate, rightDecreasing, crop_start, crop_end)\n                if arr[left_candidate] > arr[right_candidate]:\n                    while right_candidate < len(arr):\n                        if arr[left_candidate] > arr[right_candidate]:\n                            right_candidate += 1\n                        else:\n                            break\n                    if right_candidate == len(arr):\n                        return len(arr[crop_start: crop_end + 1])\n                    else:\n                        if max_crop_length < (left_candidate + 1) + (len(arr) - right_candidate):\n                            crop_start, crop_end = left_candidate + 1, right_candidate - 1\n                            max_crop_length = (left_candidate + 1) + (len(arr) - right_candidate)\n                else:\n                    if max_crop_length < (left_candidate + 1) + (len(arr) - right_candidate):\n                        crop_start, crop_end = left_candidate + 1, right_candidate - 1\n                        max_crop_length = (left_candidate + 1) + (len(arr) - right_candidate)\n                    left_candidate += 1\n                    \n            return len(arr[crop_start: crop_end + 1])\n            \n                \n                \n                \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        i,j = -1,-1\n        L = len(arr)\n        for k in range(L-1):\n            if arr[k]>arr[k+1]:\n                j = k+1\n                if i==-1:\n                    i = k\n        #print(i,j)\n        if i==-1:\n            return 0\n        res = j\n        for m in range(i+1):\n            while j<=L-1:\n                if arr[j]>=arr[m]:\n                    break\n                j += 1\n            if j==L:\n                return min(res,L-i-1)\n            else:\n                res = min(res,j-m-1)\n            #print(m,j,res)\n        return res", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        queue = deque([arr[-1]])\n        for i in range(len(arr)-1, 0, -1):\n            if arr[i-1] > arr[i]:\n                break\n            queue.appendleft(arr[i-1])\n            \n        if len(queue) == len(arr):\n            return 0\n        \n        l = len(arr) - len(queue)\n        def search(target):\n            lo = l\n            hi = l+len(queue)\n            \n            while lo < hi:\n                mid = (lo + hi) // 2\n                if arr[mid] >= target:\n                    hi = mid\n                else:\n                    lo = mid+1\n            return lo\n        \n        curMin = len(arr) - len(queue)\n        i = 0\n        while i < len(arr)-1 and arr[i] <= arr[i+1]:\n            idx = search(arr[i])\n            curMin = min(idx-i-1, curMin)\n            i += 1\n        idx = search(arr[i])\n        curMin = min(idx-i-1, curMin)\n        \n        return curMin\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n, l = len(arr), 0 \n        \n        while l+1 < n and arr[l+1] >= arr[l]: \n            l += 1  \n            \n        if l == n-1: \n            return 0   \n        \n        r = n-1\n        \n        while r > 0 and arr[r-1] <= arr[r]: \n            r -= 1          \n            \n        if arr[l] <= arr[r]: \n            return r-l-1\n        \n        ans = min(n-l-1, r)\n        \n        for i in range(l+1): \n            if arr[i] <= arr[r]: \n                ans = min(ans, r-i-1)               \n            elif r < n-1: \n                r += 1\n\n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l,r = 0,len(arr) - 1\n        while l < r and arr[l + 1] >= arr[l]:\n            l += 1\n            \n        if l == len(arr) - 1:\n            return 0\n            \n        while r < len(arr) and arr[r - 1] <= arr[r]:\n            r -= 1\n            \n        toRemove = min(len(arr) - l - 1,r)\n        \n        for iL in range(l + 1):\n            if arr[iL] <= arr[r]:\n                toRemove = min(toRemove,r - iL - 1)\n            elif r < len(arr) - 1:\n                r += 1\n            else:\n                break\n        return toRemove", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n < 2: return 0\n        left, right = 1, n - 1\n        while left < n and arr[left] >= arr[left - 1]:\n            left += 1\n        if left == n:\n            return 0\n        while left < right and arr[right] >= arr[right - 1]:\n            right -= 1\n        res = min(n - left, right)\n        left -= 1\n        while left >= 0:\n            l, r = right - 1, n - 1 # l < arr[m] <= r\n            while r - l > 1:\n                m = (l + r) // 2\n                if arr[m] >= arr[left]:\n                    r = m\n                else:\n                    l = m\n            if arr[left] > arr[r]: r += 1\n            res = min(res, r - left - 1)\n            left -= 1\n        return res\n            \n        \n        \n        \n        \n        \n        \n# 5 1 2 3 4\n# 1 2 3 4 1\n\n# 1 2 3 4 5 100 2 3 4 5 4 7 8 10 3 4 5 6 7 8\n#               l                r\n\n\n# 10 11 12 5 6 7 8 9 10 11 12 1 2 3 4\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        res = 0\n        if len(arr) > 1:\n            mr = len(arr)-1\n            while mr - 1 >= 0 and arr[mr - 1] <= arr[mr]:\n                mr -= 1\n            if mr > 0:\n                cr, res = mr, mr\n                prev = -1\n                for ml in range(0, len(arr)):\n                    if prev <= arr[ml]:\n                        while mr < len(arr) and arr[ml] > arr[mr]:\n                            mr += 1\n                            cr += 1\n                        cr -= 1\n                        res = min(res, cr)\n                    else:\n                        break\n                    prev = arr[ml]\n                \n                \n        return res", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        left, right = n-1, 0\n        for i in range(n):\n            if i > 0 and arr[i] < arr[i-1]:\n                left = i-1\n                break\n        for i in range(n-1, -1, -1):\n            if i < n-1 and arr[i] > arr[i+1]:\n                right = i+1\n                break\n        if left >= right:\n            return 0\n        \n        ans = min(n-left, right)\n        j = right\n        for i in range(left+1):\n            if j < len(arr) and arr[j] < arr[i]:\n                j += 1\n            ans = min(ans, j-i-1)\n        return ans\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        peak=0\n        while peak<len(arr)-1 and  arr[peak]<=arr[peak+1]:\n            peak+=1\n        if peak==len(arr)-1:\n            return 0\n        valley=len(arr)-1\n        while valley>0 and  arr[valley]>=arr[valley-1]:\n            valley=valley-1\n        ans=min(valley,len(arr)-peak-1)\n        i=0\n        j=valley\n        while i<=peak and j<len(arr):\n            if arr[j]>=arr[i]:\n                ans=min(ans,j-i-1)\n                i+=1\n            else:\n                j+=1\n        return ans\n        \n            \n                \n                \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n=len(arr)\n        i=0\n        for i in range(n-1):\n            if arr[i+1]<arr[i]:\n                break\n        left=i\n        for i in range(n-1,0,-1):\n            if arr[i-1]>arr[i]:\n                break\n        right=i\n        if right<=left:\n            return 0\n        i=0\n        j=right\n        ans=min(n-left-1,right)\n        while i<=left and j<n:\n            if arr[i]<=arr[j]:\n                ans=min(ans,j-i-1)\n                i+=1\n            elif arr[j]<arr[i]:\n                j+=1\n        return n-1 if ans==n+1 else ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        stack = [(len(arr)-1, arr[-1])]\n        \n        for i in range(len(arr)-2, -1, -1):\n            if arr[i] <= arr[i+1]:\n                stack.append([i, arr[i]])\n            else:\n                break\n        \n        min_len = len(arr)-len(stack)\n        \n        for i in range(len(arr)):\n            if i == 0 or arr[i] >= arr[i-1]:\n                while len(stack) > 0 and (stack[-1][1] < arr[i] or stack[-1][0] == i):\n                    stack.pop()\n\n                if len(stack) > 0:\n                    min_len = min(min_len, stack[-1][0]-i-1)\n                else:\n                    min_len = min(min_len, len(arr)-i-1)\n            else:\n                break\n        \n        return min_len\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l,r = 0,len(arr) - 1\n        while l < r and arr[l] <= arr[l + 1]:\n            l += 1\n        if l == len(arr) - 1:\n            return 0\n        \n        while r >= 0 and arr[r] >= arr[r - 1]:\n            r -= 1\n            \n        toRemove = min(len(arr) - l - 1,r)\n        \n        for iL in range(l + 1):\n            if arr[iL] <= arr[r]:\n                toRemove = min(toRemove,r - iL - 1)\n                l += 1\n            elif r < len(arr) - 1:\n                r += 1\n            else:\n                break\n           \n        return toRemove", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        #https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/discuss/830480/C%2B%2B-O(N)-Sliding-window-Explanation-with-Illustrations\n        #\u8fd9\u9053\u9898\u662ftwo pointer\u7c7b\u578b\u9898\u76ee\n        #\u5927\u4f53\u7684\u903b\u8f91\u5c31\u662f\u5de6\u8fb9\u4e00\u4e2apointer\uff0c\u53f3\u8fb9\u4e00\u4e2apointer\n        left = 0\n        right = len(arr) - 1\n        \n        #left\u5411\u53f3\u8d70\uff0c\u5982\u679cleft+1\u6307\u5411\u7684\u6570\u5b57\u5927\u4e8e\u7b49\u4e8eleft\u5c31\u4e00\u76f4\u8d70\n        #\u5982\u679cleft\u4e00\u8def\u8d70\u5230\u4e86end\uff0c\u90a3\u5c31\u8bf4\u660e\u539flist\u5c31\u662fsorted\u7684\uff0c\u90a3\u5c31\u76f4\u63a5return\n        while left + 1 <= len(arr) - 1 and arr[left] <= arr[left+1]:\n            left += 1\n        \n        if left == right:\n            return 0\n        \n        #right\u540c\u7406\u5411\u5de6\u8d70\uff0c\u5982\u679cright-1\u5c0f\u4e8e\u7b49\u4e8eright\u5c31\u7ee7\u7eed\u8d70\n        while right - 1 >= 0 and arr[right] >= arr[right - 1]:\n            right -= 1\n            \n        #\u7136\u540e\u5148\u5904\u7406\u4e24\u8fb9 \u5c31\u662f\u5f530\u5230right-1 \u6216\u8005 left+1\u5230end \u5176\u4e2d\u4e00\u4e2a\u53bb\u6389\uff0c\u4e5f\u5c31\u662f\u53bb\u6389\u4e24\u8fb9\n        #\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b \u65e0\u8bba\u600e\u4e48\u79fb\u9664\u4e2d\u95f4\u7684\u90e8\u5206 \u90fd\u6ca1\u6709\u529e\u6cd5\u4f7f\u4e24\u8fb9\u7ec4\u5408\u8d77\u6765\u6210\u4e3a\u9012\u589e\n        #\u8fd9\u79cd\u60c5\u51b5\u5c31\u50cf[6,7,8,9,10,3,5,20,4,1,2,3]\n        #left\u6307\u541110\uff0cright\u6307\u54111 -- \u56e0\u4e3a\u53ea\u80fd\u79fb\u9664\u4e00\u4e2asubarry\u6240\u4ee5\u8981\u4ece 6\u523020 \u548c 3\u52303 \u4e2d\u9009\u4e00\u4e2a\n        \n        \n        #\u6240\u4ee5\u5982\u679c\u662f\u8fd9\u79cdcase\uff0c\u90a3\u5c31\u5148\u8981\u8ba1\u7b97\u4e24\u4e2a\u8fb9\u8f83\u5c0f\u7684\u90a3\u4e2a\n        #right\u5c31\u662f0\u5230right -1 index\u7684\u957f\u5ea6\n        #len(arr)- 1 - left \u5c31\u662f end - left \u4e5f\u5c31\u662f left + 1\u5230end index\u7684\u957f\u5ea6  \n        min_sublen = min(right, len(arr)- 1 - left)\n        \n        #\u7136\u540e\u5c31\u53ef\u4ee5\u5f00\u59cb\u8fdb\u884c\u4e2d\u95f4\u60c5\u51b5\u7684\u8fd0\u7b97\n        #\u5927\u6982\u5c31\u662f\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u6211\u4eecleft\u548cright\u8981\u8fdb\u884c\u79fb\u52a8\uff0c\u7136\u540e\u627e\u5230\u6700\u77ed\u7684\u4e2d\u95f4subarray\uff0c\u4f7f\u5f97\u8be5array\u53bb\u6389\u540e\u5de6\u53f3\u4e24\u8fb9\u80fd\u6210\u4e3a\u9012\u589earray\n        #\u5927\u6982\u7684\u64cd\u4f5c\u5c31\u662f\u6bd4\u8f83 \u4e24\u4e2a\u6307\u9488lp\u548crp \u4ece0\u5230left \u548c \u4eceright\u5230end\n       \n        #\u5982\u679clp\u5c0f\u4e8erp\u4e86\uff0c\u90a3\u5c31\u8bf4\u660e\u53bb\u6389lp\u548crp\u4e2d\u95f4\u8303\u56f4\u5c31\u662f\u9012\u589e\uff0c\u6b64\u65f6\u5c31\u53ef\u4ee5\u8ba1\u7b97\u4e0bsubarr\u957f\u5ea6\uff0c\u7136\u540e\u8fdb\u884c\u6bd4\u8f83\uff0c\u7559\u4e0b\u6700\u5c0f\u7684\u90a3\u4e2a\u3002\u7136\u540elp\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u518d\u7ee7\u7eed\u6bd4\u8f83\n        #\u77e5\u9053lp\u5230\u8fbe\u4e86left\uff0c\u6216\u8005rp\u5230\u8fbe\u4e86end\uff0c\u5c31\u505c\u6b62 \u8fd4\u56de\u6700\u77ed\u7684subarry\u957f\u5ea6\n        lp = 0\n        rp = right\n        \n        #\u5982\u679clp\u5927\u4e8erp\uff0c\u90a3\u5c31\u8bf4\u660elp\u592a\u5927\u4e86\uff0crp\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\n        while lp <= left and rp <= len(arr) - 1:\n            if arr[lp] > arr[rp]:\n                rp += 1\n            #\u5982\u679clp\u5c0f\u4e8erp\u4e86\uff0c\u90a3\u5c31\u8bf4\u660e\u53bb\u6389lp\u548crp\u4e2d\u95f4\u8303\u56f4\u5c31\u662f\u9012\u589e\uff0c\u6b64\u65f6\u5c31\u53ef\u4ee5\u8ba1\u7b97\u4e0bsubarr\u957f\u5ea6\uff0c\u7136\u540e\u8fdb\u884c\u6bd4\u8f83\uff0c\u7559\u4e0b\u6700\u5c0f\u7684\u90a3\u4e2a\u3002\u7136\u540elp\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u518d\u7ee7\u7eed\u6bd4\u8f83\n            else:\n                min_sublen = min(min_sublen, rp-lp-1)\n                lp += 1\n        \n        return min_sublen", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l,r = 0, len(arr)-1\n        while l < r and arr[l+1] >= arr[l]:\n            l += 1\n        if l == len(arr)-1:\n            return 0\n        while r > 0 and arr[r-1] <= arr[r]:\n            r -= 1\n            \n        toRemove = min(len(arr)-1-l,r)\n        \n        for iL in range(l+1):\n            if arr[iL] <= arr[r]:\n                toRemove = min(toRemove, r-iL-1)\n            elif r < len(arr)-1:\n                r += 1\n            else:\n                break\n        return toRemove\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        stack = [(len(arr)-1, arr[-1])]\n        \n        for i in range(len(arr)-2, -1, -1):\n            if arr[i] <= arr[i+1]:\n                stack.append([i, arr[i]])\n            else:\n                break\n        \n        min_len = len(arr)-len(stack)\n        \n        for i in range(len(arr)):\n            if i == 0 or arr[i] >= arr[i-1]:\n                while len(stack) > 0 and (stack[-1][1] < arr[i] or stack[-1][0] <= i):\n                    stack.pop()\n\n                if len(stack) > 0:\n                    min_len = min(min_len, stack[-1][0]-i-1)\n                else:\n                    min_len = min(min_len, len(arr)-i-1)\n            else:\n                break\n        \n        return min_len\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        i = 1\n        if len(arr) <= 1:\n            return 0\n        while i < n:\n            if arr[i] < arr[i-1]:\n                break\n            i += 1\n        max_len = i\n        if max_len == n:\n            return 0\n        ini_ind = i - 1\n        end_ind = 1\n        while ini_ind >= 0:\n            if arr[ini_ind] <= arr[-1]:\n                break\n            ini_ind -= 1\n        max_len = max(max_len, ini_ind + end_ind + 1)\n        while arr[-end_ind-1] <= arr[-end_ind]:\n            while ini_ind >= 0:\n                if arr[ini_ind] <= arr[-end_ind-1]:\n                    break\n                ini_ind -= 1\n            end_ind += 1\n            max_len = max(max_len, ini_ind + end_ind + 1)\n        return n - max_len", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        start, end = 0, 0\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1] or (start and arr[i] < arr[start - 1]):\n                if not start:\n                    start = i\n                end = i\n        if start > 0:\n            if arr[end] >= arr[start - 1]:\n                end -= 1\n            curr_opt = end - start + 1\n        else:\n            curr_opt = end - start\n        for i in range(start):\n            start -= 1\n            while (end == len(arr) - 1 or arr[end] <= arr[end + 1]) and ((start and arr[end] >= arr[start - 1]) or not start):\n                end -= 1\n            curr_opt = min(curr_opt, end - start + 1)\n        return curr_opt\n            \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        l, r = 0, n-1\n        while 0 < r and arr[r-1] <= arr[r]:\n            r -= 1\n        \n        ret = r\n        while l == 0 or l < n and arr[l-1] <= arr[l]:\n            while r<=l or r < n and arr[r] < arr[l]:\n                r += 1\n            ret = min(ret, r - l - 1)\n            l += 1\n             \n        return ret", "from typing import *\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        i, j = 0, n - 1\n        while i < n - 1 and arr[i] <= arr[i + 1]:\n            i += 1\n        if i == n - 1:\n            return 0\n        while j > i and arr[j - 1] <= arr[j]:\n            j -= 1\n        res = min(n - i - 1, j)\n        oldi = i\n        oldj = j\n        i = 0\n        while i <= oldi and j < n:\n            if arr[i] <= arr[j]:\n                res = min(res, j - i - 1)\n                i += 1\n            else:\n                j += 1\n        return res\n\nprint(Solution().findLengthOfShortestSubarray([1,3,2,4])) # 1\nprint(Solution().findLengthOfShortestSubarray([1,2,3,10,4,2,3,5])) # 3", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \n        desc_idx = []\n        for idx in range(len(arr)):\n            if idx > 0 and arr[idx] < arr[idx - 1]:\n                desc_idx.append(idx-1)\n        \n        if len(desc_idx) == 0:\n            return 0\n        ans = len(arr)\n        start, end = desc_idx[0], desc_idx[-1]\n        shift_range = [0 , 1]\n        for shift1 in shift_range:\n            for shift2 in shift_range:\n                left = arr[:start+shift1]\n                right = arr[end+1+shift2:]\n                left_extend = -1\n                right_extend = -1\n\n\n                if len(left) == 0:\n                    right_extend = 0\n                else:\n                    for idx in range(len(right)):\n                        if right[idx] >= left[-1]:\n                            right_extend = idx\n                            break\n                    if right_extend == -1:\n                        right_extend = len(right)\n\n                if len(right) == 0:\n                    left_extend = 0\n                else:\n                    for idx in range(len(left)):\n                        if left[-(idx+1)] <= right[0]:\n                            left_extend = idx\n                            break\n                    if left_extend == -1:\n                        left_extend = len(left)\n                \n                ans = min(ans, min(left_extend, right_extend) +  (end+1+shift2) - (start + shift1))\n                #extend.append(left_extend)\n                #extend.append(right_extend)\n        \n        #print(extend, ans, desc_idx)\n        #ans += min(extend)\n        return ans\n            \n            \n", "class Solution:\n\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        # [1,2,3,10,4,2,3,5]\n        \n        r = len(arr) - 1 \n        while r >0 and arr[r] >= arr[r-1]:\n            r -= 1\n            \n        ret = r # worst case, remove all left\n        l = 0\n        \n        for l in range(len(arr)):\n            if l>0 and arr[l] < arr[l-1]:\n                break\n            if l >= r:\n                r += 1\n            while r < len(arr) and arr[l] > arr[r] :\n                r +=1\n            \n\n            ret = min(ret, r-l-1)\n                \n            \n            \n        return ret\n            \n\n        \n\n        \n\n        \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        for i in range(n):\n            if i+1 >= n or arr[i] > arr[i+1]:\n                l_end = i\n                break\n        for i in range(n-1,-1,-1):\n            if i-1 < 0 or arr[i-1] > arr[i]:\n                r_start = i\n                break\n        if r_start <= l_end: return 0\n        i, j = 0, r_start\n        res = min(n-(l_end+1),r_start)\n        for i in range(l_end+1):\n            while j < n and arr[i] > arr[j]:\n                j += 1\n            res = min(res, j-i-1)\n        return res", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \n        '''\n        [1,2,3,10,4,2,3,5]\n        3\n        \n        '''\n        def doesExist(arr, size, prefix, suffix):\n            if size >= suffix or (len(arr) -1 - size) <= prefix:\n                return True\n            for i in range(len(arr) - size - 1):\n                if prefix < i:\n                    break\n                else:\n                    j = i + size + 1\n                    if arr[i] <= arr[j] and j >= suffix:\n                        return True\n            return False\n          \n        prefix = 0\n        suffix = len(arr) - 1\n        for i in range(1, len(arr)):\n            if arr[i-1] <= arr[i]:\n                prefix = i\n            else:\n                break\n        \n        for i in range(len(arr) - 1, 0, -1):\n            if arr[i-1] <= arr[i]:\n                suffix = i - 1\n            else:\n                break\n                \n        l = 0\n        r = len(arr) - 1\n        optimal = r\n        while l <= r:\n            mid = (l + r) // 2\n            if doesExist(arr, mid, prefix, suffix):\n                optimal = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        return optimal\n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        #sliding window\n        #find the first element which is smaller than the previous one\n        start_f = 0\n        while start_f<len(arr)-1:\n            if arr[start_f+1] >= arr[start_f]:\n                start_f += 1\n            else:\n                break\n        \n        # if already sorted, end_f is the last element\n        if start_f == len(arr)-1:\n            return 0\n        \n        #find the end point that let end+1 element > start_f element\n        end_f = len(arr)-1\n        \n        if arr[-1] < arr[start_f]:\n            end_f = len(arr)\n        else:\n            while end_f-1 >= 0 and arr[end_f-1] >= arr[start_f]:\n                if arr[end_f-1] <= arr[end_f]: # \u9010\u6e10\u5728\u53d8\u5c0f\n                    end_f -= 1\n                else: #not sorted\uff0c \u524d\u9762\u4e00\u4e2a\u6570\u6bd4\u8f83\u5927\u4e86\uff0c\u90a3\u4e48\u5728\u5f80\u524d\u9000\uff0c\u4f1a\u5bfc\u81f4\u7b2c\u4e8c\u90e8\u5206\u4e0d\u662fsort\u7684\n                    break\n                    \n        #start,end \u662f\u9700\u8981remove\u7684\n        start, end = start_f+1, end_f-1\n        \n        ans = end-start+1\n        \n        #\u9010\u6e10\u628astart\u5f80\u524d1\uff0c\u770b\u80fd\u4e0d\u80fd\u5f97\u5230\u66f4\u5c0f\u7684\u503c\n        while start >= 0:\n            start -= 1\n            while start ==0 or arr[end] >= arr[start-1]: # start ==0\u7684\u65f6\u5019\u5c31\u6ca1\u6709\u7b2c\u4e00\u90e8\u5206\u4e86\n                \n                if end == len(arr)-1 or arr[end] <= arr[end+1]: # end\u6700\u5927\u65f6\uff0c\u5c31\u6ca1\u6709\u7b2c\u4e8c\u90e8\u5206\u4e86\n                    end -= 1\n                    ans = min(ans, end-start+1)\n                else:\n                    break\n        return ans\n        \n            \n        \n", "import bisect\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        start, end = 0, len(arr)-1\n        while start < len(arr)-1:\n            if arr[start] > arr[start+1]:\n                break\n            start += 1                \n        if start == len(arr)-1:\n            return 0 \n        while end > 0:\n            if arr[end] < arr[end-1]:\n                break\n            end -= 1                                \n        best_dist = end\n        for i in range(start, -1, -1):\n            j = bisect.bisect_left(arr, arr[i], end, len(arr))\n            dist = j - i - 1\n            best_dist = min(best_dist, dist)\n        return best_dist            \n\n", "class Solution(object):\n    def findLengthOfShortestSubarray(self, A):\n        N = len(A)\n        j = N - 1\n        while j and A[j] >= A[j - 1]:\n            j -= 1\n        # A[j:] is monotone increasing\n        \n        ans = j\n        for i in range(j):\n            if i and A[i] < A[i-1]:\n                break\n            # A[..i] is monotone increasing\n            while j < N and A[i] > A[j]:\n                j += 1\n            # j is the smallest such that A[i] <= A[j]\n            # Remove A[i+1..j-1] which has length j - i - 1\n            ans = min(ans, j - i - 1)\n        \n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        # find the first inst in left side where arr[i] < arr[i-1]\n        # next, find the first inst in right side where arr[j] < arr[j-1]\n        # next, we start i from 0, j at j\n        # we shrink window if arr[i] <= arr[j]\n        # we expand window if arr[i] > arr[j]\n        # we store the size of the window to ans\n        n = len(arr)\n        left = 0\n        while (left + 1 < n and arr[left] <= arr[left + 1]):\n            left += 1\n        if left == n - 1: return 0\n        \n        right = n-1\n        while (right > left and arr[right - 1] <= arr[right]):\n            right -= 1;\n        \n        ans = min(n - left - 1, right)\n        i, j = 0, right\n        while i <= left and j < n:\n            if arr[i] <= arr[j]:\n                ans = min(ans, j - i - 1)\n                i += 1\n            else:\n                j+=1\n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \n        def lowerbound(left, right, target):\n            while left < right:\n                mid = left + (right - left) // 2\n                \n                if arr[mid] == target:\n                    right = mid\n                elif arr[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n            \n            return left\n        \n        N = len(arr)\n        \n        i = 0\n        while i + 1 < N and arr[i] <= arr[i + 1]:\n            i += 1\n        \n        if i == N - 1:\n            return 0\n        \n        j = N - 1\n        while j - 1 >= 0 and arr[j] >= arr[j - 1]:\n            j -=1\n            \n        if j == 0:\n            return N - 1\n        \n        result = min(N - (N-j), N - i - 1)\n        \n        for k in range(i + 1):\n            l = lowerbound(j, len(arr), arr[k])\n            result = min(result, l - (k + 1))\n        \n        return result", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l = 0\n        longest_array = 0\n        while l < len(arr)-1 and arr[l+1] >= arr[l]:\n            l += 1\n        longest_array = l+1\n\n        r = len(arr)-1\n        while r > 0 and arr[r] >= arr[r-1]:\n            r -= 1\n        longest_array = max(longest_array, len(arr)-r)\n        #print(f'{l} {r}')\n\n        p1 = 0\n        p2 = r\n\n        while p1 <= l and p2 < len(arr):\n            if arr[p1] <= arr[p2]:\n                longest_array = max(longest_array, p1 + len(arr)-p2+1)\n                p1 += 1\n            else:\n                p2 += 1\n\n        if len(arr)-longest_array < 0:\n            return 0\n    \n        return len(arr) - longest_array", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        arr = [0] + arr + [float('inf')]\n        left = 0\n        right = len(arr) - 1\n        \n        while left != right:\n            if arr[left + 1] < arr[left]:\n                break\n            left += 1\n            \n        while left != right:\n            if arr[right - 1] > arr[right]:\n                break\n            right -= 1\n            \n        if right == left: return 0\n        \n        return search(left, right, arr)\n        \n\ndef search(leftidx, rightidx, arr):\n    if arr[rightidx] >= arr[leftidx]: return rightidx - leftidx - 1\n    leftsearch = rightsearch = midsearch = len(arr)\n    if leftidx > 0:\n        leftsearch = search(leftidx - 1, rightidx, arr)\n    if rightidx < len(arr) - 1:\n        rightsearch = search(leftidx, rightidx + 1, arr)\n    if leftidx > 0 and rightidx < len(arr) - 1:\n        midsearch = search(leftidx - 1, rightidx + 1, arr)\n    \n    return min(leftsearch, rightsearch, midsearch)", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n=len(arr)\n        left,right=-1,-1\n        for i in range(n-1):\n            if arr[i]>arr[i+1]:\n                left=i+1\n                break\n        if left==-1:\n            return 0\n        for j in range(n-1, 0, -1):\n            if arr[j]<arr[j-1]:\n                right=j-1\n                break\n        if right==-1:\n            return 0\n        \n        ans=min(right+1, n-left)\n        i=0\n        for j in range(right+1,n):\n            while i<left and arr[i]<=arr[j]:\n                i+=1\n            ans=min(ans, j-i)\n            if i==left:\n                break\n        return ans\n\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n=len(arr)\n        ndpreflen=1\n        for i in range(1,n):\n            if arr[i]<arr[i-1]: break\n            ndpreflen+=1\n        ndsufflen=1\n        for i in range(1,n):\n            if arr[n-1-i]>arr[n-i]: break\n            ndsufflen+=1\n        if ndpreflen+ndsufflen>n: return 0\n        sufffirstkeep_idx=n-ndsufflen\n        ans=min(n-ndpreflen,n-ndsufflen)\n        for preflastkeep_idx in range(ndpreflen):\n            while sufffirstkeep_idx<n and arr[sufffirstkeep_idx]<arr[preflastkeep_idx]:\n                sufffirstkeep_idx+=1\n            if sufffirstkeep_idx==n: break\n            ans=min(ans,sufffirstkeep_idx-preflastkeep_idx-1)\n        return ans", "class Solution:\n    '''\n    https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/discuss/830480/C%2B%2B-O(N)-Sliding-window-Explanation-with-Illustrations\n    1,2,3,10,4,2,3,5]\n    1 2 2  3 3 4 5 10\n    '''\n    def findLengthOfShortestSubarray(self, A: List[int]) -> int:\n        N = len(A)\n        left, right = 0, N - 1\n        while left + 1 < N and A[left] <= A[left + 1]:\n            left += 1\n        if left == N - 1: # not decreasing already \n            return 0\n        \n        while right > left and A[right - 1] <= A[right]:\n            right -= 1\n            \n        ans = min(N - left - 1, right)\n        i, j = 0, right\n        while i <= left and j < N:\n            if A[j] >= A[i]:\n                # can remove\n                ans = min(ans, j - i - 1)\n                i += 1 # then shrink silde window\n            else:\n                # enlarge slide window\n                j += 1\n        return ans", "from bisect import bisect_right\n\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        arr = [float('-inf')] + arr + [float('inf')]\n        if arr == sorted(arr): return 0\n        N = len(arr)\n        negatives = [None, None]\n        for i in range(1, N):\n            diff = arr[i] - arr[i-1]\n            if diff < 0:\n                if negatives[0] is None:\n                    negatives[0] = i\n                negatives[1] = i\n        ans = float('inf')\n        for j in range(negatives[1], N):\n            idx = bisect_right(arr, arr[j], hi=negatives[0])\n            ans = min(ans, j - idx)\n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n==0:\n            return 0\n        l, r = 0,n-1\n        while l < n-1 and arr[l] <= arr[l+1]:\n             l += 1\n        while r > 0 and arr[r-1] <= arr[r]:\n            r -= 1\n        nums_to_rm = min(n - 1 - l, r)\n        for c in range(l+1):\n            if arr[c] <= arr[r]:\n                nums_to_rm = min(nums_to_rm, max(0,r-c-1))\n            else:\n                if r < n-1:\n                    r += 1\n                else:\n                    break\n        \n        return nums_to_rm\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n        a,temp= [],[]\n        temp.append(arr[0])\n        for i in range(1,len(arr)):\n            if arr[i] - arr[i - 1] >= 0:\n                temp.append(arr[i])\n            else:\n                a.append(temp)\n                temp = []\n                temp.append(arr[i])\n        if temp:\n            a.append(temp)\n        if len(a)<=1:\n            return 0\n        else:\n            deletelen=[]\n            a0,a_1=a[0],a[-1]\n            deletelen.append(len(arr)-len(a0))\n            deletelen.append(len(arr)-len(a_1))\n            if a0[-1]<=a_1[0]:\n                deletelen.append(len(arr)-len(a0)-len(a_1))\n            else:\n                for i in range(len(a_1)):\n                    for j in range(len(a0)-1,-1,-1):\n                        if a_1[i]>=a0[j]:\n                            deletelen.append(len(arr) - len(a0) - len(a_1)+i+(len(a0)-j-1))\n                            break\n            return min(deletelen)", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if arr == sorted(arr):\n            return 0\n        L = len(arr)\n        \n        left = [arr[0]]\n        right = [arr[-1]]\n        \n        for i in range(1, L):\n            if arr[i] >= left[-1]:\n                left += [arr[i]]\n            else:\n                break\n        \n        for i in range(L-2, -1, -1):\n            if arr[i] <= right[0]:\n                right.insert(0, arr[i])\n            else:\n                break\n        \n        while len(left)-1 >= L-len(right) and left[-1] == right[0]:\n            left.pop(-1)\n        print((left, right, L))\n                \n        ret = 0\n        arr_len = 0\n        for i in range(len(left)):\n            for j in range(len(right)):\n                temp = 0\n                if left[i] <= right[j]:\n                    temp = i+1+len(right)-j\n                    break\n            # if left[i] in right:\n            #     idx_right = right.index(left[i])\n            #     temp = i+1+len(right)-idx_right\n            # else:\n            #     idx_right = len(right)-1\n            #     temp = 0\n            arr_len = max(arr_len, temp)\n        \n        return L-max(len(left), len(right), arr_len)\n", "class Solution:\n    # O(n)\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n\n        # determine right sorted subarray\n        r = len(arr) - 1 \n        while r >0 and arr[r] >= arr[r-1]:\n            r -= 1\n        \n        # r == 0 means array is sorted\n        if r == 0:\n            return 0\n        \n        # now determine left sorted subarray that can be merged with right\n        ret = r # set ret to worst case, remove all left \n        l = 0\n        for l in range(len(arr)):\n            # if left subarry is not in order anymore, stop, can't do better\n            if l>0 and arr[l] < arr[l-1]:\n                break\n            \n            # if arr[l] is larger than the left edge of right sorted subarray, \n            # push the edge to the right\n            # why this work? Is it OK to push to the right? We won't consider\n            # arr[i+1] and arr[r].\n            # It's OK! We don't have to consider arr[i+1] and arr[r].\n            # if arr[i] is larger than the left edge, arr[next i] is larger too!\n            # so it won't be the possible answer\n            while r < len(arr) and arr[l] > arr[r] :\n                r +=1\n\n            ret = min(ret, r-l-1)\n\n        return ret\n            \n\n        \n\n        \n\n        \n        \n", "from collections import deque\nimport bisect\n\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l, r = deque([]), deque([])\n        for i, x in enumerate(arr):\n            if len(l) == 0 or x >= l[-1]:\n                l.append(x)\n            else:\n                break\n        for i, x in enumerate(arr[::-1]):\n            if len(r) == 0 or x <= r[0]:\n                r.appendleft(x)\n            else:\n                break\n        if len(l) == len(arr):\n            return 0\n        a, b = len(l), len(r)\n        ans = b\n        for i, x in enumerate(l):\n            idx = bisect.bisect_left(r, x)\n            ans = max(ans, i + 1 + b - idx)\n        \n        return len(arr) - ans\n", "import bisect\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        start = None\n        for i in range(0, len(arr)-1):\n            if arr[i] > arr[i+1]:\n                start = i\n                break\n                \n        if start == None:\n            return 0 \n        \n        for i in range(len(arr)-1, 0, -1):\n            if arr[i] < arr[i-1]:\n                end = i\n                break\n\n        best_dist = end\n        for i in range(start, -1, -1):\n            j = bisect.bisect_left(arr, arr[i], end, len(arr))\n            dist = j - i - 1\n            best_dist = min(best_dist, dist)\n            \n        return best_dist            \n\n", "\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        # Find the longest monotonically non-decreasing prefix array in [0, i]\n        n = len(arr)\n        l = 1\n        while l < n and arr[l-1] <= arr[l]:\n            l += 1\n        l -= 1  \n        if l >= n - 2:\n            return n - 1 - l\n                \n        # Find the longest monotonically non-decreasing suffix array in [j, n - 1]\n        r = n - 2\n        while r >= 0 and arr[r] <= arr[r+1]:\n            r -= 1\n        r += 1\n        if r <= 1:\n            return r\n    \n        # Start off with min of either left or right side removed as the min_to_move\n        min_to_remove = min(n - 1, n - 1 - (l + 1) + 1, r)\n        # Try to merge [0..i] from the left into [r..n-1]. If it doesn't work, \n        # push r forward and try again, until we run out of either room for i to expand\n        # toward the right or for r to push forward to the right.\n        i = 0\n        while i < l + 1:\n            if arr[i] <= arr[r]:\n                min_to_remove = min(min_to_remove, r - i - 1)\n                i += 1\n            elif r < n - 1:\n                r += 1\n                # i += 1 # More intuitive and less subtle to NOT increment i\n\n                # Why? Because if after i gets incremented a few times to\n                # i' such that arr[i'] <= arr[r], then arr[r] must be >=\n                # all elements in [i..i'-1] because elements in [0..l] are\n                # non-decreasing. In other words as soon we hit line \n                # `if arr[i] <= arr[r]:` (after incrementing i a few times\n                # without successfully finding some arr[r], arr[i] <= arr[r]),\n                # all those values behind arr[i] can now be included in the merged\n                # result.\n            else:\n                break\n        \n        return min_to_remove\n\n        \n    def findLengthOfShortestSubarray_bruteforce_bsearch(self, arr: List[int]) -> int:\n        # Returns the smallest index `idx` such that arr[idx] >= val\n        def bsearch(val, low, high):\n            while low < high:\n                mid = (low + high) // 2\n                if arr[mid] >= val:\n                    high = mid\n                else:\n                    low = mid + 1\n            if val > arr[high]:\n                return high + 1\n            return high\n        \n        # Find the longest monotonically non-decreasing prefix array in [0, i]\n        n = len(arr)\n        curr_max = float('-inf')\n        i = 0\n        while i < n:\n            if arr[i] < curr_max:\n                break\n            curr_max = arr[i]\n            i += 1\n        i -= 1  \n        if i >= n - 2:\n            return n - 1 - i\n                \n        # Find the longest monotonically non-decreasing suffix array in [j, n - 1]\n        curr_min = float('inf')\n        j = n - 1\n        while j >= 0:\n            if arr[j] > curr_min:\n                break\n            curr_min = arr[j]\n            j -= 1\n        j += 1\n        if j <= 1:\n            return j\n        \n        # For each value arr[k], in [0, i], find the `right_idx` into the suffix array in [j, n - 1]\n        # such that arr[k] >= arr[right_idx]. We want to find the one that results in the longest\n        # sequence [0..k] + [right_idx..n-1]\n        min_to_remove = float('inf')\n        for k in range(i, -1, -1):\n            right_idx = bsearch(arr[k], j, n - 1)\n            l = k + 1 + n - right_idx\n            to_remove = n - l\n            min_to_remove = min(min_to_remove, to_remove)\n            \n        # For each value arr[k], in [j, n-1], find the `left_idx` into the prefix array in [0, i]\n        # such that arr[k] >= arr[left_idx - 1]. We want to find the one that results in the longest\n        # sequence [0..left_idx-1] + [k..n-1]\n        for k in range(j, n):\n            left_idx = bsearch(arr[k], 0, i)\n            l = left_idx + n - k\n            to_remove = n - l\n            min_to_remove = min(min_to_remove, to_remove)\n        \n        return min_to_remove\n        \n        \n\n        \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        arr = [-float('inf')] + arr + [float('inf')]\n        sorted_to = [False for _ in range(len(arr))]\n        sorted_from = [False for _ in range(len(arr))]\n        rev_arr = arr[::-1]\n        last_sorted_to = -1\n        first_sorted_from = -1\n        shortest = float('inf')\n        for idx, val in enumerate(arr):\n            if idx == 0 or val >= arr[idx - 1]:\n                sorted_to[idx] = True\n                last_sorted_to = idx\n            else:\n                break\n        for idx, val in enumerate(rev_arr):\n            if idx == 0 or val <= rev_arr[idx - 1]:\n                sorted_from[len(arr) - 1 - idx] = True\n                first_sorted_from = len(arr) - 1 - idx\n            else:\n                break\n        if arr == sorted(arr):\n            return 0\n        for i in range(last_sorted_to + 1):\n            for j in range(first_sorted_from, len(arr)):\n                if arr[j] >= arr[i]:\n                    shortest = min(shortest, j - i - 1)\n                    break\n            shortest = min(shortest, len(arr) - i - 1)\n\n        return shortest", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if arr == sorted(arr):\n            return 0\n        l = [arr[0]]\n        r = [arr[-1]]\n        for i in range(len(arr)):\n            if arr[i + 1] >= arr[i]:\n                l.append(arr[i + 1])\n            else:\n                break\n        for i in range(len(arr) - 1, -1, -1):\n            if arr[i] >= arr[i - 1]:\n                r.insert(0, arr[i - 1])\n            else:\n                break\n        res1 = len(arr) - len(r)\n        res2 = len(arr) - len(l)\n        j = 0\n        for i in range(len(l)):\n            while j < len(r) and l[i] > r[j]:\n                j += 1\n            if j == len(r):\n                j -= 1\n            p = i\n            while p < len(l) and l[p] <= r[j]:\n                p += 1\n            p -= 1            \n            return min(res1, res2, len(arr) - (p + 1 + len(r) - j))", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l,r = 0,len(arr) - 1\n        while l < r and arr[l] <= arr[l + 1]:\n            l += 1\n            \n        if l == len(arr) - 1:\n            return 0\n        while r >= 0 and arr[r] >= arr[r - 1]:\n            r -= 1\n            \n        toRemove = min(len(arr) - l - 1,r)\n        \n        for iL in range(l + 1):\n            if arr[iL] <= arr[r]:\n                toRemove = min(toRemove,r - iL - 1)\n            elif r < len(arr) - 1:\n                r += 1\n        return toRemove", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \n        def lowerbound(left, right, target):\n            while left < right:\n                mid = left + (right - left) // 2\n                \n                if arr[mid] == target:\n                    right = mid\n                elif arr[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid\n                \n            return left\n        \n        \n        N = len(arr)\n        \n        # find the longest ascending array on the left side\n        i = 0\n        while i + 1 < N and arr[i] <= arr[i+1]:\n            i += 1\n        \n        if i == N - 1:\n            # it is already in ascending order\n            return 0\n        \n        # find the longest ascending array on the right side\n        j = N - 1\n        while j - 1 >= 0 and arr[j] >= arr[j-1]:\n            j -= 1\n        \n        if j == 0:\n            # the entire array is in decending order\n            return N - 1\n        \n        # keep ascending array on right side or left side\n        result = min(N - (N - j), N - i -1)\n        \n        \n        # find the shortest unordered subarray in the middle \n        for k in range(i+1):\n            l = lowerbound(j, len(arr), arr[k])\n            result = min(result, l - (k + 1))\n        \n        \n        return result", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        if arr == sorted(arr):\n            return 0\n        l = [arr[0]]\n        r = [arr[-1]]\n        for i in range(len(arr)):\n            if arr[i + 1] >= arr[i]:\n                l.append(arr[i + 1])\n            else:\n                break\n        for i in range(len(arr) - 1, -1, -1):\n            if arr[i] >= arr[i - 1]:\n                r.insert(0, arr[i - 1])\n            else:\n                break\n        res1 = len(arr) - len(r)\n        res2 = len(arr) - len(l)\n        res3 = len(arr)\n        if l[-1] <= r[0]:\n            res3 = len(arr) - len(l) - len(r)\n        res = min(res1, res2, res3)\n        j = 0\n        for i in range(len(l)):\n            while j < len(r) and l[i] > r[j]:\n                j += 1\n            if j == len(r):\n                j -= 1\n            p = i\n            while p < len(l) and l[p] <= r[j]:\n                p += 1\n            p -= 1            \n            return min(res, len(arr) - (p + 1 + len(r) - j))", "class Solution:\n    def findLengthOfShortestSubarray(self, A):\n        # For each i, let's look at the best answer A[..i] + A[j..]\n        # This requires:\n        #   A[..i] monotone increasing;  (1)\n        #   A[j..] monotone increasing;  (2)\n        #   A[i] <= A[j]                 (3)\n        \n        # For each i, lets say the lowest (ie. best) such j = opt(i).\n        # It turns out that opt(i) is monotone increasing, so we can use\n        # two pointers.\n        \n        N = len(A)\n        j = N - 1\n        while j and A[j - 1] <= A[j]:\n            j -= 1\n        \n        ans = j\n        # j is lowest such that A[j..] is monotone increasing\n        for i in range(j):\n            if i and A[i-1] > A[i]:\n                break\n            while j < N and A[i] > A[j]:\n                j += 1\n            # Now, j = opt(i): ie., the lowest j such that\n            # all 3 conditions (1), (2), (3) above are satisified.\n            ans = min(ans, j - i - 1)\n        \n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        answer = n\n        curr = arr[0]\n        start = 1\n        while start < n:\n            if arr[start] >= curr:\n                curr = arr[start]\n                start += 1\n            else: break\n        start -= 1\n        if start == n-1:\n            return 0\n        curr = arr[n-1]\n        end = n-2\n        while end >= 0:\n            if arr[end] <= curr:\n                curr = arr[end]\n                end -= 1\n            else: break\n        end += 1\n        answer = min(answer, n-start-1, end)\n        l, r = 0, end\n        while r < n and l <= start:\n            if arr[l] <= arr[r]:\n                answer = min(answer, r-l-1)\n                l += 1\n            else:\n                r += 1\n        return answer \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr):\n        n = len(arr)\n        left, right = 0, n - 1\n        while left < n - 1 and arr[left] <= arr[left + 1]:\n            left += 1\n        if left == n - 1:\n            return 0\n        while right > 0 and arr[right - 1] <= arr[right]:\n            right -= 1\n        res = min(n - left - 1, right)\n        j = right\n        for i in range(left + 1):\n            while j <= n - 1 and arr[i] > arr[j]:\n                j += 1\n            if j <= n - 1:\n                res = min(res, j - i - 1)\n        return res\n                \n\n            \n\n\n                \n                \n            \n", "class Solution:\n    def findLengthOfShortestSubarray(self, a: List[int]) -> int:\n        n = len(a)\n        if all(a[i] >= a[i - 1] for i in range(1, n)):\n            return 0\n        d = {x: i + 1 for i, x in enumerate(sorted(set(a)))}\n        a = [d[x] for x in a]\n        last = [0] * (len(d) + 1)\n        prev = -1\n        for i, x in enumerate(a):\n            if x < prev: break\n            last[x] = i + 1\n            prev = x\n\n        for i in range(1, len(d) + 1):\n            if last[i] == 0:\n                last[i] = last[i - 1]\n\n        ans = last[-1]\n        prev = 1e100\n        for i, x in enumerate(a[::-1]):\n            if prev < x: break\n            ans = max(ans, i + 1 + last[x])\n            prev = x\n        return n - ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        N = len(arr)\n\n        left_idx = 0\n        while left_idx < N - 1 and arr[left_idx] <= arr[left_idx+1]:\n            left_idx += 1\n\n        if left_idx == N - 1:\n            return 0\n\n        right_idx = N - 1\n        while right_idx > 1 and arr[right_idx] >= arr[right_idx - 1]:\n            right_idx -= 1\n\n        r = min(N - 1 - left_idx, right_idx)\n\n        i = 0\n        j = right_idx \n        while i <= left_idx and j <= N - 1:\n            if arr[j] >= arr[i]:\n                r = min(r, j - i - 1)\n                i += 1\n            else:\n                j += 1\n        return r", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        inc_idx = 0\n        for i in range(1, len(arr)):\n            if arr[i] >= arr[i-1]:\n                inc_idx += 1\n            else:\n                break\n    \n        if inc_idx == len(arr) - 1:\n            return 0\n        \n        dec_idx = len(arr) - 1\n        for i in range(len(arr) - 2, -1, -1):\n            if arr[i] <= arr[i+1]:\n                dec_idx -= 1\n            else:\n                break\n        \n        l = self.helper(arr[:inc_idx+1], arr[dec_idx:])\n        return len(arr) - l\n        \n        \n    def helper(self, arr1: List[int], arr2: List[int]):\n        print((arr1, arr2))\n        i, j = 0, 0\n        l = 0\n        while i < len(arr1) and j < len(arr2):\n            while j < len(arr2) and arr1[i] > arr2[j]:\n                j += 1\n            if j == len(arr2):\n                break\n            \n            l = max(l, i + 1 + len(arr2) - j)\n            i += 1\n\n        return max(len(arr1), len(arr2), l)\n        \n", "# 1040\n\nclass Solution:\n  def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n    n = len(arr)\n    left_good = [True,]\n    right_good = [True,]\n    for i in range(1, n):\n      if arr[i] >= arr[i-1]:\n        left_good.append(True)\n      else:\n        break\n        \n    left_good.extend([False] * (n - len(left_good)))\n\n    for i in range(n-2, -1, -1):\n      if arr[i] <= arr[i+1]:\n        right_good.append(True)\n      else:\n        break\n        \n    right_good.extend([False] * (n - len(right_good)))\n    right_good.reverse()\n    \n    high = n\n    low = 0\n    \n    def enough(sz):\n      if sz == n:\n        return True\n      if sz == 0:\n        return left_good[n-1]\n      for begin in range(n):\n        end = begin + sz - 1\n        if end >= n:\n          return False\n        a = begin - 1\n        b = end + 1\n        if (a < 0 or left_good[a]) and (b == n or right_good[b]) and ((not 0 <= a < b < n) or (arr[a] <= arr[b])):\n          #print('found ', begin, sz)\n          return True\n        \n      return False\n    \n    #print(left_good, right_good)\n    \n    while low <= high:\n      cur = int((low + high) / 2) # low + (high - low) / 2\n      #print('trying', cur, enough(cur), low, high)\n      if enough(cur):\n        high = cur - 1\n      else:\n        low = cur + 1\n    \n    return low", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l = 0\n        r = len(arr)-1\n        while l < len(arr)-1 and arr[l+1] >= arr[l]:\n            l +=1\n        if l == len(arr)-1:\n            return 0\n        while r > 0 and arr[r-1] <= arr[r]:\n            r -=1\n        \n        res = min(len(arr)-l-1, r)\n        \n        i, j = 0, r\n        while i <= l and j < len(arr):\n            if arr[i] <= arr[j]:\n                res = min(res, j - i - 1)\n                i +=1\n            else:\n                j +=1\n                \n        return res\n", "class Solution:\n\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        # [1,2,3,10,4,2,3,5]\n        \n        r = len(arr) - 1 \n        while r >0 and arr[r] >= arr[r-1]:\n            r -= 1\n            \n        ret = r # worst case, remove all left\n        l = 0\n        \n        for l in range(len(arr)):\n            if l>0 and arr[l] < arr[l-1]:\n                break\n            if l == r:\n                r += 1\n            while r < len(arr) and arr[l] > arr[r] :\n                r +=1\n            \n\n            ret = min(ret, r-l-1)\n                \n            \n            \n        return ret\n            \n\n        \n\n        \n\n        \n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        l = 0\n        r = len(arr) - 1\n        while l < r and arr[l] <= arr[l + 1]:\n            l += 1\n        if l == r:\n            return 0\n        \n        while r > 0 and arr[r] >= arr[r - 1]:\n            r -= 1\n            \n        min_remove = min(len(arr) - l - 1, r)\n        \n        for i in range(l + 1):\n            if arr[i] <= arr[r]:\n                min_remove = min(min_remove, r - i - 1)\n            elif r < len(arr) - 1:\n                r += 1\n            else:\n                break\n                \n        return min_remove", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        inc_idx = 0\n        for i in range(1, len(arr)):\n            if arr[i] >= arr[i-1]:\n                inc_idx += 1\n            else:\n                break\n    \n        if inc_idx == len(arr) - 1:\n            return 0\n        \n        dec_idx = len(arr) - 1\n        for i in range(len(arr) - 2, -1, -1):\n            if arr[i] <= arr[i+1]:\n                dec_idx -= 1\n            else:\n                break\n        \n        l = self.helper(arr[:inc_idx+1], arr[dec_idx:])\n        return len(arr) - l\n        \n        \n    def helper(self, arr1: List[int], arr2: List[int]):\n        print((arr1, arr2))\n        i, j = 0, 0\n        l = 0\n        while i < len(arr1) and j < len(arr2):\n            while j < len(arr2) and arr1[i] > arr2[j]:\n                j += 1\n            if j == len(arr2):\n                break\n            \n            l = max(l, i + 1 + len(arr2) - j)\n            print((i, j, l))\n            i += 1\n\n        return max(len(arr1), len(arr2), l)\n        \n", "class Solution:\n    def findLengthOfShortestSubarray(self, a: List[int]) -> int:\n        n = len(a)\n        if all(a[i] >= a[i - 1] for i in range(1, n)):\n            return 0\n        d = {x: i + 1 for i, x in enumerate(sorted(set(a)))}\n        a = [d[x] for x in a]\n        last = [0] * (len(d) + 1)\n        prev = -1\n        for i, x in enumerate(a):\n            if x < prev: break\n            last[x] = i + 1\n            prev = x\n        # print(last)\n\n        for i in range(1, len(d) + 1):\n            if last[i] == 0:\n                last[i] = last[i - 1]\n\n        # print(a)\n        # print(last)\n        ans = last[-1]\n        prev = 1e100\n        for i, x in enumerate(a[::-1]):\n            if prev < x: break\n            print(prev, x, last[x], i)\n            ans = max(ans, i + 1 + last[x])\n            prev = x\n        return n - ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \n        n = len(arr)\n        \n        p1 = p2 = -1\n            \n        for i in range(1, n):\n            if arr[i] < arr[i - 1]:\n                \n                p2 = i\n                \n                if p1 == -1:\n                    p1 = i\n                    \n        if p1 == -1:\n            return 0\n        \n        \n        def chk(l):\n            \n            nonlocal p1\n            nonlocal p2\n            \n            # print (p1, p2)\n            \n            if l >= p2:\n                return True\n                                    \n            n = len(arr)\n            \n            for i in range(n):\n                                \n                if i > p1:\n                    return False\n                \n                if i + l >= n:\n                    return True\n                                \n                if i + l < p2:\n                    continue\n                \n                if arr[i - 1] <= arr[i + l]:\n                    return True\n                    \n            return False\n        \n        # print (chk(8))\n        \n        # return 0\n\n        l = 0\n        r = n\n        \n        while l < r:\n            \n            mid = (l + r) // 2\n            \n            if chk(mid):\n                r = mid\n            else:\n                l = mid + 1\n                \n        return l\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        \n        l = 0\n        r = n-1\n        ans = 0\n        \n        while l < n-1 and arr[l] <= arr[l+1]:\n            l+=1\n        if l == n-1:\n            return 0\n        \n        ans = n - l - 1\n        \n        while r >= l and arr[r] >= arr[r-1]:\n            r-=1\n              \n        if r == 0:\n            return n-1\n        ans = min(ans,r)\n        i = 0\n        j = r\n        \n        while i <= l and j < n:\n            if arr[i] <= arr[j]:\n                ans = min(ans, j-i-1)\n                i+=1\n            else:\n                j+=1\n                \n        return ans", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        i, j = 0, n - 1\n        while i < n - 1 and arr[i] <= arr[i + 1]:\n            i += 1\n        if i == n - 1: return 0 # sorted\n        while j > 0 and arr[j] >= arr[j - 1]:\n            j -= 1\n        if j == 0: return n - 1 # reversely sorted\n        \n        res = min(n - 1 - i, j) # leaving prefix, or suffix after removing\n        \n        # to merge prefix and suffix\n        # binary search also works here but worse time complexity:\n        # need to search each of prefix in suffix (or the other way)\n        # checking only end of prefix and head of suffix is not enough\n        for k in range(i + 1):\n            if arr[k] <= arr[j]:\n                res = min(res, j - k - 1)\n            elif j < n - 1:\n                j += 1\n            else:\n                break\n        return res", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        first, last = -1, -1\n        length = len(arr)\n        prev = float('-inf')\n        for i in range(length):\n            if arr[i] < prev:\n                first = i\n                break\n            prev = arr[i]\n        if first == -1:\n            return 0\n        after = float('inf')\n        for i in range(length - 1, -1, -1):\n            if arr[i] > after:\n                last = i\n                break\n            after = arr[i]\n            \n        def helper(size):\n            for i in range(length - size + 1):\n                if i <= first and i + size > last:\n                    if i + size == length or i == 0:\n                        return True\n                    if arr[i + size] >= arr[i - 1]:\n                        return True\n            return False\n            \n        low, high = 1, length - 1\n        res = float('inf')\n        while low <= high:\n            mid = low + (high - low) // 2\n            if helper(mid):\n                res = min(res, mid)\n                high = mid - 1\n            else:\n                low = mid + 1\n        return res", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        i = 0\n        pref = 1\n        while i<len(arr)-1:\n            if arr[i]<=arr[i+1]:\n                pref+=1\n            else:\n                break\n            i+=1\n        \n        j = len(arr)-1\n        suff = 1\n        while j>0:\n            if arr[j]>=arr[j-1]:\n                suff+=1\n            else:\n                break\n            j-=1\n        \n        ans = min(len(arr)-pref,len(arr)-suff)\n        pref = i\n        suff = j\n        i = 0\n        j = suff\n        while i<=pref and j<len(arr):\n            if arr[i]<=arr[j]:\n                ans = min(ans,j-i-1)\n                i+=1\n            elif arr[j]<arr[i]:\n                j+=1\n        # ans = min(ans,j-i-1)\n        return  max(0,ans)\n", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        \n        # 1 4 5 2 3 2 1 5 6 7\n        # can be removed only in 3 types \n        # last, middle, front\n        \n        #front - what is the longest sorted array in the suffix\n        #last - what is the longest sorted array in the prefix\n        #middle - find the prefix and sufix sorting then see if then can be merged else 0\n        \n        n = len(arr)\n        if n==1 or n==0:\n            return 0\n        front = 0\n        a = -1\n        b = -1\n        last = 0\n        middle = 0\n        c = 1\n        for i in range(1, n):\n            if arr[i]>=arr[i-1]:\n                c += 1\n            else :\n                a = i-1\n                front = c\n                break\n        if c == n:\n            a = n-1\n            front = c\n        c = 1\n        for i in range(n-1,1,-1):\n            if arr[i-1]<=arr[i]:\n                c += 1\n            else :\n                last = c\n                b = i\n                break\n        \n        if c == n:\n            b = 0\n            last = c\n        print((front, a, last, b))\n        if b !=-1 and a!= -1 :\n            for i in range(b,n):\n                if arr[a] <= arr[i]:\n                    middle = max(middle, front+(n-i))\n                print((1,a,i))\n            for i in range(0,a+1):\n                if arr[i] <= arr[b]:\n                    middle = max(middle, last+i+1)\n                    print((2,i, b))\n                    \n                    \n        return n-max(last,max(front,middle))\n", "from typing import List\n\n\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        # 1. formulate two non-decreasing arr\n        pre_len = 1\n        while pre_len < len(arr):\n            if arr[pre_len] < arr[pre_len - 1]:\n                break\n            pre_len += 1\n        arr_a = arr[:pre_len]\n        if len(arr_a) == len(arr):\n            return 0\n\n        arr_b = [arr[-1]]\n        for j in range(len(arr) - 2, -1, -1):\n            if arr[j] <= arr[j + 1]:\n                arr_b.insert(0, arr[j])\n            else:\n                break\n        # print(arr_a, arr_b)\n\n        # 2. Loop through arr_a to find the ans\n        ans = len(arr) - 1\n        for i in range(len(arr_a)):\n            j = self.binary_search(arr_b, arr_a[i])\n            cut_length = len(arr) - (i + 1) - (len(arr_b) - j)\n            ans = min(ans, cut_length)\n        ans = min(ans, len(arr) - len(arr_a))\n        ans = min(ans, len(arr) - len(arr_b))\n        return ans\n\n    # need to return the index i such that arr[i] >= num\n    def binary_search(self, arr, num):\n        low = 0\n        high = len(arr) - 1\n        ans = len(arr)\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] >= num:\n                ans = min(ans, mid)\n                high = mid - 1\n            else:\n                low = mid + 1\n        return ans\n\n\n# leetcode submit region end(Prohibit modification and deletion)\n\ndef __starting_point():\n    solution = Solution()\n    assert (solution.findLengthOfShortestSubarray([1, 2, 3, 10, 4, 2, 3, 5]) == 3)\n    assert (solution.findLengthOfShortestSubarray([5, 4, 3, 2, 1]) == 4)\n    assert (solution.findLengthOfShortestSubarray([1, 2, 3]) == 0)\n    assert (solution.findLengthOfShortestSubarray([13, 0, 14, 7, 18, 18, 18, 16, 8, 15, 20]) == 8)\n    assert (solution.findLengthOfShortestSubarray([16, 10, 0, 3, 22, 1, 14, 7, 1, 12, 15]) == 8)\n\n__starting_point()", "class Solution:\n\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        A=arr\n        N = len(A)\n        j = N-1\n        while j >= 1 and A[j-1] <= A[j]:\n            j -= 1\n        res = j\n        for i in range(N):\n            if i >= j or (i > 0 and A[i] < A[i-1]): \n                break\n            while j < N and A[i] > A[j]:    \n                j += 1\n            res = min(res, j-i-1)\n        return res\n\n\n        \n", "class Solution:\n\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        # [1,2,3,10,4,2,3,5]\n        \n        r = len(arr) - 1 \n        while r >0 and arr[r] >= arr[r-1]:\n            r -= 1\n            \n        ret = r # worst case, remove all left\n        l = 0\n        \n        for l in range(len(arr)):\n            if l>0 and arr[l] < arr[l-1]:\n                break\n            if l >= r:\n                break\n            while r < len(arr) and arr[l] > arr[r] :\n                r +=1\n            print((l,r))\n\n            ret = min(ret, r-l-1)\n                \n            \n            \n        return ret\n            \n\n        \n\n        \n\n        \n        \n", "from sortedcontainers import SortedList\n\nclass Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        last = -float('inf')\n        \n        sl = SortedList()\n        \n        for i, n in enumerate(arr):\n            if n < last: break\n            \n            sl.add(n)\n            \n            last = n\n                    \n        ans = len(arr) - len(sl)\n        last = float('inf')\n        \n        for i in range(len(arr)-1, 0, -1):\n            if arr[i] > last: break\n            \n            last = arr[i]\n            \n            sl_idx = sl.bisect_right(arr[i])\n                                    \n            ans = min(ans, i - sl_idx)\n        \n        return max(0, ans)", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        left_idx, right_idx = 0, n - 1\n        # edge case\n        # left side\n        while left_idx < n - 1 and arr[left_idx] <= arr[left_idx + 1]:\n            left_idx += 1    \n        # right side \n        while right_idx > 0 and arr[right_idx - 1] <= arr[right_idx]:\n            right_idx -= 1\n        nums_to_rm = min(n - left_idx - 1, right_idx)\n        \n        # print(nums_to_rm)\n        \n        # general case \n        for curr_idx in range(left_idx + 1):\n            if arr[curr_idx] <= arr[right_idx]: \n                nums_to_rm = min(nums_to_rm, max(0, right_idx - curr_idx - 1))\n                # print(nums_to_rm)\n            else:\n                # arr[curr_idx] > arr[right_idx]\n                if right_idx < n - 1:\n                    right_idx += 1\n                else:\n                    break\n        # [1,2,3,10,4,2,3,5]\n        # [5,4,3,2,1]\n        # [1]\n        return nums_to_rm", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n      \n      pre = [True]\n      pst = [True]\n      for i in range(1, len(arr)):\n        if pre[-1] and arr[i]>=arr[i-1]:\n          pre.append(True)\n        else: pre.append(False)\n        \n        if pst[-1] and arr[len(arr)-i-1]<=arr[len(arr)-i]:\n          pst.append(True)\n        else: pst.append(False)\n      \n      \n      pst = pst[::-1]\n      # print (pre)\n      # print (pst)\n      \n      def isPoss(slen):\n        for i in range(len(arr)-slen+1):\n          j = i+slen\n          \n          if not i:\n            if pst[j]: return True\n          elif j>len(arr)-1:\n            if pre[i-1]: return True\n          else:\n            if pre[i-1] and pst[j] and arr[i-1]<=arr[j]:\n              return True\n          \n        return False\n            \n      # print (isPoss(1))\n      l, r = 0, len(arr)\n      res = r\n      while l<=r:\n        m = l + (r-l)//2\n        if isPoss(m):\n          res = min(m, res)\n          r = m - 1\n        else:\n          l = m + 1\n      return res", "class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        # [start_f, end_f] is the first sorting part\n        start_f, end_f = 0, 0\n        while end_f+1 < len(arr):\n            if arr[end_f+1] >= arr[end_f]:\n                end_f += 1\n            else:\n                break\n        # the entire array is sorted\n        if end_f == len(arr)-1:\n            return 0\n        start_b, end_b = len(arr)-1, len(arr)-1\n        # the last part is smaller than first part\n        if arr[-1] < arr[end_f]:\n            start_b = len(arr)\n        else:\n            while start_b-1 >= 0 and arr[start_b-1] >= arr[end_f]:\n                if arr[start_b-1] <= arr[start_b]:\n                    start_b -= 1\n                else:\n                    break\n        print((start_f, end_f, start_b, end_b))\n        start, end = end_f+1, start_b-1\n        ans = end-start+1\n        while start >= 0:\n            start -= 1\n            while start == 0 or arr[end] >= arr[start-1]:\n                if end == len(arr)-1 or arr[end] <= arr[end+1]:\n                    end -= 1\n                    ans = min(ans, end-start+1)\n                else:\n                    break\n        return ans\n        \n"]