["class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         return self.singleNonDuplicateUtil(nums, 0, len(nums)-1)\n         \n     def singleNonDuplicateUtil(self, nums, l, r):\n         if l < r:\n             mid = int((l + r) * 0.5)\n \n             if mid-1>=0 and nums[mid-1]!=nums[mid]:\n                 mid=mid-1\n \n             if (mid - l + 1) % 2 == 0:\n                 l = mid + 1\n             else:\n                 r = mid\n \n \n             return self.singleNonDuplicateUtil(nums, l, r)\n         else:\n             return nums[l]", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         res = 0\n         for i in nums:\n             res ^= i\n         return res\n", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         count = len(nums)\n         lo = 0\n         hi = int(count/2)\n         while lo < hi:\n             m = int((lo + hi)/2)\n             if nums[2*m] != nums[2*m+1]:\n                 hi = m\n             else:\n                 lo = m + 1\n         return nums[2*lo]\n", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         i, j = 0, len(nums)-1\n         while i < j:\n             mid = i + (j - i) // 2\n             if mid % 2 == 1:\n                 mid -= 1\n             if nums[mid] == nums[mid + 1]:\n                 i = mid + 2\n             else:\n                 j = mid\n         return nums[i]", "class Solution:\n     def singleNonDuplicate(self, nums):\n         if len(nums)==1:\n             return nums[0]\n         flag=0\n         for i in range(len(nums)):\n             if flag==0:\n                 if i==len(nums)-1:\n                     return nums[i]\n                 if nums[i]==nums[i+1]:\n                     flag=1\n                 else:\n                     return nums[i]\n             else:\n                 flag=0\n                 continue", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         # # O(N) time complexity O(1) space using bit XOR manipulation\n         # x = nums[0]\n         # for num in nums[1:]:\n         #     x = x^num\n         # return x\n         \n         \n         # O(logN) runtime and O(1) Space using cool binary search (it's sorted)\n         # focuses on the index\n         \n         left = 0\n         if len(nums) == 1:\n             return nums[left]\n         \n         right = len(nums) - 1\n         \n         while left < right:\n             mid = left + (right - left) // 2\n             \n             if mid % 2 == 1:\n                 mid -= 1\n             \n             if nums[mid + 1] == nums[mid]:\n                 left = mid + 2\n             \n             else:\n                 right = mid\n         \n         return nums[left]\n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         #return sum(set(nums))*2-sum(nums)\n         '''\n         one = 0\n         for num in nums:\n             one = (~one&num)|(one&~num)\n         return one\n         '''\n         l, r = 0, len(nums)-1\n         while l < r:\n             mid = (l+r)//2\n             if nums[mid] == nums[mid-1]:\n                 if (r-mid)%2 == 1:\n                     l = mid + 1\n                 else:\n                     r = mid - 2\n             elif nums[mid] == nums[mid+1]:\n                 if (mid-l)%2 == 1:\n                     r = mid - 1\n                 else:\n                     l = mid + 2\n             else:\n                 return nums[mid]\n         return nums[l]\n", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         while nums:\n             if len(nums)>1 and nums[0]==nums[1] :\n                 nums.pop(0)\n                 nums.pop(0)\n             else:\n                 return nums[0]", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         while nums:\n             if len(nums)>1 and nums[0]==nums[1] :\n                 nums.pop(0)\n                 nums.pop(0)\n             else:\n                 return nums[0]\n             \n", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         return 2*sum(set(nums))-sum(nums) #arrays don't usually present themselves sorted for binary search in real life\n", "class Solution:\n     def singleNonDuplicate(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 1:\n             return nums[0]\n         startIndex = 0\n         endIndex = len(nums) - 1 \n         while startIndex < endIndex:\n             midIndex = (endIndex - startIndex)//2 + startIndex\n             midValue = nums[midIndex]\n             leftValue = nums[midIndex - 1] if midIndex - 1 >= 0 else None\n             rightValue = nums[midIndex + 1] if midIndex + 1 < len(nums) else None\n             \n             numLeftUnknowns = midIndex\n             numRightUnknowns = len(nums) - 1 - midIndex\n             if (leftValue != midValue and rightValue != midValue):\n                 return midValue\n             elif leftValue == midValue:\n                 numLeftUnknowns -= 1\n             else:\n                 numRightUnknowns -= 1\n                 \n             if numLeftUnknowns % 2 != 0:\n                 endIndex = midIndex - 1\n             else:\n                 startIndex = midIndex + 1\n             \n         return nums[startIndex]"]