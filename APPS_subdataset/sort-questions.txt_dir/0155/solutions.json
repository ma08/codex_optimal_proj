["class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        dp = [1] * (len(arr) + 1)\n        stack = []\n        for i, n in enumerate(arr + [1000000]):\n            while stack and arr[stack[-1]] < n:\n                same_height_idx = [stack.pop()]\n                while stack and arr[stack[-1]] == arr[same_height_idx[0]]:\n                    same_height_idx.append(stack.pop())\n                for j in same_height_idx:\n                    # jump to left\n                    if i - j <= d:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    # jump to right\n                    if stack and j - stack[-1] <= d:\n                        dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n            stack.append(i)\n        return max(dp[:-1])", "class Solution:\n    def maxJumps(self, nums: List[int], d: int) -> int:\n        # to_delete_index = set()\n        # for i in range(1, len(arr)):\n        #     if arr[i] == arr[i - 1]:\n        #         to_delete_index.add(i)\n        # nums = []\n        # for i in range(0, len(arr)):\n        #     if i not in to_delete_index:\n        #         nums.append(arr[i])\n        nums.append(math.inf) # \u8ba9\u6240\u6709\u5143\u7d20\u90fd\u51fa\u6808\n        dp = [1] * len(nums)\n        stack = [] # \u5355\u8c03\u9012\u51cf\u6808\n        for i, cur in enumerate(nums):\n            while stack and nums[stack[-1]] < cur:\n                poped_same_val = [stack.pop()]\n                while stack and nums[stack[-1]] == nums[poped_same_val[0]]:\n                    poped_same_val.append(stack.pop())\n                for poped in poped_same_val:\n                    if i - poped <= d: # i\u662fpoped\u7684\u53f3\u4fa7\u7b2c\u4e00\u4e2a\u76f8\u7b49\u6216\u66f4\u5927\u7684\u5143\u7d20\n                        dp[i] = max(dp[i], dp[poped] + 1)\n                    if stack and poped - stack[-1] <= d: # stack[-1]\u662fpoped\u7684\u5de6\u4fa7\u7b2c\u4e00\u4e2a\u66f4\u5927\u7684\u5143\u7d20\n                        left_first_big_of_poped = stack[-1]\n                        dp[left_first_big_of_poped] = max(dp[left_first_big_of_poped], dp[poped] + 1)\n            stack.append(i)\n            # print(i, dp, stack)\n        return max(dp[:-1]) # \u53bb\u6389\u6700\u540e\u4e00\u4e2ainf\u5728\u7684\u4f4d\u7f6e\u7684dp\u503c", "class Solution: # top-down dp\n    # Time complexity O(ND)\n    # Space complexity O(N) for dp\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        dp = [1] * (n+1)\n        stack = []\n        \n        for i, a in enumerate(arr + [float('inf')]):\n            while stack and arr[stack[-1]] < a:\n                L = [stack.pop()]\n                while stack and arr[stack[-1]] == arr[L[0]]:\n                    L.append(stack.pop())\n                for j in L:\n                    if i - j<=d:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    if stack and j - stack[-1] <=d:\n                        dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n            stack.append(i)\n        return max(dp[:-1])    ", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        res = 0\n        visited = {}\n        \n        def dfs(i):\n            if i in visited:\n                return visited[i]\n            \n            step = 1\n            \n            i_right = i + 1\n            while i_right < len(arr) and i_right - i <= d:\n                if arr[i_right] >= arr[i]:\n                    break\n                step = max(step, 1+dfs(i_right))\n                i_right += 1\n            \n            i_left = i - 1\n            while i_left >= 0 and i - i_left <= d:\n                if arr[i_left] >= arr[i]:\n                    break\n                step = max(step, 1+dfs(i_left))\n                i_left -= 1\n            visited[i] = step\n            return step\n        \n        \n        for i in range(len(arr)):\n            res = max(res, dfs(i))\n        \n        return res\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        # @lru_cache(None)\n        cache = {}\n        def f(i):\n            if i in cache:\n                return cache[i]\n            left = True\n            right = True\n            ret = 1\n            for step in range(1,d+1):\n                m = i - step\n                if 0 <= m < len(arr) and arr[m] < arr[i] and left:\n                    ret = max(ret,f(m)+1)\n                else:\n                    left = False\n                m = i + step\n                if 0 <= m < len(arr) and arr[m] < arr[i] and right:\n                    ret = max(ret,f(m)+1)\n                else:\n                    right = False\n                \n                if (not left) and (not right):\n                    break\n            cache[i] = ret\n            return ret\n       \n        mm = 0\n        for i in range(len(arr)):\n            fi = f(i) if i not in cache else cache[i]\n            mm = max(f(i),mm)\n        \n        return mm\n", "\n\nclass Solution:\n    # O(n x d) time, O(n) space\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        cache = {}\n        def find_max_jumps(i):\n            if i in cache:\n                return cache[i]\n            \n            max_jumps = 1\n            for dr in [1, -1]:\n                for r in range(1, d + 1):\n                    if not (0 <= i + dr * r < n and arr[i + dr * r] < arr[i]):\n                        break\n                    max_jumps = max(max_jumps, 1 + find_max_jumps(i + dr * r))\n            \n            cache[i] = max_jumps\n            return max_jumps\n        \n        result = 1\n        for i in range(n):\n            result = max(result, find_max_jumps(i))\n        return result\n\n\nclass Solution111:\n    \n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        n = len(arr)\n        res = [0] * n\n        \n        def dp(i):\n            if res[i]: return res[i]\n            res[i] = 1\n            for di in [-1, 1]:\n                for j in range(i+di, i+di+d*di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]):\n                        break \n                    res[i] = max(res[i], dp(j)+1)\n            return res[i]\n        \n        return max(map(dp, range(n)))", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        @lru_cache(None)\n        def dfs(index):\n            res = 0\n            \n            for direction in [-1, 1]:\n                for jump in range(1, d + 1):\n                    j = index + direction*jump\n                    if 0 <= j < len(arr) and arr[index] > arr[j]:\n                        res = max(res, dfs(j))\n                    else:\n                        break\n            \n            return res + 1\n        \n        return max(dfs(i) for i in range(len(arr)))\n", "from typing import List\n\n\nclass Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n\n    result = 0\n    mapping = dict()\n    for index, value in enumerate(arr):\n      if index not in mapping:\n        mapping[index] = set()\n      for dd in range(1, d + 1):\n        if index + dd >= len(arr):\n          break\n\n        if arr[index + dd] < arr[index]:\n          mapping[index].add(index + dd)\n        else:\n          break\n\n      for dd in range(1, d + 1):\n        if index - dd < 0:\n          break\n\n        if arr[index - dd] < arr[index]:\n          mapping[index].add(index - dd)\n        else:\n          break\n      pass\n\n    cache = dict()\n\n    def dfs(cache, mapping, root):\n\n      if root in cache:\n        return cache[root]\n\n      if root not in mapping:\n        return 0\n\n      result = 0\n      for next in mapping[root]:\n        result = max(result, dfs(cache, mapping, next) + 1)\n        pass\n\n      cache[root] = result\n      return result\n\n    result = 1\n    for i in range(len(arr)):\n      result = max(result, dfs(cache, mapping, i) + 1)\n\n    return result\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        memo = [0] * n\n        \n        def dfs(start):\n            if start < 0 or start >= n:\n                return 0\n            \n            if memo[start] > 0:\n                return memo[start]\n            \n            visited[start] = 1\n            ret = 1\n            for i in range(start-1, max(0, start - d) - 1, -1):\n                if arr[i] >= arr[start]:\n                    break\n                if visited[i]:\n                    continue\n                ret = max(ret, dfs(i)+1)    \n            for j in range(start+1, min(start + d, n-1) + 1):                \n                if arr[j] >= arr[start]:\n                    break\n                if visited[j]:\n                    continue\n                ret = max(ret, dfs(j)+1)   \n                \n            visited[start] = 0\n            memo[start] = ret\n            return ret\n        \n        ret = 1\n        visited = [0] * n\n        for i in range(n):            \n            ret = max(dfs(i), ret)   \n        return ret", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        def dfs(i):\n            if i in cache:\n                return cache[i]\n            cache[i] = 1\n            for neigh in g[i]:\n                cache[i] = max(cache[i], 1 + dfs(neigh))\n            return cache[i]\n        \n        g = defaultdict(set)\n        for i in range(len(arr)):\n            for x in range(1, d+1):\n                if i-x >= 0 and arr[i-x] < arr[i]:\n                    g[i].add(i-x)\n                else:\n                    break\n            for x in range(1, d+1):\n                if i+x < len(arr) and arr[i+x] < arr[i]:\n                    g[i].add(i+x)\n                else:\n                    break\n        cache = {}\n        for i in range(len(arr)):\n            dfs(i)\n        return max(cache.values())\n        '''\n        mjump = 0\n        for i, x in enumerate(arr):\n            top = i\n            bottom = i\n            while top+1 < len(arr) and x>arr[top+1]:\n                top += 1\n            while bottom-1 >= 0 and x>arr[bottom-1]:\n                bottom -=1\n            newarr = arr[bottom:top+1]\n            \n            jump =[x]\n            value = x-1\n            while value>=min(newarr):\n                if value < jump[-1]-d:\n                    break\n                elif value in newarr:\n                    jump.append(value)\n                value -= 1\n            \n            print(jump)\n            mjump = max(mjump, len(jump))\n        \n        return mjump\n        '''\n                \n            \n            \n", "class Solution:\n    def helper(self, idx):\n        if self.dp[idx] != float('inf'):\n            return self.dp[idx]\n\n        max_step = 1\n        # to left\n        for c in range(idx - 1, max(0, idx - self.d) - 1, -1):\n            if self.arr[idx] <= self.arr[c]:\n                break\n\n            max_step = max(self.helper(c) + 1, max_step)\n\n        # to right\n        for c in range(idx + 1, min(self.n, idx + self.d + 1)):\n            if self.arr[idx] <= self.arr[c]:\n                break\n\n            max_step = max(self.helper(c) + 1, max_step)\n\n        self.dp[idx] = max_step\n        return max_step\n\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        self.n = len(arr)\n        self.d = d\n        self.arr = arr\n        self.dp = [float('inf')] * self.n\n\n        self.trans = defaultdict(list)\n\n        max_ = 0\n        for i in range(self.n):\n            max_ = max(self.helper(i), max_)\n\n        return max_", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        memo = {}\n        \n        \n        def dfs(start):\n            if start < 0 or start >= n:\n                return 0\n            \n            if start in memo:\n                return memo[start]\n            \n            visited[start] = 1\n            ret = 1\n            for i in range(start-1, max(0, start - d) - 1, -1):\n                if arr[i] >= arr[start]:\n                    break\n                if visited[i]:\n                    continue\n                ret = max(ret, dfs(i)+1)    \n            for j in range(start+1, min(start + d, n-1) + 1):                \n                if arr[j] >= arr[start]:\n                    break\n                if visited[j]:\n                    continue\n                ret = max(ret, dfs(j)+1)   \n                \n            visited[start] = 0\n            memo[start] = ret\n            return ret\n        \n        ret = 1\n        visited = [0] * n\n        for i in range(n):            \n            ret = max(dfs(i), ret)   \n        return ret", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        memo = {}\n        \n        def dfs(start):\n            if start < 0 or start >= n:\n                return 0\n            \n            if start in memo:\n                return memo[start]\n            \n            visited[start] = 1\n            ret = 1\n            for i in range(start-1, max(0, start - d) - 1, -1):\n                if arr[i] >= arr[start]:\n                    break\n                if visited[i]:\n                    continue\n                ret = max(ret, dfs(i)+1)    \n            for j in range(start+1, min(start + d, n-1) + 1):                \n                if arr[j] >= arr[start]:\n                    break\n                if visited[j]:\n                    continue\n                ret = max(ret, dfs(j)+1)   \n                \n            visited[start] = 0\n            memo[start] = ret\n            return ret\n        \n        ret = 1\n        visited = [0] * n\n        for i in range(n):            \n            ret = max(dfs(i), ret)   \n        return ret", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        \n        graph = collections.defaultdict(list)\n        \n        st = []\n        for i in range(n):\n            while st and arr[st[-1]] < arr[i]:\n                j = st.pop()\n                if i - j <= d:\n                    graph[j].append(i)\n            st.append(i)\n        \n        st = []\n        for i in range(n-1, -1, -1):\n            while st and arr[st[-1]] < arr[i]:\n                j = st.pop()\n                if j - i <= d:\n                    graph[j].append(i)\n            st.append(i)\n        \n        visited = {}\n        def dfs(i):\n            if i in visited:\n                return visited[i]\n            step = 1\n            for j in graph[i]:\n                step = max(step, 1+dfs(j))\n            visited[i] = step\n            return step\n        \n        res = 0\n        for i in range(n):\n            res = max(res, dfs(i))\n                \n        return res\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        def helper(arr,index,d,memo):\n            if arr[index] < 0 or not (0 <= index < len(arr)):\n                return 0\n            if index in memo:\n                return memo[index]\n            left_visited = 0\n            right_visited = 0\n            arr[index] = -arr[index]\n            for i in range(index+1,index+d+1):\n                # if p:\n                #     pass\n                #     # print(f'{index}, {i}')\n                if i >= len(arr):\n                    break\n                if abs(arr[i]) >= abs(arr[index]):\n                    break\n                if arr[i] < 0:\n                    continue\n                # if p:\n                #     print(f'using index-{index},{i}')\n                left_visited = max(left_visited,helper(arr,i,d,memo))\n            \n            for j in range(index-1,index-d-1,-1):\n                # if p:\n                #     pass\n                    # print(f'{index}, {j}')\n                if j < 0:\n                    break\n                if abs(arr[j]) >= abs(arr[index]):\n                    break\n                if arr[j] < 0:\n                    continue\n                right_visited = max(right_visited,helper(arr,j,d,memo))\n            arr[index] = -arr[index]\n            # if p:\n            #     # pass\n            #     print(f'{index}--{left_visited},{right_visited}')\n            memo[index] = 1 + max(left_visited,right_visited)\n            return memo[index]\n        \n        \n        max_visited = 1\n        p = False\n        memo = {}\n        for index in range(len(arr)):\n            # if index == 2:\n                # p = True\n            visited = helper(arr,index,d,memo)\n            # print(f'from {index} max is {visited}')\n            max_visited = max(visited,max_visited)\n        \n        return max_visited\n", "class Solution:\n    from collections import deque\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        q=deque()\n        n=len(arr)\n        dp=[-1]*n\n        \n        def solve(node):\n            if node<0 or node>=n:\n                return -1\n            \n            if dp[node]!=-1:\n                return dp[node]\n            \n            ans=0\n            for i in range(1,d+1):\n                if node+i>=n or arr[node+i]>=arr[node]:\n                    break\n                #print(node,i+node)\n                ans=max(ans,solve(i+node))\n            \n            for i in range(1,d+1):\n                if node-i<0 or arr[node-i]>=arr[node]:\n                    break\n                #print(node,-i+node)\n                ans=max(ans,solve(node-i))\n            \n            dp[node]=1+ans\n            \n            return dp[node]\n        \n        for i in range(n):\n            solve(i)\n        \n        #print(dp)\n        return max(dp)\n", "class Solution:\n    def maxJumps(self, lst: List[int], d: int) -> int:\n        \n        \n        \n        def Ab(i,d,X):\n            if i<0 or i>= len(lst):\n                return -1\n            \n            if X<=lst[i]:\n                return None\n            \n            if dp[i] != -1:\n                return dp[i]\n            m = 1\n            for j in range(1,d+1):\n                a = 0\n                a = Ab(i-j,d,lst[i])\n                if a == None:\n                    break                \n                m = max(m,1+a)\n                              \n            for j in range(1,d+1):\n                b = 0\n                b = Ab(i+j,d,lst[i])\n                if b == None:\n                    break                \n                m = max(m,1+b)\n            dp[i] = m\n            return dp[i]\n        dp = [-1 for i in lst]\n        for i in range(len(lst)-1,-1,-1):\n            Ab(i,d,sys.maxsize)\n        return max(dp)", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        ans = [1] * len(arr)\n        \n        def dp(i):\n            nonlocal ans, arr, d\n            if ans[i] != 1:\n                return ans[i]\n            for dr in [-1, 1]:\n                for k in range(i, i + d * dr + dr, dr):\n                    if k < 0 or k == i:\n                        continue\n                    if k > len(arr) - 1 or arr[k] >= arr[i]:\n                        break\n                    ans[i] = max(ans[i], 1 + dp(k))\n            return ans[i]\n        \n        for i in range(len(arr)):\n            dp(i)\n        return max(ans)\n                \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        mem = [0] * len(arr)\n        \n        def dfs(i):\n            if mem[i]:\n                return mem[i]\n            num = 1\n            \n            j = i+1\n            while j in range(i+1, min(len(arr), i+d+1)) and arr[j] < arr[i]:\n                num = max(num, dfs(j) + 1)\n                j += 1\n            \n            j = i-1\n            while j in range(max(0, i-d), i) and arr[j] < arr[i]:\n                num = max(num, dfs(j) + 1)\n                j -= 1\n                \n            mem[i] = num   \n            return mem[i]\n        \n        res = 0\n        for i in range(len(arr)):\n            dfs(i)\n            res = max(res, dfs(i) + 1)\n            \n        return max(mem)", "import collections\n\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        outEdges = {}\n        inEdges = {}\n        \n        for idx, height in enumerate(arr):\n            \n            jumpRangeRight = list(range(idx+1, min(len(arr), idx+d+1)))\n            jumpRangeLeft = list(range(idx-1, max(0, idx - d) - 1, -1))\n            \n            for jumpRange in [jumpRangeLeft, jumpRangeRight]:\n                for jumpIdx in jumpRange:\n                    if arr[jumpIdx] >= arr[idx]:\n                        break\n\n                    if idx not in outEdges:\n                        outEdges[idx] = set()\n                    outEdges[idx].add(jumpIdx)\n\n                    if jumpIdx not in inEdges:\n                        inEdges[jumpIdx] = set()\n                    inEdges[jumpIdx].add(idx)\n        \n        noInEdges = collections.deque()\n        for idx in range(len(arr)):\n            if idx not in inEdges:\n                noInEdges.append(idx)\n        \n        topologicalOrder = collections.deque()\n        while noInEdges:\n            idx = noInEdges.pop()\n            topologicalOrder.append(idx)\n            if idx not in outEdges:\n                continue\n            for jumpIdx in outEdges[idx]:\n                inEdges[jumpIdx].remove(idx)\n                if not inEdges[jumpIdx]:\n                    noInEdges.append(jumpIdx)\n        \n        maxJumps = 1\n        jumpCount = [1] * len(arr)\n        for idx in topologicalOrder:\n            \n            if idx not in outEdges:\n                continue\n            \n            for jumpIdx in outEdges[idx]:\n                jumpCount[jumpIdx] = max(jumpCount[idx] + 1, jumpCount[jumpIdx])\n                maxJumps = max(jumpCount[jumpIdx], maxJumps)\n                \n        return maxJumps\n        \n    def maxJumpsBfs(self, arr: List[int], d: int) -> int:\n        bfs = collections.deque()\n        \n        for idx in range(len(arr)):\n            bfs.append((idx, 1))\n        \n        stepCount = {}\n        maxSteps = 0\n        \n        while bfs:\n            idx, steps = bfs.popleft()\n\n            # Already found more steps to this index.\n            if idx in stepCount and steps <= stepCount[idx]:\n                continue \n            stepCount[idx] = steps\n\n            maxSteps = max(steps, maxSteps)\n\n            # Process jumps to the right\n            for jumpIdx in range(idx+1, min(len(arr), idx+d+1)):\n                # Can't jump past taller buildings, break loop\n                if arr[jumpIdx] >= arr[idx]:\n                    break\n                    \n                # Explore this jump\n                bfs.append((jumpIdx, steps+1))\n\n            # Process jumps to the left\n            for jumpIdx in range(idx-1, max(0, idx-d) -1, -1):\n                # Can't jump past taller buildings, break loop\n                if arr[jumpIdx] >= arr[idx]:\n                    break\n\n                # Search the next step\n                bfs.append((jumpIdx, steps+1))\n            \n        return maxSteps\n                \n", "import collections\n\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        outEdges = {}\n        inEdges = {}\n        \n        for idx, height in enumerate(arr):\n            \n            jumpRangeRight = list(range(idx+1, min(len(arr), idx+d+1)))\n            jumpRangeLeft = list(range(idx-1, max(0, idx - d) - 1, -1))\n            \n            for jumpRange in [jumpRangeLeft, jumpRangeRight]:\n                for jumpIdx in jumpRange:\n                    if arr[jumpIdx] >= arr[idx]:\n                        break\n\n                    if idx not in outEdges:\n                        outEdges[idx] = set()\n                    outEdges[idx].add(jumpIdx)\n\n                    if jumpIdx not in inEdges:\n                        inEdges[jumpIdx] = set()\n                    inEdges[jumpIdx].add(idx)\n        \n        noInEdges = collections.deque()\n        for idx in range(len(arr)):\n            if idx not in inEdges:\n                noInEdges.append(idx)\n        \n        topologicalOrder = []\n        while noInEdges:\n            idx = noInEdges.pop()\n            topologicalOrder.append(idx)\n            if idx not in outEdges:\n                continue\n            for jumpIdx in outEdges[idx]:\n                inEdges[jumpIdx].remove(idx)\n                if not inEdges[jumpIdx]:\n                    noInEdges.append(jumpIdx)\n        \n        maxJumps = 1\n        jumpCount = [1] * len(arr)\n        for idx in topologicalOrder:\n            \n            if idx not in outEdges:\n                continue\n            \n            for jumpIdx in outEdges[idx]:\n                jumpCount[jumpIdx] = max(jumpCount[idx] + 1, jumpCount[jumpIdx])\n                maxJumps = max(jumpCount[jumpIdx], maxJumps)\n                \n        return maxJumps\n        \n    def maxJumpsBfs(self, arr: List[int], d: int) -> int:\n        bfs = collections.deque()\n        \n        for idx in range(len(arr)):\n            bfs.append((idx, 1))\n        \n        stepCount = {}\n        maxSteps = 0\n        \n        while bfs:\n            idx, steps = bfs.popleft()\n\n            # Already found more steps to this index.\n            if idx in stepCount and steps <= stepCount[idx]:\n                continue \n            stepCount[idx] = steps\n\n            maxSteps = max(steps, maxSteps)\n\n            # Process jumps to the right\n            for jumpIdx in range(idx+1, min(len(arr), idx+d+1)):\n                # Can't jump past taller buildings, break loop\n                if arr[jumpIdx] >= arr[idx]:\n                    break\n                    \n                # Explore this jump\n                bfs.append((jumpIdx, steps+1))\n\n            # Process jumps to the left\n            for jumpIdx in range(idx-1, max(0, idx-d) -1, -1):\n                # Can't jump past taller buildings, break loop\n                if arr[jumpIdx] >= arr[idx]:\n                    break\n\n                # Search the next step\n                bfs.append((jumpIdx, steps+1))\n            \n        return maxSteps\n                \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        result = 1\n        N = len(arr)\n        cache = {}\n        def helper(i : int) -> int:\n            if i in cache:\n                return cache[i]\n            result = 1\n            if ((i == 0 or arr[i] <= arr[i - 1]) and\n                (i == N - 1 or arr[i] <= arr[i + 1])):\n                cache[i] = result\n                return cache[i]\n            j = i - 1\n            while j >= 0 and j >= i - d and arr[j] < arr[i]:\n                cur = helper(j)\n                result = max(result, cur + 1)\n                j = j - 1\n            j = i + 1\n            while j < N and j <= i + d and arr[j] < arr[i]:\n                cur = helper(j)\n                result = max(result, cur + 1)\n                j = j + 1\n            cache[i] = result\n            return cache[i]\n        \n        for i in range(N):\n            cur = helper(i)\n            result = max(cur, result)\n        return result", "import collections\n\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        outEdges = {}\n        inEdges = {}\n        \n        for idx, height in enumerate(arr):\n            \n            jumpRangeRight = list(range(idx+1, min(len(arr), idx+d+1)))\n            jumpRangeLeft = list(range(idx-1, max(0, idx - d) - 1, -1))\n            \n            for jumpRange in [jumpRangeLeft, jumpRangeRight]:\n                for jumpIdx in jumpRange:\n                    if arr[jumpIdx] >= arr[idx]:\n                        break\n\n                    if idx not in outEdges:\n                        outEdges[idx] = set()\n                    outEdges[idx].add(jumpIdx)\n\n                    if jumpIdx not in inEdges:\n                        inEdges[jumpIdx] = set()\n                    inEdges[jumpIdx].add(idx)\n        \n        noInEdges = collections.deque()\n        for idx in range(len(arr)):\n            if idx not in inEdges:\n                noInEdges.append(idx)\n        \n        topologicalOrder = collections.deque()\n        while noInEdges:\n            idx = noInEdges.pop()\n            topologicalOrder.append(idx)\n            if idx not in outEdges:\n                continue\n            for jumpIdx in outEdges[idx]:\n                inEdges[jumpIdx].remove(idx)\n                if not inEdges[jumpIdx]:\n                    noInEdges.append(jumpIdx)\n        \n        maxJumps = 1\n        jumpCount = [1] * len(arr)\n        while topologicalOrder:\n            idx = topologicalOrder.popleft()\n            \n            if idx not in outEdges:\n                continue\n            \n            for jumpIdx in outEdges[idx]:\n                jumpCount[jumpIdx] = max(jumpCount[idx] + 1, jumpCount[jumpIdx])\n                maxJumps = max(jumpCount[jumpIdx], maxJumps)\n                \n        return maxJumps\n        \n    def maxJumpsBfs(self, arr: List[int], d: int) -> int:\n        bfs = collections.deque()\n        \n        for idx in range(len(arr)):\n            bfs.append((idx, 1))\n        \n        stepCount = {}\n        maxSteps = 0\n        \n        while bfs:\n            idx, steps = bfs.popleft()\n\n            # Already found more steps to this index.\n            if idx in stepCount and steps <= stepCount[idx]:\n                continue \n            stepCount[idx] = steps\n\n            maxSteps = max(steps, maxSteps)\n\n            # Process jumps to the right\n            for jumpIdx in range(idx+1, min(len(arr), idx+d+1)):\n                # Can't jump past taller buildings, break loop\n                if arr[jumpIdx] >= arr[idx]:\n                    break\n                    \n                # Explore this jump\n                bfs.append((jumpIdx, steps+1))\n\n            # Process jumps to the left\n            for jumpIdx in range(idx-1, max(0, idx-d) -1, -1):\n                # Can't jump past taller buildings, break loop\n                if arr[jumpIdx] >= arr[idx]:\n                    break\n\n                # Search the next step\n                bfs.append((jumpIdx, steps+1))\n            \n        return maxSteps\n                \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        def find_longest_l(pos, d):\n            if pos - 1 < 0 or arr[pos-1] > arr[pos]:\n                return pos\n            i = pos\n            while i > 0 and abs(pos - i) < d and arr[i-1] < arr[pos]:\n                i -= 1\n            return i\n        \n        def find_longest_r(pos, d):\n            if pos + 1 >= len(arr) or arr[pos+1] > arr[pos]:\n                return pos\n            i = pos\n            while i < len(arr) - 1 and abs(pos - i) < d and arr[i+1] < arr[pos]:\n                i += 1\n            return i\n        \n        def jump(pos, number_of_locations, seen):\n            maximum_locations = number_of_locations\n            L = find_longest_l(pos, d)\n            R = find_longest_r(pos, d)\n                        \n            for i in range(L, R+1):\n                if i == pos:\n                    continue  \n                if i not in seen: \n                    jumps_to_i = jump(i, number_of_locations, seen)\n                    maximum_locations = max(maximum_locations, jumps_to_i + 1) \n                else:\n                    jumps_to_i = seen[i]\n                    maximum_locations = max(maximum_locations, jumps_to_i + 1) \n\n            seen[pos] = maximum_locations\n            return maximum_locations\n      \n        indices = [(i, arr[i]) for i in range(len(arr))]\n        indices.sort(key=lambda x: x[1], reverse=True)\n        \n        seen = {}\n        return max(jump(x[0], 1, seen) for x in indices)\n            \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        def find_longest_l(pos, d):\n            if pos - 1 < 0 or arr[pos-1] > arr[pos]:\n                return pos\n            i = pos\n            while i > 0 and abs(pos - i) < d and arr[i-1] < arr[pos]:\n                i -= 1\n            return i\n        \n        def find_longest_r(pos, d):\n            if pos + 1 >= len(arr) or arr[pos+1] > arr[pos]:\n                return pos\n            i = pos\n            while i < len(arr) - 1 and abs(pos - i) < d and arr[i+1] < arr[pos]:\n                i += 1\n            return i\n        \n        def jump(pos, number_of_locations, seen):\n            maximum_locations = number_of_locations\n            # print(\\\"currently at:\\\", arr[pos], \\\"maximum location:\\\", number_of_locations)            \n            L = find_longest_l(pos, d)\n            R = find_longest_r(pos, d)\n                        \n            for i in range(L, R+1):\n                if i == pos:\n                    continue  \n                if i not in seen: \n                    jumps_to_i = jump(i, number_of_locations, seen)\n                    maximum_locations = max(maximum_locations, jumps_to_i + 1) \n                else:\n                    # print(\\\"seen:\\\", i, seen[i])\n                    jumps_to_i = seen[i]\n                    maximum_locations = max(maximum_locations, jumps_to_i + 1) \n                # print(\\\"pos:\\\", pos, \\\"max visits:\\\", maximum_locations)\n\n            # print(\\\"Backtracking\\\")\n            seen[pos] = maximum_locations\n            # print(\\\"pos:\\\", arr[pos], \\\"seen:\\\", seen)\n            return maximum_locations\n      \n        indices = [(i, arr[i]) for i in range(len(arr))]\n        indices.sort(key=lambda x: x[1], reverse=True)\n        \n        seen = {}\n        # print(seen)\n        return max(jump(x[0], 1, seen) for x in indices)\n            \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        def find_longest_l(pos, d):\n            if pos - 1 < 0 or arr[pos-1] > arr[pos]:\n                return pos\n            i = pos\n            while i > 0 and abs(pos - i) < d and arr[i-1] < arr[pos]:\n                i -= 1\n            return i\n        \n        def find_longest_r(pos, d):\n            if pos + 1 >= len(arr) or arr[pos+1] > arr[pos]:\n                return pos\n            i = pos\n            while i < len(arr) - 1 and abs(pos - i) < d and arr[i+1] < arr[pos]:\n                i += 1\n            return i\n        \n        def jump(pos, number_of_locations, seen):\n            maximum_locations = number_of_locations\n            L = find_longest_l(pos, d)\n            R = find_longest_r(pos, d)\n                        \n            for i in range(L, R+1):\n                if i == pos:\n                    continue  \n                if i not in seen: \n                    jumps_to_i = jump(i, number_of_locations, seen)\n                    maximum_locations = max(maximum_locations, jumps_to_i + 1) \n                else:\n                    jumps_to_i = seen[i]\n                    maximum_locations = max(maximum_locations, jumps_to_i + 1) \n\n            # print(\\\"Backtracking\\\")\n            seen[pos] = maximum_locations\n            # print(\\\"pos:\\\", arr[pos], \\\"seen:\\\", seen)\n            return maximum_locations\n      \n        indices = [(i, arr[i]) for i in range(len(arr))]\n        indices.sort(key=lambda x: x[1], reverse=True)\n        \n        seen = {}\n        # print(seen)\n        return max(jump(x[0], 1, seen) for x in indices)\n            \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        l = len(arr)\n        self.check, self.seen = [[] for _ in range(l)], dict()\n        for i, v in enumerate(arr):\n            for sign in (1, -1):\n                for x in range(sign, (d + 1) * sign, sign):\n                    if i + x not in list(range(l)) or v <= arr[i + x]:\n                        break\n                    self.check[i].append(i + x)\n            if not self.check[i]:\n                self.seen[i] = 1\n        return max(self.helper(i) for i in range(l))\n        \n    def helper(self, p):\n        if p not in self.seen:\n            res = 0\n            for n in self.check[p]:\n                res = max(res, self.seen.get(n, self.helper(n)) + 1)\n            self.seen[p] = res\n        return self.seen[p]\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        ans = [1] * len(arr)\n        \n        def dp(i):\n            if ans[i] != 1:\n                return ans[i]\n            for dr in [-1, 1]:\n                for k in range(i, i + d * dr + dr, dr):\n                    if k == i:\n                        continue\n                    if not (0 <= k < len(arr) and arr[k] < arr[i]):\n                        break\n                    ans[i] = max(ans[i], 1 + dp(k))\n            return ans[i]\n        \n        for i in range(len(arr)):\n            dp(i)\n        return max(ans)\n                \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        memo = {}\n        \n        \n        def dfs(start, visited):\n            if start < 0 or start >= n:\n                return 0\n            \n            if start in memo:\n                return memo[start]\n            \n            visited[start] = 1\n            ret = 1\n            for i in range(start-1, max(0, start - d) - 1, -1):\n                if arr[i] >= arr[start]:\n                    break\n                if visited[i]:\n                    continue\n                ret = max(ret, dfs(i, visited)+1)    \n            for j in range(start+1, min(start + d, n-1) + 1):                \n                if arr[j] >= arr[start]:\n                    break\n                if visited[j]:\n                    continue\n                ret = max(ret, dfs(j, visited)+1)   \n                \n            visited[start] = 0\n            memo[start] = ret\n            return ret\n        \n        ret = 1\n        for i in range(n):\n            visited = [0] * n\n            ret = max(dfs(i, visited), ret)\n            #print(i,ret, memo)\n        \n        return ret", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        '''\n        [6,4,14,6,8,13,9,7,10,6,12], d = 2\n        dp(i) = 1 + \n        max{\n        within i-d <j< i+d\n        not arr[k] > arr[i] between i, j\n        }\n        res = 0\n        j from i-1 to i-d (0<=j<len(arr)), while arr[j]<arr[i]: res = max(res, recurse j) \n        i+1 to i+d\n        memo\n        return res + 1\n        \n        '''\n        max_pos = 1\n        memo = {}\n        def helper(i):\n            if i in list(memo.keys()): return memo[i]\n            res = 0\n            j = i-1\n            while 0<=j<len(arr) and i-j<=d and arr[j]<arr[i]:\n                res = max(res, helper(j))\n                j -= 1\n            j = i+1\n            while 0<=j<len(arr) and j-i<=d and arr[j]<arr[i]:\n                res = max(res, helper(j))\n                j += 1\n            res = res + 1\n            memo[i] = res\n            return res\n        \n        for i in range(len(arr)):\n            max_pos = max(max_pos, helper(i))\n        # print(memo)\n        return max_pos\n            \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        def backtracking(idx):\n            nonlocal memo, max_val\n            if idx in memo: return memo[idx]\n            lstack = []\n            rstack = []\n            lbarrier = False\n            rbarrier = False\n            for i in range(1, d + 1):\n                if not lbarrier and idx - i >= 0 and arr[idx - i] < arr[idx]:\n                    lstack.append(idx - i)\n                else:\n                    lbarrier = True\n                if not rbarrier and idx + i < len(arr) and arr[idx + i] < arr[idx]:\n                    rstack.append(idx + i)\n                else:\n                    rbarrier = True\n            # if idx == 10: print(lstack, rstack)\n            ljump = 1\n            while lstack:\n                lidx = lstack.pop()\n                ljump = max(ljump, 1 + backtracking(lidx))\n            rjump = 1\n            while rstack:\n                ridx = rstack.pop()\n                rjump = max(rjump, 1 + backtracking(ridx))\n            jump = max(ljump, rjump)\n            memo[idx] = jump\n            max_val = max(max_val, jump)\n            return jump\n        memo = {}\n        max_val = 0\n        for i in range(len(arr)):\n            backtracking(i)\n            \n        return max_val", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        jumps = defaultdict(list)\n        \n        def check(it):\n            stack = []\n            for i in it:\n                while stack and arr[stack[-1]] < arr[i]:\n                    j = stack.pop()\n                    if abs(i - j) <= d:\n                        jumps[j].append(i)\n                stack.append(i)\n        N = len(arr)\n        check(range(N))\n        check(reversed(range(N)))\n        \n        @lru_cache(None)\n        def dfs(i):\n            return 1 + max((dfs(j) for j in jumps[i]), default = 0)\n        \n        return max((dfs(i) for i in range(N)))", "class Solution:\n    def maxJumps(self, A: List[int], d: int) -> int:\n        dp = [1]*len(A)\n        steps = [(v,i) for i,v in enumerate(A)]\n        steps.sort()\n        for val, i in steps:\n            maxVal = val\n            for j in range(i+1, min(i+d+1,len(steps))):\n                if A[j] > maxVal:\n                    maxVal = max(maxVal,A[j])\n                    dp[j] = max(dp[j], dp[i]+1)\n            maxVal = val \n            for j in reversed(range(max(i-d,0),i)):\n                if A[j] > maxVal:\n                    maxVal = max(maxVal,A[j])\n                    dp[j] = max(dp[j], dp[i]+1)\n        return max(dp)", "class Solution:\n    def maxJumps(self, A: List[int], d: int) -> int:\n        # there is some topological order\n        # but now it is asking for the longest path \n        # now we have to start at the root of the tree, and then maximize the \n        # distance of each node \n        # building the graph is tricky \n        # sliding window for building the graph \n        # i -> j if arr[i] > arr[j] but not the otherway around \n        # so we have to use a deque and pop out the indices greater than d away \n        \n        '''\n        6 4\n        14 -> 6, (0), 14 -> 4 (1)\n        14 -> (3), \n        14 -> (4), (4) -> (3)\n        \n        '''\n        \n        n = len(A)\n        graph = {}\n        inorder = [0]*n\n        for i in range(n):\n          graph[i] = []\n          is_greater = False\n          cur_max = -1\n          for ind in range(i-1, max(-1, i-d-1), -1):\n            if A[ind] >= A[i]:\n              if A[ind] >= cur_max and A[ind] > A[i]:\n                cur_max = A[ind]\n                graph[ind].append(i)\n                inorder[i] += 1\n              is_greater = True\n            else:\n              if is_greater: continue\n              graph[i].append(ind)\n              inorder[ind] += 1\n        stack = []\n        dp = [1]*n\n        for i in range(n):\n          if inorder[i] == 0:\n            stack.append(i)\n        while stack:\n          top = stack.pop()\n          for value in graph[top]:\n            inorder[value] -= 1\n            dp[value] = max(dp[value], dp[top] + 1)\n            if inorder[value] == 0:\n              stack.append(value)\n              \n        # print(A[20:60])\n        # print([(i, v)  for i,v in enumerate(dp)][:60])\n        return max(dp)\n", "class Solution:\n    def maxJumps(self, A: List[int], d: int) -> int:\n        # there is some topological order\n        # but now it is asking for the longest path \n        # now we have to start at the root of the tree, and then maximize the \n        # distance of each node \n        # building the graph is tricky \n        # sliding window for building the graph \n        # i -> j if arr[i] > arr[j] but not the otherway around \n        # so we have to use a deque and pop out the indices greater than d away \n        \n        '''\n        6 4\n        14 -> 6, (0), 14 -> 4 (1)\n        14 -> (3), \n        14 -> (4), (4) -> (3)\n        \n        '''\n        \n        n = len(A)\n        graph = {}\n        inorder = [0]*n\n        for i in range(n):\n          graph[i] = []\n          is_greater = False\n          cur_max = -1\n          for ind in range(i-1, max(-1, i-d-1), -1):\n            if A[ind] > A[i]:\n              if A[ind] >= cur_max:\n                cur_max = A[ind]\n                graph[ind].append(i)\n                inorder[i] += 1\n              is_greater = True\n            else:\n              if is_greater: continue\n              if A[i] == A[ind]: break\n              graph[i].append(ind)\n              inorder[ind] += 1\n        stack = []\n        dp = [1]*n\n        for i in range(n):\n          if inorder[i] == 0:\n            stack.append(i)\n        while stack:\n          top = stack.pop()\n          for value in graph[top]:\n            inorder[value] -= 1\n            dp[value] = max(dp[value], dp[top] + 1)\n            if inorder[value] == 0:\n              stack.append(value)\n              \n        # print(A[20:60])\n        # print([(i, v)  for i,v in enumerate(dp)][:60])\n        print(dp)\n        return max(dp)\n", "class Solution:\n    def maxJumps(self, A: List[int], d: int) -> int:\n        dp = [1]*len(A)\n        steps = [(v,i) for i,v in enumerate(A)]\n        steps.sort()\n        print(steps)\n        for val, i in steps:\n            maxVal = val\n            for j in range(i+1, min(i+d+1,len(steps))):\n                if A[j] > maxVal:\n                    maxVal = max(maxVal,A[j])\n                    dp[j] = max(dp[j], dp[i]+1)\n            maxVal = val \n            for j in reversed(range(max(i-d,0),i)):\n                if A[j] > maxVal:\n                    maxVal = max(maxVal,A[j])\n                    dp[j] = max(dp[j], dp[i]+1)\n        print(dp)\n        return max(dp)", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        book = [1]*len(arr)\n        index = collections.defaultdict(list)\n        for i in range(len(arr)):\n            index[arr[i]].append(i)\n        val = list(index.keys())\n        val.sort(reverse = True)\n        for v in val:\n            for i in index[v]:\n                height = arr[i]\n                for j in range(i+1, i+d+1):\n                    if j == len(arr):\n                        break\n                    if arr[j] > height:\n                        book[i] = max(book[i], book[j]+1)\n                        height = arr[j]\n                height = arr[i]\n                for j in range(i-1, i-d-1, -1):\n                    if j == -1:\n                        break\n                    if arr[j] > height:\n                        book[i] = max(book[i], book[j]+1)\n                        height = arr[j]\n        return max(book)", "class Solution: # top-down dp\n    # Time complexity O(ND)\n    # Space complexity O(N) for dp\n    def maxJumps(self, arr: List[int], d: int) -> int:\n\n        \n        n, inf = len(arr), float('inf')\n        a, s = [[] for _ in range(n)], [(inf, -1)]\n        \n        for i, x in enumerate(arr):\n            while s[-1][0] < x:\n                if s[-1][1] >= i-d:\n                    a[i].append(s[-1][1])\n                s.pop()\n            s.append((x, i))\n        \n        s = [(inf, -1)]\n        for i, x in reversed(list(enumerate(arr))):\n            while s[-1][0] < x:\n                if s[-1][1] <= i+d:\n                    a[i].append(s[-1][1])\n                s.pop()\n            s.append((x, i))\n        \n        dp, v = [1]*n, [0]*n\n        def dfs(i):\n            if v[i]: return\n            v[i] = 1\n            for j in a[i]:\n                dfs(j)\n                dp[i] = max(dp[i], dp[j]+1)\n        \n        for i in range(n): dfs(i)\n        return max(dp)\n", "class Solution:\n    def maxJumps(self, A: List[int], d: int) -> int:\n        N = len(A)\n        jumpable = collections.defaultdict(list)\n        \n        def find_jumpable_indices(iter):\n            stack = []\n            for i in iter:\n                while stack and A[stack[-1]] < A[i]:\n                    j = stack.pop()\n                    if abs(i - j) <= d:\n                        jumpable[i].append(j)\n                stack.append(i)\n\n        find_jumpable_indices(list(range(N)))\n        find_jumpable_indices(reversed(list(range(N))))\n        \n        dp = [-1] * N\n        def dfs(idx):\n            if dp[idx] > -1:\n                return dp[idx]\n            res = 1\n            for j in jumpable[idx]:\n                res = max(res, 1 + dfs(j))\n            \n            dp[idx] = res\n            return res\n        \n        return max(list(map(dfs, list(range(N)))))\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        dp = [1] * (n+1)\n        stack = []\n        for i, a in enumerate(arr + [float('inf')]):\n            while stack and arr[stack[-1]] < a:\n                last = [stack.pop()]\n                while stack and arr[stack[-1]] == arr[last[0]]:\n                    last.append(stack.pop())\n                for j in last:\n                    if i-j <= d:\n                        dp[i] = max(dp[i], dp[j]+1)\n                    if stack and j - stack[-1] <= d:\n                        dp[stack[-1]] = max(dp[stack[-1]], dp[j]+1)\n            stack.append(i)\n        return max(dp[:-1])", "class Solution:\n    def maxJumps(self, arr, d):\n        n = len(arr)\n        dp = [1] * (n+1)\n        stack = []\n        \n        for i, a in enumerate(arr + [float('inf')]):\n            while stack and arr[stack[-1]] < a:\n                L = [stack.pop()]\n                while stack and arr[stack[-1]] == arr[L[0]]:\n                    L.append(stack.pop())\n                for j in L:\n                    if i - j<=d:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    if stack and j - stack[-1] <=d:\n                        dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n            stack.append(i)\n        return max(dp[:-1])    ", "from collections import *\nfrom functools import *\nimport numpy as np\nfrom typing import *\n\n\nclass Solution:\n    def maxJumps(self, nums: List[int], d: int) -> int:\n        N = len(nums)\n        left_jumps = [[] for _ in range(N)]\n        left = [(-1, np.inf)]\n        for i in range(N):\n            while left[-1][1] < nums[i]:\n                j, _ = left.pop()\n                if abs(j - i) <= d:\n                    left_jumps[i].append(j)\n            left.append((i, nums[i]))\n        \n        right_jumps = [[] for _ in range(N)]\n        right = [(-1, np.inf)]\n        for i in reversed(range(N)):\n            while right[-1][1] < nums[i]:\n                j, _ = right.pop()\n                if abs(j - i) <= d:\n                    right_jumps[i].append(j)\n            right.append((i, nums[i]))\n        \n        @lru_cache(maxsize=None)\n        def longest_path_from(pos: int):\n            left_max = max((longest_path_from(p) for p in left_jumps[pos]), default=0)\n            right_max = max((longest_path_from(p) for p in right_jumps[pos]), default=0)\n            return max(1 + left_max, 1 + right_max)\n\n        return max(longest_path_from(i) for i in range(N))", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        A = arr\n        n = len(A)\n        # comp = 0\n        @lru_cache(None)\n        def dp(i):\n            # nonlocal comp\n            # comp += 1\n            count = 0\n            for j in range(i-1, i-d-1, -1):\n                if j >= 0 and A[j] < A[i]:\n                    count = max(count, dp(j))\n                else:\n                    break\n            for j in range(i+1, i+d+1):\n                if j < n and A[j] < A[i]:\n                    count = max(count, dp(j))\n                else:\n                    break\n            return count + 1\n        \n        res = 0\n        for k in range(n):\n            res = max(res, dp(k))\n        # print(comp)\n        return res", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        arr.append(math.inf) # \u8ba9\u6240\u6709\u5143\u7d20\u90fd\u51fa\u6808\n        dp = [1] * len(arr)\n        stack = [] # \u5355\u8c03\u9012\u51cf\u6808\n        for i, cur in enumerate(arr):\n            while stack and arr[stack[-1]] < cur:\n                poped_same_val = [stack.pop()]\n                while stack and arr[stack[-1]] == arr[poped_same_val[0]]: # val\u4e00\u6837\u7684\u5143\u7d20\uff0c\u4ed6\u4eec\u7684right_first_bigger\u548cleft_first_bigger\u90fd\u662f\u4e00\u6837\u7684\uff0c\u8981\u4e00\u8d77\u62ff\u51fa\u6765\u66f4\u65b0\u3002\n                    poped_same_val.append(stack.pop())\n                for poped in poped_same_val:\n                    if i - poped <= d: # i\u662fpoped\u7684\u53f3\u4fa7\u7b2c\u4e00\u4e2a\u76f8\u7b49\u6216\u66f4\u5927\u7684\u5143\u7d20\n                        dp[i] = max(dp[i], dp[poped] + 1)\n                    if stack and poped - stack[-1] <= d: # stack[-1]\u662fpoped\u7684\u5de6\u4fa7\u7b2c\u4e00\u4e2a\u66f4\u5927\u7684\u5143\u7d20\n                        left_first_big_of_poped = stack[-1]\n                        dp[left_first_big_of_poped] = max(dp[left_first_big_of_poped], dp[poped] + 1)\n            stack.append(i)\n            # print(i, dp, stack)\n        return max(dp[:-1]) # \u53bb\u6389\u6700\u540e\u4e00\u4e2ainf\u5728\u7684\u4f4d\u7f6e\u7684dp\u503c", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n=len(arr)\n        dp=[1 for i in range(n)]\n        p=[]\n        for idx,x in enumerate(arr):\n            p.append((x,idx))\n        p.sort(reverse=True)\n        for i in range(n):\n            idx=p[i][1]\n            for j in range(idx+1,min(n,d+idx+1)):\n                if arr[j]>=arr[idx]: break\n                dp[j]=max(dp[j],dp[idx]+1)\n            for j in range(idx-1,max(-1,idx-d-1),-1):\n                if arr[j]>=arr[idx]: break\n                dp[j]=max(dp[j],dp[idx]+1)\n        return max([dp[i] for i in range(n)])", "from functools import lru_cache\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        lim = len(arr)\n        @lru_cache(None)\n        def r(i):\n            \n            \n            tmp = [0]\n            for j in range(i-1,i-d-1,-1):\n                if j<0:break\n                if arr[j]<arr[i]:\n                    tmp.append(1+r(j))\n                else:\n                    break\n                    \n            \n            for j in range(i+1,i+d+1):\n                if j>=lim:break\n                if arr[j]<arr[i]:\n                    tmp.append(1+r(j))\n                else:\n                    break\n            \n            return max(tmp)\n        \n        \n        mx = 0\n        for i in range(0,lim):\n            val = 1+r(i)\n            if val>mx:mx = val\n                \n        return mx", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        @lru_cache(None)\n        def jump(mid):\n            left = max(mid - d, 0)\n            right = min(mid + d, len(arr) - 1)\n            \n            res = 1\n            for i in range(mid - 1, left - 1, -1):\n                if arr[i] >= arr[mid]:\n                    break\n                res = max(res, jump(i) + 1)\n            for i in range(mid + 1, right + 1):\n                if arr[i] >= arr[mid]:\n                    break\n                res = max(res, jump(i) + 1)\n            return res\n        \n        res = [1] * len(arr)\n        for i in range(len(arr)):\n            res[i] = jump(i)\n        return max(res)", "import functools\n\nclass Solution:\n    def maxJumps(self, arr, d: int) -> int:\n\n        @functools.lru_cache(None)\n        def helper(i):\n            ans = 1\n            for index in range(i + 1, min(len(arr), i + d + 1)):\n                if arr[i] > arr[index]:\n                    ans = max(ans,1 + helper(index))\n                else:\n                    break\n\n            for index in range(i - 1, max(-1, i - d - 1),-1):\n                if arr[i] > arr[index]:\n                    ans = max(ans,1 + helper(index))\n                else:\n                    break\n\n            return ans\n\n        maxJumps = 1\n        for i in range(len(arr)):\n            maxJumps = max(maxJumps, helper(i))\n\n        return maxJumps\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        l = []\n        n = len(arr)\n        for i in range(n):l.append([arr[i], i])\n        l.sort()\n        l = [i[1] for i in l]\n        \n        dp = [1] * n\n        for i in l:\n            for j in range(i + 1, min(n, i + d + 1)):\n                if arr[i] > arr[j]:dp[i] = max(dp[i], dp[j] + 1)\n                else:break\n            for j in range(i - 1, max(-1, i - d -1), -1):\n                if arr[i] > arr[j]:dp[i] = max(dp[i], dp[j] + 1)\n                else:break\n        return max(dp)", "import functools\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        @functools.lru_cache(None)\n        def check_i(inow) :\n            max_son = 0\n            for i in range(1, min(d+1, len(arr)-inow)) :\n                if arr[inow+i] >= arr[inow] :\n                    break\n                max_son = max(max_son, check_i(inow + i))\n            for i in range(1, min(d+1, inow+1)) :\n                if arr[inow-i] >= arr[inow] :\n                    break\n                max_son = max(max_son, check_i(inow - i))\n            \n            return max_son+1\n            \n        \n        return max([check_i(i) for i in range(len(arr))])\n            \n        \n        \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        # dp\n        # n = len(arr)\n        # res = [0] * n\n        # def dp(i):\n        #     if res[i]:\n        #         return res[i]\n        #     res[i] = 1\n        #     for di in [-1, 1]:\n        #         for j in range(i+di, i+d*di+di, di):\n        #             if not (0 <= j < n and arr[j] < arr[i]):\n        #                 break\n        #             res[i] = max(res[i], dp(j) + 1)\n        #     return res[i]\n        # return max(map(dp, range(n)))\n        n = len(arr)\n        dp = [1] * n\n        for a, i in sorted([a, i] for i, a in enumerate(arr)):\n            for di in [-1, 1]:\n                for j in range(i+di, i+d*di+di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]):\n                        break\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp) \n", "\n# 1340. Jump Game V\n# 20201003 \u8fd9\u4e2a\u9898\u76ee\uff0c\u4e5f\u53ea\u6709\u7528\u6808\u89e3\u51b3\u6700\u5feb\n\n\nclass Solution:  # Decreasing Stack + DP \uff08\u5355\u8c03\u6808 DP\uff09\n\n    def maxJumps(self, arr, d):\n        n = len(arr)\n        dp = [1] * (n + 1)\n        stack = []\n        for i, a in enumerate(arr + [float('inf')]):\n            while stack and arr[stack[-1]] < a:\n                L = [stack.pop()]\n                while stack and arr[stack[-1]] == arr[L[0]]:\n                    L.append(stack.pop())\n                for j in L:\n                    if i - j <= d:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    if stack and j - stack[-1] <= d:\n                        dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n            stack.append(i)\n            \n        return max(dp[:-1])\n    \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        N = len(arr)\n        \n        @lru_cache(None)\n        def rec(idx):\n            if not 0 <= idx < N:\n                return -inf\n            # print(idx)\n            ans = 1\n            for i in range(idx-1, idx-d-1, -1):\n                if i < 0 or arr[i] >= arr[idx]:\n                    break\n                ans = max(ans, rec(i) + 1)\n            \n            for i in range(idx+1, idx+d+1):\n                if i >= N or arr[i] >= arr[idx]:\n                    break\n                ans = max(ans, rec(i) + 1)\n            \n            return ans\n        \n        ans = 0\n        for i in range(N):\n            ans = max(ans, rec(i))\n        \n        return ans", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        @lru_cache(None)\n        def dfs(i):\n            if i==0 and i+1<len(arr):\n                if arr[i]<=arr[i+1]:\n                    return 1\n            elif i==len(arr)-1 and i-1>=0:\n                if arr[i]<=arr[i-1]:\n                    return 1\n            elif i-1>=0 and i+1<len(arr) and arr[i]<=arr[i-1] and arr[i]<=arr[i+1]:\n                return 1\n            \n            left_step = 1\n            for j in range(i+1, i+d+1):\n                if j>=len(arr) or arr[j]>=arr[i]:\n                    break\n                left_step = max(left_step, 1+dfs(j))\n            right_step = 1          \n            for j in range(i-1, i-d-1, -1):\n                if j<0 or arr[j]>=arr[i]:\n                    break\n                right_step = max(right_step, 1+dfs(j))\n            return max(left_step, right_step)\n                \n        max_step = 0\n        for i in range(len(arr)):\n            max_step = max(max_step, dfs(i))\n            # print(dfs(i))\n        return max_step\n                \n        \n        \n        \n        \n#         d\u9650\u5b9a\u4e86\u53ef\u80fd\u8df3\u7684\u6700\u5927\u6b65\u957f\n#         \u5728\u6b65\u957f\u8303\u56f4\u5185\uff0c\u8df3\u7684\u8ddd\u79bb\u5fc5\u987b\u6ee1\u8db3\u4e2d\u95f4\u4e0d\u80fd\u6709\u5927\u4e8e\u81ea\u5df1\u7684\u503c\n#         \u8fd4\u56de\u53ef\u80fd\u5230\u8fbe\u7684\u6700\u591a\u7684\u4e0b\u6807\n        \n#         \u6bcf\u4e2a\u4f4d\u7f6e\u6709\u81ea\u5df1\u53ef\u80fd\u8c03\u5230\u7684\u6700\u591a\u4e0b\u6807\n#         \u6bd4\u59826-->4\n#         14-\u300b8-\u300b6 \u6216\u800514-\u300b6-\u300b4 \n#         \u957f\u5ea6\u4e3a1000\n#         \u6309\u7167\u9ad8\u5ea6\u5927\u5c0f\uff0c\u6c42\u89e3\u521d\u59cb\u8df3\u7684\u6b65\u957f\n#         \u6700\u7ec8\u4e00\u5b9a\u662f\u8df3\u5230\u4e00\u4e2a\u5c71\u8c37\u6216\u8005\u4e24\u7aef\u7684\u4f4d\u7f6e\n#         dp[i]: \u5f53\u4f4d\u7f6e\u5230\u8fbe\u4e0b\u6807i\u65f6\uff0c\u53ef\u80fd\u8df3\u5230\u7684\u6700\u591a\u4e0b\u6807\uff0c\u5bf9\u4e8e\u5c71\u8c37\u6216\u8005\u4e24\u7aef\u4f4d\u7f6e\u800c\u8a00\uff0c\u521d\u59cb\u503c\u4e3a1\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        from functools import lru_cache\n\n        n = len(arr)\n\n        @lru_cache(maxsize=None)\n        def f(i):\n            res = 1\n            for j in range(i + 1, min(i + d + 1, n)):\n                if arr[j] < arr[i]:\n                    res = max(res, 1 + f(j))\n                else:\n                    break\n            for j in range(i - 1, max(-1, i - d - 1), -1):\n                if arr[j] < arr[i]:\n                    res = max(res, 1 + f(j))\n                else:\n                    break\n            return res\n\n        return max(f(_) for _ in range(n))", "class Solution:\n    def maxJumps(self, A: List[int], d: int) -> int:\n        n = len(A)\n        @lru_cache(None)\n        def helper(i):\n            ans = 1            \n            l = max(0,i-d)\n            r = min(n-1,i+d)\n            #print(i,l,r)\n        \n            for j in reversed(range(l,i)):\n                if(A[j]<A[i]):\n                    ans = max(ans,1 + helper(j))\n                else:\n                    break\n            for j in range(i+1,r+1):\n                if(A[j]<A[i]):\n                    ans = max(ans,1 + helper(j))\n                else:\n                    break\n            \n            return ans\n        \n        ans = max([helper(i) for i in range(n)])\n        return ans", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        sorted_indexes = sorted(range(len(arr)), key = lambda i:arr[i])\n        # print(sorted_indexes)\n        n = len(arr)\n        dp = [1] * n\n        \n        def get_neighs(cur):\n            neighs = []\n            for i in range(cur + 1, min(cur + d + 1, n)):\n                if arr[i] < arr[cur]:\n                    neighs.append(i)\n                else:\n                    break\n            for i in range(cur - 1, max(cur - d - 1, -1), -1):\n                if arr[i] < arr[cur]:\n                    neighs.append(i)\n                else:\n                    break\n            return neighs\n        \n        for cur in sorted_indexes:\n            neighs = get_neighs(cur)\n            for neigh in neighs:\n                dp[cur] = max(dp[cur], dp[neigh] + 1)\n        return max(dp)", "class Solution:\n    def maxJumps2(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        res = [0] * n\n        \n        def dp(i):\n            if res[i] > 0:\n                return res[i]\n            res[i]=1 # at least itself\n            \n            for di in [-1, 1]:\n                for j in range(i+di, i+d*di+di, di):\n                    # di=-1, j in range(i-1, i-d-1, -1) which is from i-1 to i-2 to ... i-d (d positions, all are reachable)\n                    # di=1, j in range(i+1, i+d+1, 1), which is from i+1 to i+2 to ... i+d ( d positions, all are reachable)\n                    if not (0<=j<n and arr[j] < arr[i]): # if j<0 or j>=n or arr[j] >= arr[i]: break\n                        break\n                    res[i] = max(res[i], dp(j) + 1)\n                    \n            return res[i]\n        \n        return max(map(dp, range(n)))\n    \n    def maxJumps1(self, arr, d): # \u6700\u76f4\u89c2\u7684dp\u65b9\u6cd5\uff01\u9012\u5f52\u8c03\u7528+\u8bb0\u5fc6\u5316\u4fdd\u5b58\n        n = len(arr)\n        res = [0] * n\n        \n        def dp(i):\n            if res[i] > 0: return res[i]\n            res[i] = 1\n            \n            for j in range(i+1, i+d+1):\n                if j>=n or arr[j] >= arr[i]:\n                    break\n                res[i] = max(res[i], dp(j) + 1)\n            \n            for j in range(i-1, i-d-1, -1):\n                if j<0 or arr[j] >= arr[i]:\n                    break\n                res[i] = max(res[i], dp(j) + 1)\n            return res[i]\n        return max(dp(i) for i in range(n))\n    \n    def maxJumps(self, arr, d):\n        n = len(arr)\n        dp = [1] * n\n        for a, i in sorted([a, i] for i, a in enumerate(arr)):\n            for di in [-1, 1]:\n                for j in range(i + di, i + d*di+di, di):\n                    if not (0<=j<n and arr[j] < arr[i]):\n                        break\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        hp = [(v, i) for i, v in enumerate(arr)]\n        heapq.heapify(hp)\n        dp = [0] * len(arr)\n        res = 0\n        while hp:\n            h, i = heapq.heappop(hp)\n            tmp = 1\n            for j in range(i - 1, i - 1 - d, -1):\n                if j < 0 or arr[j] >= arr[i]:\n                    break\n                tmp = max(tmp, dp[j] + 1)\n            for j in range(i + 1, i + 1 + d):\n                if j >= len(arr) or arr[j] >= arr[i]:\n                    break\n                tmp = max(tmp, dp[j] + 1)\n            dp[i] = tmp\n        return max(dp)\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        dp = [1] * len(arr)\n        a = []\n        for idx, val in enumerate(arr):\n            a.append((val, idx))\n        a.sort()\n        print(a)\n        for _, idx in a:\n            \n            for i in range(1, d+1):\n                if idx+i<len(arr) and arr[idx+i]<arr[idx]:\n                    dp[idx] = max(dp[idx], dp[idx+i]+1)\n                else:\n                    break\n            for i in range(1, d+1):\n                if 0<=idx-i and arr[idx-i]<arr[idx]:\n                    dp[idx] = max(dp[idx], dp[idx-i]+1)\n                else:\n                    break\n        return max(dp)\n                \n", "class Solution:\n    def maxJumps(self, A: List[int], d: int) -> int:\n        n = len(A)\n        dp = [1] * (n + 1)\n        stack = []\n        for i, a in enumerate(A + [float('inf')]):\n            while stack and A[stack[-1]] < a:\n                L = [stack.pop()]\n                while stack and A[stack[-1]] == A[L[0]]:\n                    L.append(stack.pop())\n                for j in L:\n                    if i - j <= d:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    if stack and j - stack[-1] <= d:\n                        dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n            stack.append(i)\n        return max(dp[:-1])\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        #top-down dp\n        res = [1] * len(arr)\n        for a, i in sorted([a, i] for i, a in enumerate(arr)):\n            for di in [-1, 1]:\n                for j in range(i + di, i + d * di + di, di):\n                    if not (0 <= j < len(arr) and arr[j] < arr[i]): break\n                    res[i] = max(res[i], 1 + res[j])\n        return max(res)\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        dp = [0] * len(arr)\n        path = {i: [(i, arr[i])] for i in range(len(arr))}\n        def jump(i):\n            nonlocal dp, path\n            if dp[i] != 0:\n                return dp[i]\n            left, right = 0, 0\n            nl, nr = i, i\n            for j in range(i+1, i+d+1):\n                if j >= len(arr):\n                    break\n                if arr[j] < arr[i]:\n                    t= jump(j)\n                    if right < t:\n                        right = t\n                        nr = j\n                else:\n                    break\n            for j in range(i-1, i-d-1, -1):\n                if j < 0:\n                    break\n                if arr[j] < arr[i]:\n                    t = jump(j)\n                    if left < t:\n                        left = t\n                        nl = j\n                else:\n                    break\n            if left < right and right > 0:\n                path[i] += path[nr]\n            elif left >= right and left > 0:\n                path[i] += path[nl]\n            dp[i] = max(left, right) + 1\n            return dp[i]\n        \n        ans = 0\n        for i in range(len(arr)):\n            jump(i)\n            # print(i, path[i])\n            ans = max(ans, dp[i])\n        return ans", "import functools\n\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        @functools.lru_cache(None)\n        def jump(index):\n            res = 0\n            for direction in [-1, 1]:\n                for x in range(1, d + 1):\n                    j = index + x * direction\n                    if 0 <= j < len(arr) and arr[j] < arr[index]:\n                        res = max(res, jump(j))\n                    else:\n                        break\n            return res + 1\n        return max(jump(index) for index in range(len(arr)))", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        N = len(arr)\n        dp = [None]* N\n        def cdp(i):\n            if dp[i] != None:\n                return dp[i]\n            dp[i] = 1\n            for j in range(i-1,max(0, i-d) -1 , -1):\n                if arr[j] >= arr[i]:\n                    break\n                dp[i] = max(dp[i] , 1 + cdp(j))\n            for j in range(i+1,min(N-1, i+d) +1):\n                if arr[j] >= arr[i]:\n                    break\n                dp[i] = max(dp[i] , 1 + cdp(j))\n            return dp[i]\n        \n        for i in range(N):\n            cdp(i)\n        return max(dp)\n", "from functools import lru_cache \nclass Solution:\n    def maxJumps(self, arr, d):\n        n = len(arr)\n        @lru_cache(maxsize = None)\n        def findMaxReach(index):\n            best = 1\n            for i in range(1, d + 1):\n                curIndex = index - i\n                if 0 <= curIndex < n and arr[curIndex] < arr[index]:\n                    best = max(findMaxReach(curIndex) + 1, best)\n                else:\n                    break\n            for i in range(1, d + 1):\n                curIndex = index + i\n                if 0 <= curIndex < n and arr[curIndex] < arr[index]:\n                    best = max(findMaxReach(curIndex) + 1, best)\n                else:\n                    break\n            return best\n        ans = 0\n        for i in range(n):\n            ans = max(findMaxReach(i), ans)\n        return ans\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        N = len(arr)\n        dp = [None]* N\n        def cdp(i):\n            if dp[i] !=None:\n                return dp[i]\n            dp[i] = 1\n            for j in range(i-1, max(0, i-d) -1 , -1):\n                if arr[j] >= arr[i]:\n                    break\n                dp[i] = max(dp[i] , 1 + cdp(j))\n            for j in range(i+1, min(N-1, i+d) +1 ):\n                if arr[j] >= arr[i]:\n                    break\n                dp[i] = max(dp[i] , 1 + cdp(j))\n            return dp[i]\n        for i in range(N):\n            cdp(i)\n        return max(dp)\n", "from functools import lru_cache\n\n\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n\n        @lru_cache(maxsize=None)\n        def jump(i):\n            res = 1\n\n            def visit(rng):\n                nonlocal res\n                for j in rng:\n                    if not 0 <= j < n or arr[j] >= arr[i]:\n                        break\n                    res = max(res, 1 + jump(j))\n\n            visit(range(i - 1, i - d - 1, -1))\n            visit(range(i + 1, i + d + 1))\n            return res\n\n        return max([jump(i) for i in range(n)])", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        dp = [0 for i in range(len(arr))]\n        \n        def findMaxJumps(i):\n            if dp[i]!=0:\n                return dp[i]\n            else:\n                ans = 1\n                for j in range(i+1, min(i+d+1, len(arr))):\n                    if (arr[j]>=arr[i]):\n                        break\n                    ans = max(ans, 1 + findMaxJumps(j))\n                for j in range(i-1, max(i-d,0)-1, -1):\n                    if (arr[j]>=arr[i]):\n                        break\n                    ans = max(ans, 1+ findMaxJumps(j))\n                dp[i] = ans \n                return ans\n            \n        ans = 1    \n        for i in range(len(arr)):\n            ans = max(ans, findMaxJumps(i))\n        return ans\n            \n                \n            \n            \n", "\n# 1340. Jump Game V\n\nclass Solution2: # bottom-up dp\n    # Time complexity O(NlogN + ND), where we are given D <= N\n    # Space complexity O(N) for dp\n    def maxJumps(self, arr, d):\n        n = len(arr)\n        dp = [1] * n\n        for a, i in sorted([a, i] for i, a in enumerate(arr)):\n            for di in [-1, 1]:\n                for j in range(i+di, i+di+d*di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]): \n                        break\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n\nclass Solution:\n    \n# All element are pushed in and poped from stack1&2 only once, \n# strick O(N) time. \u590d\u6742\u5ea6\u4e25\u683c\u7b26\u5408O(N)\u3002\n\n# Decreasing Stack + DP\n# Use a stack to keep the index of decreasing elements.\n# Iterate the array A. When we meet a bigger element a, \n# we pop out the all indices j from the top of stack, \n# where A[j] have the same value.\n\n# Then we update dp[i] and dp[stack[-1]].\n\n# Since all indices will be pushed and popped in stack, \n# appended and iterated in L once,\n# the whole complexity is guaranteed to be O(N).\n\n# All element are pushed in and poped from stack1&2 only once, strick O(N) time.\n# Time complexity O(N); Space complexity O(N)\n# Python runtime 120ms, beats 100%\n\n    def maxJumps(self, arr, d):\n        n = len(arr)\n        dp = [1] * (n + 1)\n        stack = []\n        for i, a in enumerate(arr + [float('inf')]):\n            while stack and arr[stack[-1]] < a:\n                L = [stack.pop()]\n                while stack and arr[stack[-1]] == arr[L[0]]:\n                    L.append(stack.pop())\n                for j in L:\n                    if i - j <= d:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    if stack and j - stack[-1] <= d:\n                        dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n            stack.append(i)\n        return max(dp[:-1])\n    \n    \nclass Solution1: # top-down dp\n    # Time complexity O(ND)\n    # Space complexity O(N) for dp\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        n = len(arr)\n        res = [0] * n\n        \n        def dp(i):\n            if res[i]: return res[i]\n            res[i] = 1\n            for di in [-1, 1]:\n                for j in range(i+di, i+di+d*di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]):\n                        break \n                    res[i] = max(res[i], dp(j)+1)\n            return res[i]\n        \n        return max(list(map(dp, list(range(n))))) \n    \n    # range(0, n) as input of dp func, then get the max of their results\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        sorted_indexes = sorted(range(len(arr)), key = lambda i:arr[i])\n        n = len(arr)\n        dp = [1] * n\n        \n        def get_neighs(cur):\n            neighs = []\n            directions = [1, -1]\n            for dire in directions:\n                for i in range(cur + dire, cur + (d + 1) * dire, dire):\n                    if i < 0 or i >= n:\n                        break\n                    if arr[i] >= arr[cur]:\n                        break\n                    neighs.append(i)\n            return neighs\n        \n        for cur in sorted_indexes:\n            for neigh in get_neighs(cur):\n                dp[cur] = max(dp[cur], dp[neigh] + 1)\n        return max(dp)", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n=len(arr)\n        if n==1 or d==0:\n            return 1\n        e=[[]for i in range(n)]\n        for i in range(0,n):\n            for j in range(i-1,max(0,i-d)-1,-1):\n                if arr[j]<arr[i]:\n                    e[i].append(j)\n                else :\n                    break;\n            for j in range(i+1,min(n-1,i+d)+1):\n                if arr[j]<arr[i]:\n                    e[i].append(j)\n                else :\n                    break;\n        ans=1\n        queue=[]\n        cnt=[1for i in range(n)]\n        for i in range(0,n):\n            queue.append([arr[i],i])\n        queue.sort()\n        for i in range(0,n):\n            u=queue[i][1]\n            for v in e[u]:\n                cnt[u]=max(cnt[u],cnt[v]+1)\n            ans=max(ans,cnt[u])\n        return ans\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        sorted_indexes = sorted(range(len(arr)), key = lambda i:arr[i])\n        n = len(arr)\n        dp = [1] * n\n        \n        def get_neighs(cur):\n            neighs = []\n            directions = [1, -1]\n            for dire in directions:\n                for i in range(cur + dire, cur + (d + 1) * dire, dire):\n                    if i < 0 or i >= n:\n                        break\n                    if arr[i] >= arr[cur]:\n                        break\n                    neighs.append(i)\n            return neighs\n        \n        for cur in sorted_indexes:\n            neighs = get_neighs(cur)\n            for neigh in neighs:\n                dp[cur] = max(dp[cur], dp[neigh] + 1)\n        return max(dp)", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        \n        @lru_cache(None)\n        def dfs(i):\n            left, right = i, i\n            max_range = 1\n            while left - 1 >= 0 and arr[left - 1] < arr[i] and left - 1 >= i - d:\n                left -= 1\n            while right + 1 < n and arr[right + 1] < arr[i] and right + 1 <= i + d:\n                right += 1\n            \n            for nxt in range(left, right + 1):\n                if nxt != i:\n                    max_range = max(max_range, 1 + dfs(nxt))\n            \n            return max_range\n            \n            \n        \n        return max(dfs(i) for i in range(n))", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        v = []  \n        n = len(arr)\n        for i in range(n):\n            v.append((arr[i], i))\n        v = sorted(v)\n        \n        f = [-1] * n\n        ans = -1\n        for i in range(n):\n            idx = v[i][1]\n            f[idx] = 1\n            for j in range(1, d+1):\n                if idx - j >= 0 and arr[idx - j] < arr[idx]:\n                    f[idx] = max(f[idx], f[idx - j] + 1)\n                else:\n                    break\n            for j in range(1, d+1):\n                if idx + j < n and arr[idx + j] < arr[idx]:\n                    f[idx] = max(f[idx], f[idx + j] + 1)\n                else:\n                    break\n            ans = max(ans, f[idx])\n        \n        return ans", "def bfs(arr,i,d,memo):\n    \n    if i in memo:\n        return memo[i]\n    \n    res = 1\n    for j in range(max(i-1,0),max(i-d-1,-1),-1):\n        if arr[j]>=arr[i]: break\n        res = max(res,bfs(arr,j,d,memo)+1)\n    \n    for j in range(i+1,min(i+d+1,len(arr))):\n        if arr[j]>=arr[i]: break\n        res = max(res,bfs(arr,j,d,memo)+1)\n        \n    #print(i,res)\n           \n    memo[i] = res\n    return res\n\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        memo = dict()\n        return max( bfs(arr,i,d,memo) for i in range(len(arr)) )       \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        N = len(arr)\n        dp = [None] * N\n        def cdp(i):\n            if dp[i]:\n                return dp[i]\n            dp[i]=1\n            for j in range(i-1, max(0, i-d)-1, -1):\n                if arr[j] >= arr[i]:\n                    break\n                dp[i] = max(dp[i] , 1 + cdp(j))\n            for j in range(i+1, min(N-1, i+d)+1, +1):\n                if arr[j] >= arr[i]:\n                    break\n                dp[i] = max(dp[i] , 1 + cdp(j))\n            return dp[i]\n        for i in range(N):\n            cdp(i)\n        return max(dp)\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        dp = [1 for i in range(n)]\n        \n        @lru_cache(None)\n        def rec(i):\n            j=1\n            while(j<=d and i-j>=0 and arr[i-j]<arr[i]):\n                dp[i] = max(dp[i], 1+rec(i-j))\n                j += 1\n                \n            j=1\n            while(j<=d and i+j<n and arr[i+j]<arr[i]):\n                dp[i] = max(dp[i], 1+rec(i+j))\n                j += 1\n            return dp[i]\n        for k in range(n): rec(k)\n        return max(dp)\n        \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        res = [1] * n\n        for a, i in sorted([a, i] for i, a in enumerate(arr)):\n            for di in [-1, 1]:\n                for j in range(i + di, i + d * di + di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]):\n                        break\n                    res[i] = max(res[j] + 1, res[i])\n        return max(res)", "class Solution:\n  def maxJumps(self, arr: List[int], d: int) -> int:\n    # stack, TC: O(N), SC: O(N).\n    A, n = arr, len(arr)\n    # stack is index with decreasing of values, pending jumpping from right, being popped when meet next wall on right.\n    s, stack = [1] * (n + 1), []\n    for i, x in enumerate(A + [float('inf')]):\n      while stack and A[stack[-1]] < x:\n        queue = [stack.pop()]\n        while stack and A[stack[-1]] == A[queue[-1]]:\n          queue.append(stack.pop())\n        # j is min between stack[-1] and i, reverse jump up to stack[-1] and i\n        for j in queue:\n          if i - j <= d:\n            s[i] = max(s[i], s[j] + 1)\n          if stack and j - stack[-1] <= d:\n            s[stack[-1]] = max(s[stack[-1]], s[j] + 1)\n      stack.append(i)\n    return max(s[:-1])", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        visited = {}\n        arrLen = len(arr)\n        \n        def check(i0):\n            if i0 in visited:\n                return visited[i0]\n            di = 1\n            preV = 0\n            subAns = 1\n            while di <= d and i0+di < arrLen and arr[i0+di] < arr[i0]:\n                if arr[i0+di] >= preV:\n                    subAns = max(subAns, 1 + check(i0 + di))\n                preV = max(preV, arr[i0+di])\n                di += 1\n\n            di = 1\n            preV = 0\n            while di <= d and i0-di >= 0 and arr[i0-di] < arr[i0]:\n                if arr[i0-di] >= preV:\n                    subAns = max(subAns, 1 + check(i0 - di))\n                preV = max(preV, arr[i0-di])\n                di += 1\n\n            visited[i0] = subAns\n            return subAns\n        \n        ans = 1\n        for i in range(arrLen):\n            ans = max(ans, check(i))\n        \n        # print(visited)\n        \n        return ans", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        N = len(arr)\n        dp = [None]* N\n        def cdp(i):\n            if dp[i] != None:\n                return dp[i]\n            dp[i] = 1\n            for j in range(i-1, max(0,i-d)-1,-1):\n                if arr[j]>= arr[i]:\n                    break\n                dp[i] = max(dp[i] , 1+cdp(j))\n            for j in range(i+1, min(N-1,i+d)+1):\n                if arr[j]>= arr[i]:\n                    break\n                dp[i] = max(dp[i] , 1+cdp(j))\n            return dp[i]\n        for i in range(N):\n            cdp(i)\n        return max(dp)\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        res = 0\n        n = len(arr)\n        self.m = [0] * n\n        \n        for i in range(n):\n            ans = self.dfs(arr, d, i)\n            res = max(ans, res)\n        return res\n    \n    \n    def dfs(self, arr, d, i):\n        res = 1\n        if self.m[i] != 0:\n            return self.m[i]\n        \n        for k in range(1, d+1):\n            if i + k >= len(arr):\n                break\n            if arr[i+k] >= arr[i]:\n                break\n            ans = self.dfs(arr, d, i+k) + 1\n            if ans > res:\n                res = ans\n\n        for k in range(1, d+1):\n            if i - k < 0:\n                break\n            if arr[i-k] >= arr[i]:\n                break\n            ans = self.dfs(arr, d, i-k) + 1\n            if ans  > res:\n                res = ans \n        self.m[i] = res\n        return res", "class Solution:\n    def maxJumps(self, A: List[int], d: int) -> int:\n        n = len(A)\n        dp = [1] * n\n        for a, i in sorted([a, i] for i, a in enumerate(A)):\n            j = i - 1\n            while j >= 0 and A[j] < A[i] and i - j <= d:\n                dp[i] = max(dp[i], dp[j] + 1)\n                j -= 1\n            j = i + 1\n            while j < n and A[j] < A[i] and j - i <= d:\n                dp[i] = max(dp[i], dp[j] + 1)\n                j += 1\n        return max(dp)", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        if(n<=1):\n            return n\n        visited = [False for i in range(n)]\n        L_neighbor = {}\n        R_neighbor = {}\n        #limit = {}\n        \n        for i in range(n):\n            L_neighbor[i] = i\n            R_neighbor[i] = i\n            \n        dec = deque()\n        dec.append(0)\n        for i in range(1, n):\n            while(len(dec)>0):\n                if(dec[0]<i-d):\n                    dec.popleft()\n                else:\n                    break\n            while(len(dec)>0):\n                if(arr[dec[len(dec)-1]]<arr[i]):\n                    dec.pop() \n                else:\n                    break\n            if(len(dec)==0):\n                L_neighbor[i] = max(i-d, 0)\n                dec.append(i)\n            else:\n                L_neighbor[i] = max(dec[len(dec)-1]+1, i-d, 0)\n                dec.append(i)\n        \n        dec = deque()\n        dec.append(n-1)\n        for i in range(n-2, -1, -1):\n            while(len(dec)>0):\n                if(dec[0]>i+d):\n                    dec.popleft()\n                else:\n                    break\n            \n            while(len(dec)>0):\n                if(arr[dec[len(dec)-1]]<arr[i]):\n                    dec.pop()\n                else:\n                    break\n            if(len(dec)==0):\n                R_neighbor[i] = min(i+d, n-1)\n                dec.append(i)\n            else:\n                R_neighbor[i] = min(dec[len(dec)-1]-1, i+d, n-1)\n                dec.append(i)\n        res = 0\n        limit = [0 for i in range(n)]\n        \n        for i in range(n):\n            self.maxJumpDFS(i, arr, L_neighbor, R_neighbor, visited, limit)\n        \n        for i in range(n):\n            if(res<limit[i]):\n                res = limit[i]\n        \n        return res\n      \n    \n    def maxJumpDFS(self, start, arr, L_neighbor, R_neighbor, visited, limit):\n        if(visited[start]):\n            return limit[start]\n        else:\n            currmax = 0\n            for i in range(L_neighbor[start], R_neighbor[start]+1):\n                if(i==start):\n                    continue\n                curr = self.maxJumpDFS(i, arr, L_neighbor, R_neighbor, visited, limit)\n                if(currmax<curr):\n                    currmax = curr\n            visited[start] = True\n            limit[start] = currmax + 1\n            return limit[start]\n                \n                \n            \n        \n        \n        \n        \n        \n        \n        \n        \n                \n", "class Solution:\n    \n    def maxJumps(self, arr: List[int], d: int) -> int:\n        maxPath = 0\n        memory = {i:0 for i in range(len(arr))}\n        for i in range(len(arr)):\n            maxPath = max(maxPath, self.dfs(i, d, arr, len(arr), memory))\n        return maxPath\n    def dfs(self, index, d, arr, arrLen, memory):\n        if memory[index] != 0:\n            return memory[index]\n        \n        currentMax = 0\n        for i in range(index+1, index +d +1):\n            if i >= arrLen or arr[index] <= arr[i]:\n                break\n            currentMax = max(currentMax, self.dfs(i, d, arr, arrLen, memory))\n        \n        for i in range(index-1, index - d - 1, -1):\n            if i < 0 or arr[index] <= arr[i]:\n                break\n            currentMax = max(currentMax, self.dfs(i, d, arr, arrLen, memory))\n            \n        memory[index] = currentMax+1\n        return memory[index] \n    \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        i2h = {}\n        for i, h in enumerate(arr):\n            i2h[i] = (h, i)\n        dp = [1] * n\n        for h, idx in sorted(i2h.values(), key=lambda hi: hi[0]):\n            j = idx + 1\n            while j <= min(n - 1, idx + d) and arr[idx] > arr[j]:\n                dp[idx] = max(dp[idx], dp[j] + 1)\n                j += 1\n            j = idx - 1\n            while j >= max(0, idx - d) and arr[idx] > arr[j]:\n                dp[idx] = max(dp[idx], dp[j] + 1)\n                j -= 1     \n        return max(dp)\n            \n    def maxJumps__(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        memo = [0] * n\n        def dfs(idx):\n            if memo[idx]: return memo[idx]\n            jump = 1\n            j = idx + 1\n            while j <= min(n - 1, idx + d) and arr[idx] > arr[j]:\n                jump = max(jump, dfs(j) + 1)\n                j += 1\n            j = idx - 1\n            while j >= max(0, idx - d) and arr[idx] > arr[j]:\n                jump = max(jump, dfs(j) + 1)\n                j -= 1\n            memo[idx] = jump\n            return jump\n        max_val = 0\n        for i in range(n):\n            max_val = max(max_val, dfs(i))\n        return max_val\n        \n    def maxJumps_(self, arr: List[int], d: int) -> int:\n        def backtracking(idx):\n            nonlocal memo, max_val\n            if idx in memo: return memo[idx]\n            lstack = []\n            rstack = []\n            lbarrier = False\n            rbarrier = False\n            for i in range(1, d + 1):\n                if not lbarrier and idx - i >= 0 and arr[idx - i] < arr[idx]:\n                    lstack.append(idx - i)\n                else:\n                    lbarrier = True\n                if not rbarrier and idx + i < len(arr) and arr[idx + i] < arr[idx]:\n                    rstack.append(idx + i)\n                else:\n                    rbarrier = True\n            # if idx == 10: print(lstack, rstack)\n            ljump = 1\n            while lstack:\n                lidx = lstack.pop()\n                ljump = max(ljump, 1 + backtracking(lidx))\n            rjump = 1\n            while rstack:\n                ridx = rstack.pop()\n                rjump = max(rjump, 1 + backtracking(ridx))\n            jump = max(ljump, rjump)\n            memo[idx] = jump\n            max_val = max(max_val, jump)\n            return jump\n        memo = {}\n        max_val = 0\n        for i in range(len(arr)):\n            backtracking(i)\n            \n        return max_val", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        # dp\n        n = len(arr)\n        res = [0] * n\n        def dp(i):\n            if res[i]:\n                return res[i]\n            res[i] = 1\n            for di in [-1, 1]:\n                for j in range(i+di, i+d*di+di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]):\n                        break\n                    res[i] = max(res[i], dp(j) + 1)\n            return res[i]\n        return max(map(dp, range(n)))", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        arr.append(10 ** 6)\n        n = len(arr)\n        dp = [1] * n\n        stack = []\n        result = 0\n        for i, a in enumerate(arr):\n            while stack and arr[stack[-1]] < a:\n                for j in range(len(stack) - 2, -1, -1):\n                    if arr[stack[j]] != arr[stack[j + 1]]:\n                        break\n                else:\n                    j = -1\n                for k in range(len(stack) - j - 1):\n                    l = stack.pop()\n                    if i - l <= d:\n                        dp[i] = max(dp[i], 1 + dp[l])\n                    if j >= 0 and l - stack[j] <= d:\n                        dp[stack[j]] = max(dp[stack[j]], 1 + dp[l])\n            stack.append(i)\n        dp.pop()\n        return max(dp)\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        N = len(arr)\n        dp = [None]*N\n        def cdp(i):\n            if dp[i]:\n                return dp[i]\n            dp[i]=1\n            for j in range(i-1,max(0, i-d)-1, -1):\n                if arr[j]>=arr[i]:\n                    break\n                dp[i] = max(dp[i], 1+cdp(j))    \n                \n            for j in range(i+1,min(N-1, i+d)+1):\n                if arr[j]>=arr[i]:\n                    break\n                dp[i] = max(dp[i], 1+cdp(j))    \n            return dp[i]\n        \n        for i in range(N):\n            cdp(i)\n        return max(dp)\n", "\n# 1340. Jump Game V\n\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        n = len(arr)\n        res = [0] * n\n        \n        def dp(i):\n            if res[i]: return res[i]\n            res[i] = 1\n            for di in [-1, 1]:\n                for j in range(i+di, i+di+d*di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]):\n                        break \n                    res[i] = max(res[i], dp(j)+1)\n            return res[i]\n        \n        return max(list(map(dp, list(range(n))))) \n    \n    # range(0, n) as input of dp func, then get the max of their results\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        jumps = [1] * n\n        \n        def get_neighs(cur):\n            neighs = []\n            directions = [1, -1]\n            for dire in directions:\n                for i in range(cur + dire, cur + (d + 1) * dire, dire):\n                    if i < 0 or i >= n:\n                        break\n                    if arr[i] >= arr[cur]:\n                        break\n                    neighs.append(i)\n            return neighs\n        \n        @lru_cache(None)\n        def dp(cur):\n            for neigh in get_neighs(cur):\n                jumps[cur] = max(jumps[cur], dp(neigh) + 1)\n            return jumps[cur]\n        \n        for i in range(len(arr)):\n            dp(i)\n        return max(jumps)", "class Solution:\n    \n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        n = len(arr)\n        res = [0] * n\n        \n        def dp(i):\n            if res[i]: return res[i]\n            res[i] = 1\n            for di in [-1, 1]:\n                for j in range(i+di, i+di+d*di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]):\n                        break \n                    res[i] = max(res[i], dp(j)+1)\n            return res[i]\n        \n        return max(map(dp, range(n)))", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n\n        # do a DFS with memorization\n        m = len(arr)\n        memo = [-1 for _ in range(m)]\n\n        def dfs(i):\n            if memo[i] != -1:\n                return memo[i]\n\n            memo[i] = 1\n            left = i - 1\n            while left >= 0 and i - left <= d and arr[left] < arr[i]:\n                memo[i] = max(dfs(left) + 1, memo[i])\n                left -= 1\n\n            right = i + 1\n            while right < m and right - i <= d and arr[right] < arr[i]:\n                memo[i] = max(dfs(right) + 1, memo[i])\n                right += 1\n            \n            return memo[i]\n        \n        for i in range(m):\n            # print(memo)\n            dfs(i)\n        \n        print(memo)\n        return max(memo)", "\n# 1340. Jump Game V\n\nclass Solution:\n    # Time complexity O(ND)\n    # Space complexity O(N) for dp\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        n = len(arr)\n        res = [0] * n\n        \n        def dp(i):\n            if res[i]: return res[i]\n            res[i] = 1\n            for di in [-1, 1]:\n                for j in range(i+di, i+di+d*di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]):\n                        break \n                    res[i] = max(res[i], dp(j)+1)\n            return res[i]\n        \n        return max(list(map(dp, list(range(n))))) \n    \n    # range(0, n) as input of dp func, then get the max of their results\n", "# Oct 5, while preparing for Microsoft\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        if not arr:\n            return 0\n\n        result = [0] * len(arr)\n\n        def _helper(i: int) -> int:\n            if result[i]:\n                return result[i]\n\n            result[i] = 1\n\n            j = 1\n            while j <= d and i + j < len(arr) and arr[i + j] < arr[i]:\n                result[i] = max(result[i], _helper(i + j) + 1)\n                j += 1\n\n            j = 1\n            while j <= d and i - j >= 0 and arr[i - j] < arr[i]:\n                result[i] = max(result[i], _helper(i - j) + 1)\n                j += 1\n\n            return result[i]\n\n        for i in range(len(arr)):\n            _helper(i)\n\n        return max(result)\n", "\n# 1340. Jump Game V\n\nclass Solution:\n    \n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        n = len(arr)\n        res = [0] * n\n        \n        def dp(i):\n            if res[i]: return res[i]\n            res[i] = 1\n            for di in [-1, 1]:\n                for j in range(i+di, i+di+d*di, di):\n                    if not (0 <= j < n and arr[j] < arr[i]):\n                        break \n                    res[i] = max(res[i], dp(j)+1)\n            return res[i]\n        \n        return max(map(dp, range(n)))", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        @lru_cache(None)\n        def helper(idx):\n            ans = 1\n            ub, lb = 1 , 1\n            while ub <= d or lb <= d:\n                if idx + ub < len(arr) and arr[idx + ub] < arr[idx]:\n                    ans = max(ans, 1 + helper(idx + ub))\n                    ub += 1\n                else: ub = sys.maxsize\n                if idx - lb >= 0 and arr[idx - lb] < arr[idx]:\n                    ans = max(ans, 1 + helper(idx - lb))\n                    lb += 1\n                else: lb = sys.maxsize\n            return ans\n        return max([helper(idx) for idx in range(len(arr))])", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        arr1=[[i,v]  for i,v in enumerate(arr)]\n        arr1.sort(key=lambda x:x[1])\n        dp=[0]*len(arr)\n        def dfs(start,arr,dp):\n            if dp[start]!=0:\n                return dp[start]\n            dp[start]=1\n            for i in range(start-1,max(start-d-1,-1),-1):\n                if arr[start]<=arr[i]:\n                    break\n                dp[start]=max(dp[start],dfs(i,arr,dp)+1)\n            for i in range(start+1,min(start+d+1,len(arr))):\n                if arr[start]<=arr[i]:\n                     break\n                dp[start]=max(dp[start],dfs(i,arr,dp)+1)\n            return dp[start]\n            \n        for i in range(len(arr1)):\n            dfs(arr1[i][0],arr,dp)\n        return max(dp)", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        max_less_than=[]\n        def jump(iter):\n            res=[None for i in range(len(arr))]\n            stack=deque([]) # stack\u91cc\u7684\u5143\u7d20\u8981\u4e48\u5927\uff0c\u8981\u4e48\u65b0\n            for i in iter:\n                while stack and abs(i-stack[0])>d: # \u6e05\u7a7a\u8303\u56f4\u4e4b\u5916\u7684\n                    stack.popleft()\n                while stack and arr[i]>arr[stack[-1]]: \n                    latest_poped=stack.pop()\n                    res[latest_poped]=i\n                stack.append(i)\n            return res\n        max_less_than.append(jump(range(len(arr))))\n        max_less_than.append(jump(reversed(range(len(arr)))))   \n        @lru_cache(None)\n        def dp(i):\n            if i is None:\n                return 0\n            return max(map(dp,[max_less_than[0][i],max_less_than[1][i]]),default=0)+1\n        return max(map(dp,range(len(arr))))", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        memo = [0] * len(arr)\n        def jump(i):\n            if memo[i]:\n                return memo[i]\n            ans = 1\n            for di in [-1,1]:\n                for x in range(1,d+1):\n                    j = di *x +i\n                    if 0 <= j <len(arr) and arr[j] < arr[i]:\n                        ans = max(ans, jump(j)+1)\n                    else:\n                        break\n            memo[i] = ans\n            return memo[i]\n        ans= 0\n        for i in range(len(arr)):\n            ans =max(ans, jump(i))\n        return ans\n", "from functools import lru_cache\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        @lru_cache(None)\n        def jump(idx):\n            \n            l, r = idx-1, idx+1\n            ans, lans, rans = 1, 0, 0\n            \n            while l >= max(idx-d, 0) and arr[idx] > arr[l]:\n                lans = max(lans, jump(l))\n                l -= 1\n            \n            while r <= min(len(arr)-1, idx+d) and arr[idx] > arr[r]:\n                rans = max(rans, jump(r))\n                r += 1\n            \n            return ans + max(rans, lans)\n        \n        ans = 0\n        for i in range(len(arr)):\n            ans = max(ans, jump(i))\n        return ans", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        def helper(i):\n            if cache[i]:\n                return cache[i]\n            # go right\n            numberOfJump = 0\n            for j in range(i + 1, i + d + 1):\n                if j >= len(arr) or arr[j] >= arr[i]:\n                    break\n                numberOfJump = max(helper(j), numberOfJump)\n            for j in range(i - 1, i - d - 1, -1):\n                if j < 0 or arr[j] >= arr[i]:\n                    break\n                numberOfJump = max(helper(j), numberOfJump)\n\n            cache[i] = 1 + numberOfJump\n            return cache[i]\n\n        cache = [0] * len(arr)\n        ans = 0\n        for i in range(len(arr)):\n            ans = max(helper(i), ans)\n        return ans\n\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        dp = [0] * len(arr)\n        def get_dp(i):\n            if dp[i] == 0:\n                dp[i] = 1\n                j = i-1\n                while j >= 0 and arr[i] > arr[j] and i-j <= d:\n                    dp[i] = max(dp[i], 1+get_dp(j))\n                    j -= 1\n                j = i+1\n                while j < len(arr) and arr[i] > arr[j] and j-i <= d:\n                    dp[i] = max(dp[i], 1+get_dp(j))\n                    j += 1\n            return dp[i]\n        max_count = 0\n        for i in range(len(arr)):\n            max_count = max(max_count, get_dp(i))\n        return max_count\n                    \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        memo = [-1] * len(arr)        \n        def dfs(i):\n            if i < 0 or i >= len(arr):\n                return 0\n            \n            if memo[i] > 0:\n                return memo[i]\n            \n            memo[i] = 1\n            for j in reversed(list(range(max(0, i - d), i))):\n                if arr[j] >= arr[i]:\n                    break\n                memo[i] = max(memo[i], dfs(j) + 1)\n                \n            for j in range(i + 1, min(len(arr), i + d + 1)):\n                if arr[j] >= arr[i]:\n                    break\n                memo[i] = max(memo[i], dfs(j) + 1)\n            \n            return memo[i]\n        \n        return max(dfs(i) for i in range(len(arr)))\n                \n            \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        dp = {}\n        \n        def jump(i):\n            \n            if i in dp:\n                return dp[i]\n            \n            m = 1\n            step = 1\n            while i + step < len(arr) and step <= d:\n                if arr[i] <= arr[i + step]:\n                    break\n                m = max(m, jump(i + step) + 1)\n                step += 1\n         \n            step = 1\n            while i - step >= 0 and step <= d:\n                if arr[i] <= arr[i - step]:\n                    break\n                m = max(m, jump(i - step) + 1)\n                step += 1\n            \n            dp[i] = m\n            return m\n        \n        ans = 0\n        for i in range(len(arr)):\n            if i not in dp:\n                jump(i)\n            ans = max(ans, dp[i])\n        return ans", "from functools import lru_cache\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        canJumpRight = collections.defaultdict(set)\n        deque = collections.deque()\n        for i in range(n):\n            # print(deque)\n            if not deque:\n                deque.append(i)\n            else:\n                if arr[i] < arr[deque[-1]]:\n                    deque.append(i)\n                else:\n                    temp = collections.deque()\n                    while deque and arr[deque[-1]] <= arr[i]:\n                        curr = deque.pop()\n                        # print('pop', curr, deque and i - deque[-1] <= d)\n                        if deque and curr - deque[-1] <= d:\n                            canJumpRight[deque[-1]].add(curr)\n                            for idx in canJumpRight[curr]:\n                                if idx-deque[-1]<=d:\n                                    canJumpRight[deque[-1]].add(idx)\n                    deque.append(i)\n        while deque:\n            curr = deque.pop()\n            if deque and curr - deque[-1] <= d:\n                canJumpRight[deque[-1]].add(curr)\n                for idx in canJumpRight[curr]:\n                    if idx-deque[-1]<=d:\n                        canJumpRight[deque[-1]].add(idx)\n                # canJump[deque[-1]].update(canJumpRight[curr])\n        canJumpLeft = collections.defaultdict(set)\n        for i in range(n-1, -1, -1):\n            if not deque:\n                deque.append(i)\n            else:\n                if arr[i] < arr[deque[-1]]:\n                    deque.append(i)\n                else:\n                    while deque and arr[deque[-1]] <= arr[i]:\n                        curr = deque.pop()\n                        if deque and abs(curr - deque[-1]) <= d:\n                            canJumpLeft[deque[-1]].add(curr)\n                            for idx in canJumpLeft[curr]:\n                                if abs(idx-deque[-1])<=d:\n                                    canJumpLeft[deque[-1]].add(idx)\n                    deque.append(i)\n        while deque:\n            curr = deque.pop()\n            if deque and abs(curr - deque[-1]) <= d:\n                canJumpLeft[deque[-1]].add(curr)\n                for idx in canJumpLeft[curr]:\n                    if abs(idx-deque[-1])<=d:\n                        canJumpLeft[deque[-1]].add(idx)\n        res = 0\n        arr_set = collections.defaultdict(set)\n        for i in range(n):\n            arr_set[i] = canJumpLeft[i]|canJumpRight[i]\n        res = 0\n        @lru_cache(None)\n        def dfs(curr):\n            nonlocal res\n            if curr not in arr_set:\n                return 1\n            local = 0\n            for ne in arr_set[curr]:\n                local = max(local, dfs(ne))\n            res = max(res, local+1)\n            return local+1\n        for i in range(n):\n            dfs(i)\n        return res\n        \n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        dp = [1] * n\n        for a,i in sorted([a,i] for i,a in enumerate(arr)):\n            for di in [-1,1]:\n                for j in range(i+di, i+d*di+di,di):\n                    if 0 <= j <n and arr[j] < arr[i]:\n                        dp[i] = max(dp[i],dp[j]+1)\n                    else:\n                        break\n        return max(dp)\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        memo = [0] * n\n        def dfs(idx):\n            if memo[idx]: return memo[idx]\n            jump = 1\n            j = idx + 1\n            while j <= min(n - 1, idx + d) and arr[idx] > arr[j]:\n                jump = max(jump, dfs(j) + 1)\n                j += 1\n            j = idx - 1\n            while j >= max(0, idx - d) and arr[idx] > arr[j]:\n                jump = max(jump, dfs(j) + 1)\n                j -= 1\n            memo[idx] = jump\n            return jump\n        max_val = 0\n        for i in range(n):\n            max_val = max(max_val, dfs(i))\n        return max_val\n        \n    def maxJumps_(self, arr: List[int], d: int) -> int:\n        def backtracking(idx):\n            nonlocal memo, max_val\n            if idx in memo: return memo[idx]\n            lstack = []\n            rstack = []\n            lbarrier = False\n            rbarrier = False\n            for i in range(1, d + 1):\n                if not lbarrier and idx - i >= 0 and arr[idx - i] < arr[idx]:\n                    lstack.append(idx - i)\n                else:\n                    lbarrier = True\n                if not rbarrier and idx + i < len(arr) and arr[idx + i] < arr[idx]:\n                    rstack.append(idx + i)\n                else:\n                    rbarrier = True\n            # if idx == 10: print(lstack, rstack)\n            ljump = 1\n            while lstack:\n                lidx = lstack.pop()\n                ljump = max(ljump, 1 + backtracking(lidx))\n            rjump = 1\n            while rstack:\n                ridx = rstack.pop()\n                rjump = max(rjump, 1 + backtracking(ridx))\n            jump = max(ljump, rjump)\n            memo[idx] = jump\n            max_val = max(max_val, jump)\n            return jump\n        memo = {}\n        max_val = 0\n        for i in range(len(arr)):\n            backtracking(i)\n            \n        return max_val", "import functools\n\nclass Solution:\n    def maxJumps(self, A, d):\n        N = len(A)\n        graph = collections.defaultdict(list)\n        \n        def jump(iterator):\n            stack = []\n            for i in iterator:\n                while stack and A[stack[-1]] < A[i]:\n                    j = stack.pop()\n                    if abs(i - j) <= d: graph[j].append(i)\n                stack.append(i)\n        \n        jump(range(N))\n        jump(reversed(range(N)))\n        \n        @functools.lru_cache(maxsize=None)\n        def height(i):\n            return 1 + max(map(height, graph[i]), default=0)\n        \n        return max(map(height, range(N)))", "class Solution:\n    def maxJumps(self, arr: List[int], dis: int) -> int:\n        res = 1\n        d = dict()\n        visit = set()\n        \n        if len(arr) == 1:\n            return 1\n        \n        for i in range(len(arr)):\n            if i == 0:\n                if arr[i] <= arr[i+1]:\n                    d[i] = 1\n                    visit.add(i)\n            elif i == len(arr) - 1:\n                if arr[i] <= arr[i-1]:\n                    d[i] = 1\n                    visit.add(i)\n            else:\n                if arr[i] <= arr[i-1] and arr[i] <= arr[i+1]:\n                    d[i] = 1\n                    visit.add(i)\n        \n        def dfs(index):\n            if index not in visit:\n                visit.add(index)\n                cur = 1\n                for i in range(1, dis+1):\n                    if index - i >= 0 and arr[index-i] < arr[index]:\n                        temp = dfs(index-i)\n                        d[index-i] = temp\n                        cur = max(cur, 1 + temp)\n                    else:\n                        break\n                for i in range(1, dis+1):\n                    if index + i < len(arr) and arr[index+i] < arr[index]:\n                        temp = dfs(index+i)\n                        d[index+i] = temp\n                        cur = max(cur, 1 + temp)\n                    else:\n                        break\n                return cur\n            else:\n                return d[index]      \n        \n        for x in range(len(arr)):\n            if x not in visit:\n                cur = dfs(x)\n                d[x] = cur\n                res = max(res, cur)\n            else:\n                res = max(res, d[x])\n        \n        return res", "class Solution:\n    def rec(self, v):\n        if self.memo[v]!=-1:\n            return self.memo[v]\n    \n        res = 1\n        \n        for nv in self.G[v]:\n            res = max(res, 1+self.rec(nv))\n        \n        self.memo[v] = res\n        return res\n    \n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        self.G = [[] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(i-1, i-d-1, -1):\n                if j<0 or arr[j]>=arr[i]:\n                    break\n                self.G[i].append(j)\n        \n            for j in range(i+1, i+d+1):\n                if j>=n or arr[j]>=arr[i]:\n                    break\n                self.G[i].append(j)\n        \n        self.memo = [-1]*n\n        ans = 0\n        \n        for i in range(n):\n            ans = max(ans, self.rec(i))\n        \n        return ans", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        ans = dict()\n        \n        def dfs(idx):\n            if idx in ans:\n                return\n            ans[idx] = 1\n            \n            i = idx - 1\n            while i >= 0 and idx - i <= d and arr[i] < arr[idx]:\n                dfs(i)\n                ans[idx] = max(ans[idx], ans[i]+1)\n                i -= 1\n            \n            i = idx + 1\n            while i < len(arr) and i - idx <= d and arr[i] < arr[idx]:\n                dfs(i)\n                ans[idx] = max(ans[idx], ans[i]+1)\n                i += 1\n        \n        for i in range(len(arr)):\n            dfs(i) \n        print(ans)\n        return max(ans.values())", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        memo = {}\n        def solve(i):\n            if i in memo:\n                return memo[i]\n            \n            ret = 1\n            j = i-1\n            while j>=max(0, i-d) and arr[j] < arr[i]:\n                ret = max(ret, 1+solve(j))\n                j -= 1\n            j = i+1\n            while j<=min(len(arr)-1, i+d) and arr[j]<arr[i]:\n                ret = max(ret, 1+solve(j))\n                j += 1\n            memo[i] = ret\n            return ret\n        for i in range(len(arr)):\n            solve(i)\n        return max(memo.values())\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        self.memo = {}\n        self.result = 0\n        for i in range(len(arr)):\n            self.dfs(arr, i, d)\n        return self.result\n        \n    \n    def dfs(self, arr, index, d):\n        if index in self.memo:\n            return self.memo[index]\n        result = 0\n        for dir in [-1, 1]:\n            for i in range(1, d + 1):\n                j = index + i * dir\n                if 0 <= j < len(arr) and arr[index] > arr[j]:\n                    result = max(result, self.dfs(arr, j, d))\n                else:\n                    break\n        self.memo[index] = result + 1\n        self.result = max(self.result, result + 1)\n        return result + 1", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        N  = len(arr)\n        umap = [list() for i in range(N)]\n        dp = [-1 for i in range(N)]\n        \n        def dfs(idx: int) -> int:\n            if idx >= N or idx < 0:\n                return 0\n            \n            if dp[idx] != -1:\n                return dp[idx]\n            \n            curr = 0\n            for u in umap[idx]:\n                curr = max(curr, dfs(u))\n            dp[idx] = curr + 1  \n            \n            return dp[idx]\n        \n        for i in range(N):\n            minIdx = max(0, i-d)\n            maxIdx = min(N-1, i+d)\n            \n            for t in range(i-1, minIdx-1, -1):\n                if arr[i] > arr[t]:\n                    umap[i].append(t)\n                else:\n                    break\n                    \n            for t in range(i+1, maxIdx+1):\n                if arr[i] > arr[t]:\n                    umap[i].append(t)\n                else:\n                    break\n        \n        result = 0\n        for i in range(N):\n            result = max(result, dfs(i))\n            \n        return result", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        a = []\n        jump = [0]*len(arr)\n        result = 0\n        for i in range(len(arr)):\n            a.append((i,arr[i]))\n        a.sort(key = lambda x:x[1])\n        for i in range(len(arr)):\n            l = a[i][0] - 1\n            r = a[i][0] + 1\n            m = 0\n            while (l >= 0 and arr[l] < a[i][1] and a[i][0] - l <= d):\n                m = max(m,jump[l])\n                l -= 1\n            while (r < len(arr) and arr[r] < a[i][1] and r - a[i][0] <= d):\n                m = max(m, jump[r])\n                r += 1\n            jump[a[i][0]] = m + 1\n            result = max(result, m + 1)\n        return result\n", "def max_jump(a, d, memo, i):\n    if i in memo:\n        return memo[i]\n    max_ =0\n    for j in range(1, d+1):\n        if i + j>=len(a) or a[i+j] >= a[i]:\n            break\n        max_ = max(max_, max_jump(a,d,memo, i+j))\n    for j in range(1, d+1):\n        if i - j<0 or a[i-j] >= a[i]:\n            break\n        max_ = max(max_, max_jump(a,d,memo, i-j))\n    memo[i] = max_+1\n    return max_+1\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        memo = {}\n        for i in range(len(arr)):\n            max_jump(arr, d, memo, i)\n        return max(memo.values())\n", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        \n        def dp(arr,d,dic,i,n):\n            \n            if(dic[i] != None):\n                return dic[i]\n            \n            \n            maximum = 1\n            \n            upreached = False\n            downreached = False\n            \n            for p in range(1,d+1):\n                \n                if(i + p < n and not upreached):\n                    \n                    if(arr[i+p] >= arr[i]):\n                        upreached = True\n                        \n                    else:\n                        maximum = max(maximum, 1+dp(arr,d,dic,i+p,n))\n                \n                if(i-p >= 0 and not downreached):\n                    \n                    if(arr[i-p] >= arr[i]):\n                        downreached = True\n                        \n                    else:\n                        maximum = max(maximum, 1+dp(arr,d,dic,i-p,n))\n                \n                if(upreached and downreached):\n                    break\n                \n            \n            dic[i] = maximum\n            \n            return maximum\n        \n        n = len(arr)\n        \n        dic = [None]*n\n        \n        maximum = 0\n        \n        for i in range(n):\n            \n            maximum = max(maximum,dp(arr,d,dic,i,n))\n        \n        \n        return maximum", "class Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        dp = [-1 for _ in range(len(arr))]\n\n        def dp_memo(x):\n            if dp[x] != -1:\n                return dp[x]\n\n            dp[x] = 1\n            for y in range(x-1, x-d-1, -1):\n                if y < 0 or arr[y] >= arr[x]:\n                    break\n                dp[x] = max(dp[x], 1 + dp_memo(y))\n\n            for y in range(x+1, x+d+1, +1):\n                if y >= len(arr) or arr[y] >= arr[x]:\n                    break\n                dp[x] = max(dp[x], 1 + dp_memo(y))\n            return dp[x]\n\n        for i in range(len(arr)):\n            dp_memo(i)\n        print(dp)\n        return max(dp)"]