["from itertools import chain\n\ndef fit_bag(H, W, items):\n\n    def deploy(item):\n        X,Y    = len(item), len(item[0])\n        v      = (set(chain.from_iterable(item))-{0}).pop()\n        deltas = [(x,y) for x,r in enumerate(item) for y,n in enumerate(r) if n]\n        return (len(deltas), X*Y, max(X,Y), min(X,Y), X,Y,deltas,v)\n    \n    def dfs(i=0):\n        if i==len(items): yield bag\n        _,_,_,_,X,Y,deltas,v = items[i]\n        for x in range(H-X+1):\n            for y in range(W-Y+1):\n                if all(not bag[x+dx][y+dy] for dx,dy in deltas):\n                    for dx,dy in deltas: bag[x+dx][y+dy] = v\n                    yield from dfs(i+1)\n                    for dx,dy in deltas: bag[x+dx][y+dy] = 0\n    \n    bag   = [ [0]*W for _ in range(H) ]\n    items = sorted(map(deploy,items), reverse=True)\n    return next(dfs())", "def fit_bag(height: int, width: int, items: [[[int]]]) -> [[int]]:\n    \n    # sort items: largest to smallest\n    get_box_size = lambda a: len(a) * len(a[0])\n    items.sort(key=get_box_size, reverse=True)\n\n\n    def arrange(partial_bag: [[int]], ind_item: int) -> [[int]]:\n    \n        if ind_item == len(items):\n            return partial_bag\n        \n        cur_item = items[ind_item]\n        for r in range(height - len(cur_item) + 1):\n            for c in range(width - len(cur_item[0]) + 1):        \n                if fits(partial_bag, cur_item, r, c):\n                    new_bag = arrange(combine(partial_bag, cur_item, r, c) ,ind_item + 1)\n                    if new_bag: return new_bag\n        \n        \n    def fits(b1, b2, r, c) -> bool:\n        for ir in range(r, r + len(b2)):\n            for ic in range(c, c + len(b2[0])):\n                if b1[ir][ic] and b2[ir - r][ic - c]:\n                    return False\n        return True\n            \n            \n    def combine(b1, b2, r, c) -> [[int]]:\n        new_bag = []\n        for ir in range(height):\n            new_bag.append(b1[ir][:])\n        for ir in range(r, r + len(b2)):\n            for ic in range(c, c + len(b2[0])):\n                new_bag[ir][ic] += b2[ir - r][ic - c]\n        return new_bag\n    \n    \n    return arrange([[0] * width for _ in range(height)], 0)", "def fit_bag(height: int, width: int, items: List[List[List[int]]]) -> List[List[int]]:\n    result = [[0]*width for _ in range(height)]\n    \n    def check(i, j, item):\n        return not any(x and result[i+k][j+l] for k,row in enumerate(item) for l,x in enumerate(row))\n    \n    def place(i, j, item):\n        for k,row in enumerate(item):\n            for l,x in enumerate(row):\n                if x != 0:\n                    result[i+k][j+l] = x\n    \n    def remove(i, j, item, id):\n        for k,row in enumerate(item):\n            for l,x in enumerate(row):\n                if x == id:\n                    result[i+k][j+l] = 0\n    \n    def rec(item_id=0):\n        if item_id == len(items): return True\n        item = items[item_id]\n        h, w = len(item), len(item[0])\n        id = next(x for row in item for x in row if x)\n        for i in range(height-h+1):\n            for j in range(width-w+1):\n                if check(i, j, item):\n                    place(i, j, item)\n                    if rec(item_id+1): return True\n                    remove(i, j, item, id)\n        return False\n    \n    rec()\n    return result", "def ItemFitsInBag(bag, item, y0, x0):\n    for y in range(y0, y0 + len(item)):\n        for x in range(x0, x0 + len(item[0])):\n            if bag[y][x] != 0 and item[y-y0][x-x0] != 0: return False\n    return True\n\ndef removeItem(bag, item, y0, x0):\n    ID = max([max(i) for i in item])\n    for y in range(y0, y0 + len(item)):\n        for x in range(x0, x0 + len(item[0])):\n            if bag[y][x] == ID: bag[y][x] = 0\n    return bag\n\ndef FitItemInBag(bag, item, y0, x0):\n    for y in range(y0, y0 + len(item)):\n        for x in range(x0, x0 + len(item[0])):\n            if item[y-y0][x-x0] != 0: bag[y][x] = item[y-y0][x-x0]\n    return bag\n    \ndef PossibleCoords(bag, item, height, width):\n    p = []\n    itemHeight = len(item)\n    itemWidth = len(item[0])\n    for y in range(height - itemHeight + 1):\n        for x in range(width - itemWidth + 1):\n            if ItemFitsInBag(bag, item, y, x):\n                p.append([y, x])\n    return p\n\ndef Loop(bag, height, width, items, itemINDEX):\n    \n    # If the final item has been placed in the bag then end the loop\n    if itemINDEX == len(items): return bag\n      \n    # Choose item\n    item = items[itemINDEX]\n    \n    # Coordinate possibilities of item in bag\n    possibilities = PossibleCoords(bag, item, height, width)\n    \n    # Try the possible locations to place the item in the bag\n    for p in possibilities:        \n        y = p[0]\n        x = p[1]\n        \n        # Fit the item in the bag\n        bag = FitItemInBag(bag, item, y, x)\n        \n        # Trigger backtracking\n        bag = Loop(bag, height, width, items, itemINDEX + 1)\n        \n        # If the final item has been places then end the loop\n        for i in bag:\n            if max([max(i) for i in items[-1]]) in i:\n                return bag\n        \n        # Remove the item  so that it can be differently placed \n        bag = removeItem(bag, item, y, x)\n           \n    return bag\n\ndef fit_bag(height, width, items):\n    \n    # Initialize bag with zeros\n    bag = [[0] * width for i in range(height)]\n    \n    # Initialize item index\n    itemINDEX = 0\n    \n    # Begin the loop\n    bag = Loop(bag, height, width, items, itemINDEX)\n    \n    return bag", "from copy import deepcopy\n\n\ndef insertItem(bag, item, coord):\n    bag = deepcopy(bag)\n    height, width = len(item), len(item[0])\n    y, x = coord\n    for i in range(y, y + height):\n        for j in range(x, x + width):\n            if item[i - y][j - x] != 0:\n                bag[i][j] = item[i - y][j - x]\n    return bag\n\n\ndef isCorrectVariant(bag, item, coord):\n    height, width = len(item), len(item[0])\n    y, x = coord\n    for i in range(y, y + height):\n        for j in range(x, x + width):\n            if bag[i][j] and item[i - y][j - x] != 0:\n                return False\n    return True\n\n\ndef bags_variants(bag, item):\n    bags = []\n    for i in range(len(bag) - len(item) + 1):\n        for j in range(len(bag[0]) - len(item[0]) + 1):\n            if isCorrectVariant(bag, item, (i, j)):\n                bags.append(insertItem(bag, item, (i, j)))\n    return bags\n\n\ndef solve(bag, items):\n    if not items: return bag\n\n    for temp_bag in bags_variants(bag, items[0]):\n        r = solve(temp_bag, items[1:])\n        if r: return r\n\ndef fit_bag(height, width, items):\n    bag = [[0] * width for _ in range(height)]\n    return solve(bag, items)", "from copy import deepcopy\n\npieces = {}\nsolution = []\n\ndef fits_at(grid, p, y, x):\n    nonlocal pieces\n    for pos in pieces[p]:\n        py = y+pos[0]\n        if py < 0 or py >= len(grid):\n            return False\n        px = x+pos[1]\n        if px < 0 or px >= len(grid[0]):\n            return False\n        if grid[py][px] != 0:\n            return False\n    return True\n\ndef rec_solve(grid, items):\n    nonlocal pieces, solution\n    if items == [] or solution != []:\n        return\n    \n    # fit 1st piece\n    val = items[0]\n    for y in range(len(grid)):\n        for x in range(len(grid[0])):            \n            if fits_at(grid, val, y, x):\n                # piece fits\n                # place piece\n                for pos in pieces[val]:\n                    grid[y+pos[0]][x+pos[1]] = val\n                # recursive solve\n                next_list = items[1:]\n                rec_solve(grid, next_list)\n                if next_list == []:\n                    solution = deepcopy(grid)\n                    return\n                # remove piece\n                for pos in pieces[val]:\n                    grid[y+pos[0]][x+pos[1]] = 0\n            \n\ndef fit_bag(height: int, width: int, items: List[List[List[int]]]) -> List[List[int]]:\n    # make list of relative positions from an empty grid position\n    nonlocal pieces, solution\n    solution = []\n    item_ids = []\n    for item in items:\n        i = 0\n        while item[0][i] == 0:\n            i += 1        \n        anchor = [0,i]\n        val = item[0][i]\n        \n        # generate list of coordinates relative to anchor\n        rel_c = []\n        for h in range(len(item)):\n            for w in range(len(item[0])):\n                if item[h][w] != 0:\n                    newpos = [h,w-i]\n                    rel_c.append(newpos)\n        pieces[val] = rel_c\n        item_ids.append(val)\n    \n    grid = [[0 for x in range(width)] for y in range(height)]\n    rec_solve(grid, item_ids)\n    return solution\n", "def fit_bag(height: int, width: int, items: List[List[List[int]]]) -> List[List[int]]:\n    bag = [[0]*width for _ in range(height)]\n    return solve(bag, width, height, items)\n\ndef solve(bag, width, height, items):\n    if not items:\n        return bag\n    item = items[0]\n    item_width, item_height = len(item[0]), len(item)\n    for px in range(width-item_width+1):\n        for py in range(height-item_height+1):\n            new_bag = place(bag, item, item_width, item_height, px, py)\n            if not new_bag: continue\n            solution = solve(new_bag, width, height, items[1:])\n            if solution: return solution\n\ndef place(bag, item, item_width, item_height, px, py):\n    for y in range(item_height):\n        for x in range(item_width):\n            if item[y][x] and bag[py+y][px+x]:\n                return None\n    new_bag = [row.copy() for row in bag]\n    for y in range(item_height):\n        for x in range(item_width):\n            if item[y][x]:\n                new_bag[py+y][px+x] = item[y][x]\n    return new_bag", "def fit_bag(height, width, items):\n    nitems = len(items)\n    blocks = sorted([(item, sum(j != 0 for i in item for j in i)) for item in items], key=lambda x: -x[1])\n\n    def place(block_id, bag, remain):\n        if block_id >= len(blocks): return\n        item, item_size = blocks[block_id]\n        m, n = len(item), len(item[0])\n        offsets = [(i, j) for i in range(height - m + 1) for j in range(width - n + 1)]\n        values = [(i, j, c) for i, row in enumerate(item) for j, c in enumerate(row) if c != 0]\n        for dx, dy in offsets:\n            newbag = list(map(list, bag))\n            for i, j, c in values:\n                if newbag[i + dx][j + dy] == 0: newbag[i + dx][j + dy] = c\n                else: break\n            else:\n                yield newbag, remain - item_size, block_id + 1\n\n    s = [([[0] * width for i in range(height)], height * width, 0)]\n    while s:\n        current, remain, block_id = s.pop()\n        if block_id == nitems: return current\n        for v in place(block_id, current, remain):\n            s.append(v)", "import numpy as np\nfrom itertools import product\n\ndef fit_bag(h, w, items):\n    items = sorted(map(np.array, items), key=lambda i: np.prod(i.shape), reverse=True) ### sort by size(area) of array by converting each item to array and sorting by product of shape(reverse)\n    bag = np.zeros((h, w),dtype=int)# create zeros matrix of size of bag\n\n    def fit_bag_rec(bag, items, n=0):    \n        item = items[n]\n        itemH, itemW = item.shape\n        \n        for i, j in product(range(h - itemH + 1), range(w - itemW + 1)):\n        \n            if not (bag[i:i+itemH, j:j+itemW] * item).any():\n                bag[i:i+itemH, j:j+itemW] += item\n                if n == len(items) - 1: yield bag\n                else: yield from fit_bag_rec(bag, items, n + 1)\n                bag[i:i+itemH, j:j+itemW] -= item\n                \n    return next(fit_bag_rec(bag, items)).tolist()", "def coloque(bag,item,x,y):\n    for i in range(len(item)) :\n        for j in range(len(item[0])):\n            if item[i][j] != 0 : bag[y+i][x+j] = item[i][j]\n    return bag\n\ndef fit_recur(bag,items):\n    print(\"\\n\",bag)\n    item_h = len(items[0])\n    item_w = len(items[0][0])\n    \n    for y in range(len(bag)):\n        for x in range(len(bag[0])):\n            if y + item_h <= len(bag) and x + item_w <= len(bag[0]):\n                if sum([ (bag[y+i][x+j] == 0 or items[0][i][j] == 0) for i in range(item_h)  for j in range(item_w) ]) == item_h * item_w :\n                    if len(items) > 1:\n                        bag_r = []\n                        for row in bag : bag_r.append(row[:])\n                        bag_r = fit_recur(coloque(bag_r,items[0],x,y),items[1:])\n                        if type(bag_r) == list: return bag_r\n                    else: return coloque(bag,items[0],x,y)\n    \n\ndef fit_bag(height: int, width: int, items: List[List[List[int]]]) -> List[List[int]]:\n    bag = [[0 for i in range(width)] for j in range(height)]\n    \n    \n    for item in items:  # First of all, if there is a null line at the border of the item, it is deleted\n        while sum([ ite == 0 for ite in item[0] ]) == len(item[0])  : del item[0]\n        while sum([ ite == 0 for ite in item[-1] ]) == len(item[-1])  : del item[-1]\n      \n\n\n    for i in range(1,len(items)):    #We sort the items to make the algorithm more eficient\n        while i > 0 and  len(items[i]) >= len(items[i-1]) :\n            aux = items[i]\n            items[i] = items[i-1]\n            items[i-1] = aux\n            i = i-1\n            \n    print(\"\\n Sorted items:\", items , \"\\n\")  \n    \n    return fit_recur(bag[:],items)  "]