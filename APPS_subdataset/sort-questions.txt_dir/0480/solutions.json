["# https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/discuss/569521/7-python-approaches-with-Time-and-Space-analysis\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        r = min(arrLen, steps // 2 + 1)\n        dp = [0, 1]\n        for t in range(steps):\n            dp[1:] = [sum(dp[i-1:i+2]) for i in range(1, min(r+1, t+3))]\n        return dp[1] % (10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        waysDict = {}\n        return self.numWaysRec(steps, arrLen, 0, waysDict)%(10**9 + 7)\n    \n    def numWaysRec(self, steps: int, arrLen: int, currentPos: int, waysDict: dict) -> int:\n        if (steps == currentPos) or (steps == 1 and currentPos == 0):\n            return 1\n        totalWays = 0\n        for nextMove in self.validMoves(steps,currentPos,arrLen):\n            if (nextMove,steps-1) in waysDict:\n                totalWays += waysDict[(nextMove, steps-1)]\n            else:\n                result = self.numWaysRec(steps-1,arrLen,nextMove, waysDict)\n                waysDict[(nextMove,steps-1)] = result\n                totalWays += result\n        return totalWays\n            \n    #def checkTerminal(self, steps, currentPos)\n    \n    '''def validPath(self, steps: int, currentPos: int) -> bool:\n        return currentPos <= steps'''\n    \n    def updateDict(self, steps: int, currentPos: int) -> None:\n        pass\n    \n    def validMoves(self, steps: int, currentPos: int, arrLen: int) -> list:\n        validList = []\n        #Check left move\n        if (currentPos - 1 <= steps-1) and currentPos - 1 >= 0:\n            validList.append(currentPos-1)\n        #Check stay move\n        if (currentPos <= steps-1):\n            validList.append(currentPos)\n        #Check right move\n        if (currentPos+1 <= steps-1) and currentPos +1 < arrLen:\n            validList.append(currentPos+1)\n        \n        return validList\n    \n    \n    \n    \n    def numWaysTree(self, steps: int, arrLen: int) -> int:\n        pass\n    \n    def numWaysTreeRec(self, steps: int, arrLen: int, counter: list, currentPos: int) -> None:\n        if (steps == 1 and currentPos  == 0) or (steps == currentPos):\n            counter[0] += 1", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if steps is None or steps < 0 or not arrLen: return 0\n        arrLen = min(arrLen, steps + 1)\n        memo = [[0] * arrLen for _ in range(steps + 1)]\n        memo[0][0] = 1\n        for i in range(1, steps + 1):\n            for j in range(arrLen):\n                memo[i][j] += memo[i - 1][j]\n                if j > 0: memo[i][j] += memo[i - 1][j - 1]\n                if j < arrLen - 1: memo[i][j] += memo[i - 1][j + 1]\n        return memo[steps][0] % (10 ** 9 + 7)\n", "from functools import lru_cache\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        moves = [-1, 0, 1]\n        \n        @lru_cache(maxsize=2048)\n        def count(s, position=0):\n            if position < 0 or position >= arrLen:\n                return 0\n            if s == 0:\n                return 1 if position == 0 else 0\n            number_of_moves = 0\n            for delta in moves:\n                new_position = position + delta\n                number_of_moves += count(s-1, new_position)\n            return number_of_moves\n        \n        return count(steps) % (10**9 + 7)", "class Solution:\n    \n    def count_paths(self, i, s, n, memo):\n        \n        if i < 0 or i > min(n -1, s):\n            \n            return 0\n        \n        if s == 0 and i == 0:\n            \n            return 1\n        \n        if (s, i) in memo:\n            \n            return memo[(s, i)]\n        \n        else:\n            \n            memo[(s, i)] = self.count_paths(i - 1, s - 1, n, memo) + self.count_paths(i, s - 1, n, memo) + self.count_paths(i + 1, s - 1, n, memo)\n        \n        return memo[(s, i)]\n    \n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        memo = {}\n        \n        return self.count_paths(0, steps, arrLen, memo) % (10 ** 9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        n=min(arrLen,steps)\n        m= (10**9) + 7\n        dp=[[0 for i in range(n)] for i in range(steps+1)]\n        dp[0][0]=1\n        for i in range(1,steps+1):\n            for j in range(n):\n                if(j-1<0):\n                    dp[i][j]=(dp[i-1][j]+dp[i-1][j+1] ) % m\n                elif(j+1>=n):\n                    dp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%m\n                else:\n                    dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]+dp[i-1][j+1]) % m\n        return dp[steps][0]\n                    \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(arrLen, steps)\n        r = [[0] * arrLen for _ in range(steps)]\n\n        r[0][0] = 1\n        r[0][1] = 1\n        mod = 10**9 + 7\n        for t in range(steps):\n            for i in range(arrLen):\n                r[t][i] += r[t-1][i] + (r[t-1][i-1] if i > 0 else 0) + (r[t-1][i+1] if i < arrLen -1 else 0)\n#                 if i > 0:\n#                     r[t][i] += r[t-1][i-1]\n                    \n#                 if i < arrLen - 1:\n#                     r[t][i] += r[t-1][i+1]\n                    \n                r[t][i] = r[t][i] % mod\n        # print(r)\n        return r[t][0] ", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        kmod = pow(10, 9) + 7\n        arrLen = min(steps, arrLen)\n        dp = [[0] * arrLen for _ in range(steps + 1)]\n        dp[0][0] = 1\n        dirs = [0, -1, 1]\n        \n        for s in range(steps):\n            for i in range(arrLen):\n                if dp[s][i]:\n                    for d in dirs:\n                        j = i + d\n                        if j < 0 or j >= arrLen:\n                            continue\n                        dp[s + 1][j] += dp[s][i]\n            for i in range(arrLen):\n                dp[s + 1][i] %= kmod\n                \n        return dp[steps][0]\n\n                        \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        dp = {}\n        for i in range(steps+1):\n            dp[i] = defaultdict(int) \n        \n        # dp[i][j] stores the number of ways to reach index j using i steps\n        dp[1][1] += 1 # move right\n        dp[1][0] += 1 # stay\n        # cannot move left at this moment, as index j must satisfy 0 <= sums < arrLen \n        \n        for i in range(2, steps+1):\n            # index is where we are after the first i-1 steps\n            for index in dp[i-1].keys():\n                if index + 1 < arrLen: # move right  \n                    dp[i][index + 1] += dp[i-1][index]\n                \n                if index - 1 >= 0: # move left\n                    dp[i][index - 1] += dp[i-1][index]\n                \n                dp[i][index] += dp[i-1][index] # stay\n                \n        return dp[steps][0]   % (10 ** 9 + 7) ", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        right_most=min(steps+1//2,arrLen)\n        dp=[[0 for __ in range(right_most)] for _ in range(steps)]\n        for i in range(steps):\n            if i==0:\n                dp[0][0]=1\n                dp[0][1]=1\n            else:\n                for j in range(right_most):\n                    dp[i][j]=dp[i-1][j]\n                    if j>0:\n                        dp[i][j]+=dp[i-1][j-1]\n                    if j<right_most-1:\n                        dp[i][j]+=dp[i-1][j+1]\n        return dp[-1][0]%(10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(arrLen, steps // 2 + 1)\n        dp = [0] * (arrLen)\n        dp[0] = 1\n        \n        for i in range(steps):\n            dp = [(dp[x-1] if x >= 1 else 0) + dp[x] + (dp[x+1] if x + 1 < arrLen else 0) for x in range(arrLen)]\n        return dp[0] % (10**9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if steps is None or steps < 0 or not arrLen: return 0\n        arrLen = min(arrLen, steps + 1)\n        f = [[0] * arrLen for _ in range(steps + 1)]\n        f[0][0] = 1\n        for i in range(1, steps + 1):\n            for j in range(arrLen):\n                f[i][j] += f[i - 1][j]\n                if j > 0:\n                    f[i][j] += f[i - 1][j - 1]\n                if j < arrLen - 1:\n                    f[i][j] += f[i - 1][j + 1]\n        return f[steps][0] % (10 ** 9 + 7)\n", "from functools import lru_cache\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        MOD = 10**9 + 7\n        # num_ways(0, 0, 0) = 1\n        @lru_cache(maxsize=steps*arrLen) \n        def num_ways(current, target, steps):\n            if not 0 <= target < arrLen:\n                return 0\n            if steps == 0:\n                return 1 if current == target else 0\n            elif steps == 1:\n                return 1 if abs(current - target) <= 1 else 0 \n            return (num_ways(current, target, steps - 1) + num_ways(current, target - 1, steps - 1) + num_ways(current, target +1, steps - 1)) % MOD \n        \n        return num_ways(0, 0, steps)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        n = min(steps, arrLen)\n        dp = [0] * n\n        dp[0] = 1\n        for step in range(1, steps+1):\n            tmp_dp = [0] * n\n            for idx in range(n):\n                tmp_dp[idx] = sum(dp[max(0, idx-1):min(idx+1, n)+1])\n            dp = tmp_dp\n        \n        return dp[0] % (10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        self.memo = {}\n        def dfs(steps, pos):\n            if pos < 0 or pos >= arrLen or pos>steps:\n                return 0\n            \n            if steps == 0:\n                if pos == 0:\n                    return 1\n                return 0\n            \n            if self.memo.get((steps, pos), None) is not None:\n                return self.memo.get((steps, pos))\n            \n            ret = dfs(steps-1, pos-1)\n            ret = ret % (10**9+7)\n            ret += dfs(steps-1, pos)\n            ret = ret % (10**9+7)\n            ret += dfs(steps-1, pos+1)\n            ret = ret % (10**9+7)\n            \n            self.memo.update({(steps, pos): ret})\n            \n            return ret\n        \n        return dfs(steps, 0)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        dp = [[0] * min(steps+1, arrLen) for _ in range(steps+1)]\n        dp[0][0] = 1\n        m, n = len(dp), len(dp[0])\n        \n        for step in range(1, steps+1):\n            for pos in range(n):\n                dp[step][pos] += dp[step-1][pos]\n                if pos - 1 >=0:\n                    dp[step][pos] += dp[step-1][pos-1]\n                if pos + 1 < n:\n                    dp[step][pos] += dp[step-1][pos+1]\n                # for j in range(1, step+1):\n                #     if pos - j >= 0:\n                #         dp[step][pos] += dp[step-j][pos-j]\n                #     if pos + j < n:\n                #         dp[step][pos] += dp[step-j][pos+j]\n            # print(\\\"step\\\", step)\n            # print(dp[step])\n        return dp[-1][0] %(10**9+7)\n", "class Solution:\n    # 2D DP, where ways[k][i] indicates the number of ways to stay at i after k steps.\n    def numWays(self, steps: int, arrLen: int) -> int:\n        ways = [[0] * min(251, arrLen) for _ in range(steps + 1)]\n        ways[0][0] = 1  # start at index 0\n        for k in range(1, steps + 1):\n            for i in range(len(ways[k])):\n                for offset in [-1, 0, 1]:\n                    # move into pos i from left or right\n                    if 0 <= i + offset < len(ways[k]):  \n                        ways[k][i] += ways[k - 1][i + offset]\n                ways[k][i] %= 10**9 + 7\n        return ways[-1][0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        M = (10**9) + 7\n        @lru_cache(None)\n        def help(s,i):\n            if s==1: return 1 if i<=min(1,arrLen-1) else 0\n            out = help(s-1,i)\n            if i > 0: out += help(s-1,i-1) \n            if i < arrLen-1: out += help(s-1,i+1) \n            return out % M\n        return help(steps,0)", "import math\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        self.cache = {}\n        self.array_length = arrLen-1\n        \n        return self._numWays(0, steps) % (10**9 + 7)\n        \n    def _numWays(self, position, steps):\n        \n        # print(position, steps)\n        \n        if position > steps:\n            return 0\n        \n        if (position, steps) in self.cache:\n            return self.cache[(position, steps)]\n        \n        if steps == 1:\n            if position in (-1, 0, 1):\n                return 1\n            else:\n                return 0\n        options = 0\n        if position > 0:\n            options += self._numWays(position-1, steps-1)\n        if position < self.array_length:\n            options += self._numWays(position+1, steps-1)\n        options += self._numWays(position, steps-1)\n        \n        self.cache[(position, steps)] = options\n        \n        return options\n        \n        \n#         max_possible = max(steps // 2, arrLen)\n        \n#         total = 0\n#         for i in range(max_possible):\n#             # i moves to the right, i moves to the left\n#             # \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(arrLen, steps//2 + 1)\n        dp = [0] * arrLen\n        dp[0] = 1\n        for i in range(steps):\n            dp = [ (j - 1 >= 0 and dp[j-1] or 0) + dp[j] + (j + 1 < arrLen and dp[j+1] or 0) for j in range(arrLen)]\n        return dp[0] % (10**9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(arrLen, steps + 1)\n        dp = [[0] * (arrLen) for _ in range(steps)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        m = 10**9+7\n        for i in range(1, len(dp)):\n            for j in range(len(dp[0])):\n                #print([i,j])\n                if j == 0:\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j+1])% (m)\n                    #print(dp[i][j])\n                elif j == len(dp[0]) - 1:\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j-1])% (m)\n                else:\n                    dp[i][j] = (dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j-1])% (m)\n        #print(dp)\n        return dp[-1][0]\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        maxPos = min(steps, arrLen)\n        mod = 10**9+7\n        f = [[0]*maxPos for _ in range(steps+1)]\n        f[1][0] = 1\n        f[1][1] = 1\n        for i in range(2,steps+1):\n            for j in range(maxPos):\n                f[i][j] = f[i-1][j]\n                if j > 0:\n                    f[i][j] = (f[i][j] + f[i-1][j-1])%mod\n                if j < maxPos-1:\n                    f[i][j] = (f[i][j] + f[i-1][j+1])%mod\n        return f[steps][0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        mod = 10**9+7\n        arrLen = min(steps,arrLen)\n        dp = [[0]*(steps+1) for _ in range(arrLen)]\n        dp[0][0]=1\n        for j in range(1, steps+1):\n            for i in range(0, arrLen):\n                dp[i][j]=dp[i][j-1]\n                if i-1>=0:\n                    dp[i][j]+=dp[i-1][j-1]\n                if (i+1)<arrLen:\n                    dp[i][j]+=dp[i+1][j-1]\n                dp[i][j]=dp[i][j]%mod\n        return dp[0][-1]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        self.steps = steps\n        self.arrLen = arrLen\n        self.memo = {}\n        return self.dfs(steps, 0)\n        \n        \n    def dfs(self, n, pos):\n        if n == pos:\n            return 1\n        if n < pos or pos > self.arrLen - 1:\n            return 0\n        \n        if (n, pos) in self.memo:\n            return self.memo[(n, pos)]\n        \n        ans = 0\n        \n        if pos > 0:\n            ans += self.dfs(n-1, pos-1)\n        ans += self.dfs(n-1, pos)\n        \n        if pos != self.arrLen - 1:\n            ans += self.dfs(n-1, pos+1)\n            \n        ans %= 10**9 + 7\n        self.memo[(n, pos)] = ans\n        \n        return ans", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        @lru_cache(None)\n        def dp(index, steps):\n            if index < 0 or index == arrLen: # index outside arraySize\n                return 0\n            \n            if steps == 0:\n                return 1 if index == 0 else 0\n            \n            ans = 0\n            for i in range(-1, 2, 1): # try [left, stay, right]\n                ans += dp(index+i, steps - 1)\n                ans %= (10**9 + 7)\n            return ans\n        \n        return dp(0, steps)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        @lru_cache(None)\n        def dp(index, steps):\n            if index < 0 or index == arrLen: # index outside arraySize\n                return 0\n            \n            if steps == 0:\n                return index == 0\n            \n            ans = 0\n            for i in range(-1, 2, 1):\n                ans += dp(index+i, steps - 1)\n                ans %= (10**9 + 7)\n            return ans\n        \n        return dp(0, steps)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(arrLen, steps // 2 + 1)\n        dp = [0] * arrLen\n        dp[0] = 1\n        mod = 10**9 + 7\n        for i in range(steps):\n            dp = [(dp[j] + (dp[j-1] if j >= 1 else 0) + (dp[j+1] if j + 1 < arrLen else 0)) % mod for j in range(arrLen)]\n        return dp[0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.dp = collections.defaultdict(int)\n        return self.helper(0, steps, arrLen)\n        \n    def helper(self, cur, steps, n):\n        x = (pow(10,9)+7)\n        if(cur==0 and steps==0):\n            return 1\n        if(abs(cur)>steps or cur<0 or cur>=n):\n            return 0\n        if((cur,steps) in self.dp):\n            return self.dp[(cur,steps)]\n        \n        res = self.helper(cur, steps-1,n) + self.helper(cur-1, steps-1,n) + self.helper(cur+1, steps-1,n)\n        self.dp[(cur,steps)] = res %x\n        return res%x\n            \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        ans = 0\n        \n        mem = [dict() for _ in range(501)]\n        \n        def dfs(s, arrLen, pos):\n            nonlocal ans\n            if pos < 0 or pos >= arrLen:\n                return 0\n            \n            if s == 0 and pos == 0:\n                return 1\n            \n            if s < 0:\n                return 0\n            \n            if pos in mem[s]:\n                return mem[s][pos]\n            \n            s1 = dfs(s - 1, arrLen, pos)\n            s2 = dfs(s - 1, arrLen, pos + 1)\n            s3 = dfs(s - 1, arrLen, pos - 1)\n            \n            total = (s1 + s2 + s3) \n            \n            if not pos in mem[s]:\n                mem[s][pos] = total\n            \n            \n            #print(s, pos, total)\n            \n            return total\n        \n        ans = dfs(steps, arrLen, 0)\n        \n        return ans % (10**9 + 7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        def ncr(n, r, p): \n            # initialize numerator \n            # and denominator \n            num = den = 1 \n            for i in range(r): \n                num = (num * (n - i)) % p \n                den = (den * (i + 1)) % p \n            return (num * pow(den,  \n                    p - 2, p)) % p\n        \n        ans = 0\n        dp = [[0 for i in range(min(steps, arrLen))] for j in range(steps+1)]\n        \n        dp[1][1] = 1\n        \n        for k in range(2,steps+1):\n            for l in range(len(dp[k])):\n                f,b = l-1,l+1\n                if f>=0 and f<len(dp[k]): dp[k][f]+=dp[k-1][l]\n                if b>=0 and b<len(dp[k]): dp[k][b]+=dp[k-1][l]\n        \n        for numstay in range(0,steps+1):\n            numMoves = steps - numstay\n            if numMoves%2!=0: continue\n            ans += (ncr(numstay+numMoves, numstay, 1000000007) * dp[numMoves][0])%1000000007\n            #print(numstay,numMoves,ans) \n            ans = ans%1000000007\n        #print(dp)\n        return ans+1", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        # nw(s, idx): number of ways to end up at idx after s steps\n        # nw(s, idx) = s * (nw(s - 1, idx) + nw(s - 1, idx - 1) + nw(s - 1, idx + 1))\n        \n        nw = [[0 for _ in range(min(arrLen, steps + 1))] for _ in range(steps + 1)]\n        nw[0][0] = 1\n        \n        # arr  0 1\n        #    0 1 0\n        #  s 1 1 1 \n        #    2 2 2\n        #    3 4 4\n        \n        for s in range(1, steps + 1):\n            for idx in range(min(arrLen, steps + 1)):\n                ways = nw[s - 1][idx]\n                if idx > 0:\n                    ways += nw[s - 1][idx - 1]\n                if idx < min(arrLen, steps + 1) - 1:\n                    ways += nw[s - 1][idx + 1]\n                nw[s][idx] = ways\n                \n        return nw[steps][0] % (10**9 + 7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n#         def numWays(self, steps: int, arrLen: int) -> int:\n#             if steps == 0 or arrLen == 1:\n#                 return 1\n\n#             visited = {}\n#             return self.helper(0, steps, arrLen, visited) % (10 ** 9 + 7)\n\n#         def helper(self, pos, steps, n, visited):\n#             if (pos, steps) in visited:\n#                 return visited[(pos, steps)]\n#             if steps == 0:\n#                 if pos == 0:\n#                     return 1\n#                 else:\n#                     return 0\n#             if pos > steps:\n#                 return 0\n#             res = self.helper(pos, steps-1, n, visited)\n#             if 0<=pos+1<n:\n#                 res += self.helper(pos+1, steps-1, n, visited)\n#             if 0<=pos-1<n:\n#                 res += self.helper(pos-1, steps-1, n, visited) \n#             visited[(pos, steps)] = res\n#             return visited[(pos, steps)]\n\n\n        #\n        # Solution 1: DFS + dict for recording ----- 680 ms (28.33%) / 113.1 MB (7.87%)\n        # ------------------------------------------------------------------------------------------\n        cases = {}\n        def dfs(steps, pos):\n            if (steps, pos) in cases: return cases[(steps, pos)]\n            if steps == 0: return 1 if pos == 0 else 0\n            if pos >= arrLen or pos < 0: return 0\n            subcount = dfs(steps-1, pos+1) + dfs(steps-1, pos) + dfs(steps-1, pos-1)\n            cases[(steps, pos)] = subcount\n            return subcount % (10**9 + 7)\n        \n        return dfs(steps, 0)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        @lru_cache(None)\n        def simulate(currIdx, stepsTaken):\n            nonlocal arrLen\n            nonlocal steps\n            if stepsTaken == steps:\n                if currIdx == 0:\n                    return 1\n                return 0\n            \n            ret = 0\n            \n            moves = [currIdx, currIdx - 1, currIdx + 1]\n            for nextIdx in moves:\n                if nextIdx >= 0 and nextIdx < arrLen:\n                    ret += simulate(nextIdx, stepsTaken + 1)\n                    \n            return ret\n        \n        return simulate(0, 0) % (10 ** 9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        memo = collections.defaultdict(int)\n        def dfs(index, curr):\n            if curr == steps:\n                if index == 0:\n                    return 1\n                else:\n                    return 0\n            key = (index, curr)\n            if key in memo:\n                return memo[key]\n            res = 0\n            if index > 0:\n                res += dfs(index - 1, curr + 1)\n            if index < arrLen - 1:\n                res += dfs(index + 1, curr + 1)\n            res += dfs(index, curr + 1)\n            memo[key] = res\n            return res\n        \n        return dfs(0, 0) % (10 ** 9 + 7)\n", "class Solution:\n    def __init__(self):\n        self.mnem = {}\n    def numWays(self, steps: int, arrLen: int) -> int:\n        def dp(pos, steps):\n            if (pos, steps) in self.mnem:\n                return self.mnem[(pos, steps)]\n            if steps == 0:\n                return 1 if pos == 0 else 0\n            if (pos < 0):\n                return 0\n            if (pos >= arrLen):\n                return 0\n            result = dp(pos + 1, steps - 1) + dp(pos - 1, steps - 1) + dp(pos, steps - 1)\n            self.mnem[(pos, steps)] = result\n            return result\n        \n        return dp(0, steps)  % (10**9 + 7)", "class Solution:\n    \n    def __init__(self):\n        self.dp = {}\n        \n    def numWays(self, steps: int, arrLen: int, ptr: int = 0) -> int:\n        \n        return self.numWays_dp(steps, min(arrLen, steps+1), ptr) % (10**9+7)\n    \n    def numWays_dp(self, steps: int, arrLen: int, ptr: int = 0) -> int:\n        if ptr >= arrLen:\n            return 0\n        if ptr < 0:\n            return 0\n        if steps == 0:\n            if ptr == 0:\n                return 1\n            else:\n                return 0\n            \n        if (ptr, steps) in self.dp:\n            return self.dp[(ptr, steps)]\n        \n        left_ways = self.numWays(steps-1, arrLen, ptr-1)\n        middle_ways = self.numWays(steps-1, arrLen, ptr)\n        right_ways = self.numWays(steps-1, arrLen, ptr+1)\n        \n        total_ways = left_ways + middle_ways + right_ways\n        self.dp[(ptr, steps)] = total_ways\n        \n        return total_ways", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if arrLen == 1:\n            return 1\n        memo = {}\n        return self.dfs(steps, arrLen, 0, memo)\n        \n        \n    def dfs(self, steps, arrLen, currpos, memo):\n        if (steps, currpos) in memo:\n            return memo[(steps, currpos)]\n        \n        if currpos < 0 or currpos >= arrLen:\n            return 0\n        \n        if steps == 0:\n            if currpos == 0:\n                return 1\n            else:\n                return 0\n        \n        memo[(steps, currpos)] = self.dfs(steps - 1, arrLen, currpos, memo) + self.dfs(steps - 1, arrLen, currpos + 1, memo) + self.dfs(steps - 1, arrLen, currpos - 1, memo)\n        \n        return memo[(steps, currpos)] %(10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        visited = dict()\n        \n        def move(cur_index, cur_step):\n            if (cur_index, cur_step) in visited:\n                return visited[(cur_index, cur_step)]\n            if cur_index < 0 or cur_index >= arrLen:\n                visited[(cur_index, cur_step)] = 0\n                return 0\n            \n            if cur_step == steps:\n                if cur_index == 0:\n                    return 1\n                return 0\n            \n            visited[(cur_index, cur_step)] = move(cur_index+1, cur_step+1) + move(cur_index-1, cur_step+1) + move(cur_index, cur_step+1)\n            \n            return visited[(cur_index, cur_step)]\n        \n        move(0, 0)\n        \n        return move(0, 0) % ((10**9)+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(arrLen, steps + 1)\n        f = [[0] * arrLen for _ in range(steps + 1)]\n        f[0][0] = 1\n        for i in range(1, steps + 1):\n            for j in range(arrLen):\n                for k in [-1, 0, 1]:\n                    if 0 <= j - k < arrLen:\n                        f[i][j] += f[i - 1][j - k]\n        return f[steps][0] % (10**9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        MOD = 10 ** 9 + 7\n        def dp(x, s, memo):\n            if s == 0:\n                if x == 0:\n                    return 1\n                else:\n                    return 0\n            if (x, s) not in memo:\n                if x == 0:\n                    memo[(x, s)] = (dp(x + 1, s - 1, memo) + dp(x, s - 1, memo)) % MOD\n                elif x == arrLen - 1:\n                    memo[(x, s)] = (dp(x - 1, s - 1, memo) + dp(x, s - 1, memo)) % MOD\n                else:\n                    memo[(x, s)] = (dp(x + 1, s - 1, memo) + dp(x - 1, s - 1, memo) + dp(x, s - 1, memo)) % MOD\n            return memo[(x, s)]\n        \n        return dp(0, steps, {})", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if arrLen == 1: \n            return 1    \n        memo = {}\n        \n        return self.dfs(steps, arrLen, 0, memo)   \n        \n\n    def dfs(self, steps, arrLen, cur_pos, memo):\n        if (steps, cur_pos) in memo:\n            return memo[(steps, cur_pos)]\n        \n        if cur_pos < 0 or cur_pos >= arrLen:\n            return 0 \n            \n        if steps == 0:\n            if cur_pos == 0:\n                return 1\n            else:\n                return 0\n                \n        memo[(steps, cur_pos)] = self.dfs(steps-1, arrLen, cur_pos, memo) + self.dfs(steps-1, arrLen, cur_pos-1, memo) + self.dfs(steps-1, arrLen, cur_pos+1, memo)         \n        \n            \n        return  memo[(steps, cur_pos)]%(10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        dp = {}\n        def dfs(steps, ind):\n            if (steps, ind) in dp:\n                return dp[(steps, ind)]\n            if steps == ind:\n                return 1\n            elif steps == 0:\n                return 0\n            res = 0\n            res += dfs(steps-1, ind)\n            if ind > 0:\n                res += dfs(steps-1, ind-1)\n            if ind < arrLen-1:\n                res += dfs(steps-1, ind+1)\n            dp[(steps, ind)] = res\n            return res%(10**9+7)\n        return dfs(steps, 0)", "def memoize(f):\n    d = {}\n    def memoized_f(*args):\n        if args not in d:\n            d[args] = f(*args)\n        return d[args]\n    return memoized_f\n\n@memoize\ndef numWaysHelper(steps, arrLen, position):\n    if position<0 or position >= arrLen:\n        return 0\n    if steps == 0:\n        if position == 0:\n            return 1\n        return 0\n    big_num = 10 ** 9 + 7\n    return (numWaysHelper(steps-1, arrLen, position-1) + \n           numWaysHelper(steps-1, arrLen, position) +\n           numWaysHelper(steps-1, arrLen, position+1)) % big_num\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        return numWaysHelper(steps, arrLen, 0)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        mod = 10 ** 9 + 7\n        memo = {}\n        def dfs(steps, i):\n            if not steps:\n                return int(i == 0)\n            \n            if (steps, i) in memo:\n                return memo[(steps, i)]\n            \n            res = dfs(steps - 1, i)\n            if i - 1 >= 0:\n                res += dfs(steps - 1, i - 1)\n            \n            if i + 1 <= arrLen - 1:\n                res += dfs(steps - 1, i + 1)\n            \n            memo[(steps, i)] = res % mod\n            return memo[(steps, i)]\n        \n        return dfs(steps, 0)\n", "class Solution:\n    def numWays(self, s: int, a: int) -> int:\n        MOD = 1000000007\n        mem = {}\n        def f(s, a, i):\n            if (s, i) in mem:\n                return mem[(s,i)]\n            if not s:\n                if i:\n                    return 0\n                return 1\n            if i < 0 or i == a:\n                return 0\n            #if i > s:\n            #    return 0\n            ans = 0\n            #stay\n            ans += f(s-1, a, i)\n            #left\n            ans += f(s-1, a, i-1)\n            #right\n            ans += f(s-1, a, i+1)\n            \n            mem[(s,i)] = ans\n            return ans%MOD\n            \n        return f(s, a, 0)\n            \n            \n        \n            \n    \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        memo = {}\n        \n        return self.dfs(steps, arrLen, 0, memo)\n\n    def dfs(self, steps, arrLen, pos, memo):\n        if (steps, pos) in memo:\n            return memo[(steps, pos)]\n        \n        if pos < 0 or pos >= arrLen:\n            return 0\n        \n        if steps == 0:\n            return 1 if pos == 0 else 0\n        \n        memo[(steps, pos)] = self.dfs(steps - 1, arrLen, pos - 1, memo) + self.dfs(steps - 1, arrLen, pos, memo) + self.dfs(steps - 1, arrLen, pos + 1, memo)\n        \n        return memo[(steps, pos)] % (10 ** 9 + 7)\n", "MOD = int(1e9 + 7)\n\nclass Solution:\n    def get_count(self, counts, i):\n        if i < 0 or i >= len(counts):\n            return 0\n        else:\n            return counts[i]\n        \n    def numWays(self, steps: int, arrLen: int) -> int:\n        counts = [1]\n        for si in range(1, steps + 1):\n            new_len = min(si + 1, arrLen)\n            new_counts = [0] * new_len\n            for i in range(new_len):\n                new_counts[i] = sum(self.get_count(counts, j) for j in range(i - 1, i + 1 + 1)) % MOD\n            counts = new_counts\n        return counts[0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if steps is None or steps < 0 or not arrLen: return 0\n        arrLen = min(arrLen, steps)\n        memo = [[0] * arrLen for _ in range(steps + 1)]\n        memo[0][0] = 1\n        for i in range(1, steps + 1):\n            for j in range(arrLen):\n                memo[i][j] += memo[i - 1][j]\n                if j > 0: memo[i][j] += memo[i - 1][j - 1]\n                if j < arrLen - 1: memo[i][j] += memo[i - 1][j + 1]\n        return memo[steps][0] % (10 ** 9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        return self.getWays(0, steps, 0, arrLen, {})\n        \n        \n    def getWays(self, step, steps, position, arrLen, cache):\n        if step == steps: return position == 0\n        if (step, position) in cache: return cache[(step, position)]\n        numWays = 0\n        if position > 0:\n            numWays += self.getWays(step + 1, steps, position - 1, arrLen, cache)\n        if position < arrLen - 1:\n            numWays += self.getWays(step + 1, steps, position + 1, arrLen, cache)\n        numWays += self.getWays(step + 1, steps, position, arrLen, cache)\n        cache[(step, position)] = numWays\n        return numWays % (10**9 + 7)\n        \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int: \n        memo = {}\n        \n        def helper(position, num_steps, idx):\n            nonlocal steps, arrLen, memo\n            if (position, num_steps, idx) in memo:\n                return memo[(position, num_steps, idx)]\n            if idx < 0 or idx > arrLen-1:\n                return 0\n            if num_steps == steps:\n                if position == 0:\n                    return 1\n                return 0\n            stay = helper(position, num_steps+1, idx) \n            right = helper(position+1, num_steps+1, idx+1)\n            left = helper(position-1, num_steps+1, idx-1)\n            memo[(position, num_steps, idx)] = stay + left + right\n            return memo[(position, num_steps, idx)]\n        \n        return helper(0, 0, 0) % (10**9 + 7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        states = [{0: 1}, {}]\n        base = 0\n        mod = 1000000007\n        shift = [1, 0, -1]\n        for k in range(0, steps):\n            nxt = (base+1)%2\n            states[nxt].clear()\n            for p in states[base].keys():\n                for j in range(0, 3):\n                    np = p+shift[j]\n                    if 0 <= np < arrLen:\n                        if np not in states[nxt].keys():\n                            states[nxt][np] = 0\n                        states[nxt][np] = (states[nxt][np] + states[base][p]) % mod\n            base = nxt\n        return states[base][0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if not steps or steps < 0 or arrLen == 0:\n            return 0\n        memo = {}\n        return self.dfs(steps, arrLen, 0, memo)\n    \n    def dfs(self, steps, arrLen, pos, memo):\n        if (steps, pos) in memo:\n            return memo[(steps, pos)]\n        if pos < 0 or pos > arrLen - 1:\n            memo[(steps, pos)] = 0\n            return 0\n        if steps == 0:\n            return 1 if pos == 0 else 0\n        memo[(steps, pos)] = self.dfs(steps - 1, arrLen, pos - 1, memo) + self.dfs(steps - 1, arrLen, pos + 1, memo) + self.dfs(steps - 1, arrLen, pos, memo) \n        return memo[(steps, pos)] % (10**9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n#         max_position = max(steps, arrLen)\n#         dp = [[0] * (max_position + 1) for step in range(steps+1)]\n        \n#         dp[1][0] = 1\n#         dp[1][1] = 1\n        \n#         for i in range(2, steps + 1):\n#             for j in range(0, max_position):\n#                 if j > 0:\n#                     dp[i][j] = (dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j-1]) % (10 ** 9 + 7)\n#                 else:\n#                     dp[i][j] = (dp[i-1][j] + dp[i-1][j+1]) % (10 ** 9 + 7)\n        \n#         return dp[steps][0]\n\n        mod = 10 ** 9 + 7\n        n = arrLen\n        \n        A = [0, 1]\n        for t in range(steps):\n            A[1:] = [sum(A[i - 1:i + 2]) % mod for i in range(1, min(n + 1, t + 3))]\n        \n        return A[1] % mod\n#         ways = [-1, 0, 1]\n        \n#         def visit(cur_total_steps, cur_index):\n#             if cur_total_steps == steps and cur_index == 0:\n#                 self.total_ways += 1\n#                 return\n            \n#             if cur_total_steps > steps or cur_index >= arrLen:\n#                 return\n\n#             for way in ways:\n#                 if cur_index == 0 and way == -1:\n#                     continue\n                \n#                 if cur_index == arrLen - 1 and way == 1:\n#                     continue\n                \n#                 visit(cur_total_steps + 1, cur_index + way)\n        \n#         self.total_ways = 0\n#         visit(0, 0)\n        \n#         return self.total_ways % (10^9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if steps is None or steps < 0 or not arrLen:\n            return 0\n        memo = {}\n        return self.dfs(steps, arrLen, 0, memo)\n\n    def dfs(self, steps, arrLen, pos, memo):\n        if (steps, pos) in memo:\n            return memo[(steps, pos)]\n        if pos < 0 or pos > arrLen - 1:\n            memo[(steps, pos)] = 0\n            return 0\n        if steps == 0:\n            return 1 if pos == 0 else 0\n        memo[(steps, pos)] = self.dfs(steps - 1, arrLen, pos - 1, memo) + self.dfs(steps - 1, arrLen, pos, memo) + self.dfs(steps - 1, arrLen, pos + 1, memo) \n        return memo[(steps, pos)] % (10 ** 9 + 7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        mod = 10 ** 9 + 7\n        real_len = min(steps, arrLen) + 2\n        f1 = [0 for _ in range(real_len)]\n        f1[0] = 1\n        for _ in range(steps):\n            f2 = [0 for _ in range(real_len)]\n            for i in range(real_len - 1):\n                for d in [ -1, 0, 1 ]:\n                    ii = i + d\n                    if ii >= 0  and ii <= arrLen - 1:\n                        f2[i] += f1[ii] % mod\n            f1 = f2.copy()\n        \n        return f1[0] % mod\n                        \n                \n            \n", "from functools import lru_cache\nclass Solution:\n    @lru_cache(None)\n    def helper(self, index, n, arrlen):\n        if not 0<=index<arrlen or n<0 or index>n:\n            return 0\n        if index==n:\n            return 1\n        return (self.helper(index+1, n-1, arrlen) + self.helper(index-1, n-1, arrlen) + self.helper(index, n-1, arrlen)) % self.MOD\n    \n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.MOD = 10**9 + 7\n        return self.helper(0, steps, arrLen)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        def count(pos, i):\n            if i == steps: \n                return pos == 0\n            \n            if (pos, i) in memo:\n                return memo[(pos, i)]\n            res = 0\n            if pos > 0:\n                res += count(pos-1, i+1)\n                res %= mod\n            if pos < arrLen-1:\n                res += count(pos+1, i+1)\n                res %= mod\n            res%= mod\n            res += count(pos, i+1)\n            res %= mod\n                \n            memo[(pos, i)] = res\n            return res\n        \n        mod = 10**9 + 7\n        memo = {}\n        return count(0, 0)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        MOD = 10 ** 9 + 7\n        memo = {}\n        \n        def nw(i: int, k: int) -> int:\n            if k == 0:\n                return i == 0\n            if k < 0 or i < 0 or i >= arrLen:\n                return 0\n            if (i, k) not in memo:\n                memo[(i, k)] = (nw(i - 1, k - 1) + nw(i + 1, k - 1) + nw(i, k - 1)) % MOD\n            return memo[(i, k)]\n        \n        return nw(0, steps)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(steps//2+1, arrLen)\n        ans = [0]*arrLen\n        ans[0] = 1\n        for i in range(steps):\n            new_ans = []\n            for j in range(arrLen):\n                tmp = ans[j]\n                if j > 0: tmp += ans[j-1]\n                if j < arrLen-1: tmp += ans[j+1]\n                new_ans.append(tmp)\n            ans = new_ans\n        return ans[0]%(10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        memo = dict()\n        def calculateWays(steps, arrLen, index):\n            if index < 0 or index >= arrLen:\n                return 0\n            elif steps == 0 and index == 0:\n                return 1\n            elif steps == 0 and index != 0:\n                return 0\n            elif (steps, index) in memo:\n                return memo[(steps, index)]\n            else:\n                goLeft = calculateWays(steps - 1, arrLen, index - 1)\n                stay = calculateWays(steps - 1, arrLen, index)\n                goRight = calculateWays(steps - 1, arrLen, index + 1)\n                memo[(steps, index)] = goLeft + stay + goRight\n                return memo[(steps, index)]\n        \n            \n        return calculateWays(steps, arrLen, 0) % (10**9 + 7)\n", "MODULO = 10**9 + 7 \n\nclass DP:\n    def __init__(self, arrLen: int):\n        self._len = arrLen\n        self._cache = {}\n        \n    def get(self, index, steps):\n        if (index, steps) in self._cache:\n            return self._cache[(index, steps)]\n        result = self._get_uncached(index, steps)\n        # print(f\\\"index={index} steps={steps}  =>  ways={result}\\\")\n        self._cache[(index, steps)] = result\n        return result\n        \n    def _get_uncached(self, index, steps):\n        if index < 0 or index >= self._len:\n            return 0\n        if steps == 0 and index == 0:\n            return 1\n        elif steps == 0:\n            return 0\n        return (self.get(index - 1, steps - 1) + self.get(index, steps - 1) + self.get(index + 1, steps - 1)) % MODULO\n        \n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        dp = DP(arrLen)\n        return dp.get(0, steps)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.arrLen = arrLen\n        self.memo = {}\n        return self.helper(steps, 0)\n    \n    def helper(self, steps, pos):\n        if (steps, pos) in self.memo:\n            return self.memo[(steps, pos)]\n        if pos < 0 or pos >= self.arrLen or steps < 0:\n            return 0\n        if steps == 0:\n            if pos == 0:\n                return 1\n            else:\n                return 0\n        res = 0\n        for x in [-1, 0, 1]:\n            ans = self.helper(steps-1, pos+x)\n            res += ans\n            \n        self.memo[(steps, pos)] = res % (10**9 + 7)\n        return res % (10**9 + 7)\n        \n", "class Solution:\n    # \u4e86\u89e3\u548c\u5bf9\u6bd4TC\n    # dfs to find all possible way - dfs + dp: cutting rope\n    # state: remaining steps + distance \n        # - break to two parts which sum of remain steps == total steps\n        # - sum of dist <= arrLen\n        # - takes 1 extra steps to connect\n    def numWays(self, steps: int, arrLen: int) -> int:\n        # if dist == 1, combos always 1 regardless of steps\n        if arrLen == 0 or (arrLen == 1 and steps > 0):\n            return arrLen\n        combos = {} # (dist, steps): # of combos\n        \n        def _dfs_ways(steps, arrLen, loc = 0, tar = 0):\n            if steps == 0:\n                return 1 if loc == tar else 0\n            if (steps, loc) in combos: return combos[(steps, loc)]\n            steps -= 1\n            stay, right, left = 0, 0, 0\n            stay = _dfs_ways(steps, arrLen, loc)\n            if loc + 1 < arrLen: right = _dfs_ways(steps, arrLen, loc + 1)\n            if loc - 1 >= 0: left = _dfs_ways(steps, arrLen, loc - 1)\n            steps += 1\n            res = (stay + left + right) % (math.pow(10, 9) + 7)\n            combos[(steps, loc)] = res\n            return res\n        \n        # for i in range(1, min(arrLen, steps // 2) + 1):\n        #     # for combo two parts\n        #     res = 0\n        #     for div in range(1, i + 1): # divide len for dfs\n        #         for left_steps in range(1, steps):\n        #             left_ways = _dfs(left_steps, div)\n        #             right_ways = _dfs(steps - left_steps - 1, i - div)\n        #             res += left_ways * right_ways\n        #     # for whole\n        #     res += _dfs(steps, i)\n        #     combos[(steps, i)] = res\n        _dfs_ways(steps, arrLen)\n        # print(combos)\n        ans = combos[(steps, 0)]\n        return int(ans % (math.pow(10, 9) + 7))", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.arrLen = arrLen\n        self.memo = {}\n        return self.helper(steps, 0)\n    \n    def helper(self, steps, pos):\n        if (steps, pos) in self.memo:\n            return self.memo[(steps, pos)]\n        if pos < 0 or pos >= self.arrLen or steps < 0:\n            self.memo[(steps, pos)] = 0\n            return 0\n        if steps == 0:\n            if pos == 0:\n                self.memo[(steps, pos)] = 1\n                return 1\n            else:\n                self.memo[(steps, pos)] = 0\n        res = 0\n        for x in [-1, 0, 1]:\n            res += self.helper(steps-1, pos+x)\n        self.memo[(steps, pos)] = res\n        return res % (10**9 + 7)\n        \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.arrLen = arrLen\n        \n        @lru_cache(None)\n        def dp(curr, steps):\n            # print(curr, steps)\n            if steps:\n                temp = 0\n                for i in [curr-1, curr, curr+1]:\n                    if 0 <= i < self.arrLen:\n                        temp += dp(i, steps-1)\n                return temp\n            else:\n                return 1 if curr == 0 else 0\n        \n        return dp(0, steps) % (10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        # time O(n); space O(n)\n        n = min(steps, arrLen)\n        dp = [0] * n\n        dp[0] = 1\n        for step in range(1, steps+1):\n            tmp_dp = [0] * n\n            for idx in range(n):\n                tmp_dp[idx] = sum(dp[max(0, idx-1):min(idx+1, n)+1])\n            dp = tmp_dp\n        \n        return dp[0] % (10**9+7)", "class Solution:\n    # \u4e86\u89e3\u548c\u5bf9\u6bd4TC\n    # dfs to find all possible way - dfs + dp: cutting rope\n    # state: remaining steps + distance \n        # - break to two parts which sum of remain steps == total steps\n        # - sum of dist <= arrLen\n        # - takes 1 extra steps to connect\n    def numWays(self, steps: int, arrLen: int) -> int:\n        # if dist == 1, combos always 1 regardless of steps\n        if arrLen == 0 or (arrLen == 1 and steps > 0):\n            return arrLen\n        combos = {} # (dist, steps): # of combos\n        def _dfs_ways(steps, arrLen, loc = 0, tar = 0):\n            if steps == 0:\n                return 1 if loc == tar else 0\n            if (steps, loc) in combos: return combos[(steps, loc)]\n            steps -= 1\n            stay = _dfs_ways(steps, arrLen, loc)\n            left = _dfs_ways(steps, arrLen, loc - 1) if loc - 1 >= 0 else 0\n            right = _dfs_ways(steps, arrLen, loc + 1) if loc + 1 < arrLen else 0\n            res = int((left + right + stay) % (math.pow(10, 9) + 7))\n            steps += 1\n            combos[(steps, loc)] = res\n            return res\n        \n        # for i in range(1, min(arrLen, steps // 2) + 1):\n        #     # for combo two parts\n        #     res = 0\n        #     for div in range(1, i + 1): # divide len for dfs\n        #         for left_steps in range(1, steps):\n        #             left_ways = _dfs(left_steps, div)\n        #             right_ways = _dfs(steps - left_steps - 1, i - div)\n        #             res += left_ways * right_ways\n        #     # for whole\n        #     res += _dfs(steps, i)\n        #     combos[(steps, i)] = res\n        _dfs_ways(steps, arrLen)\n        ans = combos[(steps, 0)]\n        return int(ans % (math.pow(10, 9) + 7))", "from functools import lru_cache\n\nclass Solution:\n  @lru_cache(None)\n  def recursive(self, x, i):\n    # x: steps remain, i: current position.\n    if x == i:\n      return 1\n    count = 0\n    if x > 0:\n      # stay\n      count += self.recursive(x - 1, i)\n      # left\n      if i - 1 >= 0:\n        count += self.recursive(x - 1, i - 1)\n      # right\n      if i + 1 < self.L:\n        count += self.recursive(x - 1, i + 1)\n    return count % (10 ** 9 + 7)\n  def numWays(self, steps: int, arrLen: int) -> int:\n    self.L = arrLen\n    return self.recursive(steps, 0)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.mod = 10 ** 9 + 7\n        \n        return self.dp(arrLen, steps, 0)\n    \n    @lru_cache(None)\n    def dp(self, n, steps, i):        \n        if i >= n or i < 0:\n            return 0\n        \n        if steps == 0:\n            return 1 if i == 0 else 0\n        \n        stay_in_place = self.dp(n, steps - 1, i)\n        move_left = self.dp(n, steps - 1, i - 1)\n        move_right = self.dp(n, steps - 1, i + 1)\n\n        \n        return (stay_in_place + move_left + move_right) % self.mod", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        f_old = [0] * min(steps + 1, arrLen)\n        f_new = [0] * min(steps + 1, arrLen)\n        if arrLen == 1:\n            return 1\n        elif arrLen == 0:\n            return 0\n        f_old[0] = 1\n        for i in range(steps):\n            f_new[0] = f_old[0] + f_old[1]\n            if i + 1 <= arrLen - 1:\n                f_new[i + 1] = 1\n            else:\n                f_new[-1] = f_old[-1] + f_old[-2]\n            for j in range(1, min(i + 1, arrLen - 1)):\n                f_new[j] = f_old[j - 1] + f_old[j] + f_old[j + 1]\n            f_old = f_new.copy()\n            f_old = [_ % (10 ** 9 + 7) for _ in f_old]\n        return f_old[0] \n", "\ndef count(curr, maxpos, steps, mod, obj):\n    if curr < 0: return 0\n    if curr == maxpos: return 0\n    if steps == 1 and curr == 1: return 1\n    if steps == 1 and curr == 0: return 1\n    if steps == 0: return 0\n    if (curr,steps) in obj: return obj[(curr,steps)]\n    obj[(curr,steps)] = (count(curr, maxpos, steps-1, mod, obj)%mod + count(curr+1, maxpos, steps-1, mod, obj)%mod + count(curr-1, maxpos, steps-1, mod, obj)%mod)%mod\n    return obj[(curr,steps)]\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        curr = 0\n        mod = 10**9+7\n        obj = {}\n        return count(curr, arrLen, steps, mod, obj)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.mod = 10 ** 9 + 7\n        \n        return self.dp(arrLen, steps, 0)\n    \n    @lru_cache(None)\n    def dp(self, n, steps, i):\n        if steps == 0 and i == 0:\n            return 1\n        \n        if i >= n or i < 0 or steps == 0:\n            return 0\n        \n        stay_in_place = self.dp(n, steps - 1, i)\n        move_left = self.dp(n, steps - 1, i - 1)\n        move_right = self.dp(n, steps - 1, i + 1)\n        \n        return (stay_in_place + move_left + move_right) % self.mod", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        mem = {}\n        \n        def helper(i, k, arrLen):\n            # print(i, k)\n            if i == 0 and k == 0:\n                return 1\n            if (i, k) in mem:\n                return mem[(i, k)]\n            count = 0\n            for x in [-1, 0, 1]:\n                if i+x < 0 or i+x >= arrLen or k < 0:\n                    continue\n                count += helper(i+x, k-1, arrLen)\n            mem[(i,k)] = count\n            return count\n        return helper(0, steps, arrLen)%(10**9 + 7)", "from functools import lru_cache\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        mod = 10**9 + 7\n        @lru_cache(None)\n        def dfs(s, l):\n            if s == steps:\n                if l == 0:\n                    return 1\n                return 0\n            \n            return (dfs(s + 1, l) + (dfs(s + 1, l + 1) if l < arrLen-1 else 0 )+ (dfs(s + 1, l - 1) if l else 0)) % mod\n        return dfs(0, 0)", "class Solution:\n    \n    \n    def helper(self, pos, steps):\n        if (pos, steps) in self.cache:\n            return self.cache[(pos,steps)]\n        \n        if steps == 0:\n            return 1 if pos == 0 else 0\n        \n        stay = self.helper(pos, steps - 1)\n        \n        self.cache[(pos, steps - 1)] = stay\n        \n        left = self.helper(pos + 1, steps - 1) if pos < self.arrLen - 1 else 0\n        \n        self.cache[(pos + 1, steps - 1)] = left\n\n        \n        right =  self.helper(pos - 1, steps - 1) if pos > 0 else 0\n        \n        self.cache[(pos -1 , steps - 1)] = right\n\n        \n        return stay + left + right\n        \n        \n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.cache = {}\n        self.steps = steps\n        self.arrLen = arrLen\n        return self.helper(0, steps) % (10**9 + 7)", "import functools\n@functools.lru_cache(maxsize=10**7+1)\ndef count(curr, maxpos, steps, mod):\n    if curr < 0: return 0\n    if curr == maxpos: return 0\n    if steps == 1 and curr == 1: return 1\n    if steps == 1 and curr == 0: return 1\n    if steps == 0: return 0\n    return (count(curr, maxpos, steps-1, mod)%mod + count(curr+1, maxpos, steps-1, mod)%mod + count(curr-1, maxpos, steps-1, mod)%mod)%mod\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        curr = 0\n        mod = 10**9+7\n        return count(curr, arrLen, steps, mod)", "class Solution:\n    def numWays(self, steps: int, n: int) -> int:\n        A = [0, 1]\n        mod=10 ** 9 + 7\n        for t in range(steps):\n            A[1:] = [sum(A[i - 1:i + 2]) % mod for i in range(1, min(n + 1, t + 3))]\n        return A[1] % mod        ", "class Solution:\n    \n    def __init__(self):\n        self.dp = {}\n        \n    def numWays(self, steps: int, arrLen: int, ptr: int = 0) -> int:\n        \n        return self.numWays_dp(steps, arrLen, ptr) % (10**9+7)\n    \n    def numWays_dp(self, steps: int, arrLen: int, ptr: int = 0) -> int:\n        if ptr >= arrLen:\n            return 0\n        if ptr < 0:\n            return 0\n        if steps == 0:\n            if ptr == 0:\n                return 1\n            else:\n                return 0\n            \n        if (ptr, steps) in self.dp:\n            return self.dp[(ptr, steps)]\n        \n        left_ways = self.numWays(steps-1, arrLen, ptr-1)\n        middle_ways = self.numWays(steps-1, arrLen, ptr)\n        right_ways = self.numWays(steps-1, arrLen, ptr+1)\n        \n        total_ways = left_ways + middle_ways + right_ways\n        self.dp[(ptr, steps)] = total_ways\n        \n        return total_ways", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        return self.dfs(steps, arrLen, {}, 0)%(10**9+7)\n    \n    def dfs(self, step, arrLen, mem, index):\n        if (step, index) in mem:\n            return mem[(step, index)]\n        if index < 0 or index >= arrLen:\n            return 0\n        if step == 0:\n            if index == 0:\n                return 1\n            return 0\n        mem[(step, index)] = 0\n        for i in range(-1, 2):\n             mem[(step, index)] += self.dfs(step-1, arrLen, mem, index+i)\n        return mem[(step, index)]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        dp = [0 for _ in range(arrLen)]\n        dp[0],dp[1]=1,1\n        for s in range(2,steps+1):\n            dp2 = [0 for _ in range(min(steps-s+2,arrLen))]\n            dp2[0]= dp[0]+dp[1]\n            if arrLen !=1:\n                dp2[-1]= dp[-2]+dp[-1]\n            for num in range(1,min(steps-s+1,arrLen-1)):\n                dp2[num] = dp[num-1]+dp[num]+dp[num+1]\n            dp = dp2\n            \n        return(dp[0])%(10**9+7)\n    \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        r, memo = min(arrLen, steps // 2 + 1), [0, 1]\n        for t in range(steps):\n            memo[1:] = [sum(memo[i-1:i+2]) for i in range(1, min(r+1, t+3))]\n        return memo[1] % (10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        c_ori=[0]*min(steps+2,(2+arrLen))\n        c_ori[1]=1\n        c_new=[0]*min(steps+2,(2+arrLen))\n        \n        for i in range(0,steps):\n            for j in range(1,len(c_ori)-1):\n                c_new[j]=c_ori[j]+c_ori[j-1]+c_ori[j+1]\n            #print(c_new)\n            c_ori=c_new.copy()\n        return c_ori[1]%1000000007\n", "LIMIT = 10**9 + 7\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        max_pos = min(steps // 2 + 1, arrLen) + 1\n        dp = [[0] * max_pos for _ in range(steps)]\n        dp[0][0] = dp[0][1] = 1\n        \n        for i in range(1, steps):\n            for j in range(max_pos-1):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j+1]) % LIMIT\n            \n        return dp[-1][0]\n    \n# time: O(min(arrLen, steps) * steps)\n# space: O(min(arrLen, steps) * steps)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        counts = [0] * min(arrLen, steps // 2 + 1)\n        counts[0], counts[1] = 1, 1\n        \n        mod = (10**9 + 7) \n        while steps - 1:\n            prev_counts = counts[:]\n            for i in range(len(counts)):\n                if i == 0:\n                    counts[i] = sum(prev_counts[i:i+2]) % mod\n                elif i == arrLen - 1:\n                    counts[i] = sum(prev_counts[i-1:i+1]) % mod\n                else:\n                    counts[i] = sum(prev_counts[i-1:i+2]) % mod\n            steps -= 1\n        \n        return counts[0]\n            \n        \n        \n    \n        \n        \n           \n            \n            \n            \n", "class Solution:\n    def numWays(self, steps: int, n: int) -> int:\n        mod = 10**9 + 7\n        A = [0, 1]\n        for t in range(steps):\n            A[1:] = [sum(A[i - 1:i + 2]) % mod for i in range(1, min(n + 1, t + 3))]\n        return A[1] % mod", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if arrLen < 2:\n            return 1\n        MAX = 10**9 + 7\n        \n        dp = [0]*arrLen\n        dp[0] = 1\n        dp[1] = 1\n        \n        ndp = [0]*arrLen\n        for step in range(2, steps+1):\n            ndp[0] = dp[0] + dp[1]\n            ndp[arrLen - 1] = dp[arrLen - 1] + dp[arrLen - 2]\n            \n            for i in range(1, min(steps, arrLen-1)):\n                ndp[i] = (dp[i-1] + dp[i] + dp[i+1])%MAX\n                \n            \n            dp[:min(steps, arrLen)] = ndp[:min(steps, arrLen)]\n        return dp[0] % MAX\n    \n        \n        \n        \n        \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        A = [0] * (arrLen + 2)\n        A[1] = 1\n        mod = 10**9 + 7\n        for n in range(1,steps+1):\n            prev = 0\n            for m in range(1,min(arrLen+1,n+2)): \n                old = A[m]\n                A[m] = (prev + A[m] + A[m+1]) % mod\n                prev = old\n                \n        return A[1]\n", "# dp[k][i] = # of ways at step k in i position\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        dp = [[0]*(steps//2+2) for _ in range(steps+1)] #\u5982\u679ck=500, i\u53ef\u4ee5\u53bb\u5230250 length \u6709251\u4e2a\n        dp[0][0] = 1\n        M = 10**9 + 7\n        \n        for k in range(1, steps+1):\n            for i in range(steps//2+1):\n                if i == 0:\n                    dp[k][i] = (dp[k-1][i] + dp[k-1][i+1])%M\n                    \n                elif i == arrLen-1:\n                    dp[k][i] = (dp[k-1][i] + dp[k-1][i-1])%M\n                    \n                else:\n                    dp[k][i] = (dp[k-1][i] + dp[k-1][i-1] + dp[k-1][i+1])%M\n                    \n        return dp[steps][0]%M", "from functools import lru_cache\nmod = 10**9+7\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:    \n\n        @lru_cache(None)\n        def calculation(pos: int, steps: int):\n            if pos < 0 or pos >= arrLen:\n                return 0\n            if pos > steps:\n                return 0            \n            if pos == steps:\n                return 1            \n            \n            return (calculation(pos+1, steps-1) + calculation(pos-1, steps-1) + calculation(pos, steps-1) ) % mod\n        \n        return calculation(0, steps)\n        \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if steps == 0:\n            return 0\n        if arrLen == 1:\n            return 1\n        \n        start = [1, 1] + ([0] * (min(steps, arrLen)-2))\n        return self.numWaysHelper(steps-1, start)\n        \n    # Assumes len(start) > 1\n    def numWaysHelper(self, steps, start):\n        if steps == 0:\n            return start[0] % (10**9 + 7)\n\n        n = [0] * len(start)\n        n[0] = start[0] + start[1]\n        n[len(start) - 1] = start[len(start)-1] + start[len(start)-2]\n        \n        for i in range(1, len(start) - 1):\n            n[i] = (start[i-1] + start[i] + start[i+1])\n        \n        return self.numWaysHelper(steps-1, n)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        max_len = min(steps //2 + 1, arrLen) #steps //2 + 1\n        mod = 10**9 + 7\n        dp = [[0] * (max_len+1) for _ in range(steps+1)]\n        dp[1][0] = 1\n        dp[1][1] = 1\n        for i in range(2, steps+1):\n            for j in range(max_len):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j+1] + (dp[i-1][j-1] if j > 0 else 0)) % mod\n        \n        for r in dp:\n            print(r)\n        return dp[steps][0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        dp = [[0 for _ in range(min(steps + 1, arrLen))] for _ in range(steps + 1)]\n        dp[0][0] = 1\n        for s in range(1, steps + 1):\n            for i in range(min(s + 1, arrLen, steps - s + 1)):\n                dp[s][i] = dp[s-1][i] % (10 ** 9 + 7)\n                if i > 0:\n                    dp[s][i] += dp[s-1][i-1]\n                if i < arrLen - 1:\n                    dp[s][i] += dp[s-1][i+1]\n        return dp[-1][0] % (10 ** 9 + 7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if arrLen < 2:\n            return 1\n        MAX = 10**9 + 7\n        \n        # dp[i] is num of ways to reach position i, starting from position 0\n        # if steps < i, is impossible to reach i\n        dp = [0] * arrLen \n        dp[0] = 1 # one step: stay\n        dp[1] = 1 # one step: move right\n        \n        ndp = [0] * arrLen # new dp array\n        # dp is status for previous step\n        # ndp is updated from last dp\n        for step in range(2, steps+1):\n            # two boundary case at poistion 0 and arrLen-1\n            ndp[0] = dp[0] + dp[1] #stay or move from right \n            ndp[arrLen-1] = dp[arrLen-1] + dp[arrLen-2] #stay or move from left\n            \n            # any other non-boundary positions\n            # stay, move from left, move from right\n            for i in range(1, min(steps, arrLen-1)):\n                ndp[i] = (dp[i] + dp[i-1] + dp[i+1]) % MAX\n            \n            # save status\n            for i in range(0, min(steps, arrLen)):\n                dp[i] = ndp[i]\n            \n        return dp[0] % MAX\n        \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        needed = min(steps+1,arrLen)\n        \n        dp = [0 for i in range(needed+1)]\n        new_dp = dp.copy()\n        dp[0] = 1\n        for step in range(1,steps+1):\n            for pos in range(min(step+1,arrLen)):\n                new_dp[pos] = dp[pos] + dp[pos-1] +dp[pos+1]\n            \n            dp,new_dp = new_dp,dp\n        return dp[0]%(10**9+7)\n       \n     \n        \n        needed = min(arrLen, steps + 1)\n        dp = [0 for i in range(needed + 1)]\n        dp[0] = 1\n        # used to avoid unnecessary allocation of lists\n        next_dp = dp.copy()\n        for step in range(1, steps+1):\n            # anything after index=step+1 will be 0, so we don't need to access them.\n            #for pos in range(min(step+1, needed)):\n            for pos in range(min(step+1,arrLen )):\n            #for pos in range(arrLen):\n                next_dp[pos]=dp[pos-1]+dp[pos]+dp[pos+1]\n            print((step, next_dp, dp))\n            dp, next_dp = next_dp, dp\n        return dp[0]%(10**9+7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if arrLen < 2:\n            return 1\n        MAX = 10**9 + 7\n        \n        dp = [0]*arrLen\n        dp[0] = 1\n        dp[1] = 1\n        \n        ndp = [0]*arrLen\n        for step in range(2, steps+1):\n            ndp[0] = dp[0] + dp[1]\n            ndp[arrLen - 1] = dp[arrLen - 1] + dp[arrLen - 2]\n            \n            for i in range(1, min(steps, arrLen-1)):\n                ndp[i] = (dp[i-1] + dp[i] + dp[i+1])%MAX\n                \n            for i in range(min(steps, arrLen)):\n                dp[i] = ndp[i]\n        return dp[0] % MAX\n    \n        \n        \n        \n        \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        n = min(steps+1, arrLen)\n        dp = [0]*n\n        dp[0] = 1\n        MOD = 10**9+7\n        \n        for _ in range(steps):\n            ndp = [0]*n\n            \n            for i in range(n):\n                if i==0:\n                    ndp[i] = (dp[i]+dp[i+1])%MOD\n                elif i==n-1:\n                    ndp[i] = (dp[i-1]+dp[i])%MOD\n                else:\n                    ndp[i] = (dp[i-1]+dp[i]+dp[i+1])%MOD\n            \n            dp = ndp\n            \n        return dp[0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        v = min(steps, arrLen)\n        dp = [0] * v\n        dp[0] = 1\n        temp = [0] * v\n        for _ in range(steps):\n            left = 0\n            for idx, val in enumerate(dp):\n                temp = val\n                right = 0 if idx == len(dp) - 1 else dp[idx + 1]\n                dp[idx] += left + right\n                left = temp\n            \n        return dp[0] % (10**9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        @lru_cache(None)\n        def helper(i, steps):\n            if steps == 0:\n                return i == 0\n            elif steps < i or steps + i < 0:\n                return 0\n            else:\n                result = helper(i, steps - 1)\n                if i < arrLen - 1:\n                    result += helper(i + 1, steps - 1)\n                if i > 0:\n                    result += helper(i - 1, steps - 1)\n                return result % 1_000_000_007\n        mod = 1_000_000_007\n        return helper(0, steps)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        ### dp[steps][pos]\n        modulo = 10 ** 9 + 7\n        \n        maxPos = min(steps//2 + 1, arrLen)\n        \n        dp = [ [0 for _ in range(maxPos+1)] for _ in range(steps + 1) ]\n        \n        dp[1][0], dp[1][1] = 1, 1\n        \n        ### dp[s][p] = dp[s-1][p] + dp[s-1][p-1] + dp[s-1][p+1]\n        \n        for i in range(2, steps+1):\n            for j in range(maxPos):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j+1]) % modulo\n                    \n                if j - 1 >= 0:\n                    dp[i][j] += dp[i-1][j-1] % modulo\n        \n        return dp[steps][0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        # write your code here\n        arrLen = min(arrLen, steps + 1) \n        f = [1]+[0]*(arrLen-1) # f[0] = 1\n\n        for i in range(1, steps+1):\n            old = 0 \n            for j in range(arrLen):\n                old_left = old\n                old = f[j]\n                if j > 0:\n                    f[j] += old_left      \n                if j < arrLen - 1:\n                    f[j] += f[j+1]   \n        return f[0] % (10 ** 9 + 7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(arrLen,steps + 1)\n        f = [1] + [0] * (arrLen - 1)\n        \n        for i in range(1, steps + 1):\n            old = 0\n            for j in range(arrLen):\n                old_left = old\n                old = f[j]\n                \n                if j > 0:\n                    f[j] += old_left\n                    \n                if j < arrLen - 1:\n                    f[j] += f[j + 1]\n        return f[0] % (10 ** 9 + 7)", "from functools import lru_cache\n\nclass Solution:\n    def numWays(self, steps, arrLen):\n        # write your code here\n        arrLen = min(arrLen, steps + 1) \n        f = [1]+[0]*(arrLen-1) # f[0] = 1\n\n        for i in range(1, steps+1):\n            old = 0 \n            for j in range(arrLen):\n                old_left = old\n                old = f[j]\n                if j > 0:\n                    f[j] += old_left      \n                if j < arrLen - 1:\n                    f[j] += f[j+1]   \n        return f[0] % (10 ** 9 + 7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        n = min(steps//2 + 1, arrLen)\n        f = [None] * (steps + 1)\n        f[0] = [0] * n\n        f[0][0] = 1\n        for t in range(1, steps + 1):\n            f[t] = [0] * n\n            for i in range(n):\n                f[t][i] = f[t-1][i]\n                if i + 1 < n:\n                    f[t][i] += f[t-1][i+1]\n                if i - 1 >= 0:\n                    f[t][i] += f[t-1][i-1]\n        return f[steps][0] % (10**9 + 7)\n\n        memo = {}\n        def f(i, c):\n            if c == 0:\n                return 1 if i == 0 else 0\n            if (i, c) in memo:\n                return memo[(i, c)]\n            cnt = f(i, c - 1)\n            if i + 1 < arrLen:\n                cnt += f(i + 1, c - 1)\n            if i - 1 >= 0:\n                cnt += f(i - 1, c - 1)\n            memo[(i, c)] = cnt\n            return cnt\n        \n        return f(0, steps) % (10**9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        # From index 0, we can venture out at most steps//2 additional steps and still\n        # gurantee we can come back. The length of the array that we can cover is\n        # therefore the 0-th cell, plus the steps//2 additional cells = steps//2 + 1\n        # (we ideally always need steps to be even because, from index 0, we can hit at most\n        # step//2 cells, and to come back we need again step//2 moves. But if it is odd,\n        # the extra step modulo 2 does us no good, we can make use of at most step//2 moves\n        # to the right and step//2 moves back, unable to make use of the extra step)\n        n = min(steps//2 + 1, arrLen)\n        f = [None] * (steps + 1)\n        f[0] = [0] * n\n        f[0][0] = 1\n        for t in range(1, steps + 1):\n            f[t] = [0] * n\n            for i in range(n):\n                f[t][i] = f[t-1][i]\n                if i + 1 < n:\n                    f[t][i] += f[t-1][i+1]\n                if i - 1 >= 0:\n                    f[t][i] += f[t-1][i-1]\n        return f[steps][0] % (10**9 + 7)\n\n        memo = {}\n        def f(i, c):\n            if c == 0:\n                return 1 if i == 0 else 0\n            if (i, c) in memo:\n                return memo[(i, c)]\n            cnt = f(i, c - 1)\n            if i + 1 < arrLen:\n                cnt += f(i + 1, c - 1)\n            if i - 1 >= 0:\n                cnt += f(i - 1, c - 1)\n            memo[(i, c)] = cnt\n            return cnt\n        \n        return f(0, steps) % (10**9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        # time O(n^2); space O(n)\n        n = min(steps//2 + 1, arrLen)\n        dp = [0] * n\n        dp[0] = 1\n        for _ in range(steps):\n            tmp_dp = [0] * n\n            for idx in range(n):\n                tmp_dp[idx] = sum(dp[max(0, idx-1):min(n, idx+1)+1])\n            dp = tmp_dp\n        \n        return dp[0] % (10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        modulo = 10**9 + 7\n        @lru_cache(None)\n        def make_step(pos, steps_left):\n            if steps_left == 0 or pos > steps_left:\n                if pos == 0:\n                    return 1\n                return 0\n            else:\n                #Left\n                ways = 0\n                if pos > 0:\n                    ways += make_step(pos-1, steps_left-1) % modulo\n                #Right\n                if pos < arrLen-1:\n                    ways += make_step(pos+1, steps_left-1) % modulo\n                #Stay\n                ways += make_step(pos, steps_left-1) % modulo\n                return ways % modulo\n        \n        return make_step(0, steps) ", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(steps+1, arrLen)\n        ans = [0]*arrLen\n        ans[0] = 1\n        for i in range(steps):\n            new_ans = []\n            for j in range(arrLen):\n                tmp = ans[j]\n                if j > 0: tmp += ans[j-1]\n                if j < arrLen-1: tmp += ans[j+1]\n                new_ans.append(tmp)\n            ans = new_ans\n        return ans[0]%(10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if arrLen>steps//2+1:\n            arrLen=steps//2+1\n        num_ways=[0 for i in range(arrLen)]\n        num_ways[0]=1\n        k=10**9+7\n        for _ in range(steps):\n            cur_num_ways=num_ways[:]\n            for i in range(arrLen):\n                if i-1>=0:\n                    cur_num_ways[i]+=num_ways[i-1]\n                if i+1<arrLen:\n                    cur_num_ways[i]+=num_ways[i+1]\n                cur_num_ways[i]=cur_num_ways[i]%k\n            num_ways=cur_num_ways\n        return num_ways[0]\n                    \n                    \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        max_dist = min(steps // 2 + 1, arrLen)\n        dp = [[0] * (max_dist + 1) for _ in range(steps)]\n        \n        dp[0][0] = dp[0][1] = 1\n        \n        for i in range(1, steps):\n            for j in range(max_dist):\n                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1]) % (10**9 + 7)\n                \n        return dp[-1][0]", "from collections import defaultdict\n\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.counter = 0\n        cache = defaultdict(defaultdict)\n       \n        def rec(pos, steps):\n            if pos in cache:\n                if steps in cache[pos]:\n                    return cache[pos][steps]\n                \n            if steps == 0:\n                if pos == 0:\n                    return 1\n                return\n            if pos < 0 or pos >= arrLen:\n                return\n           \n            if steps < pos:\n                return\n            \n            left = rec(pos-1, steps-1)\n            right = rec(pos+1, steps-1)\n            stay = rec(pos, steps-1)\n            if left is None and right is None and stay is None:\n                val = None\n            else:\n                val = (left or 0) + (right or 0) + (stay or 0)\n                \n            cache[pos][steps] = val\n            return val\n        \n        res = rec(0, steps) \n        \n        return res % (10**9 + 7)\n", "from functools import lru_cache\n\nclass Solution:\n    def numWays(self, steps: int, n: int) -> int:\n        \n        MOD = 10**9 + 7\n        \n        # @lru_cache(None)\n        def calculate(pos, steps):\n            nonlocal dp\n\n            if pos < 0 or pos >= n: return 0\n            if pos > steps: return 0\n            if steps == pos: return 1\n            steps -= 1\n            \n            if (pos+1,steps) in dp:\n                step1 = dp[(pos+1,steps)]\n            else:\n                step1 = calculate(pos+1, steps) \n                dp[(pos+1,steps)] = step1\n            \n            if (pos-1, steps) in dp:\n                step2 = dp[(pos-1,steps)]\n            else:\n                step2 = calculate(pos-1, steps)\n                dp[(pos-1,steps)] = step2\n            \n            if (pos,steps) in dp:\n                step3 = dp[(pos,steps)]\n            else:\n                step3 = calculate(pos, steps)   \n                dp[(pos,steps)] = step3\n                \n            return (step1+step2+step3) % MOD\n        \n        dp = {}\n        return calculate(0, steps)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        '''\n        Two-row DP solution. dp[i][j] = # of ways to get to position j in i steps.\n        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + dp[i - 1][j + 1] (need to take care of boundary conditions on first/last)\n        This is guarantee to be unique # of ways because we just look at what's the last step taken (stay, left, or right).\n        The final answer is dp[steps][0]\n        '''\n        arrLen = min(steps // 2 + 1, arrLen)\n        dp = [0] * arrLen\n        dp[0], dp[1] = 1, 1\n        for i in range(2, steps):\n            dp_new = [0] * arrLen\n            for j in range(min(i + 1,arrLen)):\n                dp_new[j] = (dp[j - 1] if (j - 1) >= 0 else 0) + dp[j] + (dp[j + 1] if (j + 1) < arrLen else 0)\n            dp = dp_new\n        return (dp[0] + dp[1]) % (10**9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, n: int) -> int:\n        \n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def calculate(pos, steps):\n            if pos < 0 or pos >= n: return 0\n            if pos > steps: return 0\n            if steps == pos: return 1\n            steps -= 1\n            return (calculate(pos+1, steps) + calculate(pos-1, steps) + calculate(pos, steps)) % MOD\n        \n        return calculate(0, steps)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        rec = [1]\n        mod = 10**9+7\n        \n        for i in range(1, steps+1):\n            temp = []\n            for j in range(min(i+1, arrLen)):\n                temp.append(sum(rec[max(0,j-1) : min(j+2, arrLen)])%mod)\n            rec = temp\n#            print(rec)\n        return rec[0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        counts = [0] * min(arrLen, steps + 1)\n        counts[0], counts[1] = 1, 1\n        \n        mod = (10**9 + 7) \n        while steps - 1:\n            prev_counts = counts[:]\n            for i in range(len(counts)):\n\n                if i == 0:\n                    counts[i] = sum(prev_counts[i:i+2]) % mod\n                elif i == arrLen - 1:\n                    counts[i] = sum(prev_counts[i-1:i+1]) % mod\n                else:\n                    counts[i] = sum(prev_counts[i-1:i+2]) % mod\n            steps -= 1\n        \n        return counts[0]\n            \n        \n        \n    \n        \n        \n           \n            \n            \n            \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if arrLen == 0 or arrLen == 1: return 1\n        \n        MODULO = 10 ** 9 + 7\n        ans = [0] * arrLen\n        # step 1:\n        ans[0] = 1\n        ans[1] = 1\n        \n        arrLen = min(steps+1, arrLen)\n        for _ in range(1, steps):\n            next_ans = [0] * arrLen\n            for j in range(arrLen):\n                if j == 0:\n                    next_ans[j] = (ans[j] + ans[j+1]) % MODULO\n                elif j == arrLen - 1:\n                    next_ans[j] = (ans[j-1] + ans[j]) % MODULO\n                else:\n                    next_ans[j] = (ans[j-1] + ans[j] + ans[j+1]) % MODULO\n            ans = next_ans\n        return ans[0]\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        MOD = 10**9 + 7\n        def count_steps(steps_left, current_pos, memo):\n            if (steps_left, current_pos) in memo:\n                return memo[(steps_left, current_pos)]\n            \n            if current_pos < 0 or current_pos > arrLen - 1 or current_pos > steps_left:\n                return 0\n            \n            if not steps_left:\n                if current_pos == 0:\n                    return 1\n                else:\n                    return 0\n            \n            ans = count_steps(steps_left - 1, current_pos, memo) + count_steps(steps_left - 1, current_pos - 1, memo) + count_steps(steps_left - 1, current_pos + 1, memo)\n            memo[(steps_left, current_pos)] = ans % MOD\n            return memo[(steps_left, current_pos)]\n        \n        return count_steps(steps, 0, {})", "class Solution:\n    dp = {}\n    \n    def traverse(self, pos, steps, arrLen):\n        key = (pos, steps)\n        dp = self.dp\n        \n        if key not in dp:\n            if pos<0 or pos>=arrLen:\n                r = 0\n            elif pos > steps:\n                r = 0\n            elif steps == 0:\n                if pos == 0:\n                    r = 1\n                else:\n                    r = 0\n            else:\n                r = (self.traverse(pos-1, steps-1,arrLen)+self.traverse(pos,steps-1,arrLen)+self.traverse(pos+1, steps-1, arrLen))%1000000007\n            \n            dp[key] = r\n        \n        return dp[key]\n        \n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.dp={}\n        return self.traverse(0, steps, arrLen)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        kmod = pow(10, 9) + 7\n        arrLen = min(steps, arrLen)\n        dp = [0] * arrLen\n        dp[0] = 1\n        \n        for s in range(steps):\n            tmp = [0] * arrLen\n            for i in range(arrLen):\n                tmp[i] = dp[i]\n                if i > 0:\n                    tmp[i] += dp[i - 1]\n                if i < arrLen - 1:\n                    tmp[i] += dp[i + 1]\n                tmp[i] %= kmod\n            dp = list(tmp)\n        return dp[0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        memo = {(0, 0):1}\n        N = 10 ** 9 + 7\n        def dfs(x, t):\n            if (x, t) not in memo:\n                if x < 0 or x >= arrLen:\n                    res = 0\n                elif x > t or x > steps - t:\n                    res = 0\n                else:\n                    res = dfs(x+1, t-1) + dfs(x, t-1) + dfs(x-1, t-1)\n                memo[(x, t)] = res % N\n            return memo[(x, t)]\n        \n        return dfs(0, steps)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        dp = {}\n        def dfs(steps, ind):\n            if (steps, ind) in dp:\n                return dp[(steps, ind)]\n            if steps == ind:\n                return 1\n            elif steps < ind:\n                return 0\n            res = 0\n            res += dfs(steps-1, ind)\n            if ind > 0:\n                res += dfs(steps-1, ind-1)\n            if ind < arrLen-1:\n                res += dfs(steps-1, ind+1)\n            dp[(steps, ind)] = res\n            return res%(10**9+7)\n        return dfs(steps, 0)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        r, dp = min(arrLen, steps // 2 + 1), [0, 1]\n        for t in range(steps):\n            dp[1:] = [sum(dp[i-1:i+2]) for i in range(1, min(r+1, t+3))]\n        return dp[1] % (10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrlen: int) -> int:\n        mod = 10 ** 9 + 7\n        if arrlen == 1: return 1\n        dp = [[0]*min(arrlen, steps+1) for _ in range(steps+1)]  # dp[a][b]: stays at position b after a steps\n        dp[1][0] = 1\n        dp[1][1] = 1\n        for a in range(2, steps + 1):\n            dp[a][0] = (dp[a-1][0] + dp[a-1][1]) % mod\n            for b in range(1,min(arrlen, a+1)):\n                if b == arrlen-1 or b == a :\n                    dp[a][b] = (dp[a-1][b] + dp[a-1][b-1]) % mod\n                else:\n                    dp[a][b] = (dp[a-1][b] + dp[a-1][b+1] + dp[a-1][b-1]) % mod\n        return dp[-1][0] ", "from functools import lru_cache\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        @lru_cache(maxsize=None)\n        def cc(step, pos):\n            if step == steps:\n                return 1 if pos == 1 else 0\n            else:\n                if pos == 1:\n                    return cc(step+1, pos+1) + cc(step+1, pos)\n                elif pos == arrLen:\n                    return cc(step+1, pos-1) + cc(step+1, pos)\n                else:\n                    return cc(step+1, pos+1) + cc(step+1, pos-1) + cc(step+1, pos)\n        mod = int(10 **9 + 7)\n        return cc(0, 1) % mod\n                    \n        \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        max_len = min(steps, arrLen) #steps //2 + 1\n        mod = 10**9 + 7\n        dp = [[0] * (max_len+1) for _ in range(steps+1)]\n        dp[1][0] = 1\n        dp[1][1] = 1\n        for i in range(2, steps+1):\n            for j in range(max_len):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j+1] + (dp[i-1][j-1] if j > 0 else 0)) % mod\n        \n        for r in dp:\n            print(r)\n        return dp[steps][0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        memo = collections.defaultdict(int)\n        def dfs(index, curr):\n            if curr == steps:\n                if index == 0:\n                    return 1\n                else:\n                    return 0\n            if index > steps - curr:\n                return 0\n            key = (index, curr)\n            if key in memo:\n                return memo[key]\n            res = 0\n            if index > 0:\n                res += dfs(index - 1, curr + 1)\n            if index < arrLen - 1:\n                res += dfs(index + 1, curr + 1)\n            res += dfs(index, curr + 1)\n            memo[key] = res\n            return res\n        \n        return dfs(0, 0) % (10 ** 9 + 7)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if not arrLen or not steps:return 1\n        if arrLen == 1: return 1 #stay all the time \n        \n        shorter = min(steps, arrLen)\n        dp = [[0 for _ in range(shorter)] for _ in range(steps+1)]\n        dp[0][0] = 1\n        dp[1][0] = 1\n        \n        for i in range(1, steps+1):\n            for j in range(shorter):\n                if j == 0:\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j+1]\n                elif j == shorter - 1:\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j-1]\n        return dp[-1][0] % (10**9 + 7)\n    \n        \n                    \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        \n        dp = {}\n        MOD = 10**9 + 7\n        \n        def moveOnce(i0, steps0):\n            if steps0 == 0:\n                if i0 == 0:\n                    return 1\n                return 0\n            \n            if (i0, steps0) in dp:\n                return dp[(i0, steps0)]\n            if i0 > steps0:\n                ans = 0\n            else:\n                if i0 == 0:\n                    ans = moveOnce(i0+1, steps0-1) + moveOnce(i0, steps0-1)\n                elif i0 == arrLen-1:\n                    ans = moveOnce(i0-1, steps0-1) + moveOnce(i0, steps0-1)\n                else:\n                    ans = moveOnce(i0+1, steps0-1) + moveOnce(i0-1, steps0-1) + moveOnce(i0, steps0-1)\n            dp[(i0, steps0)] = ans % MOD\n            return dp[(i0, steps0)]\n        \n        return moveOnce(0, steps)", "class Solution:\n    def numWays(self, s: int, a: int) -> int:\n        MOD = 1000000007\n        mem = {}\n        def f(s, a, i):\n            if (s, i) in mem:\n                return mem[(s,i)]\n            if not s:\n                if i:\n                    return 0\n                return 1\n            if i < 0 or i == a:\n                return 0\n            if i > s:\n                return 0\n            ans = 0\n            #stay\n            ans += f(s-1, a, i)\n            #left\n            ans += f(s-1, a, i-1)\n            #right\n            ans += f(s-1, a, i+1)\n            \n            mem[(s,i)] = ans\n            return ans%MOD\n            \n        return f(s, a, 0)\n            \n            \n        \n            \n    \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        if not arrLen or not steps:return 1\n        if arrLen == 1: return 1 #stay all the time \n        \n        shorter = min(steps, arrLen)#the position cannot be larger than the min(steps, arrLen)\n        dp = [[0 for _ in range(shorter)] for _ in range(steps+1)]\n        dp[0][0] = 1\n        dp[1][0] = 1\n        \n        for i in range(1, steps+1):\n            for j in range(shorter):\n                if j == 0:\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j+1]\n                elif j == shorter - 1:\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j-1]\n        return dp[-1][0] % (10**9 + 7)\n    \n        \n                    \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        self.dic = dict()\n        self.search(steps,arrLen,0) \n        return self.search(steps,arrLen,0)%(10**9+7)\n        \n        \n    def search(self,steps,arrLen,start):\n        if (steps,start) in self.dic:\n            return self.dic[(steps,start)]\n        if start>steps:\n            return 0\n        if start == 0 and steps == 0:\n            return 1\n        \n        output = 0\n        output += self.search(steps-1,arrLen,start)\n        if start>0:\n            output += self.search(steps-1,arrLen,start-1)\n        if start<arrLen-1:\n            output += self.search(steps-1,arrLen,start+1)\n        self.dic[(steps,start)] = output\n        \n        return output\n        \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        arrLen = min(steps+1, arrLen)\n        num = [0 for i in range(arrLen)]\n        num[0] = 1\n        modulo = 10**9+7\n        for i in range(steps):\n            newnum = [num[i] for i in range(arrLen)]\n            for i in range(arrLen):\n                if i > 0:\n                    newnum[i] += num[i-1]\n                if i < arrLen-1:\n                    newnum[i] += num[i+1]\n                if newnum[i] > modulo:\n                    newnum[i] %= modulo\n            num = newnum\n        return num[0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        MOD = 10**9+7\n        memory = {}\n        \n        def helper(i, steps):\n            if i < 0 or i == arrLen:\n                return 0\n            if i > steps:\n                return 0\n            if i == steps:\n                return 1\n            prev = memory.get((i, steps))\n            if prev is not None:\n                return prev\n\n            stay = helper(i, steps-1)\n            left = helper(i-1, steps-1)\n            right = helper(i+1, steps-1)\n            \n            result = (stay + left + right) % MOD\n            memory[(i, steps)] = result\n            \n            return result\n        \n        return helper(0, steps) ", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        mod = 10**9+7\n        @lru_cache(None)\n        def dp(index,steps):\n            if index < 0 or index >= arrLen:\n                return 0\n            if steps == 0:\n                if index == 0:\n                    return 1\n                return 0\n            return (dp(index-1,steps-1) + dp(index+1,steps-1) + dp(index,steps-1))%mod\n        \n        return dp(0,steps)%mod", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n  \n        @lru_cache(None)\n        def nw(pos, left):\n            \n            if pos < 0:\n                return 0\n            \n            if pos >= arrLen:\n                return 0\n            \n            if left == 0 and pos == 0:\n                return 1\n            \n            if left == 0 and pos != 0:\n                return 0\n            \n            res = nw(pos+1,left-1)\n            res += nw(pos-1,left-1)\n            res += nw(pos,left-1)\n            \n            return res\n            \n        res = nw(0,steps)\n            \n        return res % 1000000007", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        MOD = 10**9+7\n        memory = {}\n        \n        def helper(i, steps):\n            if i < 0 or i == arrLen:\n                return 0\n            if i > steps:\n                return 0\n            if i == steps:\n                return 1\n            prev = memory.get((i, steps))\n            if prev is not None:\n                return prev\n            \n            steps -= 1\n            stay = helper(i, steps)\n            left = helper(i-1, steps)\n            right = helper(i+1, steps)\n            \n            memory[(i, steps+1)] = (stay + left + right)\n            \n            return memory[(i, steps+1)]\n        \n        return helper(0, steps) % MOD", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        maxPos = min(steps, arrLen)\n        mod = 10 ** 9 + 7\n        dp = [[0] * (maxPos + 1) for _ in range(steps + 1)]\n        dp[1][0] = 1\n        dp[1][1] = 1\n        \n        for s in range(2, steps + 1):\n            for p in range(maxPos):\n                dp[s][p] = dp[s-1][p] + dp[s-1][p+1]\n                dp[s][p] += dp[s-1][p-1] if p > 0 else 0\n                dp[s][p] %= mod\n        \n        return dp[steps][0]\n    \n# initial state is critical\n# 0 step is meaningless\n# 1 step could be set manually\n", "from collections import defaultdict\ndef numWays(steps: int, arrLen: int) -> int:\n    if steps is None or steps < 0 or not arrLen:\n        return 0\n    arrLen = min(arrLen, steps + 1)\n    f = [[0] * arrLen for _ in range(steps + 1)]\n    f[0][0] = 1\n    for i in range(1, steps + 1):\n        for j in range(min(arrLen, i+1)):\n            f[i][j] += f[i - 1][j]\n            if j > 0:\n                f[i][j] += f[i - 1][j - 1]\n            if j < arrLen - 1:\n                f[i][j] += f[i - 1][j + 1]\n    return f[steps][0] % (10 ** 9 + 7)\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        return numWays(steps,arrLen)\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        memo = {}\n        const = 10**9+7\n        def num(step, idx) -> int:\n            if (step, idx) in memo:\n                return memo[(step, idx)]\n            if idx < 0 or idx >= arrLen:\n                return 0\n            if step <= 0:\n                return idx == step\n            if idx > step:\n                return 0\n            elif idx == step:\n                return 1\n            else:\n                memo[(step, idx)] = num(step-1, idx) + num(step-1, idx-1) + num(step-1, idx+1)  \n                if memo[(step, idx)] > const:\n                    memo[(step, idx)] = memo[(step, idx)]%const\n                return memo[(step, idx)]\n        return num(steps, 0)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        memo = {}\n        mod = 10**9 + 7\n        \n        return self.dfs(steps, arrLen, 0, memo, mod)\n    \n    def dfs(self, steps, arrLen, pos, memo, mod):\n        if (steps, pos) in memo:\n            return memo[(steps, pos)]\n        \n        if steps == 0:\n            if pos == 0:\n                memo[(steps, pos)] = 1\n                return 1\n            return 0\n        \n        tmp = 0\n        for d in (-1, 0, 1):\n            nxt = pos + d\n            if not (0 <= nxt < arrLen) or (nxt > steps): continue\n            tmp += self.dfs(steps-1, arrLen, nxt, memo, mod)%mod\n            \n        tmp %= mod\n            \n        memo[(steps, pos)] = tmp\n        \n        return tmp\n            \n            \n            \n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        l = min(steps, arrLen)\n        \n        dp = [0] * l\n        dp[0] = 1\n        \n        for i in range(steps):\n            nextdp = [0] * l\n            for j in range(l):\n                if j - 1 >= 0: # LEFT\n                    nextdp[j] += dp[j-1]\n                nextdp[j] += dp[j]\n                if j + 1 < l:\n                    nextdp[j] += dp[j+1]\n                nextdp[j] %= (10**9+7)\n            dp = nextdp\n            \n        return dp[0] % (10**9+7)", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        ### dp[steps][pos]\n        modulo = 10 ** 9 + 7\n        \n        maxPos = min(steps + 1, arrLen)\n        \n        dp = [ [0 for _ in range(maxPos+1)] for _ in range(steps + 1) ]\n        \n        dp[1][0], dp[1][1] = 1, 1\n        \n        ### dp[s][p] = dp[s-1][p] + dp[s-1][p-1] + dp[s-1][p+1]\n        \n        for i in range(2, steps+1):\n            for j in range(maxPos):\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j+1]) % modulo\n                    \n                if j - 1 >= 0:\n                    dp[i][j] += dp[i-1][j-1] % modulo\n        \n        return dp[steps][0]", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        waysDict = {}\n        return self.numWaysRec(steps, arrLen, 0, waysDict)%(10**9 + 7)\n    \n    def numWaysRec(self, steps: int, arrLen: int, currentPos: int, waysDict: dict) -> int:\n        if (steps == currentPos) or (steps == 1 and currentPos == 0):\n            return 1\n        totalWays = 0\n        for nextMove in self.validMoves(steps,currentPos,arrLen):\n            if (nextMove,steps-1) in waysDict:\n                totalWays += waysDict[(nextMove, steps-1)]\n            else:\n                result = self.numWaysRec(steps-1,arrLen,nextMove, waysDict)\n                waysDict[(nextMove,steps-1)] = result\n                totalWays += result\n        return totalWays\n    \n    def validMoves(self, steps: int, currentPos: int, arrLen: int) -> list:\n        validList = []\n        #Check left move\n        if (currentPos - 1 <= steps-1) and currentPos - 1 >= 0:\n            validList.append(currentPos-1)\n        #Check stay move\n        if (currentPos <= steps-1):\n            validList.append(currentPos)\n        #Check right move\n        if (currentPos+1 <= steps-1) and currentPos +1 < arrLen:\n            validList.append(currentPos+1)\n        \n        return validList\n", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        #dp = [steps][10^6]\n        dp = [defaultdict(int) for _ in range(steps+1)]\n        \n        dp[0][0] += 1\n        dp[1][1] += 1\n        dp[1][0] += 1\n        \n        modulo = pow(10, 9) + 7\n        \n        for i in range(2, steps+1):\n            for j in dp[i-1].keys():\n                remain = j - (steps - i)\n                if j < 0:\n                    break\n                if j + 1 < arrLen:\n                    dp[i][j + 1] += dp[i-1][j]\n                if j - 1 >= 0:\n                    dp[i][j - 1] += dp[i-1][j]\n                dp[i][j] += dp[i-1][j]\n        \n        return dp[steps][0] % modulo", "from collections import defaultdict\nclass Solution:\n    def numWays(self, steps: int, arrLen: int) -> int: \n        dp = {}\n        for i in range(steps+1):\n            dp[i] = defaultdict(int) \n        \n        # dp[i][j] stores the number of ways to reach index j using i steps\n        dp[1][1] += 1 # move right\n        dp[1][0] += 1 # stay\n        # cannot move left at this moment, as index j must satisfy 0 <= sums < arrLen \n        \n        for i in range(2, steps+1):\n            # index is where we are after the first i-1 steps\n            for index in dp[i-1].keys():\n                if index + 1 < arrLen: # move right  \n                    dp[i][index + 1] += dp[i-1][index]\n                \n                if index - 1 >= 0: # move left\n                    dp[i][index - 1] += dp[i-1][index]\n                \n                dp[i][index] += dp[i-1][index] # stay\n                \n        return dp[steps][0]   % (10 ** 9 + 7) ", "class Solution:\n    def numWays(self, steps: int, arrLen: int) -> int:\n        dp = {}\n        for i in range(steps+1):\n            dp[i] = collections.defaultdict(int) \n        \n        # dp[i][j] stores the number of ways to reach index j using i steps\n        dp[1][1] += 1 # move right\n        dp[1][0] += 1 # stay\n        # cannot move left at this moment, as index j must satisfy 0 <= sums < arrLen \n        \n        for i in range(2, steps+1):\n            # index is where we are after the first i-1 steps\n            for index in dp[i-1].keys():\n                if index + 1 < arrLen: # move right  \n                    dp[i][index + 1] += dp[i-1][index]\n                \n                if index - 1 >= 0: # move left\n                    dp[i][index - 1] += dp[i-1][index]\n                \n                dp[i][index] += dp[i-1][index] # stay\n                \n        return dp[steps][0]   % (10 ** 9 + 7) "]