["def handle(func, success, failure, *exceptions):\n    class manager:\n        def __enter__(self):\n            pass\n        def __exit__(self, type, value, traceback):\n            if isinstance(value, exceptions):\n                failure(func, value)\n                return True\n            return not value\n    with manager():\n        success(func, func())\n", "# Steal some contextlib stuff. Teach it to remember the exception instance.\n# 3.5 version used, no 3.7+ ABCs.\nclass suppress:\n    \"\"\"Context manager to suppress specified exceptions\n    After the exception is suppressed, execution proceeds with the next\n    statement following the with statement.\n         with suppress(FileNotFoundError):\n             os.remove(somefile)\n         # Execution still resumes here if the file was already removed\n    \"\"\"\n\n    def __init__(self, *exceptions):\n        self._exceptions = exceptions\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exctype, excinst, exctb):\n        # Unlike isinstance and issubclass, CPython exception handling\n        # currently only looks at the concrete type hierarchy (ignoring\n        # the instance and subclass checking hooks). While Guido considers\n        # that a bug rather than a feature, it's a fairly hard one to fix\n        # due to various internal implementation details. suppress provides\n        # the simpler issubclass based semantics, rather than trying to\n        # exactly reproduce the limitations of the CPython interpreter.\n        #\n        # See http://bugs.python.org/issue12029 for more details\n        self.excinst = excinst\n        return exctype is not None and issubclass(exctype, self._exceptions)\n\ndef handle(func, success, failure, *args):\n    result = None # function result, if any\n    ei = None # exception instance, if any\n\n    for exc in args: # let's see if we can get any exception\n        with suppress(*args): # muffle everything which we must handle\n            scm = suppress(exc) # get an object here for furter extraction of the instance\n            with scm:\n                # either this fails for currently tested exception, or some other supported one\n                result = func()\n                break # no need to continue if we're good\n            if result is None: # this means we have found our exception\n                ei = scm.excinst # grab the saved guts\n                break # nothing more to do here\n        continue # if we're here, then we have an exception but didn't find which one yet\n\n    if result is not None: # we got something good, call success as needed\n        success(func, result)\n        return # all done, happy hour time\n    \n    if ei: # found that bastard instance\n        failure(func, ei)", "from contextlib import suppress\n\ndef handle(func, success, failure, *exceptions):\n    class silenced:\n        def __enter__(self): return self\n        def __exit__(self, type, value, traceback):\n            nonlocal ret\n            if not type: success(func, ret)\n            if isinstance(value, exceptions): failure(func, value)\n            \n    with suppress(*exceptions), silenced():\n        ret = func()", "def handle(func, success, failure, *exceptions):\n    class CatchError(object):\n        __enter__ = lambda self: None\n        def __exit__(self, e_type, *_):\n            if e_type is not None and isinstance(e_type(), exceptions):\n                failure(func, e_type())\n                return True\n    with CatchError():\n        success(func, func())\n", "class HandleException:\n    def __init__(self, func, failure, exceptions):\n        self.target = func\n        self.failure = failure\n        self.captures = exceptions\n\n    def __enter__(self):\n        pass\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type is not None and issubclass(exc_type, self.captures):\n            self.failure(self.target, exc_value)\n            return True\n\n\ndef handle(func, success, failure, *exceptions):\n    with HandleException(func, failure, exceptions):\n        return success(func, func())", "class Handler:\n    def __init__(self, func, success, failure, *exception_types):\n        self.func = func\n        self.success = success\n        self.failure = failure\n        self.exception_types = exception_types\n    def __enter__(self):\n        pass\n    def __exit__(self, exc_type, exc_value, traceback):\n        if isinstance(exc_value, self.exception_types):\n            self.failure(self.func, exc_value)\n            return True\n\ndef handle(func, success, failure, *exception_types):\n    with Handler(func, success, failure, *exception_types):\n        success(func, func())\n", "def handle(func, success, failure, *exceptions):\n    try:\n        success(func, func())\n    except Exception as e:\n        for ex in exceptions:\n            if isinstance(e, ex):\n                failure(func, e)\n                return\n        raise e\n\nimport dis\nclass Injection():\n    def __init__(self, opcode, opname, arg, argval, argrepr, offset, starts_line, is_jump_target):\n        self.opname = opname\ndis.Instruction = Injection", "import contextlib\ndef handle(func, success, failure, *exceptions):\n    with contextlib.suppress(*exceptions):\n        return success(func, func())\n    return failure(func, ZeroDivisionError())", "class ErrorHandler:\n    def __init__(self, *exceptions):\n        self._exceptions = exceptions\n        \n    def __enter__(self):\n        pass\n    \n    def __exit__(self, exctype, excinst, exctb):\n        self.traceback = exctype\n        return exctype and issubclass(exctype, self._exceptions)\n\ndef handle(func, success, failure, *exceptions):\n    handler = ErrorHandler(*exceptions)\n    with handler:\n        return success(func, func())\n    return failure(func, handler.traceback())\n", "from contextlib import ContextDecorator\n\nclass Swallower:\n    def __init__(self, exns): self.exns = exns\n    def __enter__(self): return self\n\n    def __exit__(self, kls, val, trace):\n        if not val:\n            self.fail = None\n            return True\n        elif any(isinstance(val, e) for e in self.exns):\n            self.fail = val\n            return True\n        else:\n            return False\n\ndef handle(func, success, failure, *exceptions):\n    swallower = Swallower(exceptions)\n    with swallower:\n        val = func()\n    \n    if swallower.fail:\n        failure(func, swallower.fail)\n    else:\n        success(func, val)\n"]