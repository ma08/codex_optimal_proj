["def best_match(goals1, goals2):\n    return min( (a-b, -b, i) for i,(a,b) in enumerate(zip(goals1, goals2)) )[2]", "def best_match(goals1, goals2):\n  bestDiff = goals1[0] - goals2[0]\n  bestIndex = 0\n  for i in range(len(goals1)):\n      if goals1[i] - goals2[i] < bestDiff:\n          bestIndex = i\n          bestDiff = goals1[i] - goals2[i]\n      if (goals1[i] - goals2[i] == bestDiff) and (goals2[i] > goals2[bestIndex]):\n          bestIndex = i\n          bestDiff = goals1[i] - goals2[i]\n  return bestIndex", "def best_match(goals1, goals2):\n    return sorted( (a-b, -b, i) for i,(a,b) in enumerate(zip(goals1, goals2)) )[0][2]", "\ndef best_match(goals1 : list, goals2 : list):\n\n    # Set the current \"best\" values as the first match\n    lowest_difference = goals1[0] - goals2[0]\n    amount_of_goals = goals2[0]\n    best_match_index = 0\n\n    # Loop through the length of the lists, to see if theres a better match\n    for i in range(1, len(goals1)):\n\n        # The current difference in goals.\n        current_difference = goals1[i] - goals2[i]\n\n        if (current_difference) < lowest_difference: # If the game was closer, this is the best match\n            lowest_difference = current_difference\n            amount_of_goals = goals2[i]\n            best_match_index = i\n\n        elif (current_difference == lowest_difference) and (amount_of_goals < goals2[i]): # If the difference is the same, but Zamalek scored more goals, it should change the best match.\n            amount_of_goals = goals2[i]\n            best_match_index = i\n    \n    return best_match_index", "def best_match(goals1, goals2):\n  # scores makes an array of following structure [(Goal difference, Zamalek Goals, index in the arrays), ...]\n  scores = [(zip[0] - zip[1], zip[1], idx) for idx, zip in enumerate(zip(goals1, goals2))]\n  # Sorts the score array first by Goal difference first and by Zamalek Goals after (reversed) and get's the first element index\n  return sorted(scores, key=lambda y: (y[0], -y[1]))[0][2]", "from collections import namedtuple\n\n\ndef best_match(goals1, goals2):\n    Match = namedtuple('Match', ['diff', 'scored', 'index'])\n    temp = [Match(xy[0]-xy[1], xy[1], idx) for idx, xy in enumerate(zip(goals1, goals2))]\n    best_diff = min([match.diff for match in temp])\n    temp = [match for match in temp if match.diff == best_diff]\n    return sorted(temp, key=lambda match: match.scored, reverse=True)[0].index", "def best_match(goals1, goals2):\n    num=goals1[0]-goals2[0]\n    goal=0\n    for i in range(len(goals1)):\n        if goals1[i]-goals2[i]<num:\n            num=goals1[i]-goals2[i]\n            goal=i\n        if goals1[i]-goals2[i]==num:\n            if goals2[i]>goals2[goal]:\n                goal=i\n    return goal\n            \n  #coding and coding..\n", "def best_match(goals1, goals2):\n    l = [abs(i - j) for i, j in zip(goals1, goals2)]\n    ll = [(abs(i - j), j) for i, j in zip(goals1, goals2)]\n    if l.count(min(l)) > 1:\n        l_new = [(a, b) for a, b in sorted(ll) if a == min(l)]\n        return ll.index(l_new[-1])\n    return l.index(min(l))", "def best_match(goals1, goals2):\n    l = [(i - j, -j) for i, j in zip(goals1, goals2)]\n    return l.index(min(l))"]