["class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        ans = 0 \n        for seat, group in itertools.groupby(seats):\n            if not seat:\n                k = len(list(group))\n                ans = max(ans, (k+1)//2)\n        return max(ans, seats.index(1),seats[::-1].index(1))\n        \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        \n        \n#         runzero, maxzero = 0,0\n        \n#         for i, seat in enumerate(seats):\n            \n#             if seat==0:\n#                 runzero += 1\n#                 maxzero = max(maxzero, runzero)\n#             else:\n#                 runzero=0\n                \n#         ans = (maxzero+1)//2\n#         startmax = seats.index(1)\n#         endmax = seats[::-1].index(1)\n#         return max(ans, startmax, endmax)\n\n        anspointer = -float('inf')\n        prvpointer = None\n        \n        for i, seat in enumerate(seats):\n            \n            if seat==1:\n                if prvpointer == None:\n                    anspointer = i\n                    # prvpointer = i\n                else:\n                    anspointer = max(anspointer, (i-prvpointer)//2)\n                \n                prvpointer = i\n        \n        anspointer = max(anspointer, len(seats)-1-prvpointer)\n        \n        return anspointer", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        n = len(seats)\n        left, right = [-1]*n, [-1]*n\n        leftMost, rightMost = float('-inf'), float('inf')\n        for i in range(n):\n            if seats[i] == 1:   leftMost = i\n            left[i] = leftMost\n            if seats[n-1-i] == 1:   rightMost = n-1-i\n            right[n-1-i] = rightMost\n        print()\n        maxDistance = 0\n        for i in range(n):\n            if seats[i] == 1:   continue\n            distance = min(i-left[i], right[i]-i)\n            maxDistance = max(maxDistance, distance)\n        \n        return maxDistance", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        lToR = [0 for _ in range(len(seats))]\n        rToL = [0 for _ in range(len(seats))]\n        for i in range(len(seats)):\n            if seats[i] == 1:\n                lToR[i] = -1 \n                continue\n            if i == 0:\n                if seats[i] == 0:\n                    lToR[i] = 1\n            else:\n                if seats[i-1] != 1:\n                    lToR[i] = lToR[i-1]+1\n                else:\n                    lToR[i] = 1\n        for i in range(len(seats)-1, -1, -1):\n            if seats[i] == 1:\n                rToL[i] = -1 \n                continue\n            if i == len(seats)-1:\n                if seats[i] == 0:\n                    rToL[i] = 1\n            else:\n                if seats[i+1] != 1:\n                    rToL[i] = rToL[i+1]+1\n                else:\n                    rToL[i] = 1\n        res = 1\n        for i in range(len(seats)):\n            if i == 0 or i == len(seats)-1:\n                if lToR[i] != -1 and rToL[i] != -1:\n                    res = max(res,max(lToR[i],rToL[i]))\n            else:\n                if lToR[i] != -1 and rToL[i] != -1:\n                    res = max(res,min(lToR[i],rToL[i]))\n        return res\n'''\nclass Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        if not seats: return 0\n        res = 0\n        que = deque()\n        que.append(-1)\n        for index, seat in enumerate(seats):\n            if seat == 1: que.append(index)\n            if len(que) == 2:\n                if que[0] == -1:\n                    res = max(res, que[1])\n                else:\n                    res = max(res, (que[1]-que[0])//2)\n                que.popleft()\n        res = max(res, len(seats)-1-que[0])\n        return res\n'''\n                    \n        \n'''\nclass Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        res = 0\n        que = deque()\n        que.append(-1)\n        #start, end = 0, 0\n        \n        for index, seat in enumerate(seats):\n            if seat == 1: que.append(index)\n            if len(que) == 2:\n                if que[0] == -1:\n                    res = max(res, que[1])\n                else:\n                    res = max(res, (que[1]-que[0])//2)\n                que.popleft()\n                    \n        res = max(res, len(seats)-1-que[0])\n        return res\n'''\n        \n \n                \n        \n        \n                \n                \n            \n                    \n       \n  \n            \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        \n        N = len(seats)\n        \n        left = [0 for _ in range(N)]\n        right = [0 for _ in range(N)]\n        \n        for i in range(N):\n \n            if seats[i]==1:\n                left[i]=i\n                continue\n            \n            if i==0:\n                left[i]=-1\n                continue\n            \n                \n            left[i] = left[i-1]\n            \n        for i in range(N-1,-1,-1):\n        \n            if seats[i]==1:\n                right[i]=i\n                continue\n            \n            if i==(N-1):\n                right[i]=-1\n                continue\n                \n            right[i]=right[i+1]\n        \n        print((right,left))\n        maxDistance = 0\n        \n        for pos in range(N):\n            \n            if seats[pos]==0:\n                if left[pos]==-1 or right[pos]==-1:\n                    if left[pos]==-1:\n                        distance = right[pos]-pos\n                    else:\n                        distance = pos-left[pos]\n                else:\n                    distance = min(right[pos]-pos,pos-left[pos])\n                \n                maxDistance = max(maxDistance,distance)\n                \n        return maxDistance\n                        \n                \n                \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        seated = [i for i, elem in enumerate(seats) if elem == 1]\n        empties = [i for i, elem in enumerate(seats) if elem == 0]\n        \n        s_p, e_p = 0, 0\n        min_dist = 0\n        while e_p < len(empties):\n            # make the determination:\n            while (s_p < len(seated) - 1) and empties[e_p] > seated[s_p]:\n                s_p += 1\n            if s_p > 0:\n                tmp_dist = min(abs(empties[e_p] - seated[s_p - 1]), \n                               abs(empties[e_p] - seated[s_p]))\n            else:\n                tmp_dist = abs(empties[e_p] - seated[s_p])\n            if tmp_dist > min_dist:\n                min_dist = tmp_dist\n            e_p += 1\n        return min_dist", "class Solution:\n    def maxDistToClosest(self, seats) -> int:\n        self.dists = [0 for i in range(len(seats))]\n        i = 0\n        # loop thru seats, assign weights as they come. update i to next seat found\n        while i < len(seats)-1:\n            i = self.assign_weights(i,seats)\n        # print(self.dists)\n        return max(self.dists)\n    # from left seat, search for next seat and assign weights\n    def assign_weights(self,start, seats):\n        if start == 0 and seats[start] != 1:\n            l_seat = math.inf\n        else:\n            l_seat = start\n        temp = start + 1\n        while temp < len(seats) and seats[temp] != 1:\n            temp+=1\n        \n        if temp == len(seats):\n            r_seat = math.inf\n        else:\n            r_seat = temp\n\n        for i in range(start,min(len(seats),r_seat)):\n            l_dist = abs(l_seat-i)\n            r_dist = r_seat - i \n            self.dists[i] = min(l_dist,r_dist)\n\n        return r_seat\n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        if len(seats) == 0 or min(seats) == 1:\n            return 0\n        \n        \n        left = [len(seats)] * len(seats)\n        right = [len(seats)] * len(seats)\n        latest = -1\n        for i in range(len(seats)):\n            if seats[i] == 1:\n                latest = i\n            if latest >= 0:\n                left[i] = i - latest\n            \n        latest = len(seats)\n        for i in reversed(range(len(seats))):\n            if seats[i] == 1:\n                latest = i\n            if latest < len(seats):\n                right[i] = latest - i\n            \n        ans = 0\n        for i in range(len(seats)):\n            ans = max(ans, min(left[i], right[i]))\n            \n        print(left, right)\n            \n        return ans", "from collections import defaultdict\nclass Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        N=len(seats)\n        front=defaultdict(int)\n        hind=defaultdict(int)\n            \n        frontI=float('-inf')\n        hindI=float('inf')\n        for n in range(N):\n            if seats[n]==1:\n                frontI=n\n            front[n]=frontI\n        for n in range(N)[::-1]:\n            if seats[n]==1:\n                 hindI=n\n            hind[n]=hindI\n        res=0  \n\n        for n in range(N):\n            if seats[n]==0:\n                res=max(res, min(n-front[n],hind[n]-n))\n        return res\n                \n            \n            \n            \n        \n        \n\n        \n        \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        prev_s = [None for _ in seats]\n        next_s = [None for _ in seats]\n        last_1 = -float('INF')\n        next_1 = float('INF')\n        for i in range(len(seats)):\n            if seats[i] == 1:\n                last_1 = i\n            else:\n                prev_s[i] = last_1\n        \n        for i in range(len(seats) - 1, -1, -1):\n            if seats[i] == 1:\n                next_1 = i\n            else:\n                next_s[i] = next_1\n        \n        print(prev_s, next_s)\n        closest_max = -1\n        for i in range(len(seats)):\n            if prev_s[i] != None and next_s[i] != None:\n                print(prev_s[i], next_s[i])\n                closest_max = max(closest_max, min(i - prev_s[i], next_s[i] - i))\n        return closest_max", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        # Goal is to maximize 0's on each side of i\n        # so first option that immediatly comes to mind is to run through the list\n        # checking every positon, and then its distance, saving the seat with the maximized distance\n        # This is really slow\n        # to speed it up, i can only check seats that are farther from most recent seat than best yet\n        # so in the first example\n        \n        # [1,0,0,0,1,0,1]\n        # 0 continue\n        # 1, check its 1 away, save its values\n        # 2 check its two away, save its values\n        # 3 its 3 away check its values, do not save\n        # 4 continue\n        # 5 1 is most recent continue\n        # 6 conitnue\n        \n        # still n^2 but faster than checking EVERY possibiliy\n        \n        # Go through once, saving the position of every person initially.\n        \n        # So here we just have to loop through and find the max difference between. Then return the mid value\n        # This algorithm is much faster\n        \n        # Edge case of best seat being on far right and far left\n        # first find distance of first person from beginning, then afyer \n        \n        # 0, 4, 6\n        # best = people[0]\n        # pos = 0\n        # distance = (people[i] - people[i-1])//2\n        # if distance > best:\n        #   best = distance\n        #   \n        # [0, 0, 1]\n        prev = -1\n        best = 0\n        for i in range(0, len(seats)):\n            if seats[i] == 1:\n                if prev == -1:\n                    distance = i\n                else:\n                    distance = (i - prev)//2\n                best = max(best, distance)\n                prev = i\n        best = max(best, len(seats) - prev-1)\n        \n#         best = people[0]\n        \n#         for i in range(1, len(people)):\n#             distance = (people[i] - people[i-1])//2\n#             best = max(best, distance)\n        \n#         best = max(best, len(seats) - people[-1]-1)\n        return best\n            \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        \n        s = seats\n        \n        first = 0 \n        second = 0\n        second_index = 0\n        output = []\n        Set = False\n        count = 0 \n        \n        for i in range(len(s)):\n            if s[i] != 1:\n                if(Set ==  False):\n                    count = count + 1\n                \n                continue\n            else:\n                Set = True\n                for j in range(i+1 , len(s)):\n                    if(s[j] != 1):\n                        second_index = j\n                        continue\n                    else:\n                        second_index = j\n                        print((second_index , i ))\n                        break\n                        \n                diff = second_index - i \n                \n                if( second_index == len(s) - 1 and s[second_index] == 0):\n                    output.append(diff)\n                    \n                output.append(count)\n                    \n                \n                \n                if(diff %2 == 0 ):\n                    output.append(int(diff/2))\n                else:\n                    output.append(int(diff/2))\n                        \n        return max(output)\n                        \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        count0, mmax, dist, start = 0, 0, 0, True\n        for i, e in enumerate(seats):\n            if e == 0:\n                count0 += 1\n                if i == len(seats)-1:\n                    dist = count0\n            else:\n                if count0 > 0:\n                    if start:\n                        dist = count0\n                    else:\n                        dist = (count0+1)//2\n                count0 = 0\n                start = False\n            mmax = max(dist, mmax)\n        return mmax", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        \n        max_distance = 0\n        for i, seat in enumerate(seats):\n            if seat == 1:\n                pass\n            \n            else:\n                left = right = i\n                location = [0, 0]\n                while 0 <= left < len(seats):\n                    if seats[left] != 1:\n                        location[0] += 1\n                        left -= 1\n                    else:\n                        break\n                        \n                \n                while 0 <= right < len(seats):\n                    if seats[right] != 1:\n                        location[1] += 1\n                        right += 1\n                    else:\n                        break\n                        \n                if i == 0 or i == len(seats) - 1:\n                    distance = max(location[0], location[1])\n                else:\n                    distance = min(location[0], location[1])\n                        \n                if distance > max_distance:\n                    max_distance = distance\n                        \n                \n                \n                \n        print(max_distance)\n        return max_distance\n                    \n", "class Solution:\n    # Time: O(len(seats))\n    # Space: O(1)\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        # two pointers\n        s = -1\n        distMax = 0\n        \n        while s < len(seats) - 1:\n            print('s: ', s)\n            for e in range(s+1, len(seats)):\n                print('e: ', e)\n                if seats[e] == 1:\n                    if s == -1:\n                        distMax = max(distMax, e)\n                    else:\n                        distMax = max(distMax, (e-s)//2)\n                    s = e\n                    break\n                elif e == len(seats)-1:\n                    distMax = max(distMax, len(seats)-1-s)\n                    s = e\n                    \n        return distMax", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        '''\n        need to find the distance of the closest neighbor at each seat\n        need to find distance to left and right neighbor at each seat \n        get the min of the two\n        '''\n        n = len(seats)\n        distance = [-1] * n\n        # calc distance to left neighbor\n        left_neighbor = -float('inf')\n        for seat in range(n):\n            if seats[seat] == 1:\n                left_neighbor = seat\n            distance[seat] = seat - left_neighbor\n        print(distance)\n        # calc distance to right neighbor\n        right_neighbor = float('inf')\n        answer = 0\n        for seat in range(n-1,-1,-1):\n            if seats[seat] == 1:\n                right_neighbor = seat\n            distance[seat] = min(distance[seat], right_neighbor - seat)\n            # if distance[seat] > distance[answer]:\n            #     answer = seat\n        print(distance)\n        return max(distance)\n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        '''\n        [1,0,0,0,1,0,1]\n        \n        left = [0,0,0,0,4,4,6]\n        right [0,4,4,4,4,6,6]\n        \n        '''\n        \n        \n        n = len(seats)\n        left, right = [n] * len(seats), [n] * len(seats)\n            \n        for i in range(0, len(seats)):\n            if seats[i] == 1:\n                left[i] = 0 \n            elif i > 0 and seats[i] == 0:\n                left[i] =  left[i-1] + 1 \n            \n        for i in range(len(seats)-1, -1, -1):\n            if seats[i] == 1:\n                right[i] = 0 \n            elif i < len(seats) - 1 and seats[i] == 0:\n                right[i] = right[i+1] + 1 \n\n        maxDistance = float('-inf')\n        for i, seat in enumerate(seats):\n            if seat == 0:\n                maxDistance = max(maxDistance, min(left[i], right[i]))\n        return maxDistance", "class Solution:\n    def maxDistToClosest(self, arr):\n        n = len(arr)\n        start = 0 # start index of group of consecutive 0s\n        end = 0 # end index of group of consecutive 0s\n        \n        maxdist, dist = 0, 0\n\n        i = 0\n        while (i < n):\n\n            while (i < n and arr[i] == 1):\n                i += 1\n            start = i\n\n            while (i < n and arr[i] == 0):\n                i += 1\n            end = i - 1\n\n            if(start==0):\n                dist = end+1\n            elif(end==n-1):\n                dist = n-1 - start + 1\n            else:\n                dist = (end-start)//2 + 1\n            maxdist=max(maxdist,dist)\n\n        return maxdist", "'''\n[inf,0]\n[1,0]\n'''\n\nclass Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        index=float('inf')\n        left=[]\n        for i in range(len(seats)):\n            val=seats[i]\n            if val==1:\n                index=i\n                left.append(0)\n            elif index==float('inf'):\n                left.append(float('inf'))\n            else:\n                left.append(abs(i-index))\n        index=float('inf')\n        for i in range(len(seats)-1,-1,-1):\n            val=seats[i]\n            if val==1:\n                index=i\n                seats[i]=0\n            elif index==float('inf'):\n                seats[i]=float('inf')\n            else:\n                seats[i]=abs(i-index)\n        out=float('-inf')\n        for i in range(len(seats)):\n            temp=min(left[i],seats[i])\n            out=max(out,temp)\n        return out\n        \n", "class Solution:\n    def maxDistToClosest(self, seats) -> int:\n        max_len = 0\n        _cnt = 0\n        for v in seats:\n            if v == 0:\n                _cnt += 1\n            if v == 1:\n                max_len = max(max_len, _cnt)\n                _cnt = 0\n        max_dist = (max_len+1) // 2\n        return max(max_dist, seats.index(1), seats[::-1].index(1))", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        n = len(seats)\n        last = None\n        res = 0\n        for i in range(n):\n            if seats[i] == 1:\n                if last is not None:\n                    res = max(res, (i - last) // 2)\n                else:\n                    res = i\n                last = i\n        return max(res, n - 1 - last)", "from bisect import bisect\n\nclass Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        occupied_indexes = []\n        empty_indexes = []\n        for i, is_occupied in enumerate(seats):\n            if is_occupied:\n                occupied_indexes.append(i)\n            else:\n                empty_indexes.append(i)\n                \n        num_occupied = len(occupied_indexes)\n        max_distance = 1\n        coi = 0\n        for empty_index in empty_indexes:\n            \n            while coi < num_occupied and occupied_indexes[coi] < empty_index:\n                coi += 1\n            ridx = coi\n            lidx = ridx - 1\n            \n            lmd = rmd = float('inf')\n            if lidx >= 0:\n                lmd = empty_index - occupied_indexes[lidx]\n            if ridx < num_occupied:\n                rmd = occupied_indexes[ridx] - empty_index\n            max_distance = max(max_distance, min(lmd, rmd))\n        return max_distance\n                \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        left = []\n        right = []\n        n = len(seats)\n        leftlast = None\n        rightlast = None\n        for i in range(n):\n            if seats[i] == 1:\n                left.append(0)\n                leftlast = i\n            else:\n                if leftlast is None:\n                    left.append(float('inf'))\n                else:\n                    left.append(i - leftlast)\n            if seats[n-i-1] == 1:\n                right.append(0)\n                rightlast = n-i-1\n            else:\n                if rightlast is None:\n                    right.append(float('inf'))\n                else:\n                    right.append(rightlast - n + i + 1)\n                \n        res = 0\n        for i in range(n):\n            res = max(res, min(right[n-i-1], left[i]))\n        return res\n                \n            \n            \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        res, last, n = 0, -1, len(seats)\n        for i in range(n):\n            if seats[i]:\n                res = max(res, i if last < 0 else (i - last) // 2)\n                last = i\n        return int(max(res, n - last - 1))", "class Solution:\n    \n    def maxDistToClosest(self, seats: List[int]) -> int:\n        seat_max_space = 0\n        max_dis = 0\n        for i, s in enumerate(seats):\n            if s == 0:\n                # print(\\\"DRR\\\", i, s)\n                j = i -1\n                #search left\n                min_left = j\n                left_seat_found = False\n                while j >= 0:\n                    if seats[j] == 1:\n                        min_left = j\n                        left_seat_found = True\n                        break\n                    j -= 1\n                k = i\n                min_right = k +1\n                right_seat_found = False\n                while k < len(seats):\n                    if seats[k] == 1:\n                        min_right = k\n                        right_seat_found = True\n                        break\n                    k += 1\n                if right_seat_found is False and left_seat_found is False:\n                    return len(seats) -1\n                if right_seat_found is False:\n                    min_right = min_left\n                if left_seat_found is False:\n                    min_left = min_right\n                closer = abs(min(i - min_left, min_right -i))\n                # print(i, min_left ,min_right , closer )\n                seat_max_space = max(seat_max_space, closer)\n        print(seat_max_space)\n        return seat_max_space\n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        '''res=0\n        for i in range(len(seats)):\n            if seats[i]==1:\n                continue\n            if sum(seats[:i])==0:\n                left=0\n            else:\n                left=i-1\n                while seats[left]!=1:\n                    left-=1\n            if sum(seats[i+1:])==0:\n                right=len(seats)-1\n            else:\n                right=i+1                \n                while seats[right]!=1:\n                    right+=1\n            if i-left!=0 and right-i!=0:\n                res=max(res,min(i-left,right-i))\n            if i-left==0:\n                res=max(res,right-i)\n            if right-i==0:\n                res=max(res,i-left)\n                    \n        return(res)'''\n        people = (i for i, seat in enumerate(seats) if seat)\n        prev, future = None, next(people)\n\n        ans = 0\n        for i, seat in enumerate(seats):\n            if seat:\n                prev = i\n            else:\n                while future is not None and future < i:\n                    future = next(people, None)\n\n                left = float('inf') if prev is None else i - prev\n                right = float('inf') if future is None else future - i\n                ans = max(ans, min(left, right))\n\n        return ans\n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        left, right = -1, 0\n        result = 0\n        \n        for right in range(len(seats)):\n            if seats[right] == 0:\n                continue\n                \n            if seats[right] == 1:               \n                if left == -1:\n                    result = right\n                else:\n                    result = max((right - left)//2, result)\n                left = right\n        \n        if not seats[right]:\n            result = max(result, right - left)\n        \n        return result\n            \n                    \n            \n            \n            \n            \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        \n        s, max_dist = -1, 0\n        n = len(seats)\n        \n        for e in range(n):\n            if not seats[e]: continue \n                \n            if s == -1:\n                max_dist = max(max_dist, e)\n            else:\n                max_dist = max(max_dist, floor((e-s)/2))\n\n            s = e\n            \n        if seats[n-1] == 0:\n            max_dist = max(max_dist, n-1-s)\n            \n        return max_dist     \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        c = 0\n        ans = 0 \n        for i in range(len(seats)):\n            if seats[i]:\n                if ans == 0 and c > 0 and c == i:\n                    ans = c\n                elif (c+1)//2 > ans:\n                    ans = (c+1)//2\n                c = 0\n            else:\n                c += 1\n        ans = max(c, ans)\n        return ans\n                \n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        l_0 = 0\n        begin_end_0 = -1\n        curr = 0\n        n = len(seats)\n        for i, num in enumerate(seats):\n            if num==0:\n                curr += 1\n                l_0 = max(curr, l_0)\n            else:\n                curr = 0\n            if i == n-1 or i - curr + 1 == 0:\n                begin_end_0 = max(begin_end_0,curr)\n        return max(begin_end_0, (l_0-1)//2+1)\n", "class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        n = len(seats)\n        dips = [0 for _ in range(n)]\n        dist = n\n        for i in range(n):\n            if seats[i] == 1:\n                dist = 0\n            else:\n                dips[i] = dist\n            dist += 1\n        print(dist, dips)\n        dist = n\n        \n        minimum = 0\n        for i in range(n-1, -1, -1):\n            if seats[i] == 1:\n                dist = 0\n            else:\n                if dips[i] > dist:\n                    dips[i] = dist\n                if dips[i] > minimum:\n                    minimum = max(minimum, dips[i])\n            dist += 1   \n        return minimum"]