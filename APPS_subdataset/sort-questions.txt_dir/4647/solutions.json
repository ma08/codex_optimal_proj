["def get_neighbourhood(typ, arr, coordinates):\n    \n    def isInside(x,y): return 0 <= x < len(arr) and 0 <= y < len(arr[0])\n    \n    x,y = coordinates\n    if not isInside(x,y): return []\n    \n    neigh = ( [(dx, dy) for dx in range(-1,2) for dy in range(-1,2) if (dx,dy) != (0,0)]\n                  if typ == 'moore' else [(0,1), (0,-1), (1,0), (-1,0)] )\n    \n    return [ arr[a][b] for a,b in ((x+dx,y+dy) for dx,dy in neigh) if isInside(a,b) ]", "vn = [(-1, 0), (0, -1), (0, 1), (1, 0)]\nmr = vn + [(-1, -1), (-1, 1), (1, -1), (1, 1)]\n\ndef get_neighbourhood(nh, a, p):\n    h, w, nh, x, y = list(range(len(a))), list(range(len(a[0] if a else []))), mr if \"r\" in nh else vn, *p\n    return [a[x+i][y+j] for i, j in nh if ((x+i) in h and (y+j) in w)] if x in h and y in w else []\n", "def get_neighbourhood(n_type, matrix, coordinates):\n    height = len(matrix)\n    width = len(matrix[0])\n    y, x = coordinates\n    if not (0 <= y < height and 0 <= x < width): return []\n    moore = [(y+dy, x+dx) for dy in [-1, 0, 1] for dx in [-1, 0, 1] if (dy, dx) != (0, 0)]\n    von_neumann = [moore[idx] for idx in (1, 3, 4, 6)]\n    neighbors_coords = eval(n_type)\n    neighbors = [matrix[y][x] for y, x in neighbors_coords if 0 <= y < height and 0 <= x < width]\n    return neighbors", "D = {\"von_neumann\":((0, 1), (0, -1), (1, 0), (-1, 0)),\n     \"moore\":((0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1))}\n\ndef get_neighbourhood(n_type, mat, coordinates):\n    (i, j), H, W = coordinates, len(mat), len(mat[0])\n    check = lambda a,b: 0 <= i+a < H and 0 <= j+b < W\n    return [mat[i+k][j+l] for k,l in D[n_type] if check(k, l)] if check(0, 0) else []", "def get_neighbourhood(type_, arr, co):\n    h, w = len(arr), len(arr[0])\n    i, j = co\n    if not arr[0] or i>=h or j>=w:return []\n    li = []\n    if type_ == 'moore':\n        return [arr[k][l] for k in range(i-1 if i>0 else 0, (i+1 if i<h-1 else h-1) + 1)\n                          for l in range(j-1 if j>0 else 0,(j+1 if j<w-1 else w-1)+1) if [k,l]!=[i,j]]\n    else:\n        li = [arr[i-1][j] if i>0 else 'x',\n              arr[i+1][j] if i<h-1 else 'x',\n              arr[i][j-1] if j>0 else 'x', \n              arr[i][j+1] if j<w-1 else 'x']\n        while 'x' in li : li.remove('x')\n        return li", "NEIGHBOURHOOD = {\"von_neumann\": 1, \"moore\": 2}\n\ndef closer_cells(n, x, y):\n    return ((x+u, y+v)\n            for u in range(-1, 2) for v in range(-1, 2)\n            if 0 < abs(u) + abs(v) <= n)\n\ndef get_neighbourhood(n_type, arr, coordinates):\n    def is_inside(x, y):\n        return 0 <= x < len(arr) and 0 <= y < len(arr[0])\n\n    return [] if not is_inside(*coordinates) else [arr[x][y]\n        for x, y in closer_cells(NEIGHBOURHOOD[n_type], *coordinates)\n        if is_inside(x, y)]", "def get_neighbourhood(n_type, mat, coord):\n    x, y = coord[0], coord[1]\n    if x<0 or y<0 or x>=len(mat) or y>=len(mat[0]):\n        return []\n    val = [(x-1, y), (x, y-1), (x, y+1), (x+1, y)]\n    if n_type == 'moore':\n        val += [(x-1, y-1), (x-1, y+1), (x+1, y-1), (x+1, y+1)]\n    return [mat[a[0]][a[1]] for a in val if a[0]>=0 and a[0]<len(mat) and a[1]>=0 and a[1]<len(mat[0])]\n", "def get_offsets(distance, moore=True):\n    offsets = list(range(-distance, distance + 1))\n    for dr in offsets:\n        for dc in offsets:\n            if (dr, dc) == (0, 0):\n                continue\n            if not moore and abs(dr) + abs(dc) > distance:\n                # Manhattan distance too large\n                continue\n            yield (dr, dc)\n\ndef get_neighbourhood(n_type, arr, coordinates, distance=1):\n    h, w = len(arr), len(arr[0])\n    if not (0 <= coordinates[0] < h and 0 <= coordinates[1] < w):\n        # Coordinate not in arr\n        return []\n    r, c = coordinates\n    return [\n        arr[r + dr][c + dc]\n        for dr, dc in get_offsets(distance, n_type == 'moore')\n        if 0 <= r + dr < h and 0 <= c + dc < w\n    ]\n", "def get_neighbourhood(n_type, mat, coordinates):\n    d = {'moore': [(0,1),(1,0),(-1,0),(0,-1),(-1,1),(1,-1),(1,1),(-1,-1)],\n         'von_neumann': [(0,1),(1,0),(-1,0),(0,-1)]\n    }\n    y,x = coordinates\n    if not mat or not 0<=y<len(mat) or not 0<=x<len(mat[0]): return []\n    \n    r = []\n    for i,j in d.get(n_type):\n        a,b = y+i,x+j\n        if 0<=a<len(mat) and 0<=b<len(mat[0]):\n            r.append(mat[a][b])\n    \n    return r"]