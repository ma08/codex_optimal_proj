["from functools import reduce\nfrom operator import mul\n\n\ndef select_subarray(arr):\n    total = sum(arr)\n    m = reduce(mul, arr)\n    qs = [\n        (abs((m // x) / (total - x)) if total - x else float(\"inf\"), i)\n        for i, x in enumerate(arr)\n    ]\n    q = min(qs)\n    result = [[i, arr[i]] for x, i in qs if x == q[0]]\n    return result[0] if len(result) == 1 else result", "from operator import mul    \nfrom functools import reduce\ndef select_subarray(array):\n    l = []\n    for i in array:\n        arr = [j for j in array if j != i]\n        if sum(arr):\n            l.append(((abs(reduce(mul, arr)/float(sum(arr)))), array.index(i), i))\n    c = [[j, k] for i, j, k in l if i == sorted(l)[0][0]]\n    return c[0] if len(c) == 1 else c\n", "from functools import reduce\nfrom operator import mul\ndef select_subarray(a):\n    sub = []\n    for i in range(len(a)):\n        t = a[:i] + a[i + 1:]\n        p = reduce(mul, t)\n        s = sum(t)\n        if p and s : sub.append([abs(p / s), i, t])\n    m = min(sub)[0]\n    r = [i[1] for i in sub if i[0] == m]\n    result = [[i, a[i]] for i in r]\n    return result if len(result)>1 else result[0]", "import numpy as np\n\n\ndef calc_one(value, tot_sum, tot_prod):\n    value[value==tot_sum] = np.nan\n    return (tot_prod / value) / (tot_sum - value)\n\n\ndef select_subarray(arr):\n    np_arr = np.array(arr).astype(np.float64)\n    tot_sum = np_arr.sum()\n    tot_prod = np_arr.prod()\n    qs = np.apply_along_axis(\n        calc_one,\n        0,\n        np_arr,\n        tot_sum,\n        tot_prod,\n    )\n    qs = np.abs(qs)\n    min_ = np.nanmin(qs)\n    where_min = np.where(qs == min_)[0]\n    out = [[where, arr[where]] for where in where_min]\n    return out if len(out)>1 else out[0]", "import operator\nfrom functools import reduce\n\ndef min_in_dict(in_dict, original_arr):\n    positions = [] # output variable\n    min_value = float(\"inf\")\n    for key, val in in_dict.items():\n        if val == min_value:\n            positions.append([original_arr.index(key), key])\n        if val < min_value:\n            min_value = val\n            positions = [] # output variable\n            positions.append([original_arr.index(key), key])\n    return positions\n\ndef select_subarray(arr):\n    q = dict()\n    for el in arr:\n        temp = arr.copy()\n        temp.remove(el)\n        if (sum(temp)):\n            q[el] = abs(reduce(operator.mul, temp, 1)/sum(temp))\n    if (len(min_in_dict(q, arr)) == 1):\n        return min_in_dict(q, arr)[0]\n    else:\n        return min_in_dict(q, arr)", "from functools import reduce\n\ndef select_subarray(arr):   \n    d = {}\n    for i in range(len(arr)):\n        x = arr[:i]+arr[i+1:]\n        s,p = sum(x),reduce(lambda x,y: x*y,x)\n        n = abs(p/s) if s!=0 else float('inf')\n        d.setdefault(n,[]).append([i,arr[i]])\n    r = d.get(min(d))\n    return r.pop() if len(r)==1 else r", "import math\nfrom functools import reduce\nimport operator\n\ndef select_subarray(arr):\n    q_vals = []\n    for i in range(len(arr)):\n        a = arr[:i] + arr[i+1:]\n        sum_a = sum(a)\n        if sum_a == 0:\n            q_vals.append(None)\n        else:\n            q_vals.append(math.fabs(reduce(operator.mul, a, 1) / sum_a))\n    selected = min(filter(lambda x: x is not None, q_vals))\n    indexes = [i for i,x in enumerate(q_vals) if x==selected]\n    result = []\n    for index in indexes:\n        result.append([index,arr[index]])\n    if len(result)==1:\n        return result[0]\n    return result", "def select_subarray(arr):\n    s = 0\n    p = 1\n    for x in arr:\n        s += x\n        p *= x\n    result = []\n    q = None\n    for i,x in enumerate(arr):\n        if s!=x:\n            new_q = abs((p/x)/(s-x))\n            if not result or new_q<q:\n                result = [[i, x]]\n                q = new_q\n            elif new_q == q:\n                result.append([i,x])\n                \n    return result if len(result)>1 else result[0]"]