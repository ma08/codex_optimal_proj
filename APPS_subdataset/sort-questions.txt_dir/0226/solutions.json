["\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n\n        A.sort()\n        self.ans = 0\n\n        def check(A, i, path):\n            return int((A[i] + path[-1])**0.5 + 0.0)**2 == A[i] + path[-1]\n\n        def dfs(A, path):\n            if not A:\n                self.ans += 1\n                return\n\n            for i in range(len(A)):\n                if i > 0 and A[i] == A[i - 1]:\n                    continue\n                if not path or (path and check(A, i, path)):\n                    dfs(A[:i] + A[i + 1:], path + [A[i]])\n\n        dfs(A, [])\n        return self.ans\n", "from copy import copy\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        \n        d = dict()\n        count = dict()\n        lim = len(A)\n        blank = dict()\n        for i in range(0,lim-1):  \n            try:\n                count[A[i]]+=1\n            except:\n                blank[A[i]]=0\n                count[A[i]]=1\n            for j in range(i+1,lim):\n                if ((A[i]+A[j])**.5).is_integer():\n                    try:\n                        d[A[i]].add(A[j])\n                    except:\n                        d[A[i]] = set()\n                        d[A[i]].add(A[j])\n                    try:\n                        d[A[j]].add(A[i])\n                    except:\n                        d[A[j]] = set()\n                        d[A[j]].add(A[i])\n        try:\n            count[A[-1]]+=1\n        except:\n            count[A[-1]]=1\n            blank[A[-1]]=0\n            \n        check = sorted(A)\n        if d==dict():return 0\n        f = set()\n        c = 0\n        def r(val,ld,l,lth):\n            if lth==lim:\n                f.add(tuple(l))\n            else:\n                if val in d:\n                    for x in d[val]:\n                        s = copy(ld)\n                        if s[x]<=count[x]:\n                            s[x]+=1\n                            r(x,s,l+[x],lth+1)\n        \n        for x in set(A):\n            r(x,blank,[x],1)\n        for x in f:\n            if sorted(list(x))==check:c+=1\n        return c\n", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        def get_valid():\n            ans = 0\n            seen = set()\n            visited = set()\n            while q:\n                cur, remaining = q.popleft()\n                if not remaining and cur not in seen:\n                    ans += 1\n                for i, n in enumerate(remaining):\n                    sq = (cur[-1] + n) ** .5\n                    if float(int(sq)) == sq:\n                        add = cur + (n,)\n                        remain = remaining[:i] + remaining[i+1:]\n                        if (add, remain) not in visited:\n                            q.append((add, remain))\n                            visited.add((add, remain))\n            return ans\n\n        q = deque()\n        for i, num in enumerate(A):\n            q.append(((num, ), tuple(A[:i] + A[i+1:])))\n\n        return get_valid()", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        c = collections.Counter(A)\n        cand = {i: {j for j in c if int((i + j)**0.5) ** 2 == i + j} for i in c}\n\n        def dfs(x, left=len(A) - 1):\n            c[x] -= 1\n            count = sum(dfs(y, left - 1) for y in cand[x] if c[y]) if left else 1\n            c[x] += 1\n            return count\n        return sum(map(dfs, c))", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        ''' \n        # graph of indices, works if we don't have duplicate elements\n        graph = collections.defaultdict(list)\n        for i in range(len(A)):\n            for j in range(i+1, len(A)):\n                if int((A[i]+A[j])**0.5)**2==(A[i]+A[j]):\n                    graph[i] += [j]\n                    graph[j] += [i]\n        # source node\n        graph[-1] = [i for i in range(len(A))]\n        def dfs(node, visited):\n            if len(visited)==len(A):\n                return 1\n            res = 0\n            for neighbor in graph[node]:\n                if neighbor in visited:\n                    continue\n                res += dfs(neighbor, visited|{neighbor})\n            return res\n        return dfs(-1, set())\n        '''        \n        candidates = collections.Counter(A)\n        graph = {x: [y for y in candidates if int((x+y)**0.5)**2==x+y] for x in candidates}\n        # source node\n        graph[-1] = [x for x in candidates]\n        def dfs(node, node_left):\n            if node_left==0:\n                return 1\n            res = 0\n            for n in graph[node]:\n                if candidates[n]==0:\n                    continue\n                candidates[n] -= 1\n                res += dfs(n, node_left-1)\n                candidates[n] += 1\n            return res\n        return dfs(-1, len(A))", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        #visited = [False] * len(A)\n        \n        visited = collections.Counter(A)\n        \n        ans = [0]\n        self.calc(A, visited, [], ans)\n        \n        return ans[0]\n    \n    def calc(self, A, visited, tmp, ans):\n        if len(tmp) == len(A):           \n            ans[0] += 1\n            #print(tmp)\n            \n        for i in list(visited.keys()):\n            if visited[i] == 0:\n                continue\n                \n            visited[i] -= 1\n            tmp.append(i)\n            \n            if len(tmp) < 2 or (tmp[-1] + tmp[-2])**(0.5) == int((tmp[-1] + tmp[-2])**(0.5)):\n                self.calc(A, visited, tmp, ans)\n            \n            tmp.pop()\n            visited[i] += 1\n", "class Solution:\n    def numSquarefulPerms(self, nums: List[int]) -> int:\n        #nums.sort()\n        self.ans = 0\n        \n        def isSquare(v):\n            x = int(v**0.5)\n            return x * x == v\n        \n        def dfs(pos):\n            \n            if pos >= len(nums):\n                self.ans += 1\n                return\n            \n            used = set()\n            for i in range(pos, len(nums)):\n                if nums[i] in used:\n                    continue\n                used.add(nums[i])\n                nums[pos], nums[i] = nums[i], nums[pos]\n                \n                if (pos == 0) or ( pos > 0 and isSquare(nums[pos] + nums[pos-1])):\n                    dfs(pos+1)\n                nums[pos], nums[i] = nums[i], nums[pos]\n        dfs(0)\n        return self.ans", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        n = len(A)\n        A = sorted(A)\n        # g[i][j] = 1 if A[i], A[j] are squareful\n        g = [[0] * n for _ in range(n)]\n        # dp[s][i]: number of ways to reach state s and ends with node i\n        dp = [[0] * n for _ in range(1 << n)]\n        \n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                r = int((A[i] + A[j]) ** 0.5)\n                if r ** 2 == A[i] + A[j]:\n                    g[i][j] = 1\n                    \n        for i in range(n):\n            if i == 0 or A[i] != A[i - 1]:\n                dp[(1 << i)][i] = 1\n                \n        ans = 0\n        for s in range(1 << n):\n            for i in range(n):\n                if not dp[s][i]:\n                    continue\n                for j in range(n):\n                    if not g[i][j]:\n                        continue\n                    if s & (1 << j):\n                        continue\n                    if j > 0 and not (s & (1 << (j - 1))) and A[j - 1] == A[j]:\n                        continue\n                    dp[s | (1 << j)][j] += dp[s][i]\n                    \n        for i in range(n):\n            ans += dp[(1 << n) - 1][i]\n        \n        return ans\n", "# https://zxi.mytechroad.com/blog/searching/leetcode-996-number-of-squareful-arrays/\n# g[i][j]: if i and j are squareful\n# dp[s][i]: # of ways to reach state s (binary mask of nodes visited) that ends with node i\n# dp[s | (1 << j)][j] += dp[s][i] if g[i][j]\n# \u5148\u5bf9\u6570\u7ec4\u6392\u5e8f, \u7136\u540e\u8ba1\u7b97\u51fa\u6240\u6709\u7684 g[i][j]\n# for i in range(n) \u521d\u59cb\u5316 dp[(1 << i)][i] = 1, \u8868\u793a\u53ea\u6709\u4e00\u4e2a\u6570\u5b57 i \u7684\u60c5\u51b5, \u6bcf\u4e2a\u90fd\u662f\u4e00\u79cd\n# \u5982\u679c\u6709\u591a\u4e2a\u91cd\u590d\u7684\u6570\u5b57, \u53ea\u7528\u7b2c\u4e00\u4e2a\u6570\u5b57\u4f5c\u4e3a\u5f00\u5934\n# ans = sum(dp[(1 << n) - 1][i])\n# O(n^2*2^n) time complexity, O(2^n) space complexity\nimport math\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        n = len(A)\n        A = sorted(A)\n        g = [[False] * n for _ in range(n)]\n        dp = [[0] * n for _ in range(1 << n)]\n        \n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if int((A[i] + A[j]) ** 0.5 + 0.5) ** 2 == A[i] + A[j]:\n                    g[i][j] = True\n\n        for i in range(n):\n            if i > 0 and A[i] == A[i - 1]:  # For the same numbers, only the first one can be the starting point\n                continue\n            dp[1 << i][i] = 1\n\n        for s in range(1 << n):\n            for i in range(n):\n                if dp[s][i] <= 0:  # \u5982\u679c dp[s][i] <= 0, \u8bf4\u660e\u6ca1\u6709\u4ee5 i \u7ed3\u5c3e\u7684\u60c5\u51b5, \u8df3\u8fc7\n                    continue\n                for j in range(n):  # \u5c1d\u8bd5\u8ba9\u4efb\u610f\u4e00\u4e2a\u6570\u5b57\u8fde\u63a5\u5728\u6700\u540e\u9762\n                    if not g[i][j] or (s & (1 << j)):  # \u5982\u679c i, j \u4e0d\u662f squareful \u6216 j \u5df2\u7ecf\u4f7f\u7528\u8fc7, \u8df3\u8fc7\n                        continue\n                    if j > 0 and not (s & (1 << (j - 1))) and A[j] == A[j - 1]:  # \u51fa\u73b0\u91cd\u590d\u7684\u53ea\u4f7f\u7528\u7b2c\u4e00\u4e2a\n                        continue\n                    dp[s | (1 << j)][j] += dp[s][i]\n        \n        res = 0\n        for i in range(n):\n            res += dp[(1 << n) - 1][i]\n        return res\n", "import numpy as np\nclass Solution:\n    graph = {}\n    count = {}\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        self.graph = {}\n        self.count = {}\n        for i in A:\n            if i in self.count:\n                self.count[i] += 1\n            else:\n                self.count[i] = 1\n            self.graph[i] = []\n            \n        for i in self.count:\n            for j in self.count:\n                r = int(np.sqrt(i + j))\n                if r * r == i + j:\n                    self.graph[i].append(j)\n        ans = 0\n        L = len(A)\n        for i in self.graph:\n            ans += self.dfs(i, L-1)\n        return ans\n    \n    def dfs(self, i, L):\n        self.count[i] -= 1\n        ans = 1\n        if L != 0:\n            ans = 0\n            for j in self.graph[i]:\n                if self.count[j] != 0:\n                    ans += self.dfs(j, L - 1)\n        self.count[i] += 1\n        return ans\n    \n", "import numpy as np\n\n\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        N = len(A)\n        count = collections.Counter(A)\n        graph = collections.defaultdict(list)\n        for x in count:\n            for y in count:\n                if int((x + y) ** (0.5)) ** 2 == (x + y):\n                    graph[x].append(y)\n        \n        def dfs(x, todo):\n            count[x] -= 1\n            if todo == 0:\n                ans = 1\n            else:\n                ans = 0\n                for y in graph[x]:\n                    if count[y]:\n                        ans += dfs(y, todo - 1)\n                        \n            count[x] += 1\n            return ans\n        \n        return sum(dfs(x, N - 1) for x in count)", "import numpy as np\nclass Solution:\n    graph = {}\n    count = {}\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        self.graph = {}\n        self.count = {}\n        for i in A:\n            if i in self.count:\n                self.count[i] += 1\n            else:\n                self.count[i] = 1\n            self.graph[i] = []\n            \n        for i in self.count:\n            for j in self.count:\n                r = int(np.sqrt(i + j))\n                if r * r == i + j:\n                    self.graph[i].append(j)\n        ans = 0\n        L = len(A)\n        print((self.count))\n        print((self.graph))\n        for i in self.graph:\n            ans += self.dfs(i, L-1)\n        return ans\n    \n    def dfs(self, i, L):\n        self.count[i] -= 1\n        ans = 1\n        if L != 0:\n            ans = 0\n            for j in self.graph[i]:\n                if self.count[j] != 0:\n                    ans += self.dfs(j, L - 1)\n        self.count[i] += 1\n        return ans\n    \n", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        def edge(x, y):\n            return int((x + y) ** 0.5) ** 2 == (x + y)\n        \n        def dfs(x, t):\n            count[x] -= 1\n            if t == 0:\n                ans = 1\n            else:\n                ans = 0\n                for y in graph[x]:\n                    if count[y]:\n                        ans += dfs(y, t - 1)\n            count[x] += 1\n            return ans\n                \n        N = len(A)\n        count = collections.Counter(A)\n        graph = collections.defaultdict(list)\n        for x in count:\n            for y in count:\n                if edge(x, y):\n                    graph[x].append(y)\n                    \n        return sum(dfs(x, N - 1) for x in count)\n", "from functools import lru_cache\n\n\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        def edge(x, y):\n            r = math.sqrt(x + y)\n            return int(r) ** 2 == (x + y)\n        \n        @lru_cache(None)\n        def dfs(node, seen):\n            if seen == (1 << N) - 1:\n                return 1\n            \n            ans = 0\n            for n in graph[node]:\n                nxt = seen | (1 << n)\n                if nxt == seen:\n                    continue\n                ans += dfs(n, nxt)\n            return ans\n                    \n        \n        N = len(A)\n        count = collections.Counter(A)\n        graph = [[] for _ in range(N)]\n        \n        for i in range(N):\n            for j in range(i + 1, N):\n                if edge(A[i], A[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n                    \n        ans = sum(dfs(i, 1 << i) for i in range(N))\n        for v in count.values():\n            ans //= math.factorial(v)\n        \n        return ans", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        import math\n        \n        def is_not_square(num): \n            return int(math.sqrt(num) + 0.5) ** 2 != num\n    \n        memo = {}\n        def perms(arr):\n            key = tuple(sorted(arr))\n            \n            if key in memo: return memo[key]\n            if len(arr) <= 1: return [arr]\n            \n            permutations = []\n            seen = set()\n            for i in range(len(arr)):\n                el = arr[i]\n                rest = arr[:i] + arr[i+1:]\n                # if all([is_not_square(el+n) for n in rest]): continue\n                if el not in seen:\n                    sub_perms = perms(rest)\n                    if not sub_perms: continue\n                    for p in sub_perms:\n                        if not is_not_square(el + p[0]):\n                            permutations.append([el] + p)\n                seen.add(arr[i])\n                \n            memo[key] = permutations\n            return permutations\n        \n            \n        return len(perms(A))\n                \n", "from functools import lru_cache\n\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        N = len(A)\n        \n        def valid(x,y):\n            return (math.sqrt(x+y)).is_integer()\n        \n        graph = [[] for _ in range(N)]\n    \n        for i,x in enumerate(A):\n            for j in range(i):\n                if valid(x,A[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n                    \n        # FINDING NO OF HAMILTONIAN PATH\n        \n        @lru_cache(None)\n        def dfs(node,visited):\n            if visited == (1<<N) - 1:\n                return 1\n            \n            ans = 0\n            for val in graph[node]:\n                if (visited & 1<<val)==0:\n                    ans+= dfs(val,visited | 1<<val)\n            return ans\n        \n        ans = sum(dfs(i,1<<i) for i in range(N))\n        count = collections.Counter(A)\n        for v in count.values():\n            ans //= math.factorial(v)\n        return ans", "from functools import lru_cache\n\nclass Solution:\n    def numSquarefulPerms(self, A):\n        N = len(A)\n\n        def edge(x, y):\n            r = math.sqrt(x+y)\n            return int(r + 0.5) ** 2 == x+y\n\n        graph = [[] for _ in range(len(A))]\n        for i, x in enumerate(A):\n            for j in range(i):\n                if edge(x, A[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        # find num of hamiltonian paths in graph\n\n        @lru_cache(None)\n        def dfs(node, visited):\n            if visited == (1 << N) - 1:\n                return 1\n\n            ans = 0\n            for nei in graph[node]:\n                if (visited >> nei) & 1 == 0:\n                    ans += dfs(nei, visited | (1 << nei))\n            return ans\n\n        ans = sum(dfs(i, 1<<i) for i in range(N))\n        count = collections.Counter(A)\n        for v in count.values():\n            ans //= math.factorial(v)\n        return ans", "from functools import lru_cache\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        N = len(A)\n\n        def edge(x, y):\n            r = math.sqrt(x+y)\n            return int(r + 0.5) ** 2 == x+y\n\n        graph = [[] for _ in range(len(A))]\n        for i, x in enumerate(A):\n            for j in range(i):\n                if edge(x, A[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        # find num of hamiltonian paths in graph\n\n        @lru_cache(None)\n        def dfs(node, visited):\n            if visited == (1 << N) - 1:\n                return 1\n\n            ans = 0\n            for nei in graph[node]:\n                if (visited >> nei) & 1 == 0:\n                    ans += dfs(nei, visited | (1 << nei))\n            return ans\n\n        ans = sum(dfs(i, 1<<i) for i in range(N))\n        count = collections.Counter(A)\n        for v in count.values():\n            ans //= math.factorial(v)\n        return ans", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        N = len(A)\n\n        def edge(x, y):\n            r = math.sqrt(x+y)\n            return int(r + 0.5) ** 2 == x+y\n\n        graph = [[] for _ in range(len(A))]\n        for i, x in enumerate(A):\n            for j in range(i):\n                if edge(x, A[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        # find num of hamiltonian paths in graph\n\n        @lru_cache(None)\n        def dfs(node, visited):\n            if visited == (1 << N) - 1:\n                return 1\n\n            ans = 0\n            for nei in graph[node]:\n                if (visited >> nei) & 1 == 0:\n                    ans += dfs(nei, visited | (1 << nei))\n            return ans\n\n        ans = sum(dfs(i, 1<<i) for i in range(N))\n        count = collections.Counter(A)\n        for v in count.values():\n            ans //= math.factorial(v)\n        return ans", "\n\n\ndef getPermutations(array):\n    ans = set()\n    def helper(arr,i,ans):\n        if i==len(arr)-1:\n\n            ans.add(tuple(arr))\n            return\n        \n        for j in range(i,len(arr)):\n            if not (arr[i]==arr[j] and i!=j):\n                test = (i<=1) or (((arr[i-1]+arr[i-2])**0.5)==int((arr[i-1]+arr[i-2])**0.5))\n                swap(arr,i,j)\n                if (test):\n                    helper(arr,i+1,ans)\n            \n                swap(arr,i,j)\n            \n    def swap(arr,i,j):\n        arr[i],arr[j]=arr[j],arr[i]\n        \n    helper(array,0,ans)\n    return ans\n\nclass Solution:\n    \n    \n    \n    def numSquarefulPerms(self, A: List[int]) -> int:\n        va = getPermutations(A)\n        \n        valid = 0\n        # print(va)\n        for a in va:\n            isValid = True\n            # print(a)\n            for idx in range(1,len(a)):\n                \n                if ((a[idx]+a[idx-1])**0.5)!=int((a[idx]+a[idx-1])**0.5):\n                    # print(a,idx)\n                    isValid = False\n                    break\n                    \n            if isValid:\n                # print(a)\n                valid+=1\n                \n        # print(valid)\n        return valid\n        \n", "from functools import lru_cache\n\nclass Solution:\n    def numSquarefulPerms(self, A):\n        N = len(A)\n\n        def edge(x, y):\n            r = math.sqrt(x+y)\n            return int(r + 0.5) ** 2 == x+y\n\n        graph = [[] for _ in range(len(A))]\n        for i, x in enumerate(A):\n            for j in range(i):\n                if edge(x, A[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        # find num of hamiltonian paths in graph\n        @lru_cache(None)\n        def dfs(node, visited):\n            if visited == (1 << N) - 1:\n                return 1\n            ans = 0\n            for nei in graph[node]:\n                if (visited >> nei) & 1 == 0:\n                    ans += dfs(nei, visited | (1 << nei))\n            return ans\n\n        ans = sum(dfs(i, 1<<i) for i in range(N))\n        count = collections.Counter(A)\n        for v in count.values():\n            ans //= math.factorial(v)\n        return ans", "class Solution:\n    def numSquarefulPerms(self, A):\n        A.sort()\n        N = len(A)\n        graph = [[0] * N for _ in range(N)]\n\n        for i in range(N):\n            for j in range(N):\n                if i==j: continue\n                if int((A[i]+A[j])**0.5)**2==(A[i]+A[j]):\n                    graph[i][j]=1\n                    graph[j][i]=1\n\n\n        dp=[[0]*N for i in range(1<<N)]\n        for i in range(N):\n            dp[1<<i][i]=1\n        for s in range(1<<N):\n            for i in range(N):\n                if not dp[s][i]: continue\n                for j in range(N):\n                    if not graph[i][j]: continue\n                    if s&(1<<j): continue\n                    if j>0 and s&(1<<(j-1)) and A[j]==A[j-1]:continue\n                    dp[s|(1<<j)][j]+=dp[s][i]\n\n        ans=0\n        for i in range(N):\n            ans+=dp[-1][i]\n\n        return ans\n        \n\n        \n", "from collections import Counter\n\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        \n        counts = Counter(A)\n        graph = {x: [] for x in counts}\n        \n        for x in counts:\n            for y in counts:\n                r = int((x + y) ** 0.5 + 0.5)\n                if r * r == x + y:\n                    graph[x].append(y)\n                    \n        def dfs(x, todo):\n            counts[x] -= 1\n            if todo == 0:\n                res = 1\n            else:\n                res = 0\n                for y in graph[x]:\n                    if counts[y] > 0:\n                        res += dfs(y, todo - 1)\n\n            counts[x] += 1\n            return res\n            \n            \n        return sum(dfs(x, len(A) - 1) for x in counts)", "from collections import Counter\nfrom functools import lru_cache\nimport math\n\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        # Backtracking\n        # Time  complexity: O(N^N)\n        # Space complexity: O(N)\n        # N = len(A)\n        # count = Counter(A)\n\n        # graph = {x: [] for x in count}\n        # for x in count:\n        #     for y in count:\n        #         if int((x + y) ** .5 + 0.5) ** 2 == x + y:\n        #             graph[x].append(y)\n\n        # def dfs(x, todo):\n        #     count[x] -= 1\n        #     if todo == 0:\n        #         ans = 1\n        #     else:\n        #         ans = 0\n        #         for y in graph[x]:\n        #             if count[y]:\n        #                 ans += dfs(y, todo - 1)\n\n        #     count[x] += 1\n        #     return ans\n\n        # return sum(dfs(x, len(A) - 1) for x in count)\n\n\n        # Dynamic Programming\n        # Time  complexity: O(N^2 x 2^N) = O(sum_{k=1}^{N} C_N^K x C_k^2)\n        # Space complexity: O(N x 2^N)\n        N = len(A)\n\n        def edge(x, y):\n            r = math.sqrt(x + y)\n            return int(r + 0.5) ** 2 == x + y\n\n        graph = [[] for _ in range(len(A))]\n        for i, x in enumerate(A):\n            for j in range(i):\n                if edge(x, A[j]):\n                    graph[i].append(j)\n                    graph[j].append(i)\n\n        # find num of hamiltonian paths in graph\n        @lru_cache(None)\n        def dfs(node, visited):\n            if visited == (1 << N) - 1:\n                return 1\n\n            ans = 0\n            for nei in graph[node]:\n                if (visited >> nei) & 1 == 0:\n                    ans += dfs(nei, visited | 1 << nei)\n            return ans\n\n        ans = sum(dfs(i, 1 << i) for i in range(N))\n        count = Counter(A)\n        for v in list(count.values()):\n            ans //= math.factorial(v)\n        return ans\n\n\n        # c = Counter(A)\n        # cand = {i: {j for j in c if int((i+j)**.5) ** 2 == i + j} for i in c}\n        # self.res = 0\n\n        # def dfs(x, left=len(A)-1):\n        #     c[x] -= 1\n        #     if left == 0:\n        #         self.res += 1\n        #     for y in cand[x]:\n        #         if c[y]:\n        #             dfs(y, left - 1)\n        #     c[x] += 1\n\n        # for x in c: dfs(x)\n        # return self.res\n\n\n        # def backtrack(i, A):\n        #     if i > 1:\n        #         val = A[i - 2] + A[i - 1]\n        #         is_square = math.sqrt(val) == math.floor(math.sqrt(val))\n        #         if not is_square:\n        #             return\n\n        #     if i == len(A):\n        #         output.append(A)\n        #         return\n\n        #     for j in range(i, len(A)):\n        #         A[i], A[j] = A[j], A[i]\n        #         search = (i, A[i], tuple(A[:i]))\n        #         if search not in seen:\n        #             seen.add(search)\n        #             backtrack(i + 1, A)\n\n        #         A[i], A[j] = A[j], A[i]\n\n        # output, seen = [], set()\n        # backtrack(0, A)\n        # return len(output)\n\n", "class Solution:\n    \n    def dfs(self, pos):\n        if pos==self.n:\n            self.ans += 1\n            return\n        \n        last = None\n        for i, val in enumerate(self.a):\n            if self.usable[i]:\n                if val == last:\n                    continue\n                if pos-1 >= 0 and (val + self.rec[pos-1]) not in self.square:\n                    continue\n                \n                self.usable[i] = False\n                self.rec[pos] = val\n                self.dfs(pos + 1)\n                self.usable[i] = True\n                last = val\n    \n    def numSquarefulPerms(self, A: List[int]) -> int:\n        \n        self.a = sorted(A)\n        self.square=set()\n        i = 0 # not 1\n        while i*i <= self.a[-1]*2:\n            self.square.add(i*i)\n            i += 1\n        \n        #print(self.square)\n        self.ans = 0\n        self.n = len(self.a)       \n        self.usable = [True]*self.n\n        self.rec = [None]*self.n\n        self.dfs(0)\n        return self.ans\n        \n        \n        \n", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        \n        d = defaultdict(int)\n        res = 0\n        \n        ps = {}\n        i = 0\n        while i*i <= 2*max(A):\n            ps[i*i]=True\n            i += 1\n            \n        def ok(x):\n            return x in ps\n        \n        def solve(x):\n            nonlocal res\n            # takes some number X and multiset D. Returns answer of the problem for numbers in D such that first number is X\n            if not len(d):\n                res += 1\n                return\n            for k in list(d.keys()):\n                if not ok(x + k): continue\n                d[k] -= 1\n                if d[k] == 0: del d[k]\n                solve(k)\n                d[k] += 1\n                \n            \n        for x in A: d[x] += 1\n        for k in list(d.keys()):\n            d[k] -= 1\n            if not d[k]: del d[k]\n            solve(k)\n            d[k] += 1\n            \n        return res\n                    \n", "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def helper(self, last_num, used, partners, index):\n        if index == len(used):\n            return 1\n        total = 0\n        # print(partners, partners[last_num])\n        for partner, partner_list in partners[last_num].items():\n            for partner_index in partner_list:\n                if not used[partner_index]:\n                    used[partner_index] = True\n                    total += self.helper(partner, used, partners, index+1)\n                    used[partner_index] = False\n                    break\n        return total\n\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        squares = set()\n        i = 0\n        partners = defaultdict(lambda: defaultdict(set))\n        while i * i <= 200000000:\n            squares.add(i*i)\n            i += 1\n        for i in range(len(A)):\n            for j in range(i+1, len(A), 1):\n                if A[i] + A[j] in squares:\n                    partners[A[i]][A[j]].add(j)\n                    partners[A[j]][A[i]].add(i)\n        unique_nums = dict()\n        for i, num in enumerate(A):\n            unique_nums[num] = i\n        used = [False for _ in A]\n        total = 0\n        for num, i in unique_nums.items():\n            used[i] = True\n            total += self.helper(num, used, partners, 1)\n            used[i] = False\n        return total", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n\n        A.sort()\n        self.ans = 0\n\n        def check(A, i, path):\n            return int((A[i] + path[-1])**0.5 + 0.0)**2 == A[i] + path[-1]\n\n        def dfs(A, path):\n            if len(A) == 0:\n                self.ans += 1\n                return\n\n            for i in range(len(A)):\n                if i > 0 and A[i] == A[i - 1]:\n                    continue\n                if len(path) == 0 or (len(path) > 0 and check(A, i, path)):\n                    dfs(A[:i] + A[i + 1:], path + [A[i]])\n\n        dfs(A, [])\n        return self.ans\n", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        def edge(x, y):\n            return int((x + y) ** 0.5) ** 2 == (x + y)\n        \n        def dfs(x, t):\n            count[x] -= 1\n            if t == 0:\n                ans = 1\n            else:\n                ans = 0\n                for y in graph[x]:\n                    if count[y]:\n                        ans += dfs(y, t - 1)\n            count[x] += 1\n            return ans\n                    \n        N = len(A)\n        count = collections.Counter(A)\n        graph = collections.defaultdict(list)\n        for x in count:\n            for y in count:\n                if edge(x, y):\n                    graph[x].append(y)\n                    \n        return sum(dfs(x, N - 1) for x in count)\n                    \n        \n    \n    \n        \n", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        A.sort()\n        n = len(A)\n        visited = [False] * n\n        res = []\n        self.count = 0\n        def dfs(curr):\n            if len(curr) == n:\n                self.count += 1\n                return \n            for i in range(n):\n                if visited[i]: continue \n                if i > 0 and A[i] == A[i - 1] and not visited[i - 1]: continue \n                if len(curr) > 0 and (int((curr[-1] +  A[i]) ** 0.5))**2 != curr[-1] +  A[i]: continue \n                visited[i] = True\n                dfs(curr + [A[i]])\n                visited[i] = False\n        dfs([])\n        return self.count\n", "from math import sqrt\nclass Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        return self.backtrack(A, 0, set())\n    \n    def isPerfect(self, num):\n        return int(sqrt(num))**2 == num\n        \n    def backtrack(self, permutation, j, seen):\n        permutation_tuple = (j,) + tuple(permutation)\n        if permutation_tuple in seen: return 0\n        seen.add(permutation_tuple)\n        if j == len(permutation):\n            return 1\n        total = 0\n        for i in range(j, len(permutation)):\n            self.swap(permutation, i, j)\n            if j == 0 or self.isPerfect(permutation[j] + permutation[j-1]):\n                total += self.backtrack(permutation, j+1, seen)\n            self.swap(permutation, i, j)\n        return total\n    \n    def swap(self, array, i, j):\n        array[i], array[j] = array[j], array[i]\n", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        count ={}\n        for i in A:\n            count[i]=count.get(i,0)+1\n        graph = {x: [] for x in A}\n        for x in count:\n            for y in count:\n                if int((x + y) ** 0.5 + 0.5) ** 2 == x + y:\n                    graph[x].append(y)\n        def dfs(x, todo):\n            count[x] -= 1\n            if todo == 0:\n                ans = 1\n            else:\n                ans = 0\n                for y in graph[x]:\n                    if count[y]:\n                        ans += dfs(y, todo - 1)\n            count[x] += 1\n            return ans\n\n        return sum(dfs(x, len(A) - 1) for x in count)\n", "class Solution:\n    def numSquarefulPerms(self, A: List[int]) -> int:\n        c = {}\n        for i in A:\n            c[i]=c.get(i,0)+1\n        cand = {i: [j for j in c if int((i + j)**0.5) ** 2 == i + j] for i in c}\n\n        def dfs(x, left=len(A) - 1):\n            c[x] -= 1\n            count = sum(dfs(y, left - 1) for y in cand[x] if c[y]) if left else 1\n            c[x] += 1\n            return count\n        return sum(map(dfs, c))\n"]