["class CombinationIterator:\n    def __init__(self, characters: str, combinationLength: int):\n        self.nextCombIt = combinations(characters, combinationLength)\n        self.nextComb = next(self.nextCombIt, None)\n\n    def __next__(self) -> str:\n        nextComb = self.nextComb\n        self.nextComb = next(self.nextCombIt, None)\n        return ''.join(nextComb)\n\n    def hasNext(self) -> bool:\n        return self.nextComb is not None\n", "from itertools import combinations\nfrom math import factorial\nclass CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.base = characters\n        self.start = 0\n        self.end = factorial(len(characters)) / factorial(combinationLength) / factorial(len(characters)-combinationLength)\n        self.strBase = combinations(characters, combinationLength)\n\n    def __next__(self) -> str:\n        if self.hasNext():\n            self.start += 1\n            val = next(self.strBase)\n            return ''.join(val)\n        else:\n            raise StopIteration\n\n    def hasNext(self) -> bool:\n        return self.start < self.end\n        \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.combinations = self.get_combinations(characters,combinationLength,0)        \n        self.next_item=0\n\n    def next(self) -> str:\n        ans= self.combinations[self.next_item]\n        self.next_item+=1\n        return \\\"\\\".join(ans)\n\n    def hasNext(self) -> bool:\n        return self.next_item < len(self.combinations)\n\n    def get_combinations(self,chars, k, start):\n        ans = []\n        if k == 0:\n            return ans\n        if k==1:\n            return [[char] for char in chars[start:] ]\n        count = 0\n        for c in chars[start:]:\n            for comb in self.get_combinations(chars, k - 1,start+count+1):\n                    temp = []\n                    temp.append(c)\n                    temp.extend(comb)\n                    ans.append(temp)\n            count+=1\n        return ans\n\n            \n        \n        \n        \n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()", "class CombinationIterator:\n\n    def __init__(self, arr: str, l: int):\n        self.result = []\n        self.idx = 0\n        n = len(arr)\n        \n        self.backtrack(arr, 0, l, n, \\\"\\\")\n                        \n    def backtrack(self, arr, left, ln, n, currStr):\n        if ln == 0:\n            self.result.append(\\\"\\\".join(sorted(currStr)))\n            return\n        \n        for i in range(left, n):\n            \n            newStr = currStr\n            newStr += arr[i]\n            \n            self.backtrack(arr, i+1, ln-1, n, newStr)\n        \n\n    def next(self) -> str:\n        res = self.result[self.idx]\n        self.idx += 1\n        return res\n        \n\n    def hasNext(self) -> bool:\n        if self.idx >= len(self.result):\n            return False\n        \n        return True\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.combs = []\n        \n        n = len(characters)\n        # the order in self.combs is reverse lexicographical by going from bitmask of 0 upwards\n        for bitmask in range((1<<n)): \n            if bin(bitmask).count('1') == combinationLength: \n                curr = []\n                for j in range(n): \n                    if bitmask & (1 << n-j-1): \n                        curr.append(characters[j])\n                self.combs.append(''.join(curr))\n\n\n    def __next__(self) -> str:\n        return self.combs.pop()\n\n    def hasNext(self) -> bool:\n        return self.combs\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.characters = characters\n        self.len = combinationLength\n        self.dic = deque([x for x in itertools.combinations(self.characters,self.len)])\n\n    def next(self) -> str:\n        x = self.dic.popleft()\n        return \\\"\\\".join(x)\n        \n    def hasNext(self) -> bool:\n        if len(self.dic) != 0:\n            return True\n        return False\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        def dfs(start, path):\n            if len(path)==self.combinationLength:\n                yield ''.join(path)\n            else:\n                for i in range(start, len(self.characters)):\n                    path.append(self.characters[i])\n                    yield from dfs(i+1, path)\n                    path.pop()\n        \n        self.characters = sorted(characters)\n        self.combinationLength = combinationLength\n        self.next_val = None\n        self.comb = dfs(0, [])\n \n    def __next__(self) -> str:\n        if self.next_val:\n            tmp = self.next_val\n            self.next_val = None\n            return tmp\n        else:\n            return next(self.comb)\n\n    def hasNext(self) -> bool:\n        if self.next_val:\n            return True\n        else:\n            self.next_val = next(self.comb,False)\n            return bool(self.next_val)\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.combinations = []\n        self.characters = characters\n        self.combinationLength = combinationLength\n        \n    \n        def backtrack(characters,res,cur,index):\n            if len(cur) == combinationLength:\n                #print(cur)\n                res.append(\\\"\\\".join(cur[:]))\n                return\n            for i in range(index,len(self.characters)):\n                cur.append(self.characters[i])\n                #print(cur)\n                backtrack(characters,res,cur,i+1)\n                cur.pop()\n        \n        backtrack(characters,self.combinations,[],0)\n        self.combinationsQueue = deque(self.combinations)\n        print(self.combinationsQueue)\n    def next(self) -> str:\n        if self.combinationsQueue:\n            return self.combinationsQueue.popleft()\n\n    def hasNext(self) -> bool:\n        return len(self.combinationsQueue) > 0\n        \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.combinations = []\n        self.characters = characters\n        self.combinationLength = combinationLength\n        \n    \n        def backtrack(characters,res,cur,index):\n            if len(cur) == combinationLength:\n                #print(cur)\n                res.append(\\\"\\\".join(cur[:]))\n                return\n            for i in range(index,len(self.characters)):\n                cur.append(self.characters[i])\n                #print(cur)\n                backtrack(characters,res,cur,i+1)\n                cur.pop()\n        \n        backtrack(characters,self.combinations,[],0)\n        self.combinationsQueue = deque(self.combinations)\n        #print(self.combinationsQueue)\n    def next(self) -> str:\n        if self.combinationsQueue:\n            return self.combinationsQueue.popleft()\n\n    def hasNext(self) -> bool:\n        return len(self.combinationsQueue) > 0\n        \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()", "from queue import Queue\nclass CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        \n        self.characters=characters\n        self.combinationLength=combinationLength\n        self.arr=[0]*26\n        for i in self.characters:\n            temp=ord(i)\n         \n            self.arr[temp-97]+=1\n            \n        \n        self.q=Queue(maxsize=10001)\n        self.solve(self.arr,self.combinationLength,self.q,0,\\\"\\\")\n        \n        \n        \n    \n    \n    def solve(self,arr,sizee,bag,ind,cur):\n        if(len(cur)==sizee):\n            bag.put(cur)\n            return bag\n        \n        \n        for i in range(ind,26):\n            if(arr[i]!=0):\n                arr[i]-=1\n                bag=self.solve(arr,sizee,bag,i,cur+chr(i+97))\n            \n                arr[i]+=1\n        \n        return bag\n                \n                \n                \n                \n        \n\n    def next(self) -> str:\n        \n        return self.q.get()\n\n    def hasNext(self) -> bool:\n        return not self.q.empty()\n        \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()", "def rec(s, l, arr, current):\n    for i in range(len(s)):\n        current.append(s[i])\n        if len(current)==l:\n            arr.append(''.join(current))\n        rec(s[i+1:],l,arr,current)\n        current.pop(len(current)-1)\n        \n\nclass CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.characters = characters\n        self.combinationLength = combinationLength\n        self.index = 0\n        self.arr = []\n        c = []\n        rec(characters, combinationLength, self.arr,c)\n\n    def __next__(self) -> str:\n        ret = self.arr[self.index]\n        self.index+=1\n        return ret\n\n    def hasNext(self) -> bool:\n        if self.index<len(self.arr):\n            return True\n        return False\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.input_string = characters\n        self.queue = []\n        self.combinationLength = combinationLength\n        self.generate(0, '')\n        \n    def generate(self, start_index, acc_string):\n        if len(acc_string)==self.combinationLength:\n            self.queue.append(acc_string) \n            return\n        \n        for i in range(start_index, len(self.input_string)):\n            self.generate(i+1, acc_string + self.input_string[i])\n        \n    def __next__(self) -> str:\n        return self.queue.pop(0)\n\n    def hasNext(self) -> bool:\n        return len(self.queue)!=0\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.comb = list(map(lambda x: \\\"\\\".join(x), list(itertools.combinations(characters,combinationLength))))[::-1]\n\n\n    def next(self) -> str:\n        return self.comb.pop()\n\n    def hasNext(self) -> bool:\n        return (len(self.comb) != 0)      \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.N = combinationLength\n        self.cl = len(characters)\n        self.sym = characters\n        self.precom = self.__pre(self.cl, combinationLength)\n        self.index = len(self.precom)-1\n    def __next__(self) -> str:\n        curr = self.precom[self.index]\n        res = []\n        for i,c in enumerate(curr):\n            if c == '1':\n                res.append(self.sym[i])\n        self.index -= 1\n        return ''.join(res)\n    def hasNext(self) -> bool:\n        if self.index < 0:\n            return False\n        return True\n    def __pre(self, N, M):\n        maxi = 2**N\n        res = []\n        for curr in range(maxi):\n            binary = bin(curr)[2:]\n            if binary.count('1') == M:\n                res.append(binary.zfill(N))\n        return res\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n\n\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.chars = characters\n        self.n = combinationLength\n        self.inds = [i for i in range(combinationLength)]\n        self.iMax = len(self.chars)\n        self.gotNext = True\n\n    def __next__(self) -> str:\n        print((self.inds))\n        ans = ''.join([self.chars[i] for i in self.inds])\n        c = 1\n        i = self.n -1\n        while i >= 0 and c == 1:\n            if self.inds[i] == self.iMax-self.n+i:\n                c = 1\n            else:\n                c = 0\n            i -= 1\n        if i == -1 and c == 1:\n            self.gotNext = False\n        else:\n            self.inds[i+1] += 1\n            for j in range(i+2, self.n):\n                self.inds[j] =  self.inds[j-1] +1\n        \n        \n#         for i in range(self.n-1, -1 ,-1):\n#             self.inds[i] += c\n#             if self.inds[i] == self.iMax-self.n+i+1:\n#                 if i != 0:\n#                     self.inds[i] = self.inds[i-1] + 2\n#                     c = 1\n#                 else:\n#                     self.gotNext = False\n#             else:\n#                 c = 0\n        return ans\n\n    def hasNext(self) -> bool:\n        return self.gotNext\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.combs = list(combinations(characters, combinationLength))\n        self.idx = 0\n        \n\n    def next(self) -> str:\n        chars = self.combs[self.idx]\n        self.idx += 1\n        return \\\"\\\".join(chars)\n        \n\n    def hasNext(self) -> bool:\n        return self.idx < len(self.combs)\n        \n        \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.nums = [i for i in range(combinationLength)]\n        self.characters = characters\n        self.s = len(characters)\n        self.len = combinationLength\n        self.is_next = True\n        \n    def __next__(self) -> str:\n        ret = ''\n        for n in self.nums:\n            ret += self.characters[n]\n        \n        self.nums[-1] += 1\n        if self.nums[-1] == self.s:\n            carry = True\n            cnt = -2\n            while carry and cnt >= -self.len:\n                self.nums[cnt] += 1\n                if self.nums[cnt] > self.s + cnt:\n                    carry = True\n                    cnt -= 1\n                else:\n                    carry = False\n        \n            if cnt < -self.len:\n                self.is_next = False\n            else:\n                for i in range(cnt+1, 0, 1):\n                    self.nums[i] = self.nums[i-1] + 1\n                \n        # print(self.nums)\n        return ret\n    \n    def hasNext(self) -> bool:\n        return self.is_next\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.s=characters\n        self.k=combinationLength\n        self.r=[]\n        self.dfs('',0)\n    def dfs(self,st,idx):\n        if len(st)==self.k:\n            self.r.append(st)\n            return\n        for i in range(idx,len(self.s)):\n            self.dfs(st+self.s[i],i+1)\n\n    def __next__(self) -> str:\n        return self.r.pop(0)\n        \n\n    def hasNext(self) -> bool:\n        return len(self.r)!=0\n        \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "import itertools\n\nclass CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        char_arr = list(characters)\n        self.data = itertools.combinations(char_arr, combinationLength)\n        self.count = len(list(itertools.combinations(char_arr, combinationLength)))\n\n    def __next__(self) -> str:\n        ans = ''.join(next(self.data, ''))\n        self.count -= 1\n        return ans\n\n    def hasNext(self) -> bool:\n        return self.count > 0\n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.chs = characters\n        self.comblen = combinationLength\n        self.totlen = len(self.chs)\n        self.idx = [_ for _ in range(self.comblen)]\n        self.idx[-1] -= 1\n\n\n    def __next__(self) -> str:\n        k = self.comblen  # the digit where the calculation stop propagating\n        while k > 0:\n            k -= 1\n            self.idx[k] += 1\n            if self.idx[k] < self.totlen + k + 1 - self.comblen:\n                break\n        for i in range(k+1, self.comblen):\n            self.idx[i] = self.idx[i-1] + 1\n\n        return ''.join([self.chs[k] for k in self.idx])\n\n    def hasNext(self) -> bool:\n        return self.idx[0] != self.totlen - self.comblen\n        \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.last = None\n        self.end = characters[-combinationLength:]\n        self.gen = self.gen_comb(characters, 0, [], combinationLength)\n    \n    def gen_comb(self, char, start, buffer, length):\n        if len(buffer) == length:\n            yield ''.join(buffer)\n            return\n        \n        for i in range(start, len(char)):\n            yield from self.gen_comb(char, i+1, buffer+[char[i]], length)\n        \n    def __next__(self) -> str:\n        self.last = next(self.gen)\n        return self.last  \n\n    def hasNext(self) -> bool:\n        return self.last != self.end\n        \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n", "class CombinationIterator:\n\n    def __init__(self, characters: str, combinationLength: int):\n        self.combo = []\n        self.find_combo(0, combinationLength, characters, \\\"\\\")\n        self.combo.sort()\n        self.pos = -1\n        \n        \n\n    def next(self) -> str:\n        self.pos += 1\n        \n        return self.combo[self.pos]\n        \n        \n    def hasNext(self) -> bool:\n        return self.pos + 1 < len(self.combo)\n    \n    def find_combo(self, idx, end, characters, cur):\n        if idx == len(characters):\n            if len(cur) == end:\n                self.combo.append(cur[:])\n        \n        else:\n            self.find_combo(idx + 1, end, characters, cur + characters[idx])\n            self.find_combo(idx + 1, end, characters, cur)\n            \n            \n        \n        \n\n\n# Your CombinationIterator object will be instantiated and called as such:\n# obj = CombinationIterator(characters, combinationLength)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()"]