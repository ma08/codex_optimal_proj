["def mult_primefactor_sum(a, b): \n    s=[]\n    for i in range(a,b+1):\n       r=factorize_add(i)\n       if r!=i and i%r==0: s.append(i)\n    return s\n    \ndef factorize_add(num):\n    if num<4: return num\n    d=2; p=0\n    while d<num**.5+1:\n        while not num%d: p+=d; num/=d\n        d+=1 if d==2 else 2\n    return p if num==1 else p+num", "def mult_primefactor_sum(a, b):\n    ret = []\n    for m in range(a, b + 1):\n        p, s, n = 2, 0, m\n        while n > 1 and p <= n ** .5:\n            while n % p == 0:\n                s += p\n                n //= p\n            p += 1\n        s += n > 1 and n\n        if s < m and m % s == 0:\n            ret.append(m)\n    return ret", "from bisect import bisect_left, bisect_right\n\ndef spf(n):\n    result = 0\n    nd = 0\n    while n % 2 == 0:\n        result += 2\n        nd += 1\n        n //= 2\n    d = 3\n    while n > 1:\n        while n % d == 0:\n            result += d\n            n //= d\n            nd += 1\n        d += 2\n    return n+1 if nd == 1 else (result or n+1)  # nd == 1 -> prime\n\nxs = [x for x in range(1, 20001) if x % spf(x) == 0]\n\ndef mult_primefactor_sum(a, b):\n    i = bisect_left(xs, a)\n    j = bisect_right(xs, b)\n    return xs[i:j]", "def mult_primefactor_sum(a, b):\n    prime_factors = [factorize(n) for n in range(a, b+1)]\n    return [n for n, pf in enumerate(prime_factors, a) if len(pf) > 1 and n % sum(pf) == 0]\n\n\n# Memoization and this factorization algorithm are overkill here,\n# one of them is enough (I didn't try none of them).\n# More simple than memoize is to precompute prime_factors, if you\n# know the max number to factorize (seems to be 20000 here).\n\ndef memoize(func):\n    cache = {}\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n    return wrapper\n\n@memoize\ndef factorize(n):\n    if n < 2:\n        return []\n    factors = []\n    for k in (2, 3):\n        while n % k == 0:\n            n //= k\n            factors.append(k)\n    k = 5\n    step = 2\n    while k * k <= n:\n        if n % k:\n            k += step\n            step = 6 - step\n        else:\n            n //= k\n            factors.append(k)\n    if n > 1:\n        factors.append(n)\n    return factors", "''' keep track of numbers checked '''\nNUMS = [0, 0]\n\ndef mult_primefactor_sum(a, b):\n    \n    ''' only check numbers greater than before '''\n    for n in range(len(NUMS), b+1):\n        x, div, factors = n, 2, []\n        \n        ''' generate prime factors '''\n        while x > 1:\n            if x % div == 0:\n                factors.append(div)\n                x //= div\n            else:\n                div += 1 if div == 2 else 2\n        \n        ''' store number if it fulfills the conditions, otherwise put 0 '''\n        if len(factors) == 1 or n % sum(factors) != 0:\n            NUMS.append(0)\n        else:\n            NUMS.append(n)\n    \n    ''' return the results '''\n    return [ x for x in NUMS[a:b+1] if x ]", "def primes(n):\n    primfac = []\n    d = 2\n    while d*d <= n:\n        while (n % d) == 0:\n            primfac.append(d)\n            n //= d\n        d += 1\n    if n > 1:\n       primfac.append(n)\n    return primfac\ndef mult_primefactor_sum(a, b): \n    l = []\n    for i in range(a, b+1):\n        factors = primes(i) \n        if i>sum(factors) and not i%sum(factors):\n            l.append(i)\n    return l", "def prime_factorizations(n):\n    sieve = [0 for x in range(n)]\n    for i in range(2, n):\n        if not sieve[i]:\n            sieve[i] = i\n            for r in range(i, n, i):\n                sieve[r] = sieve[r] or i\n    return sieve\n\ndef factor_sum(sieve, n):\n    results = 0\n    while n > 1:\n        p = sieve[n]\n        results += p\n        if p == n:\n            break\n        n //= p\n    return results\n\ndef mult_primefactor_sum(a, b):\n    sieve = prime_factorizations(b+1)\n    return [n for n in range(a, b+1) if sieve[n]!=n and n%factor_sum(sieve, n)==0]", "def prime_factors(n):\n    if n%2==0 and n>0:return [2]+prime_factors(n//2)\n       \n    for a in range(3,int(n**.5)+1,2):            \n        if n%a==0:return sorted(prime_factors(n//a)+prime_factors(a))        \n    return [n] if n>1 else []\n\ndef mult_primefactor_sum(a, b): # [a, b] range of numbers included a and b\n    return [c for c in range(a,b+1) if len(prime_factors(c))>1 and c%sum(prime_factors(c))==0]"]