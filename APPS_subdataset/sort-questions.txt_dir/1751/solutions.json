["from heapq import *\nfrom itertools import starmap\nfrom collections import deque, namedtuple\n\nArmy    = namedtuple('Army', 'i,q')\nSoldier = namedtuple('Soldier', 'i,speed')\n\n\ndef queue_battle(d, *args):\n    armies  = [ Army(i, deque(starmap(Soldier,enumerate(q))) ) for i,q in enumerate(args)]\n    bullets = [[] for _ in range(len(armies))]        # bullet[i] shoots at armies[i+1]\n    t       = 0\n    \n    while len(armies)>1:\n        t     += 1\n        alives = [1]*len(armies)\n        \n        for i,q in enumerate(bullets):\n            if q and q[0]<=t:    alives[ (i+1)%len(armies) ] = 0\n            while q and q[0]<=t: heappop(q)\n        \n        emptyArmies = False\n        for i,alive in enumerate(alives):\n            if alive:\n                heappush(bullets[i], t + d/armies[i].q[0].speed)\n                armies[i].q.rotate(-1)\n            else:\n                armies[i].q.popleft()\n                emptyArmies |= not armies[i].q\n        \n        if emptyArmies:\n            armies  = [army for army in armies if army.q]\n            bullets = [[] for _ in range(len(armies))]\n            \n    if not armies: return (-1,())\n    win = armies.pop()\n    return (win.i, tuple(soldier.i for soldier in win.q))", "\ndef queue_battle(dist,*armies):\n\n    armies_copy = [*armies]\n    armies= [[*a] for a in armies]\n    armies_left = [i for i in range(len(armies))]\n    soldiers_id = [[i for i in range(len(army))] for army in armies]\n    bullets_between = [[] for i in armies_left]\n\n    while True:\n\n        bullets_between = [[[s, s+l] for (s, l) in bullets] for bullets in bullets_between]\n        recovering_armies = []\n\n        for i in range(len(bullets_between)):\n            for j in range(len(bullets_between[i])):\n                if bullets_between[i][j][1] >= dist:\n                    del armies[armies_left[(i+1)%len(armies_left)]][0]\n                    del soldiers_id[armies_left[(i+1)%len(armies_left)]][0]\n                    recovering_armies.append(armies_left[(i+1)%len(armies_left)])\n                    break\n            bullets= []\n            for j in range(len(bullets_between[i])):\n                if bullets_between[i][j][1] < dist:\n                    bullets.append(bullets_between[i][j])\n            bullets_between[i] = bullets\n\n        for i in range(len(armies_left)):\n            if armies_left[i] not in recovering_armies:\n                bullet_speed = armies[armies_left[i]][0]\n                bullets_between[i].append( [bullet_speed, 0] )\n\n        if len(armies_left) == 0: \n            return (-1, ())\n        if len(armies_left) == 1:\n            return (armies_left[0], tuple(soldiers_id[armies_left[0]]))\n\n        for i in range(len(armies_left)):\n            if armies_left[i] not in recovering_armies:\n                soldiers_id[armies_left[i]].append(soldiers_id[armies_left[i]].pop(0))\n                armies[armies_left[i]].append(armies[armies_left[i]].pop(0))\n\n        armies_left_new = [*armies_left]\n        for i in range(len(armies_left)):\n            if len(armies[armies_left[i]]) == 0:\n                armies_left_new.remove(armies_left[i])\n                bullets_between = [[] for i in armies_left_new]\n\n        armies_left = armies_left_new\n\n    return ", "def queue_battle(dist, *armies0):\n    armies = [{'idx': idx, 'soldier': [{'idx': idx, 'speed': el, 'remove': False} for idx, el in enumerate(a)]} for idx, a in enumerate(armies0)]\n    bullets = [[] for i in range(len(armies))]\n    \n    while len(armies) > 1:\n        for i in range(len(bullets)):\n            bullets2 = list(filter(lambda d: d['dist'] < dist, map(lambda d: {'dist': d['dist'] + d['speed'], 'speed': d['speed']}, bullets[i])))\n            if len(bullets2) != len(bullets[i]):\n                armies[(i + 1) % len(armies)]['soldier'][0]['remove'] = True\n                \n            bullets[i] = bullets2\n\n        armies = list(filter(lambda a: not (len(a['soldier']) == 1 and a['soldier'][0]['remove']), armies))\n        elimination = len(armies) != len(bullets)\n\n        for i in range(len(armies)):\n            el = armies[i]['soldier'].pop(0)\n            if not el['remove']:\n                bullets[i].append({'dist': 0, 'speed': el['speed']})\n                armies[i]['soldier'].append(el)\n\n        if elimination:\n            bullets = [[] for i in range(len(armies))]\n                \n    if len(armies) > 0:\n        return (armies[0]['idx'], tuple(map(lambda s: s['idx'], armies[0]['soldier'])))\n    \n    return (-1,()) ", "from collections import deque\n\nclass Bullet:\n    def __init__(self, speed, target_army):\n        self.time_to_hit = DIST / speed\n        self.target_army = target_army\n\n    def increment_time(self, seconds):\n        self.time_to_hit -= seconds\n\n    def has_hit(self):\n        return self.time_to_hit <= 0.0\n\nclass Soldier:\n    def __init__(self, original_index, bullet_speed):\n        self.original_index = original_index\n        self.bullet_speed = bullet_speed\n\n\n    def fire_bullet(self, target_army):\n        return Bullet(self.bullet_speed, target_army)\n\nclass Army:\n    def __init__(self, original_index, soldiers):\n        # using deque for simpler rotations\n        self.soldiers = deque(soldiers)\n        self.original_index = original_index\n\n    def fire_bullet(self, target_army):\n        if self.is_wiped_out():\n            raise Exception('tried to fire bullet on wiped out army!')\n\n        bullet = self.soldiers[0].fire_bullet(target_army)\n        self.soldiers.rotate(-1)\n        return bullet\n\n\n    def is_wiped_out(self):\n        return len(self.soldiers) == 0\n\n    def eliminate_head(self):\n        if self.is_wiped_out():\n            raise Exception('tried to kill someone on wiped out army!')\n        self.soldiers.popleft()\n\n\nclass Battlefield:\n    def __init__(self, armies):\n        self.armies = armies\n        self.bullets = []\n\n    def increment_second(self):\n        # need to keep track of which armies were already hit with a bullet, so we don't\n        # eliminate more than one person per round\n        armies_hit = []\n\n        for bullet in self.bullets:\n            bullet.increment_time(1)\n            if bullet.has_hit() and bullet.target_army not in armies_hit:\n                target = self.armies[bullet.target_army]\n                target.eliminate_head()\n                armies_hit.append(bullet.target_army)\n\n\n        # each army which was not hit this round fires one bullet\n        for i, army in enumerate(self.armies):\n            if not i in armies_hit:\n                bullet = army.fire_bullet((i + 1) % len(self.armies))\n                self.bullets.append(bullet)\n\n        \n        if any(army.is_wiped_out() for army in self.armies):\n            # reset bullet list\n            self.bullets = []\n            # reset army list(eliminate wiped out armies)\n            self.armies = [army for army in self.armies if not army.is_wiped_out()]\n        else:\n            # remove bullets which have already reached their target\n            self.bullets = [bullet for bullet in self.bullets if not bullet.has_hit()]\n\n\n    def do_battle(self):\n        while len(self.armies) > 1:\n            self.increment_second()\n\n        # return winner, or None\n        return self.armies[0] if self.armies else None\n\n\n\ndef queue_battle(dist,*armies):\n    # yes, I am too lazy to use these as constructor params for every class\n    nonlocal DIST, N_ARMIES\n    DIST = dist\n    N_ARMIES = len(armies)\n    \n    army_list = []\n    for i in range(N_ARMIES):\n        soldiers = [Soldier(j, speed) for j, speed in enumerate(armies[i])]\n        army_list.append(Army(i, soldiers))\n\n    battlefield = Battlefield(army_list)\n    winner = battlefield.do_battle()\n\n    if winner is None:\n        # no winner\n        return -1,()\n    else:\n        soldiers = tuple([soldier.original_index for soldier in winner.soldiers])\n        return winner.original_index, soldiers", "def queue_battle(dist,*armies):\n    \n    #declare variables\n    DIST = dist\n    ARMY_COUNT = len(armies)\n    \n    #Keep track of active armies - needed for reassigning targets\n    active_armies = []\n    for army in range (0,ARMY_COUNT):\n        active_armies.append(army)\n    \n    #Add each army and target to dictionary\n    queues = {}\n    for n, army in enumerate(armies):\n        if n==len(armies)-1:\n            target = 0\n        else:\n            target = n+1\n        queues[n]={'target':target,'army':{k:v for k,v in enumerate(list(army))}}\n    \n    #Declare variables for game loop\n    bullet_count = 1\n    bullets={}\n    no_victor = True\n    \n    #Start game loop\n    while no_victor:\n\n        #CODE FOR BULLETS\n        bullets_hit = []\n        targets_hit = []\n\n        #Check if any current bullets hit\n        for bullet, data in bullets.items():\n            bullets[bullet]['dist'] += bullets[bullet]['speed']\n            if bullets[bullet]['dist'] >= DIST:\n                bullets_hit.append(bullet)\n                targets_hit.append(bullets[bullet]['target'])\n        \n        #Remove bullets that hit\n        for bullet in bullets_hit:\n            bullets.pop(bullet)  \n            \n        #Fire off new bullets\n        armies_to_be_removed = []\n        for army in queues:\n            #find first key\n            fk = list(queues[army]['army'].keys())[0]\n            if army in targets_hit:\n                #Remove first soldier if hit\n                queues[army]['army'].pop(fk)\n                #Check if army has remaining soldiers\n                if len(queues[army]['army']) == 0:\n                    armies_to_be_removed.append(army)\n            else:\n                bullets[bullet_count]={'dist':0,'speed':queues[army]['army'][fk],'target':queues[army]['target']}\n                bullet_count += 1\n                #Rotate first soldier to the back\n                x = queues[army]['army'][fk] \n                queues[army]['army'].pop(fk)\n                queues[army]['army'][fk]=x\n                \n        #Remove current bullets if elimination occurs.        \n        if len(armies_to_be_removed) > 0:\n            bullets={}\n              \n        #Updates active_armies list\n        for army in armies_to_be_removed:\n            active_armies.remove(army)\n            queues.pop(army)\n            \n        #Assign new targets\n        for army in queues:\n            if queues[army]['target'] not in active_armies:\n                new_target=active_armies.index(army)+1\n                if new_target > len(active_armies)-1:\n                    new_target=0\n                queues[army]['target']=active_armies[new_target]\n           \n        #Ends loops if one or zero armies remain\n        if len(queues) <= 1:\n                no_victor=False\n    \n    #return based on victor (or lack thereof)\n    if active_armies == []:\n        return (-1,())\n    else:\n        winning_army = active_armies[0]\n        leftover_soldiers = list(queues[army]['army'].keys())\n        \n        return(winning_army,tuple(leftover_soldiers))", "from collections import deque, namedtuple, defaultdict\n\nArmy = namedtuple('Army', ('num', 'soldiers'))\nSoldier = namedtuple('Soldier', ('num', 'speed'))\n\ndef queue_battle(distance, *armies):\n    bullets = defaultdict(set)\n    now = 0\n    armies = [Army(an, deque(Soldier(sn, sp) for sn, sp in enumerate(army)))\n              for an, army in enumerate(armies)]\n    \n    while len(armies) > 1:\n        now += 1\n\n        fallen = bullets.pop(now, {})\n        eliminated = []\n        for ai in fallen:\n            armies[ai].soldiers.popleft()\n            if not armies[ai].soldiers: eliminated.append(ai)\n                \n        for ai, army in enumerate(armies):\n            if ai in fallen: continue\n            target = (ai + 1) % len(armies)\n            ttime = now + 1 + (distance-1) // army.soldiers[0].speed\n            bullets[ttime].add(target)\n            army.soldiers.rotate(-1)\n\n        if eliminated:\n            armies = [army for ai, army in enumerate(armies) if ai not in eliminated]\n            bullets.clear()\n\n    if armies:\n        return armies[0].num, tuple(s.num for s in armies[0].soldiers)\n    else:\n        return -1, ()\n", "from collections import deque\n\ndef play_round(dist, army_map):\n    armies = list(army_map.keys())\n    in_flight = {i: list() for i in armies}\n    fires_at = {src: dst for src, dst in zip(armies, armies[1:] + [armies[0]])}\n    \n    while True:\n        in_flight = {\n            i: [(travel - speed, speed) for travel, speed in bullets]\n            for i, bullets in list(in_flight.items())\n        }\n        for i, bullets in list(in_flight.items()):\n            if any(travel <= 0 for travel, _ in bullets):\n                in_flight[i] = [(travel, speed) for travel, speed in bullets if travel > 0]\n                army_map[fires_at[i]][0] = None, None\n\n        for i, army in list(army_map.items()):\n            j, head = army.popleft()\n            if head is not None:\n                in_flight[i].append((dist, head))\n                army.append((j, head))\n        \n        if any(len(army) == 0 for army in list(army_map.values())):\n            return {i: army for i, army in list(army_map.items()) if len(army) != 0}\n\n\ndef queue_battle(dist, *armies):\n    army_map = {\n        i: deque(enumerate(army))\n        for i, army in enumerate(armies)\n    }\n\n    while len(army_map) >= 2:\n        army_map = play_round(dist, army_map)\n    \n    if len(army_map) == 0:\n        return -1, tuple()\n    \n    i, army = list(army_map.items())[0]\n    return i, tuple(j for j, _ in army)\n", "from collections import deque\n\n\nclass Bullet:\n\n    def __init__(self, speed):\n        self.speed = speed  # speed bullet travels\n        self.location = 0  # distance travelled towards target\n\n    def update(self):\n        self.location += self.speed  # move bullet towards target\n\n\nclass Soldier:\n\n    def __init__(self, number, firing_speed):\n        self.number = number  # initial position of soldier in army\n        self.firing_speed = firing_speed  # speed of bullets soldier fires\n\n\nclass Army:\n\n    def __init__(self, number, firing_speeds):\n        self.number = number  # number associated with army\n        # convert input tuple of firing speeds of soldiers to deque of Soldier objects\n        self.soldiers = deque()\n        for n, firing_speed in enumerate(firing_speeds):\n            self.soldiers.append(Soldier(n, firing_speed))\n\n\ndef queue_battle(distance, *args):\n    \"\"\" Simulates battle. \"\"\"\n\n    armies = [Army(n, army) for n, army in enumerate(args)]  # list of Army objects\n\n    while len(armies) > 1:  # while armies still fighting\n\n        # reset bullets\n        bullets = {army: [] for army in range(len(armies))}  # target: list of bullets moving towards target\n\n        an_army_eliminated = False\n        while not an_army_eliminated:  # fight until 1 or more armies eliminated\n\n            # update bullet positions\n            for army in range(len(armies)):\n                for bullet in bullets[army]:\n                    bullet.update()\n\n            # for every army remove soldiers / fire as appropriate\n            for army in range(len(armies)):\n\n                for bullet in bullets[army]:\n                    if bullet.location >= distance:  # remove leading soldier if hit by bullet before can fire\n                        armies[army].soldiers.popleft()\n                        if not armies[army].soldiers:  # mark an army has been eliminated\n                            an_army_eliminated = True\n                        break\n\n                else:  # lead soldier not hit: fire and move to back\n                    target = army + 1 if army + 1 < len(armies) else 0\n                    firing_soldier = armies[army].soldiers[0]\n                    bullets[target].append(Bullet(firing_soldier.firing_speed))  # fire\n                    armies[army].soldiers.append(armies[army].soldiers.popleft())  # move to back\n\n            # remove bullets that hit\n            for army in range(len(armies)):\n                bullets[army] = [bullet for bullet in bullets[army] if bullet.location < distance]\n\n        armies = [army for army in armies if army.soldiers]  # eliminate armies with no soldiers remaining\n\n    # return number of remaining army and numbers of remaining soldiers\n    try:\n        remaining_army = armies[0]\n        return remaining_army.number, tuple(soldier.number for soldier in remaining_army.soldiers)\n    except IndexError:  # no armies remain :(\n        return -1, ()", "\n# A small class to represent a battalion\nclass Battalion:\n    def __init__(self, position, soldiers, hit):\n        self.position = position\n        self.soldiers = soldiers\n        self.hit = hit\n\n\ndef queue_battle(dist, *armies):\n    #list of bullets currency on the air\n    bullets = []\n    #converting tuple of tuples to list of lists containing tuples with each soldier and his original position\n    armies = [list((s, i) for i, s in enumerate(a)) for a in armies]\n    #creating a list of battalions to keep track of things\n    battalions = [Battalion(i, list(a), False) for i, a in enumerate(armies)]\n\n    #Run the loop until one or less battalions remain\n    while len(battalions) > 1:\n        #Check for any hits this round, in reverse order to allow removing of items inside loop\n        for b in reversed(bullets):\n            target = battalions[b[2]]\n            #Increase bullet distance by speed\n            b[0] = b[0] + b[1][0]\n            #Check if bullet reached the destination\n            if b[0] >= dist:\n                if not target.hit:\n                    #remove the front soldier of the queue hit, but only if queue wasn't already hit this round\n                    target.soldiers.pop(0)\n                    #Set hit to true to avoid further hits this round\n                    target.hit = True\n                #Remove bullet that hit target    \n                bullets.remove(b)\n\n        #A helper variable to track any eliminations\n        elim = 0\n        #Loop through battalions, in reverse order as well to allow elimination\n        for idx, ba in enumerate(reversed(battalions)):\n            #Remove battalion with no soldiers left, remove all bullets as there will be a position change\n            if not ba.soldiers:\n                battalions.remove(ba)\n                bullets = []\n                elim += 1\n            elif not ba.hit:\n                if elim == 0:\n                    #Reverse looping, so index 0 is really last, so should target battal\n                    if idx == 0:\n                        target = 0\n                    else:\n                        target = len(battalions) - idx\n                        if target >= len(battalions):\n                            target = 0\n                    #Shoot a new bullet with distance, speed and target battalion index\n                    bullets.append([0, ba.soldiers[0], target])\n                #Switch the current shooter to the back of the queue\n                ba.soldiers.insert(len(ba.soldiers), ba.soldiers[0])\n                ba.soldiers.pop(0)\n            ba.hit = False\n    if battalions:\n        pos = battalions[0].position\n        survivors = tuple([s[1] for s in battalions[0].soldiers])\n        return (pos,survivors)\n    else:\n        return (-1,())\n\n", "log = False\n\nfrom collections import deque\n\nclass Game():\n\n    def __init__(self, distance, armies):\n        self.round = 0\n        self.victory = False\n        self.distance = distance\n        self.armies = deque([Army(position=i, members=army_tuple) for i, army_tuple in enumerate(armies)])\n        self.bullets = set()\n\n    def print_state(self):\n        if log:\n            print('Armies:')\n            for army in self.armies:\n                print(army)\n            if self.bullets:\n                print('Bullets:')\n                for bullet in self.bullets:\n                    print(bullet)\n\n    def assign_targets(self):\n        if log:\n            print('-> Assigning targets')\n        for army, target in zip(self.armies, range(1, len(self.armies)+1)):\n            if target == len(self.armies):\n                target = 0\n            army.target = self.armies[target]\n        self.print_state()\n\n    def move_bullets(self):\n        if log:        \n            print('-> Moving bullets')\n        for bullet in self.bullets:\n            bullet.move()\n        self.print_state()\n\n    def kill_leaders(self):\n        if log:\n            print('-> Killing army leaders')\n        for bullet in self.bullets:\n            if bullet.distance_to_target <= 0:\n                bullet.target.leader.alive = False\n        self.bullets = {b for b in self.bullets if b.distance_to_target > 0}  # Clear bullets\n        self.print_state()\n\n    def fire_bullets(self):\n        if log:\n            print('-> Firing bullets')\n        for army in self.armies:\n            if army.leader.alive:\n                self.bullets.add(Bullet(target=army.target, speed=army.leader.bullet_speed, distance_to_target=self.distance))\n        self.print_state()\n\n    def regroup_armies(self):\n        if log:\n            print('-> Regrouping armies')\n        for army in self.armies:\n            army.regroup()\n        original_armies_count = len(self.armies)\n        self.armies = deque([army for army in self.armies if len(army.soldiers) > 0])\n        if len(self.armies) < original_armies_count:\n            self.bullets = set()\n        if len(self.armies) <= 1:\n            self.victory = True\n        self.print_state()\n\n    def render_victory(self):\n        if len(self.armies) < 1:\n            return (-1, ())\n        else:\n            return (self.armies[0].original_position, tuple([s.original_position for s in self.armies[0].soldiers]))\n\n    def game_loop(self):\n        while True:\n            if log:\n                print('--> Executing round {}'.format(self.round))\n            self.print_state()\n            self.assign_targets()\n            self.move_bullets()\n            self.kill_leaders()\n            self.fire_bullets()\n            self.regroup_armies()\n            if self.victory:\n                break\n            self.round += 1\n\nclass Army():\n\n    def __init__(self, position, members):\n        self.original_position=position\n        self.soldiers = deque([Soldier(position=i, bullet_speed=bs) for i, bs in enumerate(members)])\n        self.leader = self.soldiers[0]\n        self.target = None\n\n    def regroup(self):\n        if self.leader.alive:\n            self.soldiers.append(self.soldiers.popleft())  # Move head to the back\n        else:\n            self.soldiers.popleft()  # Head just dies\n        if len(self.soldiers) > 0:\n            self.leader = self.soldiers[0]\n        else:\n            self.leader = None\n\n    def __str__(self):\n        return 'Army {army_number} [Soldires: {soldiers}, Leader: {leader}, Target: {target}]'.format(\n            army_number=self.original_position,\n            soldiers=self.soldiers,\n            leader=self.leader,\n            target=repr(self.target)\n        )\n\n    def __repr__(self):\n        return 'Army {}'.format(self.original_position)\n\nclass Soldier():\n\n    def __init__(self, position, bullet_speed):\n        self.original_position = position\n        self.bullet_speed = bullet_speed\n        self.alive = True\n\n    def __repr__(self):\n        return '({bullet_speed}, {alive_status})'.format(\n            bullet_speed=self.bullet_speed,\n            alive_status='alive' if self.alive else 'dead'\n        )\n\nclass Bullet():\n\n    def __init__(self, target, speed, distance_to_target):\n        self.target = target\n        self.speed = speed\n        self.distance_to_target = distance_to_target\n\n    def __str__(self):\n        return 'Bullet [Target: {target}, Dist: {distance}, Speed: {speed}]'.format(\n            target=repr(self.target),\n            distance=self.distance_to_target,\n            speed=self.speed\n        )\n\n    def move(self):\n        self.distance_to_target -= self.speed\n\ndef queue_battle(dist,*armies):\n    game = Game(dist, armies)\n    game.game_loop()\n\n    return game.render_victory()"]