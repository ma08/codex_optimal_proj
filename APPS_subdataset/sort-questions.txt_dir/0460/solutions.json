["class Solution:\n     def arrayNesting(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         best = 0\n         n = len(nums)\n         p = []\n         for i in range(len(nums)):\n             j = i\n             current = 0\n             while nums[j] != -1:\n                 current += 1\n                 n -= 1\n                 k = j\n                 j = nums[j]\n                 nums[k] = -1\n             best = max(best,current)\n             if n <= best:\n                 return best\n         return best\n", "class Solution:\n     def arrayNesting(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         maxlen = 0\n         for i in range(0,len(nums)):\n             cur = nums[i]\n             if(cur >=0):\n                 curlen = 0\n                 nums[i] = -1\n                 while cur>=0:\n                     j = cur\n                     cur = nums[j]\n                     nums[j] = -1\n                     curlen = curlen+1\n                 if curlen>maxlen:\n                     maxlen=curlen\n         return maxlen\n", "class Solution:\n     def arrayNesting(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n \n         \n         dic = set()\n         ma = 0\n         for i in nums:\n             if i not in dic: # not considered\n                 set_ = set()\n                 while i  not in set_:\n                     set_.add(i)\n                     i = nums[i]\n                 ma = max(ma,len(set_))\n                 dic.update(set_)\n         return ma", "class Solution:\n     def arrayNesting(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         ans, step, n = 0, 0, len(nums)\n         signal = [False] * n\n         for i in range(n):\n             while not signal[i]:\n                 signal[i] = True\n                 step += 1\n                 i = nums[i]\n                 ans = max(ans, step)\n             step = 0\n         return ans", "class Solution:\n     def arrayNesting(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         longest = 1\n         for i in range(len(nums)):\n             count = 1\n             if i==nums[i]:\n                 continue\n             index = nums[i]\n             nums[i] *= -1\n             flag = True\n             while flag:\n                 if index<0:\n                     flag = False\n                     continue\n                 if nums[index]==0:\n                     count += 1\n                     tmp = index\n                     index = nums[index]\n                     nums[tmp] = -20001\n                 if nums[index]>0:\n                     count += 1\n                     tmp = index\n                     index = nums[index]\n                     nums[tmp] *= -1\n                 else:\n                     if count>longest:\n                         longest = count\n                     flag = False\n         return longest", "class Solution:\n     def arrayNesting(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         maxLength = 0\n         for i in range(len(nums)):\n             length = 0\n             j = i\n             while nums[j] >= 0:\n                 length += 1\n                 tmp = nums[j]\n                 nums[j] = -1\n                 j = tmp\n             maxLength = max(maxLength, length)\n         return maxLength", "class Solution:\n     def arrayNesting(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         curr = 0\n         maxLen = 0\n         tovisit = set([i for i in range(len(nums))])\n         while len(tovisit) > 0:\n             p = tovisit.pop()\n             curr = 1\n             while nums[p] != -1 and nums[p] in tovisit:\n                 tovisit.remove(nums[p])\n                 nums[p], p = -1, nums[p]\n                 curr += 1\n             maxLen = max(maxLen, curr)\n         return maxLen\n"]