["from functools import total_ordering\n\n@total_ordering\nclass PokerHand(object):\n    CARDS = \"AKQJT987654321\"\n    RANKS = {card: idx for idx, card in enumerate(CARDS)}\n    \n    def score(self, hand):    \n        values, suits = zip(*hand.split())\n        idxs, ordered = zip(*sorted((self.RANKS[card], card) for card in values))\n        is_straight = ''.join(ordered) in self.CARDS\n        is_flush = len(set(suits)) == 1\n        return (-2 * sum(values.count(card) for card in values)\n                - 13 * is_straight - 15 * is_flush, idxs)\n    \n    def __init__(self, hand):\n        self.hand = hand\n        self.score = min(self.score(hand), self.score(hand.replace('A', '1')))\n    \n    def __repr__(self):  return self.hand\n    def __eq__(self, other): return self.score == other.score\n    def __lt__(self, other): return self.score < other.score", "from collections import Counter\n\nHEX_CARDS     = \"23456789ABCDE\"\nCARD_TO_HEX   = str.maketrans(\"TJQKA\", \"ABCDE\")\n\nclass PokerHand(object):\n\n    def __init__(self, hand):\n        self.hand    = hand\n        hand         = hand.translate(CARD_TO_HEX)\n        valCount     = Counter( hand[n] for n in range(0, len(hand), 3) )\n        colorCount   = Counter( hand[n] for n in range(1, len(hand), 3) )\n        \n        minCardIdx   = int(min(valCount.keys()), 16) - 2\n        isStraight   = list(valCount.keys()) == set(HEX_CARDS[minCardIdx:minCardIdx+5])\n        \n        if list(valCount.keys()) == {'2','3','4','5','E'}:\n            isStraight = True\n            valCount['1'] = valCount.pop('E')\n        \n        mainVal = next( i for i,elt in enumerate([5 in list(colorCount.values()) and isStraight,              # Straight Flush\n                                                  4 in list(valCount.values()),                               # Square\n                                                  3 in list(valCount.values()) and 2 in list(valCount.values()),    # Full house\n                                                  5 in list(colorCount.values()),                             # Flush\n                                                  isStraight,                                           # Straight\n                                                  3 in list(valCount.values()),                               # Three of a kind\n                                                  2 in list(valCount.values()) and len(list(valCount.keys())) == 3, # 2 pairs\n                                                  2 in list(valCount.values()) and len(list(valCount.keys())) == 4, # 1 pair,\n                                                  True]) if elt )                                       # 1 card\n                                                  \n        self.handValue = int(''.join(sorted(list(valCount.keys()), key = lambda k: (valCount[k], k), reverse = True)), 16) + (8 - mainVal) * 16**5 \n                \n    def __eq__(self, other):  return self.handValue == other.handValue\n    def __lt__(self, other):  return self.handValue >  other.handValue\n    def __gt__(self, other):  return self.handValue <  other.handValue\n    \n    def __repr__(self):       return \"PokerHand({})\".format(self.hand)\n", "class PokerHand(object):\n    ''' The class represent a poker hand at Texas Holdem Poker.\n        A hand consists of 5 best cards from 7 cards(2-pocket, 5-table).\n        And this 5 cards is a combination, each combination have a value.\n        The hand with a larger value - wins.\n        \n        The class contains following functions:\n            * hand_to_vector - converts a hand in vector of count cards\n            * combination - returns the name of the combination of a hand\n            * value - returns the value of the combination (can be compared with another hand)\n            * compare_with - compares the instance hand with other hand\n    '''\n    \n    def __init__(self, hand):\n        self.hand = hand\n        self.hand_value = self.value(hand)\n    \n    \n    def __repr__(self):  return self.hand\n  \n    def __lt__(self, other):  return self.hand_value > other.hand_value\n    def __eq__(self, other): return self.hand_value == other.hand_value\n    \n    def compare_with(self, other):\n        ''' Compares 2 hands: first - instance hand, second - param\n            Args:\n                other (PokerHand): Another instance of PokerHand\n            Returns:\n                str: the result of the game if our and another hand were played\n        '''\n        if self.hand_value > other.hand_value:\n            return 'Win'\n        elif self.hand_value < other.hand_value:\n            return 'Loss'\n        elif self.hand_value == other.hand_value:\n            return 'Tie'\n  \n  \n    @staticmethod\n    def hand_to_vector(hand):\n        ''' Parse a hand in a vector, where a value of the vector is count of cards\n            card:     2  3  4      K  A\n            vector:  [0, 0, 0, ... 0, 0]    \n        Args:\n            hand (str): A combination of five cards, example '2S AH 4H 5S 6C'\n        Returns:\n            list: A vector of count of cards\n        '''\n        vec_hand = [0]*13\n        for card in hand.split():\n            try:\n                vec_hand[int(card[0])-2] += 1\n            except:\n                switcher = {'A': 12, 'K' : 11, 'Q' : 10, 'J' : 9, 'T' : 8}\n                vec_hand[switcher[card[0]]] += 1\n        return vec_hand\n      \n      \n    @staticmethod\n    def combination(hand):\n        ''' Firuers out the combination of the hand\n        Args:\n            hand (str): A combination of five cards, example '2S AH 4H 5S 6C'\n        Returns:\n            str: the name of the combination\n        '''\n        vec_hand = PokerHand.hand_to_vector(hand)\n        # suited --> True, when all cards of the same suit\n        suited = False\n        if 1 == len(set([x[1] for x in hand.split()])):\n            suited = True\n        \n        if 4 in vec_hand:\n            return 'Four of a kind'\n        else:\n            if 3 in vec_hand:\n                if 2 in vec_hand:\n                    return 'Full house'\n                else:\n                    return 'Three of a kind'\n            else:\n                if 2 in vec_hand:\n                    if 2 == vec_hand.count(2):\n                        return 'Two pair'\n                    else:\n                        return 'One pair'\n                if '11111' not in ''.join([str(x) for x in (vec_hand[-1:]+vec_hand)]):\n                    if suited:\n                        return 'Flush'\n                    else:\n                        return 'High card'\n                else:\n                    if not suited:\n                        return 'Straight'\n                    else:\n                        if vec_hand[8] == 1 and vec_hand[12] == 1:\n                            return 'Royal flush'\n                        else:\n                            return 'Straight flush'\n                        \n        \n    @staticmethod\n    def value(hand):\n        ''' Calculates the value of the hand\n        Args:\n            hand (str): A combination of five cards, example '2S AH 4H 5S 6C'\n        Returns:\n            int: the value of the hand\n        '''\n        hand_vec = PokerHand.hand_to_vector(hand)\n        ''' value_vec - a splited binary number, where each section represents\n            a specific combination\n            [ Straight flush, Care, Full house(set), Full house(pair), Flush, Straight,\n              Two pair(Hihg pair), Two pair(Low pair), One pair ]\n        '''\n        value_vec = ['0','0000','0000','0000','0','0','0000','0000','0000','0000']\n        combination = PokerHand.combination(hand)\n        if combination == 'One pair':\n            value_vec[9] = '{:04b}'.format(hand_vec.index(2))\n        elif combination == 'Two pair':\n            value_vec[8] = '{:04b}'.format(hand_vec.index(2))\n            value_vec[7] = '{:04b}'.format(hand_vec.index(2, hand_vec.index(2)+1))\n        elif combination == 'Three of a kind':\n            value_vec[6] = '{:04b}'.format(hand_vec.index(3))\n        elif combination == 'Straight':\n            value_vec[5] = '1'\n            if hand_vec[12] == 1 and hand_vec[3] == 1:\n                hand_vec[12] = 0\n        elif combination == 'Flush':\n            value_vec[4] = '1'\n        elif combination == 'Full house':\n            value_vec[3] = '{:04b}'.format(hand_vec.index(2))\n            value_vec[2] = '{:04b}'.format(hand_vec.index(3))\n        elif combination == 'Four of a kind':\n            value_vec[1] = '{:04b}'.format(hand_vec.index(4))\n        elif combination == 'Straight flush':\n            value_vec[0] = '1'\n            if hand_vec[12] == 1 and hand_vec[3] == 1:\n                hand_vec[12] = 0\n        elif combination == 'Royal flush':\n            value_vec[0] = '1'\n            value_vec[1] = '1111'\n\n        ''' The result is binary number: value_vec extended \n            with hand_vec(contains only 0/1, to represent remaining single cards),\n            and this resulting extended binary number convert to decimal.\n        '''\n        return int(''.join(value_vec) + ''.join(reversed(list([str(x) if x == 1 else str(0) for x in hand_vec]))), 2)\n\n", "class PokerHand(object):\n    CARD = \"23456789TJQKA\"\n    def __repr__(self): return str(self.hand)\n    def __init__(self, hand):\n        self.hand = hand\n        values = ''.join(sorted(hand[::3], key=self.CARD.index))\n        suits = set(hand[1::3])\n        is_straight = values in self.CARD or values == \"2345A\"\n        is_flush = len(suits) == 1\n        self.score = (2 * sum(values.count(card) for card in values)\n                      + 13 * is_straight + 15 * is_flush,\n                      [self.CARD.index(card) for card in values[::-1]])\n        if(values == \"2345A\"):      \n            self.score = (13 * is_straight + 15 * is_flush + 10, [3, 2, 1, 0, 12])\n    def __lt__(self, other): return (self.score > other.score)", "class PokerHand(object):\n    CARD = \"23456789TJQKA\"\n    RESULT = [\"Loss\", \"Tie\", \"Win\"]\n\n    def __repr__(self):  return self.hand\n    \n    def __lt__(self, other):\n        res = self.compare_with(other)        \n        return res == self.RESULT[2]   \n\n    def __init__(self, hand):\n        self.hand = hand\n        values = ''.join(sorted(hand[::3], key=self.CARD.index))        \n        suits = set(hand[1::3])\n        is_straight = values in self.CARD\n        is_straight_bad = values in ['2JQKA','23QKA','234KA','2345A']        \n        is_flush = len(suits) == 1\n        self.score = (2 * sum(values.count(card) for card in values)\n                      + 13 * is_straight + (12.5 * is_straight_bad) + 15 * is_flush,\n                      [self.CARD.index(card) for card in values[::-1]])\n        \n    def compare_with(self, other):        \n        return self.RESULT[(self.score > other.score) - (self.score < other.score) + 1]", "from collections import defaultdict\nfrom typing import List\n\n\nclass PokerHand(object):\n    '''Representation of a poker hand and its basic characteristics.\n\n    The PokerHands Weight are:\n        Straight Flush  : 1\n        Four of a Kind  : 2\n        Full House      : 3\n        Flush           : 4\n        Straight        : 5\n        Three of a Kind : 6\n        Two Pairs       : 7\n        Pair            : 8\n        High Card       : 9\n    \n    In the sample test, the sorted poker hands are displayed with the highest ranking hand in the top.\n    The sort method, sorts in ascending order, this means the highest weight would have to be considered the lowest number.\n\n    If there are ties between the hands weight, the tiebreaker shall be resolved as follow:\n        Straight Flush or Straight:\n            The hand with the highest card in the Straight.\n            There's no need to account for the Royal Straight Flush because of this.\n        Four of a Kind:\n            The highest Four of a Kind, then the Kicker.\n        Full House:\n            The highest Three of a Kind, then the highest Pair.\n        Flush:\n            The hand with the highest card in the Flush wins.\n        Three of a Kind:\n            The highest Three of a Kind, then the highest Kicker.\n        Two Pairs or Pair:\n            The highest Pair, then the highest Kicker.\n        High Card:\n            The highest card in the hand.\n\n    If still there is a tie, then it is a tie because all the Suits have the same weight.\n\n    Attributes:\n        hand (str): String representation of the poker hand.\n        cards (List[PokerCard]): The list of poker cards in this hand.\n    '''\n    def __repr__(self):\n        return self.hand\n\n    def __init__(self, hand: str):\n        self.hand = hand\n        self.cards = [PokerCard(card) for card in hand.split(' ')]\n        self.cards.sort()\n        self.hand_weight = self._calculate_hand_weight()\n        \n    def __eq__(self, other):\n        if self.hand_weight[0] != other.hand_weight[0]:\n            return False\n        \n        for i in range(1, len(self.hand_weight)):\n            if self.hand_weight[i] != other.hand_weight[i]:\n                return False\n        return True\n    \n    def __lt__(self, other):\n        if self.hand_weight[0] < other.hand_weight[0]:\n            return True\n        \n        # if both hands have teh same weight, the tie must be broken by highest ranking cards.\n        if self.hand_weight[0] == other.hand_weight[0]:\n            for i in range(1, len(self.hand_weight)):\n                # if the rank is also equal, you want to check the next cards, if any are left\n                if self.hand_weight[i] == other.hand_weight[i]:\n                    continue\n                if self.hand_weight[i] < other.hand_weight[i]:\n                    return True\n                return False\n        # if it is a tie\n        return False\n\n    def _calculate_hand_weight(self):\n        '''Analize hand strenght.\n\n        Returns:\n            A Tuple containing the hand weight as its firs argument,\n            then the cards ranks to break a tie in case the hand weight is the same.\n        '''\n        hand = defaultdict(int)\n        for card in self.cards:\n            hand[card.rank] += 1\n\n        length = len(hand)\n        # values holds the count for how many times each rank appears in the hand\n        values = list(hand.values())\n\n        # five different cards\n        if length == 5:\n            suited = self.is_suited()\n            straight_high_card = self.is_a_straight()\n\n            # if it is a straight flush:\n            if suited and straight_high_card:\n                return (1, straight_high_card)\n            # if it is a flush:\n            if suited:\n                return (4, *self.cards)\n            # if it is a straight:\n            if straight_high_card:\n                return (5, straight_high_card)\n            # high card:\n            return (9, *self.cards)\n\n        if length == 2:\n            # four of a kind:\n            if 4 in values:\n                i_four = values.index(4)\n                i_kicker = values.index(1)\n                return (2, self.cards[i_four], self.cards[i_kicker])\n\n            # full house:\n            i_triple = values.index(3)\n            i_pair = values.index(2)\n            return (3, self.cards[i_triple], self.cards[i_pair])\n\n        if length == 3:\n            # triple:\n            if 3 in values:\n                i_triple = values.index(3)\n                return (6, self.cards[i_triple], *self.cards[:i_triple], *self.cards[i_triple+1:])\n\n            # two pairs:\n            i_pair = values.index(2)\n            j_pair = values.index(2, i_pair+1)\n            i_kicker = values.index(1)\n            return (7, self.cards[i_pair], self.cards[j_pair], self.cards[i_kicker])\n\n        if length == 4:\n            # this is a pair:\n            i_pair = values.index(2)\n            return (8, self.cards[i_pair], *self.cards[:i_pair], *self.cards[i_pair+1:])\n\n    def is_suited(self):\n        '''Check if hand is Suited.'''\n        for i in range(len(self.cards)-1):\n            if self.cards[i].suit != self.cards[i+1].suit:\n                return False\n\n        return True\n    \n    def is_a_straight(self):\n        '''Check if hand is a Straight\n        \n        Returns:\n            The highest card in the Straight.\n        '''\n        starter = 0\n        # if True, skips the first element to check for the Low Straight\n        if self.cards[0].rank == 'A' and self.cards[1].rank == '5':\n            starter = 1\n\n        for i in range(starter, len(self.cards)-1):\n            if self.cards[i+1] - self.cards[i] != 1:\n                return False\n\n        # in case it was a Low Straight, you want to return the 5 instead of the Ace\n        if starter == 1:\n            return self.cards[1]\n\n        return self.cards[0]\n\n\nclass PokerCard(object):\n    '''Representation of a poker card and its basic characteristics.\n\n    The PokerCards Weight are:\n        Ace:    1       |   7:      8\n        King:   2       |   6:      9\n        Queen:  3       |   5:      10\n        Jack:   4       |   4:      11\n        Ten:    5       |   3:      12\n        9:      6       |   2:      13\n        8:      7       |   Ace*:   When comparing it in a low Straight\n\n    Attributes:\n        card (str): String representation of the poker card.\n        rank (str): The rank of the card.\n        suit (str): The suit of the card.\n    '''\n    def __repr__(self):\n        return self.card_weight\n    \n    def __init__(self, card: str):\n        self.card = card\n        self.rank = card[0]\n        self.suit = card[1]\n        self.card_weight = self.get_card_weight()\n    \n    def __eq__(self, other):\n        return True if self.card_weight == other.card_weight else False\n    \n    def __lt__(self, other):\n        return True if self.card_weight < other.card_weight else False\n    \n    def __sub__(self, other):\n        return self.card_weight - other.card_weight\n    \n    def get_card_weight(self):\n        '''Return the card weight based on its rank.'''\n        if self.rank == 'T':\n            return 5\n        if self.rank == 'J':\n            return 4\n        if self.rank == 'Q':\n            return 3\n        if self.rank == 'K':\n            return 2\n        if self.rank == 'A':\n            return 1\n        return (63 - ord(self.rank))\n", "from itertools import groupby\nfrom enum import IntEnum, auto\n\nclass PokerHand:\n    def __init__(self, hand):\n        self.hand = hand\n        cards = hand.split()\n        values = tuple(sorted(cardval.get(c[0]) or int(c[0]) for c in cards))\n        groups = tuple(sorted((len(tuple(g)) for _, g in groupby(values)), reverse=True))\n        hand_value = hv_table.get(groups)\n        if hand_value is None:\n            flush = len(set(c[1] for c in cards)) == 1\n            straight = set(a-b for (a, b) in zip(values[1:], values[:-1])) == {1} or values == (2,3,4,5,14)\n            if straight and flush:\n                hand_value = HV.royal_flush if values[0] == 10 else HV.straight_flush\n            elif flush:\n                hand_value = HV.flush\n            elif straight:\n                hand_value = HV.straight\n            else:\n                hand_value = HV.highcard\n        self.hand_value = hand_value\n    \n    def __lt__(lhs, rhs):\n        return lhs.hand_value > rhs.hand_value\n\n    def __eq__(lhs, rhs):\n        return lhs.hand_value == rhs.hand_value\n\n    def __repr__(self):\n        return self.hand\n    \n\n\ncardval = dict(T=10, J=11, Q=12, K=13, A=14)\n\nclass HV(IntEnum):\n    highcard = auto()\n    pair = auto()\n    two_pairs = auto()\n    three_ok_a_kind = auto()\n    straight = auto()\n    flush = auto()\n    full_house = auto()\n    four_of_a_kind = auto()\n    straight_flush = auto()\n    royal_flush = auto()\n\nhv_table = {\n    (2,1,1,1): HV.pair,\n    (2,2,1): HV.two_pairs,\n    (3,1,1): HV.three_ok_a_kind,\n    (3,2): HV.full_house,\n    (4,1): HV.four_of_a_kind,\n}\n", "from typing import Tuple, List\nfrom functools import total_ordering\n\n\n@total_ordering\nclass PokerHand(object):\n    \"\"\"Create an object representing a Poker Hand based on an input of a\n    string which represents the best 5 card combination from the player's hand\n    and board cards.\n\n    Attributes:\n        hand: string representating the hand consisting of five cards\n        cards: list of two tuple containing the value of the card and suit\n            in sorted order\n        hand value: total hand value of all the cards\n        hand type: hand type as a number from the list given in docstring of\n            hand_type function\n        high card: value of the high card in a given hand\n\n    Methods:\n        compare_with(self, opponent): takes in player's hand (self) and\n            opponent's hand (opponent) and compares both hands according to\n            rules of Texas Hold'em.\n            Returns one of 3 strings (Win, Loss, Tie) based on whether\n            player's hand is better than opponent's hand.\n\n    Helper Methods:\n        _hand_with_values: Internal representation of hand as a list of two\n            tuple containing the value of the card and suit in sorted order\n        _is_flush: Determine whether a hand is flush or not\n        _is_straight: Determine whether a hand is straight or not\n        _is_same_kind: Determine whether a hand is of any kind (Look at doc\n            for complete list)\n        _hand_type: represent hand type as a number in order of precedence\n        _high_card: Value of the highest card to break the tie in straight or\n            straight flush\n        _total_hand_value: Total value of the hand\n        _compare_cards: Compare each cards from self and other\n        _tie_breaker: To determine the outcome if self and other are of same\n            type\n    \"\"\"\n    def __init__(self, hand: str):\n        self._hand = hand\n        self._cards = self._hand_with_values()\n        self._hand_value = self._total_hand_value()\n        self._hand_type = self._hand_type()\n        self._high_card = self._high_card()\n        self._first_pair = 0\n        self._second_pair = 0\n\n    def compare_with(self, other: 'PokerHand') -> str:\n        \"\"\"\n        Determines the outcome of the comparing self hand with other hand.\n        Returns the output either 'Win', 'Loss', 'Tie' accordingly.\n        :type other: PokerHand\n        \"\"\"\n        # Basic comparison\n        if self._hand_type > other._hand_type:\n            return 'Win'\n        elif self._hand_type < other._hand_type:\n            return 'Loss'\n        else:\n            return self._tie_breaker(other, self._hand_type)\n\n    def _tie_breaker(self, other: 'PokerHand', hand_type: int) -> str:\n        \"\"\"\n        This method is used to break the tie if self hand and other hand\n        has same type.\n        For royal flush, it can only be a Tie.\n        For straigh flush or straight compare the high card.\n        For four of a kind or full house compare the first pair and if they\n            are same then compare the hand value.\n        For three of a kind or one pair, compare the first pair and if they\n            are same then compare all the cards in reverse order as the cards\n            are sorted.\n        For two pairs, compare the first pair and then the second pair and if\n            both are the same then compare the hand value.\n        For flush and high card, compare all the cards in reverse order.\n        :type other: PokerHand\n        \"\"\"\n        if hand_type == 23:  # Royal flush\n            return 'Tie'\n\n        elif hand_type in [22, 18]:  # Straight flush or Straight\n            return 'Win' if self._high_card > other._high_card else 'Loss' \\\n                if self._high_card < other._high_card else 'Tie'\n\n        elif hand_type in [21, 20]:  # Four of a kind or Full house\n            if self._first_pair == other._first_pair:\n                return 'Win' if self._hand_value > other._hand_value else \\\n                    'Loss' if self._hand_value < other._hand_value else 'Tie'\n            return 'Win' if self._first_pair > other._first_pair else 'Loss'\n\n        elif hand_type in [17, 15]:  # Three of a kind or One pair\n            if self._first_pair == other._first_pair:\n                return self._compare_cards(other)\n            return 'Win' if self._first_pair > other._first_pair else 'Loss'\n\n        elif hand_type == 16:  # Two pairs\n            if self._first_pair == other._first_pair:\n                if self._second_pair == other._second_pair:\n                    return 'Win' if self._hand_value > other._hand_value else \\\n                     'Loss' if self._hand_value < other._hand_value else 'Tie'\n                else:\n                    return 'Win' if self._second_pair > other._second_pair \\\n                        else 'Loss'\n            return 'Win' if self._first_pair > other._first_pair else 'Loss'\n\n        else:  # Flush and high card\n            return self._compare_cards(other)\n\n    def _compare_cards(self, other: 'PokerHand') -> str:\n        \"\"\"Comparing all the cards from its highest value to the lowest\n        and accordingly returns either 'Win', 'Loss', 'Tie'.\n        :type other: PokerHand\n        \"\"\"\n        for i in range(4, -1, -1):\n            if self._cards[i][0] != other._cards[i][0]:\n                return 'Win' if self._cards[i][0] > other._cards[i][0] else \\\n                    'Loss'\n        return 'Tie'\n\n    def _hand_type(self) -> int:\n        \"\"\"\n        Determine the type of hand.\n        Returns the value from the following table:\n        23: Royal flush\n        22: Straight flush\n        21: Four of a kind\n        20: Full house\n        19: Flush\n        18: Straight\n        17: Three of a kind\n        16: Two pairs\n        15: One pair\n        14: Decide with highest card\n        \"\"\"\n        if self._is_flush() and (self._is_five_high_straight() or\n                                 self._is_straight()):\n            if self._hand_value == 60:\n                return 23\n            else:\n                return 22\n        elif self._is_flush():\n            return 19\n        elif self._is_five_high_straight() or self._is_straight():\n            return 18\n        elif self._is_same_kind():\n            kind_type = self._is_same_kind()\n            return 14 + kind_type\n        else:\n            return 14\n\n    def _high_card(self) -> int:\n        \"\"\"Return the value of highest card in a hand\"\"\"\n        return self._cards[-1][0]\n\n    def _total_hand_value(self) -> int:\n        \"\"\"Return the total hand value\"\"\"\n        return sum(card[0] for card in self._cards)\n\n    def _is_flush(self) -> bool:\n        \"\"\"\n        Determine whether hand is a flush or not.\n        Returns True or False\n        \"\"\"\n        suit = self._cards[0][-1]\n        return all(map(lambda card: suit in card, self._cards))\n\n    def _is_five_high_straight(self) -> bool:\n        \"\"\"\n        Determine whether a hand is a five high straight (low ace)\n        If it is change the location of ace from the end of the list to the\n        start otherwise don't do anything. If asked again then don't pop the\n        last element again. Check whether the last element is ace or not.\n        Returns True or False\n        \"\"\"\n        if self._hand_value == 28:\n            if self._cards[-1][0] == 14:\n                ace_card = self._cards.pop()\n                self._cards.insert(0, ace_card)\n            return True\n        return False\n\n    def _is_straight(self) -> bool:\n        \"\"\"\n        Determine whether hand is straight or not.\n        Returns True or False.\n        \"\"\"\n        for i in range(4):\n            if self._cards[i+1][0] - self._cards[i][0] != 1:\n                return False\n        return True\n\n    def _is_same_kind(self) -> int:\n        \"\"\"\n        Determine the kind of hand if it is any and assign the value of the\n        first and second pair to the respective attributes.\n        Returns kind value else False.\n        Kind Values:\n        7: Four of a kind\n        6: Full house\n        3: Three of a kind\n        2: Two pairs\n        1: One pair\n        0: False\n        \"\"\"\n        kind = val1 = val2 = 0\n        for i in range(4):\n            if self._cards[i][0] == self._cards[i+1][0]:\n                if not val1:\n                    val1 = self._cards[i][0]\n                    kind += 1\n                elif val1 == self._cards[i][0]:\n                    kind += 2\n                elif not val2:\n                    val2 = self._cards[i][0]\n                    kind += 1\n                elif val2 == self._cards[i][0]:\n                    kind += 2\n        kind = kind + 2 if kind in [4, 5] else kind\n        self._first_pair = max(val1, val2)\n        self._second_pair = min(val1, val2)\n        return kind\n\n    def _hand_with_values(self) -> List[Tuple[int, str]]:\n        \"\"\"\n        Subsitute word values with int values and convert the hand into\n        2-tuple lists having the values (value, suit).\n        Returns the sorted hand with the above changes.\n        \"\"\"\n        trans = {\n            'T': '10',\n            'J': '11',\n            'Q': '12',\n            'K': '13',\n            'A': '14'\n        }\n        new_hand = self._hand.translate(str.maketrans(trans)).split()\n        final_hand = [(int(card[:-1]), card[-1]) for card in new_hand]\n        return sorted(final_hand)\n\n    def __repr__(self):\n        return self._hand\n\n    def __str__(self):\n        return self._hand\n\n    def __lt__(self, other: 'PokerHand'):\n        outcome = self.compare_with(other)\n        return True if outcome == 'Win' else False\n\n    def __eq__(self, other: 'PokerHand'):\n        outcome = self.compare_with(other)\n        return True if outcome == 'Tie' else False", "from collections import Counter\nclass PokerHand(object):\n    CARD = \"123456789TJQKA\"\n\n    def __repr__(self):  return self.hand\n\n    def __init__(self, hand):\n        self.hand = hand\n        CARD = self.CARD\n        values = ''.join(sorted(hand[::3], key=CARD.index))\n        if all([c in values for c in 'A2345']):\n            CARD = 'A' + self.CARD[1:-1]\n            values = ''.join(sorted(hand[::3], key=CARD.index))\n        is_flush = len(set(hand[1::3])) == 1\n        counts = Counter(values)\n        is_straight = values in CARD\n        self.score = (2 * sum(counts[card] for card in values)\n                      + 13 * is_straight + 15 * is_flush,\n                      sorted((cnt, CARD.index(card)) for card, cnt in counts.most_common())[::-1])\n    def __lt__(self, other):\n        return self.score > other.score\n", "class PokerHand(object):\n    VALUES = \"A23456789TJQKA\"\n    \n\n    def __repr__(self):  return self.hand\n\n    def __init__(self, hand):\n        self.hand = hand\n        values = ''.join(sorted(hand[::3], key=self.VALUES[1:].index))\n        suits = set(hand[1::3])\n        hi_straight = values in self.VALUES\n        lo_straight = values[-1] + values[:-1] in self.VALUES\n        is_flush = len(suits) == 1\n        self.score = (2 * sum(values.count(card) for card in values)\n                      + 13 * (hi_straight or lo_straight) + 15 * is_flush,\n                     [self.VALUES[:-1].index(card) if lo_straight else self.VALUES[1:].index(card) for card in values[::-1]])\n        \n    def __lt__(self, other):\n        return other.score < self.score"]