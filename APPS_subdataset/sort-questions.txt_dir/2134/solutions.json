["from collections import defaultdict, deque\n\nn = int(input())\nadj = [[] for _ in range(n)]\nv = [0] * n\nl = list(map(int, input().split()))\nfor i, f in enumerate(l):\n    adj[f - 1].append(i + 1)\n\ns = list(map(int, input().split()))\n\nQ = deque([(0, s[0], s[0])])\nans = 0\nflag = False\npossible = True\nwhile Q and possible:\n    # print(Q)\n    flag = not flag\n    for _ in range(len(Q)):\n        cur, v, curs = Q.popleft()\n        if v < 0:\n            possible = False\n            ans = -1\n            break\n        ans += v\n        if flag:\n            for i in adj[cur]:\n                if len(adj[i]) <= 1:\n                    Q.append((i, 0, curs))\n                else:\n                    temp = min([s[k] for k in adj[i]])\n                    Q.append((i, temp - curs, temp))\n        else:\n            for i in adj[cur]:\n                Q.append((i, s[i] - curs, s[i]))\nprint(ans)\n", "def main():\n    n=int(input())\n    p=[0,None]+list(map(int,input().split()))\n    s=[None]+list(map(int,input().split()))\n    a=[None,s[1]]+[None]*(n-1)\n    children=[0]\n    for i in range(n):\n        children.append([])\n    for i in range(2,n+1):\n        children[p[i]].append(i)\n    broken=[False]\n    def dostuff(parent,children,vals):\n        small=vals[parent]\n        for child in children[parent]:\n            if len(children[child])>0:\n                mini=min(s[guy] for guy in children[child])\n            else:\n                mini=small\n            if mini<small:\n                broken[0]=True\n            a[child]=mini-small\n            for child1 in children[child]:\n                a[child1]=s[child1]-mini\n                dostuff(child1,children,vals)\n    dostuff(1,children,s)\n    if broken[0]:\n        print(-1)\n    else:\n        print(sum(a[1:]))\n\nimport sys\nimport threading\nsys.setrecursionlimit(2097152)\nthreading.stack_size(134217728)\nmain_thread=threading.Thread(target=main)\nmain_thread.start()\nmain_thread.join()", "n = int(input())\nroot = list(map(int, input().split()))\nsums = list(map(int, input().split()))\n\ndirect = []\nfor i in range(n):\n    direct.append([])\nfor i in range(n-1):\n    direct[root[i]-1].append(i+2)\n\n#print(direct)\n\nstack = [1]\ns = sums[0]\nwork = True\nwhile(len(stack) > 0 and work):\n    v = stack.pop()\n    #v is odd height\n    for u in direct[v-1]:\n        if len(direct[u-1]) == 0:\n            sums[u-1] = sums[v-1]\n        else:\n            minval = -1\n            for w in direct[u-1]:\n                if minval == -1 or minval > sums[w-1]:\n                    minval = sums[w-1]\n                s+=sums[w-1]\n                stack.append(w)\n            s-=minval*len(direct[u-1])\n            sums[u-1] = minval\n        if sums[u-1] < sums[v-1]:\n            work = False\n            break;\n        s+=sums[u-1] - sums[v-1]\n\nif work:\n    print(s)\nelse:\n    print(-1)\n\n\n", "import sys\n\nn = int(input())\nsys.setrecursionlimit(100*1000+100)\n\nch = [[] for _ in range(n)]\nfor i, x in enumerate(map(int, input().split(' ')), start=1):\n    ch[x-1].append(i)\n\ns = list(map(int, input().split(' ')))\n\nans = 0\ndef dfs(v, buf):\n    nonlocal ans\n    while True:\n        m = min((s[c] for c in ch[v]), default=buf) if s[v] == -1 else s[v]\n        if m < buf: ans = -1\n        if ans == -1: return\n        ans += m - buf\n        if len(ch[v]) == 1:\n            v = ch[v][0]\n            buf = m\n            continue\n        else:\n            for c in ch[v]: \n                dfs(c, m)\n            break\n\ndfs(0, 0)\nprint (ans)", "n = int(input())\np = [1] + list(map(int, input().split()))\ns = list(map(int, input().split()))\np = [i-1 for i in p]\nfor i in range(1,n):\n    if s[i] != -1 and (s[p[i]] == -1 or s[p[i]] > s[i]):\n        s[p[i]] = s[i]\na = [s[0]]+[0]*(n-1)\nfor i in range(1,n):\n    if s[i] == -1:\n        a[i] = 0\n    else:\n        a[i] = s[i]-s[p[i]]\n        if a[i] < 0:\n            print(-1)\n            quit()\nprint(sum(a))", "class vertex():\n    def __init__(self,v,sv,av=0):\n        self.v=v\n        self.sv=sv\n        self.av=av\n        self.child=[]\n    def sve(self):\n        if self.child==[]: \n            return(t.vert[pa[self.v-2]].sv)\n        l=[t.vert[i].sv for i in self.child]\n        return(min(l))\n        \n    \nclass tree():\n    def __init__(self):\n        self.vert={}\nsum=0\nt=tree()\nn=int(input())\npa=list(map(int, input().split()))\ns=list(map(int, input().split()))\nfor i in range(1,n+1):\n    t.vert[i]=vertex(i,s[i-1])\nfor i in range(n-1):\n    par=pa[i]\n    t.vert[par].child.append(i+2)\nfor i in range(1,n+1):\n    if t.vert[i].sv==-1:\n        t.vert[i].sv=t.vert[i].sve()\nfor i in range(2,n+1):\n    k=t.vert[i].sv-t.vert[pa[t.vert[i].v-2]].sv\n    if k<0:\n        sum=-1\n        break\n    else:t.vert[i].av=k\nif sum==-1:print(-1)\nelse:\n    r=s[0]\n    for i in range(2,n+1):\n        r+=t.vert[i].av\n    print(r)", "n = int(input())\nparents = [None]+[int(x)-1 for x in input().split()]\ns = list(map(int, input().split()))\nchildren = [[] for _ in range(n)]\na = [None for _ in range(n)]\n\nfor v, parent in enumerate(parents):\n    if parent is not None:\n        children[parent] += [v]\n\nbroken = False\nstack = []\nstack.append((0, 1))\na[0] = s[0]\nwhile len(stack) > 0:\n    v, depth = stack.pop()\n    # assert (s[v]==-1) == (depth%2==0)\n    if depth % 2 == 0:\n        if len(children[v]) > 0:\n            s[v] = s[min(children[v], key=lambda child: s[child])]\n        else:\n            s[v] = s[parents[v]]\n        if s[v] < s[parents[v]]:\n            broken = True\n            break\n    if depth>1:\n        a[v] = s[v] - s[parents[v]]\n    for child in children[v]:\n        stack.append((child, depth+1))\n\nif not broken:\n    print(sum(a))\nelse:\n    print(-1)\n\n", "def solve():\n    num_nodes = int(input())\n    parents = [0] + [int(x)-1 for x in input().split()]\n    S = [int(x) for x in input().split()]\n\n    children = [[] for _ in parents]\n    for child, parent in enumerate(parents):\n        children[parent].append(child)\n\n    for node in range(num_nodes):\n        if S[node] == -1:\n            S[node] = min((S[child] for child in children[node]), default=S[parents[node]])\n\n    A = [None for _ in range(num_nodes)]\n    A[0] = S[0]\n    for node in range(1, num_nodes):\n        A[node] = S[node] - S[parents[node]]\n        if A[node] < 0:\n            print('-1')\n            return False\n\n    print(sum(A))\n\nsolve()\n    \n", "n = int(input())\n\nclass Tree:\n    height = 1\n    def __init__(self, parent=None):\n        self.nodes = []\n        self.s = -1\n        self.a = -1\n        self.parent = parent\n        if parent:\n            self.height = parent.height+1\n            parent.nodes.append(self)\n\ntrs = [Tree()]\n\nfor i in map(int, input().split()):\n    trs.append(Tree(trs[i-1]))\n\nfor i, s in enumerate(map(int, input().split())):\n    trs[i].s = s\n\ntrs.sort(key=lambda x: x.height)\ntrs[0].a = trs[0].s\nres = trs[0].a\n\ntry:\n    for t in trs[1:]:\n        if t.s == -1:\n            t.a = min([x.s - t.parent.s for x in t.nodes], default=0)\n            t.s = t.a + t.parent.s\n        else:\n            t.a = t.s - t.parent.s\n        if t.a < 0:\n            raise\n        res += t.a\n    print(res)\nexcept:\n    print(-1)\n", "from collections import deque,defaultdict\nn=int(input())\ng=defaultdict(list)\na=list(map(int,input().split()))\nfor i in range(n-1):\n    g[a[i]].append(i+2)\n    g[i+2].append(a[i])\ns=list(map(int,input().split()))\nvisited=[False]*(n+1)\nq=deque();q.append(1);visited[1]=True\nval=[0]*(n+1);val[1]=s[0]\n#print(val)\nwhile len(q)>0:\n    v=q.popleft()\n    b=[]\n    for i in g[v]:\n        if not visited[i]:\n            if s[v-1]==-1:\n                b.append(s[i-1])\n            else:\n                if v>1:\n                    val[v]=s[v-1]-s[g[v][0]-1]\n            q.append(i)\n            visited[i]=True\n    if b!=[] and not all([x>=s[g[v][0]-1] for x in b]):\n        print(-1)\n        return\n    elif b!=[]:\n        val[v]=min(b)-s[g[v][0]-1]\n        s[v-1]=val[v]+s[g[v][0]-1]\n    else:\n        if s[v-1]!=-1 and v>1:\n            val[v]=s[v-1]-s[g[v][0]-1]\n    \n\n\nprint(sum(val))\n", "from collections import deque\nn = int(input())\ngraph = {i: set() for i in range(1, n + 1)}\nP = list(map(int, input().split()))\nS = [0] + list(map(int, input().split()))\nfor i in range(n - 1):\n    graph[P[i]].add(i + 2)\nQ = deque([1])\nused = [0] * (n + 1)\nans = S[1]\nkek = {1: S[1]}\nused[1] = 1\nwhile Q:\n    v = Q.popleft()\n    for u in graph[v]:\n        if used[u] == 0:\n            used[u] = 1\n            Q.append(u)\n            if S[u] != -1:\n                if kek[v] > S[u]:\n                    print(-1)\n                    return\n                ans += (S[u] - kek[v])\n                kek[u] = S[u]\n            else:\n                sos = set()\n                for u2 in graph[u]:\n                    sos.add(S[u2])\n                if sos:\n                    x = min(sos)\n                    if kek[v] <= x:\n                        ans += (x - kek[v])\n                        kek[u] = x\n                    else:\n                        print(-1)\n                        return\nprint(ans)", "n = int(input())\np = list(map(int, input().split()))\ns = list(map(int, input().split()))\na = [0]*n\na[0] = s[0]\ng = [[] for _ in range(n+1)]\nfor i in range(n-1):\n    g[p[i]].append(i+2)\nfor i in range(1, n):\n    if s[i] == -1:\n        if len(g[i+1]) == 0:\n            s[i] = s[p[i-1]-1]\n        else:\n            m = s[g[i+1][0]-1]\n            for j in g[i+1]:\n                m = min(m, s[j-1])\n            s[i] = m\n    if s[i] < s[p[i-1]-1]:\n        print(-1)\n        return\n    else:\n        a[i] = s[i]-s[p[i-1]-1]\nprint(sum(a))\n", "import sys\ninput = sys.stdin.readline\nfrom collections import deque\n\ndef bfs():\n    q = deque([0])\n    a[0] = s[0]\n    visited = [False]*n\n    visited[0] = True\n    \n    while q:\n        v = q.popleft()\n        \n        for nv in G[v]:\n            if visited[nv]:\n                continue\n            \n            visited[nv] = True\n            \n            if s[nv]==-1:\n                l = []\n                \n                for nnv in G[nv]:\n                    if v==nnv:\n                        continue\n                    \n                    l.append(s[nnv])\n\n                if len(l)==0:\n                    s[nv] = s[v]\n                else:\n                    s[nv] = min(l)\n                \n                a[nv] = s[nv]-s[v]\n                q.append(nv)\n            else:\n                a[nv] = s[nv]-s[v]\n                q.append(nv)\n\nn = int(input())\np = list(map(int, input().split()))\ns = list(map(int, input().split()))\nG = [[] for _ in range(n)]\n\nfor i in range(n-1):\n    G[i+1].append(p[i]-1)\n    G[p[i]-1].append(i+1)\n\na = [0]*n\nbfs()\n\nif min(a)>=0:\n    print(sum(a))\nelse:\n    print(-1)", "from bisect import bisect_left as bl, bisect_right as br, insort\nimport sys\nimport heapq\n#from math import *\nfrom collections import defaultdict as dd, deque\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return map(int, data().split())\n#sys.setrecursionlimit(100000)\nmod=int(1e9+7)\n\n\n\nn=int(data())\nt=[{} for i  in range(n)]\nP=list(mdata())\nfor i in range(n-1):\n    t[P[i]-1][i+1]=0\nA=list(mdata())\nflag=True\nv=[0]*n\nv[0]=max(A[0],0)\nans=v[0]\nfor i in range(0,n):\n    if A[i]==-1 :\n        l=[]\n        for j in t[i]:\n            if A[j]!=-1:\n                l.append(A[j])\n        m=0\n        if len(l)>0:\n            m=min(l)\n            if m<v[i]:\n                print(-1)\n                return\n            ans+=m-v[i]\n            v[i]=m\n    else:\n        v[i]=A[i]\n    for j in t[i]:\n        if A[j]==-1:\n            v[j]=v[i]\n        elif A[j]<v[i]:\n            print(-1)\n            return\n        else:\n            v[j]=A[j]\n        ans+=v[j]-v[i]\nprint(ans)", "from collections import *\nn=int(input())\nfa=[0,0]+[int(i) for i in input().split()]\ns=[0]+[int(i) for i in input().split()]\ng=[[] for i in range(n+1)]\nfor x in range(2,len(fa)):\n    g[fa[x]].append(x)\n\nsub=[0]*(n+1)\nq=deque([1])\nrcr=[]\nwhile(q):\n    x=q.popleft()\n    rcr.append(x)\n    for y in g[x]:\n        q.append(y)\nrcr.reverse()\n\ninf=int(1e10)\ns1=[inf if i==-1 else i for i in s]\nfor x in rcr:\n    sub[x]=s1[x]\n    if g[x]:\n        sub[x]=min(sub[x],  min([sub[y] for y in g[x]]) )\n\ndp=[0]*(n+1)\na=[0]*(n+1)\nq=deque(g[1])\na[1] = s[1] if s[1]!=-1 else 0\ndp[1]=a[1]\nans=a[1]\nok=1\nwhile(q):\n    x=q.popleft()\n    if sub[x]==inf:\n        a[x]=0\n    else:\n        if s[x]==-1 : a[x]=sub[x]-dp[fa[x]]\n        else : a[x]=s[x]-dp[fa[x]]\n    if a[x]<0 :\n        ok=0\n        break\n    dp[x]=dp[fa[x]]+a[x]\n    ans+=a[x]\n    for y in g[x]:\n        q.append(y)\n\nprint(ans) if ok else print(-1)     \n", "import sys\ninput=sys.stdin.readline\nimport collections\nfrom collections import defaultdict\nn=int(input())\npar=[ int(i) for i in input().split() if i!='\\n']\nsuma=[int(i) for i in input().split() if i!='\\n']\ngraph=defaultdict(list)\nfor i in range(n-1):\n    graph[i+2].append(par[i])\n    graph[par[i]].append(i+2)\n#print(graph)\nweight=[0]*(n+1)\nweight[1]=suma[0]\nqueue=collections.deque([1])\nvisited=set()\nvisited.add(1)\nok=True\nwhile queue:\n    vertex=queue.popleft()\n    for child in graph[vertex]:\n        if child not in visited: \n            if suma[child-1]==-1:\n                mina=[]\n                if len(graph[child])==1:\n                    mina=[0]\n                else:   \n                    for j in graph[child]:\n                        if j!=vertex:\n                            mina.append(suma[j-1]-suma[vertex-1])\n                ans=suma[vertex-1]+min(mina)\n                suma[child-1]=ans\n                if suma[child-1]<suma[vertex-1]:\n                    ok=False\n                else:\n                    weight[child]=(suma[child-1]-suma[vertex-1])\n            else:\n                if suma[child-1]<suma[vertex-1]:\n                    ok=False\n                else:\n                    weight[child]=(suma[child-1]-suma[vertex-1])\n            #print(child,vertex,weight,suma[child-1],suma[vertex-1])\n            queue.append(child)\n            visited.add(child)\n#print(weight,ok,suma)\nif ok==True:\n    print(sum(weight))\nelse:\n    print(-1)\n", "import collections\nfrom collections import defaultdict\nn=int(input())\npar=[ int(i) for i in input().split() if i!='\\n']\nsuma=[int(i) for i in input().split() if i!='\\n']\ngraph=defaultdict(list)\nfor i in range(n-1):\n    graph[i+2].append(par[i])\n    graph[par[i]].append(i+2)\nweight=[0]*(n+1)\nweight[1]=suma[0]\nqueue=collections.deque([1])\nvisited=set()\nvisited.add(1)\nok=True\nwhile queue:\n    vertex=queue.popleft()\n    for child in graph[vertex]:\n        if child not in visited: \n            if suma[child-1]==-1:\n                mina=[]\n                if len(graph[child])==1:\n                    mina=[0]\n                else:   \n                    for j in graph[child]:\n                        if j!=vertex:\n                            mina.append(suma[j-1]-suma[vertex-1])\n                ans=suma[vertex-1]+min(mina)\n                suma[child-1]=ans\n                if suma[child-1]<suma[vertex-1]:\n                    ok=False\n                else:\n                    weight[child]=(suma[child-1]-suma[vertex-1])\n            else:\n                if suma[child-1]<suma[vertex-1]:\n                    ok=False\n                else:\n                    weight[child]=(suma[child-1]-suma[vertex-1])\n            queue.append(child)\n            visited.add(child)\nif ok==True:\n    print(sum(weight))\nelse:\n    print(-1)\n", "from collections import deque\n\n\ndef solve(p, s):\n    children = {}\n    parents = {}\n    for i, e in enumerate(p):\n        if e not in children:\n            children[e] = []\n        children[e].append(i+2)\n        parents[i+2] = e\n\n    sums = {}\n    for i, e in enumerate(s):\n        sums[i+1] = e if e != -1 else None\n\n    queue = deque([1])\n\n    while len(queue) > 0:\n        to_visit = queue.popleft()\n        if to_visit in children:\n            for child in children[to_visit]:\n                queue.append(child)\n\n        if sums[to_visit] is None:\n            parent = sums[parents[to_visit]]\n            if to_visit in children:\n                min_child = min(map(lambda x: sums[x], children[to_visit]))\n                if min_child - parent < 0:\n                    return -1\n                sums[to_visit] = min_child\n            else:\n                sums[to_visit] = parent\n\n    result = 0\n\n    for key in sums:\n        if key in parents:\n            result += sums[key] - sums[parents[key]]\n        else:\n            result += sums[key]\n\n    return result\n\n\n\n\n\n\ndef __starting_point():\n    n = int(input())\n    p = map(int, input().split())\n    s = map(int, input().split())\n    print(solve(p, s))\n__starting_point()", "n,ans=int(input()),0\na=[0,0]+list(map(int,input().split()))\ns=[0]+[i if i!=-1 else 1e9+1 for i in map(int,input().split())]\nfor i in range(1,n+1):s[a[i]]=min(s[a[i]],s[i])\nfor i in range(1,n+1):\n    if s[a[i]]>s[i]:print(-1);return\n    if s[i]==1e9+1:s[i]=s[a[i]]\n    ans+=s[i]-s[a[i]]\nprint(ans)", "from collections import deque\n\nclass Graph(object):\n\t\"\"\"docstring for Graph\"\"\"\n\tdef __init__(self,n,d): # Number of nodes and d is True if directed\n\t\tself.n = n\n\t\tself.graph = [[] for i in range(n)]\n\t\tself.parent = [-1 for i in range(n)]\n\t\tself.directed = d\n\t\t\n\tdef addEdge(self,x,y):\n\t\tself.graph[x].append(y)\n\t\tif not self.directed:\n\t\t\tself.graph[y].append(x)\n\n\tdef bfs(self, root): # NORMAL BFS\n\t\tself.parent = [-1 for i in range(self.n)]\n\t\tqueue = [root]\n\t\tqueue = deque(queue)\n\t\tvis = [0]*self.n\n\t\tans = 0\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tif self.parent[element] != -1 and s[element] != -1:\n\t\t\t\tif s[self.parent[self.parent[element]]] > s[element]:\n\t\t\t\t\treturn False\n\t\t\tflag = 0\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tflag = 1\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tself.parent[i] = element\n\t\t\t# if flag == 0:\n\t\t\t# \tif s[element] == -1:\n\t\t\t# \t\tif parent[element] != -1:\n\t\t\t# \t\t\tans+=s[parent[element]]\n\t\t\t# \telse:\n\t\t\t# \t\tans+=s[element]\n\t\treturn True\n\n\tdef dfs(self, root, ans): # Iterative DFS\n\t\tstack=[root]\n\t\tvis=[0]*self.n\n\t\tstack2=[]\n\t\twhile len(stack)!=0: # INITIAL TRAVERSAL\n\t\t\telement = stack.pop()\n\t\t\tif vis[element]:\n\t\t\t\tcontinue\n\t\t\tvis[element] = 1\n\t\t\tstack2.append(element)\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tself.parent[i] = element\n\t\t\t\t\tstack.append(i)\n\n\t\twhile len(stack2)!=0: # BACKTRACING. Modify the loop according to the question\n\t\t\telement = stack2.pop()\n\t\t\tm = 10**18\n\t\t\tif s[element] == -1:\n\t\t\t\tfor i in self.graph[element]:\n\t\t\t\t\tif i!=self.parent[element]:\n\t\t\t\t\t\tm = min(m, ans[i])\n\t\t\t\tif m==10**18:\n\t\t\t\t\tm = 0\n\t\t\t\t\tans[element] = 0\n\t\t\t\telse:\n\t\t\t\t\tans[element] = m\n\t\t\tfor i in self.graph[element]:\n\t\t\t\tif i!=self.parent[element]:\n\t\t\t\t\tans[i] = max(ans[i]-ans[element],0)\n\t\treturn ans\n\n\tdef shortestpath(self, source, dest): # Calculate Shortest Path between two nodes\n\t\tself.bfs(source)\n\t\tpath = [dest]\n\t\twhile self.parent[path[-1]]!=-1:\n\t\t\tpath.append(parent[path[-1]])\n\t\treturn path[::-1]\n\n\tdef ifcycle(self):\n\t\tself.bfs(0)\n\t\tqueue = [0]\n\t\tvis = [0]*n\n\t\tqueue = deque(queue)\n\t\twhile len(queue)!=0:\n\t\t\telement = queue.popleft()\n\t\t\tvis[element] = 1\n\t\t\tfor i in graph[element]:\n\t\t\t\tif vis[i]==1 and i!=parent[element]:\n\t\t\t\t\treturn True\n\t\t\t\tif vis[i]==0:\n\t\t\t\t\tqueue.append(i)\n\t\t\t\t\tvis[i] = 1\n\t\treturn False\n\n\tdef reroot(self, root, ans):\n\t\tstack = [root]\n\t\tvis = [0]*n\n\t\twhile len(stack)!=0:\n\t\t\te = stack[-1]\n\t\t\tif vis[e]:\n\t\t\t\tstack.pop()\n\t\t\t\t# Reverse_The_Change()\n\t\t\t\tcontinue\n\t\t\tvis[e] = 1\n\t\t\tfor i in graph[e]:\n\t\t\t\tif not vis[e]:\n\t\t\t\t\tstack.append(i)\n\t\t\tif self.parent[e]==-1:\n\t\t\t\tcontinue\n\t\t\t# Change_The_Answers()\n\n\n\nn = int(input())\ng = Graph(n,False)\np = list(map(int,input().split()))\ns = list(map(int,input().split()))\nfor i in range(len(p)):\n\tg.addEdge(i+1,p[i]-1)\nif not g.bfs(0):\n\tprint(-1)\n\treturn\ns=g.dfs(0,s)\n# print (s)\nprint(sum(s))\n", "from sys import stdin\ninput=lambda : stdin.readline().strip()\nfrom math import ceil,sqrt,factorial,gcd\nfrom collections import deque\nn=int(input())\nl=list(map(int,input().split()))\ns=list(map(int,input().split()))\ngraph={i:set() for i in range(1,n+1)}\nfor i in range(n-1):\n\tgraph[l[i]].add(i+2)\nlevel=[[] for i in range(n+2)]\nstack=[[1,1]]\nflag=1\nwhile stack:\n\tx,y=stack.pop()\n\tlevel[y].append(x)\n\tfor i in graph[x]:\n\t\tstack.append([i,y+1])\n# print(level)\nans=[0 for i in range(n+2)]\nans[1]=s[0]\nfor i in range(1,n+1):\n\tif i%2==0:\n\t\tfor j in level[i]:\n\t\t\tpapa=s[l[j-2]-1]\n\t\t\tif len(graph[j])==0:\n\t\t\t\ts[j-1]=papa\n\t\t\t\tans[j]=0\n\t\t\telse:\n\t\t\t\tmi=float(\"infinity\")\n\t\t\t\tfor k in graph[j]:\n\t\t\t\t\tmi=min(mi,s[k-1])\n\t\t\t\t\tif s[k-1]<papa:\n\t\t\t\t\t\tflag=0\n\t\t\t\t\t\tbreak\n\t\t\t\tans[j]=mi-papa\n\t\t\t\ts[j-1]=papa+ans[j]\n\telse:\n\t\tif i>1:\n\t\t\tfor j in level[i]:\n\t\t\t\tpapa=s[l[j-2]-1]\n\t\t\t\t# print(papa)\n\t\t\t\tans[j]=s[j-1]-papa\n# print(ans)\nif flag==0:\n\tprint(-1)\nelse:\n\tprint(sum(ans))\n", "n=int(input())\np=[0,0]+list(map(int,input().split()))\ns=[0]+list(map(int,input().split()))\nht=[0]*(n+1)\nht[1]=1\n\nfrom collections import defaultdict,deque\ngr=defaultdict(list)\n\nfor i in range(2,n+1):\n    gr[p[i]].append(i)\n    \nq=deque()\nq.append([1,-1])\nwhile q:\n    x,pr=q.popleft()\n    for i in gr[x]:\n        if i!=pr:\n            ht[i]=ht[x]+1\n            q.append([i,x])\na=[0]*(n+1)\na[1]=s[1]\n\n\nq.append([1,-1])\nwhile q:\n    x,pr=q.popleft()\n    for ch in gr[x]:\n        q.append([ch,x])\n        \n    if ht[x]%2==0:\n        mn=float('inf')\n        for i in gr[x]:\n            mn=min(mn,s[i]-s[p[x]])\n            \n        if mn!=float('inf'):\n            a[x]=mn\n        for i in gr[x]:\n            a[i]=s[i]-s[p[x]]-mn        \ntf=True\nfor i in a:\n    if i<0:\n        tf=False\n        break\nif tf:\n    print(sum(a))        \nelse:\n    print(-1)", "def solve():\n    a = [None] * (n + 1)\n\n    a[1] = s[0]\n    for i in range(2, n + 1):\n        if s[i - 1] == -1:\n            continue\n\n        pi = p[i - 2]\n        pi_er_pi = p[pi - 2]\n\n        if s[i - 1] < s[pi_er_pi - 1]:\n            return -1\n\n        new_value = s[i - 1] - s[pi_er_pi - 1]\n        a[pi] = min(a[pi] if a[pi] is not None else float('inf'), new_value)\n\n    for i in range(2, n + 1):\n        if s[i - 1] == -1:\n            continue\n\n        pi = p[i - 2]\n        pi_er_pi = p[pi - 2]\n\n        a[i] = s[i - 1] - s[pi_er_pi - 1] - a[pi]\n\n    return sum(filter(None, a))\n\n\nn = int(input())\np = list(map(int, input().split()))\ns = list(map(int, input().split()))\nans = solve()\nprint(ans)"]