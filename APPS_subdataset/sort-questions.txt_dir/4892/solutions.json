["from itertools import combinations\n\ndef area(t):\n    (a,b),(c,d),(e,f) = t\n    return abs(a*d+b*e+c*f-d*e-a*f-b*c)/2\n\ndef find_biggTriang(lst):\n    tris  = list(combinations(lst,3))\n    areas = list(map(area,tris))\n    m     = max(areas)\n    mTris = [list(map(list,t)) for t,v in zip(tris,areas) if v==m]\n    return [ len(lst), len(tris), sum(map(bool,areas)),\n             mTris if len(mTris)!=1 else mTris.pop(), m]", "from itertools import combinations as com\nfrom collections import defaultdict\n\ndef area(points):\n    (ax, ay), (bx, by), (cx, cy) = points\n    return abs(ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)) / 2\n\ndef find_biggTriang(listPoints):\n    allcom = [[[j[0], j[1]] for j in i] for i in set(com(listPoints, 3))]\n    aaa = defaultdict(list)\n    count = 0\n    for i in allcom:\n        ar = area(i)\n        if ar != 0:\n            count += 1\n            aaa[ar].append(i)\n    maxarea = max(set(aaa.keys()))\n    po = aaa[maxarea]\n    if len(po) == 1: po = po[0]\n        \n    return([len(listPoints), len(allcom), count, po, maxarea])", "from itertools import combinations\n\ndef find_biggTriang(points):\n    num_triplets = num_triangles = 0\n    max_area, max_triangles = 0, []\n    for triangle in map(list, combinations(map(list, points), 3)):\n        num_triplets += 1\n        (ax, ay), (bx, by), (cx, cy) = triangle\n        area = abs(ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)) / 2\n        if not area: continue\n        num_triangles += 1\n        if area > max_area: max_area, max_triangles = area, []\n        if area == max_area: max_triangles.append(triangle)\n    return [len(points), num_triplets, num_triangles,\n            max_triangles.pop() if len(max_triangles) == 1 else max_triangles, max_area]", "def find_biggTriang(ps):\n    n = len(ps)\n    count = 0\n    max_area = -1.0\n    max_area_triangles = []\n    for i in xrange(n):\n        for j in xrange(i + 1, n):\n            dx1, dy1 = ps[j][0] - ps[i][0], ps[j][1] - ps[i][1]\n            for k in xrange(j + 1, n):\n                dx2, dy2 = ps[k][0] - ps[i][0], ps[k][1] - ps[i][1]\n                a = abs(0.5 * (dx1 * dy2 - dx2 * dy1))\n                count += a != 0\n                if a < max_area:\n                    continue\n                triangle = [ps[i], ps[j], ps[k]]\n                if a > max_area:\n                    max_area = a\n                    max_area_triangles = [triangle]\n                elif a == max_area:\n                    max_area_triangles.append(triangle)\n    max_area_triangles = [map(list, tr) for tr in max_area_triangles]\n    if len(max_area_triangles) == 1:\n        max_area_triangles = max_area_triangles[0]\n    return [n, n * (n-1) * (n-2) // 6, count, max_area_triangles, max_area]", "from itertools import combinations\n\n\ndef dist(a, b):\n    return ((a[0]-b[0])**2+(a[1]-b[1])**2)**0.5\n\n\ndef triangle_area(A, B, C):\n    a, b, c = sorted([dist(A, B), dist(A, C), dist(B, C)])\n    if a+b > c and c-a < b:\n        s = round(((a+b+c)*(a+b-c)*(a+c-b)*(b+c-a))**0.5/4, 1)\n    else:\n        s = None\n    return s\n\n\ndef find_biggTriang(listPoints):\n    num_points = len(listPoints)  # 1\n    possible_count = 0\n    real_count = 0\n    areas = {}\n    max_area = 0\n    for x in combinations(listPoints, 3):\n        possible_count += 1\n        area = triangle_area(*x)\n        if area:\n            areas[x] = area\n            max_area = max(max_area, area)\n            real_count += 1\n    max_triangles = [list(map(list, k))\n                     for k, v in list(areas.items()) if v == max_area]\n    if len(max_triangles) == 1:\n        max_triangles = max_triangles[0]\n    return [num_points, possible_count, real_count, max_triangles, max_area]\n\n", "def area_triangel(i):\n    return abs(1/2*(i[0][0]*i[1][1]+i[0][1]*i[2][0]+i[1][0]*i[2][1]-i[2][0]*i[1][1]-i[2][1]*i[0][0]-i[1][0]*i[0][1]))\n\ndef find_biggTriang(listPoints):\n    import itertools\n    max_points = []\n    max_area = -1000\n    every_valid_point = list(itertools.combinations(listPoints, 3))\n    num_invalid_points = 0\n    for j in every_valid_point:\n        area = area_triangel(j)\n        if area == 0:\n            num_invalid_points += 1\n        elif area > max_area:\n            max_area, max_points = area, []\n            max_points.append(list(list(x) for x in j))\n        elif area == max_area:\n            max_points.append(list(list(x) for x in j))\n\n    return [len(listPoints), len(every_valid_point), len(every_valid_point)-num_invalid_points, max_points[0] if len(max_points) == 1 else max_points ,max_area]", "from itertools import combinations\nfrom numpy.linalg import det\n\ndef find_biggTriang(listP):\n    lp = list(map(list,listP))\n    result = [0,0,0,[],0]\n    result[0] = len(lp)\n    lc = list(combinations(lp,3))\n    result[1] = len(lc)\n    n = 0\n    for c in lc:\n        l = list(c)\n        m = [[l[0][0],l[0][1],1],[l[1][0],l[1][1],1],[l[2][0],l[2][1],1]]\n        A = round((1/2)*abs(det(m)),1)\n        if A == 0:\n            n += 1\n        elif A==result[4]:\n            result[3].append(l)\n        elif A>result[4]:\n            result[4] = A\n            result[3].clear()\n            result[3].append(l)\n    result[2] = result[1] - n\n    result[3] = sorted(result[3])\n    if len(result[3])==1:\n        result[3] = result[3][0]\n    return result", "from itertools import combinations\n\ndef find_biggTriang(listPoints):\n    s = combinations(listPoints, 3)\n    j = 0\n    i = 0\n    ret = []\n    mx = 0\n    for a, b, c in s:\n        s = abs((b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1]-a[1])) / 2\n        if s > mx:\n            mx = s\n            ret = []\n        if s == mx:\n            ret.append([list(a), list(b), list(c)])\n        if s > 0:\n            i += 1\n        j += 1\n    if len(ret) <= 1:\n        ret = ret[0]\n    return [len(listPoints), j, i, ret, mx]", "import math\n\ndef area(x,y,z):\n    a = math.hypot(x[0]-y[0],x[1]-y[1])\n    b = math.hypot(x[0]-z[0],x[1]-z[1])\n    c = math.hypot(z[0]-y[0],z[1]-y[1])\n    p = (a+b+c)/2\n    s = (p*(p-a)*(p-b)*(p-c))**.5 \n    if abs(s)/(a+b+c)<1e-6: \n        return 0\n    return round(s,6)\n\n\ndef find_biggTriang(listPoints):\n    num_of_pts = len(listPoints)\n    num_of_tri = 0\n    best_area = None\n    best_list = []\n    for i in range(num_of_pts-2):\n        for j in range(i+1,num_of_pts-1):\n            for k in range(j+1,num_of_pts):\n                a = area(listPoints[i],listPoints[j],listPoints[k])\n                if a>0:\n                    num_of_tri += 1\n                    if best_area is None or best_area<a:\n                        best_area = a\n                        best_list = []\n                    if a==best_area:\n                        best_list.append([list(listPoints[x]) for x in (i,j,k)])\n    if len(best_list)==1:\n        best_list = best_list[0]\n    return [num_of_pts, num_of_pts*(num_of_pts-1)*(num_of_pts-2)//6,num_of_tri,best_list,best_area]", "def find_biggTriang(P,m=0,c=0):\n    Z,V,l=[],set(),len(P)\n    for i in range(l-2):\n        for j in range(i+1,l-1):\n            for k in range(j+1,l):\n                (x,y),(u,v),(p,q)=P[i],P[j],P[k]\n                s=abs((u-x)*(q-y)-(v-y)*(p-x))/2\n                if s:V.add((i,j,k))\n                T=[[x,y],[u,v],[p,q]]\n                if m<s:Z,m=[T],s\n                elif m==s:Z+=[T]\n                c+=1\n    return[l,c,len(V),1<len(Z)and Z or Z[0],m]"]