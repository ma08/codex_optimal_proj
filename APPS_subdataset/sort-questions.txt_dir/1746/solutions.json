["def rpg(field, actions):\n    p = Player(field)\n    try:\n        for m in actions:\n            if m=='A': p.attack()\n            elif m in 'HCK':  p.use(m)\n            elif m in '<^>v': p.rotate(m)\n            p.checkDmgsAndAlive()\n            if m=='F':        p.move()\n            \n    except Exception as e:\n        return None\n    return p.state()\n    \n\nclass Player:\n    DIRS = dict(list(zip('<>^v',((0,-1),(0,1),(-1,0),(1,0)))))\n\n    def __init__(self,field):\n        self.h, self.atk, self.d, self.bag, self.xps = 3,1,1,[],0\n        self.field = field\n        self.pngs  = {}\n        for x,r in enumerate(self.field):\n            for y,c in enumerate(r):\n                if c in self.DIRS: self.x,self.y,self.c=x,y,c ; self.dx,self.dy=self.DIRS[c]\n                elif c=='D':       self.pngs[(x,y)] = {'h':10, 'atk':3}\n                elif c=='E':       self.pngs[(x,y)] = {'h':1,  'atk':2}\n                elif c=='M':       self.pngs['M']   = {'coins':3}\n    \n    def state(self): return self.field, self.h, self.atk, self.d, sorted(self.bag)\n    \n    def rotate(self,c):\n        self.dx, self.dy = self.DIRS[c]\n        self.c = self.field[self.x][self.y] = c\n    \n    def move(self):\n        self.field[self.x][self.y] = ' '\n        self.x += self.dx\n        self.y += self.dy\n        c = self.field[self.x][self.y]\n        assert c not in '#ED-|M' and self.x>=0 and self.y>=0\n        if c!=' ': self.takeThis(c)\n        self.field[self.x][self.y] = self.c\n    \n    def checkAhead(self,what):\n        x,y = self.x+self.dx, self.y+self.dy\n        assert self.field[x][y] in what\n        return x,y\n    \n    def takeThis(self,c):\n        if c not in 'SX': self.bag.append(c)\n        if   c=='S': self.d += 1\n        elif c=='X': self.atk += 1\n        \n    def use(self,c):\n        self.bag.remove(c)\n        if c=='C':\n            x,y = self.checkAhead('M')\n            self.pngs['M']['coins'] -= 1\n            if not self.pngs['M']['coins']: self.field[x][y] = ' '\n        elif c=='H':\n            assert self.h<3\n            self.h = 3\n        elif c=='K':\n            x,y = self.checkAhead('|-')\n            self.field[x][y] = ' '\n        \n    def attack(self):\n        x,y = nmy = self.checkAhead('ED')\n        self.pngs[nmy]['h'] -= self.atk\n        if self.pngs[nmy]['h']<1:\n            del self.pngs[nmy]\n            self.field[x][y] = ' '\n            lvlUp,self.xps = divmod(self.xps+1,3)\n            self.atk += lvlUp\n        \n    def checkDmgsAndAlive(self):\n        for dx,dy in list(self.DIRS.values()):\n            nmy = self.x+dx, self.y+dy\n            if nmy in self.pngs:\n                self.h -= max(0,self.pngs[nmy]['atk'] - self.d)\n                assert self.h>0\n        \n", "only_show_wrong()\nclass RPG:\n    \n    def __init__(self, field, actions):\n        frame = ['#'] * (len(field[0])+2)\n        self.field = [frame] + [['#'] +  line + ['#'] for line in field]  + [frame]\n        self.actions = actions\n        self.l = len(self.field)\n        self.pack = {'H':3, 'X':1, 'S':1,}\n        self.bag = []\n        self.moves = {'<':(0,-1) ,'>':(0,1), '^':(-1,0), 'v':(1,0)}\n        self.x = self.find_player(self.field, lambda e:any(('<' in e, '>' in e, '^' in e, 'v' in e)))\n        self.y = self.find_player(self.field[self.x], lambda e:e in '<>^v')\n        self._player = self.field[self.x][self.y]\n        self.back = None\n        self.boss = 10\n        self._result = 1\n        self.use_coint = 0\n        self.level_up = 0\n        self.ready_atack = []\n        self.use_item = {'K':self.use_key,'C':self.coint_act,'H':self.get_energy,'A':self.atack}\n        \n    def __call__(self):\n        for i, act in enumerate(self.actions):\n            self.use_item.get(act, self.make_step)(act, act!='F')\n            if not self._result:\n                break\n            self.enemy_status(i,act)\n        if self.use_coint:\n            x,y = self.step\n            if self.field[x][y] != 'M':\n                return\n        return self.result\n        \n    @property\n    def game_over(self):\n        self._result = None\n    \n    @property\n    def step(self):\n        move = self.moves[self._player]\n        return (self.x + move[0], self.y + move[1])\n        \n    @property\n    def result(self):\n        if self._result:\n            return ([line[1:-1] for line in self.field[1:-1]], *self.pack.values(), sorted(self.bag))\n        \n    @property\n    def set_player(self):\n        self._player = self.field[self.x][self.y]\n        return self._player\n    \n    def enemy_status(self,i,act):\n        for x,y in [(self.x+1, self.y),(self.x-1, self.y),(self.x, self.y+1),(self.x, self.y-1)]:\n            if self.field[x][y] in 'DE':\n                self.ready_atack.append(self.field[x][y])\n        if self.ready_atack:\n            pref_a, next_a, l = self.actions, self.actions, len(self.actions)-1\n            if i and i<l and pref_a[i-1] in '<>^vF' and next_a[i+1] =='F' and act=='F' or act in '<>^vAH' and i!=l or act =='F' and i<l and next_a[i+1] in '<>v^' :\n                self.enemy_atack()\n            self.ready_atack = []\n          \n    def enemy_atack(self):\n        for enemy in self.ready_atack:\n            self.pack['H'] -= max(0, (2,3)[enemy=='D'] - self.pack['S'])\n            if self.pack['H'] <= 0:\n                self.game_over\n        \n    def act(self):\n        if self.back in '|-M#E':\n            self.game_over\n        if self.back in 'KCH':\n            self.bag.append(self.back)\n        if self.back in 'SX':\n            self.pack[self.back] += 1\n            \n    def ded(self,x,y):\n        self.field[x][y] = ' '\n        \n    def use_key(self,key,x):\n        x, y = self.step\n        if key in self.bag and self.field[x][y] in '|-':\n            self.drop(key)\n            self.ded(x,y)\n        else:\n            self.game_over\n            \n    def atack(self,x,z):\n        x, y = self.step\n        if self.field[x][y] == 'E':\n            self.ded(x,y)\n            self.level_up += 1\n            if self.level_up == 3:\n                self.pack['X'] += 1\n                self.level_up   = 0\n        elif self.field[x][y] == 'D':\n            self.boss -= self.pack['X']\n            if self.boss <= 0:\n                self.ded(x,y)\n        else:\n            self.game_over\n            \n    def coint_act(self, coint , i):\n        if coint not in self.bag:\n            self.game_over\n            return\n        self.use_coint += i\n        self.drop(coint)\n        if self.use_coint == 3:  \n            x, y = self.step\n            if  self.field[x][y] == 'M':\n                self.use_coint = 0\n                self.ded(x,y)\n            else:\n                self.game_over\n            \n    def get_energy(self, energy,x):\n        if energy not in self.bag or self.pack[energy] >=3:\n            self.game_over\n            return\n        self.drop(energy)\n        self.pack[energy] = 3\n            \n    def drop(self, element):\n        del self.bag[self.bag.index(element)]\n    \n    def make_step(self, element,p):\n        way = (self.set_player, element)[p]\n        if not p:\n            self.field[self.x][self.y] = ' ' \n            self.x, self.y = self.step\n        if self.x < 1 or self.x >= self.l-1 or  self.y < 1 or self.y >= len(self.field[self.x])-1:\n            self.game_over\n            return\n        if self.field[self.x][self.y] != ' ':\n            self.back = self.field[self.x][self.y]\n            self.act()\n        self.field[self.x][self.y] = way\n        self.set_player\n        \n    @staticmethod\n    def find_player( field, condition ):\n        return next(i for i,e in enumerate(field) if condition(e))\n        \ndef rpg(f, a) -> Tuple[List[List[str]], int, int, int, List[str]]:\n    play_game = RPG(f,a)\n    return play_game() ", "only_show_wrong()\n\ndef rpg(map: List[List[str]], actions: List[str]) -> Tuple[List[List[str]], int, int, int, List[str]]:\n    class Hero:\n        def __init__(self, coordy, coordx, pointer):\n            self.coordx = coordx\n            self.coordy = coordy\n            self.health = 3\n            self.attack = 1\n            self.defence = 1\n            self.pointer = pointer\n            self.bag = []\n            self.kills = 0\n            self.lvlupkills = 0\n\n    class Monsters:\n        def __init__(self, coordy, coordx, attack, health):\n            self.coordx = coordx\n            self.coordy = coordy\n            self.attack = attack\n            self.health = health\n\n    class DemonLord(Monsters):\n        pass\n\n    class Merchant:\n        def __init__(self, coordy, coordx):\n            self.coordx = coordx\n            self.coordy = coordy\n            self.health = 3\n\n    def initiate(field):\n        monstdict = {}\n        merchdict = {}\n        hero = 0\n        for y in range(len(field)):\n            for x in range(len(field[y])):\n                if field[y][x] == \"E\":\n                    monstdict[(y, x)] = Monsters(y, x, 2, 1)\n                elif field[y][x] == \"D\":\n                    monstdict[(y, x)] = DemonLord(y, x, 3, 10)\n                elif field[y][x] in (\"^\", \">\", \"v\", \"<\"):\n                    hero = Hero(y, x, field[y][x])\n                elif field[y][x] == \"M\":\n                    merchdict[(y, x)] = Merchant(y,x)\n        return (monstdict, hero, merchdict)\n\n    def monsters_move(hero,monstdict):\n        for i in [(hero.coordy, hero.coordx - 1), (hero.coordy + 1, hero.coordx), (hero.coordy, hero.coordx + 1),\n                  (hero.coordy - 1, hero.coordx)]:\n            if i in monstdict:\n                hero.health -= max(0, monstdict[i].attack - hero.defence)\n\n    def forward_coords(hero):\n        pointer = {\"^\": (0, -1), \">\": (1, 0), \"v\": (0, 1), \"<\": (-1, 0)}\n        coordx = hero.coordx + pointer[hero.pointer][0]\n        coordy = hero.coordy + pointer[hero.pointer][1]\n        return (coordx, coordy)\n\n    def move_forward(hero,field,monstdict,merchdict):\n        monsters_move(hero,monstdict)\n        field[hero.coordy][hero.coordx] = \" \"\n        coords = forward_coords(hero)\n        hero.coordx = coords[0]\n        hero.coordy = coords[1]\n        if 0 <= hero.coordy < len(field) and 0 <= hero.coordx < len(field[hero.coordy]) and field[hero.coordy][\n            hero.coordx] not in (\"D\", \"E\", \"M\", \"#\", \"-\", \"|\"):\n            if field[hero.coordy][hero.coordx] in (\"C\", \"H\", \"K\"):\n                hero.bag.append(field[hero.coordy][hero.coordx])\n            elif field[hero.coordy][hero.coordx] == \"S\":\n                hero.defence += 1\n            elif field[hero.coordy][hero.coordx] == \"X\":\n                hero.attack += 1\n            field[hero.coordy][hero.coordx] = hero.pointer\n            return True\n        else:\n            return False\n\n    def change_pointer(hero,field,monstdict,merchdict,pointer):\n        monsters_move(hero,monstdict)\n        hero.pointer = pointer\n        field[hero.coordy][hero.coordx] = pointer\n        if hero.health <= 0:\n            return False\n        return True\n\n    def use_coin(hero,field,monstdict,merchdict):\n        monsters_move(hero,monstdict)\n        coords = forward_coords(hero)\n        x = coords[0]\n        y = coords[1]\n        if \"C\" in hero.bag and (y, x) in merchdict and hero.health > 0:\n            merchdict[(y, x)].health -= 1\n            hero.bag.pop(hero.bag.index(\"C\"))\n            if merchdict[(y, x)].health == 0:\n                field[y][x] = \" \"\n                del merchdict[(y, x)]\n            return True\n        return False\n\n    def use_potion(hero,field,monstdict,merchdict):\n        if \"H\" in hero.bag and hero.health != 3:\n            hero.health = 3\n            hero.bag.pop(hero.bag.index(\"H\"))\n        else:\n            return False\n        monsters_move(hero,monstdict)\n        return True if hero.health > 0 else False\n\n    def use_key(hero,field,monstdict,merchdict):\n        coords = forward_coords(hero)\n        x = coords[0]\n        y = coords[1]\n        monsters_move(hero,monstdict)\n        if \"K\" in hero.bag and 0 <= x < len(field[y]) and 0 <= y < len(field) and field[y][x] in (\n                \"-\", \"|\") and hero.health > 0:\n            field[y][x] = \" \"\n            hero.bag.pop(hero.bag.index(\"K\"))\n            return True\n        return False\n\n    def attack(hero,field,monstdict,merchdict):\n        coords = forward_coords(hero)\n        x = coords[0]\n        y = coords[1]\n        if (y, x) in monstdict:\n            monstdict[(y, x)].health -= hero.attack\n            if monstdict[(y, x)].health <= 0:\n                hero.lvlupkills += 1\n                if hero.lvlupkills == 3:\n                    hero.attack += 1\n                    hero.lvlupkills = 0\n                hero.kills += 1\n                field[y][x] = \" \"\n                del monstdict[(y, x)]\n        else:\n            return False\n        monsters_move(hero,monstdict)\n        return True if hero.health > 0 else False\n\n    field = [[str(x) for x in line] for line in map]\n    initialize = initiate(field)\n    monstdict = initialize[0]\n    hero = initialize[1]\n    merchdict = initialize[2]\n\n    actionsdict = {\"F\": move_forward, \"A\": attack, \"C\": use_coin, \"K\": use_key, \"H\": use_potion}\n    for i in actions:\n        if i in actionsdict:\n            flag = actionsdict[i](hero,field,monstdict,merchdict)\n        else:\n            flag = change_pointer(hero,field,monstdict,merchdict,i)\n        if not flag or hero.health <=0:\n            return None\n    return (field, hero.health, hero.attack, hero.defence, sorted(hero.bag))", "only_show_wrong()\n\n\ndef rpg(game: List[List[str]], actions: List[str]) -> Tuple[List[List[str]], int, int, int, List[str]]:\n\n    # Scan through the game to find the player\n    # Any invalid action, or death, returns None\n\n    # If player is attacking\n    # Decrease health of enemy in front, or return None if invalid\n    # If enemy dies, update map\n\n    # If player is moving\n    # Update location on map, or return None if invalid\n\n    # If player is rotating\n    # Update player character inside array\n\n    # If player is using object\n    # Check if object is in bag and can be used\n    # Is valid object usage?\n    # Potion - is player low on health?\n    # Coin   - is there a merchant in front of player?\n    # Key    - is there a door in front of player?\n    # Use object, or return None if invalid\n\n    # After all action (related to where the player WAS, not their new location)\n    # If there are enemies to attack player\n    # Decrease player health, check is alive\n\n    class GameObject:\n        def __init__(self, game, h, a, d, l=None):\n            self.g = game\n            self.l = l if l is not None else (0, 0)\n            self.h = h  # health\n            self.a = a  # attack\n            self.d = d  # defense\n\n        @property\n        def is_alive(self):\n            return self.h > 0\n\n        def take_damage(self, attack):\n            damage = max(0, attack - self.d)\n            self.h -= damage\n            if not self.is_alive:\n                self.handle_death()\n                return True\n\n        def attack(self, other):\n            return other.take_damage(self.a)\n\n        def handle_death(self):\n            self.g.removeObj(self.l)\n\n    class Player(GameObject):\n\n        direction_table = {\n            \"^\": lambda self: (self.l[0], self.l[1]-1),\n            \">\": lambda self: (self.l[0]+1, self.l[1]),\n            \"v\": lambda self: (self.l[0], self.l[1]+1),\n            \"<\": lambda self: (self.l[0]-1, self.l[1]),\n        }\n\n        def __init__(self, game, s, l=None, b=None):\n            super().__init__(game, 3, 1, 1, l)\n            self.s = s  # symbol, \"^\" \">\" \"v\" or \"<\"\n            self.b = b if b is not None else []\n            self.exp = 0\n\n        def __check_forward(self):\n            new_loc = Player.direction_table[self.s](self)\n            if self.g.is_within_bounds(new_loc):\n                x, y = new_loc[0], new_loc[1]\n                obj = self.g.field[y][x]\n                return (new_loc, obj)\n            else:\n                return None\n\n        def handle_death(self):\n            self.g.player = None\n            super().handle_death()\n\n        def __find_item(self, item):\n            for i in range(len(self.b)):\n                if self.b[i] == item:\n                    return self.b.pop(i)\n            return None\n\n        def __pickup_item(self, item):\n            if item in \"CKH\":\n                self.b.append(item)\n            elif item == \"X\":\n                self.a += 1\n            else:   # == \"S\"\n                self.d += 1\n\n        def rotate(self, symb):\n            self.s = symb\n            x, y = self.l[0], self.l[1]\n            self.g.field[y][x] = self.s\n\n        def move(self):\n            new_loc = self.__check_forward()\n            if new_loc is None or new_loc[1] in \"#MED-|\":\n                return False\n            if new_loc[1] in \"CKHSX\":\n                self.__pickup_item(new_loc[1])\n\n            self.g.removeObj(self.l)\n            self.l = new_loc[0]\n            x, y = self.l[0], self.l[1]\n            self.g.field[y][x] = self.s\n            return True\n\n        def attack(self):\n            maybe_enemy = self.__check_forward()\n            if maybe_enemy is None or maybe_enemy[1] not in \"ED\":\n                return False\n\n            loc, symb = maybe_enemy[0], maybe_enemy[1]\n            if symb == \"E\":\n                enemy = self.g.enemies[loc]\n                if super().attack(enemy):\n                    self.add_exp()\n            else:\n                super().attack(self.g.demonlord)\n            return True\n\n        def add_exp(self):\n            self.exp += 1\n            if self.exp == 3:\n                self.a += 1\n                self.exp = 0\n\n        def use_item(self, item_s):\n            # Check if item is in bag\n            item = self.__find_item(item_s)\n            if item is None:\n                return False\n\n            # Check for proper item usage\n            if item == \"H\":\n                if self.h < 3:\n                    self.h = 3\n                    return True\n                else:\n                    return False\n\n            if item == \"C\":\n                maybe_merch = self.__check_forward()\n                if maybe_merch is None or maybe_merch[1] != \"M\":\n                    return False\n\n                merch_loc = maybe_merch[0]\n                self.g.merchants[merch_loc].take_damage(1)\n                return True\n\n            if item == \"K\":\n                maybe_door = self.__check_forward()\n                if maybe_door is None or maybe_door[1] not in \"-|\":\n                    return False\n\n                door_loc = maybe_door[0]\n                self.g.removeObj(door_loc)\n                return True\n\n    class Enemy(GameObject):\n        def __init__(self, game, l=None):\n            super().__init__(game, 1, 2, 0, l)\n\n        def handle_death(self):\n            del self.g.enemies[self.l]\n            super().handle_death()\n\n    class DemonLord(GameObject):\n        def __init__(self, game, l=None):\n            super().__init__(game, 10, 3, 0, l)\n\n        def handle_death(self):\n            self.g.demonlord = None\n            super().handle_death()\n\n    class Merchant(GameObject):\n        def __init__(self, game, l=None):\n            super().__init__(game, 3, 0, 0, l)\n\n        def handle_death(self):\n            del self.g.merchants[self.l]\n            super().handle_death()\n\n    class Game:\n        def __init__(self, field):\n            self.field = field\n            self.player = None\n            self.merchants = {}\n            self.enemies = {}\n            self.demonlord = None\n            self.find_game_objects()\n\n        def find_game_objects(self):\n            for y in range(len(self.field)):\n                for x in range(len(self.field[y])):\n                    if self.field[y][x] == \"M\":\n                        self.merchants[(x, y)] = Merchant(self, (x, y))\n                    if self.field[y][x] == \"E\":\n                        self.enemies[(x, y)] = Enemy(self, (x, y))\n                    if self.field[y][x] == \"D\":\n                        self.demonlord = DemonLord(self, (x, y))\n                    if self.field[y][x] in \"^><v\":\n                        self.player = Player(self, self.field[y][x], (x, y))\n\n        def is_within_bounds(self, loc):\n            return 0 <= loc[0] and loc[0] < len(self.field[0]) and 0 <= loc[1] and loc[1] < len(self.field)\n\n        def check_enemies(self, loc):\n            directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\n            for d in directions:\n\n                new_loc = (loc[0] + d[0], loc[1] + d[1])\n                if self.is_within_bounds(new_loc):\n\n                    if new_loc in self.enemies:\n                        self.enemies[new_loc].attack(self.player)\n\n                    elif self.demonlord and new_loc == self.demonlord.l:\n                        self.demonlord.attack(self.player)\n\n                if self.player is None:\n                    return False\n            return True\n\n        def removeObj(self, loc):\n            x, y = loc[0], loc[1]\n            self.field[y][x] = \" \"\n\n        def run_game(self, action_list):\n            for action in action_list:\n                prev_loc = self.player.l\n                # The player acts\n                success = True\n                if action in \"^><v\":\n                    self.player.rotate(action)\n                elif action == \"A\":\n                    success = self.player.attack()\n                elif action in \"CKH\":\n                    success = self.player.use_item(action)\n                else:\n                    success = self.player.move()\n                if not success:\n                    # Unsuccessful act? Return None\n                    return None\n\n                # Enemies attack, if there are any\n                is_alive = self.check_enemies(prev_loc)\n                if not is_alive:\n                    return None\n\n            return (self.field, self.player.h, self.player.a, self.player.d, sorted(self.player.b))\n\n    game = Game(game)\n    return game.run_game(actions)\n", "only_show_wrong()\n\ndef rpg(field: List[List[str]], actions: List[str]) -> Tuple[List[List[str]], int, int, int, List[str]]:\n    print(field, actions)\n    width = len(field[0])\n    height = len(field)\n    player = None\n    lords = 0\n    merchants = {}\n    enemies = {}\n    for y, row in enumerate(field):\n        for x, c in enumerate(row):\n            if c in dirchr: \n                if player is None:\n                    player = x, y\n                    direction = dirchr.index(c)\n                    field[y][x] = ' '\n                else:\n                    raise ValueError\n            elif c == 'D':\n                if lords: raise ValueError\n                enemies[x,y] = 10\n                lords += 1\n            elif c == 'E':\n                enemies[x,y] = 1\n            elif c == 'M':\n                merchants[(x,y)] = 3\n    if not player: raise ValueError\n\n    health = 3\n    attack = 1\n    defense = 1\n    bag = []\n    killed = 0\n    x, y = player\n\n    for a in actions:\n        if a == 'F':\n            health -= check_enemy_attack(field, width, height, x, y, defense)\n            x += dx[direction]\n            y += dy[direction]\n            if x < 0 or x >= width or y < 0 or y >= height or field[y][x] not in ' CKHSX':\n                return None\n            obj = field[y][x]\n            field[y][x] = ' '\n            if obj in 'CKH': bag.append(obj)\n            elif obj == 'S': defense += 1\n            elif obj == 'X': attack += 1\n        elif a in dirchr:\n            direction = dirchr.index(a)\n            health -= check_enemy_attack(field, width, height, x, y, defense)\n        elif a in 'ACKH':\n            if a in 'CKH':\n                if a not in bag: return None\n                bag.remove(a)\n            tx, ty = x+dx[direction], y+dy[direction]\n            if tx < 0 or tx >= width or ty < 0 or ty >= width: return None\n            target = field[ty][tx]\n            if a in valid_target and target not in valid_target[a]: return None\n            if a == 'A':\n                enemies[tx,ty] -= attack\n                if enemies[tx,ty] <= 0:\n                    field[ty][tx] = ' '\n                    killed += 1\n                    if killed == 3:\n                        attack += 1\n                        killed = 0\n                health -= check_enemy_attack(field, width, height, x, y, defense)\n            elif a == 'C':\n                merchants[tx,ty] -= 1\n                if not merchants[tx,ty]: field[ty][tx] = ' '\n            elif a == 'K':\n                field[ty][tx] = ' '\n            elif a == 'H':\n                health = 3\n                health -= check_enemy_attack(field, width, height, x, y, defense)\n        if health <= 0: return None\n\n    field[y][x] = dirchr[direction]\n    return field, health, attack, defense, sorted(bag)\n\ndirchr = '^>v<'\ndx = 0, 1, 0, -1\ndy = -1, 0, 1, 0\n\nvalid_target = dict(A='DE', C='M', K='-|')\nenemy_attack = dict(D=3, E=2)\n\ndef check_enemy_attack(field, width, height, px, py, defense):\n    damage = 0\n    for x, y in ((px,py-1), (px+1,py), (px,py+1), (px-1,py)):\n        if x >= 0 and x < width and y >=0 and y < height and field[y][x] in 'DE':\n            attack = enemy_attack[field[y][x]]\n            if attack > defense:\n                damage += attack - defense\n    return damage", "only_show_wrong()\n\nplayer = ['^', 'v', '<', '>']\nitems = [' ', 'K', 'C', 'H', 'S', 'X']\n\ndef rpg(field: List[List[str]], actions: List[str]) -> Tuple[List[List[str]], int, int, int, List[str]]:\n    health = 3\n    attack = 1\n    defense = 1\n    killed = 0\n    bag = []\n    demon_health = 10\n    merchant_greed = 3\n    for action in actions:\n        cell, x, y, x2, y2 = find_player(field)\n        if action == 'F':\n            if cell not in items:\n                return None\n            field[y2][x2] = field[y][x]\n            field[y][x] = ' '\n            if cell == ' ':\n                pass\n            elif cell == 'X':\n                attack += 1\n            elif cell == 'S':\n                defense += 1\n            else:\n                bag.append(cell)\n        elif action in player:\n            field[y][x] = action\n        elif action == 'K':\n            if cell not in ['-', '|'] or 'K' not in bag:\n                return None\n            field[y2][x2] = ' '\n            bag.remove('K')\n        elif action == 'A':\n            if cell not in ['E', 'D']:\n                return None\n            enemy_health = (demon_health if cell == 'D' else 1) - attack\n            if enemy_health <= 0:\n                field[y2][x2] = ' '\n                if cell == 'E':\n                    killed += 1\n                    if killed == 3:\n                        killed = 0\n                        attack += 1\n            else:\n                demon_health = enemy_health\n        elif action == 'C':\n            if cell != 'M' or 'C' not in bag:\n                return None\n            merchant_greed -= 1\n            bag.remove('C')\n            if merchant_greed == 0:\n                field[y2][x2] = ' '\n        elif action == 'H':\n            if health == 3 or 'H' not in bag:\n                return None\n            health = 3\n            bag.remove('H')\n        health = check_enemy_near(field, x, y, health, defense)\n        if health <= 0:\n            return None\n    bag.sort()\n    return field, health, attack, defense, bag\n\ndef check_enemy_near(field, x, y, health, defense):\n    w = len(field[0])\n    h = len(field)\n    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n        x2, y2 = x + dx, y + dy \n        if 0 <= x2 < w and 0 <= y2 < h:\n            if field[y2][x2] == 'E':\n                health -= max(0, 2 - defense)\n            elif field[y2][x2] == 'D':\n                health -= max(0, 3 - defense)\n    return health\n\ndef get_direction (player):\n    if player == '^':\n        return 0, -1\n    elif player == 'v':\n        return 0, 1\n    elif player == '<':\n        return -1, 0\n    elif player == '>':\n        return 1, 0\n\ndef find_player (field):\n    w = len(field[0])\n    h = len(field)\n    for y in range(h):\n        for x in range(w):\n            if field[y][x] in player:\n                dx, dy = get_direction(field[y][x])\n                x2, y2 = x + dx, y + dy\n                return field[y2][x2] if 0 <= x2 < w and 0 <= y2 < h else None, x, y, x2, y2\n    return None, 0, 0, 0, 0\n", "# only_show_wrong()\ndir_dict = {'^': (-1, 0), 'v': (1, 0), '<': (0, -1), '>': (0, 1)}\n\n\ndef rpg(field, actions):\n    width, height = len(field[0]), len(field)\n    field, actions = [list(line) for line in field], list(actions)\n\n    found = False\n    for row in range(height):\n        if found: break\n        for col in range(width):\n            if field[row][col] in dir_dict:\n                player_loc = (row, col)\n                player_dir = field[row][col]\n                target_loc = (row + dir_dict[player_dir][0], col + dir_dict[player_dir][1])\n                found = True\n                break\n\n    hlh, atk, des, bag = 3, 1, 1, []\n    mer_dict = {}\n    enemy_count, dl_hlh = 0, 10\n\n    for action in actions:\n        if action not in dir_dict:\n            if target_loc[0] < 0 or target_loc[0] >= height or target_loc[1] < 0 or target_loc[1] >= width: return None\n            target_tile = field[target_loc[0]][target_loc[1]]\n\n        if action == 'C':\n            if target_tile != 'M': return None\n            if action not in bag: return None\n            bag.remove(action)\n            if target_loc not in mer_dict: mer_dict[target_loc] = 2\n            else:\n                mer_dict[target_loc] = mer_dict[target_loc] - 1\n                if mer_dict[target_loc] == 0: field[target_loc[0]][target_loc[1]] = ' '\n\n        elif action == 'K':\n            if target_tile not in '-|': return None\n            if action not in bag: return None\n            bag.remove(action)\n            field[target_loc[0]][target_loc[1]] = ' '\n\n        else:\n            # enemy will attack!\n            if action == 'F':\n                if target_tile in ['C', 'K', 'H']:\n                    bag.append(target_tile)\n                    bag.sort()\n                elif target_tile == 'S': des = des + 1\n                elif target_tile == 'X': atk = atk + 1\n                elif target_tile != ' ': return None\n                field[target_loc[0]][target_loc[1]] = player_dir\n                field[player_loc[0]][player_loc[1]] = ' '\n            elif action in dir_dict:\n                player_dir = action\n                field[player_loc[0]][player_loc[1]] = action\n                target_loc = (player_loc[0] + dir_dict[player_dir][0], player_loc[1] + dir_dict[player_dir][1])\n            elif action == 'A':\n                if target_tile == 'E':\n                    field[target_loc[0]][target_loc[1]] = ' '\n                    enemy_count = enemy_count + 1\n                    if enemy_count == 3:\n                        enemy_count = 0\n                        atk = atk + 1\n                elif target_tile == 'D':\n                    dl_hlh = dl_hlh - atk\n                    if dl_hlh <= 0: field[target_loc[0]][target_loc[1]] = ' '\n                else: return None\n            elif action == 'H':\n                if action not in bag: return None\n                hlh = 3\n                bag.remove(action)\n\n            # check if enemy exists\n            for d in dir_dict:\n                check_loc = (player_loc[0] + dir_dict[d][0], player_loc[1] + dir_dict[d][1])\n                if check_loc[0] >= 0 and check_loc[0] < height and check_loc[1] >= 0 and check_loc[1] < width:\n                    if field[check_loc[0]][check_loc[1]] == 'E': hlh = hlh - max(0, 2 - des)\n                    elif field[check_loc[0]][check_loc[1]] == 'D': hlh = hlh - max(0, 3 - des)\n                    if hlh <= 0: return None\n\n            if action == 'F':\n                player_loc = target_loc\n                target_loc = (target_loc[0] + dir_dict[player_dir][0], target_loc[1] + dir_dict[player_dir][1])\n    return tuple([field, hlh, atk, des, bag])", "D = {'^': (-1, 0), 'v': (1, 0), '<': (0, -1), '>': (0, 1)}\n\ndef rpg(field, actions):\n    g = [list(x) for x in field]\n    HP, Atk, Def, Boss, En = 3, 1, 1, 10, 0\n    BC = BK = BH = 0\n    px = py = 0\n    mechanics = {}\n\n    for i in range(len(g)):\n        for j in range(len(g[i])):\n            if g[i][j] in '^v<>':\n                px, py = i, j\n            if g[i][j] == 'M':\n                mechanics[(i, j)] = 3\n\n    def move(p, q, c):\n        nonlocal BK, BC, BH, Atk, Def\n        k = g[q[0]][q[1]]\n        if k == 'K':\n            BK += 1\n        elif k == 'C':\n            BC += 1\n        elif k == 'X':\n            Atk += 1\n        elif k == 'S':\n            Def += 1\n        elif k == 'H':\n            BH += 1\n        g[q[0]][q[1]], g[p[0]][p[1]] = c, ' '\n\n    def bounds(x, y):\n        return 0 <= x < len(g) and 0 <= y < len(g[x])\n\n    def attack(i, j, e):\n        nonlocal HP, Def\n        k = g[i][j]\n        nx, ny = i+D[k][0], j+D[k][1]\n        for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n            if bounds(x, y) and g[x][y] in 'DE':\n                if not (e == 'A' and x == nx and y == ny):\n                    HP -= max({'D': 3, 'E': 2}[g[x][y]] - Def, 0)\n\n    for e in actions:\n        if e == 'H':\n            if BH <= 0 or HP == 3:\n                return None\n            BH, HP = BH-1, 3\n        attack(px, py, e)\n        k = g[px][py]\n        if e == 'F':\n            ox, oy = px, py\n            px, py = px+D[k][0], py+D[k][1]\n            if not bounds(px, py) or g[px][py] not in ' CKXSH':\n                return None\n            move((ox, oy), (px, py), k)\n        if e in '^v<>':\n            g[px][py] = e\n            \n        nx, ny = px + D[k][0], py + D[k][1]\n        if e == 'K':\n            if not bounds(nx, ny):\n                return None\n            if g[nx][ny] not in '-|' or BK <= 0:\n                return None\n            g[nx][ny] = ' '\n            BK -= 1\n        elif e == 'A':\n            if not bounds(nx, ny) or g[nx][ny] not in 'DE':\n                return None\n            if g[nx][ny] == 'E' and Atk >= 1:\n                En += 1\n                if En % 3 == 0:\n                    Atk += 1\n                g[nx][ny] = ' '\n            elif g[nx][ny] == 'D':\n                Boss -= Atk\n                if Boss <= 0:\n                    g[nx][ny] = ' '\n                    break\n                HP -= max({'D': 3, 'E': 2}[g[nx][ny]] - Def, 0)\n        elif e == 'C':\n            if not bounds(nx, ny) or g[nx][ny] != 'M' or BC <= 0:\n                return None\n            mechanics[(nx, ny)] -= 1\n            if mechanics[(nx, ny)] == 0:\n                g[nx][ny] = ' '\n            BC -= 1\n    if HP <= 0:\n        return None\n    Bag = ['C'] * BC + ['H'] * BH + ['K'] * BK\n    return g, HP, Atk, Def, Bag", "only_show_wrong()\n\ndef rpg(field, actions):\n    newfield = [[val for val in row] for row in field]\n    playerpos = [0,0,0] # [x,y,dir]\n    playerstats = [3, 1, 1, 0]  # Health, attack, defense, enemies killed\n    playerbag = []\n    myactions = actions\n\n    ## Board stuff    \n    demonlord_hp = [10]\n    merchants = []  # [[posx,posy,coinsgiven][posx,posy,coinsgiven]] this list holds a 'reference' to all merchants\n\n    ## Finding player position\n    for row in newfield:\n        for val in row:\n            if val == '^':\n                playerpos[0] = row.index(val)\n                playerpos[1] = newfield.index(row)\n                playerpos[2] = 0\n            elif val == '>':\n                playerpos[0] = row.index(val)\n                playerpos[1] = newfield.index(row)\n                playerpos[2] = 1\n            elif val == 'v':\n                playerpos[0] = row.index(val)\n                playerpos[1] = newfield.index(row)\n                playerpos[2] = 2\n            elif val == '<':\n                playerpos[0] = row.index(val)\n                playerpos[1] = newfield.index(row)\n                playerpos[2] = 3\n            elif val == 'M':\n                merchants.append([row.index(val), newfield.index(row), 3])\n    ## Taking the actions\n    for action in myactions:\n        ## Save players last known position for damage calculation\n        lastplayerpos = playerpos[:]\n        legalmove = True\n        if(action == 'F'):\n            legalmove = forward(newfield, playerpos, playerbag, playerstats)\n        elif(action == '^'):\n            playerpos[2] = 0\n            newfield[playerpos[1]][playerpos[0]] = getplayerstring(playerpos)\n        elif (action =='>'):\n            playerpos[2] = 1\n            newfield[playerpos[1]][playerpos[0]] = getplayerstring(playerpos)\n        elif (action =='v'):\n            playerpos[2] = 2\n            newfield[playerpos[1]][playerpos[0]] = getplayerstring(playerpos)\n        elif (action =='<'):\n            playerpos[2] = 3\n            newfield[playerpos[1]][playerpos[0]] = getplayerstring(playerpos)\n        elif (action =='A'):\n            legalmove = attack(newfield, playerpos, playerstats, demonlord_hp)\n            if(legalmove == 'win'):\n                print('we won!')\n                break\n        elif (action =='C'):\n            legalmove = coin(newfield, playerpos, playerbag, merchants)\n        elif (action =='K'):\n            legalmove = key(newfield, playerpos, playerbag)\n        elif (action =='H'):\n            legalmove = health(playerbag, playerstats)\n\n        if(legalmove == False):\n            print(\"Encountered invalid!\")\n            print(\"last action: \" + action)\n            return None\n        \n        ##Check for enemy damage and shit\n        enemies = getajanba(newfield, lastplayerpos)\n        if(len(enemies) > 0):\n            print(\"Printing enemies!\")\n            print('last action: ' + action)\n            for enemy in enemies:\n                print(enemy)\n        for enemy in enemies:\n            damagetodeal = max(0, 2 - playerstats[2]) if enemy == 'E' else max(0, 3 - playerstats[2])\n            playerstats[0] -= damagetodeal\n            if(playerstats[0] <= 0):\n                return None\n    \n    ## Actions finished, give back output\n    sortedbag = playerbag if len(playerbag) <= 1 else sorted(playerbag)\n    return (newfield, playerstats[0], playerstats[1], playerstats[2], sortedbag)\n    \ndef forward(field, playerpos, bag, playerstats):\n    #find where the in front of the player is\n    ## check_movement returns [obj, posx, posy]\n    infront = check_front(field, playerpos)\n    \n    if(infront == False):    ## if oob\n        return False\n\n    obj = infront[0]\n    posx = infront[1]\n    posy = infront[2]\n    if(obj == '#' or obj == 'M' or obj == '-' or obj == '|' or obj == 'E' or obj == 'D'):\n        return False\n    elif(obj == 'C' or obj == 'K' or obj == 'H'):   ## Time to check for objects(inventory)\n        bag.append(obj)\n        print(\"obtained: \" + obj + \"   bag is now: \")\n        print(bag)\n        field[posy][posx] = ' '\n    elif(obj == 'S'):\n        playerstats[2] += 1\n        field[posy][posx] = ' '\n    elif(obj == 'X'):\n        playerstats[1] += 1\n        field[posy][posx] = ' '\n    ## Update player pos\n    field[playerpos[1]][playerpos[0]] = ' '\n    field[posy][posx] = getplayerstring(playerpos)\n    playerpos[0] = posx\n    playerpos[1] = posy\n    return True\n\ndef attack(field, playerpos, playerstats, demonlord):\n    infront = check_front(field, playerpos)\n    if(infront == False):\n        return False\n    enemy = infront[0]\n    posx = infront[1]\n    posy = infront[2]\n\n    if enemy == 'E':\n        field[posy][posx] = ' '\n        playerstats[3] += 1\n        if playerstats[3] >= 3:\n            playerstats[1] += 1\n            playerstats[3] = 0\n        return True\n    elif enemy == 'D':\n        demonlord[0] -= playerstats[1]\n        if demonlord[0] <= 0:\n            field[posy][posx] = ' '\n            return 'win'\n    else: \n        return False\n\ndef coin(field, playerpos, playerbag, merchants):\n    ## Do we have coins?\n    if 'C' not in playerbag:\n        return False\n\n    ## Is a merchant in front of us\n    infront = check_front(field, playerpos)\n    if(infront == False):\n        return False\n    obj = infront[0]\n    posx = infront[1]\n    posy = infront[2]\n    if obj != 'M':\n        print('No merchant in front!')\n        return False\n    ## Find specific merchant in array\n    for merchant in merchants:\n        if merchant[0] == posx and merchant[1] == posy:\n            playerbag.remove('C')\n            merchant[2] -= 1\n            print('giving coin to merchant')\n            if merchant[2] <= 0:\n                field[posy][posx] = ' '\n                print('merchant should b gone')\n            break\n    return True\n\ndef key(field, playerpos, playerbag):\n    ## Do we have keys\n    if 'K' not in playerbag:\n        return False\n    \n    ## Is a door in front of us    \n    infront = check_front(field, playerpos)\n    if(infront == False):\n        return False\n    obj = infront[0]\n    posx = infront[1]\n    posy = infront[2]\n    if obj != '-' and obj != '|':\n        return False\n    field[posy][posx] = ' '\n    playerbag.remove('K')\n    return True\n\ndef health(playerbag, playerstats):\n    if playerstats[0] >= 3:\n        return False\n    if 'H' not in playerbag:\n        return False\n    playerstats[0] = 3\n    playerbag.remove('H')\n    return True\n\ndef check_front(field, playerpos):\n    #checking direction of movement and get square\n    posx = playerpos[0]\n    posy = playerpos[1]\n    posdir = playerpos[2]\n    if(posdir == 0):\n        posx += 0\n        posy -= 1\n    elif(posdir == 1):\n        posx += 1\n        posy -= 0\n    elif(posdir == 2):\n        posx += 0\n        posy += 1\n    elif(posdir == 3):\n        posx -= 1\n        posy -= 0\n    \n    #Check for OOB\n    if (posx < 0 or posx >= len(field[0])) or (posy < 0 or posy >= len(field)):\n        return False\n    #Check for Objects\n    obj = field[posy][posx]\n    return [obj, posx, posy]\n\ndef getplayerstring(playerpos):\n    if(playerpos[2] == 0):\n        return '^'\n    elif(playerpos[2] == 1):\n        return '>'\n    elif(playerpos[2] == 2):\n        return 'v'\n    elif(playerpos[2] == 3):\n        return '<'\n    \ndef getajanba(field, playerpos):\n    enemylist = []\n    tocheck = [[playerpos[0]+1, playerpos[1]],[playerpos[0]-1, playerpos[1]],[playerpos[0], playerpos[1]+1],[playerpos[0], playerpos[1]-1]]\n    for check in tocheck:\n        posx = check[0]\n        posy = check[1]\n        if (posx < 0 or posx >= len(field[0])) or (posy < 0 or posy >= len(field)):\n            continue\n        \n        obj = field[posy][posx]\n        if obj == 'E' or obj == 'D':\n            enemylist.append(obj) \n    return enemylist", "only_show_wrong()\nplayerDirections = {\n    \"^\": (0, -1),\n    \"<\": (-1, 0),\n    \">\": (1, 0),\n    \"v\": (0, 1)\n}\nitems = (\"X\", \"K\", \"H\", \"S\", \"C\")\n\ndef rpg(field: List[List[str]], actions: List[str]) -> Tuple[List[List[str]], int, int, int, List[str]]:\n    player = {\n        \"x\": 0,\n        \"y\": 0,\n        \"direction\": (0, 0),\n        \"char\": \"\",\n        \"health\": 3,\n        \"attack\": 1,\n        \"defense\": 1,\n        \"inventory\": [],\n        \"levelCounter\": 0,\n        \"coinsCounter\": 0\n    }\n    demonLord = 10\n    \n    for y, str in enumerate(field):\n        for x, char in enumerate(str):\n            if char in playerDirections:\n                player[\"x\"] = x\n                player[\"y\"] = y\n                player[\"direction\"] = playerDirections[char]\n                player[\"char\"] = char\n                break\n        else: continue\n        break\n    \n    for action in actions:\n        if action in playerDirections:\n            player[\"direction\"] = playerDirections[action]\n            player[\"char\"] = action\n            \n        elif action == \"F\":\n            enemiesClose = []\n            for dir in playerDirections.values():\n                adjacent = \"\"\n                try:\n                    positions = (max(0, player[\"y\"] + dir[1]), max(0, player[\"x\"] + dir[0]))\n                    adjacent = field[positions[0]][positions[1]]\n                except:\n                    adjacent = \"\"\n                if adjacent == \"E\" or adjacent == \"D\":\n                    player[\"health\"] -= max(0, (2 if adjacent == \"E\" else 3) - player[\"defense\"])\n        \n            field[player[\"y\"]][player[\"x\"]] = \" \"\n            player[\"x\"] += player[\"direction\"][0]\n            player[\"y\"] += player[\"direction\"][1]\n            \n            if(player[\"x\"] < 0 or player[\"y\"] < 0 or\n               player[\"y\"] >= len(field) or player[\"x\"] >= len(field[player[\"y\"]])): return None\n            nextTile = field[player[\"y\"]][player[\"x\"]]\n            if(not nextTile in items and nextTile != \" \"): return None\n            if(nextTile in items):\n                if nextTile == \"X\": player[\"attack\"] += 1\n                elif nextTile == \"S\": player[\"defense\"] += 1\n                else: player[\"inventory\"].append(nextTile)     \n            \n        elif action in player[\"inventory\"]:\n            if action == \"H\":\n                if player[\"health\"]< 3: player[\"health\"] = 3\n                else: return None\n            elif action == \"K\":\n                nextTilePos = (player[\"y\"] + player[\"direction\"][1], player[\"x\"] + player[\"direction\"][0])\n                if(nextTilePos[1] < 0 or nextTilePos[0] < 0 or\n                   nextTilePos[0] >= len(field) or nextTilePos[1] >= len(field[nextTilePos[0]])): return None\n                nextTile = field[nextTilePos[0]][nextTilePos[1]]\n                if(nextTile == \"-\" or nextTile == \"|\"): field[nextTilePos[0]][nextTilePos[1]] = \" \"\n                else: return None\n            else:\n                nextTilePos = (player[\"y\"] + player[\"direction\"][1], player[\"x\"] + player[\"direction\"][0])\n                if(nextTilePos[1] < 0 or nextTilePos[0] < 0 or\n                   nextTilePos[0] >= len(field) or nextTilePos[1] >= len(field[nextTilePos[0]])): return None\n                if field[nextTilePos[0]][nextTilePos[1]] == \"M\":\n                    player[\"coinsCounter\"] += 1\n                    if player[\"coinsCounter\"] >= 3:\n                        field[nextTilePos[0]][nextTilePos[1]] = \" \"\n                else: return None\n            player[\"inventory\"].remove(action)\n        \n        elif action == \"A\":\n            nextTilePos = (player[\"y\"] + player[\"direction\"][1], player[\"x\"] + player[\"direction\"][0])\n            nextTile = field[nextTilePos[0]][nextTilePos[1]]\n            if nextTile == \"E\":\n                field[nextTilePos[0]][nextTilePos[1]] = \" \"\n                player[\"levelCounter\"] += 1\n                if player[\"levelCounter\"] >= 3:\n                    player[\"levelCounter\"] = 0\n                    player[\"attack\"] += 1\n            elif nextTile == \"D\":\n                demonLord -= player[\"attack\"]\n                if demonLord <= 0:\n                    field[nextTilePos[0]][nextTilePos[1]] = \" \"\n            else: return None\n        \n        else: return None\n        \n        if action == \"A\" or action == \"H\" or action in playerDirections:\n            for dir in playerDirections.values():\n                adjacent = \"\"\n                try:\n                    positions = (max(0, player[\"y\"] + dir[1]), max(0, player[\"x\"] + dir[0]))\n                    adjacent = field[positions[0]][positions[1]]\n                except:\n                    adjacent = \"X\"\n                if adjacent == \"E\" or adjacent == \"D\":\n                    player[\"health\"] -= max(0, (2 if adjacent == \"E\" else 3) - player[\"defense\"])\n        \n        if player[\"health\"] <= 0: return None\n    \n    field[player[\"y\"]][player[\"x\"]] = player[\"char\"]\n    return (field, player[\"health\"], player[\"attack\"], player[\"defense\"], sorted(player[\"inventory\"]))"]