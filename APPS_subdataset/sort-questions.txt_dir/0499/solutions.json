["class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        prev = -1\n        ans = 0\n        for num in target:\n            if prev == -1:\n                prev = num\n                ans += num\n                continue\n            if num > prev:\n                ans += (num - prev)\n            #print(ans, num, prev)\n            prev = num\n        return ans", "'''\nKeeping track of reusable operations\n\nIdea:\n\nStart with first position a[0]. We know that it will take overall a[0] operations to reach a[0] from 0.\n\nNow, 2 things can happen from here:\n\nWe encounter a number less than a[0] (a[1] < a[0]): In this case we can simply reuse the same operations that we did for a[0]. i.e If array was (3, 2), we can first perform 3 operations and then use 2 of the same operations in next term. However, going forward, we will only have a[1] operations available for reuse.\n\nWe encounter a number greater than a[0] (a[1] > a[0]): In this case we can simply reuse the same operations that we did for a[0]. And additionally, we will perform a[1] - a[0] more operation to reach a[1]. Again, going forward, we will have a[1] operations available for reuse.\n\nTC: O(n)\nSC: O(1)\n'''\nclass Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        tLen = len(target)\n        steps = target[0]\n        reusableOperations = target[0]\n        \n        for i in range(1, tLen):\n            if target[i] <= reusableOperations: # Case 1\n                reusableOperations = target[i]\n            else: # Case 2\n                steps += target[i] - reusableOperations\n                reusableOperations = target[i]\n        \n        return steps\n                \n        \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans=target[0]\n        for i in range(1,len(target)):\n            if target[i-1]<target[i]:\n                ans+=target[i]-target[i-1]\n        return ans\n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans = prev = 0\n        for i in target:\n            ans += max(0,i - prev)\n            prev = i\n        return ans", "class Solution:\n    def minNumberOperations(self, A: List[int]) -> int:\n        res = pre = 0\n        for a in A:\n            res += max(0,a - pre)\n            pre = a\n        return res", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        pre = 0\n        res = 0\n        for a in target:\n            res += max(a-pre, 0)\n            pre = a \n        return res", "'''\n            [1,2,3,2,1]\n\ndiff array: [1,1,1,-1,-1]\n\npresum: [1,3,6,8,9]\n\n\u5dee\u5206\u6570\u7ec4\uff1aa[i] - a[i-1]\n\n\n\u5bf9\u6570\u7ec4A[i:j]\u533a\u95f4\u6bcf\u4e2a\u6570\u90fd\u52a0k -> diff[i] + k,   diff[j] - k \uff08j\u4e4b\u540e\u7684\u6570\u5e76\u4e0d\u60f3+k, \u6240\u4ee5\u8981\u51cf\u56de\u53bb\uff09  -> \u8fd9\u6837\u5c31\u80fd\u8fd8\u539f\u51fa\u4e00\u4e2a\u7b26\u5408\u8981\u6c42\u7684\u6570\u7ec4\u4e86\n\u5bf9[1,2,3,2,1] \u533a\u95f4[1:4] \u6bcf\u4e2a\u5143\u7d20\u90fd+1 \uff1a \ndiff [1,2,1,-1,-2]\n\u8fd8\u539f\u6570\u7ec4 [1,3,4,3,1]\n\n\ntarget = [1,2,3,2,1] -> \u6c42diff -> [1,1,1,-1,-1]\n\n\u82e5\u6b64\u9898\u8f6c\u5316\u4e3a\u6c42diff\u6570\u7ec4\n[0,0,0,0,0] -> [1,1,1,-1,-1]\n\n\u56e0\u4e3a\u6bcf\u6b21\u5728\u4e00\u4e2a\u533a\u95f4\u8fde\u7eed+1 \u76f8\u5f53\u4e8e\u5728\u8fd9\u4e2a\u533a\u95f4\u7684\u7b2c\u4e00\u4e2adiff\u5143\u7d20\u52a0\u4e00\uff0c\u7ed3\u5c3e\u540e\u9762\u4e00\u4e2adiff\u5143\u7d20-1\uff0c\u6b64\u9898\u4e2d-1\u53ef\u9009 \u56e0\u4e3a\u6211\u4eec\u6700\u591a\u53ef\u4ee5\u628a\u8fd9\u4e2a\u533a\u95f4\u6269\u5927\u5230n\uff0c \u6240\u4ee5 \u6c42diff\u91cc\u9762positive\u6570\u7684\u548c \u5c31\u662f\u7b54\u6848\n\n\n\n'''\n\nclass Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        diff = [0] * len(target)\n        diff[0] = target[0]\n        for i, num in enumerate(target[1:], 1):\n            diff[i] = target[i] - target[i-1]\n            \n        opr = 0\n        for d in diff:\n            if d > 0:\n                opr += d\n        return opr\n            \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        # target[0] + sum([max(0, curr - pre) for pre, curr in zip(target, target[1:])])\n        # if len(target) == 1: return target[0]\n        ans = 0\n        for i in range(1, len(target)):\n            pre, curr = target[i-1], target[i]\n            ans += max(curr-pre, 0)\n        return ans + target[0]", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans=1\n        target=target+[1]\n        pre=1\n        _max=1\n        _min=10**9\n        for i in range(len(target)-1):\n            cur=target[i]\n            if cur==1:continue\n            nex=target[i+1]\n            if cur<=nex:\n                 if nex>_max:_max=nex\n            else:\n                if nex<_min:_min=nex\n                if cur>_max:_max=cur\n                ans+=min(_max-pre,_max-1)\n                pre=_min\n                _min=10**9\n                _max=nex\n        return ans        \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        res = 0\n        \n        for i in range(len(target)):\n            if i == 0:\n                res = target[0]\n                continue\n                \n            d = target[i]-target[i-1]\n            \n            if d > 0:\n                res += d\n                \n        return res", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        return target[0] + sum([max(0, curr - pre) for pre, curr in zip(target, target[1:])])", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        return sum([max(b - a, 0) for a, b in zip([0] + target, target)])", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        return target[0] + sum(max(0,a-b) for a, b in zip(target[1:], target))", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        stack = [0]\n        res = 0\n        for num in target:\n            if num > stack[-1]:\n                res += num-stack[-1]\n            elif num<stack[-1]:\n                while stack[-1]>num:\n                    stack.pop()\n            stack.append(num)\n        return res\n            \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        tot = 0\n        l = 0\n        for t in target:\n            if t > l:\n                tot += t - l\n                l = t\n            elif t < l:\n                l = t\n        return tot", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        prev, ans = None, 0\n        for t in target:\n            if prev is not None:\n                if t >= prev:\n                    ans += (t-prev)\n            else: \n                ans += t\n            prev = t\n        return ans", "'''\nUsing minimum and maximum value tracking\n'''\nclass Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        tLen = len(target)\n        maxValInd = [target[0], 0]\n        minValInd = [target[0], 0]\n        steps = target[0]\n        \n        for i in range(1,tLen):\n            if target[i] >= maxValInd[0]:\n                if not (maxValInd[1] <= minValInd[1] <= i-1):\n                    steps += target[i] - maxValInd[0]\n                    maxValInd = [target[i], i]\n                    if target[i] <= minValInd[0]:\n                        minValInd = [target[i], i]\n                    \n                else:\n                    steps += target[i] - minValInd[0]\n                    maxValInd = [target[i], i]\n                    minValInd = [target[i], i]\n            \n            else:\n                maxValInd = [target[i], i]\n                if target[i] <= minValInd[0]:\n                    minValInd = [target[i], i]\n        \n        return steps", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        n = len(target)\n        if (n == 1):\n            return target[0]\n        else:\n            ans = target[0]\n            for i in range(1,n):\n                ans += max(0,target[i] - target[i-1])\n            return ans", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans=1\n        target=[1]+target+[1]\n        pre=1\n        _max=1\n        _min=10**9\n        for i in range(len(target)-1):\n            cur=target[i]\n            if cur==1:continue\n            nex=target[i+1]\n            if cur<=nex:\n                 if nex>_max:_max=nex\n            else:\n                if nex<_min:_min=nex\n                if cur>_max:_max=cur\n                ans+=min(_max-pre,_max-1)\n                pre=_min\n                _min=10**9\n                _max=nex\n        return ans        \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        num_increments = 0\n        prev = 0\n        for t in target:\n            if t > prev:\n                num_increments += t - prev\n            prev = t\n        return num_increments", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        l = len(target)\n        if l == 1:\n            return target[0]\n        ans = target[0]\n        for i in range(1,l):\n            if target[i] > target[i-1]:\n                ans += (target[i] - target[i-1])\n        return ans", "\nclass Solution:\n  def minNumberOperations(self, target: List[int]) -> int:\n\n    result = 0\n    for index, value in enumerate(target):\n      if index == 0:\n        result = value\n      elif value > target[index - 1]:\n        result += value - target[index-1]\n      pass\n    return result\n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans = target[0]\n        d = 0\n        base = target[0]\n        for i in range(1,len(target)):\n            if target[i] == target[i-1]:\n                continue\n            elif target[i] < target[i-1]:\n                if d == 0:\n                    d = -1\n                if d == 1:\n                    d = -1\n                    ans += (target[i-1] - base)\n            elif target[i] > target[i-1]:\n                if d == 0:\n                    d = 1\n                if d == -1:\n                    d = 1\n                    base = target[i-1]\n        if d == 1:\n            ans += (target[-1] - base)\n        return ans\n            \n                \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans=1\n        x=0\n        target=[1]+target+[1]\n        n=len(target)\n        pre=1\n        while x<n-1:\n            while x<n and  target[x]==1:x+=1\n            if x==n:break\n            while x<n-1 and target[x]<=target[x+1]:x+=1\n            _max=target[x]\n##            print('pre',pre)\n            while x<n-1 and target[x]>=target[x+1]:x+=1\n            _min=target[x]\n            pre=_min\n##            print(_max,_min)\n            ans+=min(_max-pre,_max-1)\n        return ans\n", "class Solution:\n    def minNumberOperations(self, A: List[int]) -> int:\n        res = pre = 0\n        for a in A:\n            res += max(a - pre, 0)\n            pre = a\n        return res", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        res = pre = 0\n        for a in target:\n            res += max(a - pre, 0)\n            pre = a\n        return res", "class Solution:\n    def minNumberOperations(self, t: List[int]) -> int:\n        cnt=t[0]\n        for i in range(1,len(t)):\n            if t[i]>t[i-1]:\n                cnt+=t[i]-t[i-1]\n        return cnt\n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans, prev = 0, 0\n        for n in target:\n            ans += max(0, n-prev)\n            prev = n\n        return ans\n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        res = 0\n        res += target[0] - 1\n        for i in range(1, len(target)):\n            if target[i] <= target[i - 1]:\n                continue\n            else:\n                res += target[i] - target[i - 1]\n        return res + 1", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        prev = 0\n        total = 0\n        for num in target:\n            if num > prev:\n                total += num-prev\n            prev = num\n        return total\n                \n            \n        \n            \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        prev = 0\n        step = 0\n        for i in range(len(target)):\n            step += max(0, target[i] - prev)\n            prev = target[i]\n        return step", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans=1\n        x=0\n        target=target+[1]\n        n=len(target)\n        pre=1\n        while x<n-1:\n            while x<n and  target[x]==1:x+=1\n            if x==n:break\n            while x<n-1 and target[x]<=target[x+1]:x+=1\n            _max=target[x]\n##            print('pre',pre)\n            while x<n-1 and target[x]>=target[x+1]:x+=1\n            _min=target[x]\n            pre=_min\n##            print(_max,_min)\n            ans+=min(_max-pre,_max-1)\n        return ans\n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        count = target[0]\n        for a, b in zip(target, target[1:]):\n            count += max(0, b - a)\n        return count", "class Solution:\n  def minNumberOperations(self, target: List[int]) -> int:\n    # TC: O(N), SC: O(1), stack\n    #  keep a stack of increasing nums, settle whenever see a decrease\n    stack, count = [], 0\n    for x in target:\n      m = 0\n      while stack and stack[-1] >= x:\n        m = max(m, stack.pop() - x)\n      count += m\n      stack.append(x)\n    count += stack[-1]\n    return count", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        if not target: return 0\n        ret = target[0]\n        for a,b in zip(target[:-1], target[1:]):\n            ret += max(0, b-a)\n        return ret\n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans = target[0]\n        for i in range(1, len(target)):\n            ans += max(0, target[i]-target[i-1])\n        return ans", "\nclass Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        if not target:\n            return 0\n        \n        totalCost = target[0]\n\n        for index in range(1, len(target)):\n            num = target[index]\n            prev = target[index-1]\n            \n            diff = num - prev\n            totalCost += max(diff, 0)\n\n        return totalCost\n            \n        \n        lst = []\n            \n        lst.append(target)\n        \n        prev_layer = target\n        new_layer = []\n        \n        while len(prev_layer)>1:\n        \n            \n            counter = 0\n            while counter<len(prev_layer):\n\n                fi = prev_layer[counter]\n\n                se = fi            \n                if counter+1 < len(prev_layer):\n                    se = prev_layer[counter+1]\n                new_layer.append(min(fi, se))\n\n                counter += 2\n                        \n            # print('prev_layer', prev_layer)\n            \n            lst.append(new_layer)\n            prev_layer = new_layer\n            new_layer = []\n        \n        lst.append([0])\n        cost = 0\n        \n        print(lst)\n        for index in range(len(lst)-2, -1, -1):\n            l = lst[index]\n            print(('l', l))\n            \n            for in_index in range(len(l)):\n                val = l[in_index]\n                parent_index = int(in_index / 2)\n                cost += (val - lst[index+1][parent_index])\n                \n                print(('val', val))\n                print(('parent_val',lst[index+1][parent_index]))\n                print(('cost', cost))\n                print('--------')\n                \n        return cost\n                \n        \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        res = pre = 0\n        \n        for n in target:\n            res += max(n - pre, 0)\n            pre = n\n        return res", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans=1\n        target=[1]+target+[1]\n        pre=1\n        _max=1\n        _min=10**9\n        for i in range(len(target)-1):\n            if target[i]==1:continue\n            if target[i]<=target[i+1]:\n                 _max=max(_max,target[i+1])\n            else:\n                _min=min(_min,target[i+1])\n                _max=max(_max,target[i])\n                ans+=min(_max-pre,_max-1)\n                pre=_min\n                _min=10**9\n                _max=target[i+1]\n        return ans    \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        count, stack = 0, [0]\n        for height in target:\n            if stack[-1] > height:\n                while stack[-1] > height:\n                    stack.pop()\n            else:\n                count += height - stack[-1]\n            stack.append(height)\n        \n        return count", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n            \n                res = pre = 0\n                for a in target:\n                    res += max(a - pre, 0)\n                    pre = a\n                return res", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        A = target\n        res = pre = 0\n        for a in A:\n            res += max(a - pre, 0)\n            pre = a\n        return res", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ret = 0\n        old = 0\n        for e in target:\n            if e > old:\n                ret += e - old\n            old = e\n        return ret", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        stack = []\n        ans = 0\n        for n in target:\n            if len(stack) != 0 and n <= stack[-1]:\n                ans += (stack[-1] - n)\n                while len(stack) != 0 and n <= stack[-1]:\n                    x = stack.pop()\n            stack.append(n)\n        \n        if len(stack) != 0:\n            ans += stack[-1]\n        return ans", "class Solution:\n    def minNumberOperations(self, A: List[int]) -> int:\n        res = pre = 0\n        for a in A:\n            res += max(a - pre, 0)\n            pre = a\n        return res\n", "class Solution1:\n    # brute force\n    def minNumberOperations(self, target: List[int]) -> int:\n        max_bar, blocks = max(target), 0\n        for bar in range(1, max_bar + 1):\n            op = [ 0 ] * len(target)\n            prev_op = 0\n            for i, t in enumerate(target):\n                if t >= bar:\n                    op[i] = 1\n                if prev_op != op[i]:\n                    prev_op = op[i]\n                    if op[i] == 1:\n                        blocks += 1     \n        return blocks\n    \nclass Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        prev_t, n, valley = 0, len(target), 0\n        blocks = 0\n        for i in range(n):\n            if i + 1 < n and target [i + 1] == target[i]:\n                continue\n            if prev_t < target[i] and (i + 1 == n or target[i] > target[i + 1]):\n                blocks += target[i] - valley\n            if target[i] <  prev_t and (i + 1 == n or target[i] <= target[i+1]):\n                valley = target[i]\n            prev_t = target[i]     \n        return blocks\n            \n            \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        l = target\n        stack = []\n        total = 0\n        for i in range(len(l)):\n            if stack and l[stack[-1]] > l[i]:\n                total += l[stack[-1]] - l[i]\n                while stack and l[stack[-1]] > l[i]:\n                    stack.pop()\n\n            if not stack or l[stack[-1]] < l[i]:\n                stack.append(i)\n\n            # print(stack, total)\n        if stack:\n            total += l[stack[-1]]\n            \n        return total", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        stack = []\n        count = 0\n        target.append(0)\n        for num in target:\n            while stack and stack[-1] >= num:\n                if len(stack) > 1:\n                    count += stack[-1] - max(num, stack[-2])\n                    stack.pop()\n                else:\n                    count += stack.pop() - num\n            stack.append(num)\n        return count", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans = 0\n        stack = [0]\n        for num in target:\n            max_ = 0\n            while(stack and stack[-1] >= num ):\n                max_ = max(max_, abs(stack.pop() - num))\n            ans += max_\n            stack.append(num)\n        while(stack[-1]):\n            ans += abs(stack.pop() - stack[-1])\n        return ans", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        res = target[0]\n        for i in range(1, len(target)):\n            if target[i] > target[i - 1]:\n                res += target[i] - target[i - 1]\n        \n        return res", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        bottleneck = 0\n        ans = 0\n        \n        for num in target:\n            if num > bottleneck:\n                ans += (num-bottleneck)\n                bottleneck = num\n            else:\n                bottleneck = num\n        return ans", "class Solution:\n    #Version 1: DFS with memoization\n    #Brute force\n    #TC: O(n^3), SC: O(n^2)\n    '''\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        def get(num, dp):\n            if not num:\n                return 0\n            numt = tuple(num)\n            if numt not in dp:\n                val = min(num)\n                left = 0\n                result = val\n                for k in range(len(num)):\n                    num[k] -= val\n                    if num[k] == 0:\n                        if left < k:\n                            result += get(num[left:k], dp)\n                        left = k + 1\n                if left < len(num):\n                    result += get(num[left:], dp)\n                dp[numt] = result\n            return dp[numt]\n        \n        dp = {}\n        return get(target, dp)\n    '''\n    \n    #Version 2: Use stack to check the increment status\n    #If the number is smaller than the top of the stack, it means some increments used on the top of the stack will not be used for the new number.\n    #Therefore, we can pop the stack.\n    #TC: O(n), SC: O(n)\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans = 0\n        stack = [0]\n        for k in target:\n            while len(stack) >= 1 and stack[-1] >= k:\n                ans += (stack[-1]-max(k, stack[-2]))\n                stack.pop()\n            stack.append(k)\n        #print(stack)\n        return ans + stack[-1]\n    \n    '''\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans = 0\n        current = 0\n        for k in target:\n            if k > current:\n                ans += (k-current)\n            current = k\n        return ans\n    '''            ", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ret = target[0]\n        for i in range(1, len(target)):\n            ret += max(0, target[i] - target[i-1])\n        return ret", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        result = 0\n        if not target : return result\n        result = target[0]\n        for i in range(1, len(target)):\n            if target[i] > target[i-1]:\n                result += target[i] - target[i-1]\n        return result\n                \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        target.append(0)\n        \n        stack = [0]\n        res = 0\n        for t in target:\n            if t < stack[-1]:\n                res += stack.pop() - t\n                while stack[-1] > t:\n                    stack.pop()\n            if t > stack[-1]:\n                stack.append(t)\n        return res\n", "class Solution:\n    def minNumberOperations(self, A: List[int]) -> int:\n        res = pre = 0\n        for a in A:\n            res += max(a - pre,0)\n            pre = a\n        return res", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        count = target[0]\n        avop = target[0]\n        \n        for i in range(1, len(target)):\n            \n            if avop < target[i]:\n                count += target[i] - avop\n\n            avop = target[i]\n        \n        return count", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        result = 0\n        last = 0\n        for i in range(len(target)):\n            if target[i] >= last:\n                result += target[i] - last\n            last = target[i]\n        return result\n            \n", "import heapq\n\nclass Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        target.append(0)\n        stack = [(0, -1)]\n        ans = 0\n        for i, x in enumerate(target):\n            if stack[-1][0] < x:\n                stack.append((x, i))\n            elif stack[-1][0] == x:\n                stack[-1] = (stack[-1][0], i)\n            else:\n                while len(stack) >= 2 and stack[-1][0] >= x:\n                    tmp = stack.pop()\n                    ans += tmp[0] - max(x, stack[-1][0])\n                    if stack[-1][0] > x:\n                        stack[-1] = (stack[-1][0], tmp[1])\n                stack.append((x, i))\n                \n        return ans\n                    \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        res = 0\n        cur = 0\n        for i in range(len(target)):\n            if target[i] > cur:\n                res += target[i] - cur\n            cur = target[i]\n        return res\n        \n        \n        \n        \n        \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ans=target[0]\n        # max_used=target[0]\n        for i in range(1,len(target)):\n            \n            if target[i-1]>target[i]:\n                pass\n                # ans+=       \n                # max_used=target[i]\n                \n            else:\n                ans+=target[i]-target[i-1]\n        return ans\n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        count = target[0]\n        height = target[0]\n        for val in target[1:]:\n            if val > height:\n                count += val - height\n            height = val\n        return count", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        ret = 0\n        carry = 0\n        for i in range(len(target)):\n            e = target[i]\n            ret += max(0, e - carry)\n            carry = e\n        return ret", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        \n        res = 0\n        prev = 0\n        for t in target:\n            res += max(t-prev, 0)\n            prev = t\n        \n        return res", "class Solution:\n    def minNumberOperations(self, A):\n        res = pre = 0\n        for a in A:\n            res += max(a - pre, 0)\n            pre = a\n        return res", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        r = target[0]\n        carry = target[0]\n        \n        for i in range(1, len(target)):\n            if target[i] > carry:\n                r += target[i]-carry\n                carry = target[i]\n            else:\n                carry = target[i]\n                \n        return r\n            \n        \n        \n        \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        \n        r = carry = 0\n        \n        for h in target:\n            if h > carry:\n                r += h-carry\n            carry = h\n                \n        return r\n            \n        \n        \n        \n", "class Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        total = 0\n        prev = 0\n        for num in target:\n            total += max(0, num - prev)\n            prev = num\n        return total"]