["'''\n\\\"aabcaca\\\"\n 0123456\n  x\n \ndevide conquer\n\u5148\u627e\u5230\u7b2c\u4e00\u4e2astamp\u628astring\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff08\u5fc5\u987b\u8981\uff09\uff08On\n\u7136\u540e\u4ece\u957f\u5230\u77ed\u7528stamp\u7684\u5934match\u5de6\u8fb9\u7684\u90e8\u5206\uff0c\u76f4\u5230match\u5230\u6700\u5934 \u5982\u679c\u4e0d\u80fd\u5230\u6700\u5934\u5219\u9000\u51fa\n\u4ece\u957f\u5230\u77ed\u7528stamp\u7684\u5c3e\u5df4match\u53f3\u8fb9\uff0c\u76f4\u5230match\u5230\u5c3e\u5df4\uff0c\u5982\u679c\u4e0d\u80fdmatch\u5230\u6700\u5c3e\u5df4 \u5219 \u7ee7\u7eed\u627e\u4e0b\u4e00\u4e2astamp\n\u80fd\u628a\u4ed6\u5206\u6210\u5de6\u53f3\n\u8fd9\u65f6\u7684\u5de6\u8fb9\u6709\u4e2aoffset\u4e86\uff0c\u6bd4\u5982****b** offset\u662f3\uff0c\u53ea\u8981stamp\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7\u5934\u4e14\u80fdmatch\u4e0a\uff0c\u5c31\u53ef\u4ee5\n\n\u8fd9\u4e2a\u89e3\u6cd5\u53ef\u4ee5\u6709nwin*M^2 \u5176\u4e2dm\u5e73\u65b9\u662f\u5728\u7528stamp\u53bbmatch\u7684\u65f6\u5019\u6700\u574f\u80fd\u4ecestamp\u6700\u957fmatch\u52301\n\u53ef\u4ee5\u7ed9\u51fa\u6700\u77edmatch\u8def\u5f84\n\n\n'''\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        ans = []\n        offset = 0\n        while target!='':\n            x = target.find(stamp)\n            if x==-1:\n                return []\n            ans.append(x+offset)\n            \n            can_stamp,indices = self.moveLeft(stamp,target[:x],offset)\n            if not can_stamp:\n                return []\n            ans.extend(indices)\n            \n            offset,target,indices = self.moveRight(stamp,target[x+len(stamp):],\n                                                offset+x+len(stamp))\n            ans.extend(indices)\n            \n        return ans[::-1]\n        \n        \n    \n    def moveLeft(self,stamp,s,offset):\n        ans = []\n        while s:\n            for ind in range(1,len(stamp)):\n                additional = 0\n                if ind>len(s):\n                    if offset == 0:\n                        continue\n                        \n                    additional = ind - len(s)\n                    \n                if stamp[additional:ind]==s[-ind:]:\n                    ans.append(offset+len(s)-ind)\n                    s=s[:-ind]\n                    break\n            else:\n                return False,[]\n        return True,ans\n        \n    \n    def moveRight(self,stamp,s,offset):\n        ans = []\n        while s:\n            for ind in range(1,len(stamp)):\n                if stamp[-ind:]==s[:ind]:\n                    ans.append(offset+ind-len(stamp))\n                    offset+=ind\n                    s=s[ind:]\n                    break\n            else:\n                return offset,s,ans\n        return offset,s,ans\n", "'''\n\\\"aabcaca\\\"\n 0123456\n  x\n \ndevide conquer\n\u5148\u627e\u5230\u7b2c\u4e00\u4e2astamp\u628astring\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff08\u5fc5\u987b\u8981\uff09\uff08On\n\u7136\u540e\u4ece\u957f\u5230\u77ed\u7528stamp\u7684\u5934match\u5de6\u8fb9\u7684\u90e8\u5206\uff0c\u76f4\u5230match\u5230\u6700\u5934 \u5982\u679c\u4e0d\u80fd\u5230\u6700\u5934\u5219\u9000\u51fa\n\u4ece\u957f\u5230\u77ed\u7528stamp\u7684\u5c3e\u5df4match\u53f3\u8fb9\uff0c\u76f4\u5230match\u5230\u5c3e\u5df4\uff0c\u5982\u679c\u4e0d\u80fdmatch\u5230\u6700\u5c3e\u5df4 \u5219 \u7ee7\u7eed\u627e\u4e0b\u4e00\u4e2astamp\n\u80fd\u628a\u4ed6\u5206\u6210\u5de6\u53f3\n\u8fd9\u65f6\u7684\u5de6\u8fb9\u6709\u4e2aoffset\u4e86\uff0c\u6bd4\u5982****b** offset\u662f3\uff0c\u53ea\u8981stamp\u7684\u957f\u5ea6\n\n\u8fd9\u4e2a\u89e3\u6cd5\u53ef\u4ee5\u6709nwin*M^2 \u5176\u4e2dm\u5e73\u65b9\u662f\u5728\u7528stamp\u53bbmatch\u7684\u65f6\u5019\u6700\u574f\u80fd\u4ecestamp\u6700\u957fmatch\u52301\n\u53ef\u4ee5\u7ed9\u51fa\u6700\u77edmatch\u8def\u5f84\n\n\n'''\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        ans = []\n        offset = 0\n        while target!='':\n            x = target.find(stamp)\n            if x==-1:\n                return []\n            ans.append(x+offset)\n            \n            can_stamp,indices = self.moveLeft(stamp,target[:x],offset)\n            if not can_stamp:\n                return []\n            ans.extend(indices)\n            \n            offset,target,indices = self.moveRight(stamp,target[x+len(stamp):],\n                                                offset+x+len(stamp))\n            ans.extend(indices)\n            \n        return ans[::-1]\n        \n        \n    \n    def moveLeft(self,stamp,s,offset):\n        ans = []\n        while s:\n            for ind in range(1,len(stamp)):\n                additional = 0\n                if ind>len(s):\n                    if offset == 0:\n                        continue\n                        \n                    additional = ind - len(s)\n                    \n                if stamp[additional:ind]==s[-ind:]:\n                    ans.append(offset+len(s)-ind)\n                    s=s[:-ind]\n                    break\n            else:\n                return False,[]\n        return True,ans\n        \n    \n    def moveRight(self,stamp,s,offset):\n        ans = []\n        while s:\n            for ind in range(1,len(stamp)):\n                if stamp[-ind:]==s[:ind]:\n                    ans.append(offset+ind-len(stamp))\n                    offset+=ind\n                    s=s[ind:]\n                    break\n            else:\n                return offset,s,ans\n        return offset,s,ans\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        stamp = list(stamp)\n        target = list(target)\n        result = []\n        \n        def change(i):\n            if target[i:i + m].count('?') == m:\n                return False\n            ch = False\n            for j in range(m):\n                if target[i + j] == '?':\n                    continue\n                if target[i + j] != stamp[j]:\n                    ch = False\n                    break\n                ch = True\n            if ch:\n                target[i:i + m] = ['?'] * m\n                result.append(i)\n            return ch\n        ch = True\n        while ch:\n            ch = False\n            for i in range(n - m + 1):\n                ch |= change(i)\n            \n        return reversed(result) if target.count('?') == n else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        done = set()\n        n = len(stamp)\n        m = len(target)\n        res = []\n        \n        def check(i):\n            j = 0\n            count = 0\n            while j < n :\n                if i in done:\n                    j += 1\n                    i += 1\n                elif stamp[j] == target[i]:\n                    count += 1\n                    i += 1\n                    j += 1\n                else:\n                    return False\n            return count > 0\n        \n        while len(done) < m :\n            found = 0\n            for i in range(m-n+1):\n                if check(i):\n                    for j in range(i,i+n):\n                        done.add(j)\n                    res.append(i)\n                    found = 1\n                    break\n            if not found:\n                return []\n                    \n        \n        \n        \n        \n        return res[::-1]\n                \n            \n        \n        \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        #if not sol return []\n        \n        #start from target and trace back, use dfs each time change slice in stamp to ??? or ??X\n        \n        list_s, list_t = list(stamp), list(target)  #convert to list coz str immutable\n        res = []\n        \n        #changed means if this round can remove stamp\n        changed = True\n        while changed:\n            #\u8bb0\u4f4f\u5148\u8d4b\u503cfalse\uff01\uff01\uff01\n            changed = False\n            #check each slice of target if can remove stamp!\n            for i in range(len(list_t) - len(list_s) + 1):\n                changed = changed or self.remove_stamp(list_s, list_t, i, res)\n\n        return res[::-1] if list_t == ['?'] * len(list_t) else []\n    \n    \n    def remove_stamp(self, list_s, list_t, i, res):\n        #check if target can remove stamp from ind of i; if ? can also remove!!!!!!!(abc??-->ababc \u53cd\u8fc7\u6765 ababc-->ab??? then ab? can still un-stamp!!!!)\n        changed = False\n    \n        for j in range(len(list_s)):\n            if list_t[i + j] == '?': \n                continue\n            if list_t[i + j] != list_s[j]: \n                return False\n            changed = True\n        \n        #also need convert target back!\n        if changed:\n            list_t[i:i + len(list_s)] = ['?'] * len(list_s)     #\u6570\u7ec4\u53ef\u4ee5\u76f4\u63a5\u6574\u4f53\u8d4b\u503c\uff01\uff01\uff01\n            \n            res.append(i)\n            \n        return changed", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n\n        def canStamp(targetStr, idx, stamp):\n            hasOneChar = False\n            for i in range(len(stamp)):\n                if targetStr[idx+i] == \\\"?\\\":\n                    continue\n                \n                if targetStr[idx+i] == stamp[i]:\n                    hasOneChar = True\n                    continue\n                else:\n                    return False\n            if hasOneChar:\n                return True\n            else:\n                return False\n            \n        \n        queue = [(target, [])]\n        \n        while queue:\n            curtStr, steps = queue.pop(0)\n            if len(steps) >= len(target) * 10:\n                continue\n            if all(x == \\\"?\\\" for x in list(curtStr)):\n                return steps[::-1]\n            for i in range(len(curtStr) - len(stamp) + 1):\n                if canStamp(curtStr, i, stamp):\n                    queue.append((curtStr[:i] + \\\"?\\\" * len(stamp) + curtStr[i+len(stamp):], steps + [i]))\n                    break\n            \n            ", "from collections import deque\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        #if not sol return []\n        \n        #start from target and trace back, use dfs each time change slice in stamp to ??? or ??X\n        \n        list_s, list_t = list(stamp), list(target)\n        res = []\n\n        changed = True\n        while changed:\n            changed = False\n            for i in range(len(list_t) - len(list_s) + 1):\n                changed = changed or self.remove_stamp(list_s, list_t, i, res)\n\n        return res[::-1] if list_t == ['?'] * len(list_t) else []\n    \n    \n    def remove_stamp(self, list_s, list_t, i, res):\n        changed = False\n    \n        for j in range(len(list_s)):\n            if list_t[i + j] == '?': \n                continue\n            if list_t[i + j] != list_s[j]: \n                return False\n            changed = True\n            \n        if changed:\n            list_t[i:i + len(list_s)] = ['?'] * len(list_s)\n            \n            res.append(i)\n            \n        return changed", "# ababcbc\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        s, t = list(stamp), list(target)\n        ans = []\n        \n        def check(idx):\n            changed = False\n            for i in range(m):\n                if t[idx + i] == \\\"?\\\": continue\n                if t[idx + i] != s[i]: return False\n                changed = True\n            if changed:\n                t[idx: idx + m] = [\\\"?\\\"] * m\n                ans.append(idx)\n            return changed\n            \n        changed = True\n        while changed:\n            changed = False\n            for i in range(n - m + 1):\n                if check(i):\n                    changed = True\n                    break\n        return ans[::-1] if t == [\\\"?\\\"] * n else []\n                ", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        # This is Greedy sol from https://leetcode.com/problems/stamping-the-sequence/discuss/189254/Python-Greedy-and-DFS\n        # reversely change target to **********\n        # the method is once find a substring in target that equals stamp, change them to *\n        # when seeing a * just continue\n        # continue doing this until no matching can be found\n        \n        def check(i):\n            found = False\n            for j in range(len(s)):\n                if t[i+j] == '*':\n                    continue\n                if t[i+j] != s[j]: # substring t[i:i+m] != s\n                    return False\n                found = True\n            if found:\n                t[i:i+len(s)] = ['*'] * len(s)\n                res.append(i)\n            return found\n        \n        n, m, t, s, res = len(target), len(stamp), list(target), list(stamp), []\n        while True:\n            found = False\n            for i in range(n-m+1):\n                found = found or check(i)\n            if not found:\n                break\n        return res[::-1] if t == ['*']*n else []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        def one_sweep():\n            nonlocal done, ans\n            for ti in range(len(target) - len(stamp) + 1):\n                matched_cs, matched = [], True\n                for si in range(len(stamp)):\n                    sc, tc = stamp[si], target[ti]\n                    if ti in done:\n                        ti = ti + 1\n                        continue\n                    elif sc == tc:\n                        matched_cs.append(ti)\n                        ti = ti + 1\n                    else:\n                        matched = False\n                        break\n                if matched and matched_cs:\n                    done = done | set(matched_cs)\n                    ans.append(ti - len(stamp))\n                    return True                        \n            return False\n            \n        ans, done = [], set()\n        while one_sweep(): pass\n        return ans[::-1] if len(done) == len(target) else []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        n = len(target)\n        m = len(stamp)\n        seen = [0]*n\n        t = list(target)\n        total = 0\n        def match(ind): # to match pattens in target\n            l = 0\n            size = 0\n            while l <=m-1 and ind+l<=n-1:\n                if t[ind+l] == stamp[l]:\n                    l+=1\n                    size += 1\n                elif t[ind+l]=='*':\n                    l+=1\n                else:\n                    return 0\n            t[ind:ind+l] = ['*']*l\n            return size\n        ans = []\n        while total<n:\n            found = False\n            for i in range(n-m+1):\n                if seen[i]==0:\n                    num = match(i)\n                    if num>0:\n                        found = True\n                        seen[i]=1\n                        total+= num\n                        ans.append(i)\n                        break\n            if found == False:\n                break\n        return ans[::-1] if total==n else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        #if not sol return []\n        \n        #start from target and trace back, use dfs each time change slice in stamp to ??? or ??X\n        \n        list_s, list_t = list(stamp), list(target)  #convert to list coz str immutable\n        res = []\n        \n        #changed means if this round can remove stamp\n        changed = True\n        while changed:\n            #\u8bb0\u4f4f\u5148\u8d4b\u503cfalse\uff01\uff01\uff01\n            changed = False\n            #check each slice of target if can remove stamp!\n            for i in range(len(list_t) - len(list_s) + 1):\n                changed = changed or self.remove_stamp(list_s, list_t, i, res)\n\n        return res[::-1] if list_t == ['?'] * len(list_t) else []\n    \n    \n    def remove_stamp(self, list_s, list_t, i, res):\n        #check if target can remove stamp from ind of i; if ? can also remove!!!!!!!(abc??-->ababc \u53cd\u8fc7\u6765 ababc-->ab??? then ab? can still un-stamp!!!!)\n        #changed = False\n    \n        for j in range(len(list_s)):\n            if list_t[i + j] == '?': \n                continue\n            if list_t[i + j] != list_s[j]: \n                return False\n        \n        #also need convert target back!\n        #first check if target already ??? case then no need change!!!!!!!\n        if list_t[i:i + len(list_s)] != ['?'] * len(list_s):\n            list_t[i:i + len(list_s)] = ['?'] * len(list_s)     #\u6570\u7ec4\u53ef\u4ee5\u76f4\u63a5\u6574\u4f53\u8d4b\u503c\uff01\uff01\uff01\n            \n            res.append(i)\n            return True\n        \n        return False", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        done = set()\n        n = len(stamp)\n        m = len(target)\n        candidates = { i for i in range(m-n+1) }\n        res = []\n        \n        def check(i):\n            j = 0\n            count = 0\n            while j < n :\n                if i in done:\n                    j += 1\n                    i += 1\n                elif stamp[j] == target[i]:\n                    count += 1\n                    i += 1\n                    j += 1\n                else:\n                    return -1\n            if count == 0:\n                return 0\n            else:\n                return 1\n        \n        while len(done) < m :\n            found = 0\n            remove = set()\n            for i in candidates:\n                I = check(i)\n                if I == 1:\n                    for j in range(i,i+n):\n                        done.add(j)\n                    res.append(i)\n                    found = 1\n                    break\n                elif I == 0:\n                    remove.add(i)\n                    \n            if not found:\n                return []\n            else:\n                candidates.remove(i)\n                candidates -= remove\n                \n                    \n        return res[::-1]\n                \n            \n        \n        \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        sLen = len(stamp)\n        tLen = len(target)\n        dp = {}\n        # buttom up DP approach\n\n        def dfs(sidx, tidx, result):\n            \\\"\\\"\\\"\n            1. stamp[sidx] == target[tidx], sidx+=1, tidx+=1\n            2. stamp[sidx] != target[tidx], dp[sidx, tidx] = []\n            3. sidx == sLen, stamp is done, backtrace\n            4. end criteria, tidx == tLen, and sidx == sLen (stamp\u8981\u84cb\u5b8c)\n\n            using sidx, tidx as key for DP\n            \\\"\\\"\\\"\n\n            if tidx == tLen:\n                dp[sidx, tidx] = result if sidx == sLen else []\n\n            if (sidx, tidx) not in dp:\n                if sidx == sLen:\n                    # backtracking\n\n                    for idx in range(sLen):\n                        dp[sidx, tidx] = dfs(idx, tidx, [tidx-idx] + result)\n\n                        if dp[sidx, tidx]:\n                            break\n\n                elif stamp[sidx] == target[tidx]:\n                    nextResult = dfs(sidx+1, tidx+1, result)\n                    dp[sidx, tidx] = nextResult if nextResult else dfs(0, tidx+1, result + [tidx+1])\n\n                else:\n                    dp[sidx, tidx] = []\n\n            return dp[sidx, tidx]\n\n        return dfs(0, 0, [0])\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        if set(stamp) < set(target) or len(stamp) > len(target):\n            return []\n        \n        path = []\n        while target != '*' * len(target):\n            prev_target = target\n            for i in range(len(target) - len(stamp) + 1):\n                if target[i:i + len(stamp)] == '*' * len(stamp):\n                    continue\n                if not all(target[i + j] in (stamp[j], '*') for j in range(len(stamp))):\n                    continue\n                \n                target = target[:i] + '*' * len(stamp) + target[i + len(stamp):]\n                path.append(i)\n            \n            if prev_target == target:\n                return []\n        \n        return path[::-1]   ", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        star = 0\n        visited = [False]*len(target)\n        target = list(target)\n        res = []\n        while star<len(target):\n            doReplace = False\n            for i in range(len(target)-len(stamp)+1):\n                if not visited[i] and self.canReplace(stamp,target,i):\n                    #if target[i:i+len(stamp)]==['*']*len(stamp):\n                    #    visited[i] = True\n                    #    continue\n                    star+=self.doReplace(stamp,target,i)\n                    doReplace = True\n                    visited[i] = True\n                    res.append(i)\n                    if star==len(target):\n                        break\n            if not doReplace:\n                return []\n        return res[::-1]\n    \n    def canReplace(self, stamp:str,target:List[str],i:int) -> bool:\n        for j in range(len(stamp)):\n            if target[i]!='*' and stamp[j]!=target[i]:\n                return False\n            i+=1\n        return True\n    \n    def doReplace(self,stamp:str,target:List[str],i:int) -> int:\n        count = 0\n        for j in range(len(stamp)):\n            if target[i]!='*':\n                target[i] = '*'\n                count+=1\n            i+=1\n        return count", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        t = list(target)\n        res = []\n        \n        def check(i):\n            if t[i:i+m] == ['?']*m:\n                return False\n            \n            for j in range(m):\n                if t[i+j] not in  ['?', stamp[j]]:\n                    return False\n            \n            t[i:i+m] = ['?']*m\n            res.append(i)\n            return True\n        \n        change = True\n        while change:\n            change = False\n            for i in range(n-m+1):\n                change |= check(i)\n            \n        return res[::-1] if t == ['?']*n else []\n                \n            \n                \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        marks, t = 0, list(target)\n        res = []\n        visited = set()\n        while marks < len(target):\n            found = False\n            for i in range(len(t) - len(stamp) + 1):\n                if i not in visited and self.canReplace(stamp, t,i):  \n                    marks += self.replace(stamp,t,i)\n                    res.append(i)  \n                    visited.add(i)  \n                    found = True\n                if marks >= len(target): break\n            if not found: return []\n\n        return res[::-1]\n    \n    def canReplace(self, s,t, j): \n        for i in range(len(s)):    \n            if t[j+i] != \\\"*\\\" and s[i] != t[j+i]:                \n                return False               \n        return True\n    \n    def replace(self, s,t, j):\n        count = 0\n        for i in range(len(s)):\n            if t[i+j] != \\\"*\\\":\n                t[i+j] = \\\"*\\\"\n                count += 1\n        return count\n        ", "class Solution(object):\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        memo = {}\n\n        def dfs(t, s, cur_stmp):\n            if (t, s) in memo:\n                return memo[t, s]\n            if s == len(stamp):\n                if t < len(target):\n                    # check if cur_stmp precedes its following substring\n                    for i, ch in enumerate(stamp):\n                        if ch == target[t]:\n                            suffix_stmp_seq = dfs(t, i, t-i)\n                            if suffix_stmp_seq:\n                                memo[t, s] = suffix_stmp_seq + [cur_stmp]\n                                return suffix_stmp_seq + [cur_stmp]\n                    else:\n                        memo[t, s] = []\n                        return []\n                else:\n                    memo[t, s] = [cur_stmp]\n                    return [cur_stmp]\n            \n            if t == len(target):\n                # target[t] is empty while s < len(stamp), cur_stmp cannot succeeds empty.\n                memo[t,s] = []\n                return []\n\n            if stamp[s] == target[t]:\n                seq1 = dfs(t+1, s+1, cur_stmp)\n                if seq1:\n                    memo[t, s] = seq1\n                    return seq1\n                else:\n                    cand = dfs(t+1, 0, t+1)\n                    memo[t,s] = [cur_stmp] + cand if cand else []\n                    return [cur_stmp] + cand if cand else []\n\n            elif stamp[s] != target[t]:\n                # check if cur_stmp succeeds the substring target[t:]\n                if stamp[0] == target[t]:\n                    suffix_stmp_seq = dfs(t, 0, t) \n                    memo[t, s] = [cur_stmp] + dfs(t, 0, t) if suffix_stmp_seq else []\n                    return [cur_stmp] + dfs(t, 0, t) if suffix_stmp_seq else []\n                else:\n                    memo[t, s] = []\n                    return []\n\n        return dfs(0, 0, 0)", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        marks, t = 0, list(target)\n        res = []\n        visited = set()\n        while marks < len(target):\n            found = False\n            for i in range(len(t) - len(stamp) + 1):\n                if i not in visited and self.canReplace(stamp, t,i):  \n                    marks += self.replace(stamp,t,i)\n                    res.append(i)  \n                    visited.add(i)  \n                    found = True\n                if marks >= len(target): break\n            if not found: return []\n\n        return res[::-1]\n    \n    def canReplace(self, s,t, j): \n        for i in range(len(s)):    \n            if t[j+i] != \\\"*\\\" and s[i] != t[j+i]:                \n                return False               \n        return True\n    \n    def replace(self, s,t, j):\n        count = 0\n        for i in range(len(s)):\n            if t[i+j] != \\\"*\\\":\n                t[i+j] = \\\"*\\\"\n                count += 1\n        return count\n        \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        l = len(stamp)\n        \n        @lru_cache(None)\n        def dfs(i, o):\n            if i == len(target):\n                return []\n            \n            if not o:\n                if i+l > len(target):\n                    return None\n                for k in range(l):\n                    if i+k >= len(target) or stamp[k] != target[i+k]:\n                        break\n                    if dfs(i+k+1, False) is not None:\n                        return [i] + dfs(i+k+1, False)\n                else:\n                    if dfs(i+k+1, True) is not None:\n                        return dfs(i+k+1, True) + [i]\n            else:\n                for j in range(l):\n                    if l-j+i > len(target):\n                        continue\n                    for k in range(j,l):\n                        if i+k-j >= len(target) or stamp[k] != target[i+k-j]:\n                            break\n                        if dfs(i+k-j+1, False) is not None:\n                            return [i-j] + dfs(i+k-j+1, False)\n                    else:\n                        if dfs(i+k-j+1, True) is not None:\n                            return dfs(i+k-j+1, True) + [i-j]\n            return None\n            \n        return dfs(0, False)\n                \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        n, m = len(target), len(stamp)\n        if n < m:\n            return False\n\n        def check_and_mark(s: list, i: int) -> tuple:\n            # return True if update, next_read_pos\n            if s[i:i+m] == ['?'] * m:\n                return False, i + 1\n            i0 = i\n            j = 0\n            while i < n and j < m and (s[i] == '?' or s[i] == stamp[j]):\n                i += 1\n                j += 1\n            if j == m:\n                s[i0:i0 + m] = ['?'] * m\n                return True, i\n            else:\n                return False, (n if i == n else i0 + 1)\n        \n        final = ['?'] * n\n        ans = []\n        target = list(target)\n        while target != final:\n            i = 0\n            updated = False\n            while i < n:\n                done, i = check_and_mark(target, i)\n                if done:\n                    updated = done\n                    ans.append(i - m)\n            if not updated:\n                return []\n        return ans[::-1]", "def matchs(stamp, target, i, j, ans, pos):\n        S = len(stamp)\n        T = len(target)\n        if (target[i] != stamp[j]) or (T - i < S - j) or (j > i):\n            return False\n            \n        res = ['?'] * T \n        res[i - j : i - j + S] = list(stamp)\n        for poss in range(pos, len(ans)):\n            if ans[poss] in range(i - j - S + 1, i):\n                res[ans[poss]: min(ans[poss] + S, T)] = list(stamp[:min(S, T - ans[poss])])\n        \n        res = \\\"\\\".join(res)\n        if (res[i - j : i] == target[i - j : i]):\n            return True\n        else:\n            return False\n        \nclass Solution:            \n    def movesToStamp(self, stamp: str, target: str):\n        S = len(stamp)\n        T = len(target)\n        j = 0\n        pos = -1\n        ans = []\n        for i in range(T):\n            j = j % S\n            if(target[i] == stamp[j]):\n                if(j == 0):\n                    reached = False\n                    for j in range(S-1, 0, -1):\n                        if matchs(stamp, target, i, j, ans, pos):\n                            reached = True\n                            ans.insert(pos, i - j)\n                            break\n                    if not reached:\n                        if matchs(stamp, target, i, 0, ans, pos + 1):\n                            j = 0\n                            pos += 1\n                            ans.insert(pos, i)\n                        else:\n                            return []\n            else:\n                reached = False\n                if (j == 0):\n                    for j in range(S-1, 0, -1):\n                        if matchs(stamp, target, i, j, ans, pos):\n                            reached = True\n                            ans.insert(pos, i - j)\n                            break\n                else:\n                    for j in range(S):\n                        if matchs(stamp, target, i, j, ans, pos + 1):\n                            reached = True\n                            pos += 1\n                            ans.insert(pos, i - j)\n                            break\n                if not reached:\n                    return []\n            j += 1\n        return ans\n\n                \n                        \n    \n        \n        ", "class Solution(object):\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        memo = {}\n        T, S = len(target), len(stamp)\n        def dfs(t, s, cur_stmp):\n            if t == T:\n                memo[t, s] = cur_stmp if s == S else []\n                return memo[t, s]\n            if (t, s) not in memo:\n                # complete match, find successor\n                if s == S:\n                    for i in range(S):\n                        if stamp[i] == target[t]:\n                            suff_stmp = dfs(t, i, [t-i]) \n                            if suff_stmp:\n                                memo[t, s] = suff_stmp + cur_stmp\n                                break\n                    else:\n                        memo[t, s] = []\n\n                elif stamp[s] == target[t]:\n                    suff_stmp = dfs(t+1, s+1, cur_stmp)\n                    if suff_stmp:\n                        memo[t, s] = suff_stmp\n                    else:\n                        # add word cut and find predeccessor\n                        suff_stmp = dfs(t+1, 0, [t+1])\n                        memo[t, s] = cur_stmp + suff_stmp if suff_stmp else []\n\n                else:\n                    memo[t, s] = []\n\n                return memo[t, s] if memo[t, s] else []\n\n\n        return dfs(0, 0, [0])", "class Solution(object):\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        memo = {}\n        T, S = len(target), len(stamp)\n        def dfs(t, s, cur_stmp):\n            if t == T:\n                memo[t, s] = cur_stmp if s == S else []\n                return memo[t, s]\n            if (t, s) not in memo:\n                # complete match, find successor\n                if s == S:\n                    for i in range(S):\n                        if stamp[i] == target[t]:\n                            suff_stmp = dfs(t, i, [t-i]) \n                            if suff_stmp:\n                                memo[t, s] = suff_stmp + cur_stmp\n                                break\n                    else:\n                        memo[t, s] = []\n\n                elif stamp[s] == target[t]:\n                    suff_stmp = dfs(t+1, s+1, cur_stmp)\n                    if suff_stmp:\n                        memo[t, s] = suff_stmp\n                    else:\n                        # add word cut and find predeccessor\n                        suff_stmp = dfs(t+1, 0, [t+1])\n                        memo[t, s] = cur_stmp + suff_stmp if suff_stmp else []\n\n                elif stamp[s] != target[t]:\n                    # add word cut and find predeccessor\n                    if stamp[0] == target[t]:\n                        suff_stmp = dfs(t, 0, [t])\n                        memo[t, s] = cur_stmp + suff_stmp if suff_stmp else []\n                    else:\n                        memo[t, s] = []\n\n                return memo[t, s] if memo[t, s] else []\n\n\n        return dfs(0, 0, [0])\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        stamp = list(stamp)\n        target = list(target)\n        res = []\n        \n        def check(i):\n            changed = False\n            for j in range(len(stamp)):\n                if target[i+j] == '?': continue\n                if target[i+j] != stamp[j]: return False\n                changed = True\n\n            return changed\n            \n        seen = [0] * len(target)   \n        ans = True\n        while ans:\n            ans = False\n            for i in range(len(target) - len(stamp) + 1):\n                changed = check(i)               \n                ans = ans or changed\n                            \n                if changed:\n                    res.append(i)\n                    target[i:i+len(stamp)] = ['?'] * len(stamp)\n                    seen[i:i+len(stamp)] = [1] * len(stamp)\n                               \n        return res[::-1] if sum(seen) == len(target) else []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        from collections import deque\n        m, n = len(stamp), len(target)\n        queue = deque()\n        done = [False]*n\n        ans = []\n        A = []\n        for i in range(n-m+1):\n            todo, made = set(), set()\n            for j in range(m):\n                if stamp[j] == target[i+j]:\n                    made.add(i+j)\n                else:\n                    todo.add(i+j)\n            A.append((todo, made))\n            if not todo:\n                ans.append(i)\n                for j in made:\n                    if not done[j]:\n                        done[j] = True\n                        queue.append(j)\n        while queue:\n            i = queue.popleft()\n            for j in range(max(0, i-m+1), min(i, n-m)+1):\n                if i in A[j][0]:\n                    A[j][0].discard(i)\n                    if not A[j][0]:\n                        ans.append(j)\n                        for k in A[j][1]:\n                            if not done[k]:\n                                done[k] = True\n                                queue.append(k)\n                                \n        return ans[::-1] if all(done) else []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        ls,lt = list(stamp),list(target)\n        m,n = len(ls),len(lt)\n        todo,move,res = n-m+1,0,[]\n        def match(lst,ls):\n            ret = False\n            for c1,c2 in zip(lst,ls):\n                if c1 == '?':\n                    continue\n                elif c1 != c2:\n                    return False\n                else:\n                    ret = True\n            if ret:\n                lt[i:i+m] = ['?']*m\n            return ret\n        while move<todo:\n            prv = move\n            for i in range(n-m+1):\n                if match(lt[i:i+m],ls):\n                    move += 1\n                    res.append(i)\n            if lt == ['?']*n:return res[::-1]\n            if prv == move:break\n        return []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        N, M, match = len(target), len(stamp), True\n        \n        positions = []\n        while match:\n            match, idx = False, 0\n            while idx <= N-M:\n                match_cnt = 0\n                for i in range(M):\n                    if target[idx+i] == '?':\n                        continue\n                    if target[idx+i] != stamp[i]:\n                        break\n                    match_cnt += 1\n                else:\n                    if match_cnt:\n                        positions.append(idx)\n                        target = target[:idx] + '?'*M + target[idx+M:]\n                        match, idx = True, idx+M-1\n                idx += 1\n        return positions[::-1] if target == '?'*N else []\n", "class Solution(object):\n    def movesToStamp(self, stamp, target):\n        M, N = len(stamp), len(target)\n\n        queue = collections.deque()\n        done = [False] * N\n        ans = []\n        A = []\n        for i in range(N - M + 1):\n            # For each window [i, i+M),\n            # A[i] will contain info on what needs to change\n            # before we can reverse stamp at i.\n\n            made, todo = set(), set()\n            for j, c in enumerate(stamp):\n                a = target[i+j]\n                if a == c:\n                    made.add(i+j)\n                else:\n                    todo.add(i+j)\n            A.append((made, todo))\n\n            # If we can reverse stamp at i immediately,\n            # enqueue letters from this window.\n            if not todo:\n                ans.append(i)\n                for j in range(i, i + len(stamp)):\n                    if not done[j]:\n                        queue.append(j)\n                        done[j] = True\n\n        # For each enqueued letter,\n        while queue:\n            i = queue.popleft()\n\n            # For each window that is potentially affected,\n            # j: start of window\n            for j in range(max(0, i-M+1), min(N-M, i)+1):\n                if i in A[j][1]:  # This window is affected\n                    A[j][1].discard(i) # Remove it from todo list of this window\n                    if not A[j][1]:  # Todo list of this window is empty\n                        ans.append(j)\n                        for m in A[j][0]: # For each letter to potentially enqueue,\n                            if not done[m]:\n                                queue.append(m)\n                                done[m] = True\n\n        return ans[::-1] if all(done) else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        done = [False]*n\n        from collections import deque\n        ans = []\n        queue = deque()\n        A = []\n        for i in range(n-m+1):\n            todo, made = set(), set()\n            for j, ch in enumerate(stamp):\n                a = target[i+j]\n                if a == ch:\n                    made.add(i+j)\n                else:\n                    todo.add(i+j)\n            A.append((made, todo))\n            if not todo:\n                ans.append(i)\n                for k in made:\n                    if not done[k]:\n                        done[k] = True\n                        queue.append(k)\n        \n        while queue:\n            i = queue.popleft()\n            for j in range(max(0, i-m+1), min(i, n-m)+1):\n                if i in A[j][1]:\n                    A[j][1].discard(i)\n                    if not A[j][1]:\n                        ans.append(j)\n                        for k in A[j][0]:\n                            if not done[k]:\n                                done[k] = True\n                                queue.append(k)\n        return ans[::-1] if all(done) else []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        #\n        # BFS & DP ----- Time Limit Exceeded\n        # -----------------------------------------------------------------------------------------------\n        # n = len(target)\n        # k = len(stamp)\n        # visited = set()\n        # q = [(\\\"?\\\" * len(target), [])]\n        # while q:\n        #     cur_str, seq = q.pop(0)\n        #     for i in range(0, n-k+1):\n        #         new_str = cur_str[:i] + stamp + cur_str[i + k:]\n        #         if new_str == target:\n        #             return seq + [i]\n        #         if new_str not in visited:\n        #             visited.add(new_str)\n        #             q.append((new_str, seq + [i]))\n        # return []\n    \n    \n        #\n        # DFS & DP ----- 96 ms (94.35%) / 20.6 MB (6.00%)\n        # \n        # Here are few rules for this problem:\n        #\n        # 1. stamp[0] has to be equal with target[0]\n        # 2. stamp[-1] has to be equal with target[-1]\n        # 3. We keep checking pairs of (stamp[s], target[t]). When checking (s, t). \n        #    If stamp[s] equals to target[t], we can move forward to (s+1, t+1). \n        #    Otherwise, we add a new stamp at index t+1 and stamp[0] has to be equal with target[t+1]. \n        #    Then we move forward to (0, t+1). (If stamp[0] != target[t+1] here, \n        #    there is no way to stamp without overwriting previous stamped sequence).\n        # 4. When a stamp is used up, s == len(stamp), and we can try any i that stamp[i] == target[t]. \n        #    In such case, we stamp at index t-i at the beginning of the sequence so that \n        #    stamp[:i] will be overwritten by \\\"later\\\" stamps and we move forward to (i, t).\n        # 5. We finish our search when we reach the end of target or t == len(target). \n        #    Based on rule #2, if i == len(stamp) as well, we have a valid sequence.\n        # \n        # Based on these rules, we can build a DFS with memoization. The speed beats 90%.\n        # -----------------------------------------------------------------------------------------------\n        memo, ls, lt = {}, len(stamp), len(target)\n        \n        def dfs(s, t, seqs):\n            if t == lt:\n                memo[s, t] = seqs if s == ls else []\n            if (s, t) not in memo:\n                if s == ls:\n                    for i in range(ls):\n                        if stamp[i] != target[t]:\n                            continue\n                        cand = dfs(i, t, [t-i]+seqs)\n                        if cand:\n                            memo[s, t] = cand\n                            break\n                        else: \n                            memo[s, t] = []\n                elif target[t] == stamp[s]:\n                    cand = dfs(s+1, t+1, seqs)\n                    memo[s, t] = cand if cand else dfs(0, t+1, seqs+[t+1])\n                else:\n                    memo[s, t] = []\n            return memo[s, t]\n        \n        return dfs(0, 0, [0])\n                \n            \n\\\"\\\"\\\"\nTest Cases\nmovesToStamp(\\\"abc\\\", \\\"ababc\\\")\nmovesToStamp(\\\"ab\\\", \\\"babab\\\")\nmovesToStamp(\\\"o\\\", \\\"oooooooooooooooooooo\\\")\n\n\\\"\\\"\\\"", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        stamp_len, target_len, stamp, target, result = len(stamp), len(target), list(stamp), list(target), []\n        changed = True\n        while changed:\n            changed = False\n            for i in range(target_len - stamp_len + 1):\n                changed |= self.check(stamp, target, i, result)\n        return result[::-1] if target == ['?'] * target_len else []   \n    \n    def check(self, stamp, target, i, result):\n        changed = False\n        for j in range(len(stamp)):\n            if target[i+j] == '?': continue\n            if stamp[j] != target[i+j]: return False\n            changed = True\n        if changed:\n            target[i:i+len(stamp)] = ['?'] * len(stamp)\n            result.append(i)\n        return changed", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        ret = []\n        stamp = list(stamp)\n        target= list(target)\n        cnt = 0\n        candidates = [i for i in range(len(target)-len(stamp)+1)]\n        # print(candidates)\n        while cnt < len(target) and len(candidates) > 0:\n            nxt = set()\n            for i in candidates:\n                l = min(len(stamp), len(target)-i)\n                if (all(target[i+j] in ['*', stamp[j]] for j in range(l)) \n                    and any(target[i+j] != '*' for j in range(l))):\n                    nxt |= set(max(0, i-j) for j in range(l))\n                    for j in range(i, i+l):\n                        if target[j] != '*':\n                            cnt +=1\n                        target[j] = '*'\n                    ret.append(i)\n            candidates = nxt\n            # print(target)\n            \n        return ret[::-1] if cnt == len(target) else []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        locks = collections.defaultdict(set)\n        count_locks = collections.defaultdict(int)\n        \n        last_window = len(target)-len(stamp)\n        \n        for i in range(last_window+1):\n            for j in range(i, i+len(stamp)):\n                if stamp[j-i] != target[j]:\n                    locks[j].add(i)\n                    count_locks[i] += 1\n            \n        available_windows = collections.deque([])\n        for i in range(last_window+1):\n            if count_locks[i] == 0:\n                available_windows.append(i)\n                \n        res = []\n        target = list(target)\n        while available_windows:\n            window = available_windows.popleft()\n            res.append(window)\n            for i in range(window, window+len(stamp)):\n                if target[i] == \\\"?\\\":\n                    pass\n                else:\n                    target[i] = \\\"?\\\"\n                    while locks[i]:\n                        w = locks[i].pop()\n                        count_locks[w] -= 1\n                        if count_locks[w] == 0:\n                            available_windows.append(w)\n        if any(c != \\\"?\\\" for c in target):\n            return []\n        return res[::-1]\n                        ", "# ababcbc\nclass Solution:\n    def movesToStamp(self, s, t):\n        n, m, t, s, res = len(t), len(s), list(t), list(s), []\n\n        def check(i):\n            changed = False\n            for j in range(m):\n                if t[i + j] == '?': continue\n                if t[i + j] != s[j]: return False\n                changed = True\n            if changed:\n                t[i:i + m] = ['?'] * m\n                res.append(i)\n            return changed\n\n        changed = True\n        while changed:\n            changed = False\n            for i in range(n - m + 1):\n                changed |= check(i)\n        return res[::-1] if t == ['?'] * n else []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        \n        def helper(idx):\n            num = len(stamp)\n            for i in range(len(stamp)):\n                if target[i+idx] == '*':\n                    num -= 1\n                elif target[i+idx] != stamp[i]:\n                    return 0\n            target[idx:idx+len(stamp)] = ['*']*len(stamp)\n            return num\n        \n        seen = [0]*len(target)\n        total = 0\n        res = []\n        target = list(target)\n        while total < len(target):\n            found = False\n            for i in range(len(target)-len(stamp)+1):\n                if seen[i] == 1: continue\n                num = helper(i)\n                if num == 0: continue\n                seen[i] = 1\n                total += num\n                found = True\n                res.append(i)\n            if not found: return []\n        return res[::-1]\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m=len(stamp)\n        n=len(target)\n        stamp=list(stamp)\n        target=list(target)\n        noleft=n\n        c=[]\n        while(noleft>0):\n            onc=False\n            for i in range(n-m+1):\n                oc=False\n                no=0\n                for j in range(i,i+m):\n                    if(target[j]==stamp[j-i]):\n                        no+=1\n                    elif(target[j]==\\\"?\\\"):\n                        continue\n                    else:\n                        oc=True\n                        break\n                if(oc==False)and(no!=0):\n                    onc=True\n                    c.append(i)\n                    noleft-=no\n                    for j in range(i,i+m):\n                        target[j]=\\\"?\\\"\n            if(onc==False):\n                return []\n        c.reverse()\n        return c\n                \n                \n                        \n        ", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        res = []\n        all_len = 0\n        cur_len = 1\n        while cur_len:\n            cur_len = 0\n            for i in range(len(stamp)):\n                for j in range(len(stamp) - i):\n                    cur_stamp = '*' * i + stamp[i: len(stamp) - j] + '*' * j\n                    # print(cur_stamp)\n                    idx = target.find(cur_stamp)\n                    while idx != -1:\n                        target = target[:idx] + '*' * len(cur_stamp) + target[idx + len(cur_stamp):]\n                        # print(cur_stamp, target)\n                        res.append(idx)\n                        cur_len += len(stamp) - i - j\n                        idx = target.find(cur_stamp)\n            all_len += cur_len\n        \n        #print(all_len)\n        return res[::-1] if all_len == len(target) else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        # abc??\n        # ?abc?\n        # ??abc\n        \n        def num_match(stamp, target):\n            ret = 0\n            for (c1, c2) in zip(stamp, target):\n                if c1 == c2:\n                    ret += 1\n                elif c2 != '?':\n                    return -1\n            return ret\n\n        remain = len(target)\n        ret= []\n        cur = list(target)\n        while remain > 0:\n            tmp = remain\n            match = 0\n            for l in range(len(target)):\n                r = l + len(stamp) - 1\n                if r >= len(target):\n                    break\n                match = num_match(stamp, cur[l:r + 1])\n                if match > 0:\n                    cur[l:l + len(stamp)] = ['?'] * len(stamp)\n                    ret.append(l)\n                    remain -= match\n                    \n            if tmp == remain:\n                return []\n        \n        return ret[::-1]\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        memo, ls, lt = {}, len(stamp), len(target)\n        def dfs(s, t, seqs):\n            if t == lt:\n                memo[s, t] = seqs if s == ls else []\n            if (s, t) not in memo:\n                if s == ls:\n                    for i in range(ls):\n                        cand = dfs(i, t, [t-i]+seqs)\n                        if cand:\n                            memo[s, t] = cand\n                            break\n                    else: \n                        memo[s, t] = []\n                elif target[t] == stamp[s]:\n                    cand = dfs(s+1, t+1, seqs)\n                    memo[s, t] = cand if cand else dfs(0, t+1, seqs+[t+1])\n                else:\n                    memo[s, t] = []\n            return memo[s, t]\n            \n        return dfs(0, 0, [0])", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        # greedy\n        res = []\n        seq = list(target)\n        m, n = len(stamp), len(target)\n        def check(i):\n            changed = False\n            full = True\n            for j in range(m):\n                if seq[i+j]=='?': \n                    continue                    \n                else:\n                    if target[i+j] == stamp[j]:\n                        changed = True\n                    else:\n                        full = False\n            if changed and full:\n                seq[i:i+m] = ['?'] * m\n                return True\n            return False\n        \n        changed = True\n        while changed:\n            changed = False\n            for i in range(n-m+1):\n                if check(i):\n                    res.append(i)\n                    changed = True\n        return res[::-1] if all([c=='?' for c in seq]) else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        stampList = list(stamp)\n        targetList = list(target)\n        \n        result = []\n        changed = True\n        while changed:\n            changed = False\n            for i in range(len(targetList) - len(stampList) + 1):\n                temp = self.validTarget(stampList, targetList, i)\n                \n                if temp:\n                    changed = True\n                    result += [i]\n            \n            if not changed:\n                break\n        \n        if targetList == [\\\"?\\\"] * len(targetList):\n            return reversed(result)\n        else:\n            return []\n        \n        \n    def validTarget(self, stamp, target, i):\n        \n        changed = False\n        \n        for j in range(len(stamp)):\n            \n            if target[j+i] == \\\"?\\\":\n                continue\n            if stamp[j] != target[i+j]:\n                return False\n            \n            changed = True\n        \n        if not changed:\n            return False\n        \n        for j in range(len(stamp)):\n            target[j+i] = \\\"?\\\"\n        \n        return True", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        ret = []\n        stamp = list(stamp)\n        target= list(target)\n        cnt = 0\n        candidates = [i for i in range(len(target)-len(stamp)+1)]\n        # print(candidates)\n        while cnt < len(target) and len(candidates) > 0:\n            nxt = []\n            for i in candidates:\n                l = min(len(stamp), len(target)-i)\n                if (all(target[i+j] in ['*', stamp[j]] for j in range(l)) \n                    and any(target[i+j] != '*' for j in range(l))):\n                    nxt += [max(0, i-j) for j in range(l)]\n                    for j in range(i, i+l):\n                        if target[j] != '*':\n                            cnt +=1\n                        target[j] = '*'\n                    ret.append(i)\n            candidates = nxt\n            # print(target)\n            \n        return ret[::-1] if cnt == len(target) else []\n", "def getstamps(s):\n    stamps = []\n    for i in range(0, len(s)):\n        for j in range(len(s), -1, -1):\n            if i + len(s)-j <len(s):\n                stamp = '*'*i+s[i:j]+'*'*(len(s)-j)\n                stamps.append(stamp)\n    return stamps\n\ndef stampseq(s, t):\n    stamps = getstamps(s)\n    print(stamps)\n    flag = True\n    result = []\n    while flag:\n        flag = False\n        for stamp in stamps:\n            pos = t.find(stamp)\n            while(pos != -1):\n                result.append(pos)\n                t = t[:pos] + '*'*len(s) + t[pos+len(s):]\n                flag = True\n                pos = t.find(stamp)\n            if t == '*'*len(t):\n                return reversed(result)\n    return []\n        \n        \nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        return stampseq(stamp, target)", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        s_l, t_l = len(stamp), len(target)\n        t = list(target)\n        res = list()\n        \n        def stmp(i):\n            # match the whole stamp\n            match = False\n            for j in range(s_l):\n                if t[i + j] == '?':\n                    continue\n                elif t[i + j] != stamp[j]:\n                    return False\n                match = True\n            if match:\n                t[i : i + s_l] = ['?'] * s_l\n                res.append(i)\n            return match\n        \n        match = True\n        # loop until no more match\n        while match:\n            match = False\n            for i in range(t_l - s_l + 1):\n                match |= stmp(i)\n        \n        return res[::-1] if t == ['?'] * t_l else list()\n            \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        tl,sl = len(target),len(stamp)\n        t,s = list(target),list(stamp)\n        res = []\n        def check(i):\n            signal = False\n            for j in range(sl):\n                if t[i+j] == '?':continue\n                if t[i+j] != s[j]:return False\n                signal = True\n            if signal:\n                t[i:i+sl] = ['?']*sl\n                res.append(i)\n            return signal\n        signal = True\n        while signal:\n            signal = False\n            for i in range(tl-sl+1):\n                signal = signal | check(i)\n        return res[::-1] if t == ['?']*tl else []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        from collections import deque, defaultdict\n        \n        ls = len(stamp)\n        lt = len(target)\n        \n        flag = [False] * lt\n        todo_mp = defaultdict(set)\n        wait_mp = defaultdict(set)\n        \n        for i in range(lt - ls + 1):\n            for j in range(ls):\n                if stamp[j] == target[i + j]:\n                    todo_mp[i].add(i + j)\n                else:\n                    wait_mp[i].add(i + j)\n        \n        q = deque([i for i in range(lt - ls + 1) if len(wait_mp[i]) == 0])\n        \n        ret = []\n        visited = set(q)\n        while len(q) > 0 and all(flag) is False:\n            idx = q.popleft()\n            to_add = False\n            for item in todo_mp[idx]:\n                if flag[item] is False:\n                    flag[item] = True\n                    to_add = True\n            if to_add is True:\n                ret.append(idx)\n                \n            for nei in range(max(idx - ls + 1, 0), min(idx + ls - 1, lt - ls) + 1):\n                if nei in visited:\n                    continue\n                for t in todo_mp[idx]:\n                    wait_mp[nei].discard(t)\n                if len(wait_mp[nei]) == 0:\n                    q.append(nei)\n                    visited.add(nei)\n        \n        if all(flag) is True:\n            return ret[::-1]\n        return []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        n, m, t, s, res = len(target), len(stamp), list(target), list(stamp), []\n        \n        def check(i):\n            changed = False\n            for j in range(m):\n                if t[i+j] == '?': continue\n                if t[i+j] != s[j]: return False\n                changed = True\n                \n            if changed:\n                t[i:i+m] = ['?'] * m\n                res.append(i)\n            return changed\n        \n        changed = True\n        while changed:\n            changed = False\n            for i in range(n-m+1):\n                changed |= check(i)\n        return res[::-1] if t ==['?'] * n else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        def okay(s):\n            ret = False\n            for c1,c2 in zip(stamp,s):\n                if c2 == '?':continue\n                elif c1 != c2:return False\n                else:\n                    ret = True\n            return ret\n        \n        todo = len(target)-len(stamp)+1\n        res = []\n        idx = 0\n        while idx<todo:\n            prv = idx\n            for i in range(todo):\n                if okay(target[i:i+len(stamp)]):\n                    idx += 1\n                    res.append(i)\n                    target = target[:i]+'?'*(len(stamp))+target[i+len(stamp):]\n            if target == '?'*len(target):\n                return res[::-1]\n            if idx == prv:break\n        return []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        if stamp not in target:\n            return []\n        \n        m, n = len(stamp), len(target)\n        cnt = 0\n        res = []\n        \n        while cnt < 10:\n            flag = False\n            for i in range(n-m+1):\n                if target[i:i+m] != \\\".\\\"*m and self.helper(stamp, target[i:i+m]):\n                    flag = True\n                    target = target[:i] + \\\".\\\"*m + target[i+m:]\n                    res.append(i)\n                    \n            if target == \\\".\\\"*n:\n                return res[::-1]\n            if not flag:\n                return []\n        cnt += 1\n            \n        return []\n    \n    def helper(self, stamp, target):\n        for i in range(len(stamp)):\n            if target[i] != \\\".\\\" and stamp[i] != target[i]:\n                return False\n        return True", "class Solution:\n    # O(mnn) time, O(n) space\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        target_list = list(target)\n        result = []\n        \n        def is_changed(i):\n            changed = False\n            for j in range(m):\n                if target_list[i + j] == \\\"?\\\":\n                    continue\n                if target_list[i + j] != stamp[j]:\n                    return False\n                # equal to stamp[j] and should be changed to ?\n                changed = True\n            if changed:\n                for j in range(m):\n                    target_list[i + j] = \\\"?\\\"\n                result.append(i)\n            return changed\n        \n        changed = True\n        while changed:\n            changed = False\n            for i in range(n - m + 1):\n                changed |= is_changed(i)\n        \n        if all(x == \\\"?\\\" for x in target_list):\n            return result[::-1]\n        return []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        \n        root = '?' * (n := len(target))\n        res = []\n        moves = 0\n        def match(s, t):\n            # return all(ch1 in {ch2, '?'} for ch1, ch2 in zip(s, t))\n            for ch1, ch2 in zip(s, t):\n                if ch1 == '?':\n                    continue\n                elif ch1 != ch2:\n                    return False\n            return True\n        \n        while moves <= 10 * n:\n            pre_move = 0\n            for i in range(n - (m := len(stamp)) + 1):\n                if target[i] in {stamp[0], '?'} and match(target[i:i+m], stamp):\n                    moves += 1\n                    res.append(i)\n                    target = target[:i] + '?' * m + target[i+m:]\n                    \n                    if target == root:\n                        return reversed(res)\n            if pre_move == moves:\n                return []\n        return []    \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        root = '?' * (n := len(target))\n        res = []\n        moves = 0\n        def match(s, t):\n            for c1, c2 in zip(s, t):\n                if c1 == '?':\n                    continue\n                elif c1 != c2:\n                    return False\n            return True\n        \n        while moves <= 10 * n:\n            prev_move = moves\n            for i in range(n - (m := len(stamp)) + 1):\n                if target[i] in {stamp[0], '?'} and match(target[i:i+m], stamp):\n                    moves += 1\n                    res.append(i)\n                    target = target[:i] + '?' * m + target[i+m:]\n                    \n                    if target == root:\n                        return res[::-1]\n            if prev_move == moves:\n                return []\n        return []\n           \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        \n        root = '?' * (n := len(target))\n        res = []\n        moves = 0\n        def match(s, t):\n            for ch1, ch2 in zip(s, t):\n                if ch1 == '?':\n                    continue\n                elif ch1 != ch2:\n                    return False\n            return True\n        while moves <= 10 * n:\n            pre_move = 0\n            for i in range(n - (m := len(stamp)) + 1):\n                if target[i] in {stamp[0], '?'} and match(target[i:i+m], stamp):\n                    moves += 1\n                    res.append(i)\n                    target = target[:i] + '?' * m + target[i+m:]\n                    \n                    if target == root:\n                        return reversed(res)\n            if pre_move == moves:\n                return []\n        return []    \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        res = []\n        ns,nt = len(stamp),len(target)\n        final = \\\"?\\\"*nt\n        def same(ind):\n            other = False\n            for i in range(ns):\n                if target[i+ind] not in stamp[i]+\\\"?\\\":\n                    return False\n                if target[i+ind]!=\\\"?\\\":\n                    other = True\n            return other\n        change = True\n        while change:\n            change = False\n            for ind in range(nt-ns+1):\n                if same(ind):\n                    change=True\n                    res.append(ind)\n                    target=target[:ind]+\\\"?\\\"*ns+target[ind+ns:]\n        return res[::-1] if all(i==\\\"?\\\" for i in target) else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        N , M = len(target), len(stamp)\n        def cor(s):\n            result = False\n            for c1, c2 in zip(s,stamp):\n                if c1 == '?':\n                    continue\n                elif c1 != c2:\n                    return False\n                else:\n                    result = True\n            return result\n        base, times, max_times, indexes = '?' * N , 0 , 10* N, []                \n        while times < max_times:\n            start = times\n            for i in range(N - M + 1):                \n                if cor(target[i:i + M  ]):\n                    times += 1\n                    indexes.append(i)\n                    target = target[:i] + '?' *  M + target[i+M:]                \n            if target == base:\n                return indexes[::-1]\n                \n            if times == start:\n                break\n        print(\\\"here\\\")\n        return  []\n            \n                \n                \n            \n            \n            ", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        if set(stamp) < set(target) or len(stamp) > len(target):\n            return []\n        \n        patterns = set()\n        for l in range(1, len(stamp) + 1):\n            for i in range(len(stamp) - l + 1):\n                patterns.add('*' * i + stamp[i:i + l] + '*' * (len(stamp) - i - l))\n            \n        goal = '*' * len(target)\n        def dfs(cur, path, moves):\n            if cur == goal:\n                return path\n            \n            if not moves:\n                return []\n            \n            old_moves = moves\n            for pattern in patterns:\n                i = cur.find(pattern)\n                if i >= 0:\n                    cur = cur[:i] + '*' * len(stamp) + cur[i + len(stamp):]\n                    path.append(i)\n                    moves -= 1\n            \n            if old_moves == moves:\n                return []\n            \n            return dfs(cur, path, moves)\n        \n        return dfs(target, [], 10 * len(target))[::-1]\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        lens,lent = len(stamp), len(target)\n        out = []\n        q = collections.deque()\n        done = set()\n        # create v,t \n        v = [set() for _ in range(lent-lens+1)]\n        t = [set() for _ in range(lent-lens+1)]\n        # iterate over all offsets\n        for i in range(len(target)-len(stamp)+1):\n            for j in range(len(stamp)):\n                if stamp[j] == target[i+j]:\n                    v[i].add(i+j)\n                else:\n                    t[i].add(i+j)\n            if len(t[i]) == 0:\n                out.append(i)\n                for j in range(len(stamp)):\n                    done.add(i+j)\n                q.append(i)\n        while q:\n            offset = q.popleft()\n            for of in range(max(0,offset-lens+1),min(lent-lens+1,offset+lens)): \n                t[of] -= done\n                if len(t[of]) == 0:\n                    if len(v[of] - done) > 0:\n                        q.append(of)\n                        done |= v[of]\n                        out.append(of)\n        if len(done) == lent:             \n            return out[::-1]\n        return []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        \n        def check_equal(sub_string):\n            \n            for c1, c2 in zip(list(sub_string), list(stamp)):\n                if c1 != \\\"?\\\" and c1 != c2:\n                    return False\n            return True\n                \n        stamp_length = len(stamp)\n        end_result = \\\"?\\\" * len(target)\n        no_check_string = \\\"?\\\" * stamp_length\n\n        res = []\n        for _ in range(10 * len(target)):\n            found = False\n            for ti in range(len(target) - stamp_length + 1):\n                sub_string = target[ti:ti+stamp_length]\n                # print(sub_string)\n                if sub_string == no_check_string:\n                    continue\n                if check_equal(sub_string):\n                    target = target[:ti] + no_check_string + target[ti + stamp_length:]\n                    found = True\n                    res += [ti]\n                    break\n            \n            if found:\n                if target == end_result:\n                    return res[::-1]\n            \n            else:\n                return []\n            \n        return []\n                \n            \n            \n            \n            \n            \n        ", "'''\n\\\"aabcaca\\\"\n 0123456\n  x\n \nmatched = [set() for _ in range(M-N)]\n\nque = [1]\nfor window_start in range(i - n + 1, i + n):\n    for j in range(i, i+n):\n        todo[window_start].discard(j)\n        if canMatch(todo[window_start]):\n            que.append(window_start)\n'''\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        '''greedy. everytime put the totally matched window to the que\n            then update the windows that are affected\n            then if updated window is totally matched, append to que.\n            keep doing it.\n        '''\n\n        M = len(stamp)\n        N = len(target)\n        nwin = N - M + 1\n        matched = [set() for _ in range(nwin)]\n        done = set()\n        \n        for win_start in range(nwin):\n            for i, (c1, c2) in enumerate(zip(target[win_start: win_start+M], stamp)):\n                if c1 == c2: matched[win_start].add(i + win_start)\n        \n        res = []\n        que = deque()\n        for win_start in range(nwin):\n            if len(matched[win_start]) == M:\n                que.append(win_start)\n                res.append(win_start)\n                done.add(win_start)\n        \n        #print(que, matched) \n        \n        while que:\n            win_start = que.popleft() #done window\n            #new windows that are affected\n            \n            for nws in range(max(0, win_start-M +1), min(nwin, win_start + M)):\n                #add the pos if not matched in new window yet\n                if nws in done: continue\n                for pos in range(win_start, win_start + M): # pos in done\n                    if nws <= pos < nws + M:\n                        matched[nws].add(pos)\n                        \n                if len(matched[nws]) == M:\n                    que.append(nws)\n                    done.add(nws)\n                    res.append(nws)\n            \n        return res[::-1] if all([d in done for d in range(nwin)]) else []\n                    \n                \n            \n            \n            \n            \n", "class Solution:\n    def movesToStamp(self, stamp, target):\n        memo, ls, lt = {}, len(stamp), len(target)\n        def dfs(s, t, seqs):\n            if t == lt:\n                memo[s, t] = seqs if s == ls else []\n            if (s, t) not in memo:\n                if s == ls:\n                    for i in range(ls):\n                        cand = dfs(i, t, [t-i]+seqs)\n                        if cand:\n                            memo[s, t] = cand\n                            break\n                    else: \n                        memo[s, t] = []\n                elif target[t] == stamp[s]:\n                    cand = dfs(s+1, t+1, seqs)\n                    memo[s, t] = cand if cand else dfs(0, t+1, seqs+[t+1])\n                else:\n                    memo[s, t] = []\n            return memo[s, t]\n        return dfs(0, 0, [0])\n", "class Solution:\n    def movesToStamp(self, stamp, target):\n        ns = len(stamp)        \n        stamp_patterns = []\n\\t\\t# Step - 1:\n        # we need to collect all possible stamp patters, like\n        # 'abcde'\n        # 'abcd*'\n        # '*bcde'\n        # 'abc**'\n        # '**cde'\n        # 'ab***'\n        # '*bc**'\n        # '**cd*'\n        # '***de'\n        # \u2018****e\u2019 and etc\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.append('*' * ns)\n\n        res = []\n        nt = len(target)\n\\t\\t# Step - 2\n        # '*****' is our final target\n        while target != '*' * nt:\n            old_target = target\n            # greedy, keep replace current target string with possible patter\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        \n        return res[::-1]\n        ", "class Solution:\n    def movesToStamp(self, stamp, target):\n        ns = len(stamp)        \n        stamp_patterns = []\n\\t\\t\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.append('*' * ns)\n\n        res = []\n        nt = len(target)\n        while target != '*' * nt:\n            old_target = target\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        \n        return res[::-1]", "class Solution:\n    def movesToStamp(self, stamp, target):\n        ns = len(stamp)        \n        stamp_patterns = []\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.append('*' * ns)\n\n        res = []\n        nt = len(target)\n        while target != '*' * nt:\n            old_target = target\n            # greedy, keep replace current target string with possible patter\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        \n        return res[::-1]", "class Solution:\n    def movesToStamp(self, stamp, target):\n        ns = len(stamp)        \n        stamp_patterns = []\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.append('*' * ns)\n\n        res = []\n        nt = len(target)\n        while target != '*' * nt:\n            old_target = target\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        \n        return res[::-1]", "class Solution:\n    def movesToStamp(self, stamp, target):\n        ns = len(stamp)        \n        stamp_patterns = []\n\\t\\t# Step - 1:\n        # we need to collect all possible stamp patters, like\n        # 'abcde'\n        # 'abcd*'\n        # '*bcde'\n        # 'abc**'\n        # '**cde'\n        # 'ab***'\n        # '*bc**'\n        # '**cd*'\n        # '***de'\n        # \u2018****e\u2019 and etc\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.append('*' * ns)\n\n        res = []\n        nt = len(target)\n\\t\\t# Step - 2\n        # '*****' is our final target\n        while target != '*' * nt:\n            old_target = target\n            # greedy, keep replace current target string with possible patter\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        \n        return res[::-1]\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        if not stamp or not target:\n            return []\n        m, n = len(stamp), len(target)\n        if m > n:\n            return []\n        if m == n:\n            if stamp == target:\n                return [0]\n            else:\n                return []\n        if '?' in target:\n            return []\n\n        invalid = []\n        invert_idx = [set() for _ in range(n)]\n\n        for i in range(n - m + 1):\n            mismatch = set()\n            for j in range(m):\n                if target[i + j] != '?' and target[i + j] != stamp[j]:\n                    mismatch.add(i + j)\n                    invert_idx[i + j].add(i)\n            invalid.append(mismatch)\n\n        cleared = set()\n        seq = []\n        visited = set()\n\n        while len(cleared) < n:\n            not_found = True\n            for i in range(len(invalid)):\n                if i not in visited and not invalid[i]:\n                    not_found = False\n                    seq.append(i)\n                    visited.add(i)\n\n                    for j in range(m):\n                        cleared.add(i+j)\n                        if invert_idx[i + j]:\n                            for k in invert_idx[i + j]:\n                                invalid[k].remove(i + j)\n                            invert_idx[i + j].clear()\n                    break\n            if not_found:\n                return []\n        return seq[::-1]", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        \n        root = '?' * (n := len(target))\n        res = []\n        moves = 0\n        def match(s, t):\n            return all(ch1 in {ch2, '?'} for ch1, ch2 in zip(s, t))\n            # for ch1, ch2 in zip(s, t):\n            #     if ch1 == '?':\n            #         continue\n            #     elif ch1 != ch2:\n            #         return False\n            # return True\n        \n        while moves <= 10 * n:\n            pre_move = 0\n            for i in range(n - (m := len(stamp)) + 1):\n                if target[i] in {stamp[0], '?'} and match(target[i:i+m], stamp):\n                    moves += 1\n                    res.append(i)\n                    target = target[:i] + '?' * m + target[i+m:]\n                    \n                    if target == root:\n                        return reversed(res)\n            if pre_move == moves:\n                return []\n        return []    \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        \n        root = '?' * (n := len(target))\n        res = []\n        moves = 0\n        def match(s, t):\n            return all(ch1 in {ch2, '?'} for ch1, ch2 in zip(s, t))\n            # for ch1, ch2 in zip(s, t):\n            #     if ch1 == '?':\n            #         continue\n            #     elif ch1 != ch2:\n            #         return False\n            # return True\n        \n        while moves <= 10 * n:\n            pre_move = 0\n            for i in range(n - (m := len(stamp)) + 1):\n                if target[i] in {stamp[0], '?'} and all(ch1 in {ch2, '?'} for ch1, ch2 in zip(target[i:i+m], stamp)):\n                    moves += 1\n                    res.append(i)\n                    target = target[:i] + '?' * m + target[i+m:]\n                    \n                    if target == root:\n                        return reversed(res)\n            if pre_move == moves:\n                return []\n        return []    \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        ns = len(stamp)        \n        stamp_patterns = []\n\\t\\t# Step - 1:\n        # we need to collect all possible stamp patters, like\n        # 'abcde'\n        # 'abcd*'\n        # '*bcde'\n        # 'abc**'\n        # '**cde'\n        # 'ab***'\n        # '*bc**'\n        # '**cd*'\n        # '***de'\n        # \u2018****e\u2019 and etc\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.append('*' * ns)\n\n        res = []\n        nt = len(target)\n\\t\\t# Step - 2\n        # '*****' is our final target\n        while target != '*' * nt:\n            old_target = target\n            # greedy, keep replace current target string with possible patter\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        \n        return res[::-1]\n        ", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        memo, ls, lt = {}, len(stamp), len(target)\n        def dfs(s, t, seqs):\n            if t == lt:\n                memo[s, t] = seqs if s == ls else []\n            if (s, t) not in memo:\n                # stamp down\n                if s == ls:\n                    for i in range(ls):\n                        cand = dfs(i, t, [t-i]+seqs)\n                        if cand:\n                            memo[s, t] = cand\n                            break\n                    else: \n                        memo[s, t] = []\n                # stamp up\n                elif target[t] == stamp[s]:\n                    cand = dfs(s+1, t+1, seqs)\n                    memo[s, t] = cand if cand else dfs(0, t+1, seqs+[t+1])\n                # no match\n                else:\n                    memo[s, t] = []\n            return memo[s, t]\n            \n        return dfs(0, 0, [0])", "class Solution:\n    def movesToStamp(self, stamp, target):\n        ns = len(stamp)        \n        stamp_patterns = []\n        # we need to collect all possible stamp patters, like\n        # 'abcde'\n        # 'abcd*'\n        # '*bcde'\n        # 'abc**'\n        # '**cde'\n        # 'ab***'\n        # '*bc**'\n        # '**cd*'\n        # '***de'\n        # \u2018****e\u2019 and etc\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.append('*' * ns)\n\n        res = []\n        nt = len(target)\n        # '*****' is our final target\n        while target != '*' * nt:\n            old_target = target\n            # greedy, keep replace current target string with possible patter\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        assert len(res) <= 10 * len(target)\n        return res[::-1]", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        n = len(target)\n        m = len(stamp)\n        totalStamped = 0\n        turnStamped = -1\n        res = []\n\n        while True:\n            turnStamped = 0\n\n            for coverSize in range(m, 0, -1): # size: the window size that will stamp over, so *bc , size = 2, abc , size = 3\n                for i in range(m-coverSize+1): # i: the startIdx of \\\"*\\\" from left, if left = 0 , then based on m-coverSize, we can figure out rightIdx to add \\\"*\\\"\n                    newStamp = \\\"*\\\"*i + stamp[i:i+coverSize] + \\\"*\\\"*(m-coverSize-i)\n                    pos = target.find(newStamp)\n\n                    while pos != -1:\n                        res.append(pos)\n                        turnStamped += coverSize # \\\"abc\\\" will cover 3 while \\\"ab*\\\" only cover 2\n                        target = target[:pos] + \\\"*\\\"*len(stamp) + target[pos+len(newStamp):]\n                        pos = target.find(newStamp)\n\n            totalStamped += turnStamped\n            if turnStamped == 0:\n                break\n\n        return res[::-1] if totalStamped == len(target) else []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        S = list(stamp)\n        T = list(target)\n        visited = [False for _ in range(len(T))]\n        ans = []\n        cnt = 0\n        while cnt < len(T):\n            found = False\n            for i in range(len(T) - len(S) + 1):\n                if not visited[i] and self.canStamp(S, T, i):\n                    cnt += self.doStamp(S, T, i)\n                    found = True\n                    ans.append(i)\n                    visited[i] = True\n                    break\n            if not found:\n                return []\n        return ans[::-1]\n    \n    \n    def canStamp(self, S, T, start):\n        for i in range(len(S)):\n            if S[i] != T[i+start] and T[i+start] != \\\"?\\\":\n                return False\n        return True\n    \n    def doStamp(self, S, T, start):\n        cnt = 0\n        for i in range(len(S)):\n            if T[i + start] != \\\"?\\\":\n                cnt += 1\n                T[i + start] = \\\"?\\\"\n        return cnt", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        S = list(stamp)\n        T = list(target)\n        visited = [False for _ in range(len(T))]\n        ans = []\n        cnt = 0\n        while cnt < len(T):\n            found = False\n            for i in range(len(T) - len(S) + 1):\n                if not visited[i] and self.canStamp(S, T, i):\n                    cnt += self.doStamp(S, T, i)\n                    ans.append(i)\n                    visited[i] = True\n                    found = True\n                    break\n            if not found:\n                return []\n        return ans[::-1]\n        \n    def canStamp(self, S, T, start) -> bool:\n        for i in range(len(S)):\n            if S[i] != T[start+i] and T[start+i] != \\\"?\\\":\n                return False\n        return True\n    \n    def doStamp(self, S, T, start) -> int:\n        cnt = 0\n        for i in range(len(S)):\n            if T[start+i] != \\\"?\\\":\n                T[start+i] = \\\"?\\\"\n                cnt += 1\n        return cnt", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        if stamp not in target:\n            return []\n\n        m, n = len(stamp), len(target)\n        cnt = 0\n        res = []\n\n        while cnt < 1000:\n\n            for i in range(n-m+1):\n\n                # check any partial overlap of a stamp with target\n                if target[i:i+m] != \\\".\\\"*m and self.find(stamp, target[i:i+m]):\n                    target = target[:i] + \\\".\\\"*m + target[i+m:]\n                    res.append(i)\n                    break\n            else:\n                return []\n \n            if target == \\\".\\\" * n:\n                return res[::-1]\n            cnt += 1\n\n        return []\n\n    def find(self, stamp, target):\n        for i in range(len(stamp)):\n            if target[i] != \\\".\\\" and stamp[i] != target[i]:\n                return False\n        return True        ", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        done = set()\n        n = len(stamp)\n        m = len(target)\n        candidates = { i for i in range(m-n+1) }\n        res = []\n        \n        def check(i):\n            j = 0\n            count = 0\n            while j < n :\n                if i in done:\n                    j += 1\n                    i += 1\n                elif stamp[j] == target[i]:\n                    count += 1\n                    i += 1\n                    j += 1\n                else:\n                    return False\n            return count > 0\n        \n        while len(done) < m :\n            found = 0\n            for i in candidates:\n                if check(i):\n                    for j in range(i,i+n):\n                        done.add(j)\n                    res.append(i)\n                    found = 1\n                    break\n            if not found:\n                return []\n            else:\n                candidates.remove(i)\n                \n                    \n        return res[::-1]\n                \n            \n        \n        \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        if set(stamp) != set(target):\n            return []\n        done = set()\n        n = len(stamp)\n        m = len(target)\n        candidates = { i for i in range(m-n+1) }\n        res = []\n        \n        def check(i):\n            j = 0\n            count = 0\n            while j < n :\n                if i in done:\n                    j += 1\n                    i += 1\n                elif stamp[j] == target[i]:\n                    count += 1\n                    i += 1\n                    j += 1\n                else:\n                    return False\n            return count > 0\n        \n        while len(done) < m :\n            found = 0\n            for i in candidates:\n                if check(i):\n                    for j in range(i,i+n):\n                        done.add(j)\n                    res.append(i)\n                    found = 1\n                    break\n            if not found:\n                return []\n            else:\n                candidates.remove(i)\n                \n                    \n        return res[::-1]\n                \n            \n        \n        \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        ns = len(stamp)        \n        stamp_patterns = []\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.reverse()        \n\n        res = []\n        nt = len(target)\n\n        while target != '*' * nt:\n            old_target = target\n            # greedy, keep replace current target string with possible pattern\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        \n        return reversed(res)", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        memo, ls, lt = {}, len(stamp), len(target)\n        def dfs(s, t, seqs):\n            if t == lt:\n                memo[s, t] = seqs if s == ls else []\n            if (s, t) not in memo:\n                if s == ls:\n                    for i in range(ls):\n                        cand = dfs(i, t, [t-i]+seqs)\n                        if cand:\n                            memo[s, t] = cand\n                            break\n                    else: \n                        memo[s, t] = []\n                elif target[t] == stamp[s]:\n                    cand = dfs(s+1, t+1, seqs)\n                    memo[s, t] = cand if cand else dfs(0, t+1, seqs+[t+1])\n                else:\n                    memo[s, t] = []\n            return memo[s, t]\n        return dfs(0, 0, [0])", "class Solution:\n    def movesToStamp(self, stamp, target):\n        ns = len(stamp)        \n        stamp_patterns = []\n        # we need to collect all possible stamp patters, like\n        # 'abcde'\n        # 'abcd*'\n        # '*bcde'\n        # 'abc**'\n        # '**cde'\n        # 'ab***'\n        # '*bc**'\n        # '**cd*'\n        # '***de'\n        # \u2018****e\u2019 and etc\n        for window_size in range(1, ns + 1):\n            for i in range(ns - window_size + 1):\n                curr = '*' * i + stamp[i:i + window_size] + '*' * (ns - window_size - i)\n                stamp_patterns.append(curr)\n        stamp_patterns.append('*' * ns)\n\n        res = []\n        nt = len(target)\n        # '*****' is our final target\n        while target != '*' * nt:\n            old_target = target\n            # greedy, keep replace current target string with possible patter\n            for pattern in stamp_patterns:\n                inx = target.find(pattern)\n                if inx != -1:\n                    target = target[:inx] + '*' * ns + target[inx + ns:]\n                    res.append(inx)\n            if old_target == target:\n                return []\n        \n        return res[::-1]", "class Solution:\n    def movesToStamp(self, s: str, t: str) -> List[int]:\n        if s[0] != t[0] or s[-1] != t[-1]: return []\n        n, m = len(s), len(t)\n        path = [0] * m\n        pos = collections.defaultdict(set)\n        for i, c in enumerate(s): pos[c].add(i)\n\n        def dfs(i, index):\n            path[i] = index\n            if i == m - 1: return index == n - 1\n            nxt_index = set()\n            if index == n - 1:  # rule 2\n                nxt_index |= pos[t[i + 1]]\n            elif s[index + 1] == t[i + 1]:  # rule 0\n                nxt_index.add(index + 1)\n            if s[0] == t[i + 1]:  # rule 1\n                nxt_index.add(0)\n            return any(dfs(i + 1, j) for j in nxt_index)\n\n        def path2res(path):\n            down, up = [], []\n            for i in range(len(path)):\n                if path[i] == 0:\n                    up.append(i)\n                elif i and path[i] - 1 != path[i - 1]:\n                    down.append(i - path[i])\n            return down[::-1] + up\n\n        if not dfs(0, 0): return []\n        print(path)\n        return path2res(path)\n", "class Solution:\n    def movesToStamp(self, s, t):\n        if s[0] != t[0] or s[-1] != t[-1]: return []\n        n, m = len(s), len(t)\n        path = [0] * m\n        pos = collections.defaultdict(set)\n        for i, c in enumerate(s): pos[c].add(i)\n\n        def dfs(i, index):\n            path[i] = index\n            if i == m - 1: return index == n - 1\n            nxt_index = set()\n            if index == n - 1:  # rule 2\n                nxt_index |= pos[t[i + 1]]\n            elif s[index + 1] == t[i + 1]:  # rule 0\n                nxt_index.add(index + 1)\n            if s[0] == t[i + 1]:  # rule 1\n                nxt_index.add(0)\n            return any(dfs(i + 1, j) for j in nxt_index)\n\n        def path2res(path):\n            down, up = [], []\n            for i in range(len(path)):\n                if path[i] == 0:\n                    up.append(i)\n                elif i and path[i] - 1 != path[i - 1]:\n                    down.append(i - path[i])\n            return down[::-1] + up\n\n        if not dfs(0, 0): return []\n        return path2res(path)        ", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        stamp = list(stamp)\n        target = list(target)\n        result = []\n        \n        def change(i):\n            if target[i:i + m].count('?') == m:\n                return False\n            ch = False\n            for j in range(m):\n                if target[i + j] == '?':\n                    continue\n                if target[i + j] != stamp[j]:\n                    ch = False\n                    break\n                ch = True\n            if ch:\n                target[i:i + m] = ['?'] * m\n                result.append(i)\n            return ch\n        while True:\n            if not any(change(i) for i in range(n - m + 1)):\n                break\n        return reversed(result) if target.count('?') == n else []", "class Solution:\n    def movesToStamp(self, s: str, t: str) -> List[int]:\n        if s[0] != t[0] or s[-1] != t[-1]: return []\n        n, m = len(s), len(t)\n        path = [0] * m\n        pos = collections.defaultdict(set)\n        for i, c in enumerate(s): pos[c].add(i)\n\n        def dfs(i, index):\n            path[i] = index\n            if i == m - 1: return index == n - 1\n            nxt_index = set()\n            if index == n - 1:  # rule 2\n                nxt_index |= pos[t[i + 1]]\n            elif s[index + 1] == t[i + 1]:  # rule 0\n                nxt_index.add(index + 1)\n            if s[0] == t[i + 1]:  # rule 1\n                nxt_index.add(0)\n            return any(dfs(i + 1, j) for j in nxt_index)\n\n        def path2res(path):\n            down, up = [], []\n            for i in range(len(path)):\n                if path[i] == 0:\n                    up.append(i)\n                elif i and path[i] - 1 != path[i - 1]:\n                    down.append(i - path[i])\n            return down[::-1] + up\n\n        if not dfs(0, 0): return []\n        return path2res(path)", "class Solution:\n    def movesToStamp(self, s, t):\n        if s[0] != t[0] or s[-1] != t[-1]: return []\n        n, m = len(s), len(t)\n        path = [0] * m\n        pos = collections.defaultdict(set)\n        for i, c in enumerate(s): pos[c].add(i)\n\n        def dfs(i, index):\n            path[i] = index\n            if i == m - 1: return index == n - 1\n            nxt_index = set()\n            if index == n - 1:  # rule 2\n                nxt_index |= pos[t[i + 1]]\n            if index < n - 1 and s[index + 1] == t[i + 1]:  # rule 0\n                nxt_index.add(index + 1)\n            if s[0] == t[i + 1]:  # rule 1\n                nxt_index.add(0)\n            return any(dfs(i + 1, j) for j in nxt_index)\n\n        def path2res(path):\n            down, up = [], []\n            for i in range(len(path)):\n                if path[i] == 0:\n                    up.append(i)\n                elif i and path[i] - 1 != path[i - 1]:\n                    down.append(i - path[i])\n            return down[::-1] + up\n\n        if not dfs(0, 0): return []\n        return path2res(path)        ", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        done = set()\n        n = len(stamp)\n        m = len(target)\n        candidates = { i for i in range(m-n+1) }\n        res = []\n        \n        def check(i):\n            j = 0\n            count = 0\n            while j < n :\n                if i in done:\n                    j += 1\n                    i += 1\n                elif stamp[j] == target[i]:\n                    count += 1\n                    i += 1\n                    j += 1\n                else:\n                    return -1\n            if count == 0:\n                return 0\n            else:\n                return 1\n        \n        while len(done) < m :\n            found = 0\n            remove = set()\n            for i in candidates:\n                I = check(i)\n                if I == 1:\n                    for j in range(i,i+n):\n                        done.add(j)\n                    res.append(i)\n                    found = 1\n                    break\n                elif I == 0:\n                    remove.add(i)\n                    \n            if not found:\n                return []\n            else:\n                candidates.remove(i)\n                \n                    \n        return res[::-1]\n                \n            \n        \n        \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        s = set([stamp])\n        for i in range(len(stamp)):\n            for j in range(len(stamp), i, -1):\n                s.add('*'  * i + stamp[i:j] + '*' * (len(stamp) - j))\n        print(s)\n        \n        turns = 0\n        numStars = 0\n        ans = []\n        while turns <= 10 * len(target) and numStars != len(target):\n            # print(target)\n            replaced = False\n            numStars = 0\n            for i in range(len(target)):\n                if target[i] == '*':\n                    numStars += 1\n                if i >= len(target) - len(stamp) + 1:\n                    continue\n                if target[i:i + len(stamp)] in s:\n                    ans.append(i)\n                    replaced = True\n                    target = target[:i] + '*' * len(stamp) + target[i + len(stamp):]\n                    break\n            if not replaced and numStars != len(target):\n                return []\n            turns += 1\n            \n        if turns <= 10 * len(target):\n            ans.reverse()\n            return ans\n        else:\n            return []\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        m, n = len(stamp), len(target)\n        stamp = list(stamp)\n        target = list(target)\n        result = []\n        \n        def change(i):\n            if target[i:i + m].count('?') == m:\n                return False\n            if all(target[i + j] == '?' or target[i + j] == stamp[j] for j in range(m)):\n                target[i:i + m] = ['?'] * m\n                result.append(i)\n                return True\n            return False\n        while True:\n            if not any(change(i) for i in range(n - m + 1)):\n                break\n        return reversed(result) if target.count('?') == n else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        \n        partial_stamps, L, N = [stamp], len(stamp), len(target)\n        for covered_length in range(1, L):\n            for leading in range(covered_length+1):\n                prefix, postfix = '?'*leading, '?'*(covered_length-leading)\n                partial_stamps.append( prefix + stamp[leading:leading+L-covered_length] + postfix )\n        \n        reversed_positions, dest = [], '?'*N\n        while target != dest:\n            prev = target\n            for idx in range(N-L+1):\n                p = target[idx:idx+L]\n                for s in partial_stamps:\n                    if p == s:\n                        reversed_positions.append(idx)\n                        target = target[:idx] + '?'*L + target[idx+L:]\n                        break\n            if prev == target:\n                return []\n        return reversed_positions[::-1]\n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        done = set()\n        n = len(stamp)\n        m = len(target)\n        candidates = { i for i in range(m-n+1) }\n        res = []\n        \n        def check(i):\n            j = 0\n            count = 0\n            while j < n :\n                if i in done:\n                    j += 1\n                    i += 1\n                elif stamp[j] == target[i]:\n                    count += 1\n                    i += 1\n                    j += 1\n                else:\n                    return -1\n            if count == 0:\n                return 0\n            else:\n                return 1\n        \n        while len(done) < m :\n            found = 0\n            remove = set()\n            for i in candidates:\n                I = check(i)\n                if I == 1:\n                    for j in range(i,i+n):\n                        done.add(j)\n                    res.append(i)\n                    remove.add(i)\n                    found = 1\n                    break\n                elif I == 0:\n                    remove.add(i)\n                    \n            if not found:\n                return []\n            else:\n                candidates -= remove\n                \n                    \n        return res[::-1]\n                \n            \n        \n        \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        \n        M, N = len(stamp), len(target)\n        stamp, target = list(stamp), list(target)\n        \n        ans = []\n        \n        def check(i):\n            needsUpdate = False\n            for j in range(M):\n                if target[i+j] == '?':\n                    continue\n                if target[i+j] != stamp[j]:\n                    return False\n                needsUpdate = True\n            \n            if needsUpdate:\n                target[i:i+M] = '?' * M\n                ans.append(i)\n            return needsUpdate\n            \n        \n        changed = True\n        while changed:\n            changed = False\n            for i in range(N - M + 1):\n                if check(i):\n                    changed = True\n                    break\n\n        return ans[::-1] if target.count('?') == len(target) else []\n        \n", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        pos_detail = []\n        complete_cell = [False] * len(target)\n        check_next = []\n        steps = []\n        for i in range(len(target) - len(stamp) + 1):\n            match = set()\n            unmatch = set()\n            for j in range(len(stamp)):\n                if target[i + j] == stamp[j]:\n                    match.add(i + j)\n                else:\n                    unmatch.add(i + j)\n            pos_detail.append((match, unmatch))\n            if not unmatch:\n                steps.append(i)\n                for j in range(max(0, i - len(stamp) + 1),\n                               min(len(target) - len(stamp) + 1, i + len(stamp))):\n                    check_next.insert(0, j)\n                for j in range(len(stamp)):\n                    complete_cell[i + j] = True\n        while check_next:\n            i = check_next.pop(0)\n            match, unmatch = pos_detail[i]\n            if not unmatch:\n                continue\n            for j in range(len(stamp)):\n                if i + j in unmatch and complete_cell[i + j]:\n                    unmatch.remove(i + j)\n            if not unmatch and match:\n                steps.insert(0, i)\n                for j in range(len(stamp)):\n                    complete_cell[i + j] = True\n                for j in range(max(0, i - len(stamp) + 1),\n                               min(len(target) - len(stamp) + 1, i + len(stamp))):\n                    check_next.append(j)\n        return steps if all(complete_cell) else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        # work backward; time O(n(n-m)); space O(1)\n        n_s, n_t = len(stamp), len(target)\n        stamp, target = list(stamp), list(target)\n        \n        def check(idx):\n            match = False\n            for i in range(n_s):\n                if target[idx+i] == '?':\n                    continue\n                if target[idx+i] != stamp[i]:\n                    return False\n                match = True\n            if match:\n                target[idx:idx+n_s] = ['?'] * n_s\n                res.append(idx)\n            return match\n        \n        changed = True\n        res = []\n        while changed:\n            changed = False\n            for idx in range(n_t-n_s+1):\n                changed = changed or check(idx)\n        \n        return res[::-1] if target == ['?'] * n_t else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        # work backward; time O(n(n-m)); space O(1)\n        n_s, n_t = len(stamp), len(target)\n        stamp, target = list(stamp), list(target)\n        \n        def check(idx):\n            match = False\n            for j in range(n_s):\n                if target[idx+j] == '?': \n                    continue\n                if target[idx+j] != stamp[j]:\n                    return False\n                match = True\n            if match:\n                target[idx:idx+n_s] = ['?'] * n_s\n                res.append(idx)\n            return match\n        \n        changed = True\n        res = []\n        while changed:\n            changed = False\n            for idx in range(n_t - n_s + 1):\n                changed = changed or check(idx)\n        \n        return res[::-1] if target == ['?'] * n_t else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        # Time: O(T(T-S)*S); Space: O(S) #\n        # We iteratively find the stamp in target and replace the matched string to * \n        # we need to reverse the ans, because the first find ones would be the one that final filled as the assume target at begining is filled with all \\\"?\\\"\n        # we are filling it back\n        \n        M, N = len(stamp), len(target)\n        stamp = list(stamp)\n        target = list(target)\n        ans = []\n        \n        def check(i):\n            changed = False\n            for j in range(M):\n                if target[i+j] == \\\"?\\\":\n                    continue\n                if target[i+j] != stamp[j]:\n                    return False\n                changed = True\n            if changed:\n                target[i:i+M] = [\\\"?\\\"]*M\n                ans.append(i)\n            return changed\n        \n        changed = True\n        while changed:\n            changed = False\n            for i in range(N - M + 1):\n                changed = changed or check(i)\n        return ans[::-1] if target == [\\\"?\\\"]*N else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        # work backward\n        n_s, n_t = len(stamp), len(target)\n        stamp, target = list(stamp), list(target)\n        \n        def check(idx):\n            match = False\n            for j in range(n_s):\n                if target[idx+j] == '?': \n                    continue\n                if target[idx+j] != stamp[j]:\n                    return False\n                match = True\n            if match:\n                target[idx:idx+n_s] = ['?'] * n_s\n                res.append(idx)\n            return match\n        \n        changed = True\n        res = []\n        while changed:\n            changed = False\n            for idx in range(n_t - n_s + 1):\n                changed = changed or check(idx)\n        \n        return res[::-1] if target == ['?'] * n_t else []", "class Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        s,t = list(stamp),list(target)\n        n,m = len(s),len(t)\n        res = []\n        def check(i):\n            changed = False\n            for j in range(n):\n                if t[i+j] == '?':continue\n                if t[i+j] != s[j]:return False\n                else:\n                    changed = True\n            if changed:\n                t[i:i+n] = ['?']*n\n                res.append(i)\n            return changed\n        chan = True\n        while chan:\n            chan = False\n            for i in range(m-n+1):\n                chan = chan or check(i)\n        return res[::-1] if t == ['?']*m else []"]