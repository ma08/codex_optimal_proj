["from collections import defaultdict\nfrom itertools   import combinations\n\ndef norme(vect):          return sum( v**2 for v in vect )**.5\ndef vectorize(pt1, pt2):  return [b-a for a,b in zip(pt1, pt2)]\ndef isInCircle(d, r):     return d < r and (r-d)/r > 1e-10\ndef crossProd(v1, v2):    return [v1[0]*v2[1] - v1[1]*v2[0],\n                                  v1[1]*v2[2] - v1[2]*v2[1],\n                                  v1[2]*v2[0] - v1[0]*v2[2] ]\n\ndef biggest_triang_int(point_list, center, radius):\n    filteredPts = [ pt for pt in point_list if isInCircle(norme(vectorize(pt, center)), radius) ]\n    \n    dctTriangles = defaultdict(list)\n    for threePts in combinations(filteredPts, 3):\n        area = abs( norme(crossProd(vectorize(*threePts[:2]), vectorize(*threePts[1:]))) / 2.0 )\n        if area > 1e-8: dctTriangles[area].append(list(threePts))\n    \n    maxArea = max(dctTriangles.keys()) if dctTriangles else 0\n    return [] if not dctTriangles else [sum(map(len, dctTriangles.values())),\n                                        maxArea,\n                                        sorted(dctTriangles[maxArea]) if len(dctTriangles[maxArea]) > 1 else dctTriangles[maxArea][0] ]", "from itertools import combinations\n\nisclose=lambda a, b:abs(a-b)<=10e-6\ndistance = lambda a, b, c, d, e, f: ((d - a) ** 2 + (e - b) ** 2 + (f - c) ** 2) ** .5\n\ndef biggest_triang_int(points, center, r):\n    valid = [i for i in points if distance(*(i+center)) <= r]\n    filter_ = []\n    for (a,b,c) in combinations(valid, 3):\n        ab = distance(*(a+b))\n        bc = distance(*(b+c))\n        ac = distance(*(a+c))\n        if ab + bc > ac and ab + ac > bc and bc + ac > ab:\n            s = (ab + bc + ac) / 2\n            area = (s * (s - ab) * (s - bc) * (s - ac)) ** .5\n            filter_.append([[a, b, c], area])\n    \n    m = max(filter_, key=lambda x: x[1])[1] if filter_ else None\n    ans = sorted([i[0] for i in filter_ if isclose(i[1], m)])\n    \n    return [len(filter_), m, ans[0] if len(ans)==1 else ans] if m else []", "from math import sqrt\nfrom itertools import combinations\n\n\ndef sort_key(tri_list, tri):\n    '''Returns an integer found by concatenating the indecies of the points in\n    the triangle'''\n    x, y, z = tri\n    deg = len(str(len(tri_list)))\n    x_dex, y_dex, z_dex = tri_list.index(x), tri_list.index(y), tri_list.index(z)\n    return x_dex * 10 ** (3 * deg) + y_dex * 10 ** (2 * deg) + z_dex * 10 ** deg\n\n\ndef in_sphere(point, center, radius):\n    '''returns a True if the point is inside a sphere with given center and radius'''\n    return radius - distance(point, center) > 1 * 10 ** -10\n\n\ndef distance(point_1, point_2):\n    '''Returnse the distance between 2 points in space'''\n    x_1, y_1, z_1 = tuple(point_1)\n    x_2, y_2, z_2 = tuple(point_2)\n    \n    return sqrt( (x_2 - x_1) ** 2 + (y_2-y_1) ** 2 + (z_2 - z_1) ** 2)\n\n\ndef area(p1, p2, p3):\n    '''Returns the area of the triangle using Heron's Formula'''\n    # print(p1, p2, p3)\n    a = distance(p1, p2)\n    b = distance(p1, p3)\n    c = distance(p2, p3)\n    \n    s = (a + b + c)/2\n    \n    return sqrt(s * (s - a) * (s - b) * (s - c))\n\n\ndef format_output(triangle_list):\n    '''formats the output so it is either a list of 3 points or a\n    list of lists of 3 points\n    '''\n    list_out = []\n    for item in triangle_list:\n        list_out += [list(item)]\n    if len(list_out) == 1:\n        return list_out[0]\n    else:\n        return list_out\n\n\ndef biggest_triang_int(point_list, center, radius):\n    valid_points = [point for point in point_list if in_sphere(point, center, radius)]\n\n    if len(valid_points) < 3:\n        return []\n\n    triangles = [tri for tri in combinations(valid_points, r=3)]\n    areas = [[area(tri[0], tri[1], tri[2]), tri] for tri in triangles]\n\n    max_area = max(areas, key=lambda x: x[0])[0]\n    num_tri = len(triangles)\n\n    tri_w_max_area = [tri[1] for tri in areas if abs(tri[0] - max_area) < 10 ** -10]\n\n    tri_vert = sorted(tri_w_max_area, key=lambda x: sort_key(point_list, x))\n\n    tri_vert = format_output(tri_vert)\n\n    return [num_tri, max_area, tri_vert]\n", "from itertools import combinations\n\ndef distance(*pair):\n    return sum((u - v) ** 2 for u, v in zip(*pair)) ** .5\n\ndef area(*vertices):\n    sides = [distance(*p) for p in combinations(vertices, 2)]\n    return (sum(d**2for d in sides)**2 - 2 * sum(d**4for d in sides)) ** .5 / 4\n\ndef biggest_triang_int(point_list, center, radius):\n    points = [p for p in point_list if distance(center, p) < radius]\n    triangles = [[area(*t), list(t)] for t in combinations(points, 3)]\n    if not triangles: return []\n    max_area = max(triangles)[0]\n    best_triangles = [t for a, t in triangles if a == max_area]\n    return [len(triangles), max_area, best_triangles if len(best_triangles) > 1 else best_triangles.pop()]", "from itertools import combinations\nfrom math import sqrt\n\n\n# determinant of matrix a\ndef det(a):\n    return a[0][0]*a[1][1]*a[2][2] + \\\n           a[0][1]*a[1][2]*a[2][0] + \\\n           a[0][2]*a[1][0]*a[2][1] - \\\n           a[0][2]*a[1][1]*a[2][0] - \\\n           a[0][1]*a[1][0]*a[2][2] - \\\n           a[0][0]*a[1][2]*a[2][1]\n\n\n# unit normal vector of plane defined by points a, b, and c\ndef unit_normal(a, b, c):\n    x = det([[1, a[1], a[2]],\n             [1, b[1], b[2]],\n             [1, c[1], c[2]]])\n    y = det([[a[0], 1, a[2]],\n             [b[0], 1, b[2]],\n             [c[0], 1, c[2]]])\n    z = det([[a[0], a[1], 1],\n             [b[0], b[1], 1],\n             [c[0], c[1], 1]])\n    magnitude = (x**2 + y**2 + z**2)**.5\n    return x/magnitude, y/magnitude, z/magnitude\n\n\n# dot product of vectors a and b\ndef dot(a, b):\n    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n\n\n# cross product of vectors a and b\ndef cross(a, b):\n    x = a[1] * b[2] - a[2] * b[1]\n    y = a[2] * b[0] - a[0] * b[2]\n    z = a[0] * b[1] - a[1] * b[0]\n    return x, y, z\n\n\n# area of polygon poly\ndef area(poly):\n    if len(poly) < 3:  # not a plane - no area\n        return 0\n\n    total = [0, 0, 0]\n    for i in range(len(poly)):\n        vi1 = poly[i]\n        if i is len(poly)-1:\n            vi2 = poly[0]\n        else:\n            vi2 = poly[i+1]\n        prod = cross(vi1, vi2)\n        total[0] += prod[0]\n        total[1] += prod[1]\n        total[2] += prod[2]\n    result = dot(total, unit_normal(poly[0], poly[1], poly[2]))\n    return [abs(result/2), poly]\n\n\ndef distance(a, b):\n    pow_each = [pow(x, 2) for x in map(lambda x, y: x-y, a, b)]\n    sum_all = sum(pow_each)\n    return sqrt(sum_all)\n\n\ndef out_side(point, c, r):\n    return distance(point, c) <= r\n\n\ndef all_max(elements, key):\n    if not elements:\n        return 0, []\n    value = max(elements, key=key)[0]\n    results = [j for i, j in elements if i == value]\n    return value, results if len(results) > 1 else results[0]\n\n\ndef biggest_triang_int(point_list, center, radius):\n    valid_points = [x for x in point_list if out_side(x, center, radius)]\n    comb_elements = list(combinations(valid_points, 3))\n    results = [area(x) for x in list(map(list, comb_elements))]\n    result, poly = all_max(results, key=lambda x: x[0])\n    return [len(comb_elements), result, poly] if results else []\n", "import itertools\n\ndef in_sphere(point, center, radius):\n    dist = sum([(p-r)**2 for p,r in zip(point, center)])\n    dist = dist**0.5\n    return dist < radius and abs(dist-radius)/radius > 1e-10\n\ndef area(triangle_vertices):\n    l1 = sum((triangle_vertices[0][i] - triangle_vertices[1][i])**2 for i in range(3))**0.5\n    l2 = sum((triangle_vertices[0][i] - triangle_vertices[2][i])**2 for i in range(3))**0.5\n    l3 = sum((triangle_vertices[1][i] - triangle_vertices[2][i])**2 for i in range(3))**0.5\n    p = (l1+l2+l3)/2\n    A = (p*(p-l1)*(p-l2)*(p-l3))**0.5\n    return A\n\ndef biggest_triang_int(point_list, center, radius):\n    # your code here\n    interior_points = [p for p in point_list if in_sphere(p,center,radius)]\n    Triangles = []\n    for triplet in itertools.combinations(interior_points, 3):\n        Triangles.append((list(triplet), area(triplet)))\n    \n    num_tri = len(Triangles)\n    if num_tri < 1:\n        return []\n    max_a =  max(Triangles, key=lambda x: x[1])[1]\n    winners = [T[0] for T in Triangles if abs(T[1] - max_a) < 0.01]\n    if len(winners) == 1:\n        return [num_tri, max_a, winners[0]]\n    else:\n        return [num_tri, max_a, winners]\n    return 4\n", "import itertools as it\n\ndef biggest_triang_int(point_list, center, radius):\n\n    # Check the points that fall within the sphere\n    dtc = lambda p1, p2 : sum([(i - j)**2 for i, j in zip(p1, p2)])**(1.0/2)\n    valid_points = [point for point in point_list if dtc(center, point) < radius]\n    if len(valid_points) == 0: return []\n\n    # Check available triangles and save their areas\n    point_combinations = list(it.combinations(valid_points, 3))\n    areas = []\n    for i in point_combinations:\n        # Get triangle sides\n        a, b, c = dtc(i[0], i[1]), dtc(i[1],i[2]), dtc(i[2],i[0])\n        # Get triangle area using Heron's formula\n        S = (a+b+c)/2\n        areas.append(round((S*(S-a)*(S-b)*(S-c))**0.5, 8))\n\n    # Calculate final variables to be returned\n    pot_triangles, max_area, max_triangle_points = len(areas), max(areas), []\n    \n    if areas.count(max(areas)) == 1: max_triangle_points = list(point_combinations[areas.index(max(areas))])\n    else:\n        for c in range(areas.count(max(areas))):\n            max_triangle_points.append([i for i in point_combinations[areas.index(max(areas))]])\n            del point_combinations[areas.index(max(areas))]\n            del areas[areas.index(max(areas))]\n    \n    return [pot_triangles,max_area,max_triangle_points]", "def biggest_triang_int(points, ce, ra):\n    max=0; r=[]; le=len(points); count=0\n    for i in range(le):\n       for j in range (i+1,le):\n          for k in range (j+1,le):\n             po=[points[i],points[j],points[k]]\n             if distance(po[0],ce)<=ra and distance(po[1],ce)<=ra and distance(po[2],ce)<=ra:\n                count+=1\n                ae=areatriangle(po[0],po[1],po[2])\n                if ae>=max:\n                   if abs(ae-max)>1e-5: max=ae; r=[po]\n                   else: r.append(po)\n    if len(r)==1: r=r[0]\n    return [count,max,r] if count>0 else []\n\ndef areatriangle((x1,y1,z1),(x2,y2,z2),(x3,y3,z3)):  \n    a=distance((x1,y1,z1),(x2,y2,z2))  \n    b=distance((x2,y2,z2),(x3,y3,z3))  \n    c=distance((x3,y3,z3),(x1,y1,z1))  \n    return heron(a,b,c)  \n\ndef heron(a,b,c):  \n    s=(a+b+c)/2 \n    return (s*(s-a)*(s-b)*(s-c))**0.5        \n\ndef distance((x1,y1,z1),(x2,y2,z2)):    \n    return ((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)**.5", "from itertools import *\nfrom math import sqrt\n\ndef area_triang(a, b, c):\n    s = (a + b + c)/2\n    return sqrt(s * (s - a) * (s - b) * (s - c))\n\ndef calc_area(triangle):\n    A, B, C = triangle\n    c = sqrt(distance_sq(A, B))\n    b = sqrt(distance_sq(A, C))\n    a = sqrt(distance_sq(B, C))\n    return area_triang(a, b, c)\n\ndef distance_sq(point1, point2):\n    x1, y1, z1, = point1\n    x2, y2, z2 = point2\n    return (x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2\n\ndef combin(point_list,i):\n    return combinations(point_list, i)\n\ndef is_point_in_sphere(vert, center, r):\n    dd = distance_sq(vert, center)\n    return dd - r**2 < 0 and abs((sqrt(dd) - r) / r) > pow(10, -10)\n\ndef to_tup(point_list):\n    point_list_ = []\n    for point in point_list:\n        point_list_.append(tuple(point))\n    return point_list_\n\ndef triang_to_list(triang):\n    pointA, pointB, pointC = triang\n    return [list(pointA), list(pointB), list(pointC)]\n\ndef triangs_tolist(triang_list):\n    res = []\n    for triang in triang_list:\n        res.append(triang_to_list(triang))\n    return res\n\ndef biggest_triang_int(point_list, center, radius):\n    point_list_ = []\n    for point in point_list:\n        if not is_point_in_sphere(point, center, radius): continue\n        point_list_.append(point)\n    point_list_ = to_tup(point_list_)\n    triangs_area = {}\n    for comb in combin(point_list_, 3):\n        triangle  = tuple(comb)\n        area = calc_area(triangle)\n        if area < pow(10, -8): continue\n        triangs_area[triangle] = area\n    num_triangs = len(triangs_area)\n    if num_triangs == 0: return []\n    max_area = max(triangs_area.values())\n    res = [num_triangs, max_area]\n    sol = []\n    for triang, area in triangs_area.items():\n        if abs((area - max_area) / area) < pow(10, -10):\n            sol.append(list(triang))\n    if len(sol) == 1:\n        sol_one = triang_to_list(sol[0])\n        res.append(sol_one)\n        return res\n    else:\n        sol_plus = triangs_tolist(sol)\n        res.append(sol_plus)\n    sol_plus.sort()\n    return res", "import math\n \ndef dis_cal(start_pnt, end_pnt):\n    return math.sqrt((end_pnt[0] - start_pnt[0])**2 + (end_pnt[1] - start_pnt[1])**2  + (end_pnt[2] - start_pnt[2])**2) \n    \n\ndef filter_points(point_list, center, radius):\n    fnl_pnt = []\n    for pnt in point_list:\n        dis = dis_cal(center, pnt)\n        if dis < radius and ((dis - radius) / radius) > (2.718281828459045-10):\n            fnl_pnt.append(pnt)\n    return fnl_pnt                 \n       \ndef triangle_exist(points, triangle_lst):\n    for tria_lst in triangle_lst:\n        if points[0] in tria_lst[0] and points[1] in tria_lst[0] and points[2] in tria_lst[0]:\n            return False\n    return True            \nfrom itertools import combinations\n \ndef find_triangles(point_list):\n    fnl_pnt = []\n    max_val = 0\n    for (i, j, k) in combinations(point_list, 3):\n        ab = dis_cal(i, j)\n        bc = dis_cal(j, k)\n        ac = dis_cal(k, i)\n        if ab + bc > ac and ab + ac > bc and bc + ac > ab:                                        \n            ab_vec = [(j[0] - i[0]), (j[1] - i[1]), (j[2] - i[2])]\n            ac_vec = [(k[0] - i[0]), (k[1] - i[1]), (k[2] - i[2])]                                       \n            area =  math.sqrt((ab_vec[1]*ac_vec[2] - ac_vec[1]*ab_vec[2])**2 + (ab_vec[0]*ac_vec[2] - ac_vec[0]*ab_vec[2])**2 + (ab_vec[0]*ac_vec[1] - ac_vec[0]*ab_vec[1])**2 )\n            if area > (2.718281828459045-8):  \n                fnl_pnt.append(([i, j, k], area/2))\n                if area/2 > max_val:\n                    max_val = area/2    \n                    \n    max_traingle = []\n    for i in fnl_pnt:\n        if i[1] == max_val:\n            max_traingle.append(i[0])     \n    return len(fnl_pnt), max_traingle, max_val    \n\ndef biggest_triang_int(point_list, center, radius):\n    interior_points = filter_points(point_list, center, radius)  \n    num_triangle, max_triangles, max_val = find_triangles(interior_points)     \n    if len(max_triangles) == 1:\n        max_triangles = max_triangles[0]  \n    \n    if num_triangle ==0:\n        return []\n    return [num_triangle, max_val, max_triangles]"]