["# cook your dish here\ndef mergeSort(arr, n): \n    # A temp_arr is created to store \n    # sorted array in merge function \n    temp_arr = [0]*n \n    return _mergeSort(arr, temp_arr, 0, n-1) \n  \n# This Function will use MergeSort to count inversions \n  \ndef _mergeSort(arr, temp_arr, left, right): \n  \n    # A variable inv_count is used to store \n    # inversion counts in each recursive call \n  \n    inv_count = 0\n  \n    # We will make a recursive call if and only if \n    # we have more than one elements \n  \n    if left < right: \n  \n        # mid is calculated to divide the array into two subarrays \n        # Floor division is must in case of python \n  \n        mid = (left + right)//2\n  \n        # It will calculate inversion  \n        # counts in the left subarray \n  \n        inv_count += _mergeSort(arr, temp_arr,  \n                                    left, mid) \n  \n        # It will calculate inversion  \n        # counts in right subarray \n  \n        inv_count += _mergeSort(arr, temp_arr,  \n                                  mid + 1, right) \n  \n        # It will merge two subarrays in  \n        # a sorted subarray \n  \n        inv_count += merge(arr, temp_arr, left, mid, right) \n    return inv_count \n  \n# This function will merge two subarrays  \n# in a single sorted subarray \ndef merge(arr, temp_arr, left, mid, right): \n    i = left     # Starting index of left subarray \n    j = mid + 1 # Starting index of right subarray \n    k = left     # Starting index of to be sorted subarray \n    inv_count = 0\n  \n    # Conditions are checked to make sure that  \n    # i and j don't exceed their \n    # subarray limits. \n  \n    while i <= mid and j <= right: \n  \n        # There will be no inversion if arr[i] <= arr[j] \n  \n        if arr[i] <= arr[j]: \n            temp_arr[k] = arr[i] \n            k += 1\n            i += 1\n        else: \n            # Inversion will occur. \n            temp_arr[k] = arr[j] \n            inv_count += (mid-i + 1) \n            k += 1\n            j += 1\n  \n    # Copy the remaining elements of left  \n    # subarray into temporary array \n    while i <= mid: \n        temp_arr[k] = arr[i] \n        k += 1\n        i += 1\n  \n    # Copy the remaining elements of right  \n    # subarray into temporary array \n    while j <= right: \n        temp_arr[k] = arr[j] \n        k += 1\n        j += 1\n  \n    # Copy the sorted subarray into Original array \n    for loop_var in range(left, right + 1): \n        arr[loop_var] = temp_arr[loop_var] \n          \n    return inv_count \n    \nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int,input().split()))\n    print(mergeSort(a, n) )", "def mergeSort(arr, n): \n\ttemp_arr = [0]*n \n\treturn _mergeSort(arr, temp_arr, 0, n-1) \ndef _mergeSort(arr, temp_arr, left, right): \n\tinv_count = 0\n\tif left < right: \n\t\tmid = (left + right)//2\n\t\tinv_count += _mergeSort(arr, temp_arr, \n\t\t\t\t\t\t\t\t\tleft, mid) \n\t\tinv_count += _mergeSort(arr, temp_arr, \n\t\t\t\t\t\t\t\tmid + 1, right) \n\t\tinv_count += merge(arr, temp_arr, left, mid, right) \n\treturn inv_count \ndef merge(arr, temp_arr, left, mid, right): \n\ti = left\t # Starting index of left subarray \n\tj = mid + 1 # Starting index of right subarray \n\tk = left\t # Starting index of to be sorted subarray \n\tinv_count = 0\n\n\t# Conditions are checked to make sure that \n\t# i and j don't exceed their \n\t# subarray limits. \n\n\twhile i <= mid and j <= right: \n\n\t\t# There will be no inversion if arr[i] <= arr[j] \n\n\t\tif arr[i] <= arr[j]: \n\t\t\ttemp_arr[k] = arr[i] \n\t\t\tk += 1\n\t\t\ti += 1\n\t\telse: \n\t\t\t# Inversion will occur. \n\t\t\ttemp_arr[k] = arr[j] \n\t\t\tinv_count += (mid-i + 1) \n\t\t\tk += 1\n\t\t\tj += 1\n\n\t# Copy the remaining elements of left \n\t# subarray into temporary array \n\twhile i <= mid: \n\t\ttemp_arr[k] = arr[i] \n\t\tk += 1\n\t\ti += 1\n\n\t# Copy the remaining elements of right \n\t# subarray into temporary array \n\twhile j <= right: \n\t\ttemp_arr[k] = arr[j] \n\t\tk += 1\n\t\tj += 1\n\n\t# Copy the sorted subarray into Original array \n\tfor loop_var in range(left, right + 1): \n\t\tarr[loop_var] = temp_arr[loop_var] \n\t\t\n\treturn inv_count \n\n# Driver Code \n# Given array is \nfor _ in range(int(input())):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    result = mergeSort(arr, n) \n    print(result) \n", "# Python 3 program to count inversions in an array \r\n\r\n# Function to Use Inversion Count \r\ndef mergeSort(arr, n): \r\n\t# A temp_arr is created to store \r\n\t# sorted array in merge function \r\n\ttemp_arr = [0]*n \r\n\treturn _mergeSort(arr, temp_arr, 0, n-1) \r\n\r\n# This Function will use MergeSort to count inversions \r\n\r\ndef _mergeSort(arr, temp_arr, left, right): \r\n\r\n\t# A variable inv_count is used to store \r\n\t# inversion counts in each recursive call \r\n\r\n\tinv_count = 0\r\n\r\n\t# We will make a recursive call if and only if \r\n\t# we have more than one elements \r\n\r\n\tif left < right: \r\n\r\n\t\t# mid is calculated to divide the array into two subarrays \r\n\t\t# Floor division is must in case of python \r\n\r\n\t\tmid = (left + right)//2\r\n\r\n\t\t# It will calculate inversion \r\n\t\t# counts in the left subarray \r\n\r\n\t\tinv_count += _mergeSort(arr, temp_arr, \r\n\t\t\t\t\t\t\t\t\tleft, mid) \r\n\r\n\t\t# It will calculate inversion \r\n\t\t# counts in right subarray \r\n\r\n\t\tinv_count += _mergeSort(arr, temp_arr, \r\n\t\t\t\t\t\t\t\tmid + 1, right) \r\n\r\n\t\t# It will merge two subarrays in \r\n\t\t# a sorted subarray \r\n\r\n\t\tinv_count += merge(arr, temp_arr, left, mid, right) \r\n\treturn inv_count \r\n\r\n# This function will merge two subarrays \r\n# in a single sorted subarray \r\ndef merge(arr, temp_arr, left, mid, right): \r\n\ti = left\t # Starting index of left subarray \r\n\tj = mid + 1 # Starting index of right subarray \r\n\tk = left\t # Starting index of to be sorted subarray \r\n\tinv_count = 0\r\n\r\n\t# Conditions are checked to make sure that \r\n\t# i and j don't exceed their \r\n\t# subarray limits. \r\n\r\n\twhile i <= mid and j <= right: \r\n\r\n\t\t# There will be no inversion if arr[i] <= arr[j] \r\n\r\n\t\tif arr[i] <= arr[j]: \r\n\t\t\ttemp_arr[k] = arr[i] \r\n\t\t\tk += 1\r\n\t\t\ti += 1\r\n\t\telse: \r\n\t\t\t# Inversion will occur. \r\n\t\t\ttemp_arr[k] = arr[j] \r\n\t\t\tinv_count += (mid-i + 1) \r\n\t\t\tk += 1\r\n\t\t\tj += 1\r\n\r\n\t# Copy the remaining elements of left \r\n\t# subarray into temporary array \r\n\twhile i <= mid: \r\n\t\ttemp_arr[k] = arr[i] \r\n\t\tk += 1\r\n\t\ti += 1\r\n\r\n\t# Copy the remaining elements of right \r\n\t# subarray into temporary array \r\n\twhile j <= right: \r\n\t\ttemp_arr[k] = arr[j] \r\n\t\tk += 1\r\n\t\tj += 1\r\n\r\n\t# Copy the sorted subarray into Original array \r\n\tfor loop_var in range(left, right + 1): \r\n\t\tarr[loop_var] = temp_arr[loop_var] \r\n\t\t\r\n\treturn inv_count \r\n\r\n# Driver Code \r\n# Given array is \r\nfor _ in range(int(input())):\r\n    n=int(input())\r\n    arr=list(map(int,input().split()))\r\n    result = mergeSort(arr, n) \r\n    print(result) \r\n\r\n# This code is contributed by ankush_953 \r\n", "def trans(arr, n):\r\n\ttemp = [0]*n\r\n\treturn change(arr, temp, 0, n-1)\r\n\r\n\r\ndef change(arr, temp, left, right):\r\n\r\n\trep = 0\r\n\r\n\tif left < right:\r\n\r\n\t\tmid = (left + right)//2\r\n\r\n\t\trep += change(arr, temp,\r\n\t\t\t\t\t\t\t\t\tleft, mid)\r\n\r\n\t\trep += change(arr, temp,\r\n\t\t\t\t\t\t\t\tmid + 1, right)\r\n\r\n\t\trep += merge(arr, temp, left, mid, right)\r\n\treturn rep\r\n\r\ndef merge(arr, temp, left, mid, right):\r\n\ti = left\r\n\tj = mid + 1\r\n\tk = left\r\n\trep = 0\r\n\r\n\r\n\twhile i <= mid and j <= right:\r\n\r\n\t\tif arr[i] <= arr[j]:\r\n\t\t\ttemp[k] = arr[i]\r\n\t\t\tk += 1\r\n\t\t\ti += 1\r\n\t\telse:\r\n\t\t\ttemp[k] = arr[j]\r\n\t\t\trep += (mid-i + 1)\r\n\t\t\tk += 1\r\n\t\t\tj += 1\r\n\r\n\r\n\twhile i <= mid:\r\n\t\ttemp[k] = arr[i]\r\n\t\tk += 1\r\n\t\ti += 1\r\n\r\n\twhile j <= right:\r\n\t\ttemp[k] = arr[j]\r\n\t\tk += 1\r\n\t\tj += 1\r\n\r\n\tfor loop_var in range(left, right + 1):\r\n\t\tarr[loop_var] = temp[loop_var]\r\n\r\n\treturn rep\r\n\r\n\r\n\r\n\r\n\r\nt = int(input())\r\nfrom collections import defaultdict\r\n\r\nfor _ in range(t):\r\n    n = int(input())\r\n    arr=list(map(int,input().strip().split()))[:n]\r\n    result = trans(arr, n)\r\n    print(result)\r\n", "from sys import stdin, stdout\nfrom math import floor, gcd, fabs, factorial, fmod, sqrt, inf, log\nfrom collections import defaultdict as dd, deque\nfrom heapq import merge, heapify, heappop, heappush, nsmallest\nfrom bisect import bisect_left as bl, bisect_right as br, bisect\nmod = pow(10, 9) + 7\nmod2 = 998244353\ndef inp(): return stdin.readline().strip()\ndef out(var, end=\"\\n\"): stdout.write(str(var)+\"\\n\")\ndef outa(*var, end=\"\\n\"): stdout.write(' '.join(map(str, var)) + end)\ndef lmp(): return list(mp())\ndef mp(): return map(int, inp().split())\ndef smp(): return map(str, inp().split())\ndef l1d(n, val=0): return [val for i in range(n)]\ndef l2d(n, m, val=0): return [l1d(n, val) for j in range(m)]\ndef remadd(x, y): return 1 if x%y else 0\ndef ceil(a,b): return (a+b-1)//b\n\ndef isprime(x):\n    if x<=1: return False\n    if x in (2, 3): return True\n    if x%2 == 0: return False\n    for i in range(3, int(sqrt(x))+1, 2):\n        if x%i == 0: return False\n    return True\n\ndef mergeSort(arr, n): \n    temp_arr = [0]*n \n    return _mergeSort(arr, temp_arr, 0, n-1) \n  \ndef _mergeSort(arr, temp_arr, left, right): \n    inv_count = 0\n    if left < right: \n        mid = (left + right)//2\n        inv_count += _mergeSort(arr, temp_arr,  \n                                    left, mid) \n        inv_count += _mergeSort(arr, temp_arr,  \n                                  mid + 1, right) \n        inv_count += merge(arr, temp_arr, left, mid, right) \n    return inv_count \n\ndef merge(arr, temp_arr, left, mid, right): \n    i = left    \n    j = mid + 1\n    k = left    \n    inv_count = 0\n    while i <= mid and j <= right: \n        if arr[i] <= arr[j]: \n            temp_arr[k] = arr[i] \n            k += 1\n            i += 1\n        else: \n            temp_arr[k] = arr[j] \n            inv_count += (mid-i + 1) \n            k += 1\n            j += 1\n    while i <= mid: \n        temp_arr[k] = arr[i] \n        k += 1\n        i += 1\n    while j <= right: \n        temp_arr[k] = arr[j] \n        k += 1\n        j += 1\n    for loop_var in range(left, right + 1): \n        arr[loop_var] = temp_arr[loop_var] \n    return inv_count     \n\nfor _ in range(int(inp())):\n    n = int(inp())\n    arr = lmp()\n    print(mergeSort(arr, n))", "# Python 3 program to count inversions in an array \n\n# Function to Use Inversion Count \ndef mergeSort(arr, n): \n\t# A temp_arr is created to store \n\t# sorted array in merge function \n\ttemp_arr = [0]*n \n\treturn _mergeSort(arr, temp_arr, 0, n-1) \n\n# This Function will use MergeSort to count inversions \n\ndef _mergeSort(arr, temp_arr, left, right): \n\n\t# A variable inv_count is used to store \n\t# inversion counts in each recursive call \n\n\tinv_count = 0\n\n\t# We will make a recursive call if and only if \n\t# we have more than one elements \n\n\tif left < right: \n\n\t\t# mid is calculated to divide the array into two subarrays \n\t\t# Floor division is must in case of python \n\n\t\tmid = (left + right)//2\n\n\t\t# It will calculate inversion \n\t\t# counts in the left subarray \n\n\t\tinv_count += _mergeSort(arr, temp_arr, \n\t\t\t\t\t\t\t\t\tleft, mid) \n\n\t\t# It will calculate inversion \n\t\t# counts in right subarray \n\n\t\tinv_count += _mergeSort(arr, temp_arr, \n\t\t\t\t\t\t\t\tmid + 1, right) \n\n\t\t# It will merge two subarrays in \n\t\t# a sorted subarray \n\n\t\tinv_count += merge(arr, temp_arr, left, mid, right) \n\treturn inv_count \n\n# This function will merge two subarrays \n# in a single sorted subarray \ndef merge(arr, temp_arr, left, mid, right): \n\ti = left\t # Starting index of left subarray \n\tj = mid + 1 # Starting index of right subarray \n\tk = left\t # Starting index of to be sorted subarray \n\tinv_count = 0\n\n\t# Conditions are checked to make sure that \n\t# i and j don't exceed their \n\t# subarray limits. \n\n\twhile i <= mid and j <= right: \n\n\t\t# There will be no inversion if arr[i] <= arr[j] \n\n\t\tif arr[i] <= arr[j]: \n\t\t\ttemp_arr[k] = arr[i] \n\t\t\tk += 1\n\t\t\ti += 1\n\t\telse: \n\t\t\t# Inversion will occur. \n\t\t\ttemp_arr[k] = arr[j] \n\t\t\tinv_count += (mid-i + 1) \n\t\t\tk += 1\n\t\t\tj += 1\n\n\t# Copy the remaining elements of left \n\t# subarray into temporary array \n\twhile i <= mid: \n\t\ttemp_arr[k] = arr[i] \n\t\tk += 1\n\t\ti += 1\n\n\t# Copy the remaining elements of right \n\t# subarray into temporary array \n\twhile j <= right: \n\t\ttemp_arr[k] = arr[j] \n\t\tk += 1\n\t\tj += 1\n\n\t# Copy the sorted subarray into Original array \n\tfor loop_var in range(left, right + 1): \n\t\tarr[loop_var] = temp_arr[loop_var] \n\t\t\n\treturn inv_count \n\nfor i in range(int(input())):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    result = mergeSort(arr, n) \n    print( result) \n\n\n", "def merge(A, aux, low, mid, high):\r\n \r\n    k = i = low\r\n    j = mid + 1\r\n    inversionCount = 0\r\n \r\n    # While there are elements in the left and right runs\r\n    while i <= mid and j <= high:\r\n        if A[i] <= A[j]:\r\n            aux[k] = A[i]\r\n            i = i + 1\r\n        else:\r\n            aux[k] = A[j]\r\n            j = j + 1\r\n            inversionCount += (mid - i + 1)  # NOTE\r\n \r\n        k = k + 1\r\n \r\n    # Copy remaining elements\r\n    while i <= mid:\r\n        aux[k] = A[i]\r\n        k = k + 1\r\n        i = i + 1\r\n \r\n    # Don't need to copy second half\r\n \r\n    # copy back to the original list to reflect sorted order\r\n    for i in range(low, high + 1):\r\n        A[i] = aux[i]\r\n \r\n    return inversionCount\r\n \r\n \r\n# Sort list [low..high] using auxiliary space aux\r\ndef mergeSort(A, aux, low, high):\r\n \r\n    # Base case\r\n    if high == low:  # if run size == 1\r\n        return 0\r\n \r\n    # find mid point\r\n    mid = low + ((high - low) >> 1)\r\n    inversionCount = 0\r\n \r\n    # recursively split runs into two halves until run size == 1,\r\n    # then merge them and return back up the call chain\r\n \r\n    inversionCount += mergeSort(A, aux, low, mid)        # split / merge left half\r\n    inversionCount += mergeSort(A, aux, mid + 1, high)   # split / merge right half\r\n    inversionCount += merge(A, aux, low, mid, high)      # merge the two half runs\r\n \r\n    return inversionCount\r\n \r\nfor _ in range(int(input())):\r\n    n=int(input())\r\n    l=list(map(int,input().split()))\r\n    aux=l.copy()\r\n    print(mergeSort(l,aux,0,len(l)-1))", "# Function to Use Inversion Count \r\ndef mergeSort(arr, n):\r\n    # A temp_arr is created to store \r\n    # sorted array in merge function \r\n    temp_arr = [0] * n\r\n    return _mergeSort(arr, temp_arr, 0, n - 1)\r\n\r\n\r\n# This Function will use MergeSort to count inversions \r\n\r\ndef _mergeSort(arr, temp_arr, left, right):\r\n    # A variable inv_count is used to store \r\n    # inversion counts in each recursive call \r\n\r\n    inv_count = 0\r\n\r\n    # We will make a recursive call if and only if \r\n    # we have more than one elements \r\n\r\n    if left < right:\r\n        # mid is calculated to divide the array into two subarrays \r\n        # Floor division is must in case of python \r\n\r\n        mid = (left + right) // 2\r\n\r\n        # It will calculate inversion  \r\n        # counts in the left subarray \r\n\r\n        inv_count += _mergeSort(arr, temp_arr,\r\n                                left, mid)\r\n\r\n        # It will calculate inversion  \r\n        # counts in right subarray \r\n\r\n        inv_count += _mergeSort(arr, temp_arr,\r\n                                mid + 1, right)\r\n\r\n        # It will merge two subarrays in  \r\n        # a sorted subarray \r\n\r\n        inv_count += merge(arr, temp_arr, left, mid, right)\r\n    return inv_count\r\n\r\n\r\n# This function will merge two subarrays  \r\n# in a single sorted subarray \r\ndef merge(arr, temp_arr, left, mid, right):\r\n    i = left  # Starting index of left subarray \r\n    j = mid + 1  # Starting index of right subarray \r\n    k = left  # Starting index of to be sorted subarray \r\n    inv_count = 0\r\n\r\n    # Conditions are checked to make sure that  \r\n    # i and j don't exceed their \r\n    # subarray limits. \r\n\r\n    while i <= mid and j <= right:\r\n\r\n        # There will be no inversion if arr[i] <= arr[j] \r\n\r\n        if arr[i] <= arr[j]:\r\n            temp_arr[k] = arr[i]\r\n            k += 1\r\n            i += 1\r\n        else:\r\n            # Inversion will occur. \r\n            temp_arr[k] = arr[j]\r\n            inv_count += (mid - i + 1)\r\n            k += 1\r\n            j += 1\r\n\r\n    # Copy the remaining elements of left  \r\n    # subarray into temporary array \r\n    while i <= mid:\r\n        temp_arr[k] = arr[i]\r\n        k += 1\r\n        i += 1\r\n\r\n    # Copy the remaining elements of right  \r\n    # subarray into temporary array \r\n    while j <= right:\r\n        temp_arr[k] = arr[j]\r\n        k += 1\r\n        j += 1\r\n\r\n    # Copy the sorted subarray into Original array \r\n    for loop_var in range(left, right + 1):\r\n        arr[loop_var] = temp_arr[loop_var]\r\n\r\n    return inv_count\r\n\r\nfor _ in range(int(input())):\r\n    n=int(input())\r\n    arr = list(map(int,input().split()))\r\n    print(mergeSort(arr, n))\r\n", "#https://www.geeksforgeeks.org/counting-inversions/\r\nfrom sys import stdin, stdout\r\ndef mergeSort(arr, n): \r\n\ttemp_arr = [0]*n \r\n\treturn _mergeSort(arr, temp_arr, 0, n-1) \r\ndef _mergeSort(arr, temp_arr, left, right): \r\n\tinv_count = 0\r\n\tif left < right: \r\n\t\tmid = (left + right)//2\r\n\t\tinv_count += _mergeSort(arr, temp_arr, \r\n\t\t\t\t\t\t\t\t\tleft, mid) \r\n\t\tinv_count += _mergeSort(arr, temp_arr, \r\n\t\t\t\t\t\t\t\tmid + 1, right) \r\n\t\tinv_count += merge(arr, temp_arr, left, mid, right) \r\n\treturn inv_count \r\ndef merge(arr, temp_arr, left, mid, right): \r\n\ti = left\t \r\n\tj = mid + 1  \r\n\tk = left\t \r\n\tinv_count = 0\r\n\twhile i <= mid and j <= right: \r\n\t\tif arr[i] <= arr[j]: \r\n\t\t\ttemp_arr[k] = arr[i] \r\n\t\t\tk += 1\r\n\t\t\ti += 1\r\n\t\telse: \r\n\t\t\ttemp_arr[k] = arr[j] \r\n\t\t\tinv_count += (mid-i + 1) \r\n\t\t\tk += 1\r\n\t\t\tj += 1\r\n\twhile i <= mid: \r\n\t\ttemp_arr[k] = arr[i] \r\n\t\tk += 1\r\n\t\ti += 1\r\n\twhile j <= right: \r\n\t\ttemp_arr[k] = arr[j] \r\n\t\tk += 1\r\n\t\tj += 1\r\n\tfor loop_var in range(left, right + 1): \r\n\t\tarr[loop_var] = temp_arr[loop_var] \r\n\treturn inv_count \r\ntest = int(stdin.readline())\r\nfor _ in range(test):\r\n    n = int(stdin.readline())\r\n    arr = list(map(int, stdin.readline().split()))\r\n    result = mergeSort(arr, n) \r\n    print(result) ", "def count_inversions(a):\n  res = 0\n  counts = [0]*(len(a)+1)\n  rank = { v : i+1 for i, v in enumerate(sorted(a)) }\n  for x in reversed(a):\n    i = rank[x] - 1\n    while i:\n      res += counts[i]\n      i -= i & -i\n    i = rank[x]\n    while i <= len(a):\n      counts[i] += 1\n      i += i & -i\n  return res\n  \nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int,input().split()))\n    print(count_inversions(a))"]