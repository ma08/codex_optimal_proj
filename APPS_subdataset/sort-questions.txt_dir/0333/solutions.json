["from collections import deque\n\nclass Solution:\n    def minJumps(self, arr: list) -> int:\n        if len(arr) == 1:\n            return 0\n        graph = {}\n        for i, n in enumerate(arr):\n            if n in graph:\n                graph[n].append(i)\n            else:\n                graph[n] = [i]\n        \n        curs = [0]\n        other = [len(arr)-1]\n        visited = {0}\n        visited2 = {len(arr)-1}\n        step = 0\n        while curs:\n            if len(curs) > len(other):\n                curs, other = other, curs\n                visited, visited2 = visited2, visited\n            nex = []\n            for node in curs:\n                for child in graph[arr[node]]:\n                    if child in visited2:\n                        return step + 1\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                for child in [node-1, node+1]:\n                    if child in visited2:\n                        return step + 1\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n            curs = nex\n            step += 1\n        return -1\n                    \n                    \n            \n            \n", "from collections import deque\n\nclass Solution:\n    def minJumps(self, arr: list) -> int:\n        if len(arr) == 1:\n            return 0\n        graph = {}\n        for i, n in enumerate(arr):\n            if n in graph:\n                graph[n].append(i)\n            else:\n                graph[n] = [i]\n        \n        curs = [0]\n        other = [len(arr)-1]\n        visited = {0}\n        visited2 = {len(arr)-1}\n        step = 0\n        while curs:\n            is_curs = len(curs) <= len(other)\n            if not is_curs:\n                curs, other = other, curs\n                visited, visited2 = visited2, visited\n            nex = []\n\n            for node in curs:\n                for child in graph[arr[node]]:\n                    if child in visited2:\n                        return step + 1\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                for child in [node-1, node+1]:\n                    if child in visited2:\n                        return step + 1\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n            curs = nex\n            step += 1\n        return -1\n                    \n                    \n            \n            \n", "class Solution:\n    # bidirectional, best 416 ms, memory 99.90%\n    def minJumps(self, arr):\n        length = len(arr)\n        # if no any connection in nodes, answer equals to array length - 1\n        if len(set(arr)) == length: return length - 1\n        if arr[0] == arr[-1]: return 1\n\n        _map = defaultdict(set) # connection map\n        for i, val in enumerate(arr): _map[val].add(i)\n\n        # BFS, seen: visited index, visit: visited connection\n        res, seen, visit = 0, {0}, set()\n        # curs: nodes in current side level, other: nodes in opposite side\n        curs, other = {0}, {length - 1}\n        while curs:\n            res += 1\n            # store found nodes in this level\n            thisLevel = set()\n            for i in curs:\n                # check move backwards \n                if i - 1 > 0 and i - 1 not in seen: \n                    thisLevel.add(i - 1)\n                # check in place\n                if arr[i] in _map:\n                    thisLevel |= (_map[arr[i]] - seen) \n                    visit.add(arr[i])\n                    del _map[arr[i]]\n                # check move forwards\n                if i + 1 < length and i + 1 not in seen: \n                    thisLevel.add(i + 1)\n\n            # check if this level and the other side intersect\n            if thisLevel & other: return res  \n\n            # update current side for next round          \n            curs = thisLevel\n            # choose smaller side into next round \n            if len(curs) > len(other): curs, other = other, curs\n            # if we don't exchange, put found nodes into seen\n            # because they are found in current direction\n            else: seen |= thisLevel", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        connected = collections.defaultdict(list)\n        _ = [connected[v].append(i) for i, v in enumerate(arr)]\n        \n        queue, pos_visited = [0], set([0])\n        steps = 0\n        \n        while queue:\n            next_steps = []\n            for cur_pos in queue:\n                if cur_pos == len(arr) - 1: return steps\n                next_steps += [cur_pos - 1, cur_pos + 1] + connected[arr[cur_pos]]\n                connected[arr[cur_pos]].clear()\n            queue = []\n            for _ in next_steps:\n                if _ >= 0 and _ < len(arr) and _ not in pos_visited:\n                    queue.append(_)\n                    pos_visited.add(_)\n            steps += 1\n        return steps\n                \n", "class Solution:\n    def minJumps(self, arr):\n        n = len(arr)\n        if n == 1: return 0 \n        d = defaultdict(list)\n        for i,val in enumerate(arr):\n            d[val].append(i)\n        visited = set([0])\n        stack = deque([0])\n        k, jumps = len(stack), 1\n        while stack:\n            i = stack.popleft()\n            childs = [j for j in [i-1,i+1] if arr[j] != arr[i]] + [j for j in d.pop(arr[i],[])]\n            childs = [j for j in childs if 0 <= j < n and j not in visited]\n            for j in childs:\n                if j == n-1: return jumps\n                visited.add(j)\n                stack.append(j)\n            k -= 1\n            if not k:\n                k = len(stack)\n                jumps += 1\n        return jumps", "from collections import defaultdict\nclass Solution:\n    def get_jump_indices(self, arr):\n        jump_indices = defaultdict(set)\n        for i, val in enumerate(arr):\n            jump_indices[val].add(i)\n        return jump_indices\n    def minJumps(self, arr: List[int]) -> int:\n        # Dictionary from array value to set of jumpable indices\n        jump_indices = self.get_jump_indices(arr)\n        next_indices = [len(arr) - 1]\n        visited = set()\n        visited.add(len(arr) - 1)\n        jumps = 0\n        while next_indices:\n            reachable_indices_set = set()\n            for index in next_indices:\n                if index == 0:\n                    return jumps\n                reachable_indices = jump_indices[arr[index]].copy()\n                reachable_indices.remove(index)\n                reachable_indices.add(index - 1)\n                if index != len(arr) - 1:\n                    reachable_indices.add(index + 1)\n                for reachable_index in reachable_indices:\n                    if reachable_index in visited:\n                        continue\n                    visited.add(reachable_index)\n                    reachable_indices_set.add(reachable_index)\n            next_indices = list(reachable_indices_set)\n            jumps += 1\n        return None", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        v2n = collections.defaultdict(set)\n        for i, v in enumerate(arr):\n            if 0 < i < len(arr) - 1 and arr[i - 1] == v and arr[i + 1] == v:\n                continue\n            v2n[v].add(i)\n        visited, seen, q, step = set([0]), set(), collections.deque([0]), 0\n        while q:\n            for _ in range(len(q)):\n                cur = q.popleft()\n                if cur == len(arr) - 1: return step\n                neighbors = set([cur + 1, cur - 1] + [x for x in v2n[arr[cur]]])\n                for nb in neighbors:\n                    if nb >= 0 and nb < len(arr) and nb != cur and nb not in visited:\n                        visited.add(cur)\n                        q.append(nb)\n                # seen.add(cur)\n            step += 1\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if not arr or len(arr)==1:\n            return 0\n        \n        dp=[float('inf')]*len(arr)\n        dp[0]=0\n        \n        position=collections.defaultdict(set)\n        visited={}\n        for i,e in enumerate(arr):\n            position[e].add(i)\n            visited[i]=False\n        visited[0]=True\n        \n        start={0}\n        step=0\n        while start:\n            nextstart=set()\n            for i in start:\n                \n                if i==len(arr)-1:\n                    return step\n                \n                if i-1>=0 and not visited[i-1]:\n                    dp[i-1]=min(dp[i-1],dp[i]+1)\n                    nextstart.add(i-1)\n                    visited[i-1]=True\n                if i+1<len(arr) and not visited[i+1]:\n                    dp[i+1]=min(dp[i+1],dp[i]+1)\n                    nextstart.add(i+1)\n                    visited[i+1]=True\n                for p in position[arr[i]]:\n                    if p!=i and not visited[p]:\n                        dp[p]=min(dp[p],dp[i]+1)\n                        nextstart.add(p)\n                        visited[p]=True\n                position[arr[i]].clear()\n\n            start=nextstart\n            step+=1\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n  \n        \n        \n        val_to_ids = collections.defaultdict(list)\n        _ = [val_to_ids[x].append(i) for i, x in enumerate(arr)]\n        \n        # print(val_to_ids)\n        queue = collections.deque([(0, 0)])\n        positions_seen = set()\n        num_met = set()\n        while queue:\n            i, dis = queue.popleft()\n            if i == len(arr) - 1:\n                return dis\n            val = arr[i]\n            positions_seen.add(i)\n            \n            possible_indexes = []\n            possible_indexes.append(i + 1)\n            possible_indexes.append(i - 1)\n            \n            if len(val_to_ids[val]) > 1:\n                for idx in val_to_ids[val]:\n                    if idx not in positions_seen:\n                        possible_indexes.append(idx)\n                del val_to_ids[val]\n\n            for p in possible_indexes:\n                if p < 0 or p > len(arr) or p in positions_seen:\n                    continue\n                queue.append((p, dis+1))\n            \n\n        \n#         nei = collections.defaultdict(list)\n#         _ = [nei[x].append(i) for i, x in enumerate(arr)]\n\n#         frontier = collections.deque([(0,0)])\n#         num_met, pos_met = set(), set()\n#         while frontier:\n#             pos, step = frontier.popleft() # state: position, step\n#             if pos == len(arr) - 1: return step\n#             num = arr[pos]\n#             pos_met.add(pos) # track explored positions\n\n#             for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\n#                 if p in pos_met or not 0 <= p < len(arr): continue\n#                 frontier.append((p, step + 1))\n\n#             num_met.add(num) # track explored values\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # corner case\n        if len(arr) == 1:\n            return 0\n        \n        # create a better lookup data structure\n        dict_ = collections.defaultdict(list)\n        for index in range(len(arr)):\n            dict_[arr[index]].append(index)\n        \n        #print(dict_)\n            \n        # a variable to save ans\n        min_count = 0\n        \n        # remember visited points\n        visited = set()\n        visited.add((arr[0], 0))\n        \n        # bfs\n        queue = collections.deque()\n        queue.append((arr[0], 0))\n        \n        while queue:\n            #print(queue)\n            size = len(queue)\n            # spread the nodes at the same level\n            for i in range(size):\n                curr_num, index = queue.popleft()\n                #print(\\\"index: \\\",index)\n                # reach the condition \n                if index == len(arr) - 1:\n                    return min_count\n                # add unvisited neighbor points to the queue\n                for new_num, new_index in self.move(curr_num, index, arr, dict_,visited):\n                    if (new_num, new_index) not in visited:\n                        #print(\\\"new_index: \\\", new_index)\n                        visited.add((new_num,new_index))\n                        queue.append((new_num, new_index))                                 \n            min_count = min_count + 1\n        \n    \n    def move(self, curr_num, index, arr, dict_, visited):\n            for new_num, new_index in [(arr[index - 1], index - 1), (arr[index+1], index + 1)]:\n                if 0 <= new_index < len(arr) and (new_num, new_index) not in visited:\n                    yield new_num, new_index\n            if dict_[curr_num]:\n                new_num = curr_num\n                for new_index in dict_[curr_num]:\n                    if 0 <= new_index < len(arr) and (new_num, new_index) not in visited:\n                        yield new_num, new_index\n                del dict_[curr_num]", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # corner case\n        if len(arr) == 1:\n            return 0\n        \n        # create a better lookup data structure\n        dict_ = collections.defaultdict(list)\n        for index in range(len(arr)):\n            dict_[arr[index]].append(index)\n        \n        #print(dict_)\n            \n        # a variable to save ans\n        min_count = 0\n        \n        # remember visited points\n        visited = set()\n        visited.add((arr[0], 0))\n        \n        # bfs\n        queue = collections.deque()\n        queue.append((arr[0], 0))\n        \n        while queue:\n            #print(queue)\n            size = len(queue)\n            # spread the nodes at the same level\n            for i in range(size):\n                curr_num, index = queue.popleft()\n                #print(\\\"index: \\\",index)\n                # reach the condition \n                if index == len(arr) - 1:\n                    return min_count\n                # add unvisited neighbor points to the queue\n                for new_num, new_index in self.move(curr_num, index, arr, dict_,visited):\n                    if (new_num, new_index) not in visited:\n                        #print(\\\"new_index: \\\", new_index)\n                        visited.add((new_num,new_index))\n                        queue.append((new_num, new_index))                                 \n            min_count = min_count + 1\n        \n    \n    def move(self, curr_num, index, arr, dict_, visited):\n            for new_num, new_index in [(arr[index - 1], index - 1), (arr[index+1], index + 1)]:\n                if 0 <= new_index < len(arr) and (new_num, new_index) not in visited:\n                    yield new_num, new_index\n            if dict_[curr_num]:\n                for new_index in dict_[curr_num]:\n                    new_num = curr_num\n                    if 0 <= new_index < len(arr) and (new_num, new_index) not in visited:\n                        yield new_num, new_index\n                del dict_[curr_num]", "class Solution:\n    # bidirectional, best 416 ms, memory 99.90%\n    def minJumps(self, arr):\n        length = len(arr)\n        # if no any connection in nodes, answer equals to array length\n        if len(set(arr)) == length: return length - 1\n        if arr[0] == arr[-1]: return 1\n\n        _map = defaultdict(set) # connection map\n        for i, val in enumerate(arr): _map[val].add(i)\n\n        # BFS, seen: visited index, visit: visited connection\n        res, seen, visit = 0, {0}, set()\n        # curs: nodes in current side level, other: nodes in opposite side\n        curs, other = {0}, {length - 1}\n        while curs:\n            res += 1\n            # store found nodes in this level\n            thisLevel = set()\n            for i in curs:\n                # check move backwards \n                if i - 1 > 0 and i - 1 not in seen: \n                    thisLevel.add(i - 1)\n                # check in place\n                if arr[i] not in visit: # here can change into \\\"arr[i] in _map: del _map[arr[i]]\\\"\n                    thisLevel |= (_map[arr[i]] - seen) \n                    visit.add(arr[i])\n                # check move forwards\n                if i + 1 < length and i + 1 not in seen: \n                    thisLevel.add(i + 1)\n\n            # check if this level and the other side intersect\n            if thisLevel & other: return res  \n\n            # update current side for next round          \n            curs = thisLevel\n            # choose smaller side into next round \n            if len(curs) > len(other): curs, other = other, curs\n            # if we don't exchange, put found nodes into seen\n            # because they are found in current direction\n            else: seen |= thisLevel", "#Bidirectional BFS\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:        \n        if len(arr) < 2:\n            return 0\n        \n        graph = {} #\u5b58\u6bcf\u500b\u503c\u7684index\n        for i in range(len(arr)):\n            if arr[i] in graph:\n                graph[arr[i]].append(i)\n            else:\n                graph[arr[i]] = [i]\n                \n        cur = [0] #\u76ee\u524d\u9019\u6b65\u8981\u62dc\u8a2a\u7684index\n        visited = {0}\n        step = 0\n        \n        other = [len(arr) - 1] #\u53e6\u4e00\u500b\u6c92\u8d70\u904e\u7684\u90e8\u5206\n        \n        while cur:\n            #\u5f9e\u8f03\u5c0f\u7684\u958b\u59cb\u641c\u5c0b\n            if len(cur) > len(other):\n                cur, other = other, cur\n            \n            nex = [] #\u4e0b\u4e00\u6b65\u8981\u62dc\u8a2a\u7684index\n            \n            for i in cur:\n                # check same value\n                for node in graph[arr[i]]:\n                    if node in other:\n                        return step + 1\n                    if node not in visited:\n                        visited.add(node)\n                        nex.append(node)\n                graph[arr[i]].clear()  #\u907f\u514d\u91cd\u8907\u62dc\u8a2a\n                \n                for x in [i + 1, i - 1]:\n                    if x in other:\n                        return step + 1\n                    if 0 <= x < len(arr) and x not in visited:\n                        visited.add(x)\n                        nex.append(x)\n            cur = nex\n            step += 1\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        indexMap = collections.defaultdict(list)\n        for i,a in enumerate(arr):\n            indexMap[a].append(i)\n            \n        d = deque([(0,0)])\n        distance = 0\n        visited = {0}\n        while d:\n            node,distance = d.popleft()\n            if node == len(arr)-1:\n                return distance\n            for nei in [node-1, node+1]+indexMap[arr[node]][::-1]:\n                if 0<=nei<len(arr) and nei!=node and nei not in visited:\n                    visited.add(nei)\n                    if nei == len(arr)-1:\n                        return distance+1\n                    d.append((nei,distance+1))\n        \n    \n        # def bfs():\n        #     from collections import deque\n        #     Q = deque([(0,0)])\n        #     seen = {0}\n        #     while Q:\n        #         i, d = Q.popleft()\n        #         if i==len(arr)-1:return d\n        #         for j in [i-1, i+1]+a_i[arr[i]][::-1]:\n        #             if 0<=j<len(arr) and j!=i and j not in seen:\n        #                 seen.add(j)\n        #                 if j==len(arr)-1:return d+1\n        #                 Q.append((j,d+1))\n        # return bfs()\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        v2n = collections.defaultdict(set)\n        for i, v in enumerate(arr):\n            if 0 < i < len(arr) - 1 and arr[i - 1] == v and arr[i + 1] == v:\n                continue\n            v2n[v].add(i)\n        visited, seen, q, step = set([0]), set(), collections.deque([0]), 0\n        while q:\n            for _ in range(len(q)):\n                cur = q.popleft()\n                if cur == len(arr) - 1: return step\n                neighbors = set([cur + 1, cur - 1] + [x for x in v2n[arr[cur]] if arr[cur] not in seen])\n                for nb in neighbors:\n                    if nb >= 0 and nb < len(arr) and nb != cur and nb not in visited:\n                        visited.add(cur)\n                        q.append(nb)\n                seen.add(cur)\n            step += 1\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # corner case\n        if len(arr) == 1:\n            return 0\n        \n        # create a better lookup data structure\n        dict_ = collections.defaultdict(list)\n        for index in range(len(arr)):\n            dict_[arr[index]].append(index)\n        \n        #print(dict_)\n            \n        # a variable to save ans\n        min_count = 0\n        \n        # remember visited points\n        visited = set()\n        visited.add((arr[0], 0))\n        \n        # bfs\n        queue = collections.deque()\n        queue.append((arr[0], 0))\n        \n        while queue:\n            #print(queue)\n            size = len(queue)\n            # spread the nodes at the same level\n            for i in range(size):\n                curr_num, index = queue.popleft()\n                #print(\\\"index: \\\",index)\n                # reach the condition \n                if index == len(arr) - 1:\n                    return min_count\n                # add unvisited neighbor points to the queue\n                for new_num, new_index in self.move(curr_num, index, arr, dict_,visited):\n                    if (new_num, new_index) not in visited:\n                        #print(\\\"new_index: \\\", new_index)\n                        visited.add((new_num,new_index))\n                        queue.append((new_num, new_index))                                 \n            min_count = min_count + 1\n        \n    \n    def move(self, curr_num, index, arr, dict_, visited):\n            for new_num, new_index in [(arr[index - 1], index - 1), (arr[index+1], index + 1)]:\n                if 0 <= new_index < len(arr):\n                    yield new_num, new_index\n            if dict_[curr_num]:\n                for new_index in dict_[curr_num]:\n                    new_num = curr_num\n                    if 0 <= new_index < len(arr) and (new_num, new_index) not in visited:\n                        yield new_num, new_index\n                del dict_[curr_num]", "from collections import defaultdict, deque\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n        \n        graph = defaultdict(list)\n        for i, num in enumerate(arr):\n            graph[num].append(i)\n        \n        curr = [0]\n        visited = set([0])\n        jumps = 0\n        \n        while curr:\n            nxt = []\n            \n            for node in curr:\n                if node == n - 1:\n                    return jumps\n                \n                for child in graph[arr[node]]:\n                    if child not in visited:\n                        visited.add(child)\n                        nxt.append(child)\n                \n                graph[arr[node]].clear()\n                \n                for child in (node-1, node+1):\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nxt.append(child)\n                \n            curr = nxt\n            jumps += 1\n", "from collections import deque,defaultdict\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        idxs=defaultdict(set)\n        for idx,e in enumerate(arr):\n            idxs[e].add(idx)\n        def bfs(idx):\n            q=deque([0])\n            step=-1\n            not_visited=set(range(len(arr)-1,0,-1))\n            while q:\n                step+=1\n                for _ in range(len(q)):\n                    node=q.popleft()\n                    if node==len(arr)-1:\n                        return step\n                    nxt_nodes=idxs[arr[node]]\n                    nxt_nodes=not_visited&nxt_nodes\n                    for nxt in [node-1,node+1]:\n                        if nxt in not_visited:\n                            nxt_nodes.add(nxt)\n                    if len(arr)-1 in nxt_nodes:\n                        return step+1\n                    not_visited.difference_update(nxt_nodes)\n                    nxt_nodes=nxt_nodes\n                    q.extend(nxt_nodes)\n            return -1\n        return bfs(0)\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr)<=1:\n            return 0\n        link = collections.defaultdict(list)\n        for i, x in enumerate(arr):\n            link[x].append(i)\n        lvl = 0   \n        num_met, pos_met = set(), set()\n        # dp = [-1]*len(arr)\n        queue = collections.deque([0]) #put index\n        while queue:\n            L = len(queue)\n            for i in range(L):\n                x = queue.popleft()\n                if x==len(arr)-1: return lvl\n                num = arr[x]\n                pos_met.add(x)\n                \n                for k in [x-1, x+1]+ link[num]*(num not in num_met):  #\u53d6\u4ea4\u96c6\n                    if k in pos_met or not 0<=k<len(arr): continue\n                    queue.append(k)\n                num_met.add(num)\n            lvl +=1\n        return 0\n                    \n        \n", "from collections import defaultdict\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n_arr = len(arr)\n        if n_arr <= 1:\n            return 0\n        \n        value_arr_map = defaultdict(list)\n        for i, n in enumerate(arr):\n            value_arr_map[n].append(i)\n        \n        head = [0]\n        tail = [n_arr-1]\n        visited = {0, n_arr-1}\n        n_move = 0\n        while head or tail:            \n            if len(head) > len(tail):\n                head, tail = tail, head \n            \n            next_head = []\n            for current_index in head:\n                current_value = arr[current_index]\n\n                candidates = []\n                if current_value in value_arr_map:\n                    candidates += value_arr_map[current_value]            \n                if current_index < n_arr - 1:\n                    candidates += [current_index+1]\n                if current_index > 0:\n                    candidates += [current_index-1]\n                for cand in candidates:\n                    if cand in tail:\n                        return n_move + 1\n                    elif cand not in visited:\n                        visited.add(cand)\n                        next_head.append(cand)\n\n            if current_value in value_arr_map:\n                del value_arr_map[current_value]\n            head = next_head                \n            n_move += 1\n        raise ValueError()", "class Solution:\n    def minJumps(self, arr):\n        n = len(arr)\n        if n == 1: return 0 \n        \n        d = defaultdict(list)\n        for i,val in enumerate(arr):\n            d[val].append(i)\n            \n        visited = set([0])\n        stack = deque([0])\n        k, jumps = len(stack), 1\n        while stack:\n            k -= 1\n            i = stack.popleft()\n            childs = [j for j in d.pop(arr[i],[])]\n            for j in [i-1,i+1]:\n                if 0 <= j < n and arr[j] != arr[i] and j not in visited: childs.append(j)\n            for j in childs:\n                if j == n-1: return jumps\n                visited.add(j)\n                stack.append(j)\n            if not k:\n                k = len(stack)\n                jumps += 1\n        return jumps", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \n        print((len(arr)))\n        adj = collections.defaultdict(list)\n        for i,n in enumerate(arr):\n            adj[n].append(i)\n        \n        #for a in adj:\n        #    adj[a].sort(reverse=True)\n        \n        q=collections.deque()\n        q.append( (0,0) )  # position, step\n        \n        used=[False]*len(arr)\n        \n        i=0\n        while q:\n            cur,step=q.popleft()\n            print((len(q)))\n            \n            if cur==len(arr)-1:\n                return step\n            \n                   \n            if cur<len(arr)-1 and not used[cur+1]:\n                used[cur+1]=True\n                q.append((cur+1,step+1))\n                \n            if cur>0 and not used[cur-1]:\n                used[cur-1]=True\n                q.append((cur-1, step+1))\n                \n            for nxt in adj[arr[cur]]:\n                if (not used[nxt]):\n                    used[nxt]=True\n                    q.append((nxt,step+1))           \n             \n            adj[arr[cur]]=[k for k in adj[arr[cur]] if not used[k]]\n\n                \n        return -1\n\n", "class Solution:\n    def minJumps1(self, arr: List[int]) -> int:\n#         [100,-23,-23,404,100,23,23,23,3,404]\n        \n#         [0,   1,   2,  2,  1, 2, 3, 3, 4,  3]\n        \n        if not arr:\n            return 0\n        \n        dp = [float('inf')] * len(arr)\n        dp[0] = 0\n        minIdx = { arr[0]: (0, 0) }\n        for i in range(1, len(arr)):\n            x = arr[i]\n            stepRight = dp[i-1] + 1\n            jumpStep = minIdx[x][1] + 1 if x in minIdx else float('inf')\n            \n            dp[i] = min(stepRight, jumpStep)\n            \n            if x in minIdx:\n                if dp[i] < minIdx[x][1]:\n                    minIdx[x] = (i, dp[i])\n            else:\n                minIdx[x] = (i, dp[i])\n            \n            j = i - 1\n            while j >= 0 and dp[j] > dp[j + 1] + 1:\n                dp[j] = dp[j+1] + 1\n                y = arr[j]\n                if dp[j] < minIdx[y][1]:\n                    minIdx[y] = (j, dp[j])\n                j -= 1\n        \n        return dp[-1]\n            \n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n\n        graph = {}\n        for i in range(n):\n            if arr[i] in graph:\n                graph[arr[i]].append(i)\n            else:\n                graph[arr[i]] = [i]\n\n        curs = [0]  # store current layers\n        visited = {0}\n        step = 0\n\n        # when current layer exists\n        while curs:\n            nex = []\n\n            # iterate the layer\n            for node in curs:\n                # check if reached end\n                if node == n-1:\n                    return step\n\n                # check same value\n                for child in graph[arr[node]]:\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                # clear the list to prevent redundant search\n                graph[arr[node]].clear()\n\n                # check neighbors\n                for child in [node-1, node+1]:\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n            curs = nex\n            step += 1\n\n        return -1", "from collections import deque,defaultdict\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        idxs=defaultdict(set)\n        for idx,e in enumerate(arr):\n            idxs[e].add(idx)\n        def bfs(idx):\n            q=deque([0])\n            step=-1\n            not_visited=set(range(len(arr)-1,0,-1))\n            while q:\n                step+=1\n                for _ in range(len(q)):\n                    node=q.popleft()\n                    if node==len(arr)-1:\n                        return step\n                    nxt_nodes=idxs[arr[node]]\n                    del idxs[arr[node]]\n                    nxt_nodes=not_visited&nxt_nodes\n                    for nxt in [node-1,node+1]:\n                        if nxt in not_visited:\n                            nxt_nodes.add(nxt)\n                    if len(arr)-1 in nxt_nodes:\n                        return step+1\n                    not_visited.difference_update(nxt_nodes)\n                    nxt_nodes=sorted(nxt_nodes,reverse=True)\n                    q.extend(nxt_nodes)\n            return -1\n        return bfs(0)\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n\n        \n        # Each array index is a node\n        # Each link (i+1), (i-1), (arr[i] == arr[j]) is a connection\n        # Create a graph of arr\n        # BFS to find the shortest path from 0 to arr.length - 1\n        \n        if len(arr) == 1: return 0\n        \n        val_to_id = collections.defaultdict(set)\n        id_to_neigh = {}\n        \n        for i,val in enumerate(arr):\n            if (not i) or (i == len(arr) - 1):\n                val_to_id[val].add(i)\n            elif not (arr[i-1] == arr[i] == arr[i+1]):\n                val_to_id[val].add(i)\n        \n        for i,val in enumerate(arr):\n            if (not i) or (i == len(arr) - 1):\n                id_to_neigh[i] = set([i-1,i+1])|val_to_id[val]\n                id_to_neigh[i] -= set([-1, len(arr), i])\n            elif not (arr[i-1] == arr[i] == arr[i+1]):\n                id_to_neigh[i] = set([i-1,i+1])|val_to_id[val]\n                id_to_neigh[i].remove(i)\n                \n        t = len(arr) - 1 # target index\n        q = [(0, 0)] # (n) number of jumps, (i) current index\n        v = set([0])\n\n        while q:\n            \n            level = []\n            \n            for n, i in q:\n                if i == t:\n                    return n\n                for j in id_to_neigh.get(i, []):\n                    if j not in v:\n                        v.add(j)\n                        level.append((n+1, j))\n            q = level", "class Solution:\n    def minJumps(self, a: List[int]) -> int:\n        n = len(a)\n        adj = defaultdict(list)\n        for i, x in enumerate(a):\n            adj[x].append(i)\n        q = [(0, 0)]\n        seen = [False] * n\n        seen[0] = True\n        for u, d in q:\n            if u == n - 1:\n                return d\n            for v in (u - 1, u + 1):\n                if 0 <= v < n and not seen[v]:\n                    seen[v] = True\n                    q.append((v, d + 1))\n            x = a[u]\n            for v in adj[x]:\n                if not seen[v]:\n                    seen[v] = True\n                    q.append((v, d + 1))\n            if adj[x]:\n                adj[x] = [] # remove edges", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        A = len(arr)\n        m = defaultdict(list)\n        for i, n in enumerate(arr):\n            m[n].append(i)\n        \n        visited = set([-1])\n        curr = set([0])\n        \n        for steps in itertools.count():\n            visited.update(curr)\n            \n            if A - 1 in visited:\n                return steps\n            \n            curr = { j for i in curr for j in [i-1, i+1] + m.pop(arr[i], []) if j not in visited }\n            \n            # curr = { k for j in curr for k in [j+1, j-1] + m.pop(arr[j], []) } - visited\n        \n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        nei = collections.defaultdict(list)\n        for i, x in enumerate(arr):\n            nei[x].append(i)\n\n        frontier = collections.deque([(0,0)])\n        num_met, pos_met = set(), set()\n        while frontier:\n            pos, step = frontier.popleft() # state: position, step\n            if pos == len(arr) - 1: return step\n            num = arr[pos]\n            pos_met.add(pos) # track explored positions\n\n            for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\n                if p in pos_met or not 0 <= p < len(arr): continue\n                frontier.append((p, step + 1))\n\n            num_met.add(num) # track explored values\n        \n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \n        to_index = {}\n        for i in range(len(arr)):\n            if arr[i] not in to_index:\n                to_index[arr[i]] = []\n            to_index[arr[i]].append(i)\n        \n        n = len(arr)\n        q = [(0,0)]\n        vis = set([0])\n\n        for i, jumps in q:\n            if i == n-1:\n                return jumps\n            if i+1<n and i+1 not in vis:\n                vis.add(i+1)\n                q.append((i+1,jumps+1))\n            if i-1>=0 and i-1 not in vis:\n                vis.add(i-1)\n                q.append((i-1,jumps+1))\n            for j in to_index[arr[i]]:\n                if j not in vis:\n                    q.append((j,jumps+1))\n                    vis.add(j)\n            to_index[arr[i]] = []\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n<=1:\n            return 0\n        \n        seen = set([0])\n        \n        dic = collections.defaultdict(set)\n        for i,num in enumerate(arr):\n            dic[num].add(i)\n        \n        bfs = collections.deque([[0,0]])\n        while bfs:\n            ind,c = bfs.popleft()\n            if ind==n-1:\n                return c\n            for nind in [ind-1,ind+1]:\n                if 0<=nind<n and nind not in seen:\n                    bfs.append([nind,c+1])\n                    seen.add(nind)\n            for child in dic[arr[ind]]:\n                if child not in seen:\n                    seen.add(child)\n                    bfs.append([child,c+1])\n            dic[arr[ind]] = set()\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        index = {}\n        if len(set(arr))>10:\n            for ic,val in enumerate(arr):\n                index[val] = index.get(val,[])+[ic]\n        else:\n            for val in set(arr):\n                index[val] = [ ic for ic,v0 in enumerate(arr) if v0==val]\n#        print(len(index),len(arr))\n#        return 6\n        neigh = {}\n        for ic,val in enumerate(arr):\n            if ic-1>=0:\n                neigh[ic]= neigh.get(ic,[])+[ic-1]\n            if ic+1<len(arr):\n                neigh[ic]= neigh.get(ic,[])+[ic+1]\n        front = [0]; visited = {0:0}\n        checkedvalues = set()\n        while front!=[]:\n            nf = [];\n            for u in front:\n                val = arr[u];\n                for v in neigh.get(u,[]):\n                    if not v in visited:\n                        visited[v] = visited[u]+1\n                        nf.append(v)\n                if not val in checkedvalues:\n                    for v in index[val]+neigh.get(u,[]):\n                        if not v in visited:\n                            visited[v] = visited[u]+1\n                            nf.append(v)\n                checkedvalues.add(val)\n            front = nf\n        return visited.get(len(arr)-1,-1)", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        L = len(arr)\n        if L<2:\n            return 0\n        cnt = defaultdict(list)\n        for i,val in enumerate(arr):\n            cnt[val].append(i)\n            \n        q = deque([0])\n        visited = {0}\n        steps = 0\n        while q:\n            size = len(q)\n            for _ in range(size):\n                n = q.popleft()\n                if n==L-1:\n                    return steps\n                for el in cnt[arr[n]]:\n                    if el not in visited:\n                        q.append(el)\n                        visited.add(el)\n                cnt[arr[n]].clear()\n                for c in [n-1,n+1]:\n                    if 0<=c<L and c not in visited:\n                        q.append(c)\n                        visited.add(c)\n            steps += 1\n        \n        return steps\n                \n                \n", "# 1345. Jump Game IV\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        maps = collections.defaultdict(list)\n        [maps[a].append(i) for i, a in enumerate(arr)]\n \n        begins = set([0])\n        ends = set([len(arr) - 1])\n        visitedIdx = set([-1, len(arr)])\n        for steps in range(len(arr)):\n            if len(begins) > len(ends):\n                begins, ends = ends, begins\n            nextLevels = set()\n            for b in begins:\n                if b in ends:\n                    return steps\n                if b in visitedIdx:\n                    continue\n                visitedIdx.add(b)\n                nextLevels.update([b - 1, b + 1] + maps[arr[b]])\n                maps.pop(arr[b])\n            begins = nextLevels", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        d = defaultdict(list)\n        n = len(arr)\n\n        for i in range(n):\n            d[arr[i]].append(i)\n\n        vis = [0] * n\n        vis[0] = 1\n        q = [(0, 0)]\n        while q:\n            i, k = q.pop(0)\n            for j in d[arr[i]] + [i - 1, i + 1]:\n                if j < 0 or j >= n or vis[j]:\n                    continue\n                if j == n - 1:\n                    return k + 1\n                vis[j] = 1\n                q.append((j, k + 1))\n            d[arr[i]] = []\n\n        return 0\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # Compress the array:\n        # for any sub array s[i] == s[i+1] == s[i+2]... we only care about the start and the end        \n        arr = [x for i, x in enumerate(arr) if i == 0 or i == len(arr)-1 or x != arr[i-1] or x != arr[i+1]]\n        \n        d = {}\n        # O(N)\n        for i, x in enumerate(arr):\n            d.setdefault(x, set()).add(i)\n        # Build graph O(N^2)\n        adj = {}\n        for i, x in enumerate(arr):\n            adj[i] = set()\n            if i != 0: adj[i].add(i-1)\n            if i != len(arr)-1: adj[i].add(i+1)\n            adj[i] |= d[arr[i]] # O(N^2)?\n            adj[i].remove(i)\n            \n        #print(adj)\n        # BFS\n        q = collections.deque()\n        distance = [len(arr)-1] * len(arr)\n        q.append(0)\n        count = 0\n        while q:\n            nxt_q = collections.deque()\n            while q:\n                nxt = q.popleft()\n                if distance[nxt] <= count: continue\n                distance[nxt] = count\n                for x in adj[nxt]:\n                    nxt_q.append(x)\n            q = nxt_q\n            count += 1\n        return distance[-1]\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \n        print((len(arr)))\n        adj = collections.defaultdict(list)\n        for i,n in enumerate(arr):\n            adj[n].append(i)\n        \n        #for a in adj:\n        #    adj[a].sort(reverse=True)\n        \n        q=collections.deque()\n        q.append( (0,0) )  # position, step\n        \n        used=[False]*len(arr)\n        \n        i=0\n        while q:\n            cur,step=q.popleft()\n            print((len(q)))\n            \n            if cur==len(arr)-1:\n                return step\n            \n                   \n            if cur<len(arr)-1 and not used[cur+1]:\n                used[cur+1]=True\n                q.append((cur+1,step+1))\n                \n            if cur>0 and not used[cur-1]:\n                used[cur-1]=True\n                q.append((cur-1, step+1))\n                \n            for nxt in adj[arr[cur]]:\n                if (not used[nxt]):\n                    used[nxt]=True\n                    q.append((nxt,step+1))           \n             \n            adj[arr[cur]]=[k for k in adj[arr[cur]] if not used[nxt]]\n\n                \n        return -1\n\n", "class Solution:\n    def minJumps(self, arr):\n        nei = collections.defaultdict(list)\n        _ = [nei[x].append(i) for i, x in enumerate(arr)]\n\n        frontier = collections.deque([(0,0)])\n        num_met, pos_met = set(), set()\n        while frontier:\n            pos, step = frontier.popleft() # state: position, step\n            if pos == len(arr) - 1: return step\n            num = arr[pos]\n            pos_met.add(pos) # track explored positions\n\n            \n            nexts = [pos - 1, pos + 1]+nei[num] if num not in num_met else [pos - 1, pos + 1]\n            \n            for p in nexts:\n                if p in pos_met or not 0 <= p < len(arr): continue\n                frontier.append((p, step + 1))\n\n            num_met.add(num) # track explored values\n                \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # BFS\n        A = arr\n        n = len(A)\n        q = []\n        val_dic = collections.defaultdict(list)\n        for i, val in enumerate(A):\n            if len(val_dic[val]) > 0:\n                last_range = val_dic[val][-1]\n                if last_range[1]+1 == i:\n                    last_range[1] = i\n                else:\n                    val_dic[val].append([i,i])\n            else:\n                val_dic[val].append([i,i])\n                \n        walked_val = set()\n        # for i in val_dic[A[0]]:\n        q.append(0)\n            \n        walked = set()\n        steps = -1\n        while len(q) > 0:\n            # print(q)\n            cur_len = len(q)\n            next_q = []\n            for i in q:\n                val = A[i]\n                if i == n-1:\n                    return steps+1\n                \n                walked.add(i)\n                \n                if i+1 < n and i+1 not in walked:\n                    next_q.append(i+1)\n                if i-1 > -1 and i-1 not in walked:\n                    next_q.append(i-1)\n                if val not in walked_val:\n                    index_range_list = val_dic[val]\n                    for index_range in index_range_list:\n                        for j in (index_range[0], index_range[1]):\n                            if j != i and j not in walked:\n                                next_q.append(j)\n                        walked_val.add(val)\n                \n            steps += 1\n            q = next_q\n        return steps\n\n\n\n# class Solution:\n#     def minJumps(self, arr: List[int]) -> int:\n#         # BFS\n#         A = arr\n#         n = len(A)\n#         q = collections.deque()\n#         val_dic = collections.defaultdict(list)\n#         for i, val in enumerate(A):\n#             if len(val_dic[val]) > 0:\n#                 last_range = val_dic[val][-1]\n#                 if last_range[1]+1 == i:\n#                     last_range[1] = i\n#                 else:\n#                     val_dic[val].append([i,i])\n#             else:\n#                 val_dic[val].append([i,i])\n                \n#         walked_val = set()\n#         # for i in val_dic[A[0]]:\n#         q.append(0)\n            \n#         walked = set()\n#         steps = -1\n#         while len(q) > 0:\n#             # print(q)\n#             cur_len = len(q)\n#             for _ in range(0,cur_len):\n                \n#                 i = q.popleft()\n#                 val = A[i]\n#                 if i == n-1:\n#                     return steps+1\n                \n#                 walked.add(i)\n                \n#                 if i+1 < n and i+1 not in walked:\n#                     q.append(i+1)\n#                 if i-1 > -1 and i-1 not in walked:\n#                     q.append(i-1)\n\n#                 # \u4e0d\u8981\u53bb\u904d\u5386\u548c\u81ea\u5df1\u7684\u503c\u76f8\u540c\u7684\u5143\u7d20\uff0c\u5982\u679c\u4e0d\u4fbf\u5229\uff0c\u5c31\u589e\u52a0\u4e0d\u8fdb\u53bb\u3002\n#                 # \u5982\u679c\u8fd9\u4e2a\u503c\u5df2\u7ecf\u88ab\u904d\u5386\u8fc7\u4e86\uff0c\u5c31\u4e0d\u8981\u518d\u6b21\u904d\u5386\u3002\n                \n#                 if val not in walked_val:\n#                     index_range_list = val_dic[val]\n#                     for index_range in index_range_list:\n#                         for j in (index_range[0], index_range[1]):\n#                             if j != i and j not in walked:\n#                                 q.append(j)\n#                         walked_val.add(val)\n                \n#             steps += 1\n                \n#         return steps\n", "from collections import defaultdict, deque\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n        \n        graph = defaultdict(list)\n        for i, num in enumerate(arr):\n            graph[num].append(i)\n        \n        curr = [0]\n        visited = set([0])\n        jumps = 0\n        \n        while curr:\n            nxt = []\n            \n            for node in curr:\n                if node == n - 1:\n                    return jumps\n                \n                for child in graph[arr[node]]:\n                    if child not in visited:\n                        visited.add(child)\n                        nxt.append(child)\n                \n                graph[arr[node]].clear()\n                \n                for child in (node-1, node+1):\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nxt.append(child)\n                \n            curr = nxt\n            jumps += 1\n                \n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        N = len(arr)\n        indices = collections.defaultdict(set)\n\n        for i, a in enumerate(arr):\n            indices[a].add(i)\n\n        queue = collections.deque([(0, 0)])        \n        seen = {0}\n        value_seen = set()\n\n        while queue:\n            i, move = queue.popleft()\n\n            if i == N-1:\n                return move\n\n            if arr[i] not in value_seen:\n                value_seen.add(arr[i])\n                for j in indices[arr[i]]:\n                    if j != i and j not in seen:\n                        seen.add(j)\n                        queue.append((j, move+1))\n\n            if i-1 >= 0 and (i-1) not in seen:\n                seen.add(i-1)\n                queue.append((i-1, move+1))\n            \n            if i+1 < N and (i+1) not in seen:\n                seen.add(i+1)\n                queue.append((i+1, move+1))", "import numpy as np\nimport heapq\nfrom collections import deque\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        self.arr = arr\n\n        # Hashing indices by values\n        self.val2indx = {}\n        for i,v in enumerate(arr):\n            if not v in self.val2indx:  self.val2indx[v] = []\n            self.val2indx[v].append(i)\n        # print(\\\"val hash: \\\", self.val2indx)\n\n        # Solutions memoization table\n        self.solutions = [np.inf for i in range(len(arr))]\n        self.solutions[-1] = 0\n        self.visited = [False for i in range(len(arr))]\n        \n        node_q = deque()\n        node_q.append((0, len(arr)-1))\n        \n        while node_q:\n            # dist, indx = heapq.heappop(node_q)\n            dist, indx = node_q.popleft()\n            self.visited[indx] = True\n            if dist > self.solutions[indx]: continue\n                \n            # Extracting edges\n            next_indx, prev_indx = min(indx+1, len(self.arr)-1), max(indx-1, 0)\n            indices = [i for i in self.val2indx[self.arr[indx]] if i != indx and i != prev_indx and i != next_indx and not self.visited[i]]    \n            indices = [prev_indx, next_indx] + indices\n            if not self.visited[prev_indx]: indices.append(prev_indx)\n            if not self.visited[next_indx]: indices.append(next_indx)\n            # exclude already visited nodes\n            # indices = [i for i in indices if not self.visited[i]]\n            # print(\\\"node:\\\", indx, \\\"edges\\\", indices)\n                            \n            # Update neighbour distances\n            for j in indices:\n                newdist = dist + 1\n                if np.isinf(self.solutions[j]) or newdist < self.solutions[j] and not self.visited[j]:\n                    self.solutions[j] = newdist\n                    # heapq.heappush(node_q, (newdist, j))\n                    node_q.append((newdist,j))\n                    self.visited[j] = True\n                    if j == 0: return newdist\n        \n        # print(\\\"solutions:\\\", self.solutions)\n        return self.solutions[0]\n            \n            \n        \n        \n\n\n# class Solution:\n#     def getSolution(self, indx):\n#         self.visitations[indx] = True\n        \n#         # Checking presence in hash table for the solution\n#         if self.solutions[indx] is not None:\n#             return self.solutions[indx]\n#         else:\n#             # min(indx-1, indx+1, indicees of val2indx[arr[indx]])\n#             indices = [i for i in self.val2indx[self.arr[indx]] if i != indx]\n#             indices = [min(indx+1, len(self.arr)-1), max(indx-1, 0)] + indices\n#             indices = np.unique(indices)         \n#             # exclude already visited states\n#             indices = [i for i in indices if not self.visitations[i] or self.solutions[i] is not None]\n#             print(indx, indices, self.solutions)\n            \n#             solutions = []\n#             for i in indices:\n#                 solutions.append(self.getSolution(i))\n                \n#                 # Just a shortcut to avoid unnecessary search\n#                 if solutions[-1] == 1: \n#                     self.solutions[indx] = 2\n#                     return self.solutions[indx]\n            \n#             if len(solutions) == 0: return np.inf\n            \n#             print(\\\"---\\\", indx ,\\\":\\\", solutions, np.min(solutions), indices)\n#             self.solutions[indx] = 1 + np.min(solutions)\n#             return self.solutions[indx]\n    \n#     def minJumps(self, arr: List[int]) -> int:\n#         self.arr = arr\n\n#         # Solutions memoization table\n#         self.solutions = [None for i in range(len(arr))]\n#         self.solutions[-1] = 0\n#         self.solutions[-2] = 1\n#         # self.visitations = [False for i in range(len(arr))]\n#         # self.visitations[-2] = True\n        \n#         # Hashing indices by values\n#         self.val2indx = {}\n#         for i,v in enumerate(arr):\n#             if not v in self.val2indx:  self.val2indx[v] = []\n#             self.val2indx[v].append(i)\n        \n#         print(\\\"arr:\\\", arr)\n#         print(\\\"val hash:\\\", self.val2indx)\n#         # return 0\n        \n#         # Get solutions starting from the end\n#         for i in range(len(arr)-2, -1, -1):\n#             print(\\\"indx:\\\", i)\n#             self.visitations = [False for j in range(len(arr))]\n#             self.visitations[-2] = True\n#             self.getSolution(indx=i)\n        \n        \n#         print(\\\"solutions: \\\", self.solutions)\n#         return self.solutions[0]\n        \n        \n", "class Solution:\n    # bidirectional, best 416 ms, memory 99.90%\n    def minJumps(self, arr):\n        length = len(arr)\n        # if no any connection in nodes, answer equals to array length\n        if len(set(arr)) == length: return length - 1\n        if arr[0] == arr[-1]: return 1\n\n        _map = defaultdict(set) # connection map\n        for i, val in enumerate(arr): _map[val].add(i)\n\n        # BFS, seen: visited index, visit: visited connection\n        res, seen, visit = 0, {0}, set()\n        # curs: nodes in current side level, other: nodes in opposite side\n        curs, other = {0}, {length - 1}\n        while curs:\n            res += 1\n            # store found nodes in this level\n            thisLevel = set()\n            for i in curs:\n              \n                # check move backwards \n                if i - 1 > 0 and i - 1 not in seen: \n                    thisLevel.add(i - 1)\n                # check in place\n                if arr[i] not in visit:\n                    thisLevel |= (_map[arr[i]] - seen) \n                    visit.add(arr[i])\n                # check move forwards\n                if i + 1 < length and i + 1 not in seen: \n                    thisLevel.add(i + 1)\n\n            # check if this level and the other side intersect\n            if thisLevel & other: return res  \n\n            # update current side for next round          \n            curs = thisLevel\n            # choose smaller side into next round \n            if len(curs) > len(other): curs, other = other, curs\n            # if we don't exchange, put found nodes into seen\n            # because they are found in current direction\n            else: seen |= thisLevel", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if not arr or len(arr)==1:\n            return 0\n        \n        dp=[float('inf')]*len(arr)\n        dp[0]=0\n        \n        position=collections.defaultdict(set)\n        visited={}\n        for i,e in enumerate(arr):\n            position[e].add(i)\n            visited[i]=False\n        visited[0]=True\n        \n        start={0}\n        step=0\n        while start:\n            nextstart=set()\n            for i in start:\n                \n                if i==len(arr)-1:\n                    return step\n                \n                if i-1>=0 and not visited[i-1]:\n                    dp[i-1]=min(dp[i-1],dp[i]+1)\n                    nextstart.add(i-1)\n                    visited[i-1]=True\n                if i+1<len(arr) and not visited[i+1]:\n                    dp[i+1]=min(dp[i+1],dp[i]+1)\n                    nextstart.add(i+1)\n                    visited[i+1]=True\n                for p in position[arr[i]]:\n                    if p!=i and not visited[p]:\n                        dp[p]=min(dp[p],dp[i]+1)\n                        nextstart.add(p)\n                        visited[p]=True\n                position[arr[i]]=set()\n\n            start=nextstart\n            step+=1\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        s = defaultdict(list)\n        for i,num in enumerate(arr):\n            s[num] += [i]\n            \n        q = set([0])\n        seen = set()\n        level = 0\n        while q:\n            seen.update(q)\n            new_q = set()\n            for i in q:\n                if i == len(arr)-1:\n                    return level\n                children = []\n                if i+1 < len(arr):\n                    children += [i+1]\n                if i-1 >= 0:\n                    children += [i-1]\n                for j in s[arr[i]]:\n                    if j != i:\n                        children += [j]\n                del s[arr[i]]\n                        \n                for child in children:\n                    if child not in seen:\n                        new_q.add(child)\n            level += 1\n            q = new_q\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        d = {}\n        seen = set()\n        queue = deque([(0, 0)])\n        \n        for i, num in enumerate(arr):\n            if i == 0 or i == len(arr)-1 or (arr[i-1] != arr[i] or arr[i+1] != arr[i]):\n                d[num] = d.get(num, []) + [i]\n        \n        while queue:\n            next_idx, steps = queue.popleft()\n            \n            if next_idx == len(arr)-1:\n                return steps\n            \n            if next_idx + 1 <= len(arr) and next_idx + 1 not in seen:\n                queue.append((next_idx+1, steps+1))\n                seen.add(next_idx+1)\n            \n            if next_idx - 1 >= 0 and next_idx - 1 not in seen:\n                queue.append((next_idx-1, steps+1))\n                seen.add(next_idx-1)\n            \n            for i in d[arr[next_idx]][::-1]:\n                if i != next_idx and i not in seen:\n                    queue.append((i, steps+1))\n                    seen.add(i)\n        \n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # U could do this in BFS\n\n        \n        record = collections.defaultdict(list)\n        for i,v in enumerate(arr):\n            record[v].append(i)\n        nums = set()\n        pos_met = set()\n        q = collections.deque([(0,0)])\n        while q:\n            pos,step = q.popleft()\n            if pos == len(arr)-1:return step\n            num = arr[pos]\n            pos_met.add(pos)\n            temp = [pos-1,pos+1]\n            if num not in nums:\n                for j in record[num]:\n                    temp += [j]\n            nums.add(num)\n            for i in temp:\n                if 0<=i<len(arr) and i not in pos_met:\n                    q.append([i,step+1])\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        def BFS(queue):\n            seen = [1]*len(arr);seen[0] = 0\n            while queue:\n                var , level = queue.pop(0)\n                if var == len(arr) - 1:return level\n                if seen[var + 1]:queue.append([var+1,level+1]);seen[var+1] = 0\n                if var - 1 >=0 and   seen[var - 1]:queue.append([var-1,level+1]);seen[var-1] = 0                 \n                for i in d[arr[var]]:\n                    if seen[i]:queue.append([i,level+1]);seen[i] = 0\n                d[arr[var]].clear()\n        \n        d = defaultdict(list)\n        for i in range(len(arr) - 1 , -1 ,-1 ):d[arr[i]] +=[i]\n        return (BFS([[0,0]]))", "from collections import defaultdict, deque\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr)==1: return 0\n        \n        VALUE_INDEX_MAP = defaultdict(list)\n        for i, v in enumerate(arr):\n            VALUE_INDEX_MAP[v].append(i)\n        \n        # BFS\n        queue = deque([0])\n        seen = set([0])\n        nsteps = -1\n        while queue:\n            levelSize = len(queue)\n            nsteps += 1\n            for _ in range(levelSize):\n                x = queue.popleft()\n                if x == len(arr)-1:\n                    return nsteps\n                for nx in VALUE_INDEX_MAP[arr[x]]+[x-1, x+1]:\n                    if 0<=nx<len(arr) and nx not in seen:\n                        queue.append(nx)\n                        seen.add(nx)\n                VALUE_INDEX_MAP[arr[x]].clear() # this ensures that the same value can be visited at most twice.\n                \n        return -1", "from collections import deque\nfrom collections import defaultdict\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        mapping = defaultdict(set)\n        for i, val in enumerate(arr):\n            mapping[val].add(i)\n\n        queue = deque([(0, 0)])\n        visited = set([0])\n        while queue:\n            curr_cost, ci = queue.popleft()\n            if ci == len(arr) - 1:\n                return curr_cost\n            if ci + 1 < len(arr) and ci + 1 not in visited:\n                queue.append((curr_cost + 1, ci + 1))\n                visited.add(ci + 1)\n                if ci + 1 in mapping[arr[ci]]:\n                    mapping[arr[ci]].remove(ci + 1)\n            if ci - 1 >= 0 and ci - 1 not in visited:\n                queue.append((curr_cost + 1, ci - 1))\n                visited.add(ci - 1)\n                if ci - 1 in mapping[arr[ci]]:\n                    mapping[arr[ci]].remove(ci - 1)\n            next_ = set(mapping[arr[ci]])\n            for ni in next_:\n                if ni not in visited:\n                    queue.append((curr_cost + 1, ni))\n                    visited.add(ni)\n                mapping[arr[ci]].remove(ni)\n        return -1\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        def BFS(queue):\n            seen , val_seen = [1]*len(arr) , set();seen[0] = 0\n            while queue:\n                var , level = queue.pop(0)\n                if var == len(arr) - 1:return level\n                if seen[var + 1]:queue.append([var+1,level+1]);seen[var+1] = 0\n                if var - 1 >=0 and   seen[var - 1]:queue.append([var-1,level+1]);seen[var-1] = 0\n                if arr[var] not in val_seen:  \n                    for i in d[arr[var]]:\n                        if seen[i]:queue.append([i,level+1]);seen[i] = 0\n                    val_seen.add(arr[var])\n        \n        d = defaultdict(list)\n        for i in range(len(arr) - 1 , -1 ,-1 ):d[arr[i]] +=[i]\n        return (BFS([[0,0]]))", "# class Solution:\n#     def minJumps(self, arr: List[int]) -> int:\n#         n = len(arr)\n#         if n <= 1:\n#             return 0\n\n#         graph = {}\n#         for i in range(n):\n#             if arr[i] in graph:\n#                 graph[arr[i]].append(i)\n#             else:\n#                 graph[arr[i]] = [i]\n\n#         curs = [0]  # store current layers\n#         visited = {0}\n#         step = 0\n\n#         # when current layer exists\n#         while curs:\n#             nex = []\n\n#             # iterate the layer\n#             for node in curs:\n#                 # check if reached end\n#                 if node == n-1:\n#                     return step\n\n#                 # check same value\n#                 for child in graph[arr[node]]:\n#                     if child not in visited:\n#                         visited.add(child)\n#                         nex.append(child)\n\n#                 # clear the list to prevent redundant search\n#                 graph[arr[node]].clear()\n\n#                 # check neighbors\n#                 for child in [node-1, node+1]:\n#                     if 0 <= child < len(arr) and child not in visited:\n#                         visited.add(child)\n#                         nex.append(child)\n\n#             curs = nex\n#             step += 1\n\n#         return -1\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if not arr or len(arr) == 1: return 0\n        \n        val_to_idxes = collections.defaultdict(list)\n        adj = collections.defaultdict(set)\n        \n        for i in range(len(arr)):\n            val_to_idxes[arr[i]].append(i)\n        \n        # bfs\n        # [(idx, dist)]\n        q = [(0, 0)]\n        visited = {0}\n        while q:\n            idx, dist = q.pop(0)\n        \n            if idx == len(arr) - 1:\n                return dist\n            \n            visited.add(idx)\n\n            for neighbor in val_to_idxes[arr[idx]]:\n\n                if neighbor in visited:\n                    continue\n\n                q.append((neighbor, dist+1))\n                visited.add(neighbor)\n                \n                if neighbor == len(arr) - 1:\n                    return dist+1            \n            \n            if idx-1 >= 0 and (idx-1) not in visited:\n                q.append((idx-1, dist+1))\n                visited.add(idx-1)\n\n            if idx+1 < len(arr) and (idx+1) not in visited:\n                q.append((idx+1, dist+1))\n                visited.add(idx+1)\n                \n                if idx+1 == len(arr)-1:\n                    return dist + 1\n\n\n            \n            val_to_idxes[arr[idx]] = []\n        \n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        dic = defaultdict(list)\n        for i in range(len(arr)):\n            dic[arr[i]].append(i)\n        visited = [False] * (len(arr))\n        queue=collections.deque()\n        queue.append((0,0))\n        ans = 0\n        N = len(arr)\n        while(queue):\n            i,step = queue.popleft()\n            print((i,step))\n            if(i == N-1):\n                ans = step\n                break\n            if visited[i] == False:\n                if(i+1<N):\n                    queue.append((i+1,step+1))\n                if(i-1>=0):\n                    queue.append((i-1,step+1))\n                for index in dic[arr[i]]:\n                    if(visited[index] == False):\n                        queue.append((index,step+1))\n                visited[i] = True\n                dic[arr[i]] = []  \n                        \n        return ans\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n < 2:\n            return 0\n        \n        graph = defaultdict(list)\n        for i, v in enumerate(arr):\n            graph[v].append(i)\n        \n        queue = [0]\n        seen = {0}\n        steps = 0\n        while queue:\n            next_ = []\n            for node in queue:\n                if node == n - 1:\n                    return steps\n                for neighbor in graph[arr[node]]:\n                     \n                    if neighbor not in seen:\n                        seen.add(neighbor)\n                        next_.append(neighbor)\n                \n                for neighbor in [node-1, node+1]:\n    \n                    if 0 <= neighbor < n and neighbor not in seen:\n                        seen.add(neighbor)\n                        next_.append(neighbor)\n                graph[arr[node]].clear()        \n                        \n            queue = next_\n            steps += 1\n            \n        return -1", "# class Solution:\n#     def minJumps(self, arr: List[int]) -> int:\n#         n = len(arr)\n#         if n <= 1:\n#             return 0\n\n#         graph = {}\n#         for i in range(n):\n#             if arr[i] in graph:\n#                 graph[arr[i]].append(i)\n#             else:\n#                 graph[arr[i]] = [i]\n\n#         curs = [0]  # store current layers\n#         visited = {0}\n#         step = 0\n\n#         # when current layer exists\n#         while curs:\n#             nex = []\n\n#             # iterate the layer\n#             for node in curs:\n#                 # check if reached end\n#                 if node == n-1:\n#                     return step\n\n#                 # check same value\n#                 for child in graph[arr[node]]:\n#                     if child not in visited:\n#                         visited.add(child)\n#                         nex.append(child)\n\n#                 # clear the list to prevent redundant search\n#                 graph[arr[node]].clear()\n\n#                 # check neighbors\n#                 for child in [node-1, node+1]:\n#                     if 0 <= child < len(arr) and child not in visited:\n#                         visited.add(child)\n#                         nex.append(child)\n\n#             curs = nex\n#             step += 1\n\n#         return -1\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if not arr or len(arr) == 1: return 0\n        \n        val_to_idxes = collections.defaultdict(list)\n        adj = collections.defaultdict(set)\n        \n        for i in range(len(arr)):\n            val_to_idxes[arr[i]].append(i)\n        \n        # bfs\n        # [(idx, dist)]\n        q = [(0, 0)]\n        visited = {0}\n        while q:\n            idx, dist = q.pop(0)\n        \n            if idx == len(arr) - 1:\n                return dist\n            \n            visited.add(idx)\n\n            for neighbor in val_to_idxes[arr[idx]]:\n\n                if neighbor in visited:\n                    continue\n\n                q.append((neighbor, dist+1))\n                visited.add(neighbor)\n                \n                if neighbor == len(arr) - 1:\n                    return dist+1            \n            \n            if idx-1 >= 0 and (idx-1) not in visited:\n                q.append((idx-1, dist+1))\n                visited.add(idx-1)\n\n            if idx+1 < len(arr) and (idx+1) not in visited:\n                q.append((idx+1, dist+1))\n                visited.add(idx+1)\n                \n                if idx+1 == len(arr)-1:\n                    return dist + 1\n            \n            val_to_idxes[arr[idx]] = []\n        \n        return -1", "# class Solution:\n#     def minJumps(self, arr: List[int]) -> int:\n#         n = len(arr)\n#         if n <= 1:\n#             return 0\n\n#         graph = {}\n#         for i in range(n):\n#             if arr[i] in graph:\n#                 graph[arr[i]].append(i)\n#             else:\n#                 graph[arr[i]] = [i]\n\n#         curs = [0]  # store current layers\n#         visited = {0}\n#         step = 0\n\n#         # when current layer exists\n#         while curs:\n#             nex = []\n\n#             # iterate the layer\n#             for node in curs:\n#                 # check if reached end\n#                 if node == n-1:\n#                     return step\n\n#                 # check same value\n#                 for child in graph[arr[node]]:\n#                     if child not in visited:\n#                         visited.add(child)\n#                         nex.append(child)\n\n#                 # clear the list to prevent redundant search\n#                 graph[arr[node]].clear()\n\n#                 # check neighbors\n#                 for child in [node-1, node+1]:\n#                     if 0 <= child < len(arr) and child not in visited:\n#                         visited.add(child)\n#                         nex.append(child)\n\n#             curs = nex\n#             step += 1\n\n#         return -1\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if not arr or len(arr) == 1: return 0\n        \n        val_to_idxes = collections.defaultdict(list)\n        adj = collections.defaultdict(set)\n        \n        for i in range(len(arr)):\n            val_to_idxes[arr[i]].append(i)\n        \n        # bfs\n        # [(idx, dist)]\n        q = [(0, 0)]\n        visited = {0}\n        while q:\n            idx, dist = q.pop(0)\n        \n            if idx == len(arr) - 1:\n                return dist\n            \n            visited.add(idx)\n        \n            if idx-1 >= 0 and (idx-1) not in visited:\n                q.append((idx-1, dist+1))\n                visited.add(idx-1)\n\n            if idx+1 < len(arr) and (idx+1) not in visited:\n                q.append((idx+1, dist+1))\n                visited.add(idx+1)\n                \n                if idx+1 == len(arr)-1:\n                    return dist + 1\n\n            for neighbor in val_to_idxes[arr[idx]]:\n\n                if neighbor in visited:\n                    continue\n\n                q.append((neighbor, dist+1))\n                visited.add(neighbor)\n                \n                if neighbor == len(arr) - 1:\n                    return dist+1\n            \n            val_to_idxes[arr[idx]] = []\n        \n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        def BFS(queue):\n            seen , val_seen = [1]*len(arr) , set();seen[0] = 0\n            while queue:\n                var , level = queue.pop(0)\n                if var == len(arr) - 1:return level\n                if seen[var + 1]:queue.append([var+1,level+1]);seen[var+1] = 0\n                if var - 1 >=0 and   seen[var - 1]:queue.append([var-1,level+1]);seen[var-1] = 0\n                if arr[var] not in val_seen:  \n                    for i in d[arr[var]]:\n                        if seen[i]:queue.append([i,level+1]);seen[i] = 0\n                val_seen.add(arr[var])\n        \n        d = defaultdict(list)\n        for i in range(len(arr) - 1 , -1 ,-1 ):d[arr[i]] +=[i]\n        return (BFS([[0,0]]))", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        def BFS(queue):\n            seen = [1]*len(arr);seen[0] = 0\n            while queue:\n                var , level = queue.pop(0)\n                if var == len(arr) - 1:return level\n                if seen[var + 1]:queue.append([var+1,level+1]);seen[var+1] = 0\n                if seen[var - 1] and var - 1 >=0 :queue.append([var-1,level+1]);seen[var-1] = 0\n                for i in d[arr[var]]:\n                    if seen[i]:queue.append([i,level+1]);seen[i] = 0\n                d[arr[var]].clear()\n        \n        d = defaultdict(list)\n        for i in range(len(arr) - 1 , -1 ,-1 ):d[arr[i]] +=[i]\n        return (BFS([[0,0]]))", "import collections\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return 0\n        \n        d = collections.defaultdict(list)\n        for index, element in enumerate(arr):\n            d[element].append(index)\n\n        queue = collections.deque([(0, 0)])\n        s = set()\n        s.add(0)\n\n        while len(queue):\n            currIndex, jumps = queue.popleft()\n\n            for nextIndex in [currIndex + 1, currIndex - 1] + d[arr[currIndex]][::-1]:\n                if nextIndex < len(arr) and nextIndex > -1 and nextIndex != currIndex and nextIndex not in s:\n                    if nextIndex == len(arr) - 1:\n                        return jumps + 1\n                    s.add(nextIndex)\n                    queue.append((nextIndex, jumps + 1))\n\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \n        print((len(arr)))\n        adj = collections.defaultdict(list)\n        for i,n in enumerate(arr):\n            adj[n].append(i)\n        \n        #for a in adj:\n        #    adj[a].sort(reverse=True)\n        \n        q=collections.deque()\n        q.append( (0,0) )  # position, step\n        \n        used=[False]*len(arr)\n        \n        i=0\n        while q:\n            cur,step=q.popleft()\n            print((len(q)))\n            \n            if cur==len(arr)-1:\n                return step\n            \n                   \n            if cur<len(arr)-1 and not used[cur+1]:\n                used[cur+1]=True\n                q.append((cur+1,step+1))\n                \n            if cur>0 and not used[cur-1]:\n                used[cur-1]=True\n                q.append((cur-1, step+1))\n                \n            for nxt in adj[arr[cur]]:\n                if (not used[nxt]):\n                    used[nxt]=True\n                    q.append((nxt,step+1))           \n            \n            adj[arr[cur]]=[]\n             \n\n                \n        return -1\n\n", "\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        #minJump, shortest Path\n        \n        minJump = len(arr) + 1\n        graph = {}\n        for i, n in enumerate(arr):\n            if 1 < i <len(arr)-1 and arr[i-1] == arr[i] == arr[i+1]: ###pruning, skip the middle of the contiguous number\n                continue\n            graph[n] = graph.get(n, [])\n            graph[n].append(i)\n        \n        queue = collections.deque([0])\n        visited = set([0])\n        step = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node = queue.popleft()\n                if node == len(arr) - 1:\n                    return step\n                num = graph.pop(arr[node], [])  ##arr[node], not node\n                for nei in [node + 1, node - 1] +num:\n                    if nei not in visited and  0 <= nei < len(arr):\n                        queue.append(nei)\n                        visited.add(nei)\n            step += 1\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n==1:\n            return 0\n        if arr[-1] == arr[0]:\n            return 1\n        mapping = collections.defaultdict(list)\n        for i, num in enumerate(arr):\n            mapping[num].append(i)\n        q = collections.deque([(0, 0)])\n        visited = set([0])\n        while q:\n            cur_i, jumps = q.popleft()\n            if cur_i == n-1:\n                return jumps\n            curnum = arr[cur_i]\n            for nei_i in mapping[curnum]:\n                if nei_i != cur_i and nei_i not in visited:\n                    visited.add(nei_i)\n                    q.append((nei_i, jumps+1))\n            # clear the neighbors, since we have tried every \n            # jumping ways in this mapping and we do not to\n            # jump back\n            mapping[curnum] = []\n            if cur_i+1 < n and cur_i+1 not in visited:\n                visited.add(cur_i+1)\n                q.append((cur_i+1, jumps+1))\n            if cur_i-1>=0 and cur_i-1 not in visited:\n                visited.add(cur_i-1)\n                q.append((cur_i-1, jumps+1))\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        c = collections.defaultdict(list)\n        for i, x in enumerate(arr):\n            c[x].append(i)\n        \n        q = [0]\n        steps = [0] * len(arr)\n        steps[0] = 1\n        seen = set()\n        \n        while q:\n            i = q.pop(0)\n            if i == len(arr) -1: return steps[i]-1\n            children = [i-1, i+1]\n            if arr[i] not in seen:\n                children += c[arr[i]][::-1]\n                seen.add(arr[i])\n            for child in children:\n                if child < 0 or child >= len(arr): continue\n                if child == i: continue\n                if steps[child]: continue\n                steps[child] = steps[i] + 1\n                q.append(child)\n        \n        return steps[-1] - 1\n", "from collections import defaultdict, deque\n\nimport heapq\n\nclass Solution:\n  def minJumps(self, arr: List[int]) -> int:\n    n = len(arr)\n    # priority queue, O(NlogN)\n    d = defaultdict(set)\n    for i, x in enumerate(arr):\n      d[x].add(i)\n    q, s = [(0, 0)], defaultdict(lambda: float('inf'))\n    s[0] = 0\n    while q:\n      m, i = heapq.heappop(q)\n      i = -i\n      if i - 1 >= 0 and s[i - 1] > m + 1:\n        s[i - 1] = m + 1\n        heapq.heappush(q, (m + 1, -(i - 1)))\n      if i + 1 < n and s[i + 1] > m + 1:\n        if i + 1 == n - 1:\n          return m + 1\n        s[i + 1] = m + 1\n        heapq.heappush(q, (m + 1, -(i + 1)))\n      x, js = arr[i], set()\n      for j in d[x]:\n        if s[j] > m + 1:\n          if j == n - 1:\n            return m + 1\n          s[j] = m + 1\n          heapq.heappush(q, (m + 1, -j))\n        else:\n          js.add(j)\n      for j in js:\n        d[x].remove(j)\n    return s[n - 1]", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        graph = defaultdict(list)\n        for i, num in enumerate(arr):\n            graph[num].append(i)\n        q = deque([0])\n        counter = 0\n        visited = [0] * len(arr)\n        visited[0] = 1\n        while q:\n            size = len(q)\n            for _ in range(size):\n                i = q.popleft()\n                if i == len(arr) - 1:\n                    return counter\n                num = arr[i]\n                neighbors = graph[num]\n                for neighbor in neighbors:\n                    if not visited[neighbor]:\n                        q.append(neighbor)\n                        visited[neighbor] = 1\n                graph.pop(num)\n                if i + 1 < len(arr) and not visited[i + 1]:\n                    q.append(i + 1)\n                    visited[i + 1] = 1\n                if i - 1 >= 0 and not visited[i - 1]:\n                    q.append(i - 1)\n                    visited[i - 1] = 1\n            counter += 1\n\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        dic = defaultdict(list)\n        for i in range(len(arr)):\n            dic[arr[i]].append(i)\n        visited = [False] * (len(arr))\n        queue=collections.deque()\n        queue.append((0,0))\n        ans = 0\n        N = len(arr)\n        while(queue):\n            i,step = queue.popleft()\n            print((i,step))\n            if(i == N-1):\n                ans = step\n                break\n            if visited[i] == False:\n                if(i+1<N and not visited[i+1]):\n                    queue.append((i+1,step+1))\n                if(i-1>=0 and not visited[i-1]):\n                    queue.append((i-1,step+1))\n                for index in dic[arr[i]]:\n                    if(visited[index] == False):\n                        queue.append((index,step+1))\n                visited[i] = True\n                dic[arr[i]] = []  \n                        \n        return ans\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        endpos = len(arr)-1\n        graph = {}\n        for i,n in enumerate(arr):\n            if n not in graph:\n                graph[n] = []\n            graph[n].append(i)\n        \n        curr = set([0])\n        hit = set()\n        mark = 0\n        while curr:\n            nxt = set()\n            for i in curr:\n                hit.add(i)\n                if i == endpos:\n                    return mark\n                if i != 0 and i-1 not in hit:\n                    nxt.add(i-1)\n                if i+1 not in hit:\n                    nxt.add(i+1)\n                if arr[i] in graph:\n                    nxt.update([j for j in graph[arr[i]] if i != j and j not in hit])\n                    del graph[arr[i]]\n            mark += 1\n            curr = nxt\n        return -1", "\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        #minJump, shortest Path\n        \n        minJump = len(arr) + 1\n        graph = {}\n        for i, n in enumerate(arr):\n            if 1 < i <len(arr)-1 and arr[i-1] == arr[i] == arr[i+1]:\n                continue\n            graph[n] = graph.get(n, [])\n            graph[n].append(i)\n        \n        queue = collections.deque([0])\n        visited = set([0])\n        step = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node = queue.popleft()\n                if node == len(arr) - 1:\n                    return step\n                num = graph.pop(arr[node], [])\n                for nei in [node + 1, node - 1] +num:\n                    if nei not in visited and  0 <= nei < len(arr):\n                        queue.append(nei)\n                        visited.add(nei)\n            step += 1\n\n        \n        \n        \n\n#         num2Index = {}\n#         for i, item in enumerate(arr):\n#             if i> 1 and i < len(arr)-1 and arr[i] == arr[i+1] == arr[i-1] : \n#                 continue\n#             if item in num2Index:\n#                 num2Index[item].append(i)\n#             else:\n#                 num2Index[item] = [i]\n            \n\n#         queue = [(0, 0)] \n#         visited = set({0})\n#         step = 0\n\n#         while queue:\n#             size =len(queue)\n#             for _ in range(size):\n#                 pos, step = queue.pop(0)\n#                 if pos == len(arr) -1 :\n#                     return step\n#                 num = num2Index.pop(arr[pos], [])\n#                 for newpos in [pos + 1, pos - 1] + num:\n#                     if 0 <= newpos < len(arr) and newpos != pos and newpos not in visited:\n#                         visited.add(newpos)\n#                         if newpos == len(arr) -1 :\n#                             return step+1\n#                         queue.append((newpos, step + 1))\n                \n#         return step\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # U could do this in BFS, dont over thinking!\n        # Start from 0,0 (position, step)\n        # Record all the numbers and positions stepped on\n        # Once u stepped on certain number, u will try out all the candidates\n        # So no twice on the same number\n        # And each time check within valid range\n        record = collections.defaultdict(list)\n        for i,v in enumerate(arr):\n            record[v].append(i)\n        nums = set()\n        pos_met = set()\n        q = collections.deque([(0,0)])\n        while q:\n            pos,step = q.popleft()\n            if pos == len(arr)-1:return step\n            num = arr[pos]\n            pos_met.add(pos)\n            temp = [pos-1,pos+1]\n            if num not in nums:\n                for j in record[num]:\n                    temp += [j]\n            nums.add(num)\n            for i in temp:\n                # Here, even though u make sure the num is not stepped on \n                # Remember to check if the position is stepped on!\n                if 0<=i<len(arr) and i not in pos_met:\n                    q.append([i,step+1])\n", "class Solution:\n    def minJumps(self, arr) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n\n        graph = {}\n        for i in range(n):\n            if arr[i] in graph:\n                graph[arr[i]].append(i)\n            else:\n                graph[arr[i]] = [i]\n\n        curs = [0]  # store layers from start\n        visited = {0, n-1}\n        step = 0\n\n        other = [n-1] # store layers from end\n\n        # when current layer exists\n        while curs:\n            # search from the side with fewer nodes\n            if len(curs) > len(other):\n                curs, other = other, curs\n            nex = []\n\n            # iterate the layer\n            for node in curs:\n\n                # check same value\n                for child in graph[arr[node]]:\n                    if child in other:\n                        return step + 1\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                # clear the list to prevent redundant search\n                graph[arr[node]].clear()\n\n                # check neighbors\n                for child in [node-1, node+1]:\n                    if child in other:\n                        return step + 1\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n            curs = nex\n            step += 1\n\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        graph = defaultdict(set)\n        for i, num in enumerate(arr):\n            graph[num].add(i)\n        q = deque([0])\n        counter = 0\n        visited = [0] * len(arr)\n        visited[0] = 1\n        while q:\n            size = len(q)\n            for _ in range(size):\n                i = q.popleft()\n                if i == len(arr) - 1:\n                    return counter\n                num = arr[i]\n                neighbors = graph[num]\n                for neighbor in neighbors:\n                    if not visited[neighbor]:\n                        q.append(neighbor)\n                        visited[neighbor] = 1\n                graph.pop(num)\n                if i + 1 < len(arr) and not visited[i + 1]:\n                    q.append(i + 1)\n                    visited[i + 1] = 1\n                if i - 1 >= 0 and not visited[i - 1]:\n                    q.append(i - 1)\n                    visited[i - 1] = 1\n            counter += 1\n\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \n        if len(arr)==1:\n            return 0\n        \n        # prune duplicates\n        i=0\n        while i<len(arr)-2:\n            if arr[i]==arr[i+1]==arr[i+2]:\n                arr.pop(i)\n            else:\n                i+=1   \n        \n        def jump(i):\n            nexts=[]\n            if i-1>=0:\n                nexts.append(i-1)\n            if i+1<len(arr):\n                nexts.append(i+1)\n            for index in d[arr[i]]:\n                #print('index', index)\n                if index != i:\n                    nexts.append(index)\n            return nexts\n                \n                \n        d={}\n        for i in range(len(arr)-1, -1, -1):\n            if arr[i] in d:\n                d[arr[i]].add(i)\n            else:\n                d[arr[i]]={i} # value is set\n        \n        for k,v in list(d.items()):\n            d[k]=list(v)\n            d[k].sort(reverse=True)\n        q=deque()\n        \n        visited=set()\n        q.append(0)\n        visited.add(0)\n        steps=-1\n        while q:\n            size=len(q)\n            steps +=1\n            for i in range(size):\n                pop_index=q.popleft()\n                if pop_index==len(arr)-1:\n                    return steps\n                for nex in jump(pop_index):\n                    if nex not in visited:\n                        q.append(nex)\n                        visited.add(nex)\n        return -1\n                \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n            \n", "from collections import defaultdict,deque\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        g=defaultdict(list)\n        \n        for i,n in enumerate(arr):\n            g[n].append(i)\n        \n        cur=[0]\n        step=0\n        seen={0}\n        while cur:\n            nex=[]\n            for i in cur:\n                if i==len(arr)-1:\n                    return step\n                for adj in g[arr[i]]:\n                    if adj not in seen:\n                        seen.add(adj)\n                        nex.append(adj)\n                g[arr[i]].clear()\n                if i-1>=0 and i-1 not in seen:\n                    seen.add(i-1)\n                    nex.append(i-1)\n                if i+1<len(arr) and i+1 not in seen:\n                    seen.add(i+1)\n                    nex.append(i+1)\n            step+=1\n            cur=nex\n        return -1\n            \n#         idx=defaultdict(list)\n#         for i,n in enumerate(arr):\n#             if n in idx:\n#                 for j in idx[n]:\n#                     g[i].add(j)\n#                     g[j].add(i)\n#             idx[n].append(i)\n#             if i>0:\n#                 g[i].add(i-1)\n#                 g[i-1].add(i)\n        \n#         q=deque([(0,0)])\n#         seen=set()\n#         while q:\n#             i,step = q.popleft()\n#             if i==len(arr)-1:\n#                 return step\n#             if i in seen:\n#                 continue\n#             seen.add(i)\n#             for adj in g[i]:\n#                 q.append((adj,step+1))\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return 0\n        \n        # intuition: BFS\n        dic = {}\n        for i, num in enumerate(arr):\n            if num not in dic:\n                dic[num] = set()\n            dic[num].add(i)\n        \n        bag= set(list(range(1, len(arr))))\n        queue = [0]\n        res = 0\n        print(bag)\n        while len(queue) > 0:\n            l = len(queue)\n            for _ in range(l):\n                node = queue.pop(0)\n                if node == len(arr)-1:\n                    return res\n                # neighbors\n                if node > 0:\n                    if node-1 in bag:\n                        queue.append(node-1)\n                        bag.remove(node-1)\n                        if arr[node-1] in dic and node-1 in dic[arr[node-1]]:\n                            dic[arr[node-1]].remove(node-1)\n                            if not dic[arr[node-1]]:\n                                del dic[arr[node-1]]\n                if node < len(arr) -1:\n                    if node + 1 in bag:\n                        queue.append(node+1)\n                        bag.remove(node+1)\n                        if arr[node-1] in dic and node-1 in dic[arr[node-1]]:\n                            dic[arr[node-1]].remove(node-1)\n                            if not dic[arr[node-1]]:\n                                del dic[arr[node-1]]\n                # SAME VALUE\n                if arr[node] in dic:\n                    for i in dic[arr[node]]:    \n                        if i in bag:\n                            bag.remove(i)\n                            queue.append(i)\n                    del dic[arr[node]]\n            res += 1\n                \n                    \n                \n                        \n            \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        '''\n        #\u6700\u77ed\u5c31\u5229\u7528BFS\n        '''\n        n=len(arr)\n        g=collections.defaultdict(list)\n        for i,v in enumerate(arr):\n            g[v].append(i)\n        #\u5b58\u653e\u540c\u503c\u7684\u4f4d\u7f6e\n        visit=[0]*n\n        values=set()\n        step=0\n        q=[0]\n        while q:\n            size=len(q)\n            for _ in range(size):\n                cur=q.pop(0)\n                if cur==n-1:\n                    return step\n                for i in [cur-1,cur+1]:\n                    if 0<=i<n and not visit[i]:\n                        visit[i]=1\n                        q.append(i)\n                if arr[cur] not in values:\n                    values.add(arr[cur])\n                    for i in g[arr[cur]]:\n                        if not visit[i]:\n                            visit[i]=1\n                            q.append(i)\n            step+=1\n        return step", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        v_jumped = set()\n        v_idx = collections.defaultdict(list)\n        for i,v in enumerate(arr):\n            v_idx[v].append(i)\n        \n        q = [0]\n        seen_idx = {0}\n        \n        step = 0\n        while q:\n            sz = len(q)\n            for _ in range(sz):\n                i = q.pop(0)\n                if i == len(arr)-1:\n                    return step\n                if arr[i] not in v_jumped:\n                    v_jumped.add(arr[i])\n                    for j in v_idx[arr[i]]:\n                        if j not in seen_idx:\n                            seen_idx.add(j)\n                            q.append(j)\n                if i + 1 < len(arr) and i+1 not in seen_idx:\n                    seen_idx.add(i+1)\n                    q.append(i+1)\n                if i-1 >= 0 and i-1 not in seen_idx:\n                    seen_idx.add(i-1)\n                    q.append(i-1)\n            step += 1\n        return -1\n        \n", "class Solution:\n    def minJumps(self, arr):\n        n = len(arr)\n        if n == 1: return 0 \n        d = defaultdict(list)\n        for i,val in enumerate(arr):\n            d[val].append(i)\n        visited = set([0])\n        check = set()\n        stack = [0]\n        k, jumps = len(stack), 1\n        while stack:\n            i = stack.pop(0)\n            childs = [i-1,i+1] \n            if arr[i] not in check:\n                childs += [j for j in d[arr[i]]]\n                check.add(arr[i])\n            childs = [j for j in childs if 0 <= j < n and j not in visited]\n            childs = set(childs)\n            for j in childs:\n                if j == n-1: return jumps\n                visited.add(j)\n                stack.append(j)\n            k -= 1\n            if not k:\n                k = len(stack)\n                jumps += 1\n        return jumps", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        def BFS(queue):\n            seen , val_seen = [1]*len(arr) , set();seen[0] = 0\n            while queue:\n                var , level = queue.pop(0)\n                if var == len(arr) - 1:return level\n                if seen[var + 1]:queue.append([var+1,level+1]);seen[var+1] = 0\n                if var - 1 >=0 and   seen[var - 1]:queue.append([var-1,level+1]);seen[var-1] = 0\n                if arr[var] not in val_seen:  \n                    for i in d[arr[var]]:\n                        if seen[i]:queue.append([i,level+1]);seen[i] = 0\n                val_seen.add(arr[var])\n        \n        d = defaultdict(list)\n        for i , v in enumerate(arr):d[v] +=[i]\n        return (BFS([[0,0]]))", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        g = collections.defaultdict(list)\n        for i, num in enumerate(arr):\n            g[num].append(i)\n        visited = set()\n        q = deque([(0,0)]) #idx,step\n        \n        while q:\n            idx,step = q.popleft()\n            if idx == len(arr)-1:\n                return step\n            visited.add(idx)\n            for n_idx in [idx-1,idx+1]+ g[arr[idx]]:\n                if n_idx not in visited and 0<=n_idx<len(arr):\n                    q.append((n_idx,step +1))\n            del g[arr[idx]]", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        record={}\n        for idx,item in enumerate(arr,0):\n            if item not in record:\n                record[item]=[idx]\n            else:\n                if record[item][-1]+2>=idx:\n                    record[item][-1]=idx\n                else:\n                    record[item].append(idx)\n        queue=[0]\n        ret=[-1]*len(arr)\n        ret[0]=0\n        step=0\n        last=len(arr)-1\n        while queue:\n            target=[]\n            step+=1\n            for idx in queue:\n                if idx>0 and ret[idx-1]==-1:\n                    target.append(idx-1)\n                    ret[idx-1]=step\n                if idx+1<len(arr) and ret[idx+1]==-1:\n                    target.append(idx+1)\n                    ret[idx+1]=step\n                    if idx+1==last:\n                        return step\n                for pos in record[arr[idx]]:\n                    if pos==idx:\n                        continue\n                    if ret[pos]==-1:\n                        target.append(pos)\n                        ret[pos]=step\n                        if pos==last:\n                            return step\n            queue=target\n        return ret[-1]", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        dic = collections.defaultdict(list)\n        for i, num in enumerate(arr):\n            dic[num].append(i)\n        queue = [0]\n        pos_visited = set([0])\n        num_visited = set()\n        step = 0\n        while queue:\n            for _ in range(len(queue)):\n                cur = queue.pop(0)\n                if cur == n - 1:\n                    return step\n                for nextIdx in [cur - 1, cur + 1] + dic[arr[cur]] * (arr[cur] not in num_visited):\n                    if 0 <= nextIdx < n and nextIdx not in pos_visited:\n                        pos_visited.add(nextIdx)\n                        queue.append(nextIdx)\n                num_visited.add(arr[cur])\n            step += 1\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        N = len(arr)\n        last_idx = N - 1\n        indices = collections.defaultdict(set)\n\n        for i, a in enumerate(arr):\n            indices[a].add(i)\n\n        moves = [None] * N\n        moves[0] = 0\n        edges = []\n        idx = 0\n        seen_values = set()\n\n        def reachables(i):\n            idx_set = set()\n            if arr[i] not in seen_values:\n                seen_values.add(arr[i])\n                idx_set |= indices[arr[i]]\n            if i-1 >= 0:\n                idx_set.add(i-1)\n            if i+1 < N:\n                idx_set.add(i+1)\n            if i in idx_set:\n                idx_set.remove(i)\n            return idx_set\n\n        while idx != last_idx:\n            for j in reachables(idx):\n                if moves[j] is None:\n                    heapq.heappush(edges, (moves[idx]+1, j))\n\n            move, idx = heapq.heappop(edges)\n            moves[idx] = move\n\n        return moves[idx]", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \n        seen = { 0 }\n        q = [0]\n        goal = len(arr) - 1\n        \n        linked = collections.defaultdict(list)\n        for idx, x in enumerate(arr):\n            linked[x].append(idx)\n            \n            \n        q_back = [goal]\n        q = [0]\n        levels = -1\n        \n        while q:\n            levels += 1\n            q_len = len(q)\n            for _ in range(q_len):\n                idx = q.pop(0)\n\n                if idx == goal:\n                    \n                    return levels\n                \n                if idx + 1 not in seen:\n                    q.append(idx + 1)\n                    seen.add(idx + 1)\n                    \n                if idx > 0  and idx - 1 not in seen:\n                    q.append(idx - 1)\n                    seen.add(idx - 1)\n                    \n                for link in linked[arr[idx]]:\n                    if link not in seen:\n                        q.append(link)\n                        seen.add(link)\n                        \n                del linked[arr[idx]]\n                        \n                \n", "class Solution:\n    def minJumps(self, nums):\n        neighbors = defaultdict(list)\n        _ = [neighbors[num].append(i) for i, num in enumerate(nums)]\n        q = deque([(0, 0)])\n        num_seen, pos_seen = set(), set()\n        while q:\n            pos, step = q.popleft()\n            if pos == len(nums) - 1:\n                return step\n            num = nums[pos]\n            pos_seen.add(pos)\n            for p in [pos - 1, pos + 1] + neighbors[num] * (num not in num_seen):\n                if p in pos_seen or not 0 <= p < len(nums):\n                    continue\n                q.append((p, step + 1))\n\n            num_seen.add(num)", "from collections import defaultdict\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        '''\n        n = len(arr)\n        if n <= 1:\n            return 0\n\n        graph = {}\n        for i in range(n):\n            if arr[i] in graph:\n                graph[arr[i]].append(i)\n            else:\n                graph[arr[i]] = [i]\n\n        curs = [0]  # store current layers\n        visited = {0}\n        step = 0\n\n        # when current layer exists\n        while curs:\n            nex = []\n\n            # iterate the layer\n            for node in curs:\n                # check if reached end\n                if node == n-1:\n                    return step\n\n                # check same value\n                for child in graph[arr[node]]:\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                # clear the list to prevent redundant search\n                graph[arr[node]].clear()\n\n                # check neighbors\n                for child in [node-1, node+1]:\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n            curs = nex\n            step += 1\n\n        return -1\n        '''\n        # we start from index one and perform a bfs\n        # in order to perform bfs properly we create a mapping from number to all the indices the number is encountered\n        m = defaultdict(list)\n        for i in range(len(arr)):\n            m[arr[i]].append(i)\n        start = (0,0)\n        queue = [start]\n        visited = set([0])\n        while queue != []:\n            current = queue.pop(0)\n            # print(current,queue)\n            if current[0] == len(arr)-1:\n                return current[1]\n            if current[0] + 1 < len(arr) and current[0] + 1 not in visited:\n                queue.append((current[0]+1,current[1]+1))\n                visited.add(current[0] + 1)\n            if current[0] - 1 >= 0 and current[0] - 1 not in visited:\n                queue.append((current[0]-1,current[1]+1))\n                visited.add(current[0] - 1)\n            for n in m[arr[current[0]]]:\n                if n not in visited:\n                    queue.append((n,current[1] + 1))\n                    visited.add(n)\n            if arr[n] in m:\n                del m[arr[n]]\n        \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        def BFS(queue):\n            seen , val_seen = [1]*len(arr) , set();seen[0] = 0\n            while queue:\n                var , level = queue.pop(0)\n                if var == len(arr) - 1:return level\n                if seen[var + 1]:queue.append([var+1,level+1]);seen[var+1] = 0\n                if var - 1 >=0 and   seen[var - 1]:queue.append([var-1,level+1]);seen[var-1] = 0\n                if arr[var] not in val_seen:  \n                    for i in d[arr[var]]:\n                        if seen[i]:queue.append([i,level+1]);seen[i] = 0\n                val_seen.add(arr[var])\n        \n        d = defaultdict(list)\n        for i in range(len(arr)):d[arr[i]] +=[i]\n        return (BFS([[0,0]]))", "from collections import defaultdict\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:        \n        pos_m = defaultdict(set)        \n        for idx, val in enumerate(arr):\n            pos_m[val].add(idx)\n        visited = [float('inf') for i in range(len(arr))]\n        seen = set([0])        \n        steps = 0\n        pos_m[arr[0]].remove(0)\n        \n        # (idx, step)\n        q = [(0, 0)]\n        while q:\n            for _ in range(len(q)):\n                idx, step = q.pop(0)\n                if idx == len(arr)-1:\n                    return step\n                if idx > 0 and idx-1 not in seen:\n                    seen.add(idx-1)\n                    q.append((idx-1, step+1))\n                if idx+1 < len(arr) and idx+1 not in seen:\n                    seen.add(idx+1)\n                    q.append((idx+1, step+1))\n                # pos_to_remove = []\n                for pos in pos_m[arr[idx]]:\n                    if pos not in seen:\n                        seen.add(pos)\n                        q.append((pos, step+1))                    \n                        # pos_to_remove.append(pos)\n                del pos_m[arr[idx]]\n                # for pos in pos_to_remove:\n                #     pos_m[arr[idx]].remove(pos)\n                        \n        return -1\n        \n            \n                \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        nei = collections.defaultdict(list)\n        _ = [nei[x].append(i) for i, x in enumerate(arr)]\n\n        frontier = collections.deque([(0,0)])\n        num_met, pos_met = set(), set()\n        while frontier:\n            pos, step = frontier.popleft() # state: position, step\n            if pos == len(arr) - 1: return step\n            num = arr[pos]\n            pos_met.add(pos) # track explored positions\n\n            for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\n                if p in pos_met or not 0 <= p < len(arr): continue\n                frontier.append((p, step + 1))\n\n            num_met.add(num) # track explored values\n       \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # return self.bfs(arr)\n        return self.minJumpsBiBFS(arr)\n    def bfs(self, arr: List[int]):\n        arrLen = len(arr)\n        if arrLen <= 1:\n            return 0\n        adjList = defaultdict(set)\n        for i in range(len(arr)):\n            adjList[arr[i]].add(i)\n        queue = deque([0])\n        visited = set([0])\n        jump = 0\n        \n        while queue:\n            length = len(queue)\n            \n            for _ in range(length):\n                node = queue.popleft()\n                for nei in adjList[arr[node]]:\n                    if nei == arrLen-1:\n                        return jump+1\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    queue.append(nei)\n                adjList[arr[node]].clear()\n                    \n                if node + 1 < arrLen:\n                    if node + 1 == arrLen-1:\n                        return jump+1\n                    if node + 1 not in visited:\n                        visited.add(node + 1)\n                        queue.append(node + 1)\n                    \n                if node -1 >= 0:\n                    if node - 1 == arrLen-1:\n                        return jump+1\n                    if node - 1 not in visited:\n                        visited.add(node - 1)\n                        queue.append(node - 1)\n            jump += 1\n        return -1\n                \n            \n        \n    def minJumpsBiBFS(self, arr: List[int]) -> int:\n        arrLen = len(arr)\n        if arrLen <= 1:\n            return 0\n        adjList = defaultdict(set)\n        for i in range(len(arr)):\n            adjList[arr[i]].add(i)\n        frontQueue = deque([0])\n        rearQueue = deque([len(arr)-1])\n        visited = set([0])\n        jump = 0\n        \n        while frontQueue or rearQueue:\n            if len(frontQueue) > len(rearQueue):\n                frontQueue, rearQueue = rearQueue, frontQueue\n            length = len(frontQueue)\n            \n            for _ in range(length):\n                node = frontQueue.popleft()\n                for nei in adjList[arr[node]]:\n                    if nei in rearQueue:\n                        return jump+1\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    frontQueue.append(nei)\n                adjList[arr[node]].clear()\n                  \n                if node + 1 < arrLen:\n                    if node + 1 in rearQueue:\n                        return jump+1\n                    if node + 1 not in visited:\n                        visited.add(node + 1)\n                        frontQueue.append(node + 1)\n                    \n                if node -1 >= 0:\n                    if node - 1 in rearQueue:\n                        return jump+1\n                    if node - 1 not in visited:\n                        visited.add(node - 1)\n                        frontQueue.append(node - 1)\n            jump += 1\n        return -1\n                    \n", "class Solution:\n    def minJumps(self, arr) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n\n        graph = {}\n        for i in range(n):\n            if arr[i] in graph:\n                graph[arr[i]].append(i)\n            else:\n                graph[arr[i]] = [i]\n\n        curs = [0]  # store layers from start\n        visited = {0, n-1}\n        step = 0\n\n        other = [n-1] # store layers from end\n\n        # when current layer exists\n        while curs:\n            # search from the side with fewer nodes\n            if len(curs) > len(other):\n                curs, other = other, curs\n            nex = []\n\n            # iterate the layer\n            for node in curs:\n\n                # check same value\n                for child in graph[arr[node]]:\n                    if child in other:\n                        return step + 1\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                # clear the list to prevent redundant search\n                #graph[arr[node]].clear()\n\n                # check neighbors\n                for child in [node-1, node+1]:\n                    if child in other:\n                        return step + 1\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n            curs = nex\n            step += 1\n\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return 0\n        else:\n            num_indices = defaultdict(list)\n            for i in range(len(arr) - 1, -1, -1):\n                num_indices[arr[i]].append(i)\n            visited = {0}\n            queue = deque()\n            queue.append((0, 0))\n            while queue:\n                i, steps = queue.popleft()\n                for j in [i - 1, i + 1] + num_indices[arr[i]]:\n                    if j not in visited and 0 <= j < len(arr):\n                        if j == len(arr) - 1:\n                            return steps + 1\n                        else:\n                            queue.append((j, steps + 1))\n                            visited.add(j)", "from collections import defaultdict\nfrom collections import deque\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return 0\n\n        indexes = defaultdict(list)\n\n        for i, v in enumerate(arr):\n            if i == 0 or arr[i - 1] != v:\n                indexes[v].append(i)\n\n        queue = deque([(0, True), (len(arr) - 1, False)])\n        minimum_steps = {0:0}\n        minimum_steps_negative = {len(arr) - 1:0}\n        while queue:\n            curPos, direction = queue.popleft()\n\n            if direction and curPos in minimum_steps_negative:\n                return minimum_steps_negative[curPos] + minimum_steps[curPos]\n            if not direction and curPos in minimum_steps:\n                return minimum_steps_negative[curPos] + minimum_steps[curPos]\n\n            candidates = []\n\n            if curPos > 0:\n                candidates.append(curPos - 1)\n            if curPos < len(arr) - 1:\n                candidates.append(curPos + 1)\n            candidates.extend(indexes[arr[curPos]])\n\n            ans = []\n            for i in candidates:\n                if direction:\n                    checker = minimum_steps\n                else:\n                    checker = minimum_steps_negative\n\n                if i not in checker:\n                    checker[i] = checker[curPos] + 1\n                    queue.append((i, direction))", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n        \n        arr_f = []\n        prev = None\n        repeat = 0\n        for num in arr:\n            if num == prev:\n                if repeat == 2:\n                    continue\n                repeat += 1\n            else:\n                prev = num\n                repeat = 0\n            arr_f.append(num)\n        n = len(arr_f)\n\n        graph = {}\n        for i in range(n):\n            if arr_f[i] in graph:\n                graph[arr_f[i]].append(i)\n            else:\n                graph[arr_f[i]] = [i]\n\n        curs = [0]  # store current layers\n        visited = {0}\n        step = 0\n\n        # when current layer exists\n        while curs:\n            nex = []\n\n            # iterate the layer\n            for node in curs:\n                # check if reached end\n                if node == n-1:\n                    return step\n\n                # check same value\n                for child in graph[arr_f[node]]:\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                # clear the list to prevent redundant search\n                graph[arr_f[node]].clear()\n\n                # check neighbors\n                for child in [node-1, node+1]:\n                    if 0 <= child < n and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n            curs = nex\n            step += 1\n\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        map = collections.defaultdict(list)\n        for i, a in enumerate(arr):\n            map[a].append(i)\n        \n        visited, visiting = {-1}, {0}\n        for steps in itertools.count():\n            visited |= visiting\n            if len(arr) - 1 in visited:\n                return steps\n            visiting = {j for i in visiting for j in [i - 1, i + 1] + map.pop(arr[i], [])} - visited", "from collections import deque\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \n        # construct graph\n        n = len(arr)\n        graph = collections.defaultdict(list)\n        for i, num in enumerate(arr):\n            graph[num].append(i)\n        \n        # bfs\n        queue = deque([0])\n        visited = set([0])\n        \n        steps = 0\n        while queue:\n            level_size = len(queue)\n            for _ in range(level_size):\n                curr_idx = queue.popleft()\n                if curr_idx == n - 1:\n                    return steps\n                for nxt_idx in [curr_idx - 1, curr_idx + 1] + graph[arr[curr_idx]][::-1]:\n                    if 0 <= nxt_idx < n and nxt_idx not in visited:\n                        if nxt_idx == n - 1:\n                            return steps + 1\n                        queue.append(nxt_idx)\n                        visited.add(nxt_idx)\n            steps += 1\n            \n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # return self.bfs(arr)\n        return self.minJumpsBiBFS(arr)\n    def bfs(self, arr: List[int]):\n        arrLen = len(arr)\n        if arrLen <= 1:\n            return 0\n        adjList = defaultdict(set)\n        for i in range(len(arr)):\n            adjList[arr[i]].add(i)\n        queue = deque([0])\n        visited = set([0])\n        jump = 0\n        \n        while queue:\n            length = len(queue)\n            \n            for _ in range(length):\n                node = queue.popleft()\n                for nei in adjList[arr[node]]:\n                    if nei == arrLen-1:\n                        return jump+1\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    queue.append(nei)\n                adjList[arr[node]].clear()\n                    \n                if node + 1 < arrLen:\n                    if node + 1 == arrLen-1:\n                        return jump+1\n                    if node + 1 not in visited:\n                        visited.add(node + 1)\n                        queue.append(node + 1)\n                    \n                if node -1 >= 0:\n                    if node - 1 == arrLen-1:\n                        return jump+1\n                    if node - 1 not in visited:\n                        visited.add(node - 1)\n                        queue.append(node - 1)\n            jump += 1\n        return -1\n                \n            \n        \n    def minJumpsBiBFS(self, arr: List[int]) -> int:\n        arrLen = len(arr)\n        if arrLen <= 1:\n            return 0\n        adjList = defaultdict(set)\n        for i in range(len(arr)):\n            adjList[arr[i]].add(i)\n        frontQueue = deque([0])\n        rearQueue = deque([len(arr)-1])\n        visited = set([0])\n        jump = 0\n        \n        while frontQueue or rearQueue:\n            if len(frontQueue) > len(rearQueue):\n                frontQueue, rearQueue = rearQueue, frontQueue\n            length = len(frontQueue)\n            \n            for _ in range(length):\n                node = frontQueue.popleft()\n                for nei in adjList[arr[node]]:\n                    if nei in rearQueue:\n                        return jump+1\n                    if nei in visited:\n                        continue\n                    visited.add(nei)\n                    frontQueue.append(nei)\n                    \n                if node + 1 < arrLen:\n                    if node + 1 in rearQueue:\n                        return jump+1\n                    if node + 1 not in visited:\n                        visited.add(node + 1)\n                        frontQueue.append(node + 1)\n                    \n                if node -1 >= 0:\n                    if node - 1 in rearQueue:\n                        return jump+1\n                    if node - 1 not in visited:\n                        visited.add(node - 1)\n                        frontQueue.append(node - 1)\n            jump += 1\n        return -1\n                    \n", "\nclass Solution:\n    # bidirectional, best 416 ms, memory 99.90%\n    def minJumps(self, arr):\n        length = len(arr)\n        # if no any connection in nodes, answer equals to array length - 1\n        if len(set(arr)) == length: return length - 1\n        if arr[0] == arr[-1]: return 1\n\n        _map = defaultdict(set) # connection map\n        for i, val in enumerate(arr): _map[val].add(i)\n\n        # BFS, seen: visited index, visit: visited connection\n        res, seen, visit = 0, {0}, set()\n        # curs: nodes in current side level, other: nodes in opposite side\n        curs, other = {0}, {length - 1}\n        while curs:\n            res += 1\n            # store found nodes in this level\n            thisLevel = set()\n            for i in curs:\n                # check move backwards \n                if i - 1 > 0 and i - 1 not in seen: \n                    thisLevel.add(i - 1)\n                # check in place\n                if arr[i] in _map:\n                    thisLevel |= (_map[arr[i]] - seen) \n                    visit.add(arr[i])\n                    del _map[arr[i]]\n                # check move forwards\n                if i + 1 < length and i + 1 not in seen: \n                    thisLevel.add(i + 1)\n\n            # check if this level and the other side intersect\n            if thisLevel & other: return res  \n\n            # update current side for next round          \n            curs = thisLevel\n            # choose smaller side into next round \n            if len(curs) > len(other): curs, other = other, curs\n            # if we don't exchange, put found nodes into seen\n            # because they are found in current direction\n            else: seen |= thisLevel", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) == 1: return 0\n        \n        cost = 0\n        size = len(arr)\n        visited = [False] * size\n        visited[0] = True\n        \n        same = collections.defaultdict(list)\n        for p, n in enumerate(arr):\n            same[n].append(p)\n            \n        st = [0] # contains same cost vals\n        cost = 0\n        \n        while True:\n            nxt = []\n            cost += 1\n            # print(st)\n            while st:\n                cur = st.pop()\n                # print()\n                for nei in same[arr[cur]] + [cur-1, cur+1]:\n                    # print(nei, end=' ')\n                    if nei == cur or not 0 <= nei < size:\n                        continue\n                    if nei == size - 1:\n                        # print(st)\n                        return cost\n                    if not visited[nei]:\n                        visited[nei] = True\n                        nxt.append(nei)\n            st = nxt\n            \n            \n        \n        \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        x=[]\n        x.append(arr[0])\n        for i in range(1,len(arr)-1):\n            if arr[i]==arr[i-1] and arr[i]==arr[i+1]:\n                continue\n            else:\n                x.append(arr[i])\n        if len(arr)>1:\n            x.append(arr[-1])\n        arr=x\n        d=collections.defaultdict(list)\n        for i in range(len(arr)):\n            d[arr[i]].append(i)\n        bfs=[0]\n        steps=0\n        temp=[]\n        seen=set([0])\n        while len(bfs)>0:\n            index = bfs.pop()\n            if index==len(arr)-1:\n                return steps\n            if (index+1)<len(arr) and (index+1) not in seen:\n                temp.append(index+1)\n                seen.add(index+1)\n            if (index-1)>=0 and (index-1) not in seen:\n                temp.append(index-1)\n                seen.add(index-1)\n            for i in d[arr[index]]:\n                if i not in seen:\n                    temp.append(i)\n                    seen.add(i)\n\n            if len(bfs)==0:\n                bfs=temp\n                temp=[]\n                steps+=1\n\n        return steps\n            \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        pos = defaultdict(list)\n        for i, num in enumerate(arr):\n            pos[num].append(i)\n        \n        q, steps = deque([0]), 0\n        seen = [False]*n\n        seen[0] = True\n        while q:\n            size = len(q)\n            for _ in range(size):\n                i = q.popleft()\n                if i == n-1:\n                    return steps\n                # jump to i+1\n                if i+1 < n and not seen[i+1]:\n                    q.append(i+1)\n                    seen[i+1] = True\n                # jump to i-1\n                if i-1 > -1 and not seen[i-1]:\n                    q.append(i-1)\n                    seen[i-1] = True\n                # jump to j where arr[i] == arr[j]\n                for j in pos[arr[i]]:\n                    if not seen[j]:\n                        q.append(j)\n                        seen[j] = True\n                pos[arr[i]].clear()\n            steps += 1\n        \n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        \n        arr_f = []\n        prev = None\n        repeat = 0\n        for num in arr:\n            if num == prev:\n                if repeat == 2:\n                    continue\n                repeat += 1\n            else:\n                prev = num\n                repeat = 0\n            arr_f.append(num)\n        n = len(arr_f)\n        \n        idx_by_num = defaultdict(list)\n        for i in range(n):\n            idx_by_num[arr_f[i]].append(i)\n        \n        q = [(0, n-1)]\n        visited = set([n-1])\n        while q:\n            step, cidx = q.pop(0)\n            if cidx == 0:\n                return step\n            \n            if cidx - 1 not in visited:\n                visited.add(cidx - 1)\n                q.append((step + 1, cidx - 1))\n            if cidx + 1 < n and cidx + 1 not in visited:\n                visited.add(cidx + 1)\n                q.append((step + 1, cidx + 1))\n            \n            for same_v_idx in idx_by_num[arr_f[cidx]]:\n                if same_v_idx not in visited:\n                    visited.add(same_v_idx)\n                    q.append((step + 1, same_v_idx))\n            \n        \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        \n        arr_f = []\n        prev = None\n        repeat = 0\n        for num in arr:\n            if num == prev:\n                if repeat == 2:\n                    continue\n                repeat += 1\n            else:\n                prev = num\n                repeat = 0\n            arr_f.append(num)\n        n = len(arr_f)\n        \n        idx_by_num = defaultdict(list)\n        for i in range(n):\n            idx_by_num[arr_f[i]].append(i)\n        \n        q = [(0, n-1)]\n        visited = set([n-1])\n        while q:\n            step, cidx = q.pop(0)\n            if cidx == 0:\n                return step\n            \n            if cidx - 1 not in visited:\n                visited.add(cidx - 1)\n                q.append((step + 1, cidx - 1))\n            if cidx + 1 < n and cidx + 1 not in visited:\n                visited.add(cidx + 1)\n                q.append((step + 1, cidx + 1))\n            \n            for same_v_idx in idx_by_num[arr_f[cidx]]:\n                if same_v_idx not in visited:\n                    visited.add(same_v_idx)\n                    q.append((step + 1, same_v_idx))\n            \n            idx_by_num[arr_f[cidx]].clear()\n            \n        \n", "# https://leetcode.com/problems/jump-game-iv/discuss/774915/Python-Easy!-BFS-Solution-oror-Time-Complexity%3A-O(n)\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return 0\n        \n        d = collections.defaultdict(list)\n        for index, element in enumerate(arr):\n            d[element].append(index)\n\n        queue = deque([(0, 0)])\n        s = set([0])\n\n        while len(queue):\n            currIndex, jumps = queue.popleft()\n\n            for nextIndex in [currIndex - 1, currIndex + 1] + d[arr[currIndex]][::-1]:\n                if nextIndex < len(arr) and nextIndex >= 0 and nextIndex != currIndex and nextIndex not in s:\n                    if nextIndex == len(arr) - 1:\n                        return jumps + 1\n                    s.add(nextIndex)\n                    queue.append((nextIndex, jumps + 1))\n\n        return -1\n", "# https://leetcode.com/problems/jump-game-iv/discuss/774915/Python-Easy!-BFS-Solution-oror-Time-Complexity%3A-O(n)\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) == 1:\n            return 0\n        \n        d = collections.defaultdict(list)\n        for index, element in enumerate(arr):\n            d[element].append(index)\n\n        queue = collections.deque([(0, 0)])\n        s = set()\n        s.add(0)\n\n        while len(queue):\n            currIndex, jumps = queue.popleft()\n\n            for nextIndex in [currIndex - 1, currIndex + 1] + d[arr[currIndex]][::-1]:\n                if nextIndex < len(arr) and nextIndex >= 0 and nextIndex != currIndex and nextIndex not in s:\n                    if nextIndex == len(arr) - 1:\n                        return jumps + 1\n                    s.add(nextIndex)\n                    queue.append((nextIndex, jumps + 1))\n\n        return -1\n", "# from collections import deque\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        graph = collections.defaultdict(list)\n        for i,val in enumerate(arr):\n            graph[val].append(i)\n            \n        def dfs():\n            queue = deque() # or we could also write it as deque([])\n            queue.append((0,0))# start index ,steps(level)\n            seen={0}\n            \n            while queue:\n                i,d= queue.popleft()\n                if i==len(arr)-1:\n                    return(d)\n                \n                for j in [i-1,i+1]+ graph[arr[i]][::-1] : # not reversing the array will TLE, even though its correct, cause it will again do BFS on ith index instead of trying other ones first\n                    if 0<=j<len(arr) and j not in seen and j!=i:\n                        seen.add(j)\n                        if j==len(arr)-1: # again this part is imp otherwise it will TLE\n                            return(d+1)\n                        queue.append((j,d+1))\n        \n        return( dfs() )\n    \n#         q = deque([[0, 0]])\n#         d = defaultdict(list)\n#         vis = set([0])\n#         for i,val in enumerate(arr):\n#             d[val].append(i)\n        \n#         while q:\n#             idx, steps = q.popleft()\n#             if idx == len(arr)-1:\n#                 return steps\n#             for i in d.pop(arr[idx], [])+[idx+1, idx-1]:\n#                 if i not in vis and i >= 0:\n#                     vis.add(i)\n#                     q.append([i, steps + 1])\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) <= 1:\n            return 0\n        bfs = []\n        heapq.heappush(bfs, (0,0))\n        seen = {}\n        seen[0] = 0\n        G = defaultdict(list)\n        for i, a in enumerate(arr):\n            G[a].append(i)\n        while bfs:\n            step, idx = heapq.heappop(bfs)\n            idx = -idx\n            for d in (-1, 1):\n                nidx = idx + d\n                if nidx >= 0 and nidx < len(arr):\n                    if nidx not in seen or seen[nidx] > step + 1:\n                        if nidx == len(arr) - 1:\n                            return step + 1\n                        seen[nidx] = step + 1\n                        heapq.heappush(bfs, (step + 1, -nidx))\n            for d in G[arr[idx]][::-1]:\n                if d not in seen or seen[d] > step + 1:\n                    if d == len(arr) - 1:\n                        return step + 1\n                    seen[d] = step + 1\n                    heapq.heappush(bfs, (step + 1, -d))\n        return -1", "from collections import defaultdict, deque\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) <= 1:\n            return 0\n        mapping = defaultdict(list)\n        for idx, val in enumerate(arr):\n            mapping[val].append(idx)\n        visited = set()\n        que = deque()\n        que.append((0, 0))\n        visited.add(0)\n        m = len(arr)\n        while que:\n            top = que.popleft()\n            idx, depth = top[0], top[1]\n            if idx + 1 < m and (idx+1) not in visited:\n                if idx+1  == (m-1):\n                    return depth + 1\n                visited.add(idx+1)\n                que.append((idx+1, depth+1))\n            if idx-1 >= 0 and (idx-1) not in visited:\n                visited.add(idx-1)\n                que.append((idx-1, depth+1))\n            for neigh in mapping[arr[idx]]:\n                if neigh not in visited:\n                    if  neigh == m-1:\n                        return depth+1\n                    visited.add(neigh)\n                    que.append((neigh, depth+1))\n            mapping.pop(arr[idx])\n        return -1", "from collections import *\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) <= 1:\n            return 0\n        mapper = defaultdict(set)\n        for i, x in enumerate(arr):\n            mapper[x].add(i)\n        end = len(arr) - 1\n        queue = deque([(arr[0],0,0)])\n        vis = set()\n        vis.add(0)\n        while queue:\n            # print(queue)\n            num, index, count = queue.popleft()\n            if index == end:\n                return count\n            if num in mapper:\n                for y in mapper.pop(num):\n                    if y not in vis:\n                        queue.append((arr[y],y,count + 1))\n                        vis.add(y)\n            if index+1 <= end and index + 1 not in vis:\n                queue.append((arr[index+1],index+1,count + 1))\n                vis.add(index+1)\n            if index-1 >= 0 and index - 1 not in vis:\n                queue.append((arr[index-1],index-1,count + 1))\n                vis.add(index-1)", "\nclass Solution:\n    def minJumps(self, arr):\n        length = len(arr)\n        if len(set(arr)) == length: return length - 1\n        if arr[0] == arr[-1]: return 1\n\n        _map = defaultdict(set) # connection map\n        for i, val in enumerate(arr): _map[val].add(i)\n\n        res, seen, visit = 0, {0}, set()\n        curs, other = {0}, {length - 1}\n        while curs:\n            res += 1\n\n            thisLevel = set()\n            for i in curs:\n                if i - 1 > 0 and i - 1 not in seen: \n                    thisLevel.add(i - 1)\n                if arr[i] in _map:\n                    thisLevel |= (_map[arr[i]] - seen) \n                    visit.add(arr[i])\n                    del _map[arr[i]]\n                if i + 1 < length and i + 1 not in seen: \n                    thisLevel.add(i + 1)\n\n            if thisLevel & other: return res          \n            curs = thisLevel\n            if len(curs) > len(other): curs, other = other, curs\n            else: seen |= thisLevel", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n\n        graph = {}\n        for i in range(n):\n            if arr[i] in graph:\n                graph[arr[i]].append(i)\n            else:\n                graph[arr[i]] = [i]\n\n        curs = [0]  # store current layers\n        visited = {0}\n        step = 0\n\n        # when current layer exists\n        while curs:\n            nex = []\n\n            # iterate the layer\n            for node in curs:\n                # check if reached end\n                if node == n-1:\n                    return step\n\n                # check same value\n                for child in graph[arr[node]]:\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                # clear the list to prevent redundant search\n                graph[arr[node]].clear()\n\n                # check neighbors\n                for child in [node-1, node+1]:\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n            curs = nex\n            step += 1\n\n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n        #construct graph\n        valueIndex = collections.defaultdict(list)\n        for i, a in enumerate(arr):\n            valueIndex[a].append(i)\n        \n#         graph = collections.defaultdict(list)\n#         for i in range(len(arr)):\n#             neighbor = []\n#             if i > 0:\n#                 neighbor.append(i-1)\n#             if i < len(arr) - 1:\n#                 neighbor.append(i+1)\n#             sameValueIndices = valueIndex[arr[i]]\n#             for idx in sameValueIndices:\n#                 if idx != i:\n#                     neighbor.append(idx)\n#             graph[i] = neighbor\n        \n        #BFS\n        queue = collections.deque([0])\n        visited = {0 : 0}\n        visitedValues = set()\n        while queue:\n            head = queue.popleft()\n            #print(f\\\"head={head}\\\")\n            if head == len(arr) - 1:\n                return visited[head]\n            \n            shortNeighbor = [head - 1, head + 1]\n            for neighbor in shortNeighbor:\n                if 0 <= neighbor < len(arr) and not neighbor in visited:\n                    visited[neighbor] = visited[head] + 1\n                    queue.append(neighbor)\n                \n            if arr[head] not in visitedValues:\n                visitedValues.add(arr[head])\n                for neighbor in valueIndex[arr[head]]:\n                    if neighbor not in visited:\n                        visited[neighbor] = visited[head] + 1\n                        queue.append(neighbor)\n            \n        return visited[len(arr) - 1]\n                \n            \n            \n        \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        q = deque([[0, 0]])\n        d = defaultdict(list)\n        vis = set([0])\n        for i,val in enumerate(arr):\n            d[val].append(i)\n        \n        while q:\n            idx, steps = q.popleft()\n            if idx == len(arr)-1:\n                return steps\n            for i in d.pop(arr[idx], [])+[idx+1, idx-1]:\n                if i not in vis and i >= 0:\n                    vis.add(i)\n                    q.append([i, steps + 1])", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # Similar concept to jump game3, but here we need to find the minimum\n        # jumps so we need to use queue instead of stack, also we need to use\n        # hashmap to handle the third jump of mirror values\n        \n        # Base Case - No jumps needed\n        if len(arr) == 1:\n            return 0\n        \n        # Data Structure Declaration\n        q = collections.deque()\n        seen = set()\n        hashmap = collections.defaultdict(list)\n        destination = len(arr)-1\n        minJumps = 0\n        \n        # Store mirrors in hashmap\n        for index, num in enumerate(arr):\n            hashmap[num].append(index)\n        \n\n        # Traversal start points\n        q.append(0)\n        seen.add(0)\n\n        # Run loop until we have values in queue\n        while q:\n            \n            sizeQ = len(q)\n            \n            # Traverse the queue level by level\n            for i in range(sizeQ):\n                Pos = q.popleft()\n                # Check for destination\n                if Pos == destination:\n                    return minJumps\n                \n                # Number of choices for Jumping\n                nextPos = Pos + 1\n                prevPos = Pos - 1\n                mirrorPos = hashmap[arr[Pos]]\n                \n                # Add if nextPos is valid\n                if nextPos >= 0 and nextPos < len(arr) and nextPos not in seen:\n                    seen.add(nextPos)\n                    q.append(nextPos)\n                    \n                # Add if prevPos is valid\n                if prevPos >= 0 and prevPos < len(arr) and prevPos not in seen:\n                    seen.add(prevPos)\n                    q.append(prevPos)\n                \n                # Add if we have mirror elements present\n                if mirrorPos:\n                    for val in mirrorPos:\n                        if val >= 0 and val < len(arr) and val not in seen:\n                            seen.add(val)\n                            q.append(val)\n                    # Once current element is taken into account, delete from map\n                    del hashmap[arr[Pos]]\n            # for every level increase the number of Jumps\n            minJumps += 1\n        return minJumps", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) <= 1:\n            return 0\n        bfs = [0]\n        seen = set()\n        seen.add(0)\n        G = defaultdict(list)\n        for i, a in enumerate(arr):\n            G[a].append(i)\n        step = 0\n        while bfs:\n            cur, bfs = bfs, []\n            for idx in cur:\n                if idx == len(arr) - 1:\n                    return step\n                for d in (-1, 1):\n                    nidx = idx + d\n                    if nidx >= 0 and nidx < len(arr):\n                        if nidx not in seen:\n                            seen.add(nidx)\n                            bfs.append(nidx)\n                for d in G[arr[idx]]:\n                    if d not in seen:\n                        if d not in seen:\n                            seen.add(d)\n                            bfs.append(d)\n                G.pop(arr[idx])\n            step += 1\n        return -1", "from collections import defaultdict\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def adjacent(self, arr, i, jumps):\n        if i > 0:\n            yield i - 1\n        if i < len(arr) - 1:\n            yield i + 1\n        \n        for j in jumps[arr[i]]:\n            if i != j:\n                yield j\n        \n    def minJumps(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n        \n        jumps = defaultdict(set)\n        for i, v in enumerate(arr):\n            if i == 0 or i == len(arr) - 1 or arr[i - 1] != v or arr[i + 1] != v:\n                jumps[v].add(i)\n        \n        steps = {}\n        \n        pq = []\n        heappush(pq, (0, 0))\n        \n        while pq:\n            n, neg_i = heappop(pq)\n            i = -neg_i\n            \n            if i == len(arr) - 1:\n                return n\n            \n            for j in self.adjacent(arr, i, jumps):\n                if j not in steps or steps[j] > n + 1:\n                    steps[j] = n + 1\n                    heappush(pq, (n + 1, -j))\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        from collections import deque,defaultdict\n        d=defaultdict(set)\n        q=deque([0])\n        res=0\n        last=len(arr)-1\n        for i in range(len(arr)):\n            d[arr[i]].add(i)\n        d[arr[0]].remove(0)\n        print(d)\n        while q:\n            for i in range(len(q)):\n                e=q.popleft()\n                if e==last:\n                    return res\n                if e-1>=0 and e-1 in d[arr[e-1]]:\n                    q.append(e-1)\n                    d[arr[e-1]].remove(e-1)\n                if e+1<=last and e+1 in d[arr[e+1]]:\n                    q.append(e+1)\n                    d[arr[e+1]].remove(e+1)\n                for n in d[arr[e]]:\n                    q.append(n)\n                d[arr[e]]=[]\n            res+=1\n        return res\n                    \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \n        lim = len(arr)\n        d = dict()\n        \n        for i in range(0,lim):\n            if arr[i] in d:\n                d[arr[i]].append(i)\n            else:\n                d[arr[i]]=[i]\n        for x in d:\n            d[x].sort(reverse=True)\n        \n        start = []\n        a=[-1 for i in range(0,lim)]       \n        start = [[0,0]]\n        \n        for x in d[arr[0]]:\n            if x!=0:\n                start.append([x,1])\n                a[x]=1\n        \n        start.sort(key=lambda x: x[1])\n        while 1!=-1:\n            tmp = []\n            \n            for x in start:\n                \n                if x[0]==lim-1:\n                    return x[1]\n                if x[0]+1==lim-1:\n                    return x[1]+1\n                a[x[0]]=1\n                if x[0]>0 and a[x[0]-1]==-1:\n                    tmp.append([x[0]-1,x[1]+1])\n                if a[x[0]+1]==-1:\n                    tmp.append([x[0]+1,x[1]+1])\n                for y in d[arr[x[0]]]:\n                    \n                    if a[y]==-1:\n                        \n                        tmp.append([y,x[1]+1])\n              \n            start = tmp\n        \n                \n                \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n\n        graph = {} ## \u548c\u4e0a\u9762\u7684idxs\u662f\u4e00\u6837\u7684\n        for i in range(n):\n            if arr[i] in graph:\n                graph[arr[i]].append(i)\n            else:\n                graph[arr[i]] = [i]\n\n        curs = [0]  # store current layers\n        visited = {0}\n        step = 0\n\n        # when current layer exists\n        while curs:\n            nex = []\n\n            # iterate the layer\n            for node in curs: ## \u7528curs\u548cnxt\u4ee3\u66ffbfs\u91ccdeque\u7684\u4f5c\u7528\n                # check if reached end\n                if node == n-1:\n                    return step\n\n                # check same value\n                for child in graph[arr[node]]:\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                # clear the list to prevent redundant search\n                graph[arr[node]].clear()\n\n                # check neighbors\n                for child in [node-1, node+1]:\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n            curs = nex\n            step += 1\n\n        return -1", "from collections import deque\nfrom collections import defaultdict\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(arr) == 1: return 0\n        d = defaultdict(list)\n        for i, num in enumerate(arr):\n            d[num].append(i)\n        length = len(arr)\n        q = deque()\n        level = 0\n        q.append(0)\n        s = set()\n        s.add(0)\n        while(len(q) > 0):\n            size = len(q)\n            while size > 0:\n                top = q.popleft()\n                # if top == length - 1:\n                #     return level\n                if top - 1 >= 0 and top - 1 not in s:\n                    s.add(top-1)\n                    q.append(top-1)\n                if top + 1 < length and top + 1 not in s:\n                    if top + 1 == length - 1:\n                        return level + 1\n                    s.add(top+1)\n                    q.append(top+1)\n                for i in range(len(d[arr[top]])):\n                    idx = d[arr[top]][len(d[arr[top]]) - 1 - i]\n                    if idx not in s:\n                        if idx == length - 1:\n                            return level + 1\n                        q.append(idx)\n                        s.add(idx)\n                size -= 1\n            level += 1\n        return level\n            \n            \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        \n        m = len(arr)\n        seen = [False for _ in range(m)]\n        q = deque()\n        step = 0\n\n        quick_jump_graph = {}\n\n        for i in range(len(arr)):\n            if arr[i] in quick_jump_graph:\n                quick_jump_graph[arr[i]].append(i)\n            else:\n                quick_jump_graph[arr[i]] = [i]\n\n        q.append(0)\n\n        while(len(q)):\n            s = len(q)\n            for i in range(s):\n                cur_idx = q.popleft()\n                if cur_idx < 0 or cur_idx >= m or seen[cur_idx]:\n                    continue\n                elif cur_idx == m - 1:\n                    return step\n                else:\n                    seen[cur_idx] = True\n                    q.append(cur_idx + 1)\n                    q.append(cur_idx - 1)\n                    if len(quick_jump_graph[arr[cur_idx]]) != 0:\n                        for num in quick_jump_graph[arr[cur_idx]]:\n                            q.append(num)\n                        quick_jump_graph[arr[cur_idx]] = []\n            step += 1\n    \n        return -1", "from collections import deque,defaultdict\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        idxs=defaultdict(set)\n        for idx,e in enumerate(arr):\n            idxs[e].add(idx)\n        def bfs(idx):\n            q=deque([0])\n            step=-1\n            not_visited=set(range(len(arr)-1,0,-1))\n            while q:\n                step+=1\n                for _ in range(len(q)):\n                    node=q.popleft()\n                    if node==len(arr)-1:\n                        return step\n                    nxt_nodes=idxs[arr[node]]\n                    nxt_nodes=not_visited&nxt_nodes\n                    for nxt in [node-1,node+1]:\n                        if nxt in not_visited:\n                            nxt_nodes.add(nxt)\n                    if len(arr)-1 in nxt_nodes:\n                        return step+1\n                    not_visited.difference_update(nxt_nodes)\n                    nxt_nodes=sorted(nxt_nodes,reverse=True)\n                    q.extend(nxt_nodes)\n            return -1\n        return bfs(0)\n", "class Solution:\n    def minJumps_tle(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n\n        visited, L, lookup = set(), len(arr), collections.defaultdict(list)\n        que = collections.deque()\n        que.append((0, 0))\n        visited.add(0)\n\n        for k, v in enumerate(arr):\n            lookup[v].append(k)\n\n        while que:\n            c, s = que.popleft()\n            if c == L - 1:\n                return s\n            if c + 1 not in visited and c + 1 < L:\n                visited.add(c + 1)\n                que.append((c + 1, s + 1))\n            if L > c - 1 >= 0 and c - 1 not in visited:\n                visited.add(c - 1)\n                que.append((c - 1, s + 1))\n            for i in lookup[arr[c]]:\n                if i == c:\n                    continue\n                if i not in visited and 0 <= i < L:\n                    visited.add(i)\n                    que.append((i, s + 1))\n\n        return -1\n\n    def minJumps(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n\n        visited, L, lookup = set(), len(arr), collections.defaultdict(list)\n        que = collections.deque()\n        que.append(0)\n        visited.add(0)\n\n        for k, v in enumerate(arr):\n            lookup[v].append(k)\n        step = 0\n\n        while que:\n            size = len(que)\n\n            for i in range(size):\n                c = que.popleft()\n                if c == L - 1:\n                    return step\n\n                if c + 1 not in visited and 0 <= c + 1 < L:\n                    visited.add(c + 1)\n                    que.append(c+1)\n                if L > c - 1 >= 0 and c - 1 not in visited:\n                    visited.add(c - 1)\n                    que.append(c-1)\n                for i in lookup[arr[c]]:\n                    if i == c:\n                        continue\n                    if i not in visited and 0 <= i < L:\n                        visited.add(i)\n                        que.append(i)\n                del lookup[arr[c]]\n            step += 1\n\n        return -1\n\n\n\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        q = deque([[0, 0]])\n        d = defaultdict(list)\n        vis = set([0])\n        for i,val in enumerate(arr):\n            d[val].append(i)\n        \n        while q:\n            idx, steps = q.popleft()\n            if idx == len(arr)-1:\n                return steps\n            for i in d.pop(arr[idx], [])+[idx+1, idx-1][::-1]:\n                if i not in vis and i >= 0:\n                    vis.add(i)\n                    q.append([i, steps + 1])", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # dp (forward backward pass) didn't work\n        # from solution, do bfs\n        # but add mirror positions as neighbors\n        n = len(arr)\n        \n        mirrors = collections.defaultdict(list)\n        _ = [mirrors[x].append(i) for i,x in enumerate(arr)]\n        \n        visited = set()\n        q = collections.deque([(0,0)])\n        while q:\n            idx, jump = q.popleft()\n            if idx == n - 1:\n                return jump\n            \n            for nei in [idx-1, idx+1] + mirrors[arr[idx]]:\n                if 0 <= nei < n and nei not in visited:\n                    visited.add(nei)\n                    q.append((nei, jump + 1))\n            del mirrors[arr[idx]] # dont consider it from its neighbors again", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n\n        visited, L, lookup = set(), len(arr), collections.defaultdict(list)\n        que = collections.deque()\n        que.append((0, 0))\n        visited.add(0)\n\n        for k, v in enumerate(arr):\n            lookup[v].append(k)\n\n        while que:\n            c, s = que.popleft()\n            if c == L - 1:\n                return s\n            if c + 1 not in visited and c + 1 < L:\n                visited.add(c + 1)\n                que.append((c + 1, s + 1))\n            if L > c - 1 >= 0 and c - 1 not in visited:\n                visited.add(c - 1)\n                que.append((c - 1, s + 1))\n            for i in lookup[arr[c]]:\n                if i == c:\n                    continue\n                if i not in visited and 0 <= i < L:\n                    visited.add(i)\n                    que.append((i, s + 1))\n            del lookup[arr[c]]\n\n        return -1\n\n    def minJumps_2(self, arr: List[int]) -> int:\n        if not arr:\n            return 0\n\n        visited, L, lookup = set(), len(arr), collections.defaultdict(list)\n        que = collections.deque()\n        que.append(0)\n        visited.add(0)\n\n        for k, v in enumerate(arr):\n            lookup[v].append(k)\n        step = 0\n\n        while que:\n            size = len(que)\n\n            for i in range(size):\n                c = que.popleft()\n                if c == L - 1:\n                    return step\n\n                if c + 1 not in visited and 0 <= c + 1 < L:\n                    visited.add(c + 1)\n                    que.append(c + 1)\n                if L > c - 1 >= 0 and c - 1 not in visited:\n                    visited.add(c - 1)\n                    que.append(c - 1)\n                for i in lookup[arr[c]]:\n                    if i == c:\n                        continue\n                    if i not in visited and 0 <= i < L:\n                        visited.add(i)\n                        que.append(i)\n                # review, if I comment out this one, I would get TLE, for test case [7,7,7..7], it would repeat the check\n                # `if i not in visited and 0 <= i < L`\n                del lookup[arr[c]]\n            step += 1\n\n        return -1\n\n\n", "from collections import deque,defaultdict\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        idxs=defaultdict(set)\n        for idx,e in enumerate(arr):\n            idxs[e].add(idx)\n        def bfs(idx):\n            q=deque([0])\n            step=-1\n            not_visited=set(range(len(arr)-1,0,-1))\n            while q:\n                step+=1\n                for _ in range(len(q)):\n                    node=q.popleft()\n                    if node==len(arr)-1:\n                        return step\n                    nxt_nodes=idxs[arr[node]]\n                    nxt_nodes=not_visited&nxt_nodes\n                    for nxt in [node-1,node+1]:\n                        if nxt in not_visited:\n                            nxt_nodes.add(nxt)\n                    if len(arr)-1 in nxt_nodes:\n                        return step+1\n                    not_visited.difference_update(nxt_nodes)\n                    nxt_nodes=sorted(nxt_nodes,reverse=True)\n                    q.extend(nxt_nodes)\n            return -1\n        bfs(0)\n        return bfs(0)\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        visited = {0}\n        lookup = defaultdict(list)\n        for i, val in enumerate(arr):\n            lookup[val].append(i)\n        \n        deq = deque([(0,0)])\n        \n        while deq:\n            i, step = deq.popleft()\n            if i == len(arr) - 1:\n                return step\n            nxt_idx = [i-1, i+1]\n            nxt_idx.extend(lookup[arr[i]])\n            lookup[arr[i]] = []\n            for nxt in nxt_idx:\n                if 0 <= nxt < len(arr) and nxt not in visited:\n                    deq.append((nxt,step+1))\n                    visited.add(nxt)\n        return 0", "from collections import defaultdict\nfrom collections import deque\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:        \n        pos_m = defaultdict(set)        \n        for idx, val in enumerate(arr):\n            pos_m[val].add(idx)\n        visited = [float('inf') for i in range(len(arr))]\n        seen = set([0])        \n        steps = 0\n        pos_m[arr[0]].remove(0)\n        \n        # (idx, step)        \n        q = deque()\n        q.append((0,0))\n        while q:\n            for _ in range(len(q)):\n                idx, step = q.popleft()\n                if idx == len(arr)-1:\n                    return step\n                if idx > 0 and idx-1 not in seen:\n                    seen.add(idx-1)\n                    q.append((idx-1, step+1))\n                if idx+1 < len(arr) and idx+1 not in seen:\n                    seen.add(idx+1)\n                    q.append((idx+1, step+1))\n                for pos in pos_m[arr[idx]]:\n                    if pos not in seen:\n                        seen.add(pos)\n                        q.append((pos, step+1))                    \n                del pos_m[arr[idx]]\n                        \n        return -1\n        \n            \n                \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n#         graph = defaultdict(list)\n#         for i in range(len(arr)):\n#             graph[arr[i]].append(i)\n            \n#         visited = set()\n#         src,dest = 0,len(arr)-1\n#         queue = deque()\n#         queue.append((src,0))\n#         visited.add(src)\n        \n#         while queue:\n#             node,dist = queue.popleft()\n#             if node == dest:\n#                 return dist\n#             nextLayer = [node-1, node+1] + graph[arr[node]]\n            \n#             for child in nextLayer:\n                \n                \n#                 if 0 <= child < len(arr) and child != node and child not in visited:\n#                     visited.add(child)\n#                     if child == dest:\n                        \n#                         return dist+1\n#                     queue.append((child,dist+1))\n#             del graph[arr[node]]\n        \n#         return -1\n    \n        graph = defaultdict(list)\n        for i in range(len(arr)):\n            graph[arr[i]].append(i)\n        visited = set()\n        src, dest = 0, len(arr)-1\n        queue = deque()\n        queue.append((src, 0))\n        visited.add(src)\n        while queue:\n            vid, step = queue.popleft()\n            if vid == dest:\n                return step\n            nextLayer = [vid-1, vid+1] + graph[arr[vid]]\n            for v in nextLayer:\n                if 0<=v<len(arr) and v!=vid and v not in visited:\n                    visited.add(v)\n                    queue.append((v, step+1))\n            del graph[arr[vid]]\n        return -1\n        \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        \n        # map value to list of indices\n        idxs = defaultdict(list)\n        for i,v in enumerate(arr):\n            # don't care about v if it's sandwiched between two numbers of same value\n            if (0 < i < n-1 and arr[i-1] == v == arr[i+1]):\n                continue\n            idxs[v].append(i)\n        \n        # bfs\n        q = deque([(0, 0)])\n        visited = set()\n        while q:\n            i, cnt = q.popleft()\n            visited.add(i)\n            \n            if i == len(arr)-1:\n                return cnt\n            \n            # left, right case\n            for j in [i-1,i+1]:\n                if 0 <= j < n and j not in visited:\n                    q.append((j, cnt+1))\n            \n            # same-jump case\n            for j in idxs[arr[i]]:\n                if j != i and j not in visited:\n                    q.append((j, cnt+1))\n                    \n        return -1", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        dict1={}\n        i=0\n        n=len(arr)\n        while i<n:\n            if arr[i] in dict1:\n                dict1[arr[i]].append(i)\n            else:\n                dict1[arr[i]]=[i]\n            cur=arr[i]\n            j=1\n            while i+j<n:\n                if arr[i+j]==cur:\n                    j+=1\n                else:\n                    break   \n            if j>1:\n                dict1[arr[i]].append(i+j-1)\n            i+=j\n        \n        curPoss={0}\n        cnt=0\n        while curPoss!=[]:\n            nextPoss=set()\n            for cur in curPoss:\n                if cur==n-1:\n                    return cnt\n                #arr[cur]=None\n                l=cur-1\n                if 0<l<n and l not in curPoss and arr[l]!=None:\n                    nextPoss.add(l)\n                r=cur+1\n                if 0<r<n and r not in curPoss and arr[r]!=None:\n                    nextPoss.add(r)\n                #print(cur,arr[cur])\n                for i in dict1[arr[cur]]:\n                    if i!=cur and i not in curPoss and arr[i]!=None:\n                        nextPoss.add(i)\n                arr[cur]=None\n            curPoss=nextPoss\n            cnt+=1\n            \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        queue = deque([0])\n        visited = set([0])\n        map = defaultdict(list)\n        \n        for idx, num in enumerate(arr):\n            map[num].append(idx)\n            \n        step = 0\n        \n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                pos = queue.popleft()\n                if pos == len(arr) - 1:\n                    return step\n                for nxt in [pos - 1, pos + 1]:\n                    if nxt < 0 or nxt >= len(arr) or nxt in visited:\n                        continue\n                    queue.append(nxt)\n                    visited.add(nxt)\n                for neighbor in map[arr[pos]]:\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n                        visited.add(neighbor)\n                #  \u907f\u514dTLE ,\u7b2c\u4e00\u6b21\u5df2\u7ecf\u628a\u6240\u6709\u503c\u76f8\u540c\u7684\u52a0\u5230\u4e86queue\uff0c\u4e4b\u540e\u8bbf\u95ee\u5230\u548c\u5f53\u524d\u503c\u76f8\u540c\u7684idx\u65f6 \u4e0d\u9700\u8981\u518dapply \u7b2c\u4e09\u6761\u89c4\u5219\n                # \u5373for neighbor in map[arr[pos]]\n                del map[arr[pos]]\n            \n            step += 1\n        return -1\n", "from collections import deque,defaultdict\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        idxs=defaultdict(list)\n        for idx,e in enumerate(arr):\n            idxs[e].append(idx)\n        def bfs(idx):\n            q=deque([0])\n            step=-1\n            not_visited=set(range(len(arr)-1,0,-1))\n            while q:\n                step+=1\n                for _ in range(len(q)):\n                    node=q.popleft()\n                    if node==len(arr)-1:\n                        return step\n                    nxt_nodes=set(idxs[arr[node]]+[node+1,node-1])\n                    nxt_nodes=not_visited&nxt_nodes\n                    if len(arr)-1 in nxt_nodes:\n                        return step+1\n                    not_visited.difference_update(nxt_nodes)\n                    nxt_nodes=sorted(nxt_nodes,reverse=True)\n                    q.extend(nxt_nodes)\n            return -1\n        return bfs(0)\n", "class Solution:\n    def minJumps(self, arr) -> int:\n        n = len(arr)\n        if n <= 1:\n            return 0\n\n        graph = {}\n        for i in range(n):\n            if arr[i] in graph:\n                graph[arr[i]].append(i)\n            else:\n                graph[arr[i]] = [i]\n\n        curs = [0]  # store layers from start\n        visited = {0, n-1}\n        step = 0\n\n        other = [n-1] # store layers from end\n\n        # when current layer exists\n        while curs:\n            # search from the side with fewer nodes\n            if len(curs) > len(other):\n                curs, other = other, curs\n            nex = []\n\n            # iterate the layer\n            for node in curs:\n\n                # check same value\n                for child in graph[arr[node]]:\n                    if child in other:\n                        return step + 1\n                    if child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n                # clear the list to prevent redundant search\n                # graph[arr[node]].clear()\n\n                # check neighbors\n                for child in [node-1, node+1]:\n                    if child in other:\n                        return step + 1\n                    if 0 <= child < len(arr) and child not in visited:\n                        visited.add(child)\n                        nex.append(child)\n\n            curs = nex\n            step += 1\n\n        return -1\n", "from collections import defaultdict, deque\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        node_h = defaultdict(list)\n        graph = defaultdict(set)\n        \n        # Constructring graph based on these rules\n        # i + 1 where: i + 1 < arr.length.\n        # i - 1 where: i - 1 >= 0.\n        # j where: arr[i] == arr[j] and i != j.\n        for idx, val in enumerate(arr):\n            # if idx - 1 >= 0:\n            #     graph[idx].add(idx-1)\n            # if idx + 1 < len(arr):\n            #     graph[idx].add(idx+1)\n            # for node_idx in node_h[val]:\n            #     # graph[idx].add(node_idx)\n            #     graph[val].add(idx)\n            #     # graph[node_idx].add(idx)\n            node_h[val].append(idx)\n\n        q = deque()\n        visited = set()\n        q.append((0, 0))\n        visited.add(0)\n        \n        while (q):\n            node, level = q.popleft()\n            if node == len(arr) - 1:\n                return level\n            nbrs = node_h[arr[node]]\n            nbrs.append(node - 1)\n            nbrs.append(node + 1)\n            # for nbr in graph[node]:\n            for nbr in nbrs:\n                if nbr == len(arr) - 1:\n                    return level + 1\n                if nbr >= 0 and nbr < len(arr) and nbr not in visited:\n                    q.append((nbr, level + 1))\n                    visited.add(nbr)\n            node_h[arr[node]] = [] # [BUG] Clearing this is crucial otherwise we might revisit the node again, causing TLE \n            \n        return 0\n        \n# [NOTE] First attempt failed with large input of same numbers with just the last number different :)\n# https://leetcode.com/submissions/detail/397710738/testcase/\n\n# Clearing up the processed node list helped with TLE better explanation here\n# https://leetcode.com/problems/jump-game-iv/discuss/502699/JavaC++-BFS-Solution-Clean-code-O(N)/445620\n\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        from collections import defaultdict, deque\n        n = len(arr)\n        \n        indices = defaultdict(list)\n        \n        for i in range(n):\n            indices[arr[i]].append(i)\n            \n        visited = [False] * n\n        visited[0] = True\n        \n        queue = deque()\n        # add first position\n        queue.append(0)\n        \n        steps = 0\n        \n        while len(queue) > 0:\n            for size in range(len(queue), 0, -1):\n                i = queue.popleft()\n                \n                # termination check\n                if i == n - 1:\n                    return steps\n                \n                next = indices[arr[i]]\n                \n                next.append(i - 1)\n                next.append(i + 1)\n                \n                for num in next:\n                    if num >= 0 and num < n and not visited[num]:\n                        visited[num] = True\n                        queue.append(num)\n                        \n                # remove already looked up indices\n                indices[arr[i]] = []\n                \n            steps += 1\n            \n        return 0", "from collections import defaultdict, deque\nclass Solution:\n    def minJumps(self, arr):\n        n = len(arr)\n        if n == 1: return 0\n        d = defaultdict(list)\n        for i,val in enumerate(arr):\n            d[val].append(i)\n            \n        visited = set([0])\n        stack = deque([0])\n        k, jumps = len(stack), 1\n        while stack:\n            k -= 1\n            i = stack.popleft()\n            childs = [j for j in d.pop(arr[i],[])]\n            for j in [i-1,i+1]:\n                if 0 <= j < n and arr[j] != arr[i] and j not in visited: childs.append(j)\n            visited |= set(childs)\n            if n-1 in visited: return jumps\n            stack += childs\n            if not k:\n                k = len(stack)\n                jumps += 1\n        return jumps", "from collections import deque, defaultdict\n\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        visited = {0}\n        q = deque([(0, 0)])\n        val_to_is = defaultdict(list)\n        \n        for i, val in enumerate(arr):\n            val_to_is[val].append(i)\n        \n        def move(i):\n            for j in [i - 1, i + 1] + val_to_is[arr[i]]:\n                if 0 <= j < len(arr) and j != i and j not in visited:\n                    yield j\n                    \n        while q:\n            i, steps = q.pop()\n            for j in move(i):\n                if j == len(arr) - 1:\n                    return steps + 1\n                visited.add(j)\n                if arr[i] in val_to_is:\n                    del val_to_is[arr[i]]\n                q.appendleft((j, steps + 1))\n        \n        return 0\n", "class Solution:\n    def minJumps(self, arr):\n        # Similar concept to jump game3, but here we need to find the minimum\n        # jumps so we need to use queue instead of stack, also we need to use\n        # hashmap to handle the third jump of mirror values\n        \n        # Base Case - No jumps needed\n        if len(arr) == 1:\n            return 0\n        \n        # Data Structure Declaration\n        q = collections.deque()\n        seen = set()\n        hashmap = collections.defaultdict(list)\n        destination = len(arr)-1\n        minJumps = 0\n        \n        # Store mirrors in hashmap\n        for index, num in enumerate(arr):\n            hashmap[num].append(index)\n        \n\n        # Traversal start points\n        q.append(0)\n        seen.add(0)\n\n        # Run loop until we have values in queue\n        while q:\n            \n            sizeQ = len(q)\n            \n            # Traverse the queue level by level\n            for i in range(sizeQ):\n                Pos = q.popleft()\n                # Check for destination\n                if Pos == destination:\n                    return minJumps\n                \n                # Number of choices for Jumping\n                nextPos = Pos + 1\n                prevPos = Pos - 1\n                mirrorPos = hashmap[arr[Pos]]\n                \n                # Add if nextPos is valid\n                if nextPos >= 0 and nextPos < len(arr) and nextPos not in seen:\n                    seen.add(nextPos)\n                    q.append(nextPos)\n                    \n                # Add if prevPos is valid\n                if prevPos >= 0 and prevPos < len(arr) and prevPos not in seen:\n                    seen.add(prevPos)\n                    q.append(prevPos)\n                \n                # Add if we have mirror elements present\n                if mirrorPos:\n                    for val in mirrorPos:\n                        if val >= 0 and val < len(arr) and val not in seen:\n                            seen.add(val)\n                            q.append(val)\n                    # Once current element is taken into account, delete from map\n                    del hashmap[arr[Pos]]\n            # for every level increase the number of Jumps\n            minJumps += 1\n        return minJumps\n                \n", "class Solution:\n    # bidirectional, 460 ms\n    def minJumps(self, arr):\n        if len(arr) == 1: return 0\n        if arr[0] == arr[-1]: return 1\n\n        length = len(arr)\n        if len(set(arr)) == length: return length - 1\n        _map = defaultdict(set) # connection map\n        for i, val in enumerate(arr): _map[val].add(i)\n\n        # bfs, seen: visited index, visit: visited connextion\n        res, visit = 0, set()\n        seen = {0}\n        curs, other = {0}, {length - 1}\n        while curs:\n            res += 1\n            thisLevel = set() # indexes can be seen in this level\n            for i in curs:\n                if i - 1 > 0 and i - 1 not in seen: \n                    thisLevel.add(i - 1)\n                if arr[i] not in visit:\n                    thisLevel |= (_map[arr[i]] - seen) \n                    visit.add(arr[i])\n                if i + 1 < length and i + 1 not in seen: \n                    thisLevel.add(i + 1)\n            if len(thisLevel & other) > 0: return res               \n            curs = thisLevel\n            if len(curs) > len(other): curs, other = other, curs\n            else: seen |= thisLevel", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        nei = collections.defaultdict(list)\n        _ = [nei[x].append(i) for i, x in enumerate(arr)]\n\n        frontier = collections.deque([(0,0)])\n        num_met, pos_met = set(), set()\n        while frontier:\n            pos, step = frontier.popleft() # state: position, step\n            if pos == len(arr) - 1: return step\n            num = arr[pos]\n            pos_met.add(pos) # track explored positions\n\n            for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\n                if p in pos_met or not 0 <= p < len(arr): continue\n                frontier.append((p, step + 1))\n\n            num_met.add(num) # track explored values", "from queue import Queue\ndef dedup(arr):\n    n = len(arr)\n    if n <= 2:\n        return arr\n    \n    ret = [arr[0]]\n    is_equal = False\n    for i in range(1, n):\n        if arr[i] == arr[i-1]:\n            if not is_equal:\n                is_equal = True\n                ret.append(arr[i])\n            else:\n                #visited[ret[-1]] = 1\n                ret[-1] = arr[i]                \n        else:\n            ret.append(arr[i])\n            is_equal = False\n    return ret     \n        \nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if len(set(arr)) == len(arr):\n            return len(arr)-1\n        \n        arr = dedup(arr)\n        memo = defaultdict(list)\n        n = len(arr)\n        visited = [0] *n\n        for i in range(n):\n            memo[arr[i]].append(i)\n        \n        #for k in memo.keys():\n        #    memo[k] = dedup(memo[k], visited)\n            \n        q = Queue()\n        q.put((0,0))\n        visited[0] = 1\n        while not q.empty():\n            cur, cnt = q.get()\n            if cur == n - 1:\n                return cnt\n                \n            wk = [cur+1, cur-1]\n            for v in memo[arr[cur]]+wk:\n                #print(cur, v)\n                if -1 < v < n and not visited[v]:\n                    q.put((v,cnt+1))\n                    visited[v] = 1\n        return 0", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        dp = {}\n        count = {}\n        for i in range(len(arr)):\n            res = count.get(arr[i], [])\n            res.append(i)\n            count[arr[i]] = res\n        \n        vis = set()\n        vis.add(0)\n        q = collections.deque([(0, 0)])\n        c = 0\n        while q:\n            l = len(q)\n            for i in range(l):\n                node = q.popleft()\n                if node[0] == len(arr) - 1:\n                    return node[1]\n            \n                if node[0] != 0:\n                    if node[0] - 1 not in vis:\n                        q.append((node[0] - 1, node[1] + 1))\n                        vis.add(node[0] - 1)\n            \n                if node[0] != len(arr) - 1:\n                    if node[0] + 1 not in vis:\n                        q.append((node[0] + 1, node[1] + 1))\n                        vis.add(node[0] + 1)\n                \n                for j in count[arr[node[0]]]:\n                    if j not in vis and j != node[0]:\n                        q.append((j, node[1] + 1))\n                        vis.add(j)\n                if j in count[arr[node[0]]]:\n                    count[arr[node[0]]] = []\n                    \n            c += 1\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        indexes = collections.defaultdict(list)\n        for idx, v in enumerate(arr):\n            indexes[v].append(idx)\n        #early pruning.\n        for key in indexes:\n            indexes[key] = [\n                v\n                for j, v in enumerate(indexes[key]) \n                if not (\n                    1 <= j < len(indexes[key]) - 1 \n                    and indexes[key][j-1]==v-1 \n                    and indexes[key][j+1]==v+1\n                )\n            ]\n        \n        queue, visited = collections.deque([(0, 0)]), set([0])\n        \n        while queue:\n            idx, jumps = queue.popleft()\n            if idx == len(arr) - 1:\n                return jumps\n            \n            v = arr[idx]\n            for j in [idx + 1, idx - 1] + indexes[v][::-1]:\n                if 0 <= j < len(arr) and j not in visited:\n                    visited.add(j)\n                    queue.append((j, jumps + 1))\n                    \n# class Solution:\n#     def minJumps(self, arr: List[int]) -> int:\n#         a_i = collections.defaultdict(list)\n#         for i, a in enumerate(arr):\n#             a_i[a].append(i)\n#         def bfs():\n#             from collections import deque\n#             Q = deque([(0,0)])\n#             seen = {0}\n#             while Q:\n#                 i, d = Q.popleft()\n#                 if i==len(arr)-1:return d\n#                 for j in [i-1, i+1]+a_i[arr[i]][::-1]:\n#                     if 0<=j<len(arr) and j!=i and j not in seen:\n#                         seen.add(j)\n#                         if j==len(arr)-1:return d+1\n#                         Q.append((j,d+1))\n#         return bfs()\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        map = defaultdict(list)\n        for i, item in enumerate(arr):\n            map[item].append(i)\n        \n        q = deque()\n        q.appendleft((0, 0))\n        visited = set()\n        num_vis = set()\n        while q:\n            index, jumps = q.pop()\n            if index == len(arr)-1: return jumps\n            visited.add(index)\n            if arr[index] not in num_vis:\n                nxts = map[arr[index]]\n                num_vis.add(arr[index])\n            \n                for nxt in nxts:\n                    if nxt<0 or nxt>len(arr) or nxt in visited: continue\n                    q.appendleft((nxt, jumps+1))\n            \n            for nbr in [index+1, index-1]:\n                if nbr<0 or nbr>=len(arr) or nbr in visited: continue\n                q.appendleft((nbr, jumps+1))\n\n        return -1\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        if not arr or len(arr) == 1:\n            return 0\n        \n        n = len(arr)\n        \n        same_val = {}\n        for i in range(n):\n            if arr[i] not in same_val:\n                same_val[arr[i]] = [i]\n            else:\n                same_val[arr[i]].append(i)\n                \n        visited = [False] * n\n        step = 0\n        curr = [0]\n        \n        while curr:\n            next = []\n            \n            for i in curr:\n                if i == n-1: # reached end\n                    return step\n                \n                visited[i] = True\n                \n                for next_idx in same_val[arr[i]]:\n                    if not visited[next_idx]:\n                        next.append(next_idx)\n                        \n                same_val[arr[i]].clear() # critical step: clear the same_val list to prevent redundant search!\n                \n                for next_idx in [i-1, i+1]:\n                    if 0 <= next_idx < n and not visited[next_idx]:\n                        next.append(next_idx)\n                        \n            curr = next\n            step += 1\n            \n        return -1 # unreachable", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        # BFS next step: +1, -1, same val pos\n        # val_to_pos dict\n        # dist dict\n        \n        if not arr:\n            return 0\n        \n        \n        \n        n = len(arr)\n        \n        val_to_pos = collections.defaultdict(list)\n        \n        for i, val in enumerate(arr):\n            val_to_pos[val].append(i)\n        \n        dist = 0\n        \n        curr_set = set([0])\n        other_set = set([n - 1])\n        \n        curr_visited = curr_set\n        other_visited = other_set\n        \n        while curr_set and other_set:\n            if len(other_set) < len(curr_set):\n                curr_set, other_set = other_set, curr_set\n                curr_visited, other_visited = other_visited, curr_visited\n            \n            next_set = set()\n            \n            while curr_set:\n                curr = curr_set.pop()\n                \n                \n                if curr in other_visited:\n                    return dist\n                \n                for nei in val_to_pos[arr[curr]] + [curr + 1, curr - 1]:\n                    if not 0 <= nei < n:\n                        continue\n                    \n                    if nei in curr_visited:\n                        continue\n                    \n                    \n                    next_set.add(nei)\n                \n                val_to_pos[arr[curr]] = []\n                \n                \n            curr_visited |= next_set\n            curr_set = next_set\n            dist += 1\n        \n", "#20201003 \u94fe\u8868\nclass Solution:\n    def minJumps(self, arr):\n        length = len(arr)\n        if len(set(arr)) == length: return length - 1\n        if arr[0] == arr[-1]: return 1\n\n        _map = defaultdict(set) # connection map\n        for i, val in enumerate(arr): _map[val].add(i)\n\n        res, seen, visit = 0, {0}, set()\n        curs, other = {0}, {length - 1}\n        while curs:\n            res += 1\n\n            thisLevel = set()\n            for i in curs:\n                if i - 1 > 0 and i - 1 not in seen: \n                    thisLevel.add(i - 1)\n                if arr[i] in _map:\n                    thisLevel |= (_map[arr[i]] - seen) \n                    visit.add(arr[i])\n                    del _map[arr[i]]\n                if i + 1 < length and i + 1 not in seen: \n                    thisLevel.add(i + 1)\n\n            if thisLevel & other: return res          \n            curs = thisLevel\n            if len(curs) > len(other): curs, other = other, curs\n            else: seen |= thisLevel", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        n = len(arr)\n        if n <= 1: return 0\n        dictor = collections.defaultdict(list)\n        queue = collections.deque([(0, 0)])\n        \n        for i in range(n):\n            dictor[arr[i]].append(i)\n        \n        \n        seen = set([0, n-1])\n        while queue:\n            idx, step = queue.popleft()\n            indexes = dictor[arr[idx]]\n            for i in indexes:\n                if i == n - 1:\n                    return step + 1\n                if i not in seen:\n                    queue.append((i, step + 1))\n                    seen.add(i)\n            del dictor[arr[idx]]\n            \n            for di in [-1, 1]:\n                new_i = idx + di\n                if new_i == n - 1:\n                    return step + 1\n                if 0 <= new_i < len(arr) and new_i not in seen:\n                    queue.append((new_i, step + 1))\n                    seen.add(new_i)\n        return -1\n                    \n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        g = defaultdict(list)\n        for i, v in enumerate(arr):\n            g[v].append(i)\n        N = len(arr)\n        \n        val_flag = set()\n        \n        cost = [math.inf] * N\n        cost[0] = 0\n        heap = [(0, 0)]\n        \n        while heap:\n            c, i = heappop(heap)\n            # print(f'Now {i}  Cost {c}  Heap {heap}')\n            if i == N-1:\n                return c\n            for n in (g[arr[i]] * (arr[i] not in val_flag)) + [i-1, i+1]:\n                if not 0 <= n < N:\n                    continue\n                if cost[n] > c + 1:\n                    cost[n] = c + 1\n                    heappush(heap, (c+1, n))\n            \n            val_flag.add(arr[i])\n        return cost[-1]", "from collections import deque,defaultdict\nclass Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        idxs=defaultdict(set)\n        for idx,e in enumerate(arr):\n            idxs[e].add(idx)\n        def bfs(idx):\n            q=deque([0])\n            step=-1\n            not_visited=set(range(len(arr)-1,0,-1))\n            while q:\n                step+=1\n                for _ in range(len(q)):\n                    node=q.popleft()\n                    if node==len(arr)-1:\n                        return step\n                    nxt_nodes=idxs[arr[node]]\n                    nxt_nodes=not_visited&nxt_nodes\n                    for nxt in [node-1,node+1]:\n                        if nxt in not_visited:\n                            nxt_nodes.add(nxt)\n                    if len(arr)-1 in nxt_nodes:\n                        return step+1\n                    not_visited.difference_update(nxt_nodes)\n                    nxt_nodes=nxt_nodes\n                    q.extend(nxt_nodes)\n            return -1\n        bfs(0)\n        return bfs(0)\n", "class Solution:\n    def minJumps(self, arr):\n        nei = collections.defaultdict(list)\n        _ = [nei[x].append(i) for i, x in enumerate(arr)]\n\n        frontier = collections.deque([(0,0)])\n        num_met, pos_met = set(), set()\n        while frontier:\n            pos, step = frontier.popleft() # state: position, step\n            if pos == len(arr) - 1: return step\n            num = arr[pos]\n            pos_met.add(pos) # track explored positions\n\n            for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\n                if p in pos_met or not 0 <= p < len(arr): continue\n                frontier.append((p, step + 1))\n\n            num_met.add(num) # track explored values", "class Solution:\n  def minJumps(self, arr):\n    nei = collections.defaultdict(list)\n    _ = [nei[x].append(i) for i, x in enumerate(arr)]\n\n    frontier = collections.deque([(0,0)])\n    num_met, pos_met = set(), set()\n    while frontier:\n        pos, step = frontier.popleft() # state: position, step\n        if pos == len(arr) - 1: return step\n        num = arr[pos]\n        pos_met.add(pos) # track explored positions\n\n        for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\n            if p in pos_met or not 0 <= p < len(arr): continue\n            frontier.append((p, step + 1))\n\n        num_met.add(num) # track explored values", "class Solution:\n    def minJumps(self, arr):\n        nei = collections.defaultdict(list)\n        _ = [nei[x].append(i) for i, x in enumerate(arr)]\n\n        frontier = collections.deque([(0,0)])\n        num_met, pos_met = set(), set()\n        while frontier:\n            pos, step = frontier.popleft() # state: position, step\n            if pos == len(arr) - 1: return step\n            num = arr[pos]\n            pos_met.add(pos) # track explored positions\n\n            for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\n                if p in pos_met or not 0 <= p < len(arr): continue\n                frontier.append((p, step + 1))\n\n            num_met.add(num) # track explored values\n", "class Solution:\n    def minJumps(self, arr: List[int]) -> int:\n        pos = {}\n        for i, x in enumerate(arr):\n            if x in pos:\n                pos[x][0].append(i)\n            else:\n                pos[x] = [[i], False]\n            \n        q = deque([(len(arr) - 1, 0, True), (0, 0, False)])\n        visited = [[-1,-1] for _ in range(len(arr))]\n        \n        while q:\n            i, n, d = q.popleft()\n            \n            if visited[i][int(not d)] != -1:\n                return n + visited[i][int(not d)]\n            \n            if visited[i][int(d)] != -1:\n                continue\n            visited[i][int(d)] = n\n            \n            if i < len(arr) - 1:\n                q.append((i+1, n+1, d))\n            if i > 0:\n                q.append((i-1, n+1, d))\n            \n            if not pos[arr[i]][1]:\n                for idx in pos[arr[i]][0]:\n                    q.append((idx, n+1, d))\n                pos[arr[i]][1] = True"]