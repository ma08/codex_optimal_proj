["from heapq import heappush, heappop\n \n class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         \"\"\"\n         heap = []\n         def push(i, j):\n             if i < len(nums1) and j < len(nums2):\n                 heappush(heap, (nums1[i] + nums2[j], i, j))\n         push(0,0)\n         res = []\n         while heap and len(res) < k:\n             _, i, j = heappop(heap)\n             res.append([nums1[i], nums2[j]])\n             push(i, j+1)\n             if j == 0:\n                 push(i+1, 0)\n         return res", "class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         \"\"\"\n         queue = []\n         def push(i, j):\n             if i < len(nums1) and j < len(nums2):\n                 heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n         push(0, 0)\n         pairs = []\n         while queue and len(pairs) < k:\n             _, i, j = heapq.heappop(queue)\n             pairs.append([nums1[i], nums2[j]])\n             push(i, j + 1)\n             if j == 0:\n                 push(i + 1, 0)\n         return pairs", "class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         \"\"\"\n         if not nums1 or not nums2 or k < 1:\n             return []\n         n1, n2 = len(nums1), len(nums2)\n         stack = [(nums1[0] + nums2[0], (0, 0))]\n         visited = set()\n         res = []\n         while len(res) < k and stack:\n             num, (p1, p2) = heapq.heappop(stack)\n             res.append([nums1[p1], nums2[p2]])\n             if p1 + 1 < n1 and (p1 + 1, p2) not in visited:\n                 heapq.heappush(stack, (nums1[p1 + 1] + nums2[p2], (p1 + 1, p2)))\n                 visited.add((p1 + 1, p2))            \n             if p2 + 1 < n2 and (p1, p2 + 1) not in visited:\n                 heapq.heappush(stack, (nums1[p1] + nums2[p2 + 1], (p1, p2 + 1)))\n                 visited.add((p1, p2 + 1))            \n         return res", "class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         \"\"\"\n         #heap based solution\n         #visualize as a matrix\n         #best possible solution will be first row or first column\n         #O(2K + Klog2K) time; O(1) time\n         \n         if not nums1 or not nums2:\n             return []\n         \n         queue = [(nums1[0]+nums2[0],0,0)]\n         ans = []\n         while queue and len(ans) < k:\n             _, i, j = heapq.heappop(queue)\n             ans.append([nums1[i],nums2[j]])            \n             if j+1 < len(nums2): #smallest values #row-wise\n                 heapq.heappush(queue, (nums1[i]+nums2[j+1],i,j+1))                \n             if j == 0 and i+1 < len(nums1): #smallest values #column-wise #takes care of row traversal                     \n                 heapq.heappush(queue, (nums1[i+1]+nums2[j],i+1,j))                                           \n         return ans\n             \n", "import heapq\n class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         \"\"\"\n         pq = []\n         m, n = len(nums1), len(nums2)   # get lenth\n         if m == 0 or n == 0:            # if one of the list is empty return []\n             return []\n         for i in range(m):              # get through the first list\n             if len(pq) == k and pq[0][0] > -nums1[i]-nums2[0]: # stop if larger than current k\n                 break\n             for j in range(n):          # go throught the second list\n                 s = -nums1[i]-nums2[j]   # get the sum\n                 if len(pq) < k or pq[0][0] < s: # if less than k or less than current k\n                     heapq.heappush(pq, (s, [nums1[i], nums2[j]]))   # push \n                     if len(pq) > k: # get it out\n                         heapq.heappop(pq)\n                 else:                   # stop if larger than current k\n                     break\n         return [item[1] for item in pq]\n         ", "class Solution(object):\n     def kSmallestPairs(self, nums1, nums2, k, heap=[]):\n         for n1 in nums1:\n             for n2 in nums2:\n                 if len(heap) < k: heapq.heappush(heap, (-n1-n2, [n1, n2]))\n                 else:\n                     if heap and -heap[0][0] > n1 + n2:\n                         heapq.heappop(heap)\n                         heapq.heappush(heap, (-n1-n2, [n1, n2]))\n                     else: break\n         return [heapq.heappop(heap)[1] for _ in range(k) if heap]", "import heapq\n \n class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         \"\"\"\n         \n         if not nums1 or not nums2:\n             return []\n         \n         index = [0 for _ in range(len(nums1))]\n         q = [[nums1[i] + nums2[index[i]], i] for i in range(len(nums1))]\n         heapq.heapify(q)\n         i = 0\n         ans = []\n         while i < k and i < len(nums1) * len(nums2):\n             pair = heapq.heappop(q)\n             ans.append([nums1[pair[1]], nums2[index[pair[1]]]])\n             i += 1\n             if index[pair[1]] + 1 < len(nums2):\n                 index[pair[1]] += 1\n                 heapq.heappush(q, [nums1[pair[1]] + nums2[index[pair[1]]], pair[1]])\n             \n         return ans\n             \n         ", "class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         \"\"\"\n         q = []\n         def push(i,j):\n             if i<len(nums1) and j<len(nums2):\n                 heapq.heappush(q,[nums1[i]+nums2[j],i,j])\n         push(0,0) # pushing first sum into heap\n         res = []\n         while q and len(res) <k:\n             s,i,j = heapq.heappop(q) #pops out min till here\n             res.append([nums1[i],nums2[j]])\n             push(i,j+1)\n             if j == 0:\n                 push(i+1,0)\n         return res        ", "class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         \"\"\"\n         :type nums1: List[int]\n         :type nums2: List[int]\n         :type k: int\n         :rtype: List[List[int]]\n         \"\"\"\n         result = []\n         import heapq\n         m = len(nums1)\n         n = len(nums2)\n         if m*n>0:\n             used = [[0 for _ in range(n)] for _ in range(m)]\n             used[0][0] = 1\n             h = [(nums1[0]+nums2[0],(0,0))]\n             while k  > 0 and h:\n                 _,(s1,s2) = heapq.heappop(h)\n                 result.append([nums1[s1],nums2[s2]])\n                 if s1+1 < m and used[s1+1][s2] == 0:\n                     heapq.heappush(h,(nums1[s1+1]+nums2[s2],(s1+1,s2)))\n                     used[s1+1][s2] = 1\n                 if s2+1 < n and used[s1][s2+1] == 0:\n                     heapq.heappush(h,(nums1[s1]+nums2[s2+1],(s1,s2+1)))\n                     used[s1][s2+1] = 1\n                 k -= 1\n         return result\n", "class Solution:\n     def kSmallestPairs(self, nums1, nums2, k):\n         if not nums1 or not nums2:\n             return []\n         queue = []\n         heapq.heappush(queue, [nums1[0] + nums2[0], 0, 0])\n         ans = []\n         seen = {(0, 0):1}\n         while k > len(ans) and queue:\n             top = heapq.heappop(queue)\n             i, j = top[1], top[2]\n             ans.append([nums1[i],nums2[j]])\n             #print(i, j, queue)\n             if i+1 < len(nums1) and (i+1, j) not in seen:\n                 heapq.heappush(queue, [nums1[i+1] + nums2[j], i+1, j])\n                 seen[(i+1, j)] = 1\n             if j+1 < len(nums2) and (i, j+1) not in seen:\n                 heapq.heappush(queue, [nums1[i] + nums2[j+1], i, j+1])\n                 seen[(i, j+1)] = 1\n         return ans"]