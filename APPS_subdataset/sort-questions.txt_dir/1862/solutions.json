["class Solution:\n    def pancakeSort(self, A: List[int]) -> List[int]:\n        n = len(A)\n        res = []\n        \n        for x in range(n, 1, -1):\n            idx = A.index(x)\n            res.extend([idx + 1, x])\n            A = A[idx::-1] + A[idx+1:]\n            A = A[x-1::-1]\n            \n        return res\n", "class Solution:\n    def pancakeSort(self, A: List[int]) -> List[int]:\n        N = len(A)\n        res = []\n        for x in range(N, 0, -1):\n            i = A.index(x)\n            res.extend([i + 1, x])\n            A = A[:i:-1] + A[:i]\n        return res", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        ans = []\n        for i in range(n, 0, -1):\n            for j in range(i-1):\n                if arr[j] == i:\n                    ans.append(j+1)\n                    ans.append(i)\n                    print((j, i))\n                    arr = list(reversed(arr[:j+1])) + arr[j+1:]\n                    print(arr)\n                    arr = list(reversed(arr[:i])) + arr[i:]\n                    print(arr)\n                    break\n        return ans\n                    \n", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        res = []\n        for x in range(len(arr), 1, -1):\n            i = arr.index(x)\n            res.extend([i + 1, x])\n            arr = arr[:i:-1] + arr[:i]\n        return res", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n\n        def pancake_flip(to_flip, index):\n            print(\\\"flipping \\\" + str(to_flip) + \\\" with index \\\" + str(index))\n            middle = index // 2\n            for i in range(middle):\n                to_flip[i], to_flip[index - i - 1] = to_flip[index - i - 1], to_flip[i]\n            print(\\\"flipped: \\\" + str(to_flip))\n            return to_flip\n        \n        is_sorted = True\n        for i in range(len(arr) - 1):\n            if arr[i] > arr[i + 1]:\n                is_sorted = False\n                break\n        if is_sorted:\n            return []\n        \n        result = []\n        print(\\\"starting with: \\\" + str(arr))\n        current_element = 1\n        while current_element < len(arr):\n            print(\\\"current element: \\\" + str(current_element))\n            index = arr.index(current_element) + 1\n            print(\\\"found element \\\" + str(current_element) + \\\" at \\\" + str(index))\n            if index != len(arr) - current_element + 1:\n                if index != 1:\n                    result.append(index)\n                    arr = pancake_flip(arr, index)\n                index = len(arr) - current_element + 1\n                result.append(index)\n                arr = pancake_flip(arr, index)\n            current_element += 1\n        result.append(len(arr))\n        return result\n", "class Solution:\n    def pancakeSort(self, A: List[int]) -> List[int]:\n        def flip(r):\n            l = 0\n            while l<r:\n                A[l], A[r] = A[r], A[l]\n                l, r = l+1, r-1     \n                \n        ans = []\n        for x in range(len(A),0,-1):\n            i = A.index(x)+1 #x is the current unsorted largest element\n            ans.extend([i, x])\n            flip(i-1)\n            flip(x-1)\n        \n        return ans\n", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        # Discussion solution by Lee215\n        res = []\n        for x in range(len(arr), 1, -1):\n            i = arr.index(x)\n            res.extend([i + 1, x])\n            arr = arr[:i:-1] + arr[:i]\n        return res\n        \n        # First answer: Best run 93.4%[36ms], 5.03%[14.2MB]\n        out = []\n        for i in range(len(arr),0,-1):  # traverse left-to-right\n            if arr[i-1] != i:           # find 1st wrong entry  \n                j = arr.index(i)        # search for right entry\n                out.extend([j+1,i])\n                arr[:j+1] = reversed(arr[:j+1])\n                arr[:i]   = reversed(arr[:i])\n        return out", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        res = []\n        A = arr\n        for x in range(len(A), 1, -1):\n            i = A.index(x)\n            res.extend([i+1, x])\n            A = A[x-1:i:-1] + A[:i]\n            \n        return res\n", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        \n        last = len(arr)\n        ans = []\n        \n        while last > 1:\n            #print(f\\\"last={last} ans={ans} arr={arr}\\\")\n            max_pos = 0\n            max_v = -float('inf')\n            for i in range(last):\n                if arr[i] > max_v:\n                    max_v = arr[i]\n                    max_pos = i\n                    \n        \n                \n            ans.append(max_pos+1)\n            ans.append(last)\n            arr[:max_pos+1] = arr[:max_pos+1][::-1]\n            arr[:last] = arr[:last][::-1]\n                \n            last -= 1\n        return ans\n    \n    \n", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        # 1. find max value, flip it to first; 2. flip whole array, let max to the end.\n        results = []\n        end = len(arr)\n        \n        while end > 1:\n            max_idx = arr.index(max(arr[:end]))\n            if max_idx == end - 1:\n                end -= 1\n            else:\n                if max_idx > 0:\n                    results.append(max_idx+1)\n                    arr[:max_idx+1] = reversed(arr[:max_idx+1])\n                results.append(end)\n                arr[:end] = reversed(arr[:end])\n                end -= 1\n        print(arr)\n        return results\n", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        ans = []\n        def flip(idx):\n            arr[:idx+1] = arr[:idx+1][::-1]\n        for i in range(len(arr)):\n            maxInd = arr[:n].index(max(arr[:n]))\n            if maxInd != n:\n                ans.append(maxInd+1)\n                ans.append(n)\n                flip(maxInd)\n                flip(n -1)\n            n -= 1\n        \n        return ans\n", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        def flip(k):\n            for i in range(k // 2):\n                arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n        \n        ans = []\n        val = len(arr)\n        while val > 0:\n            i = arr.index(val)\n            if 0 < i < val - 1:\n                ans.append(i + 1)\n                flip(i + 1)\n            if i < val - 1:\n                ans.append(val)\n                flip(val)\n            val -= 1\n        return ans", "class Solution:\n    def pancakeSort(self, arr: List[int]) -> List[int]:\n        \n        def flip(sublist,k):\n            i=0\n            while(i<k/2):\n                sublist[i],sublist[k-i-1]=sublist[k-i-1],sublist[i]\n                i+=1\n        \n        ans = []\n        value_to_sort= len(arr)\n        while(value_to_sort>0):\n            index = arr.index(value_to_sort)\n            if(index!=value_to_sort-1):\n                if(index!=0):\n                    ans.append(index+1)\n                    flip(arr,index+1)\n                ans.append(value_to_sort)\n                flip(arr,value_to_sort)\n            value_to_sort-=1\n        return ans\n", "class Solution(object):\n    def pancakeSort(self, arr):\n        p = arr.copy()\n        final = p.copy()\n        final.sort()\n        print(p)\n        k = len(final) - 1\n        ret = []\n        while k >= 0:\n            val = final[k]\n            print(\\\"value = \\\", val)\n            ind = p.index(val)\n            print(\\\"p array = \\\", p)\n            print(\\\"index for\\\", val, \\\"=\\\", ind)\n            if ind != k and ind != 0:\n                p = p[:(ind+1)][::-1] + p[(ind+1):]\n                p = p[:(k+1)][::-1] + p[(k+1):]\n                ret += [ind+1, k+1]\n            elif ind == k:\n                pass\n            elif ind == 0:\n                p = p[:(k+1)][::-1] + p[(k+1):]\n                ret.append(k+1)\n            k -= 1\n        return ret\n"]