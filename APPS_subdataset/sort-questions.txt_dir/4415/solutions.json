["from operator import mul\nfrom math import factorial\nfrom functools import reduce\nfrom collections import Counter\n\ndef proc_arr(arr):\n    s = ''.join(sorted(arr))\n    return [factorial(len(arr)) // reduce(mul, list(map(factorial, list(Counter(arr).values())))), int(s), int(s[::-1])]\n", "from math import factorial\n\ndef proc_arr(arr):\n    arr = ''.join(sorted(arr))\n    comb = factorial(len(arr))\n    same = eval('*'.join(map(str, [factorial(arr.count(n)) for n in '0123456879'])))\n    \n    return [ comb/same, int(arr), int(arr[::-1]) ]", "from collections import Counter\nfrom operator import floordiv\nfrom functools import reduce\nfrom math import factorial\n\ndef proc_arr(arr):\n    count = reduce(floordiv, map(factorial, Counter(arr).values()), factorial(len(arr)))\n    mini = int(''.join(sorted(arr)))\n    maxi = int(''.join(sorted(arr, reverse=True)))\n    return [count, mini, maxi]", "from functools import reduce\nfrom math import factorial as fac\nfrom operator import mul\n\ndef proc_arr(lst):\n    stg = \"\".join(sorted(lst))\n    p = fac(len(stg)) // reduce(mul, (fac(stg.count(d)) for d in set(stg)))\n    return [p, int(stg), int(stg[::-1])]", "from math import factorial as f \nfrom functools import reduce as r\nfrom operator import mul as m\nfrom collections import Counter as C\nproc_arr=lambda a:[f(len(a))//r(m,map(f,C(a).values())),int(''.join(sorted(a,key=int))),int(''.join(sorted(a,key=int))[::-1])]", "from collections import Counter\nfrom math import factorial\nfrom operator import mul\nfrom functools import reduce\n\ndef proc_arr(arr):\n    c = Counter(arr)\n    xs = sorted(arr)\n    n = factorial(len(arr)) // reduce(mul, list(map(factorial, list(c.values()))))\n    return [n, int(''.join(xs)), int(''.join(xs[::-1]))]\n", "from collections import Counter\nfrom math import factorial\n\ndef proc_arr(arr):\n    perm, strng = factorial(len(arr)), []\n    for k, v in sorted(Counter(arr).items()):\n        perm //= factorial(v)\n        strng.append(k * v)\n    return [perm, int(''.join(strng)), int(''.join(strng[::-1]))]\n", "import math\nfrom collections import Counter\nfrom functools import reduce\n\ndef proc_arr(arr): #, k):\n    arrstr = \"\".join(sorted(arr, key=int))\n    dupes = reduce((lambda x, y: x * y), [math.factorial(x[1]) for x in Counter(arr).most_common() if x[1] > 1] or [1])\n    return [math.factorial(len(arr)) / dupes, int(arrstr), int(arrstr[::-1])]\n", "from math import factorial\n\nimport re\n\ndef proc_arr(arr):\n    s = ''.join(sorted(arr))\n    r = ''.join(reversed(s))\n    low, high = int(s), int(r)\n    digits = len(s)\n    denominator = mul([factorial(end - start) for start, end in \n                       [m.span() for m in re.finditer('(?P<D>\\d)(?P=D)*', s)]])\n    return [(factorial(digits) // denominator), low, high]\n    \ndef mul(coll):\n    return 1 if not coll else coll[0] * mul(coll[1:])\n"]