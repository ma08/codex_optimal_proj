["import sys\ninput = sys.stdin.readline\n\ndef dfs(x,S):\n    #print(x,S)\n    for i in range(len(S)):\n        if x in S[i]:\n            S[i].remove(x)\n\n    #print(x,S)\n        \n    LEN1=0\n    for s in S:\n        if len(s)==1:\n            LEN1+=1\n            ne=list(s)[0]\n        if LEN1==2:\n            return [-1]\n    if LEN1==1:\n        return [ne]+dfs(ne,S)\n    else:\n        return [-1]\n    \n        \nimport copy    \n\nt=int(input())\nfor tests in range(t):\n    n=int(input())\n    A=tuple(set(list(map(int,input().split()))[1:]) for i in range(n-1))\n\n    for i in range(1,n+1):\n        ANS=[i]+dfs(i,copy.deepcopy(A))\n        #print(i,ANS)\n        if -1 in ANS[:n]:\n            continue\n        else:\n            #print(ANS[:n])\n            USE=[0]*(n-1)\n\n            flag=1\n\n            for i in range(n-1,0,-1):\n                SET=set()\n                for j in range(i,-1,-1):\n                    SET.add(ANS[j])\n                    if SET in A:\n                        break\n                else:\n                    flag=0\n                    break\n\n            if flag:\n                print(*ANS[:n])\n                break\n    \n\n        \n", "def __starting_point():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        ns = {}\n        for _ in range(n - 1):\n            _, *p = list(map(int, input().split()))\n            tp = tuple(p)\n            for pp in p:\n                ns.setdefault(pp, set()).add(tp)\n        first = [(k, list(v)[0]) for k, v in list(ns.items()) if len(v) == 1]\n        found = False\n        while not found:\n            nns = {k: v.copy() for k, v in list(ns.items())}\n            min_index = {}\n            cur, cur_tp = first.pop()\n            result = [cur]\n            failed = False\n            while len(nns) > 0 and not failed:\n                nxt = set()\n                for k in cur_tp:\n                    mi = n - len(result) - len(cur_tp) + 1\n                    min_index[k] = max(min_index.get(k, 0), mi)\n                    nsk = nns[k]\n                    nsk.remove(cur_tp)\n                    if k == cur:\n                        nns.pop(k)\n                    elif len(nsk) == 1:\n                        nxt.add(k)\n                if len(nns) == len(nxt) or len(nns) == 1:\n                    break\n                if len(nxt) == 0:\n                    failed = True\n                else:\n                    mmi = -1\n                    for nx in nxt:\n                        if min_index[nx] > mmi:\n                            mmi = min_index[nx]\n                            cur = nx\n                    cur_tp = list(nns[cur])[0]\n                    result.append(cur)\n            if not failed:\n                found = True\n                if len(nns) == 1:\n                    result.append(nns.popitem()[0])\n                else:\n                    a1, a2 = list(nns.keys())\n                    if min_index[a1] == 1:\n                        result.extend((a1, a2))\n                    else:\n                        result.extend((a2, a1))\n                print(\" \".join(map(str, reversed(result))))\n\n__starting_point()", "from collections import Counter\nfrom itertools import chain\n\n\ndef dfs(n, r, hint_sets, count, removed, result):\n    # print(n, r, hint_sets, count, removed, result)\n    if len(result) == n - 1:\n        last = (set(range(1, n + 1)) - set(result)).pop()\n        result.append(last)\n        return True\n\n    i, including_r = 0, None\n    for i, including_r in enumerate(hint_sets):\n        if i in removed:\n            continue\n        if r in including_r:\n            break\n    removed.add(i)\n\n    next_r = []\n    for q in including_r:\n        count[q] -= 1\n        if count[q] == 1:\n            next_r.append(q)\n    if not next_r:\n        return False\n\n    # print(r, next_r, result)\n\n    if len(next_r) == 2:\n        nr = -1\n        can1, can2 = next_r\n        for h in hint_sets:\n            if can1 in h and can2 not in h and not h.isdisjoint(result):\n                nr = can1\n                break\n            if can1 not in h and can2 in h and not h.isdisjoint(result):\n                nr = can2\n                break\n        if nr == -1:\n            nr = can1\n    else:\n        nr = next_r[0]\n\n    result.append(nr)\n    res = dfs(n, nr, hint_sets, count, removed, result)\n    if res:\n        return True\n    result.pop()\n\n    for q in including_r:\n        count[q] += 1\n\n    return False\n\n\nt = int(input())\nbuf = []\nfor l in range(t):\n    n = int(input())\n    hints = []\n    for _ in range(n - 1):\n        k, *ppp = list(map(int, input().split()))\n        hints.append(ppp)\n\n    count = Counter(chain.from_iterable(hints))\n    most_common = count.most_common()\n\n    hint_sets = list(map(set, hints))\n\n    r = most_common[-1][0]\n    result = [r]\n    if dfs(n, r, hint_sets, dict(count), set(), result):\n        buf.append(' '.join(map(str, result[::-1])))\n        continue\n    r = most_common[-2][0]\n    result = [r]\n    assert dfs(n, r, hint_sets, dict(count), set(), result)\n    buf.append(' '.join(map(str, result[::-1])))\n\nprint('\\n'.join(map(str, buf)))\n", "from collections import Counter\nfrom itertools import chain\n\n\ndef dfs(n, r, hint_sets, count, removed, result):\n    # print(n, r, hint_sets, count, removed, result)\n    if len(result) == n - 1:\n        last = (set(range(1, n + 1)) - set(result)).pop()\n        result.append(last)\n        return True\n\n    i, including_r = 0, None\n    for i, including_r in enumerate(hint_sets):\n        if i in removed:\n            continue\n        if r in including_r:\n            break\n    removed.add(i)\n\n    next_r = []\n    for q in including_r:\n        count[q] -= 1\n        if count[q] == 1:\n            next_r.append(q)\n    if not next_r:\n        return False\n\n    # print(r, next_r, result)\n\n    if len(next_r) == 2:\n        nr = -1\n        can1, can2 = next_r\n        for h in hint_sets:\n            if can1 in h and can2 not in h and not h.isdisjoint(result):\n                nr = can1\n                break\n            if can1 not in h and can2 in h and not h.isdisjoint(result):\n                nr = can2\n                break\n        if nr == -1:\n            nr = can1\n    else:\n        nr = next_r[0]\n\n    result.append(nr)\n    res = dfs(n, nr, hint_sets, count, removed, result)\n    if res:\n        return True\n    result.pop()\n\n    for q in including_r:\n        count[q] += 1\n\n    return False\n\n\nt = int(input())\nbuf = []\nfor l in range(t):\n    n = int(input())\n    hints = []\n    for _ in range(n - 1):\n        k, *ppp = list(map(int, input().split()))\n        hints.append(ppp)\n\n    count = Counter(chain.from_iterable(hints))\n    most_common = count.most_common()\n\n    hint_sets = list(map(set, hints))\n\n    r = most_common[-1][0]\n    result = [r]\n    if dfs(n, r, hint_sets, dict(count), set(), result):\n        buf.append(' '.join(map(str, result[::-1])))\n        continue\n    r = most_common[-2][0]\n    result = [r]\n    assert dfs(n, r, hint_sets, dict(count), set(), result)\n    buf.append(' '.join(map(str, result[::-1])))\n\nprint('\\n'.join(map(str, buf)))\n", "from collections import Counter\nfrom itertools import chain\n\n\ndef dfs(n, r, hint_sets, count, removed, result):\n    if len(result) == n - 1:\n        last = (set(range(1, n + 1)) - set(result)).pop()\n        result.append(last)\n        return True\n\n    i, including_r = 0, None\n    for i, including_r in enumerate(hint_sets):\n        if i in removed:\n            continue\n        if r in including_r:\n            break\n    removed.add(i)\n\n    next_r = []\n    for q in including_r:\n        count[q] -= 1\n        if count[q] == 1:\n            next_r.append(q)\n    if not next_r:\n        return False\n\n    if len(next_r) == 2:\n        nr = -1\n        can1, can2 = next_r\n        for i, h in enumerate(hint_sets):\n            if i not in removed:\n                continue\n            if can1 in h and can2 not in h:\n                nr = can1\n                break\n            if can1 not in h and can2 in h:\n                nr = can2\n                break\n        if nr == -1:\n            nr = can1\n    else:\n        nr = next_r[0]\n\n    result.append(nr)\n    res = dfs(n, nr, hint_sets, count, removed, result)\n    if res:\n        return True\n    result.pop()\n\n    for q in including_r:\n        count[q] += 1\n\n    return False\n\n\nt = int(input())\nbuf = []\nfor l in range(t):\n    n = int(input())\n    hints = []\n    for _ in range(n - 1):\n        k, *ppp = list(map(int, input().split()))\n        hints.append(ppp)\n\n    count = Counter(chain.from_iterable(hints))\n    most_common = count.most_common()\n\n    hint_sets = list(map(set, hints))\n\n    r = most_common[-1][0]\n    result = [r]\n    if dfs(n, r, hint_sets, dict(count), set(), result):\n        buf.append(' '.join(map(str, result[::-1])))\n        continue\n    r = most_common[-2][0]\n    result = [r]\n    assert dfs(n, r, hint_sets, dict(count), set(), result)\n    buf.append(' '.join(map(str, result[::-1])))\n\nprint('\\n'.join(map(str, buf)))\n", "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    def ok():\n        if len(ans)<n:return False\n        for r,si in enumerate(sii,2):\n            s=ss[si]\n            cur=set(ans[r-len(s):r])\n            if s!=cur:return False\n        return True\n\n    for _ in range(II()):\n        n=II()\n        ee=[[n**2]*n for _ in range(n)]\n        for ei in range(n):ee[ei][ei]=0\n        ss=[set(LI()[1:]) for _ in range(n-1)]\n        for a0 in range(1,n+1):\n            used=set([a0])\n            ans=[a0]\n            sii=[]\n            for _ in range(n-1):\n                nxt=[]\n                for si,s in enumerate(ss):\n                    cur=s-used\n                    if len(cur)==1:\n                        for a in cur:nxt.append(a)\n                        sii.append(si)\n                if len(nxt)!=1:break\n                ans.append(nxt[0])\n                used.add(nxt[0])\n            if ok():break\n        print(*ans)\n\nmain()", "from collections import defaultdict as dd\nfrom pprint import pprint as pp\n\n\ndef solve():\n    n = int(input())\n    seqs = []\n    d = dd(list)\n    for _ in range(n-1):\n        seqs.append(list(map(int, input().split()[1:])))\n    for seq in seqs:\n        for i in range(len(seq)):\n            s = ' '.join(str(x) for j, x in enumerate(seq) if j != i)\n            d[s].append(seq[i])\n    for st in range(1, n+1):\n        seq = [st]\n        seq_set = {st}\n        for _ in range(n-1):\n            found = False\n            for l in range(len(seq)):\n                k = ' '.join(str(x) for x in sorted(seq[-(l+1):]))\n                if k in d:\n                    for j in d[k]:\n                        if j not in seq_set:\n                            seq.append(j)\n                            seq_set.add(j)\n                            found = True\n                            break\n                if found:\n                    break\n            if not found:\n                break\n        if len(seq) == n:\n            print(' '.join(str(x) for x in seq))\n            break\n\n\nfor _ in range(int(input())):\n    solve()\n", "import sys\nimport collections\nimport threading\nimport copy\n\ndef check(itr, sets):\n    d={}\n    def dmap(x):\n        return d[x]    \n    for i in range(len(itr)):\n        d[itr[i]] = i\n    for perm in sets:\n        tmp = sorted(list( map(dmap, perm) ))\n        if len(tmp) != tmp[-1] - tmp[0] + 1:\n            return False\n\n    return True\n\n\ndef main():\n    n = int( input() )\n    sets = []\n    start = set()\n    for _ in range(n-1):\n        l, *tmp = list(map( int, input().split() ))\n        sets.append( set(tmp) )\n        if l == 2:\n            start.add(tmp[0])\n            start.add(tmp[1])\n\n    ans = collections.deque()\n    for i in start:\n        permuts = copy.deepcopy(sets)\n        next = i\n        while len(ans) > 0: ans.pop()\n\n        ans.append(next)\n        while len(ans) < n:\n            q = []\n            for permut in permuts:\n                if next in permut:\n                    permut.remove(next)\n                    if len(permut) == 1:\n                        q.append(permut)\n            if len(q) != 1:\n                break ########## exit\n            next = list(q[0])[0]\n            ans.append(next)\n        if len(ans)==n and check(ans, sets):\n            print(*ans)\n            return\n    print(\"error\")\n    return\n        \n\n        \n\n\n\n\ninput = sys.stdin.readline\n#sys.setrecursionlimit(2097152)\ntnum = int(input())\nfor _ in range(tnum):\n    main()\n\n# threading.stack_size(134217728)\n\n# main_thread = threading.Thread(target=main)\n# main_thread.start()\n# main_thread.join()\n"]