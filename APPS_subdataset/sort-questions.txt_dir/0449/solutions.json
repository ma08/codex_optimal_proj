["class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) <= 3:\n             return min(nums)\n         lo = 0\n         hi = len(nums) - 1\n         mid = (hi + lo) // 2\n         if nums[mid] < nums[mid-1] and nums[mid] < nums[mid+1]:\n             return nums[mid]\n         if nums[mid] > nums[lo] and nums[mid] > nums[hi]:\n             # pivot on the right side\n             return self.findMin(nums[mid:])\n         #elif nums[mid] < nums[lo] and nums[mid] < nums[hi]:\n         else:\n             #pivot on the left side\n             return self.findMin(nums[:mid+1])", "class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 0:\n             return None\n         \n         # case 1: minimum element is at index 0\n         # case 2: minimum element is at pivot index\n         #     4 5 6 7   0 1 2\n         #             |<-  every element after here is < element at index 0\n         #     tail    |  head\n         \n         # => check for case 1:\n         if nums[-1] > nums[0]:\n             return nums[0]\n         \n         # case 2. binary search for the start of the pivoted sequence\n         boundary = nums[0]\n         return self.binary_search_min(nums, boundary)\n         \n     def binary_search_min(self, nums, maximum):\n         \"\"\"\n         Binary search for the minimum element, assuming that every element >= maximum indicates leaving the array to the left\n         \"\"\"        \n         left_boundary = 0\n         right_boundary = len(nums) - 1\n         \n         while True:\n             current_index = left_boundary + (right_boundary - left_boundary) // 2\n             value = nums[current_index]\n             \n             if left_boundary == right_boundary:\n                 return value\n             \n             if value >= maximum:\n                 # we hit the tail end, search further to the right\n                 left_boundary = current_index + 1\n             else:\n                 # still in the head, search further to the left\n                 right_boundary = current_index \n             \n             \n         \n         \n", "class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums or len(nums) == 0:\n             return 0\n         \n         start, end = 0, len(nums) - 1\n         target = nums[-1]\n         \n         while start + 1 < end:\n             mid = (start + end) // 2\n             if nums[mid] < target:\n                 end = mid\n             else:\n                 start = mid\n         \n         if nums[start] < target:\n             return nums[start]\n         return nums[end]", "class Solution:\n     def findMin(self, nums):\n         left, right = 0, len(nums) - 1\n         mid = 0\n         while left < right:\n             mid = left + (right-left)//2\n             \n             # \u8f6c\u6298\u70b9\u5728\u53f3\u8fb9\n             if nums[right] < nums[mid]:\n                 left = mid + 1\n             # \u8f6c\u6298\u70b9\u5728\u5de6\u8fb9\n             elif nums[right] > nums[mid]:\n                 if nums[mid-1] > nums[mid]:\n                     return nums[mid]\n                 else:\n                     right = mid - 1\n         return nums[left]", "class Solution:\n     def findMin(self, nums):\n         if len(nums) == 0:\n             return -1\n         if len(nums) == 2:\n             return min(nums)\n         low = 0\n         high = len(nums) - 1\n         mid = (low+high)//2\n         while low < high:\n             if nums[mid] < nums[high]:\n                 high = mid\n             elif nums[mid] > nums[high]:\n                 low = mid + 1\n             mid = (low+high)//2\n         return nums[low]\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n", "class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         return min(nums)", "class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         low, high = 0, len(nums) - 1\n         while low < high:\n             mid = (low + high) // 2\n             if nums[mid] <= nums[high]: #min\u4f4d\u4e8e\u5de6\u4fa7\u4e0a\u5347\u6cbf\n                 high = mid\n             else: #min\u4f4d\u4e8e\u5de6\u4fa7\u4e0a\u5347\u6cbf\u4e0e\u53f3\u4fa7\u4e0a\u5347\u6cbf\u4e4b\u95f4\n                 low = mid + 1\n         return nums[low]", "class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         return sorted(nums)[0]\n #         low, high = 0, len(nums)-1\n #         while low < high:\n #             mid = (high - low) / 2\n", "class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 1:\n                 return nums[0]\n \n         low, high = 0, len(nums) - 1\n         \n         if nums[low] < nums[high]:\n             return nums[low]\n         \n         while low < high:\n             mid = low + (high - low) // 2\n             if nums[mid] > nums[high]:\n                 low = mid + 1\n             else:\n                 high = mid\n         return nums[low]", "class Solution:\n     # def findMin_PRACTICE(self, nums):\n     def findMin(self, nums):\n         if len(nums) == 1:\n             return nums[0]\n         l = 0\n         r = len(nums) - 1\n         while l < r:\n             m = (l+r) // 2\n             v = nums[m]\n             if nums[m-1] < v:\n                 if nums[r] > v:\n                     r = m - 1\n                 else:\n                     l = m + 1\n             else:\n                 l = m + 1\n \n         if l == r:\n             if m < l:\n                 if nums[m] < nums[l]:\n                     return nums[m]\n                 else:\n                     return nums[l]\n         if l < m:\n             if nums[l-1] < nums[m]:\n                 return nums[l-1]\n             return nums[l]\n         elif r < l:\n             return nums[r]\n         else:\n             return nums[m]\n     \n     def findMin_PASSED(self, nums):    \n     # def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if len(nums) == 1:\n             return nums[0]\n         retval = float('inf')\n         l, r = 0, len(nums)-1\n         while l < r:\n \n             m = (l + r) // 2\n             v = nums[m]\n \n             if v < nums[m+1]:\n                 if v < nums[r]:\n                     r = m\n                 elif v > nums[r]:\n                     l = m + 1\n             elif v > nums[m+1]:\n                 l = m + 1\n \n         if nums[m] < nums[m+1]:\n             return nums[m]\n         else:\n             return nums[m+1]\n", "class Solution:\n     def findMin(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         # m = nums[0]\n         # for num in nums:\n         #     if num < m:\n         #         m = num\n         # return m\n         if len(nums) == 1:\n             return nums[0]\n         \n         for i in range(1,len(nums)):\n             if nums[i - 1] > nums[i]:\n                 return nums[i]\n             \n         return nums[0]"]