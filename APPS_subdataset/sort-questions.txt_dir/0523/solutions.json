["f = 5003*[0]\nmodn = 1000000007\n\n\ndef qPow(a, b):\n nonlocal modn\n res = 1\n while b > 0:\n  if (b & 1) == 1:\n   res = res * a % modn\n  a = a * a % modn\n  b = b >> 1\n return res\n\n\ndef getF():\n nonlocal f\n f[0] = 1\n for i in range(1, 5001):\n  f[i] = f[i-1] * i\n\n\ndef __starting_point():\n getF()\n T = int(input())\n while T > 0:\n  T = T - 1\n  n, k = list(map(int,input().split()))\n  lis = list(map(int, input().split()))\n  lis = sorted(lis)\n  res = 1\n  for i in range(n):\n   zhi = f[n-1]//f[k-1]//f[n-k]\n   if i >= k-1:\n    zhi = zhi - f[i]//f[k-1]//f[i+1-k]\n   if n-i-1 >= k-1:\n    zhi = zhi - f[n-i-1]//f[k-1]//f[n-i-k]\n   zhi = zhi % (modn-1)\n   # print(zhi)\n   res = res * qPow(lis[i], zhi) % modn\n  print(res)\n\n__starting_point()", "# cook your dish here\nMOD = (10**9) + 7\n\ndef ncr(n, r, p): \n # initialize numerator \n # and denominator \n num = den = 1 \n for i in range(r): \n  num = (num * (n - i)) % p \n  den = (den * (i + 1)) % p \n return (num * pow(den,  \n   p - 2, p)) % p \n\nfor _ in range(int(input())):\n \n n , k = list(map( int, input().split()))\n \n arr = list( map( int, input().split()) )\n \n arr = sorted(arr)\n \n value = ncr(n-1,k-1,MOD)\n \n ans = 1\n \n \n \n for x in range(1,n-1):\n  \n  if (n - x - 1) >= (k-1) :\n   \n   temp1 = ncr(n-x-1,k-1,MOD)\n  else:\n   temp1 = 0\n   \n  if x >= (k-1):\n   \n   temp2 = ncr(x,k-1,MOD)\n  else:\n   temp2 = 0 \n   \n   \n  # print(value,ans,temp1,temp2)\n  ans = ( ans * (arr[x]**( value - temp2 - temp1 )) )%MOD\n  \n print(ans)\n   \n  \n  \n \n", "# cook your dish here\nMOD = (10**9) + 7\n\ndef ncr(n, r, p): \n # initialize numerator \n # and denominator \n num = den = 1 \n for i in range(r): \n  num = (num * (n - i)) % p \n  den = (den * (i + 1)) % p \n return (num * pow(den,  \n   p - 2, p)) % p \n\nfor _ in range(int(input())):\n \n n , k = list(map( int, input().split()))\n \n arr = list( map( int, input().split()) )\n \n arr = sorted(arr)\n \n value = ncr(n-1,k-1,MOD)\n \n ans = 1\n \n \n \n for x in range(1,n-1):\n  \n  if (n - x - 1) >= (k-1) :\n   \n   temp1 = ncr(n-x-1,k-1,MOD)\n  else:\n   temp1 = 0\n   \n  if x >= (k-1):\n   \n   temp2 = ncr(x,k-1,MOD)\n  else:\n   temp2 = 0 \n   \n   \n  # print(value,ans,temp1,temp2)\n  ans = ( ans * (arr[x]**( value - temp2 - temp1 )) )%MOD\n  \n print(ans)\n   \n  \n  \n \n", "# cook your dish here\nMOD = (10**9) + 7\n\ndef nCrModpDP(n, r, p): \n  \n # The array C is going to store \n # last row of pascal triangle \n # at the end. And last entry  \n # of last row is nCr \n C = [0] * (n + 1); \n \n # Top row of Pascal Triangle \n C[0] = 1;  \n \n # One by constructs remaining  \n # rows of Pascal Triangle from  \n # top to bottom \n for i in range(1, (n + 1)): \n   \n  # Fill entries of current  \n  # row using previous row \n  # values \n  j = min(i, r);  \n  while(j > 0): \n   C[j] = (C[j] + C[j - 1]) % p; \n   j -= 1; \n return C[r]; \n \n# Lucas Theorem based function that   \n# returns nCr % p. This function \n# works like decimal to binary  \n# conversion recursive function. \n# First we compute last digits of  \n# n and r in base p, then recur \n# for remaining digits \ndef nCrModpLucas(n, r, p): \n  \n # Base case \n if (r == 0): \n  return 1; \n   \n # Compute last digits of n \n # and r in base p \n ni = int(n % p); \n ri = int(r % p); \n   \n # Compute result for last digits  \n # computed above, and for remaining  \n # digits. Multiply the two results  \n # and compute the result of  \n # multiplication in modulo p. \n # Last digits of n and r \n return (nCrModpLucas(int(n / p), int(r / p), p) * \n   nCrModpDP(ni, ri, p)) % p;\n\nfor _ in range(int(input())):\n \n n , k = list(map( int, input().split()))\n \n arr = list( map( int, input().split()) )\n \n arr = sorted(arr)\n \n value = nCrModpLucas(n-1,k-1,MOD)\n \n ans = 1\n \n \n \n for x in range(1,n-1):\n  \n  if (n - x - 1) >= (k-1) :\n   \n   temp1 = nCrModpLucas(n-x-1,k-1,MOD)\n  else:\n   temp1 = 0\n   \n  if x >= (k-1):\n   \n   temp2 = nCrModpLucas(x,k-1,MOD)\n  else:\n   temp2 = 0 \n   \n   \n  # print(value,ans,temp1,temp2)\n  ans = ( ans * (arr[x]**( value - temp2 - temp1 )) )%MOD\n  \n print(ans)\n   \n  \n  \n \n", "# cook your dish here\nMOD = (10**9) + 7\n\ndef binomialCoefficient(n, r, p): \n\n # The array C is going to store last row of \n # pascal triangle at the end. And last entry \n # of last row is nCr. \n C = [0 for i in range(r+1)] \n \n C[0] = 1 # Top row of Pascal Triangle \n \n # One by constructs remaining rows of Pascal \n # Triangle from top to bottom \n for i in range(1, n+1): \n \n  # Fill entries of current row  \n  # using previous row values \n  for j in range(min(i, r), 0, -1): \n \n   # nCj = (n - 1)Cj + (n - 1)C(j - 1) \n   C[j] = (C[j] + C[j-1]) % p \n \n return int(C[r])\n\nfor _ in range(int(input())):\n \n n , k = list(map( int, input().split()))\n \n arr = list( map( int, input().split()) )\n \n arr = sorted(arr)\n \n value = binomialCoefficient(n-1,k-1,MOD)\n \n ans = 1\n \n \n \n for x in range(1,n-1):\n  \n  if (n - x - 1) >= (k-1) :\n   \n   temp1 = binomialCoefficient(n-x-1,k-1,MOD)\n  else:\n   temp1 = 0\n   \n  if x >= (k-1):\n   \n   temp2 = binomialCoefficient(x,k-1,MOD)\n  else:\n   temp2 = 0 \n   \n   \n  # print(value,ans,temp1,temp2)\n  ans = ( ans * (arr[x]**( value - temp2 - temp1 )) )%MOD\n  \n print(ans)\n   \n  \n  \n \n", "# cook your dish here\nMOD = (10**9) + 7\n\ndef binomialCoefficient(n, k): \n # since C(n, k) = C(n, n - k) \n  # Declaring an empty array \n C = [0 for i in range(k+1)] \n C[0] = 1 #since nC0 is 1 \n \n for i in range(1,n+1): \n \n  # Compute next row of pascal triangle using \n  # the previous row \n  j = min(i ,k) \n  while (j>0): \n   C[j] = C[j] + C[j-1] \n   j -= 1\n \n return int(C[k] )\n\nfor _ in range(int(input())):\n \n n , k = list(map( int, input().split()))\n \n arr = list( map( int, input().split()) )\n \n arr = sorted(arr)\n \n value = binomialCoefficient(n-1,k-1)\n \n ans = 1\n \n \n \n for x in range(1,n-1):\n  \n  if (n - x - 1) >= (k-1) :\n   \n   temp1 = binomialCoefficient(n-x-1,k-1)\n  else:\n   temp1 = 0\n   \n  if x >= (k-1):\n   \n   temp2 = binomialCoefficient(x,k-1)\n  else:\n   temp2 = 0 \n   \n   \n  # print(value,ans,temp1,temp2)\n  ans = ( ans * (arr[x]**( value - temp2 - temp1 )) )%MOD\n  \n print(ans)\n   \n  \n  \n \n", "# cook your dish here\nMOD = (10**9) + 7\n\ndef binomialCoefficient(n, k): \n # since C(n, k) = C(n, n - k) \n if(k > n - k): \n  k = n - k \n # initialize result \n res = 1\n # Calculate value of  \n # [n * (n-1) *---* (n-k + 1)] / [k * (k-1) *----* 1] \n for i in range(k): \n  res = res * (n - i) \n  res = res / (i + 1) \n return int(res) \n\nfor _ in range(int(input())):\n \n n , k = list(map( int, input().split()))\n \n arr = list( map( int, input().split()) )\n \n arr = sorted(arr)\n \n value = binomialCoefficient(n-1,k-1)\n \n ans = 1\n \n \n \n for x in range(1,n-1):\n  \n  if (n - x - 1) >= (k-1) :\n   \n   temp1 = binomialCoefficient(n-x-1,k-1)\n  else:\n   temp1 = 0\n   \n  if x >= (k-1):\n   \n   temp2 = binomialCoefficient(x,k-1)\n  else:\n   temp2 = 0 \n   \n   \n  # print(value,ans,temp1,temp2)\n  ans = ( ans * (arr[x]**( value - temp2 - temp1 )) )%MOD\n  \n print(ans)\n   \n  \n  \n \n", "# cook your dish here\n\nfrom itertools import combinations\n\n\nfor i in range(int(input())) :\n \n n , k = list(map(int,input().split()))\n \n arr = list(map(int,input().split()))\n \n arr.sort()\n \n sub = [arr[i] for i in range(1,n-1)]\n \n comb = combinations(sub,k-2) \n \n prod = 1\n \n #print(list(comb))\n \n for i in list(comb) :\n  \n  maximum = max(i)\n  \n  minimum = min(i)\n  \n  \n  ind_max , ind_min = arr.index(maximum) , arr.index(minimum) \n  \n  \n  \n  aftermax = n - ind_max - 1 \n  \n  beforemin = ind_min \n  \n  \n  \n  temp = aftermax * beforemin\n  \n  for j in i :\n   \n   \n   \n   prod = prod * (j**temp)\n   \n print(prod % (10**9 + 7))\n   \n   \n   \n   \n   \n   \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \n \n \n \n \n \n", "MOD=10**9+7\np=100000\nfact=[0]*p \nfact[0]=1 \nfor i in range(1,p):\n fact[i]=(fact[i-1]*i)%MOD\ndef MI(a,MOD):\n return pow(a,MOD-2,MOD)\ndef nck(n, k,MOD):\n if n==k or k==0:\n  return 1 \n if n<k:\n  return 0 \n return (fact[n]*MI(fact[k],MOD)%MOD*MI(fact[n-k],MOD)%MOD)%MOD\nfor _ in range(int(input())):\n n,k=map(int,input().split())\n prod=1\n l=[int(i) for i in input().split()]\n l.sort()\n for i in range(n):\n  tot=nck(n-1,k-1,MOD)\n  x=n-i\n  asmin=nck(x-1,k-1,MOD)\n  y=i+1\n  asmax=nck(y-1,k-1,MOD)\n  req=tot-asmin-asmax\n  prod=(prod*pow(l[i],req,MOD))%MOD\n print(prod%MOD)", "MOD=10**9+7\np=100000\nfact=[0]*p \nfact[0]=1 \nfor i in range(1,p):\n fact[i]=(fact[i-1]*i)%MOD\ndef MI(a,MOD):\n return pow(a,MOD-2,MOD)\ndef nck(n, k):\n if n==k or k==0:\n  return 1 \n if n<k:\n  return 0 \n return (fact[n]*MI(fact[k],MOD)%MOD*MI(fact[n-k],MOD)%MOD)%MOD\nfor _ in range(int(input())):\n n,k=map(int,input().split())\n prod=1\n l=[int(i) for i in input().split()]\n l.sort()\n for i in range(n):\n  tot=nck(n-1,k-1)\n  x=n-i\n  asmin=nck(x-1,k-1)\n  y=i+1\n  asmax=nck(y-1,k-1)\n  req=tot-asmin-asmax\n  prod=(prod*pow(l[i],req,MOD))%MOD\n print(prod%MOD)", "MOD=10**9+7\np=1000000\nfact=[0]*p \nfact[0]=1 \nfor i in range(1,p):\n fact[i]=(fact[i-1]*i)%MOD\ndef MI(a,MOD):\n return pow(a,MOD-2,MOD)\ndef nck(n, k):\n if n==k or k==0:\n  return 1 \n if n<k:\n  return 0 \n return (fact[n]*MI(fact[k],MOD)%MOD*MI(fact[n-k],MOD)%MOD)%MOD\nfor _ in range(int(input())):\n n,k=map(int,input().split())\n prod=1\n l=[int(i) for i in input().split()]\n l.sort()\n for i in range(n):\n  tot=nck(n-1,k-1)\n  x=n-i\n  asmin=nck(x-1,k-1)\n  y=i+1\n  asmax=nck(y-1,k-1)\n  req=tot-asmin-asmax\n  prod*=pow(l[i],req,MOD)\n print(prod%MOD)", "MOD=10**9+7\np=1000000\nfact=[0]*p \nfact[0]=1 \nfor i in range(1,p):\n fact[i]=(fact[i-1]*i)%MOD\ndef MI(a,MOD):\n return pow(a,MOD-2,MOD)\ndef nck(n, k):\n if n==k or k==0:\n  return 1 \n if n<k:\n  return 0 \n return fact[n]*MI(fact[k],MOD)*MI(fact[n-k],MOD)%MOD\nfor _ in range(int(input())):\n n,k=map(int,input().split())\n prod=1\n l=[int(i) for i in input().split()]\n l.sort()\n for i in range(n):\n  tot=nck(n-1,k-1)\n  x=n-i\n  asmin=nck(x-1,k-1)\n  y=i+1\n  asmax=nck(y-1,k-1)\n  req=tot-asmin-asmax\n  prod*=pow(l[i],req,MOD)\n print(prod%MOD)", "MOD=10**9+7\np=6000\nfact=[0]*p \nfact[0]=1 \nfor i in range(1,p):\n fact[i]=(fact[i-1]*i)%MOD\ndef MI(a,MOD):\n return pow(a,MOD-2,MOD)\ndef nck(n, k):\n if n==k or k==0:\n  return 1 \n if n<k:\n  return 0 \n return fact[n]*MI(fact[k],MOD)*MI(fact[n-k],MOD)%MOD\nfor _ in range(int(input())):\n n,k=map(int,input().split())\n prod=1\n l=[int(i) for i in input().split()]\n l.sort()\n #nck=combo_nck(n,k)\n for i in range(n):\n  tot=nck(n-1,k-1)\n  # print(tot)\n  x=n-i\n  if x>=k-1:\n   asmin=nck(x-1,k-1)\n  else:\n   asmin=0\n  y=i+1\n  if y>=k-1:\n   asmax=nck(y-1,k-1)\n  else:\n   asmax=0\n  #print(asmin)\n  #print(asmin,asmax)\n  prod*=pow(l[i],tot-asmin-asmax,MOD)\n  # print(prod)\n print(prod%MOD)"]