["class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n     \n        stack,res,cur=[],[],['']\n        for v in expression:\n           \n            if v.isalpha():\n                cur=[c+v for c in cur]\n            elif v==',':\n                res+=cur\n                cur=['']\n            elif v=='{':\n                stack.append(res)\n                stack.append(cur)\n                res,cur=[],['']\n            elif v=='}':\n                preCur=stack.pop()\n                preRes=stack.pop()\n                cur=[p+c for p in preCur for c in res+cur]\n                res=preRes\n        return sorted(set(res+cur))", "class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        groups = [[]]\n        level = 0\n        for i, c in enumerate(expression):\n            if c == '{':\n                if level == 0:\n                    start = i+1\n                level += 1\n            elif c == '}':\n                level -= 1\n                if level == 0:\n                    groups[-1].append(self.braceExpansionII(expression[start:i]))\n            elif level == 0:\n                if c == \\\",\\\":\n                    groups.append([])\n                else:\n                    groups[-1].append([c])\n                \n        return sorted(set().union(*[set(map(''.join, itertools.product(*group))) for group in groups]))\n", "class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        stack = []\n        prev = set()\n        curr = set()\n        for s in expression:\n            if s == '{':\n                stack.append(prev)\n                stack.append(curr)\n                curr = set()\n                prev = set()\n            elif s == '}':\n                k = stack.pop()\n                p = set()\n                for i in k or ['']:\n                    for j in prev | curr:\n                        p.add(i + j)\n                prev = stack.pop()\n                curr = p\n            elif s == ',':\n                prev |= curr\n                curr = set()\n            else:\n                p = set()\n                for c in curr or ['']:\n                    p.add(c + s)\n                curr = p\n        return list(sorted(curr))", "class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        stack,res,cur=[],[],['']\n        for i,v in enumerate(expression):\n            print(v)\n            print(stack)\n            print(res,cur)\n            if v.isalpha():\n                cur=[c+v for c in cur]\n\n            elif v=='{':\n                stack.append(res)\n                stack.append(cur)\n                res,cur=[],['']\n            elif v=='}':\n                precur=stack.pop()\n                preres=stack.pop()\n                cur=[p+c for p in precur for c in res+cur]\n                res=preres\n            elif v==',':\n                res+=cur\n                cur=['']\n        return sorted(set(res+cur))", "class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        stack = []\n        for letter in expression:\n            if letter.isalpha():\n                stack.append(set(letter))\n            elif letter == '{':\n                stack.append('{')\n            elif letter == ',':\n                stack.append(',')\n            elif letter == '}': #Only deal with problems here\n                #Stack[-1] must be a set otherwise violates sense\n                while stack[-2] == ',':\n                    set2 = stack.pop()\n                    stack.pop()\n                    stack[-1].update(set2)\n                #Stack[-2] must be '{' now\n                tail = stack.pop()\n                stack[-1] = tail \n            while len(stack) > 1 and isinstance(stack[-1], set) and isinstance(stack[-2], set):\n                set2 = stack.pop()\n                set1 = stack.pop()\n                stack.append(set(w1 + w2 for w1 in set1 for w2 in set2))\n            \n        return list(sorted(stack[-1]))", "import itertools\n\nclass Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:          \n        expression = \\\"{{{0}}}\\\".format(expression)\n        s = []\n        exp = ''        \n        for x in (expression):\n            if x in ('{', ',', '}'):\n                if exp:\n                    s.append([exp])\n                    exp = ''\n                \n                while len(s) > 2 and s[-1] not in ('{', ',', '}') and s[-2] not in ('{', ',', '}'):\n                    w2, w1 = s.pop(), s.pop()\n                    s.append(sorted([''.join(y) for y in itertools.product(w1,w2)]))                                                                     \n                \n                if x == \\\"}\\\":\n                    words = set()\n                    w = s.pop()                        \n                    while w != '{':\n                        if w != \\\",\\\":                          \n                            words.update(w)\n                            \n                        w = s.pop()\n                        \n                    s.append(sorted(words))\n                else:\n                    s.append(x)  \n                    \n            else:\n                if exp == '':\n                    exp = x\n                else:\n                    exp += x\n                    \n        return s[0]\n", "class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        stack, cur, prev = [], [], []\n        for c in expression:\n            if c.isalpha():\n                cur = [x + c for x in cur or [\\\"\\\"]]\n            elif c == ',':\n                # Attach cur to prev\n                prev += cur\n                cur = []\n            elif c == '{':\n                #print(\\\"{\\\", stack, cur, prev)\n                stack.append(cur)\n                stack.append(prev)\n                cur, prev = [], []\n            else:\n                # Attach cur to prev\n                prev += cur\n                pre_prev = stack.pop()\n                pre_cur = stack.pop()\n                # multiply prev and pre_cur\n                cur= [p+c for c in prev for p in pre_cur or ['']]\n                prev = pre_prev\n                #print(\\\"}\\\", stack, cur, prev)\n        return sorted(set(cur+prev))\n", "class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        # print(expression, len(expression))\n        def helper(words1, words2):\n            # print(words1, words2)\n            s = set([])\n            for word in words1:\n                s.update([word + w for w in words2])\n            return list(s)\n        \n        if len(expression) == 1:\n            return [expression]\n        n = len(expression)\n        b = False\n        if expression[0] == '{':\n            cnt = 0\n            i = 0\n            while i < n:\n                if expression[i] == '{':\n                    cnt += 1\n                elif expression[i] == '}':\n                    cnt -= 1\n                    if not cnt:\n                        break\n                i += 1\n            if i == n - 1:\n                b = True\n        if b:\n            res = set([])\n            cnt = 0\n            i0 = i = 1\n            while i < n - 1:\n                if expression[i] == '{':\n                    cnt += 1\n                elif expression[i] == '}':\n                    cnt -= 1\n                elif expression[i] == ',' and cnt == 0:\n                    ret = self.braceExpansionII(expression[i0:i])\n                    res.update(ret)\n                    i0 = i + 1\n                i += 1\n            ret = self.braceExpansionII(expression[i0:i])\n            res.update(ret)\n            return sorted(list(res))\n        else:\n            res = [\\\"\\\"]\n            i0 = i = 0\n            while i < n:\n                while i < n and not expression[i] == '{':\n                    i += 1\n                res = helper(res, [expression[i0:i]])\n                i0 = i\n                cnt = 0\n                while i < n:\n                    # print(i, expression[i], cnt)\n                    if expression[i] == '{':\n                        cnt += 1\n                    elif expression[i] == '}':\n                        cnt -= 1\n                        if not cnt:\n                            ret = self.braceExpansionII(expression[i0:(i+1)])\n                            res = helper(res, ret)\n                            i0 = i + 1\n                            break\n                    i += 1\n            return sorted(list(set(res)))\n                \n                     ", "class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        groups = [[]]\n        level = 0\n        for i, c in enumerate(expression):\n            if c == '{':\n                if level == 0:\n                    start = i+1\n                level += 1\n            elif c == '}':\n                level -= 1\n                if level == 0:\n                    groups[-1].append(self.braceExpansionII(expression[start:i]))\n            elif c == ',' and level == 0:\n                groups.append([])\n            elif level == 0:\n                groups[-1].append([c])\n        word_set = set()\n        for group in groups:\n            word_set |= set(map(''.join, itertools.product(*group)))\n        return sorted(word_set)\n", "class Solution:\n    def braceExpansionII(self, expression: str) -> List[str]:\n        \n        res = set()\n        queue = []\n        queue.append(expression)\n        seen = set()\n        while queue:\n            n = len(queue)\n            \n            for i in range(n):\n                exp = queue.pop(0)\n                \n                if exp in seen:\n                    continue\n                else:\n                    seen.add(exp)\n                \n                if exp.find(\\\"{\\\") == -1:\n                    res.add(exp)\n                    continue\n                    \n                for j in range(len(exp)):\n                    if exp[j] == \\\"}\\\":\n                        right = j\n                        break\n                    \n                    if exp[j] == \\\"{\\\":\n                        left = j\n                \n                arr = exp[left+1:right].split(\\\",\\\")\n                \n                for element in arr:\n                    queue.append(exp[:left] + element + exp[right+1:])\n                \n        return sorted(list(res))\n        ", "import itertools\n\nfrom abc import ABC, abstractmethod\n\nclass Syntax(ABC):\n    def __init__(self, next=None):\n        self.next = next\n    \n    @abstractmethod\n    def get_values(self):\n        return []\n    \n    def get_strings(self):\n        if self.next is None:\n            return self.get_values()\n        \n        return (a+b for a in self.get_values() for b in self.next.get_strings())\n    \nclass Letter(Syntax):\n    def __init__(self, letter, next=None):\n        super().__init__(next)\n        self.letter = letter\n        \n    def get_values(self):\n        return [self.letter]\n    \nclass Union(Syntax):\n    def __init__(self, elts, next=None):\n        super().__init__(next)\n        self.elts = elts\n        \n    def get_values(self):\n        return itertools.chain(*[elt.get_strings() for elt in self.elts])\n    \nclass Solution:\n    def find_close_brace(self, expression, offset):\n        level = 1\n        \n        while level:\n            offset += 1\n            if expression[offset] == '{':\n                level += 1\n            elif expression[offset] == '}':\n                level -= 1\n        \n        return offset\n    \n    def split_union_commas(self, expression):\n        left = 0\n        curr = 0\n        \n        expressions = []\n        \n        while left < len(expression):\n            if expression[curr] == '{':\n                curr = self.find_close_brace(expression, curr) + 1\n            elif expression[curr] == ',':\n                expressions.append(expression[left:curr])\n                curr += 1\n                left = curr\n            else:\n                curr += 1\n                \n            if curr == len(expression):\n                expressions.append(expression[left:curr])\n                break\n                \n        return expressions\n    \n    def parse(self, expression, offset):\n        if offset == len(expression):\n            return None\n        \n        if expression[offset] != '{':\n            # this is a letter\n            try:\n                word_end = expression.index('{', offset)\n            except ValueError:\n                word_end = len(expression)\n                \n            return Letter(expression[offset:word_end], self.parse(expression, word_end))\n        \n        # parse union\n        close_idx = self.find_close_brace(expression, offset)\n        return Union(self.parse_union(expression[offset+1:close_idx]), self.parse(expression, close_idx+1))\n        \n    def parse_union(self, expression):\n        elts = self.split_union_commas(expression)\n        return [self.parse(elt, 0) for elt in elts]\n    \n    def braceExpansionII(self, expression: str) -> List[str]:\n        head = self.parse(expression, 0)\n        if head is None:\n            return []\n        \n        return sorted(list(set(head.get_strings())))"]