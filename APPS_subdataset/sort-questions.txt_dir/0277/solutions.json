["class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        right = 0\n        ans = 0\n        for i in range(len(light)):\n            if (light[i] > right):\n                right = light[i]\n            \n            if (i + 1 == right):\n                ans += 1\n                \n        return ans", "'''\nTime Limited\nhttps://leetcode.com/submissions/detail/406886943/testcase/\n'''\n\nclass Solution:\n    def numTimesAllBlue(self, light):\n        cnt, N = 0, len(light)\n        bulbs = [0] * N\n        for i, pos in enumerate(light, start = 1):\n            pos -= 1\n            if sum(bulbs[:pos]) == 2 * pos:\n                bulbs[pos] = 2\n                while pos + 1 < N and bulbs[pos+1] == 1:\n                    bulbs[pos+1] = 2\n                    pos += 1\n                if sum(bulbs) == 2 * i:\n                    cnt += 1\n            else:\n                bulbs[pos] = 1\n        return cnt\n        \nclass Solution:\n    def numTimesAllBlue(self, light):\n        cnt, seen = 0, set()\n        for v in light:\n            seen.add(v)\n            if max(seen) == len(seen):\n                cnt += 1 \n        return cnt\n    \nclass Solution:\n    def numTimesAllBlue(self, light):\n        cnt = 0\n        maxV, size = 0, 0\n        for v in light:\n            size += 1\n            if v > maxV: maxV = v\n            if maxV == size:\n                cnt += 1 \n        return cnt", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        def natural_sum(n):\n            return (n*(n+1))//2\n        count, s = 0, 0\n        for i in range(len(light)):\n            s += light[i]\n            if natural_sum(i+1) == s:\n                count += 1\n        return count", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        n = len(light)\n        dp = [0] * (n+1)\n        dp[0] = 2\n        max_so_far = moment = 0\n        \n        for num in light:\n            max_so_far = max(num, max_so_far)\n            if dp[num-1] == 2:\n                dp[num] = 2\n                \n                for b in range(num+1, max_so_far+1):\n                    if dp[b] == 1:\n                        dp[b] = 2\n                    else:\n                        break\n                if dp[max_so_far] == 2: moment += 1\n            else:\n                dp[num] = 1\n                \n        return moment", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res = hi = on = 0\n        for l in light:\n            on += 1\n            if l>hi:\n                hi = l\n            if on==hi:\n                res+=1\n        return res", "import bisect\nclass Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        sl = []\n        count = 0\n        for k in range(len(light)):\n            bisect.insort_right(sl,light[k])\n            if len(sl)==sl[-1]:\n                count = count +1    \n        return count\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        ans = 0\n        m = 0\n        for i, j in enumerate(light):\n            m = max(m, j)\n            if i + 1 == m:\n                ans += 1\n        return ans\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        ans = 0\n        maxidx = 0\n        \n        for i, l in enumerate(light):\n            maxidx = max(maxidx, l)\n            if i+1 == maxidx:\n                ans += 1\n        return ans", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        history = []\n        count = 0\n        limit = -1\n        for i in light:\n            history.append(light)\n            limit = max(limit, i)\n            if len(history) == limit:\n                count += 1\n        \n        \n        return count", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        count=0\n        right=0\n        for i in range(len(light)):\n            right = max(light[i], right)\n            if right==i+1:\n                count+=1\n        \n        return count", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        h = []\n        heapq.heapify(h)\n        ret = 0\n        for idx, l in enumerate(light):\n            heapq.heappush(h, -l)\n            max_val = -heapq.heappop(h)\n            ret += max_val == idx + 1\n            heapq.heappush(h, -max_val)\n        return ret", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        left_most_off = 0\n        right_most_on = -1\n        state = [0] * len(light)\n        res = 0\n        for e in light:\n            e -= 1\n            state[e] = 1\n            right_most_on = max(right_most_on, e)\n            if e == left_most_off:\n                while left_most_off < len(light) and state[left_most_off]:\n                    left_most_off += 1\n                if left_most_off == len(light) or left_most_off > right_most_on:\n                    res += 1\n        \n        return res\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        cur_max=0\n        count=0\n        res=0\n        for i in light:\n            cur_max=max(cur_max,i)\n            count+=1\n            if count==cur_max:\n                res+=1\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        state = [] # on/off\n        count = 0\n        blue = 0\n        last = 0\n        \n        for i in range(0, len(light)):\n            state.append(False)\n            \n        for i, k in enumerate(light):\n            state[k-1] = True\n            \n            # count how many are blue\n            for c in range(last, len(light)):\n                if not state[c]:\n                    last = c\n                    break\n                blue += 1\n                \n            if blue == i+1:\n                count += 1\n                \n        return count", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        return sum(i == m for i, m in enumerate(itertools.accumulate(light, max), 1))", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        on = [False]*len(light)\n        n = len(light)\n        blue,ans = 0,0\n        for i in range(0,n):\n            on[light[i]-1] = True\n            while(blue<n and on[blue] == True):\n                blue += 1\n            if(blue == i+1):\n                ans += 1\n        return ans", "from sortedcontainers import SortedList\nclass Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        turned = SortedList()\n        ret = 0\n        \n        for turn in light:\n            turned.add(turn)\n            if len(turned) == turned[-1]:\n                ret += 1\n        \n        return ret", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        n = len(light)\n        mn, ma = n + 1, 0\n        ans = 0\n        for k, v in enumerate(light):\n            ma, mn = max(ma, v), min(mn, v)\n            if mn == 1 and ma - mn == k:\n                ans += 1\n\n        return ans\n\n\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        result, right = 0, 0\n        for i, num in enumerate(light, 1):\n            right = max(right, num)\n            result += (right == i)\n        return result\n\n\n\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        count = 0\n        right = 0\n        target = 0\n        for n in reversed(light):\n            right += 1\n            target = max(target, len(light) - n + 1)\n            if right == target:\n                count += 1\n            \n        return count", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        arr = [0]*(len(light)+1)\n        most_right = 0\n        count = 0\n        for i, num in enumerate(light):\n            if num > most_right:\n                arr[num] = arr[most_right]+1 \n                most_right = num \n            else:\n                arr[most_right] += 1\n                \n            if arr[most_right] == most_right:\n                count += 1 \n                \n        return count ", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        \n        \n        cnt = 0\n        checker =  0\n        light_status = 0\n        \n        for i in range(0, len(light)):\n            light_status |= 1 <<(light[i] - 1)\n            \n            checker |= 1 << i\n            \n            if checker == light_status:\n                cnt+=1\n        return cnt\n            \n        \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        blue = right = 0\n        \n        for i, a in enumerate(light, 1):\n            right = max(right, a)\n            if i == right:\n                blue += 1\n                \n        return blue", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        r=0\n        c=0\n        for i in range(len(light)):\n            r=max(r,light[i])\n            if(r==i+1):\n                c=c+1\n        return c", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        \n        req = 1\n        seen = set()\n        ans = 0\n        for i,n in enumerate(light, start=1):\n            seen.add(n)\n            \n            if n == req:\n                while req in seen:\n                    seen.remove(req)\n                    req += 1\n            if not seen:\n                ans += 1\n\n        return ans", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        num = 0 \n        maxPos = 0 \n        res = []\n        for i in range(len(light)):\n            maxPos = max(maxPos, light[i])\n            num += 1\n            if num == maxPos:\n                res.append(i)\n        return len(res)\n                \n                \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        bSum=0\n        pSum=0\n        rr=0\n        for i in range(len(light)):\n            bSum+=light[i]\n            pSum+=i+1\n            if bSum==pSum: rr+=1\n        return rr\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        max_so_far = 0\n        ret = 0\n        for i, l in enumerate(light):\n            max_so_far = max(max_so_far, l)\n            ret += max_so_far == i + 1\n        \n        return ret", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        first = 0\n        last = 1\n        on = [False] * len(light)\n        ans = 0\n        for l in light:\n            # print(on, first, l, last)\n            on[l-1] = True\n            last = max(l, last)\n            if first + 1 == l:\n                while first<len(light) and on[first]:\n                    first += 1\n                if first == last:\n                    ans += 1\n        return ans", "class Solution:\n    def numTimesAllBlue(self, light):\n        cnt = 0\n        maxV, size = 0, 0\n        for v in light:\n            size += 1\n            if v > maxV: maxV = v\n            if maxV == size:\n                cnt += 1\n        return cnt", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        right = result = 0\n        for i, a in enumerate(light, 1):\n            right = max(right, a)\n            result += right == i\n        return result\n        \n        \n        \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        c=0\n        mx=0\n        for i in range(len(light)):\n            a = light[i]\n            mx=max(mx,a)\n            if mx==i+1:\n                c+=1\n        return c", "# \nclass Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        # index for lights that should be on but is currently off\n        pending_on = set()\n        \n        # index for lights that is turned on but not yet blue\n        already_on = set()\n        \n        count = 0\n        for idx, lgt in enumerate(light):\n            lgt -= 1 # change from 1-base to 0-base\n            if idx in already_on:\n                already_on.remove(idx)\n            else:\n                pending_on.add(idx)\n            \n            if lgt in pending_on:\n                pending_on.remove(lgt)\n            else:\n                already_on.add(lgt)\n            \n            if len(pending_on) == 0:\n                count += 1\n        \n        return count\n", "##we need to find out for indices i which ones such that a[0],a[1],...,a[i] are permutations of 1,2,...,i+1.\nclass Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        minimum = len(light)+1\n        maximum = 0\n        moments = 0\n        for index,num in enumerate(light):\n            minimum = min(num,minimum)\n            maximum = max(num,maximum)\n            if minimum == 1 and maximum == index+1:\n                moments += 1\n        return moments\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        yellow, blue = set(), set()\n        moment = 0\n        for bulb in light:\n            if bulb == 1 or bulb - 1 in blue:\n                blue.add(bulb)\n                t = bulb+1\n                while t in yellow:\n                    yellow.remove(t)\n                    blue.add(t)\n                    t += 1\n            else:\n                yellow.add(bulb)\n            if not yellow:\n                moment += 1\n        return moment\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        n = len(light)\n        ans = 0\n        bulbs = [0 for _ in range(n)]\n        zero_i, one_i = 0, 0\n        for i in light:\n            bulbs[i-1] = 1\n            if zero_i == i-1:\n                j = i-1\n                while j < n and bulbs[j] == 1:\n                    j += 1\n                zero_i = j\n            one_i = max(one_i, i-1)\n            if one_i < zero_i:\n                ans += 1\n                \n        return ans", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        min_seen, max_seen = float('inf'), float('-inf')\n        times = 0\n        for i, moment in enumerate(light):\n            min_seen = min(min_seen, moment)\n            max_seen = max(max_seen, moment)\n            times += (max_seen - min_seen == i) and min_seen == 1 and max_seen == i + 1\n        return times\n", "class Solution:\n    def numTimesAllBlueQuad(self, light: List[int]) -> int:\n        blue = 0\n        lights = [0 for l in light]\n        \n        for l in light:\n            lights[l-1] = 1\n            \n            if all([x == 1 for x in lights[:l-1]]):\n                blue += 1\n                print(l)\n        \n        return blue\n            \n    def numTimesAllBlue(self, light: List[int]) -> int:\n        count = 0\n        sums = [0] * (len(light) + 1)\n        for idx, l in enumerate(light):\n            sums[idx+1] = sums[idx] + l\n            \n        print(sums)\n        for idx, l in enumerate(light):\n            if sums[idx+1] == self.required(idx+1):\n                count += 1\n        \n        return count\n        \n    @staticmethod\n    def required(n):\n        return ((n+1)*n)//2", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        n = len(light)\n        rMin = [light[-1]]*n\n        for i in range(n-2,-1,-1):\n            rMin[i] = min(rMin[i+1],light[i])\n        \n        out = 1\n        lmax = 0\n        for i in range(n-1):\n            lmax = max(lmax,light[i])\n            if lmax <= rMin[i+1]:\n                out+=1\n        return out\n        \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        if len(light) == 0:\n            return 0\n        dic = {}\n        count = 0\n        flag = True\n        Max = light[0]\n        for i, item in enumerate(light):\n            dic[item] = True\n            Max = max(light[i], Max)\n            if Max == len(dic):\n                count += 1\n                continue\n            elif Max > len(dic):\n                flag = False\n            else:\n                for j in range(item, 0, -1):\n                    if j not in dic:\n                        flag = False\n            if flag:\n                count += 1\n            flag = True\n        return count\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res = hi = on = 0\n        for l in light:\n            on += 1\n            if l>hi:\n                hi = l\n            if on==hi:\n                res+=1\n        return res\n            \n            \n            \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        b=0\n        ans=0\n        k=0\n        l=[0 for i in range(len(light))]\n        for i in range(len(light)):\n            a=light[i]-1\n            if b==a:\n                l[a]=2\n                c=a+1\n                #print(l,a,c)\n                b=c\n                while c<len(light) and l[c]==1:\n                    l[c]=2\n                    b=c+1\n                    k-=1\n                    c+=1\n            else:\n                if a>0 and l[a-1]==2:\n                    l[a]=2\n                    b=l[a]+1\n                else:\n                    l[a]=1\n                    k+=1\n            #print(i,l,k,a,b)\n            if k==0:\n                ans+=1\n        return ans\n", "class Solution:\n    # 2:00\n    '''\n    - light yellow\n    - if left is blue\n        - keep on marking everything to the right blue\n    - if in the end number of yello = 0, increment ans\n    - key thing to notice is that the blue only start propogating when number 1 bulb is lighted\n    \n    '''\n    \n    def numTimesAllBlue(self, light: List[int]) -> int:\n        nyellow = 0\n        nblue = 0\n        dx = {}\n        YELLOW = 0\n        BLUE = 1\n        OFF = 2\n        for b in light:\n            dx[b] = OFF\n        ans = 0\n        for i in range(len(light)):\n            \n            curr = light[i]\n            dx[curr] = YELLOW\n            nyellow  += 1\n            check = False\n            \n            if curr == 1 or dx[curr - 1] == BLUE:\n                check  = True\n            if check:\n                for j in range(curr, len(light)+1):\n                    if dx[j] == OFF:\n                        break\n                    else:\n                        nyellow  -= 1\n                        nblue += 1\n                        dx[j] = BLUE\n                    \n            # print(light[i], nyellow)\n            if nyellow == 0:\n                ans += 1\n        return ans\n                \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        n = max(light)\n        bulb_status = ['off'] * (n + 1)\n        \n        count = 0\n        num_on = 0\n        num_blue = 0\n        \n        for i in light:\n            \n            bulb_status[i] = 'on'\n            num_on += 1\n            \n            while i <= n and (i == 1 or bulb_status[i - 1] == 'blue'):\n                if bulb_status[i] == 'off':\n                    break\n                    \n                bulb_status[i] = 'blue'\n                num_blue += 1\n                num_on -= 1\n                \n                i += 1\n                \n            if num_on == 0 and num_blue > 0:\n                count += 1\n        \n        return count", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        \n        maxBulb = 0\n        maxBlue = 0\n        count = 0\n        \n        moments = [False for i in range(len(light))]     \n        for idx, bulb in enumerate(light):\n            maxBulb = max(maxBulb, bulb)\n            moments[bulb-1] = True\n            if bulb == 1 or maxBlue == bulb-1:\n                maxBlue = bulb\n                i = bulb+1\n                while(i <= len(light) and moments[i-1]):\n                    maxBlue = i\n                    i+=1\n    \n            if maxBlue == maxBulb:\n                count+=1\n        return count\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        \n        # use a min and max counter when min == max => all bulbs are blue\n        \n        min_counter = -1\n        max_counter = -1\n        \n        turned_on = [0] * len(light)\n        \n        moments = 0\n        for bulb in light:\n            bulb = bulb-1\n            max_counter = max(max_counter, bulb)\n            turned_on[bulb] = 1\n            \n            while min_counter+1 < len(turned_on) and turned_on[min_counter+1] == 1: \n                min_counter += 1\n                \n            if max_counter == min_counter:\n                moments += 1\n        \n        return moments\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        if len(light) == 1:\n            return 1\n        mx, mi, s = float('-inf'), float('inf'), 0\n        \n        res = 0 \n        for i, num in enumerate(light):\n            s += num\n            mx = max(mx, num)\n            mi = min(mi, num)\n            if mi == 1 and mx == i+1 and s == (i+1)*(i+2)//2:\n                res += 1\n        \n        return res\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        light = [i-1 for i in light]\n        bulbs = [0 for _ in range(len(light))]\n        on,blue = set(),set()\n        res = 0\n        #print(bulbs)\n        #print(light)\n        n = len(light)\n        total = 0\n        for moment in light:\n            #print(bulbs,moment)\n            if moment == 0:\n                bulbs[0] = 2\n                blue.add(0)\n            elif bulbs[moment-1] == 2:\n                bulbs[moment] = 2\n                blue.add(moment)\n            else:\n                bulbs[moment] = 1\n                on.add(moment)\n            if bulbs[moment] == 2:\n                #print('turning things blue',bulbs[moment+1] if moment+1 < n else -1)\n                i = moment+1\n                while i < n and bulbs[i] == 1:\n                    bulbs[i] = 2\n                    blue.add(on.remove(i))\n                    i += 1\n            res += 1 if blue and not on else 0\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        # Moments at which max light is last consec on\n        max_light_on = -1\n        last_consecutive_on = -1\n        \n        all_blue = 0\n        \n        for light_bulb in light:\n            # Turn this light on by negating it\n            light_index = abs(light_bulb) - 1\n            light[light_index] = -light[light_index]\n            \n            # Check if this is the max light on\n            max_light_on = max(max_light_on, light_index)\n            \n            # Check if this is the last consecutive light on starting from 0\n            while last_consecutive_on < len(light) - 1 and light[last_consecutive_on + 1] < 0:\n                last_consecutive_on += 1\n            \n            if max_light_on == last_consecutive_on:\n                all_blue += 1\n        \n        return all_blue", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        sum  = total = count = 0\n        \n        for i in range(len(light)):\n            sum += i+1\n            total += light[i]\n            if sum == total:\n                count+=1\n        return count\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        min_off = 1\n        max_on = float('-inf')\n        count = 0\n        \n        blue = [0]*(len(light)+1)\n        \n        for i in range(len(light)):\n            blue[light[i]] = 1\n            max_on = max(max_on,light[i])\n            if light[i] == min_off:\n                while min_off <= len(light) and blue[min_off] == 1:\n                    min_off +=1\n            if max_on < min_off:\n                count += 1\n                \n        return count ", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        light = [i-1 for i in light]\n        bulbs = [0 for _ in range(len(light))]\n        on,blue = set(),set()\n        res = 0\n        print(bulbs)\n        print(light)\n        n = len(light)\n        total = 0\n        for moment in light:\n            #print(bulbs,moment)\n            if moment == 0:\n                bulbs[0] = 2\n                blue.add(0)\n            elif bulbs[moment-1] == 2:\n                bulbs[moment] = 2\n                blue.add(moment)\n            else:\n                bulbs[moment] = 1\n                on.add(moment)\n            if bulbs[moment] == 2:\n                #print('turning things blue',bulbs[moment+1] if moment+1 < n else -1)\n                i = moment+1\n                while i < n and bulbs[i] == 1:\n                    bulbs[i] = 2\n                    blue.add(on.remove(i))\n                    i += 1\n            res += 1 if blue and not on else 0\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        light = sorted([(light[i], i) for i in range(len(light))], key=lambda t: t[0])\n        go_over = list([t[1] for t in light])\n                     \n        smallest_distance_left_until_blue = 0\n        count = 0\n        for i in range(len(go_over)):\n            smallest_distance_left_until_blue = max(smallest_distance_left_until_blue - 1, 0, go_over[i] - i)\n            if smallest_distance_left_until_blue == 0:\n                count += 1\n            \n        return count\n", "import collections\n\nclass Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        n = len(light)\n        ans = count_blue = 0\n        state = collections.defaultdict(int)\n        \n        for j, bulb in enumerate(light):\n            #if prev bulb is blue\n            if bulb == 1 or state[bulb-1]==2:\n                state[bulb] = 2\n                count_blue+=1\n            else:\n                # else just set to lit\n                state[bulb] = 1\n            \n            \n            # if curre bulb is blue, set next bulb to blue if they are lit\n            if state[bulb] == 2:\n                i = bulb+1\n                while i<n+1 and state[i]==1:\n                    count_blue+=1\n                    state[i] = 2\n                    i+=1\n            if count_blue== j+1:\n                ans += 1\n            \n        return ans\n                \n", "def fillMissingSet(highest_bulb, bulbs_missing, bulbs_lit, difference):\n    for i in range(highest_bulb-difference,highest_bulb):\n        if i not in bulbs_lit:\n            bulbs_missing.add(i)\n\nclass Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        highest_bulb = 1\n        difference = 0\n        bulbs_lit = set()\n        bulbs_missing = set()\n        instances=0\n        fillMissingSet(light[0], bulbs_missing, bulbs_lit, difference)\n        for i in range(len(light)):\n            difference = 0\n            if highest_bulb < light[i]:\n                difference = light[i]-highest_bulb\n                highest_bulb = light[i]\n            bulbs_lit.add(light[i])\n            if light[i] in bulbs_missing:\n                bulbs_missing.remove(light[i])\n            fillMissingSet(highest_bulb, bulbs_missing, bulbs_lit, difference)\n            if len(bulbs_missing) == 0:\n                instances +=1\n            #print(highest_bulb, bulbs_missing, bulbs_lit, instances, difference)\n        return instances\n    \n\n", "import heapq\nclass Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        q = []\n        res = 0\n        for num in light:\n            heapq.heappush(q, -num)\n            if -q[0] == len(q):\n                res += 1\n        return res\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        '''m = set()\n        flag, c = -1, 0\n        for i in range(len(light)):\n            m.add(light[i])\n            for j in range(i+1,0,-1):\n                if j not in m:\n                    flag = 1\n                    break\n            if flag == 1:\n                flag = -1\n            else:\n                c += 1\n        return c'''\n        res = 0\n        curr = -1\n        for p,q in enumerate(light):\n            curr = max(curr,q)\n            if curr == p+1:\n                res += 1\n        return res\n            \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        n = len(light)\n        states = [0] * n\n        yellow_lights = set()\n        all_blue_counter = 0\n        \n        for i in range(n): \n            bulb = light[i] - 1\n            \n            if bulb == 0 or states[bulb-1] == 2:\n                states[bulb] = 2\n            elif states[bulb-1] != 2:\n                states[bulb] = 1\n                yellow_lights.add(bulb)\n            \n            if states[bulb] == 2:\n                for j in range(bulb + 1, n):\n                    if states[j] == 1:\n                        yellow_lights.remove(j)\n                        states[j] = 2\n                    else: break\n            \n            if len(yellow_lights) == 0:\n                all_blue_counter += 1\n\n        return all_blue_counter", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        moment_count = 0\n        lit_idx = -1\n        \n        idx_map = {}\n        \n        for idx, moment in enumerate(light):\n            idx_map[moment] = idx\n            \n        for moment in range(1, len(light) + 1):\n            idx = idx_map[moment]\n            light[idx] = 'L'\n            \n            if idx == lit_idx + 1:\n                for l_idx in range(lit_idx + 1, len(light)):\n                    if light[l_idx] == 'L':\n                        lit_idx += 1\n                    else:\n                        break\n                        \n            if lit_idx + 1 == moment:\n                moment_count += 1\n        \n        return moment_count", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        max_light = 0\n        num=0\n        res = 0\n        for i,l in enumerate(light):\n            max_light = max(max_light,l)\n            \n            print(max_light)\n            if i+1>=max_light:\n                res+=1\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n      res = 0\n      grid = [0]*len(light)\n      dicts = {}\n      for turn in light:\n        if turn == 1:\n          grid[turn-1] = 1\n          start = turn - 1\n          while start < len(light):\n            if grid[start] != 0:\n              if start in dicts: del dicts[start]\n              grid[start] = 1\n              start += 1\n            else:\n              break\n          if not dicts: res += 1\n        else:\n          if grid[turn - 2] == 1:\n            grid[turn - 1] = 1\n            start = turn - 1\n            breaked = False\n            while start < len(light):\n              if grid[start] != 0:\n                if start in dicts: del dicts[start]\n                grid[start] = 1\n                start += 1\n              else:\n                break\n            if not dicts: res += 1           \n          else:\n            grid[turn -1] = 2\n            dicts[turn - 1] = 1\n      return res\n            \n            \n        \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        len_lis = len(light)\n        lis = [[] for x in range(len_lis+2)]\n        tot = 0\n        for i in range(len_lis):\n            if(light[i] > 1 and lis[light[i]-1] and light[i] < len_lis and lis[light[i]+1]):\n                end = lis[light[i]+1][1]\n                start = lis[light[i]-1][0]\n            elif(light[i] > 1 and lis[light[i]-1]):\n                start = lis[light[i]-1][0]\n                end = light[i]\n            elif(light[i] < len_lis and lis[light[i]+1]):\n                start = light[i]\n                end = lis[light[i]+1][1]\n            else:\n                start = light[i]\n                end = light[i]\n            if(end-start == i and start == 1):\n                tot += 1\n            lis[end] = [start, end]\n            lis[start] = [start, end]\n            #print(lis)\n        return tot", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        ranges = {}\n        r = 0\n        for l in light:\n            if l + 1 not in ranges and l - 1 not in ranges:\n                ranges[l] = (l, l)\n            elif l + 1 in ranges and l - 1 not in ranges:\n                _, rr = ranges[l + 1]\n                ranges[l] = ranges[rr] = (l, rr)\n                if rr != l + 1:\n                    del ranges[l + 1]\n            elif l - 1 in ranges and l + 1 not in ranges:\n                ll, _ = ranges[l - 1]\n                ranges[ll] = ranges[l] = (ll, l)\n                if ll != l - 1:\n                    del ranges[l - 1]\n            else:\n                ll, _ = ranges[l - 1]\n                _, rr = ranges[l + 1]\n                ranges[ll] = ranges[rr] = (ll, rr)\n                if ll != l - 1:\n                    del ranges[l - 1]\n                if rr != l + 1:\n                    del ranges[l + 1]\n            # print(ranges)\n            if len(ranges) == 1:\n                r += (list(ranges.items())[0][0] == 1)\n            elif len(ranges) == 2:\n                r += (len(set(ranges.values())) == 1 and list(ranges.values())[0][0] == 1)\n        return r", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        right = res = 0\n        for i, v in enumerate(light):\n            right = max(right, v)\n            res += right == i + 1\n        return res\n\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        max_v = 0\n        res = 0\n        \n        for i,v in enumerate(light):\n            max_v = max(max_v, v)\n            if max_v == i+1:\n                res += 1\n        \n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        n = 0\n        highest = 0\n        ans = 0\n        \n        for bulb in light:\n            n += 1\n            highest = max(highest, bulb)\n            if highest == n:\n                ans += 1\n        \n        return ans", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        '''arr=[0]*(len(light)+1)\n        cnt=0\n        max_1=light[0]\n        i=0\n        while i<len(light):\n            arr[light[i]]=1           \n            if max_1<light[i]:\n                max_1=light[i] \n            if sum(arr)==max_1:\n                cnt+=1\n            i+=1\n        return(cnt)'''\n        \n        cnt=0\n        max_1=light[0]\n        for i in range(0,len(light)):\n            max_1=max(max_1,light[i])\n            #print(max_1,i+1)\n            if max_1==i+1:\n                cnt+=1\n        return(cnt)", "def parent(p,i):\n    if p[i]!=i:\n        p[i]=parent(p,p[i])\n    return p[i]\n\n\nclass Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        p=[0]*len(light)\n        c=[0]*len(p)\n        for i in range(len(p)):\n            p[i]=i\n        x=0\n        ans=0\n        for j in light:\n            i=j-1\n            x+=1\n            c[i]=1\n            if i-1>-1 and c[i-1]!=0:\n                p[i]=parent(p,i-1)\n                c[p[i]]+=1\n            if i+1<len(light) and c[i+1]!=0:\n                c[p[i]]+=c[i+1]\n                p[i+1]=p[i]\n            if c[p[i]]==x and c[0]!=0:\n                #print(c)\n                #print(p)\n                #print()\n                ans+=1\n        return ans", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        rolling_min = light[0]\n        rolling_max = light[0]\n        r = 0\n        for i, l in enumerate(light):\n            rolling_min = min(rolling_min, l)\n            rolling_max = max(rolling_max, l)\n            r += (rolling_min == 1 and rolling_max == i + 1)\n        return r", "from heapq import heappush,heappop,heapify\nclass Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        n=len(light)\n        a=[]\n        ans=0\n        for i in range(n):\n            heappush(a,-1*(light[i]))\n            if len(a)==i+1:\n                temp=-1*heappop(a)\n                if  temp==i+1:\n                    ans+=1\n                heappush(a,-1*temp)\n        return ans", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        maximum = 1\n        res = 0\n        for i, val in enumerate(light):\n            maximum = max(maximum, val)\n            if i+1 == maximum:\n                res += 1\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res, mx = 0, 0\n        for i, v in enumerate(light, 1):\n            mx = max(v, mx)\n            res += (i == mx)\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        right = res = 0\n        for i, a in enumerate(light, 1):\n            right = max(right, a)\n            res += right == i\n        return res\n", "class Solution:\n    # 2:00\n    '''\n    - light yellow\n    - if left is blue\n        - keep on marking everything to the right blue\n    - if in the end number of yello = 0, increment ans\n    - key thing to notice is that the blue only start propogating when number 1 bulb is lighted\n    \n    '''\n    \n    def numTimesAllBlue(self, light: List[int]) -> int:\n        nyellow = 0\n        nblue = 0\n        dx = {}\n        YELLOW = 0\n        BLUE = 1\n        OFF = 2\n        for b in light:\n            dx[b] = OFF\n        ans = 0\n        for i in range(len(light)):\n            \n            curr = light[i]\n            dx[curr] = YELLOW\n            nyellow  += 1\n            check = False\n            \n            if curr == 1 or dx[curr - 1] == BLUE:\n                check  = True\n            if check:\n                for j in range(curr, len(light)+1):\n                    if dx[j] == OFF:\n                        break\n                    else:\n                        nyellow  -= 1\n                        nblue += 1\n                        dx[j] = BLUE\n                    \n            print((light[i], nyellow))\n            if nyellow == 0:\n                ans += 1\n        return ans\n                \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        total = 0\n        count = 0\n        for k in range(len(light)):\n            total += light[k]\n            if total == ((k + 1) * (k + 2)) // 2:\n                count += 1\n        return count\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res = 0\n        n = len(light)\n        counter = collections.Counter()\n        for i in range(n):\n            counter[light[i]] += 1\n            if counter[light[i]] == 0:\n                counter.pop(light[i])\n            counter[i+1] -= 1\n            if counter[i+1] == 0:\n                counter.pop(i+1)\n            if not counter:\n                res += 1\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        maxv = 0\n        result =0\n        \n        for i, num in enumerate(light):\n            maxv = max(maxv, num)\n            if maxv== i+1: result+=1\n        return result\n            \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        status = [0]*(len(light)+1)\n                    \n        k = 0\n        number_of_blues = 0\n        count = 0\n        \n        while(k < len(light)):\n            idx = light[k]\n            status[idx] = 1\n            \n            if idx == 1:\n                status[1] = 2\n                number_of_blues += 1\n                \n            for i in range(idx,len(light)+1):\n                if i == idx and status[i] == 2:\n                    continue\n                if status[i] == 1 and status[i-1] == 2:\n                    status[i] = 2\n                    number_of_blues += 1\n                else:\n                    break\n                    \n            if number_of_blues == k+1:\n                count += 1\n\n\n            #print(status)   \n            k += 1\n\n        return count\n            \n                \n                \n                \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n      res = 0\n      grid = [0]*len(light)\n      dicts = {}\n      for turn in light:\n        if turn == 1:\n          grid[turn-1] = 1\n          start = turn\n          while start < len(light):\n            if grid[start] != 0:\n              if start in dicts: del dicts[start]\n              grid[start] = 1\n              start += 1\n            else:\n              break\n          if not dicts: res += 1\n        else:\n          if grid[turn - 2] == 1:\n            grid[turn - 1] = 1\n            start = turn\n            breaked = False\n            while start < len(light):\n              if grid[start] != 0:\n                if start in dicts: del dicts[start]\n                grid[start] = 1\n                start += 1\n              else:\n                break\n            if not dicts: res += 1           \n          else:\n            grid[turn -1] = 2\n            dicts[turn - 1] = 1\n      return res\n            \n            \n        \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res = 0\n        n = len(light)\n        \n        # Actual turned on light (positive)\n        # Required turned on light (negative)\n        counter = collections.Counter()\n        for i in range(n):\n            counter[light[i]] += 1\n            if counter[light[i]] == 0:\n                counter.pop(light[i])\n            \n            counter[i+1] -= 1\n            if counter[i+1] == 0:\n                counter.pop(i+1)\n            \n            if not counter:\n                res += 1\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        s = 0\n        max_index = 0\n        count = 0\n        for i in range(len(light)):\n            s += 1\n            if light[i] > max_index:\n                max_index = light[i]\n            \n            #print(f\\\"s: {s} max_index: {max_index} i: {i}\\\")\n            if i+1 == max_index:\n                count += 1\n                \n        return count", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        curr_max = 0\n        res = 0\n        for idx, val in enumerate(light):\n            curr_max = max(curr_max, val)\n            if curr_max == idx + 1:\n                res += 1\n        return res\n            \n            \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        max_ind = 0\n        res = 0\n        for t in range(len(light)):\n            max_ind = max(max_ind, light[t])\n            if max_ind == t+1:\n                res += 1\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        max_on = 0\n        count = 0\n        for idx, bulb in enumerate(light):\n            max_on = max(max_on, bulb)\n            \n            if max_on == idx+1:\n                count += 1\n        \n        return count", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res = right = 0\n        for i, n in enumerate(light):\n            # update right most bulb's number\n            right = max(right, n)\n            # right most bulb's number equals to number of processed bulbs\n            # meaning all bulbs to the left are ON\n            res += 1 if right == i + 1 else 0\n        return res\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        right = -1\n        res = 0\n        for i in range(len(light)):\n            right = max(light[i], right)\n            if right == i+1:\n                res += 1\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        bulb_ranges = {}\n        lights_on = 0\n        result = 0\n        for l in light:\n            lights_on += 1\n            left = right = None\n            if l - 1 not in bulb_ranges and l + 1 not in bulb_ranges:\n                left = l\n                right = l\n            else:\n                if l - 1 in bulb_ranges:\n                    cur_left, cur_right = bulb_ranges[l - 1]\n                    left = cur_left\n                    right = l\n                    del bulb_ranges[l - 1]\n                if l + 1 in bulb_ranges:\n                    cur_left, cur_right = bulb_ranges[l + 1]\n                    if left is None:\n                        left = l\n                    right = cur_right\n                    del bulb_ranges[l + 1]\n                    \n            bulb_ranges[left] = (left, right)\n            bulb_ranges[right] = (left, right)\n            if left == 1 and right - left + 1 == lights_on:\n                result += 1\n        \n        return result", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res = nums_on = last_pos = 0\n        for pos in light:\n            nums_on += 1\n            if pos > last_pos:\n                last_pos = pos\n            if nums_on == last_pos:\n                res += 1\n                \n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        last_on = 0\n        heap = []\n        heapq.heapify(heap)\n        result = 0\n        for i, num in enumerate(light):\n            if num == last_on + 1:\n                last_on = num\n                if not heap: result += 1\n                while(heap):    \n                    top = heapq.heappop(heap)\n                    if top == last_on+1:\n                        last_on += 1\n                    else:\n                        heapq.heappush(heap, top)\n                        break\n                    if not heap:\n                        result+=1\n            else:\n                heapq.heappush(heap, num)\n        return result", "class Solution:\n    def numTimesAllBlue(self, A):\n        right = res = 0\n        for i, a in enumerate(A, 1):\n            right = max(right, a)\n            res += right == i\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        _min = len(light)+1\n        _max = 0\n        missing = set()\n        num_moments = 0\n        \n        for i in light:\n            if i > _max:\n                if _max != 0:\n                    for j in range(_max+1, i):\n                        missing.add(j)\n                _max = i\n            if i < _min:\n                if _min != len(light)+1:\n                    for j in range(i+1, _min):\n                        missing.add(j)\n                _min = i\n            if i in missing:\n                missing.remove(i)\n            if len(missing) == 0 and _min < 2:\n                num_moments+=1\n        return num_moments\n                \n        \n#         number_of_moments = 0\n#         max_seen_value = 0\n#         min_seen_index = len(light)+1\n        \n#         for i in range(len(light)):\n#             if abs(max_seen - light[i]) == 1 and min_seen_index == 0:\n#                 number_of_moments += 1\n            \n#             if light[i] > max_seen:\n#                 max_seen = light[i]-1\n            \n#             if min_seen_index < light[i] - 1:\n#                 min_seen_index == light[i] - 1\n            \n            \n#         return number_of_moments \n    \n    \n    # max = 3, index = 2\n    # max = 3, index = 1\n    # max = 4, index = 1\n    # max = 4, index = 0\n    \n    \n#     light_on = [0]*len(light)\n#         number_of_moments = 0\n#         farthest_pos = 0\n#         for i in range(len(light)):\n#             all_blue = True\n#             light_on[light[i]-1] = 1\n#             if light[i] - 1 > farthest_pos:\n#                 farthest_pos = light[i] - 1\n#             for j in range(farthest_pos):\n#                 if light_on[j] == 0:\n#                     all_blue = False\n#                     break;\n#             if all_blue:\n#                 number_of_moments += 1\n            \n#         return number_of_moments  \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        max_ = 0\n        output = 0\n        for i in range(len(light)):\n            max_ = max(max_, light[i])\n            if max_ == i+1:\n                output += 1\n        return output\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res = 0\n        high = 0\n        on = 0\n        \n        for l in light:\n            on += 1\n            if l > high:\n                high = l\n            if on == high:\n                res += 1\n        \n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        # count times when all the lights on the left are on\n        # which is: when the max idx of the lights on == the the number of lights on. \n        max_idx = float('-inf')\n        cnt = 0\n        for i in range(len(light)):\n            max_idx = max(max_idx, light[i])\n            if max_idx == i + 1:\n                cnt += 1\n        return cnt\n        \n            \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        _max = 0\n        _min = 1\n        num_moments = 0\n        for i in range(len(light)):\n            if _max < light[i]:\n                _max = light[i]\n            \n            if _max - _min == i:\n                num_moments += 1\n        return num_moments\n#         _min = len(light)+1\n#         _max = 0\n#         missing = set()\n#         num_moments = 0\n        \n#         for i in light:\n#             if i > _max:\n#                 if _max != 0:\n#                     for j in range(_max+1, i):\n#                         missing.add(j)\n#                 _max = i\n#             if i < _min:\n#                 if _min != len(light)+1:\n#                     for j in range(i+1, _min):\n#                         missing.add(j)\n#                 _min = i\n#             if i in missing:\n#                 missing.remove(i)\n#             if len(missing) == 0 and _min < 2:\n#                 num_moments+=1\n#         return num_moments\n                \n        \n#         number_of_moments = 0\n#         max_seen_value = 0\n#         min_seen_index = len(light)+1\n        \n#         for i in range(len(light)):\n#             if abs(max_seen - light[i]) == 1 and min_seen_index == 0:\n#                 number_of_moments += 1\n            \n#             if light[i] > max_seen:\n#                 max_seen = light[i]-1\n            \n#             if min_seen_index < light[i] - 1:\n#                 min_seen_index == light[i] - 1\n            \n            \n#         return number_of_moments \n    \n    \n    # max = 3, index = 2\n    # max = 3, index = 1\n    # max = 4, index = 1\n    # max = 4, index = 0\n    \n    \n#     light_on = [0]*len(light)\n#         number_of_moments = 0\n#         farthest_pos = 0\n#         for i in range(len(light)):\n#             all_blue = True\n#             light_on[light[i]-1] = 1\n#             if light[i] - 1 > farthest_pos:\n#                 farthest_pos = light[i] - 1\n#             for j in range(farthest_pos):\n#                 if light_on[j] == 0:\n#                     all_blue = False\n#                     break;\n#             if all_blue:\n#                 number_of_moments += 1\n            \n#         return number_of_moments  \n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        \n        \n        moment = 0\n        bulbsOn = 0\n        \n        for i in range(len(light)):\n            bulbsOn = max(bulbsOn, light[i])\n            \n            if bulbsOn == i + 1:\n                moment += 1\n                \n        return moment", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res = 0\n        numBlue = 0\n        status = [0] * len(light)\n        \n        for i in range(len(light)):\n            \n            idx = light[i] - 1\n            if idx == 0 or status[idx - 1] == 2:\n                status[idx] = 2\n                numBlue += 1\n                idx += 1\n                while idx != len(light) and status[idx] == 1:\n                    status[idx] = 2\n                    numBlue += 1\n                    idx += 1\n                \n            else:\n                status[idx] = 1\n            # print(status)\n            # print(numBlue)\n            # print(i + 1)\n            if numBlue == i + 1:\n                res += 1\n        \n        return res\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        res = 0\n        right = 0\n        \n        for idx in range(len(light)):\n            right = max(right, light[idx])\n            \n            if right == idx + 1:\n                res += 1\n        \n        return res\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        count = 0\n        max_idx = 0\n        res = 0\n        for p in light:\n            max_idx = max(max_idx, p-1)\n            count += 1\n            if count == max_idx + 1:\n                res += 1\n        \n        return res\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n\n        right = res = 0\n        for i, a in enumerate(light, 1):\n            right = max(right, a)\n            res += right == i\n        return res", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        def cumulative_sum(input_list):\n            curSum, cumSum = 0, []\n            for i in input_list:\n                curSum += i\n                cumSum.append(curSum)\n            return cumSum\n        \n        cumSum = cumulative_sum(light)\n        cumSum_target = cumulative_sum(list(range(1, len(light)+1)))\n        \n        return sum([cumSum[i]==cumSum_target[i] for i in range(len(cumSum))])", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        \n        moments = 0 \n        pair = [light[0], light[0] - 1]\n        for i in range(1, len(light)):    \n            if pair[1] == 0: \n                moments += 1\n            \n            if pair[0] > light[i]: \n                pair[1] -= 1\n            else: \n                pair[1] = light[i] - pair[0] + pair[1] - 1\n                pair[0] = light[i]\n            \n        if pair[1] == 0: \n            moments += 1\n        \n        return moments\n", "class Solution:\n    def numTimesAllBlue(self, light: List[int]) -> int:\n        if not light: return int()\n        \n        answer = right = int()\n        \n        for i, light in enumerate(light):\n            right   = max(right, light)\n            if i + 1 == right:\n                answer += 1\n        \n        return answer"]