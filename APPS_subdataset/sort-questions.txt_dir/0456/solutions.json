["class Solution:\n     def canCross(self, stones):\n         \"\"\"\n         :type stones: List[int]\n         :rtype: bool\n         \"\"\"\n         if stones == []: return False\n         if len(stones) == 1: return True\n         diff = [0]*len(stones)\n         \n         for i in range(1,len(stones)):\n             if stones[i] - stones[i-1] > i: return False\n         \n         stk = [(0, 0)]\n         dictt = {}\n         for idx, stone in enumerate(stones):\n             dictt[stone] = idx\n         while stk:\n             idx, prevjump = stk.pop()\n             \n             for k in range(max(1, prevjump-1), prevjump+2):\n                 if stones[idx] + k in dictt:\n                     x = dictt[stones[idx] + k]\n                     if x == len(stones) - 1: return True\n                     stk.append((dictt[stones[idx]+k], k))\n \n         return False", "class Solution:\n     def canCross(self, stones):\n         \"\"\"\n         :type stones: List[int]\n         :rtype: bool\n         \"\"\"\n         stone_set, fail = set(stones), set()\n         stack = [(0, 0)]\n         while stack:\n             stone, jump = stack.pop()\n             for j in (jump-1, jump, jump+1):\n                 s = stone + j\n                 if j > 0 and s in stone_set and (s, j) not in fail:\n                     if s == stones[-1]:\n                         return True\n                     stack.append((s, j))\n             fail.add((stone, jump))\n         return False\n         # queue, invalid, stones = [(0, 0)], [], sorted(list(set(stones)))\n         # while queue:\n         #     pos, jump = queue.pop()\n         #     for n in [jump-1, jump, jump+1]:\n         #         if n > 0 and pos + n in stones and pos + n not in invalid:\n         #             if pos + n == stones[-1]:\n         #                 return True\n         #             else:\n         #                 queue += [(pos+n, n)]\n         #         elif n > 0 and pos + n not in invalid:\n         #             invalid += [pos + n]\n         # return False\n                 \n", "class Solution:\n     def canCross(self, stones):\n         \"\"\"\n         :type stones: List[int]\n         :rtype: bool\n         \"\"\"\n         queue, target = [(0, 0)], stones[-1]\n         invalid, stones = set(), set(stones)\n         while queue:\n             pos, jump = queue.pop()\n             for n in (jump-1, jump, jump+1):\n                 if n > 0:\n                     if pos + n == target:\n                         return True\n                     elif pos + n in stones and (pos + n, n) not in invalid:\n                         queue += [(pos+n, n)]\n             invalid.add((pos, jump))\n         return False\n     \n         # stone_set, fail = set(stones), set()\n         # stack = [(0, 0)]\n         # while stack:\n         #     stone, jump = stack.pop()\n         #     for j in (jump-1, jump, jump+1):\n         #         s = stone + j\n         #         if j > 0 and s in stone_set and (s, j) not in fail:\n         #             if s == stones[-1]:\n         #                 return True\n         #             stack.append((s, j))\n         #     fail.add((stone, jump))\n         # return False\n     \n         \n                 \n", "class Solution:\n     def canCross(self, stones):\n         \"\"\"\n         :type stones: List[int]\n         :rtype: bool\n         \"\"\"\n         target, stones, memo = stones[-1], set(stones), set()\n         \n         return self.dfs(stones, 1, 1, target, memo)\n     \n     def dfs(self, stones, pos, jump, target, memo):\n         if (pos, jump) in memo:\n             return False\n         if pos == target:\n             return True\n         if pos not in stones or jump <= 0:\n             return False\n         \n         for j in (jump-1, jump, jump+1):\n             if self.dfs(stones, pos+j, j, target, memo):\n                 return True\n         memo.add((pos, jump))   # record bad position and jump\n         return False"]