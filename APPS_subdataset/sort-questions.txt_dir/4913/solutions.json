["import re\n\ndef genMask(w):\n    x = list(w)\n    for i in range(len(w)):\n        x[i] = '.'\n        yield ''.join(x)\n        x[i] = w[i]\n\ndef mutations(alice, bob, word, first):\n    players, seen  = [alice,bob], {word}\n    win, failed, i = -1, -1, first^1\n    while 1:\n        i    ^= 1\n        lst   = players[i]\n        reg   = re.compile('|'.join(genMask(word)))\n        found = next((w for w in lst if reg.match(w) and w not in seen and len(set(w))==4), None)\n        if found is None:\n            if failed==i^1: break\n            failed = i\n        else:\n            seen.add(found)\n            word, win = found, i\n            if failed!=-1: break\n    return win", "def mutations(alice, bob, word, first):\n    seen = {word}\n    mapping = {0:alice, 1:bob}\n    prev_state,state = -1, -1\n\n    def foo(word,first):\n        nonlocal state, prev_state\n        foo.counter += 1\n\n        if foo.counter > 2 and state < 0 or foo.counter > 2 and prev_state < 0:\n            return\n        \n        for a_word in mapping[first]:\n            counter = 0\n            for i,x in enumerate(a_word):\n                if a_word[i] == word[i]:\n                    counter += 1\n\n            if counter == 3 and len(set(a_word))==4 and a_word not in seen:\n                seen.add(a_word)\n                prev_state = state\n                state = first\n                word = a_word\n                break\n\n        if counter==3 or state < 0:\n            return foo(word,first^1)\n\n    foo.counter = 0\n    foo(word,first)\n    return state", "def mutations(alice, bob, matchWord, first):\n    winner = -1\n    aliceWords = list(alice)\n    bobWords = list(bob)\n    aliceFoundAWord = bobFoundAWord = True\n    matchingWordFound = True\n    numOfIncorrectLetters = 0\n    firstRound = -1\n    i = 0\n\n    if matchWord in aliceWords: #removes the word from both Alice's and Bob's memory, as they are not allowed to be used again                 \n        del aliceWords[aliceWords.index(matchWord)]    \n    if matchWord in bobWords:\n        del bobWords[bobWords.index(matchWord)]      \n    while (aliceFoundAWord and bobFoundAWord and matchingWordFound) or (firstRound < 1):\n        firstRound += 1\n        i = 0\n        numOfIncorrectLetters = 0\n        matchingWordFound = False\n        if not (first):\n            aliceFoundAWord = False\n            for word in aliceWords:\n                for letter in word:\n                    if word.find(letter) != word.rfind(letter):\n                        break                    \n                    if letter != matchWord[i]:\n                        numOfIncorrectLetters += 1\n                    i += 1\n                    if (i == 4) and (numOfIncorrectLetters == 1):\n                        aliceFoundAWord = True\n                        matchingWordFound = True\n                        del aliceWords[aliceWords.index(word)]\n                        matchWord = word\n                        if matchWord in bobWords:\n                            del bobWords[bobWords.index(word)]                        \n                        break\n                i = 0\n                numOfIncorrectLetters = 0\n                if (aliceFoundAWord):\n                    break        \n        else:\n            bobFoundAWord = False\n            for word in bobWords:\n                for letter in word:\n                    if word.find(letter) != word.rfind(letter):\n                        break\n                    if letter != matchWord[i]:\n                        numOfIncorrectLetters += 1\n                    i += 1\n                    if (i == 4) and (numOfIncorrectLetters == 1):\n                        bobFoundAWord = True\n                        matchingWordFound = True\n                        del bobWords[bobWords.index(word)]\n                        matchWord = word\n                        if matchWord in aliceWords:\n                            del aliceWords[aliceWords.index(word)]\n                        break\n                i = 0\n                numOfIncorrectLetters = 0\n                if (bobFoundAWord):\n                    break  \n        first = not (first)\n    if (aliceFoundAWord):\n        winner = 0\n    elif (bobFoundAWord):\n        winner = 1\n    else:\n        winner = -1\n    return winner", "def mutations(alice1, bob1, ini, take):\n    alice, bob, take_up, initial = alice1.copy(), bob1.copy(), take, ini\n    def do(initial):\n        for _ in range(bob.count(initial)) : bob.remove(initial)\n        for _ in range(alice.count(initial)) : alice.remove(initial)\n    find_first=lambda word,li:next((i for i,j in enumerate(li)if sum(k!=l for k,l in zip(j, word))==1 and len(set(j))==4),-1)\n    alice__, bob__ = find_first(initial, alice), find_first(initial, bob) \n    do(initial)\n    if alice__ == -1 and  bob__ == -1 : return -1\n    while True:\n        alice__, bob__ = find_first(initial, alice), find_first(initial, bob)\n        if take_up:  # bob\n            if bob__ == -1 : return  0\n            initial = bob[bob__]\n        else:  # alice\n            if alice__ == -1 : return 1\n            initial = alice[alice__]\n        do(initial)\n        take_up ^= 1", "def done(w, seen): return w in seen\ndef size(w): return len(w) == len(set(w))\ndef check(w, word):\n    found = False\n    for c1,c2 in zip(w, word):\n        if c1 != c2:\n            if found: return False\n            else: found = True\n    return True\n\ndef mutations(alice, bob, word, first):\n    okay = lambda w: not done(w, seen) and size(w) and check(w, word)\n    player = lambda: bob if first else alice\n    seen, state = {word}, 0\n    while True:\n        try:\n            word = next(filter(okay, player()))\n            if state == 1: return first\n            if state == 0: state = 2\n            seen.add(word)\n        except:\n            if state == 1: return -1\n            if state == 2: return 1 - first\n            if state == 0: state = 1\n        first = 1 - first", "def mutations(a,b,w,f):\n    z,t,i,P,U=-1,-1,f^1,[a,b],{w}\n    while 1:\n        i^=1\n        u=next((x for x in P[i]if x not in U and sum(p==q for p,q in zip(x,w))==3and len(set(x))==4),'')\n        if u:\n            w,z,U=u,i,U|{u}\n            if t!=-1:return z\n        else:\n            if t==i^1:return z\n            t=i", "def mutations(alice, bob, word, first):\n    \n    def isValid(w): return w not in seen and sum(a==b for a,b in zip(w,word))==3 and len(set(w))==4\n    \n    players, seen  = [alice,bob], {word}\n    win, failed, i = -1, -1, first^1\n    while 1:\n        i    ^= 1\n        lst   = players[i]\n        found = next((w for w in lst if isValid(w)), None)\n        if found is None:\n            if failed==i^1: break\n            failed = i\n        else:\n            seen.add(found)\n            word, win = found, i\n            if failed!=-1: break\n    return win", "def mutations(alice, bob, word, first):\n    seen = {word}\n    mapping = {0:alice, 1:bob}\n    prev_state,state = -1, -1\n\n    def foo(word,first):\n        nonlocal state, prev_state\n        foo.counter += 1\n\n        if foo.counter > 2 and (state < 0 or prev_state < 0):\n            return\n        \n        for a_word in mapping[first]:\n            counter = 0\n            for i,x in enumerate(a_word):\n                if a_word[i] == word[i]:\n                    counter += 1\n\n            if counter == 3 and len(set(a_word))==4 and a_word not in seen:\n                seen.add(a_word)\n                prev_state = state\n                state = first\n                word = a_word\n                break\n\n        if counter==3 or state < 0:\n            return foo(word,first^1)\n\n    foo.counter = 0\n    foo(word,first)\n    return state", "cmp=lambda a,b,f:(a,b)==(0,0) and -1 or a>b and 0 or a<b and 1 or a==b and not f and 1 or 0\ndef mutations(alice, bob, word, first):\n    score = {0:0, 1:0}\n    seen = {word}\n    mapping = {0:alice, 1:bob}\n\n    def foo(alice,bob,word,first):\n        foo.counter += 1\n\n        if foo.counter > 2 and not score[0] and not score[1]:\n            return\n        \n        for a_word in mapping[first]:\n            counter = 0\n            for i,x in enumerate(a_word):\n                if a_word[i] == word[i]:\n                    counter += 1\n\n            if counter == 3 and len(set(a_word))==4 and a_word not in seen:\n                seen.add(a_word)\n                word = a_word\n                score[first] += 1\n                break\n\n        if counter==3 or not score[first]:\n            return foo(alice,bob,word,first^1)\n\n    foo.counter = 0\n    foo(alice,bob,word,first)\n    return cmp(score[0],score[1],first)", "cmp=lambda a,b,f:(a,b)==(0,0) and -1 or a>b and 0 or a<b and 1 or a==b and not f and 1 or 0\ndef mutations(alice, bob, word, first):\n    al,bo = 0,0\n    start = first\n    seen = {word}\n\n    def foo(alice,bob,word,first):\n        nonlocal al,bo,start\n        if first == 0:\n            for a_word in alice:\n                c1 = 0\n                for i,x in enumerate(a_word):\n                    if a_word[i] == word[i]:\n                        c1 += 1\n\n                if c1 == 3 and len(set(a_word))==4 and a_word not in seen:\n                    seen.add(a_word)\n                    word = a_word\n                    al += 1\n                    return foo(alice,bob,word,first+1)\n                    \n            if not al and not start:\n                return foo(alice,bob,word,first+1)\n         \n \n        else:\n            for b_word in bob:\n                c2 = 0\n                for i,j in enumerate(b_word):\n                    if b_word[i] == word[i]:\n                        c2 += 1\n\n                if c2 == 3 and len(set(b_word))==4 and b_word not in seen:\n                    seen.add(b_word)\n                    word = b_word\n                    bo += 1\n                    return foo(alice,bob,word,first-1)\n            \n            if not bo and start:\n                return foo(alice,bob,word,first-1)\n            \n\n    foo(alice,bob,word,first)\n    return cmp(al,bo,first)"]