["from sklearn.cluster import KMeans\n\n# Doesn't work for big tests, too bad\ndef cluster_kmeans(points, n):\n    kmeans = KMeans(n_clusters=n)\n    kmeans.fit(points)\n    res = [[] for _ in range(n)]\n    for i,p in zip(kmeans.labels_, points):\n        res[i].append(p)\n    return sorted(map(sorted, res))\n\n\nfrom itertools import combinations, product, starmap\nimport numpy as np\n\nmemo_points = {}\ndef point_dist(p1, p2):\n    key = (p1, p2) if p1 < p2 else (p2, p1)\n    if not key in memo_points: memo_points[key] = np.linalg.norm(np.array(key[0]) - np.array(key[1]))\n    return memo_points[key]\n\nmemo_clusters = {}\ndef cluster_dist(clusters):\n    key = tuple(map(tuple, clusters))\n    if not key in memo_clusters: memo_clusters[key] = np.mean(list(starmap(point_dist, product(*key))))\n    return memo_clusters[key]\n\ndef cluster(points, n):\n    clusters = [[p] for p in points]\n    while len(clusters) > n:\n        c1, c2 = min(combinations(clusters, 2), key=cluster_dist)\n        c1.extend(c2)\n        clusters.remove(c2)\n    return sorted(map(sorted, clusters))", "import math\nimport random\n\ndef cluster(points, n):\n    def distance(c1, c2):\n        s = 0\n        for p1 in c1:\n            for p2 in c2:\n                s += math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n        return float(s) / (len(c1) * len(c2))\n\n    def closest(cs):\n        min_dist, i1, i2 = float('inf'), -1, -1\n        for i in range(len(cs)):\n            for j in range(i+1, len(cs)):\n                dist = distance(cs[i], cs[j])\n                if dist < min_dist:\n                    min_dist = dist\n                    i1, i2 = i, j\n        return i1, i2\n\n    def merge(cs, i1, i2):\n        cs[i1].extend(cs[i2])\n        del cs[i2]\n\n    clusts = [[x] for x in points]\n    while len(clusts) > n:\n        ind1, ind2 = closest(clusts)\n        merge(clusts, ind1, ind2)\n    for i in range(len(clusts)):\n        clusts[i] = sorted(clusts[i])\n    return list(sorted(clusts))", "from statistics import mean\nfrom itertools import product\nfrom math import sqrt, inf\n\n\ndef distance_between_points(point1, point2):\n    return sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\n\ndef distance_between_clusters(cluster1, cluster2):\n    return mean(\n        distance_between_points(point1, point2) for (point1, point2) in product(cluster1, cluster2)\n    )\n\n\ndef merge_clusters(cluster1, cluster2):\n    return sorted([*cluster1, *cluster2])\n\n\ndef identificator(cluster):\n    return (cluster[0], len(cluster))\n\n\ndef update_distances(clusters, distances):\n    for cluster1 in clusters:\n        for cluster2 in clusters:\n            id1 = identificator(cluster1)\n            id2 = identificator(cluster2)\n            if id1 != id2 and distances.get((id1, id2)) is None:\n                distance = distance_between_clusters(cluster1, cluster2)\n                distances[(id1, id2)] = distance\n                distances[(id2, id1)] = distance\n\n\ndef clear_unactual_distances(distances, cluster1, cluster2):\n    old_ids = [identificator(cluster1), identificator(cluster2)]\n    new_distances = {k: v for k, v in list(distances.items()) if k[0] not in old_ids and k[1] not in old_ids}\n    return new_distances\n                \n\ndef pop_minimal_distance_pair(clusters, distances):\n    minimal_ids = None\n    minimal_distance = 10_000_000\n    for ids_pair, distance in list(distances.items()):\n        if distance < minimal_distance:\n            minimal_distance = distance\n            minimal_ids = ids_pair\n    cluster1 = next(cluster for cluster in clusters if identificator(cluster) == minimal_ids[0])\n    cluster2 = next(cluster for cluster in clusters if identificator(cluster) == minimal_ids[1])\n    clusters.remove(cluster1)\n    clusters.remove(cluster2)\n    return (cluster1, cluster2)\n    \ndef cluster(points, n):\n    clusters = [[point] for point in points]\n    distances = {}\n    while n != len(clusters):\n        update_distances(clusters, distances)\n        cluster1, cluster2 = pop_minimal_distance_pair(clusters, distances)\n        new_cluster = merge_clusters(cluster1, cluster2)\n        clusters.append(new_cluster)\n        distances = clear_unactual_distances(distances, cluster1, cluster2)\n    return sorted(clusters)\n", "def dist_between_clusters(cluster1, cluster2):\n    res = 0\n    n = 0\n    for point1 in cluster1:\n        for point2 in cluster2:\n            res += ((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2) ** 0.5\n            n += 1\n    return res / n\n\ndef cluster(points, n):\n    clusters = [[point] for point in points]\n    \n    while n < len(clusters):\n        min_dist, min1, min2 = None, None, None\n        for i, cluster1 in enumerate(clusters[:-1]):\n            for j, cluster2 in enumerate(clusters[i+1:]):\n                dist = dist_between_clusters(cluster1, cluster2)\n                if min_dist is None or dist < min_dist:\n                    min_dist, min1, min2 = dist, i, i+1+j\n        clusters[min1].extend(clusters[min2])\n        clusters.pop(min2)\n    \n    for i in range(len(clusters)):\n        clusters[i].sort()\n    clusters.sort()\n    \n    return clusters\n", "from itertools import product\n\ndef distance(p1, p2):\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n\ndef cluster(points, n):\n    lista = [[en] for en in points]\n    while len(lista) > n:\n        min_pair, min_dist = (0, 0), float('inf')\n        for i in range(len(lista) - 1):\n            for j in range(i + 1, len(lista)):\n                dist = 0\n                pairs = list(product(lista[i], lista[j]))\n                for pair in pairs:\n                    dist += distance(pair[0], pair[1])\n                dist /= len(pairs)\n                if dist < min_dist:\n                    min_dist = dist\n                    min_pair = (i, j)\n        lista[min_pair[0]].extend(lista[min_pair[1]])\n        del(lista[min_pair[1]])\n    lista = [sorted(en) for en in lista]\n    return sorted(lista, key=lambda x: x[0])", "def dist(p1, p2):\n    return ((p1[0]-p2[0])**2+(p1[1]-p2[1])**2)**0.5\n\ndef MeanDist(clus1, clus2):\n    c = 0\n    for p1 in clus1:\n        for p2 in clus2:\n            c += dist(p1, p2)\n    return c/(len(clus1)*len(clus2))\n\nfrom sklearn.cluster import KMeans\nfrom collections import defaultdict\ndef cluster(points, n):\n    if len(points) < 20:\n        pred = KMeans(n_clusters=n).fit_predict(points)\n        ans = defaultdict(list)\n        for x, y in zip(pred, points):\n            ans[x].append(y)\n        res = [sorted(i) for i in list(ans.values())]\n        res = sorted(res, key=lambda x: x[0][0])\n        return res\n    \n    clus = [[p] for p in points]\n    leng = len(clus)\n    while leng > n:\n        md = float('inf')\n        for i in range(leng):\n            for j in range(i+1, leng):\n                d = MeanDist(clus[i], clus[j])\n                if d < md:\n                    md = d\n                    c = [clus[i] + clus[j]]\n                    curr = [i, j]\n        temp = [x for i, x in enumerate(clus) if i not in curr]\n        clus = temp + c\n        leng = len(clus)\n    res = [sorted(i) for i in clus]\n    res = sorted(res, key=lambda x: x[0][0])\n    return res\n", "from itertools import product, combinations\nfrom math import hypot\n\ndef euclid(p):\n    (x1, y1), (x2, y2) = p\n    return hypot(x1 - x2, y1 - y2)\n\ndef sim(pc):\n    pc1, pc2 = pc\n    return sum(map(euclid, product(pc1, pc2))) / (len(pc1) * len(pc2))\n\ndef cluster(points, n):\n    res = [[p] for p in points]\n    while len(res) > n:\n        p0, p1 = min(combinations(res, 2), key = sim)\n        res.remove(p0)\n        res.remove(p1)\n        res.append(p0 + p1)\n    return sorted(map(sorted, res))", "from math import hypot\nfrom statistics import mean\n\ndef cluster(points, n):\n    cs = [[p] for p in points]\n    def key(ij):\n        return mean(dist(p1, p2) for p1 in cs[ij[0]] for p2 in cs[ij[1]])\n    while len(cs) > n:\n        i, j = min(((i, j) for i in range(len(cs)) for j in range(i)), key=key)\n        cs[i] += cs[j]\n        del cs[j]\n    return sorted(map(sorted, cs))\n\ndef dist(a, b):\n    return hypot(a[0] - b[0], a[1] - b[1])", "import math\nimport numpy as np\nimport itertools\n\ndef cluster(points, n):\n    \n    def get_cluster_distance(cluster1, cluster2):\n        \n        # function to find distance between a single pair\n        def get_point_distance(coord_1, coord_2):\n            x1, y1 = coord_1\n            x2, y2 = coord_2\n            return math.sqrt( ((x1 - x2)**2) + ((y1 - y2)**2) )\n        \n        distances = []\n        for point_i in cluster1:\n            for point_j in cluster2:\n                distances.append(get_point_distance(point_i, point_j))\n        \n        return np.mean(distances)\n        \n    # Initiate list of all clusters, initially every point is a cluster (its own list)\n    all_clusters = [[point] for point in points]\n    \n    # Main function\n    while len(all_clusters) > n:\n        distances = []\n        for i, j in itertools.combinations([ _ for _ in range(len(all_clusters))], 2):\n            distances.append([i, j, get_cluster_distance(all_clusters[i], all_clusters[j])])\n        minimum_distance_pair = min(distances, key = lambda x:x[2])\n        i, j, distance = minimum_distance_pair\n        all_clusters[i] = all_clusters[i] + all_clusters.pop(j)\n        \n    # Sort points in each cluster\n    for i in range(len(all_clusters)):\n        all_clusters[i] = sorted(all_clusters[i])\n    # Sort each cluster\n    return sorted(all_clusters)"]