["import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nN, M = list(map(int, input().split()))\nD = [{} for _ in range(N)]\nfor _ in range(M):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    D[a][b] = 1\n    D[b][a] = 1\n\nL = [i-1 for i in range(N)]\nR = [i+1 for i in range(N)]\n\nF = [0] * N\nfor i in range(N):\n    if F[i]: continue\n    f = 1\n    while f:\n        f = 0\n        j = R[i]\n        while j < N:\n            if j in D[i]:\n                j = R[j]\n                continue\n            F[j] = 1\n            A = [a for a in D[i] if a not in D[j]]\n            if A: f = 1\n            for a in A:\n                if a in D[i]: del D[i][a]\n                if i in D[a]: del D[a][i]\n            A = [a for a in D[j] if a not in D[i]]\n            if A: f = 1\n            for a in A:\n                if a in D[j]: del D[j][a]\n                if j in D[a]: del D[a][j]\n\n            if R[j] < N: L[R[j]] = L[j]\n            if L[j] >= 0: R[L[j]] = R[j]\n            j = R[j]\n\nprint(N - sum(F) - 1)\n", "import sys\ninput = sys.stdin.readline\n\nn,m=list(map(int,input().split()))\nE=[set() for i in range(n+1)]\n\nfor i in range(m):\n    x,y=list(map(int,input().split()))\n    E[x].add(y)\n    E[y].add(x)\n\n\nGroup=[i for i in range(n+1)]\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nfor i in range(1,n+1):\n    if find(i)==i:\n        for j in range(1,n+1):\n            if not (j in E[i]):\n                E[i]&=E[j]\n        for j in range(1,n+1):\n            if not (j in E[i]):\n                Union(i,j)\n\n                    \nprint(len(set([find(i) for i in range(1,n+1)]))-1)\n", "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\ne = set(tuple(map(int, input().split())) for _ in range(m))\n\nunknown = set(range(1, n + 1))\nto_check = []\nans = 0\nwhile unknown:\n    if to_check:\n        u = to_check.pop()\n    else:\n        u = unknown.pop()\n        ans += 1\n    cur = []\n    for v in unknown:\n        if (u, v) in e or (v, u) in e:\n            continue\n        cur.append(v)\n    for v in cur:\n        unknown.remove(v)\n    to_check += cur\n\nprint(ans - 1)", "n, m = map(int, input().split())\ne = set(tuple(map(int, input().split())) for _ in range(m))\na = set(range(1, n + 1))\nq = []\nr = 0\nwhile a:\n    if q:\n        u = q.pop()\n    else:\n        u = a.pop()\n        r += 1\n    c = {v for v in a if (u, v) not in e and (v, u) not in e}\n    a -= c\n    q += c\nprint(r - 1)", "I = input\nVertix, edge = list(map(int,I().split()))\nedges = set(tuple(map(int, I().split())) for _ in range(edge))\nUniversal_set = set(range(1, Vertix+1))\nqueu = []\ncost = 0\nwhile Universal_set:\n    if queu:\n        pop = queu.pop()\n    else:\n        pop = Universal_set.pop()\n        cost += 1\n    next = {v for v in Universal_set if (pop, v) not in edges and (v, pop) not in edges}\n    Universal_set -= next\n    queu += next\n\nprint(cost - 1)\n", "import sys \nimport queue\nclass UF(object):\n    def __init__(self, n):\n        self.arr = list(range(n+1))\n        self.rank = [1]*(n+1)\n    \n    def root(self, x):\n        if self.arr[x] != x:\n            self.arr[x] = self.root(self.arr[x])\n        return self.arr[x]\n    \n    def union(self, x, y):\n        root_x = self.root(x)\n        root_y = self.root(y)\n\n        if root_x == root_y:\n            return \n        \n        rank_x = self.rank[root_x]\n        rank_y = self.rank[root_y]\n\n        if rank_x >= rank_y:\n            self.rank[root_x] += rank_y\n            self.arr[root_y] = root_x\n        else:\n            self.rank[root_y] += rank_x\n            self.arr[root_x] = root_y\n\nn, m = sys.stdin.readline().split(\" \")\nn = int(n)\nm = int(m)\n\n#Do note that every other edge that isn't present in this list already connects nodes.\ndef load_graph(m, n):\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = set()\n\n    for _ in range(m):\n        i, j = sys.stdin.readline().split(\" \")\n        i = int(i)\n        j = int(j)\n        graph[i].add(j)\n        graph[j].add(i)\n    return graph\n    \ndef do(n, m):\n    uf = UF(n)\n    one_graph = load_graph(m, n)\n    sorted_graph = sorted(one_graph, key = lambda x: len(one_graph[x]))\n    if m < n - 1:\n        return 0\n    if m == n - 1 and n > 1:\n        if len(one_graph[sorted_graph[-1]]) == n - 1:\n            return 1\n        else:\n            return 0\n    remaining = set(range(1, n + 1))\n\n    for start in sorted_graph:\n        if len(remaining) == 0:\n            break\n        if start not in remaining:\n            continue\n\n        Q = queue.Queue()\n        Q.put(start)\n        remaining.remove(start)\n        while not Q.empty():\n            u = Q.get()\n            \n            one_graph[u].intersection_update(remaining)\n            #intersection are things you need to process but can't yet\n            remaining.difference_update(one_graph[u])\n            for elt in remaining:\n                Q.put(elt)\n                uf.union(u, elt)\n            remaining = one_graph[u]\n            if len(remaining) == 0:\n                break \n    return len(set(uf.arr)) - 2\nres = do(n, m)\nsys.stdout.write(str(res)+\"\\n\")\n\n", "class UnionFind(object):\n    __slots__ = ['nodes']\n \n    def __init__(self, n: int):\n        self.nodes = [-1]*n\n     \n    def size(self, x: int) -> int:\n        return -self.nodes[self.find(x)]\n \n    def find(self, x: int) -> int:\n        if self.nodes[x] < 0:\n            return x\n        else:\n            self.nodes[x] = self.find(self.nodes[x])\n            return self.nodes[x]\n \n    def unite(self, x: int, y: int) -> bool:\n        root_x, root_y, nodes = self.find(x), self.find(y), self.nodes\n     \n        if root_x != root_y:\n            if nodes[root_x] > nodes[root_y]:\n                root_x, root_y = root_y, root_x\n            nodes[root_x] += nodes[root_y]\n            nodes[root_y] = root_x\n     \n        return root_x != root_y\ndef main():\n    import sys\n    from collections import Counter\n    n, m = map(int, input().split())\n    rev_edges = [[] for _ in range(n)]\n     \n    for s, t in (map(int, l.split()) for l in sys.stdin):\n        if s < t:\n            rev_edges[t-1].append(s-1)\n        else:\n            rev_edges[s-1].append(t-1)\n     \n    uf = UnionFind(n)\n    find, unite, size = uf.find, uf.unite, uf.size\n    zero_union = set()\n     \n    for v in range(n):\n        cnt = Counter()\n        for src in rev_edges[v]:\n            cnt[find(src)] += 1\n     \n        for zero_v in zero_union:\n            root = find(zero_v)\n            if size(root) > cnt[root]:\n                unite(root, v)\n     \n        zero_union = set(find(v_) for v_ in zero_union) | {find(v)}\n     \n    print(len(zero_union)-1)\nmain()", "import sys \nfrom sys import stdin,stdout\nn, m = stdin.readline().split()\nn=int(n)\nm=int(m)\ne = set(tuple(map(int, stdin.readline().split())) for _ in range(m))\na = set(range(1, n + 1))\nq = []\nr = 0\nwhile a:\n    if q:\n        u = q.pop()\n    else:\n        u = a.pop()\n        r += 1\n    c = {v for v in a if (u, v) not in e and (v, u) not in e}\n    a -= c\n    q += c\nstdout.write(str(r - 1)+'\\n')", "from collections import Counter as CO\nimport sys\ninput=sys.stdin.readline\ndef find(parent,x):\n    if(parent[x]==x):\n        return x\n    else:\n        parent[x]=find(parent,parent[x])\n        return parent[x]\ndef union(parent,x,y,member):\n    parent[x]=find(parent,x)\n    parent[y]=find(parent,y)\n    #print('bhai')\n    #print(parent)\n    if(parent[x]==parent[y]):\n        return\n    else:\n        if(x<y):\n            x,y=y,x\n        \n        member[parent[y]]+=member[parent[x]]\n        del member[parent[x]]\n        parent[parent[x]]=parent[y]\n        \n        \n        return\nn,m=list(map(int,input().split()))\ngraph=dict()\nfor i in range(1,n+1):\n    graph[i]=[]\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    if(b>a):\n        a,b=b,a\n    graph[a]+=[b]\ncount=0\nparent =dict()\nmember=dict()\nfor i in range(1,n+1):\n    parent[i]=i\n    \n \nfor i in range(1,n+1):\n    \n    l=[]\n    for r in graph[i]:\n        l+=[find(parent,r)]\n    d=dict(CO(l))\n    #print(d)\n    x=[j for j in member]\n    member[i]=1\n    #print(i)\n    #print(d)\n    #print(member)\n    for k in x:\n        if k not in d:\n            union(parent,i,k,member)\n        elif(d[k]<member[k]):\n            union(parent,i,k,member)\n    \n    #print(parent) \nprint(len(member)-1)\n    \n        \n    \n        \n", "import sys\ninput=sys.stdin.readline\ndef find(parent,x):\n    if(parent[x]==x):\n        return x\n    else:\n        parent[x]=find(parent,parent[x])\n        return parent[x]\ndef union(x,y,parent):\n    parent[x]=find(parent,x)\n    parent[y]=find(parent,y)\n    if(parent[x]==parent[y]):\n        return\n    else:\n        parent[parent[y]]=parent[x]\nfrom collections import defaultdict as dd\nn,m=map(int,input().split())\nd=dd(list)\nfor i in range(m):\n    u,v=map(int,input().split())\n    if(u>v):\n        u,v=v,u\n    d[v].append(u)\nparent=dd(int)\ncom=dd(int)\ncom[1]=1\nfor i in range(1,n+1):\n    parent[i]=i\ncom[1]=1\nfor i in range(2,n+1):\n    co=dd(int)\n    for j in com:\n        co[j]=0\n    for j in d[i]:\n        a=find(parent,j)\n        co[a]+=1\n    x=dd(int)\n    #print(com)\n    #print(co,i)\n    for j in com:\n        x[j]=com[j]\n    lol=0\n    com[i]=1\n    for j in x:\n        if(co[j]<com[j]):\n            a=find(parent,i)\n            union(j,i,parent)\n            com[j]+=com[a]\n            del com[a]\n            lol=1\nprint(len(com)-1)", "n, edges_num = list(map(int, input().split()))\nedges = set(tuple( map(int, input().split()) ) for _ in range(edges_num))\nnodes = set(range(1, n+1))\ncomps = 0\ncomp_q = []\nwhile nodes:\n    if comp_q:\n        u = comp_q.pop()\n    else:\n        u = nodes.pop()\n        comps += 1\n    zero_set = {v for v in nodes if (u,v) not in edges and (v,u) not in edges}\n    nodes -= zero_set\n    comp_q += zero_set\nprint(comps-1) \n\n\n", "import collections as cc\nimport sys\ninput=sys.stdin.readline\n#sys.setrecursionlimit(10**9)\nI=lambda:list(map(int,input().split()))\nn,m=I()\ng=[set() for i in range(n+1)]\nxx=[0]*(n+1)\nfor i in range(m):\n\tx,y=I()\n\tg[x].add(y)\n\tg[y].add(x)\nparent=[i for i in range(n+1)]\ndef find(x):\n\t#print(x,parent[x])\n\twhile x!=parent[x]:\n\t\tx=parent[x]\n\treturn x\ndef union(x,y):\n\t#print(x,y)\n\ta=find(x)\n\tb=find(y)\n\t#print(a,b)\n\tif a!=b:\n\t\tparent[x]=parent[y]=min(a,b)\nff=cc.defaultdict(int)\nused=cc.defaultdict(int)\nfor i in range(1,n+1):\n\tif find(i)==i:\n\t\t\t\n\t\tfor j in range(1,n+1):\n\t\t\tif j not in g[i]:\n\t\t\t\tg[i]&=g[j]\n\t\tfor j in range(1,n+1):\n\t\t\tif j not in g[i]:\n\t\t\t\tunion(i,j)\n\t\t\t\t\n \nprint(len(set([find(i) for i in range(1,n+1)]))-1)", "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\nsys.setrecursionlimit(10**5)\n\nn,m=I()\ng=[set() for i in range(n)]\nfor i in range(m):\n\tu,v=I()\n\tg[u-1].add(v-1)\n\tg[v-1].add(u-1)\np=[i for i in range(n)]\ndef find(x):\n\twhile x!=p[x]:\n\t\tx=p[x]\n\treturn x\n\ndef union(a,b):\n\tx=find(a)\n\ty=find(b)\n\tp[y]=x\nfor i in range(n):\n\tif p[i]==i:\n\t\tfor j in range(n):\n\t\t\tif j not in g[i]:\n\t\t\t\tg[i]&=g[j]\n\t\tfor j in range(n):\n\t\t\tif j not in g[i]:\n\t\t\t\tunion(i,j)\nprint(len(set([find(i) for i in range(n)]))-1)", "import sys\ninput = sys.stdin.readline\n#lev contains height from root,lower neighbour, higher neighbours\n#lev[0] contains 0 (because it is the root), higher neighbours (=neighbours)\nn,m=map(int,input().split())\n\nneig=[0]*n\nfor i in range(n):\n    neig[i]=[0]\n\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    neig[a][0]+=1\n    neig[b][0]+=1\n    neig[a].append(b)\n    neig[b].append(a)\n\nsol=-1\nisconnected=[False]*n\nnotinacomponent=[0]*n\nfor i in range(n):\n    notinacomponent[i]=i\ntreated=0\nwhile treated<n:\n    todo=[notinacomponent.pop()]\n    treated+=1\n    sol+=1\n    while len(todo)>0:\n        v=todo.pop()\n        for i in range(1,neig[v][0]+1):\n            isconnected[neig[v][i]]=True\n        newnotin=[]\n        for u in notinacomponent:\n            if isconnected[u]:\n                newnotin.append(u)\n            else:\n                treated+=1\n                todo.append(u)\n        notinacomponent=newnotin\n        for i in range(1,neig[v][0]+1):\n            isconnected[neig[v][i]]=False\nprint(sol)", "import sys\ninput = sys.stdin.readline\n#lev contains height from root,lower neighbour, higher neighbours\n#lev[0] contains 0 (because it is the root), higher neighbours (=neighbours)\nn,m=map(int,input().split())\n\nneig=[0]*n\nfor i in range(n):\n    neig[i]=[0]\n\nfor i in range(m):\n    a,b=map(int,input().split())\n    a-=1\n    b-=1\n    neig[a][0]+=1\n    neig[b][0]+=1\n    neig[a].append(b)\n    neig[b].append(a)\n\nsol=-1\nisconnected=[False]*n\nnotinacomponent=[0]*n\nfor i in range(n):\n    notinacomponent[i]=i\ntreated=0\nwhile treated<n:\n    todo=[notinacomponent.pop()]\n    treated+=1\n    sol+=1\n    while len(todo)>0:\n        v=todo.pop()\n        for i in range(1,neig[v][0]+1):\n            isconnected[neig[v][i]]=True\n        newnotin=[]\n        for u in notinacomponent:\n            if isconnected[u]:\n                newnotin.append(u)\n                isconnected[u]=False\n            else:\n                treated+=1\n                todo.append(u)\n        notinacomponent=newnotin\nprint(sol)", "import collections as cc\nimport sys\ninput=sys.stdin.readline\n#sys.setrecursionlimit(10**9)\nI=lambda:list(map(int,input().split()))\nn,m=I()\ng=[set() for i in range(n+1)]\nxx=[0]*(n+1)\nfor i in range(m):\n\tx,y=I()\n\tg[x].add(y)\n\tg[y].add(x)\nparent=[i for i in range(n+1)]\ndef find(x):\n\twhile x!=parent[x]:\n\t\tx=parent[x]\n\treturn x\ndef union(x,y):\n\ta=find(x)\n\tb=find(y)\n\tif a!=b:\n\t\tparent[a]=parent[b]=min(a,b)\nff=cc.defaultdict(int)\nused=cc.defaultdict(int)\nfor i in range(1,n+1):\n\tif find(i)==i:\n\t\t\t\n\t\tfor j in range(1,n+1):\n\t\t\tif j not in g[i]:\n\t\t\t\tg[i]&=g[j]\n\t\tfor j in range(1,n+1):\n\t\t\tif j not in g[i]:\n\t\t\t\tunion(i,j)\n\t\t\t\t\n \nprint(len(set([find(i) for i in range(1,n+1)]))-1)", "import collections as cc\nimport sys\ninput=sys.stdin.readline\n#sys.setrecursionlimit(10**9)\nI=lambda:list(map(int,input().split()))\nn,m=I()\ng=[set() for i in range(n+1)]\nxx=[0]*(n+1)\nfor i in range(m):\n\tx,y=I()\n\tg[x].add(y)\n\tg[y].add(x)\nparent=[i for i in range(n+1)]\ndef find(x):\n\twhile x!=parent[x]:\n\t\tx=parent[x]\n\treturn x\ndef union(x,y):\n\ta=find(x)\n\tb=find(y)\n\tif a!=b:\n\t\tparent[a]=parent[b]=min(a,b)\nff=cc.defaultdict(int)\nused=cc.defaultdict(int)\nfor i in range(1,n+1):\n\tif find(i)==i:\n\t\t\t\n\t\tfor j in range(1,n+1):\n\t\t\tif j not in g[i]:\n\t\t\t\tg[i]&=g[j]\n\t\tfor j in range(1,n+1):\n\t\t\tif j not in g[i]:\n\t\t\t\tunion(i,j)\n\t\t\t\t\n \nprint(len(set([find(i) for i in range(1,n+1)]))-1)"]