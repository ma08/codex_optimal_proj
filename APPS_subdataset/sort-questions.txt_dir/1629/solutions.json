["from collections import Counter\n\ndef exchange_sort(sequence):\n    \"\"\"Greedy algorithm based on permutation cycle decomposition:\n    1. Search for transposition placing TWO elements correctly.\n    2. Search iteratively for transposition placing ONE elements correctly.\"\"\"\n    swaps, cnt = 0, Counter()\n    for a, b in zip(sequence, sorted(sequence)):\n        if cnt[b,a] > 0:\n            cnt[b,a] -= 1\n            swaps += 1\n        elif a != b:\n            cnt[a,b] += 1\n    # Special case: as there are only three keys at most,\n    # all remaining cycles will be 3-length cycles that\n    # need 2 transpositions to place 3 elements correctly.\n    return swaps + sum(cnt.values()) // 3 * 2", "from collections import Counter\n\ndef exchange_sort(s):\n    a,b,c = (Counter(zip(*p)) for p in ((s,sorted(s)), (sorted(s),s), (s,s)))\n    return sum(((a|b) + a + b - c - c - c).values()) // 6", "def exchange_sort(l):\n    a,b,c = l.count(7),-l.count(9),-l.count(8)\n    if b!=0: return (a - l[:a].count(7) + max(l[a:b].count(9), l[b:].count(8))) \n    t=sorted(l)\n    r=0\n    for i in range(len(l)): r+=1 if t[i]>l[i] else 0\n    return r", "from collections import Counter\n\ndef exchange_sort(sequence):\n    a, b, c = map(Counter(sequence).get, (7, 8, 9))\n    if not (a and b and c): return sum(x < y for x,y in zip(sorted(sequence), sequence))\n    return sequence[a:].count(7) + max(sequence[-c:].count(8), sequence[a:-c].count(9))", "def exchange_sort(xs):\n    xs7, xs9 = xs[:xs.count(7)], xs[len(xs)-xs.count(9):]\n    return xs7.count(8) + xs9.count(8) + max(xs7.count(9), xs9.count(7))", "def exchange_sort(s):\n    t7, t8 = s.count(7), s.count(8)\n    n97, n79 = s[:t7].count(9), s[t7 + t8:].count(7)\n    n87, n98 = s[:t7].count(8), s[t7:t7 + t8].count(9)\n    return 2 * n97 + n87 + n98 - min(n79, n97)    \n", "def lsorter2(l):\n    intsec = [(a,b) for (a,b) in zip(l, sorted(l)) if a!=b]\n    return list(zip(*intsec))\n\ndef naturalSwap(l):\n    x1 = lsorter2(l)\n    ori = list(x1[0])\n    sort = list(x1[1])\n\n    si = [i for i, x in enumerate(sort) if x == ori[0]]\n    fi = [i for i, x in enumerate(ori) if x == sort[0]]\n\n    ci = [x for x in si if x in fi]\n\n    new_ori = [x for i,x in enumerate(ori) if i not in ci]\n\n    swap_num1 = len(ci)\n\n    si2 = [i for i, x in enumerate(ori) if x == ori[0]]\n    fi2 = [i for i, x in enumerate(sort) if x == sort[0]]\n\n    ci2 = [x for x in si2 if x in fi2]\n\n    new_ori2 = [x for i,x in enumerate(ori) if i not in ci2]\n\n    swap_num2 = len(ci2)\n\n    swap_real= min(swap_num1,swap_num2)\n\n    to_force_swap1 = ci[:swap_real]\n    to_force_swap2 = ci2[:swap_real]\n\n    to_force_swap3 = to_force_swap1 + to_force_swap2\n\n    new_list = [x for i, x in enumerate(ori) if i not in to_force_swap3]\n    return (new_list, swap_real)\n\ndef forcedSwap(l):\n    x1 = lsorter2(l)\n    ori = list(x1[0])\n    sort = list(x1[1])\n\n    idx = ori.index(sort[0])\n    ori[0], ori[idx] = ori[idx], ori[0]\n    return ori\n\n\n\ndef exchange_sort(l):\n    swaps = 0\n    dlist = l[:]\n    cnt = 1\n    if dlist == sorted(dlist):\n        return 0\n    \n    else:\n        while cnt > 0 and len(dlist) > 0:\n            cnt = 0\n            x1 = naturalSwap(dlist)\n            cnt = x1[1]\n            swaps += x1[1]\n            dlist = x1[0]\n        while len(dlist) > 2:\n            x2 = forcedSwap(dlist)\n            swaps+=1\n            dlist = x2\n        return swaps\n", "from collections import defaultdict, Counter\n\n# the special case allows for linear solution\ndef exchange_sort(sequence):\n    n_sevens, n_eights = sequence.count(7), sequence.count(8)\n    sevens = defaultdict(lambda: 0, Counter(sequence[:n_sevens]))\n    eights = defaultdict(lambda: 0, Counter(sequence[n_sevens:n_sevens + n_eights]))\n    nines = defaultdict(lambda: 0, Counter(sequence[n_sevens + n_eights:]))\n    direct_78 = min(sevens[8], eights[7])\n    direct_79 = min(sevens[9], nines[7])\n    direct_89 = min(eights[9], nines[8])\n    sevens[8] -= direct_78\n    nines[7] -= direct_79\n    nines[8] -= direct_89\n    eights[7] -= direct_78\n    eights[9] -= direct_89\n    sevens[7], eights[8], nines[9] = 0, 0, 0\n    return direct_78 + direct_79 + direct_89 + sum(nines.values()) * 2", "def exchange_sort(sequence):\n    a=sequence[:]\n    seven=a.count(7)\n    eight=a.count(8)\n    r=0\n    for i in range(seven,len(a)):\n        if a[i]==7:\n            r+=1\n            if i<seven+eight and 8 in a[:seven]:\n                j=a.index(8)\n            else:              \n                for j in range(seven):\n                    if a[j]!=7:\n                        break\n            a[i],a[j]=a[j],a[i]\n    r+=a[seven+eight:].count(8)\n    return r", "def exchange_sort(sequence):\n    print(sequence)\n    # Reduce the sequence into its useful data\n    counts = [sequence.count(n) for n in [7, 8, 9]]\n    dividers = [0] + [sum(counts[:i]) for i in range(1,4)]\n    groupings = [[sequence[dividers[i]:dividers[i+1]].count(n) for n in [7, 8, 9]] for i in range(3)]\n    # Perform swaps en masse until done\n    n = 0\n    def swap(t0, t1, n0, n1):\n        swappable = min(groupings[t0][n1], groupings[t1][n0])\n        groupings[t0][n0] += swappable\n        groupings[t0][n1] -= swappable\n        groupings[t1][n1] += swappable\n        groupings[t1][n0] -= swappable\n        return swappable\n    for a, b in [(0, 1), (0, 2), (1, 2)]:\n        n += swap(a, b, a, b)\n    for a, b, c in [(0, 1, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0), (1, 0, 2), (0, 2, 1)]:\n        n += swap(a, b, a, c)\n    for a, b in [(0, 1), (0, 2), (1, 2)]:\n        n += swap(a, b, a, b)\n    return n"]