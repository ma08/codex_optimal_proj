["class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        d2 = {nums2[i]:i for i in range(len(nums2))}\n        _nums1 = []\n        _nums2 = []\n        prev_i, prev_j = 0, 0\n        for i in range(len(nums1)):\n            if nums1[i] in d2:\n                _nums1.append(sum(nums1[prev_i:i]))\n                _nums2.append(sum(nums2[prev_j:d2[nums1[i]]]))\n                _nums1.append(nums1[i])\n                _nums2.append(nums1[i])\n                prev_i = i+1\n                prev_j = d2[nums1[i]]+1\n        _nums1.append(sum(nums1[prev_i:]))\n        _nums2.append(sum(nums2[prev_j:]))\n        print(_nums1)\n        print(_nums2)\n        n = len(_nums1)\n        ans = 0\n        for i in range(n):\n            ans += max(_nums1[i], _nums2[i])\n        return ans % (10**9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        i, j = 0, 0\n        n1, n2 = len(nums1), len(nums2)\n        \n        total1 = 0\n        total2 = 0\n        while i < n1 or j < n2:\n            v1 = nums1[i] if i < n1 else math.inf\n            v2 = nums2[j] if j < n2 else math.inf\n            \n            if v1 < v2:\n                total1 += v1\n                i += 1\n            elif v2 < v1:\n                total2 += v2\n                j += 1\n            elif v1 == v2:\n                total = max(total1 + v1, total2 + v2)\n                total1 = total\n                total2 = total\n                i += 1\n                j += 1\n            \n        return max(total1, total2) % (10**9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        i1, i2, n1, n2, f1, f2 = 0, 0, len(nums1), len(nums2), 0, 0\n        while i1 < n1 or i2 < n2:\n            if i1 == n1:\n                f2 += sum(nums2[i2:])\n                i2 = n2\n                continue\n            if i2 == n2: \n                f1 += sum(nums1[i1:])\n                i1 = n1\n                continue\n            if nums1[i1] < nums2[i2]:\n                f1 += nums1[i1]\n                i1 += 1\n                continue\n            if nums1[i1] > nums2[i2]:\n                f2 += nums2[i2]\n                i2 += 1\n                continue\n            f1 = f2 = max(f2 + nums2[i2], f1 + nums1[i1])     \n            i1 += 1\n            i2 += 1\n        return max(f1, f2) % 1000000007", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        i, j = 0, 0\n        a, b = 0, 0\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                a += nums1[i]\n                i += 1\n            elif nums1[i] > nums2[j]:\n                b += nums2[j]\n                j += 1\n            else:\n                a = b = max(a, b) + nums1[i]\n                i += 1\n                j += 1\n        \n        if i != len(nums1):\n            a = max(b, a + sum(nums1[i:]))\n            \n        elif j != len(nums2):\n            a = max(a, b + sum(nums2[j:]))\n            \n        return a % (10 ** 9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        m = len(nums2)\n        \n        t1 = [0 for _ in range(n+1)]\n        t2 = [0 for _ in range(m+1)]\n        i,j = 1,1\n        \n        while i<n+1 and j <m+1:\n            if nums1[i-1]==nums2[j-1]:\n                t1[i] = max(t1[i-1],t2[j-1]) + nums1[i-1]\n                t2[j] = max(t1[i-1],t2[j-1]) + nums2[j-1]\n                \n                i+=1\n                j+=1\n            \n            elif nums1[i-1] < nums2[j-1]:\n                t1[i] = t1[i-1] + nums1[i-1]\n                i+=1\n            \n            else:\n                t2[j] = t2[j-1] + nums2[j-1]\n                j+=1\n        \n        while i<n+1:\n            t1[i] = t1[i-1] + nums1[i-1]\n            i+=1\n        \n        while j<m+1:\n            t2[j] = t2[j-1] + nums2[j-1]\n            j+=1\n        \n        \n        return max(t1[-1],t2[-1]) % (10**9 + 7)         ", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        indeg = defaultdict(int)\n        g = defaultdict(list)\n        \n        for i in range(len(nums1)-1):\n            g[nums1[i]].append(nums1[i+1])\n            indeg[nums1[i+1]] += 1\n        for i in range(len(nums2)-1):\n            g[nums2[i]].append(nums2[i+1])\n            indeg[nums2[i+1]] += 1\n        \n        q = deque()\n        ans = 0\n        dists = defaultdict(int)\n        for num in g:\n            if indeg[num] == 0:\n                q.append((num, num))\n                dists[num] = num\n        \n        while q:\n            num, score = q.popleft()\n            ans = max(ans, score)\n            for nei in g[num]:\n                indeg[nei] -= 1\n                dists[nei] = max(dists[nei], score)\n                if indeg[nei] == 0:\n                    q.append((nei, nei + dists[nei]))\n        return ans % (10**9+7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        i, j, n, m = 0,0,len(nums1),len(nums2)\n        a,b = 0,0\n        result = 0\n        while i<n or j<m:\n            if i<n and (j==m or nums1[i]<nums2[j]):\n                a+=nums1[i]\n                i+=1\n            elif j<m and (i==n or nums1[i]>nums2[j]):\n                b+=nums2[j]\n                j+=1\n            else:\n                a=b=max(a,b)+nums1[i]\n                i+=1\n                j+=1\n        \n        return max(a,b)%(10**9+7)\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        a = b = i = j = 0\n        \n        c = 0\n        while(i < len(nums1) or j < len(nums2)):\n            if(i < len(nums1) and (j == len(nums2) or nums1[i] < nums2[j])):\n                a += nums1[i]\n                i += 1\n            elif(j < len(nums2) and (i == len(nums1) or nums2[j] < nums1[i])):\n                b += nums2[j]\n                j += 1\n            else:\n                c += max(a, b) + nums1[i]\n                i += 1\n                j += 1\n                a = b = 0\n        return (c + max(a, b)) % (10 ** 9 + 7)        \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        prev = collections.defaultdict(set)\n        MOD = 10 ** 9 + 7\n        if not nums1:\n            return sum(nums2)\n        elif not nums2:\n            return sum(num1)\n        ans = 0\n        combined = sorted(set(nums1 + nums2))\n        dp = collections.defaultdict(lambda: 0)\n        dp[-1] = 0\n        \n        for i in  range(len(nums1)):\n            if i == 0:\n                prev[nums1[i]].add(-1)\n            prev[nums1[i]].add(nums1[i - 1])\n            \n        for i in range(len(nums2)):\n            if i == 0:\n                prev[nums2[i]].add(-1)\n            prev[nums2[i]].add(nums2[i - 1])\n        \n        for num in combined:\n            for p in prev[num]:\n                dp[num] = max(dp[p] + num, dp[num])\n                ans = max(ans, dp[num])\n        return ans % MOD\n", "class Solution:\n    def maxSum(self, A, B):\n        i, j, n, m = 0, 0, len(A), len(B)\n        a, b, mod = 0, 0, 10**9 + 7\n        while i < n or j < m:\n            if i < n and (j == m or A[i] < B[j]):\n                a += A[i]\n                i += 1\n            elif j < m and (i == n or A[i] > B[j]):\n                b += B[j]\n                j += 1\n            else:\n                a = b = max(a, b) + A[i]\n                i += 1\n                j += 1\n        return max(a, b) % mod\n\n                \n        \n            \n            \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int: \n        dp1, dp2 = collections.defaultdict(lambda: 0), collections.defaultdict(lambda: 0)\n        i = j = 0\n        \n        while i < len(nums1) and j < len(nums2):\n            x, y = nums1[i], nums2[j]\n            if x < y:\n                if i == 0:\n                    dp1[x] = dp2[y] + x\n                else:\n                    dp1[x] = max(dp1[nums1[i-1]], dp2[y]) + x\n                i += 1\n            elif x > y:\n                if j == 0:\n                    dp2[y] = dp1[x] + y\n                else:\n                    dp2[y] = max(dp2[nums2[j-1]], dp1[x]) + y\n                j += 1\n            else:\n                dp1[x] = max((dp2[nums2[j-1]] if j != 0 else 0) + x, (dp1[nums1[i-1]] if i != 0 else 0) + x)\n                dp2[y] = max((dp1[nums1[i-1]] if i != 0 else 0) + y, (dp2[nums2[j-1]] if j != 0 else 0) + y)\n                i += 1\n                j += 1\n            \n        x, y = max(dp1.values()), max(dp2.values())\n        \n        while i < len(nums1):\n            x += nums1[i]\n            i += 1\n            \n        while j < len(nums2):\n            y += nums2[j]\n            j += 1\n        \n        return max(x, y) % (10 ** 9 + 7)", "\ndef findIndex(arr, ele, start, end) :\n    \n    while (start < end) :\n        middle = (start + end - 1) // 2\n        \n        if ele == arr[middle] :\n            return middle\n        if ele < arr[middle] :\n            end = middle\n        elif ele > arr[middle] :\n            start = middle + 1\n    \n    return -1\n    \nclass Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        temp, total = 0, 0\n        i, j = 0, 0\n        n1, n2 = len(nums1), len(nums2)\n        path1, path2 = nums1, nums2\n        \n        while (i < n1) :\n            index = findIndex(path2, path1[i], j, n2)\n            if index == -1 :\n                total += path1[i]\n                temp += path1[i]\n                i += 1\n            else :\n                if (temp >= sum(path2[j : index])) :\n                    total += path1[i]\n                    temp = path1[i]\n                else :\n                    total -= temp\n                    total += sum(path2[j : index + 1])\n                    temp = path2[index]\n                i, j = index + 1, i\n                n1, n2 = n2, n1\n                path1, path2 = path2, path1\n        \n        if (temp < sum(path2[j : n2])) :\n                total -= temp\n                total += sum(path2[j : n2])\n        return (total % 1000000007)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        common = set(nums1).intersection(set(nums2))\n        ans = 0\n        segments1 = [0]*(len(common)+1)\n        \n        tmp = 0\n        j=0\n        for i in nums1:\n            tmp+=i\n            if i in common:\n                segments1[j] = tmp\n                j+=1\n                tmp = 0\n        segments1[j] = tmp    \n        \n        j=0\n        tmp = 0\n        for i in nums2:\n            tmp+=i\n            if i in common:\n                ans+=max(segments1[j], tmp)\n                j+=1\n                tmp = 0\n        \n        ans+=max(segments1[j], tmp)\n\n        return ans % (10**9+7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        m=len(nums1);n=len(nums2);i=m-1;j=n-1;s1=0;s2=0\n        while( i>=0 and j>=0):\n            if(nums1[i]>nums2[j]):\n                s1+=nums1[i];i-=1\n            elif(nums2[j]>nums1[i]):\n                s2+=nums2[j];j-=1\n            else:\n                s1=max(s1,s2)+nums1[i]\n                s2=s1\n                i-=1;j-=1\n        if(i!=-1):s1+=sum(nums1[:i+1])\n        if(j!=-1):s2+=sum(nums2[:j+1])\n        return max(s1,s2)%(10**9+7)\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        prev = collections.defaultdict(set)\n        MOD = 10 ** 9 + 7\n        if not nums1:\n            return sum(nums2)\n        elif not nums2:\n            return sum(num1)\n        ans = 0\n        \n        dp = collections.defaultdict(lambda: 0)\n        dp[-1] = 0\n        \n        for i in  range(len(nums1)):\n            if i == 0:\n                prev[nums1[i]].add(-1)\n            prev[nums1[i]].add(nums1[i - 1])\n            \n        for i in range(len(nums2)):\n            if i == 0:\n                prev[nums2[i]].add(-1)\n            prev[nums2[i]].add(nums2[i - 1])\n        i = j = 0\n        while i < len(nums1) or j < len(nums2):\n            target = -1\n            if j >= len(nums2) or (i < len(nums1) and nums1[i] < nums2[j]):\n                target = nums1[i]\n                i += 1\n            else:\n                target = nums2[j]\n                j += 1\n        \n            for p in prev[target]:\n                dp[target] = max(dp[p] + target, dp[target])\n                ans = max(ans, dp[target])\n        return ans % MOD\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        self.mod_value = pow(10, 9) + 7\n        n = len(nums1)\n        m = len(nums2)\n        \n        i = 0\n        j = 0\n        format_nums1 = []\n        format_nums2 = []\n        while i < n and j < m:\n            if nums1[i] == nums2[j]:\n                if len(format_nums1) == 0 or format_nums1[-1][1] == 0:\n                    format_nums1.append([[0, 0], 1])\n                if len(format_nums2) == 0 or format_nums2[-1][1] == 0:\n                    format_nums2.append([[0, 0], 1])\n                format_nums1.append([[0, nums1[i]], 0])\n                format_nums2.append([[0, nums2[j]], 0])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                if len(format_nums1) == 0 or format_nums1[-1][1] == 0:\n                    format_nums1.append([[0, nums1[i]], 1])\n                else:\n                    format_nums1[-1][0] = self.add_value(format_nums1[-1][0], nums1[i])\n                i += 1\n            else:\n                if len(format_nums2) == 0 or format_nums2[-1][1] == 0:\n                    format_nums2.append([[0, nums2[j]], 1])\n                else:\n                    format_nums2[-1][0] = self.add_value(format_nums2[-1][0], nums2[j])\n                j += 1\n        while i < n:\n            if len(format_nums1) == 0 or format_nums1[-1][1] == 0:\n                format_nums1.append([[0, nums1[i]], 1])\n            else:\n                format_nums1[-1][0] = self.add_value(format_nums1[-1][0], nums1[i])\n            i += 1\n        while j < m:\n            if len(format_nums2) == 0 or format_nums2[-1][1] == 0:\n                format_nums2.append([[0, nums2[j]], 1])\n            else:\n                format_nums2[-1][0] = self.add_value(format_nums2[-1][0], nums2[j])\n            j += 1\n        if format_nums1[-1][1] == 0:\n            format_nums1.append([[0, 0], 1])\n        if format_nums2[-1][1] == 0:\n            format_nums2.append([[0, 0], 1])\n        # print(format_nums1)\n        # print(format_nums2)\n        max_value1 = [0, 0]\n        max_value2 = [0, 0]\n        n = len(format_nums1)\n        for i in range(n):\n            if format_nums1[i][1] == 0 or i == 0:\n                max_value1 = self.add_value_pair(max_value1, format_nums1[i][0])\n                max_value2 = self.add_value_pair(max_value2, format_nums2[i][0])\n            else:\n                temp1 = self.add_value_pair(max_value2, format_nums1[i][0])\n                temp2 = self.add_value_pair(max_value1, format_nums2[i][0])\n                max_value1 = self.max(self.add_value_pair(max_value1, format_nums1[i][0]), temp1)\n                max_value2 = self.max(self.add_value_pair(max_value2, format_nums2[i][0]), temp2)\n                # max_value1 = self.add_value_pair(max_value1, format_nums1[i][0])\n                # max_value2 = self.add_value_pair(max_value2, format_nums2[i][0])\n        return self.max(max_value1, max_value2)[1]\n\n\n    def add_value(self, value_pair, value):\n        value_pair[1] += value\n        while (value_pair[1] >= self.mod_value):\n            value_pair[0] += 1\n            value_pair[1] -= self.mod_value\n        return value_pair\n\n    def add_value_pair(self, value_pair1, value_pair2):\n        result = [value_pair1[0] + value_pair2[0], value_pair1[1] + value_pair2[1]]\n        while result[1] >= self.mod_value:\n            result[0] += 1\n            result[1] -= self.mod_value\n        return result\n\n    def max(self, value_pair1, value_pair2):\n        if value_pair1[0] == value_pair2[0]:\n            if (value_pair1[1] > value_pair2[1]):\n                return value_pair1\n        elif value_pair1[0] > value_pair2[0]:\n            return value_pair1\n        return value_pair2", "import bisect \nfrom collections import defaultdict\nmod = 10**9+7\nclass Solution:\n    d_nums1 = defaultdict(int)\n    d_nums2 = defaultdict(int)\n    dp = []\n    def f(self, nums1, nums2, ar_ind, pos):\n        if self.dp[ar_ind][pos]!=-1:\n            return self.dp[ar_ind][pos]\n        if ar_ind == 1:\n            if pos == len(nums2):\n                 self.dp[ar_ind][pos] = 0 \n            elif self.d_nums1[nums2[pos]] == 0 and nums1[0]!=nums2[pos]:\n                self.dp[ar_ind][pos] = (nums2[pos] + self.f(nums1,nums2,1,pos+1))\n            else:\n                self.dp[ar_ind][pos] = (nums2[pos] + max(self.f(nums1,nums2,1,pos+1),self.f(nums1,nums2,0,self.d_nums1[nums2[pos]]+1)))\n        else:\n            if pos == len(nums1):\n                self.dp[ar_ind][pos] =  0\n            elif self.d_nums2[nums1[pos]] == 0 and nums2[0]!=nums1[pos]:\n                self.dp[ar_ind][pos] =  (nums1[pos] + self.f(nums1,nums2,0,pos+1))\n            else:\n                self.dp[ar_ind][pos] = (nums1[pos] + max(self.f(nums1,nums2,0,pos+1),self.f(nums1,nums2,1,self.d_nums2[nums1[pos]]+1)))\n        return self.dp[ar_ind][pos]\n                \n    \n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        self.d_nums1.clear()\n        self.d_nums2.clear()\n        for i in range(len(nums1)):\n            self.d_nums1[nums1[i]] = i \n        for i in range(len(nums2)):\n            self.d_nums2[nums2[i]] = i \n        self.dp = [[-1]*(len(nums1)+1)]\n        self.dp.append([-1]*(len(nums2)+1))\n        # print(self.dp)\n        self.f(nums1,nums2,1,0)\n        self.f(nums1,nums2,0,0)\n        \n        # print(self.dp)\n        return max(self.dp[0][0],self.dp[1][0])%mod", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        l1,l2=len(nums1),len(nums2)\n        g=defaultdict(set)\n        for i in range(1,l1): g[nums1[i-1]].add(nums1[i])\n        for i in range(1,l2): g[nums2[i-1]].add(nums2[i])\n        @lru_cache(None)\n        def dfs(n):\n            x=0\n            for i in g[n]: x=max(x,dfs(i))\n            return n+x\n        res=max(dfs(nums1[0]),dfs(nums2[0]))\n        return res%1000000007", "class Solution:\n    \n    def binary_search(self,  arr, low, high, x): \n        # Check base case \n        if high >= low: \n\n            mid = (high + low) // 2\n            #print(high, low, mid)\n            #print(arr)\n            # If element is present at the middle itself \n            if arr[mid] == x: \n                return mid \n\n            # If element is smaller than mid, then it can only \n            # be present in left subarray \n            elif arr[mid] > x: \n                return self.binary_search(arr, low, mid - 1, x) \n            # Else the element can only be present in right subarray \n            else: \n                return self.binary_search(arr, mid + 1, high, x) \n        else: \n            # Element is not present in the array \n            return -1\n        \n        \n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        modulo = 1000000007\n        num1Sum =0\n        maxSum =0\n        num2sum = 0\n        startIndex = 0\n        len2 = len(nums2)\n        for num1 in nums1:\n            num1InNum2 = self.binary_search(nums2, startIndex, len2-1, num1)\n            #print(num1InNum2)\n            if num1InNum2 != -1:\n                num2sum =  sum(nums2[startIndex:num1InNum2])\n                maxSum += num1Sum if num1Sum > num2sum else num2sum\n                maxSum += num1\n                num2sum = num1Sum = 0\n                startIndex = num1InNum2 + 1\n            else:\n                num1Sum += num1\n                \n        num2sum = sum(nums2[startIndex:])\n        maxSum += num1Sum if num1Sum > num2sum else num2sum\n        num2sum = num1Sum = 0\n        #print(maxSum)\n        maxSum = maxSum % modulo\n        return maxSum\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        ## RC ##\n        ## APPROACH : GREEDY ##\n        ## LOGIC ##\n        ## 1. similar to merging 2 sorted arrays\n        ## 2. Maintain sum for each array\n        ## 3. when you find the same element in both arrays, only take maximum of sum1, sum2 and reset them\n        \n        p1, p2, sum1, sum2, result = 0, 0, 0, 0, 0\n        while(p1 < len(nums1) and p2 < len(nums2)):\n            if nums1[p1] == nums2[p2]:\n                result += max(sum1, sum2) + nums1[p1]\n                sum1, sum2 = 0, 0\n                p1, p2 = p1 + 1, p2 + 1\n            elif nums1[p1] < nums2[p2]:\n                sum1 += nums1[p1]\n                p1 += 1\n            else:\n                sum2 += nums2[p2]\n                p2 += 1\n\n        while(p1 < len(nums1)):\n            sum1 += nums1[p1]\n            p1 += 1\n\n        while(p2 < len(nums2)):\n            sum2 += nums2[p2]\n            p2 += 1\n\n        return (result + max(sum1 , sum2)) % (10**9 + 7)\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        a = 0; b = 0\n        i = 0; j = 0\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]: a += nums1[i]; i+=1\n            elif nums1[i] > nums2[j]: b += nums2[j]; j+=1\n            else:\n                a = b = max(a, b) + nums1[i];\n                i+=1; j+=1\n\n        while i < len(nums1): a += nums1[i]; i+=1\n        while j < len(nums2): b += nums2[j]; j+=1\n        return max(a, b) % 1_000_000_007\n", "class Solution:\n    def maxSum(self, A: List[int], B: List[int]) -> int:\n        maxi = max(A[-1], B[-1])\n        A.append(maxi + 1)\n        B.append(maxi + 1)\n        \n        i = j = 0\n        s1 = s2 = 0\n        MOD = 10 ** 9 + 7\n        while i < len(A) and j < len(B):\n            if A[i] < B[j]:\n                s1 += A[i]\n                i += 1\n            elif A[i] > B[j]:\n                s2 += B[j]\n                j += 1\n            else:\n                s1 = s2 = (max(s1, s2) + A[i]) % MOD\n                i += 1\n                j += 1\n        return (MOD + s1 - A[-1]) % MOD\n        \n    \n    def maxSum_foolish_DP(self, A: List[int], B: List[int]) -> int:\n        N = [A, B]\n        NN = [{v : i for i, v in enumerate(A)}, {v : i for i, v in enumerate(B)}]\n\n        @functools.lru_cache(None)\n        def helper(index, is_bottom, changed):\n            nonlocal N, NN\n            if index < 0:\n                return 0\n\n            value = N[is_bottom][index]\n            if changed:\n                if value not in NN[1 ^ is_bottom]:\n                    return float('-inf')\n                return helper(NN[1 ^ is_bottom][value], 1 ^ is_bottom, 0)\n            else:\n                return value + max(helper(index - 1, is_bottom, 0), helper(index - 1, is_bottom, 1))\n        \n        return (max(helper(len(A) - 1, 0, 0), helper(len(A) - 1, 0, 1), helper(len(B) - 1, 1, 0), helper(len(B) - 1, 1, 1))) % (10 ** 9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        a = 0; b = 0\n        i = 0; j = 0\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]: a += nums1[i]; i+=1\n            elif nums1[i] > nums2[j]: b += nums2[j]; j+=1\n            else:\n                a = b = max(a, b) + nums1[i] # they are equal when numbers are equal\n                i+=1; j+=1\n\n        while i < len(nums1): a += nums1[i]; i+=1\n        while j < len(nums2): b += nums2[j]; j+=1\n        return max(a, b) % 1_000_000_007\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        cross = []\n        n,m = len(nums1),len(nums2)\n        i,j = 0,0\n        M = 10**9 + 7\n        while i < n and j < m:\n            if nums1[i] > nums2[j]:\n                j += 1\n            elif nums2[j] > nums1[i]:\n                i += 1\n            else:\n                cross.append((i,j))\n                i += 1\n                j += 1\n        l = len(cross)\n        if l == 0:\n            return max(sum(nums1),sum(nums2)) % M\n        ans = max(sum(nums1[cross[-1][0]:]),sum(nums2[cross[-1][1]:]))\n        ans %= M\n        for i in range(l-2,-1,-1):\n            ans += max(sum(nums1[cross[i][0]:cross[i+1][0]]),sum(nums2[cross[i][1]:cross[i+1][1]])) \n            ans %= M\n        ans += max(sum(nums1[:cross[0][0]]),sum(nums2[:cross[0][1]])) \n        ans %= M\n        return ans % M\n#         memo = {}\n#         def fun(cl,f):\n#             if (cl,f) in memo:\n#                 return memo[(cl,f)]\n#             if cl == l-1:\n#                 if f == 0:\n#                     return sum(nums1[cross[cl][0]:])\n#                 else:\n#                     return sum(nums2[cross[cl][1]:])\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sumMax = 0\n        nLen1 = len(nums1)\n        nLen2 = len(nums2)        \n        loopLen = min(nLen1, nLen2)\n        \n        maxVal = (10**9) + 7\n        \n        idx1 = {nums1[0]:0}\n        idx2 = {nums2[0]:0}\n        ps1 = 0\n        ps2 = 0\n        pe1 = 1\n        pe2 = 1\n        for i in range(1, loopLen):\n            v1 = nums1[i]\n            v2 = nums2[i]\n            sumT = 0\n            if v1 == v2:\n                pe1 = i + 1\n                pe2 = i + 1\n                sum1 = sum(nums1[ps1:pe1])\n                sum2 = sum(nums2[ps2:pe2])\n                sumT = max(sum1, sum2)\n                ps1 = pe1\n                ps2 = pe2\n            if v1 in idx2:\n                pe1 = i + 1\n                pe2 = idx2[v1] + 1\n                sum1 = sum(nums1[ps1:pe1])\n                sum2 = sum(nums2[ps2:pe2])\n                sumT = max(sum1, sum2)\n                ps1 = pe1\n                ps2 = pe2\n            elif v2 in idx1:\n                pe2 = i + 1\n                pe1 = idx1[v2] + 1\n                sum1 = sum(nums1[ps1:pe1])\n                sum2 = sum(nums2[ps2:pe2])\n                sumT = max(sum1, sum2)\n                ps1 = pe1\n                ps2 = pe2\n            \n            # print(i, ps1, pe1, ps2, pe2, sumT)\n            sumMax += sumT\n            sumMax = sumMax % maxVal\n            \n            idx1[v1] = i\n            idx2[v2] = i\n            \n        if nLen1 > nLen2:\n            for i in range(loopLen,nLen1):\n                v1 = nums1[i]\n                if v1 in idx2:\n                    pe1 = i + 1\n                    pe2 = idx2[v1] + 1\n                    sum1 = sum(nums1[ps1:pe1])\n                    sum2 = sum(nums2[ps2:pe2])\n                    sumT = max(sum1, sum2)\n                    ps1 = pe1\n                    ps2 = pe2\n                else:\n                    sumT = 0\n                sumMax += sumT\n                sumMax = sumMax % maxVal\n                idx1[v1] = i\n                \n                if v1 > nums2[-1]:\n                    break\n        elif nLen2 > nLen1:\n            for i in range(loopLen,nLen2):\n                v2 = nums2[i]\n                if v2 in idx1:\n                    pe2 = i + 1\n                    pe1 = idx1[v2] + 1\n                    sum1 = sum(nums1[ps1:pe1])\n                    sum2 = sum(nums2[ps2:pe2])\n                    sumT = max(sum1, sum2)\n                    ps1 = pe1\n                    ps2 = pe2\n                else:\n                    sumT = 0\n                # print(i, ps1, pe1, ps2, pe2, sumT)\n                sumMax += sumT\n                sumMax = sumMax % maxVal\n                idx2[v2] = i\n                \n                if v2 > nums1[-1]:\n                    break\n                    \n        # print(ps1, ps2)\n        if(ps1 < nLen1):\n            sum1 = sum(nums1[ps1:])\n        else:\n            sum1 = 0\n        \n        if(ps2 < nLen2):\n            sum2 = sum(nums2[ps2:])\n        else:\n            sum2 = 0\n            \n        sumT = max(sum1, sum2)\n        sumMax += sumT\n        sumMax = sumMax % maxVal\n        return sumMax", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        M, N = len(nums1), len(nums2)\n        sum1, sum2 = 0, 0\n        i, j = 0, 0\n        res = 0\n        while i < M and j < N:\n            if nums1[i] < nums2[j]:\n                sum1 += nums1[i]\n                i += 1\n            elif nums1[i] > nums2[j]:\n                sum2 += nums2[j]\n                j += 1\n            else:\n                res += max(sum1, sum2) + nums1[i]\n                i += 1\n                j += 1\n                sum1 = 0\n                sum2 = 0\n                \n        while i < M:\n            sum1 += nums1[i]\n            i += 1\n        while j < N:\n            sum2 += nums2[j]\n            j += 1\n        return (max(sum1, sum2) + res) % (10 ** 9 + 7)\n                \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        M,N = len(nums1),len(nums2)\n        i = 0\n        j = 0\n        sum1 = 0\n        sum2 = 0\n        res = 0\n        while i < M and j < N:\n            if nums1[i] < nums2[j]:\n                sum1 += nums1[i]\n                i += 1\n                \n            elif nums1[i] > nums2[j]:\n                sum2 += nums2[j]\n                j += 1\n            else:\n                res += max(sum1,sum2) + nums1[i]\n                i += 1\n                j += 1\n                sum1 = 0\n                sum2 = 0\n            \n        while i < M:\n            sum1 += nums1[i]\n            i += 1\n            \n        while j < N:\n            sum2 += nums2[j]\n            j += 1\n        return (res + max(sum1,sum2)) % (10 ** 9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        n1,n2 = nums1,nums2\n        s,t,sum1,sum2 = len(n1)-1,len(n2)-1,0,0\n        li = []\n        ans = 0\n        while s >= 0 and t >= 0:\n            if n1[s] > n2[t]:\n                sum1 += n1[s]\n                s -= 1\n            elif n1[s] < n2[t]:\n                sum2 += n2[t]\n                t -= 1\n            else:\n                ans += max(sum1+n1[s],sum2+n1[s])\n                # li.append((sum1+n1[s],sum2+n1[s]))\n                sum1 = sum2 = 0\n                s -= 1\n                t -= 1\n        if s >= 0: ans += max(sum1+sum(n1[:s+1]),sum2)\n            # li.append((sum1+sum(n1[:s+1]),sum2))\n        if t >= 0: ans += max(sum1,sum2+sum(n2[:t+1]))\n            # li.append((sum1,sum2+sum(n2[:t+1])))\n        # ans = 0\n        # for l in li:\n        #     ans += max(l[0],l[1])\n        #     ans = ans % (10**9+7)\n        return ans  % (10**9+7)", "class Solution:\n    def maxSum(self, A: List[int], B: List[int]) -> int:\n        i = j = 0\n        s1 = s2 = 0\n        MOD = 10 ** 9 + 7\n        while i < len(A) or j < len(B):\n            if i < len(A) and (j == len(B) or A[i] < B[j]):\n                s1 += A[i]\n                i += 1\n            elif j < len(B) and (i == len(A) or A[i] > B[j]):\n                s2 += B[j]\n                j += 1\n            else:\n                s1 = s2 = (max(s1, s2) + A[i]) % MOD\n                i += 1\n                j += 1\n        return max(s1, s2) % MOD\n        \n    \n    def maxSum_foolish_DP(self, A: List[int], B: List[int]) -> int:\n        N = [A, B]\n        NN = [{v : i for i, v in enumerate(A)}, {v : i for i, v in enumerate(B)}]\n\n        @functools.lru_cache(None)\n        def helper(index, is_bottom, changed):\n            nonlocal N, NN\n            if index < 0:\n                return 0\n\n            value = N[is_bottom][index]\n            if changed:\n                if value not in NN[1 ^ is_bottom]:\n                    return float('-inf')\n                return helper(NN[1 ^ is_bottom][value], 1 ^ is_bottom, 0)\n            else:\n                return value + max(helper(index - 1, is_bottom, 0), helper(index - 1, is_bottom, 1))\n        \n        return (max(helper(len(A) - 1, 0, 0), helper(len(A) - 1, 0, 1), helper(len(B) - 1, 1, 0), helper(len(B) - 1, 1, 1))) % (10 ** 9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        score = 0\n        total1 = 0\n        total2 = 0\n        pos1 = 0\n        pos2 = 0\n        \n        \n        while pos1 < len(nums1) or pos2 < len(nums2):\n            if pos1 < len(nums1) and (pos2 >= len(nums2) or nums1[pos1] < nums2[pos2]):\n                total1+=nums1[pos1]\n                pos1+=1\n                continue\n            \n            if pos2 < len(nums2) and (pos1 >= len(nums1) or nums1[pos1] > nums2[pos2]):\n                total2+=nums2[pos2]\n                pos2+=1\n                continue\n                \n            score+=nums1[pos1] + max(total1, total2)\n                \n            pos1+=1\n            pos2+=1\n            total1 = 0\n            total2 = 0\n            \n        score += max(total1, total2)\n                \n        return score % ( 10**9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        n1,n2 = nums1,nums2\n        s,t,sum1,sum2 = len(n1)-1,len(n2)-1,0,0\n        ans = 0\n        while s >= 0 and t >= 0:\n            if n1[s] > n2[t]:\n                sum1 += n1[s]\n                s -= 1\n            elif n1[s] < n2[t]:\n                sum2 += n2[t]\n                t -= 1\n            else:\n                ans += max(sum1+n1[s],sum2+n1[s])\n                sum1 = sum2 = 0\n                s -= 1\n                t -= 1\n        if s >= 0: ans += max(sum1+sum(n1[:s+1]),sum2)\n        if t >= 0: ans += max(sum1,sum2+sum(n2[:t+1]))\n        return ans  % (10**9+7)", "class Solution:\n    def maxSum(self, A: List[int], B: List[int]) -> int:\n        i, j, n, m = 0, 0, len(A), len(B)\n        a, b, mod = 0, 0, 10**9 + 7\n        while i < n or j < m:\n            if i < n and (j == m or A[i] < B[j]):\n                a += A[i]\n                i += 1\n            elif j < m and (i == n or A[i] > B[j]):\n                b += B[j]\n                j += 1\n            else:\n                a = b = max(a, b) + A[i]\n                i += 1\n                j += 1\n        return max(a, b) % mod", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        dp=collections.defaultdict(int)\n        i,j=len(nums1)-2,len(nums2)-2\n        dp[nums1[-1]]=nums1[-1]\n        dp[nums2[-1]]=nums2[-1]\n        while i>=0 or j>=0:\n            v1,v2=nums1[i] if i>=0 else -1,nums2[j] if j>=0 else -1\n            # print(i,j,v1,v2,dp)\n            if v1>v2:\n                dp[v1]=v1+dp[nums1[i+1]]\n                i-=1\n            elif v1<v2:\n                dp[v2]=v2+dp[nums2[j+1]]\n                j-=1\n            else:\n                dp[v1]=v1+max(dp[nums1[i+1]],dp[nums2[j+1]])\n                i-=1\n                j-=1\n        return max(dp[nums1[0]],dp[nums2[0]])%1000000007\n            \n        \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        ans, a, b = 0, 0, 0\n        n1, n2 = len(nums1), len(nums2)\n        i, j = 0, 0\n        while i<n1 and j<n2:\n            if nums1[i] == nums2[j]:\n                ans += max(a,b) + nums1[i]\n                i+=1; j+=1\n                a,b=0,0\n            elif nums1[i] < nums2[j]:\n                a+=nums1[i]\n                i+=1\n            else:\n                b+=nums2[j]\n                j+=1\n        while i<n1:\n            a+=nums1[i]\n            i+=1\n        while j<n2:\n            b+=nums2[j]\n            j+=1\n        ans +=  max(a,b)\n        return ans % (10**9 + 7)\n            \n", "class Solution:\n    def maxSum(self, nums1, nums2):\n        M, N = len(nums1), len(nums2)\n        sum1, sum2 = 0, 0\n        i, j = 0, 0\n        res = 0\n        \n        while i < M and j < N:\n            if nums1[i] < nums2[j]:\n                sum1 += nums1[i]\n                i += 1\n            elif nums1[i] > nums2[j]:\n                sum2 += nums2[j]\n                j += 1\n            else:\n                res += max(sum1, sum2) + nums1[i]\n                i += 1\n                j += 1\n                sum1 = 0\n                sum2 = 0\n                \n        while i < M:\n            sum1 += nums1[i]\n            i += 1\n        while j < N:\n            sum2 += nums2[j]\n            j += 1\n        return (res + max(sum1, sum2)) % 1000000007\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        M,N = len(nums1),len(nums2)\n        i = 0\n        j = 0\n        res = sum1 = sum2 = 0\n        while i < M and j < N:\n            if nums1[i] < nums2[j]:\n                sum1 += nums1[i]\n                i += 1\n            elif nums1[i] > nums2[j]:\n                sum2 += nums2[j]\n                j += 1\n            else:\n                res += max(sum1,sum2) + nums1[i]\n                i += 1\n                j += 1\n                sum1 = sum2 = 0\n                \n        while i < M:\n            sum1 += nums1[i]\n            i += 1\n            \n        while j < N:\n            sum2 += nums2[j]\n            j += 1\n        return (res + max(sum1,sum2)) % (10 ** 9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        accu1 = list(accumulate(nums1))\n        accu2 = list(accumulate(nums2))\n        print(accu1)\n        ans  = i = j = 0\n        pi = pj = -1\n        while i<len(nums1) and j<len(nums2):\n            if nums1[i]<nums2[j]:\n                i+=1\n            elif nums1[i]>nums2[j]:\n                j+=1\n            else:\n                ans+=max(accu1[i], accu2[j]) if pi<0 else max(accu1[i]-accu1[pi], accu2[j]-accu2[pj]) \n                pi,pj,i,j = i,j,i+1,j+1\n        \n        ans+=max(accu1[-1], accu2[-1]) if pi<0 else max(accu1[-1]-accu1[pi], accu2[-1]-accu2[pj]) \n        \n        return ans % (10**9+7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        # [idxnums1,idxnums2,value]\n        changeSum = 0\n        partial1, partial2 = 0,0\n        i,j=0,0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                print((partial1,partial2))\n                changeSum = (changeSum + nums1[i] + max(partial1, partial2)) % (10**9 + 7)\n                i += 1\n                j += 1\n                partial1, partial2 = 0,0\n            elif nums1[i] < nums2[j]:\n                partial1 += nums1[i]\n                i += 1\n            else:\n                partial2 += nums2[j]\n                j += 1\n        while i < len(nums1):\n            partial1 += nums1[i]\n            i += 1\n        while j < len(nums2):\n            partial2 += nums2[j]\n            j += 1\n        changeSum = (changeSum + max(partial1, partial2)) % (10**9 + 7)\n            \n        return changeSum % (10**9 + 7)\n                \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        m = len(nums1)\n        n = len(nums2)\n        mod = 10**9+7\n        pre1 = [0] * (m+1)\n        pre2 = [0] * (n+1)\n        \n        for i in range(m):\n            pre1[i+1] = pre1[i] + nums1[i]\n        for i in range(n):\n            pre2[i+1] = pre2[i] + nums2[i]\n        \n        cm1 = []\n        cm2 = []\n        st = set()\n        d = {}\n        for i in range(m):\n            d[nums1[i]] = i\n        st1 = set(nums1)   \n        # print(st)\n        for i in range(n):\n            if nums2[i] in st1:\n                cm1.append(d[nums2[i]])\n                cm2.append(i)\n        ans = 0\n        # print(pre1,pre2,cm1,cm2)\n        for i in range(len(cm1)):\n            idx1 = cm1[i]\n            idx2 = cm2[i]\n            \n            if i == 0:\n                sm1 = pre1[idx1]\n                sm2 = pre2[idx2]\n            else:\n                sm1 = pre1[idx1] - pre1[cm1[i-1]+1]\n                sm2 = pre2[idx2] - pre2[cm2[i-1]+1]\n            ans += max(sm1,sm2)\n            ans %= mod\n        op1 = 0\n        op2 = 0\n        if len(cm1) and cm1[-1]+1 < m:\n            op1 = sum(nums1[cm1[-1]+1:])\n        if len(cm2) and cm2[-1]+1 < n:\n            op2 = sum(nums2[cm2[-1]+1:])\n        if not len(cm1):\n            return (max(sum(nums1),sum(nums2))) %mod\n        ans += max(op1,op2)\n        ans %= mod\n        return (ans+sum(nums1[i] for i in cm1)) % mod\n                \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        one = 0\n        two = 0\n        i = 0 \n        j = 0\n        while(i<len(nums1) and j<len(nums2)):\n            if(nums1[i]==nums2[j]):\n                one = two =  max(one,two)+nums1[i]\n                i+=1\n                j+=1\n            elif(nums1[i]>nums2[j]):\n                two+=nums2[j]\n                j+=1\n            else:\n                one+=nums1[i]\n                i+=1\n                \n        # print(i,j)\n        while(i<len(nums1)):\n            one+=nums1[i]\n            i+=1\n        while(j<len(nums2)):\n            two+=nums2[j]\n            j+=1\n            \n            \n        return max(one,two)%1000000007\n            \n            \n            \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        dp1 = [0]*(len(nums1)+1)\n        dp2 = [0]*(len(nums2)+1)\n        \n        dp1[-1] = 0\n        dp2[-1] = 0\n        \n        to1 = {}\n        to2 = {}\n        inds2 = {y: j for j, y in enumerate(nums2)}\n        for i, x in enumerate(nums1):\n            if x in inds2:\n                to2[i] = inds2[x]\n                to1[inds2[x]] = i\n        \n        # print(dp1, dp2, to2, to1)\n        \n        i = len(nums1)-1\n        j = len(nums2)-1\n        \n        while i >= 0 and j >= 0:\n            if i not in to2:\n                dp1[i] = nums1[i] + dp1[i+1]\n                i -= 1\n            elif j not in to1:\n                dp2[j] = nums2[j] + dp2[j+1]\n                j -= 1\n            else:\n                dp1[i] = dp2[j] = nums1[i] + max(dp1[i+1], dp2[j+1])\n                i -= 1\n                j -= 1\n        \n        # print(dp1, dp2)\n        while i >= 0:\n            dp1[i] = nums1[i] + dp1[i+1]\n            i -= 1\n                \n        while j >= 0:\n            dp2[j] = nums2[j] + dp2[j+1]\n            j -= 1\n        \n        # print(dp1, dp2)\n        \n        return max(dp1[0], dp2[0]) % (10**9 + 7)\n", "MOD = 1000000007\nclass Solution:\n    def maxSum(self, nums1, nums2):\n        sum1, sum2, res = 0, 0, 0\n        p1, p2 = 0, 0\n        while p1 <= len(nums1) - 1 and p2 <= len(nums2) - 1:\n            if nums1[p1] == nums2[p2]:\n                res += max(sum1, sum2) + nums1[p1]\n                sum1, sum2 = 0, 0\n                p1 += 1\n                p2 += 1\n            elif nums1[p1] < nums2[p2]:\n                sum1 += nums1[p1]\n                p1 += 1\n            else:\n                sum2 += nums2[p2]\n                p2 += 1\n        if p1 <= len(nums1) - 1:\n            sum1 += sum(nums1[p1:])\n        if p2 <= len(nums2) - 1:\n            sum2 += sum(nums2[p2:])\n        return (res + max(sum1, sum2)) % MOD", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        N1 = len(nums1)\n        N2 = len(nums2)\n        \n        dp1 = [0 for _ in range(N1 + 1)]\n        dp2 = [0 for _ in range(N2 + 1)]\n        \n        i = 1\n        j = 1\n        \n        while i < N1 + 1 and j < N2 + 1:\n            if nums1[i - 1] == nums2[j - 1]:\n                dp1[i] = max(dp1[i - 1], dp2[j - 1]) + nums1[i - 1]\n                dp2[j] = max(dp1[i - 1], dp2[j - 1]) + nums2[j - 1]\n                i += 1\n                j += 1\n            elif nums1[i - 1] < nums2[j - 1]:\n                dp1[i] = dp1[i - 1] + nums1[i - 1]\n                i += 1\n            else:\n                dp2[j] = dp2[j - 1] + nums2[j - 1]\n                j += 1\n            \n        while i < N1 + 1:\n            dp1[i] = dp1[i - 1] + nums1[i - 1]\n            i += 1\n            \n        while j < N2 + 1:\n            dp2[j] = dp2[j - 1] + nums2[j - 1]\n            j += 1\n            \n        return max(dp1[-1], dp2[-1]) % (10 ** 9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        p1 = p2 = 0\n        mx1 = 0 \n        mx2 = 0\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] == nums2[p2]:\n                mx1 = mx2 = max(mx1, mx2) + nums1[p1]\n                p1 += 1\n                p2 += 1\n            while p1 < len(nums1) and p2 < len(nums2) and nums1[p1] < nums2[p2]:\n                mx1 += nums1[p1]\n                p1 += 1\n            while p1 < len(nums1) and p2 < len(nums2) and nums2[p2] < nums1[p1]:\n                mx2 += nums2[p2]\n                p2 += 1\n            \n        while p1 < len(nums1):\n            mx1 += nums1[p1]\n            p1 += 1\n        while p2 < len(nums2):\n            mx2 += nums2[p2]\n            p2 += 1\n        return max(mx1,mx2) % (10**9+7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        '''\n        nums1 = [2,4,5,8,10], nums2 = [4,6,8,9]\n        \n        dp1:[30,28,23,18,10, 0]\n        dp2: [28,24,18,9, 0]\n        \n        dp1[i] = if nums1[i]==nums2[j]: max(nums1[i]+dp1[i+1], nums1[i]+dp2[j+1])\n                    else: nums1[i]+dp1[i+1]\n        (dp1[len(nums1)]=0)\n        dp2[i] = if nums1[j]==nums2[i]: max(nums1[i]+dp1[j+1], nums1[i]+dp2[i+1])\n        \n        i1, i2 = len(nums1)-1, len(nums2)-1\n        while i1>=0 and i2>=0:\n            if nums1[i1] == nums[i2]:\n                dp1[i1] = max(nums1[i1]+dp1[i1+1], nums1[i2]+dp2[i2+1])\n                i1-=1\n                i2-=1\n            elif nums1[i1] > nums[i2]:\n                dp1[i1] = nums1[i1]+dp1[i1+1]\n                i1-=1\n            else:\n                dp2[i2] = nums2[i2]+dp2[i2+1]\n                i2-=1\n        if i1>=0:\n            return max(sum()+dp1[i1+1], dp2[i2+1])\n            \n        '''\n        dp1 = [0 for _ in range(len(nums1)+1)]\n        dp2 = [0 for _ in range(len(nums2)+1)]\n        i1, i2 = len(nums1)-1, len(nums2)-1\n        while i1>=0 and i2>=0:\n            if nums1[i1] == nums2[i2]:\n                dp1[i1] = max(nums1[i1]+dp1[i1+1], nums2[i2]+dp2[i2+1])\n                dp2[i2] = max(nums1[i1]+dp1[i1+1], nums2[i2]+dp2[i2+1])\n                i1-=1\n                i2-=1\n            elif nums1[i1] > nums2[i2]:\n                dp1[i1] = nums1[i1]+dp1[i1+1]\n                i1-=1\n            else:\n                dp2[i2] = nums2[i2]+dp2[i2+1]\n                i2-=1\n        # print(dp1)\n        # print(dp2)\n        if i1>=0:\n            return max(sum(nums1[:i1+1])+dp1[i1+1], dp2[i2+1])%(10**9+7)\n        else:\n            return max(sum(nums2[:i2+1])+dp2[i2+1], dp1[i1+1])%(10**9+7)\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1, sum2 = 0, 0\n        index1, index2 = 0, 0\n        len1, len2 = len(nums1), len(nums2)\n        \n        while index1 < len1 or index2 < len2:\n            if index1 < len1 and (index2 == len2 or nums1[index1] < nums2[index2]):\n                sum1 += nums1[index1]\n                index1 += 1\n            elif index2 < len2 and (index1 == len1 or nums1[index1] > nums2[index2]):\n                sum2 += nums2[index2]\n                index2 += 1\n            else:\n                sum1 = sum2 = max(sum1, sum2) + nums1[index1]\n                index1 += 1\n                index2 += 1\n        \n        return max(sum1, sum2) % (10**9+7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1 = 0\n        sum2 = 0\n        i1 = len(nums1) - 1\n        i2 = len(nums2) - 1\n        paths = []\n        while i1 >= 0 and i2 >= 0:\n          if nums1[i1] > nums2[i2]:\n            sum1 += nums1[i1]\n            i1 -= 1\n          elif nums1[i1] < nums2[i2]:\n            sum2 += nums2[i2]\n            i2 -= 1\n          else:\n            paths.append((sum1 + nums1[i1], sum2 + nums1[i1]))\n            sum1 = sum2 = 0\n            i1 -= 1\n            i2 -= 1\n        if i1 >= 0:\n          paths.append((sum1 + sum(nums1[:i1+1]), sum2))\n        if i2 >= 0:\n          paths.append((sum1, sum2 + sum(nums2[:i2+1])))\n        \n        ans = 0\n        for l, r in paths:\n          ans += max(l, r)\n          ans %= 10**9 + 7\n        return ans      \n            \n\n        \n        # print(nums1)\n        # print(nums2)\n        # print('')\n        def _dp(ii, its1, val):\n          # print(ii, its1, val)\n          nums = nums1 if its1 else nums2\n          oums = nums2 if its1 else nums1\n          if ii == len(nums):\n            return val\n          # path.append((its1, nums[ii]))\n          if nums[ii] in oums:\n            ix = oums.index(nums[ii])\n            # path.append((not its1, nums[ii]))\n            opt = _dp(ix + 1, not its1, val + nums[ii])\n          else:\n            opt = 0\n          cur = _dp(ii + 1,     its1, val + nums[ii]) \n          return max([opt, cur])\n            \n        \n        return max([_dp(0, True, 0), _dp(0, False, 0)])\n      \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        MOD = 10**9 + 7.\n        # get the max array by intertweenin the two\n        def csums(nums):\n            arr = [None] * len(nums)\n            for i in range(len(nums)): \n                prev = 0 if i == 0 else arr[i-1]\n                arr[i] = prev + nums[i]\n            return arr\n        s1, s2 = csums(nums1), csums(nums2)\n        mp1 = {v: idx for idx, v in enumerate(nums1)}\n        mp2 = {v: idx for idx, v in enumerate(nums2)}\n        sps = sorted(set(mp1.keys()) & set(mp2.keys())) # switch points\n        ans = 0\n        if not sps: \n            ans =  max(s1[-1], s2[-1]) % MOD\n        else: \n            idx1 = idx2 = None\n            for idx, sp in enumerate(sps): \n                idx1, idx2 = mp1[sp], mp2[sp]\n                sum1 = s1[idx1] - (0 if idx == 0 else s1[mp1[sps[idx-1]]])\n                sum2 = s2[idx2] - (0 if idx == 0 else s2[mp2[sps[idx-1]]])\n                ans = (ans + max(sum1, sum2)) % MOD # can choose either one\n            \n            left1 = s1[-1] - s1[idx1]\n            left2 = s2[-1] - s2[idx2]\n            \n            ans += max(left1, left2)\n        return int(ans % MOD)\n\n            \n        \n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n            \n        \n            \n            \n            \n            \n        \n        \n        \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        intersecting_index=[]\n        \n        l=0\n        m=0\n        \n        while l<len(nums1) and m<len(nums2):\n            if nums1[l]==nums2[m]:\n                intersecting_index.append([l,m])\n                l+=1\n                m+=1\n            elif nums1[l]>nums2[m]:\n                m+=1\n            else:\n                l+=1\n        \n        prefix_1=[0 for i in range(len(nums1)+1)]\n        prefix_2=[0 for i in range(len(nums2)+1)]\n        for i in range(1,len(nums1)+1):\n            prefix_1[i]=prefix_1[i-1]+nums1[i-1]\n        for i in range(1,len(nums2)+1):\n            prefix_2[i]=prefix_2[i-1]+nums2[i-1]\n        \n        \n        ans=[]\n        prev_1=0\n        prev_2=0\n        for i in intersecting_index:\n            ans.append([prefix_1[i[0]+1]-prefix_1[prev_1] , prefix_2[i[1]+1]-prefix_2[prev_2]])\n            prev_1=i[0]+1\n            prev_2=i[1]+1\n        \n        ans.append([prefix_1[-1]-prefix_1[prev_1] , prefix_2[-1]-prefix_2[prev_2]])\n        \n        s=0\n        for i in ans:\n            s=(max(i[0],i[1])+s)%(pow(10,9)+7)\n        return s\n            \n        \n            \n", "class Solution:\n    def maxSum(self, l1: List[int], l2: List[int]) -> int:\n        last_p1 = 0\n        last_p2 = 0\n        p1 = 0\n        p2 = 0\n        sum_so_far = 0\n        while (p1 < len(l1) and p2 < len(l2) and last_p1 < len(l1) and last_p2 < len(l2)):\n            if l1[p1] < l2[p2]:\n                p1 += 1\n            elif l1[p1] > l2[p2]:\n                p2 += 1\n            else: # ==\n                sum_so_far += max(sum(l1[last_p1:p1]), sum(l2[last_p2:p2]))\n                sum_so_far += l1[p1]\n                last_p1 = p1 + 1\n                last_p2 = p2 + 1\n                p1 += 1\n                p2 += 1\n\n        if l1[-1] != l2[-1]:\n            sum_so_far += max(sum(l1[last_p1:]), sum(l2[last_p2:]))\n        return sum_so_far % 1000000007", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        mod=10**9+7\n        l1=[]\n        d={}\n        d1={}\n        d2={}\n        \n        for i in nums1:\n            d[i]=1\n        for i in nums2:\n            d[i]=d.get(i,0)+1\n        for i in d:\n            if d[i]==2:\n                l1.append(i)\n                \n        l1.sort()\n        n1=len(l1)+1\n        l1.insert(0,0)\n        \n        dp=[[0 for j in range(2)] for i in range(n1+1)]\n        pref1=[0]*(len(nums1)+1)\n        pref2=[0]*(len(nums2)+1)\n        \n        for i in range(len(nums1)):\n            d1[nums1[i]]=i\n            pref1[i+1]=pref1[i]+nums1[i]\n        \n        for i in range(len(nums2)):\n            d2[nums2[i]]=i\n            pref2[i+1]=pref2[i]+nums2[i]\n        #print(d1,d2)\n        d1[0]=0\n        d2[0]=0\n        for i in range(1,n1):\n            \n            dp[i][0]=max(dp[i-1][0],dp[i-1][1])+pref1[d1[l1[i]]+1]-pref1[d1[l1[i-1]]]-l1[i-1]\n            dp[i][1]=max(dp[i-1][0],dp[i-1][1])+pref2[d2[l1[i]]+1]-pref2[d2[l1[i-1]]]-l1[i-1]\n            #print(123,l1[i],dp[i][0],dp[i][1])\n        #print(l1)\n        return (max(dp[n1-1][0],dp[n1-1][1])+max(pref1[len(nums1)]-pref1[d1[l1[-1]]]-l1[-1],pref2[len(nums2)]-pref2[d2[l1[-1]]]-l1[-1]))%mod", "from functools import lru_cache\nclass Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        d = {\n            0: {x:i for i, x in enumerate(nums1)},\n            1: {x:i for i, x in enumerate(nums2)},\n        }\n        arrs = [nums1, nums2]\n        MOD = 10 ** 9 + 7\n\n        @lru_cache(None)\n        def dp(i, j):\n            res = 0\n            while j < len(d[i]):\n                val = arrs[i][j]\n                if val not in d[1-i]:\n                    res += val\n                else:\n                    k = d[1-i][val]\n                    res += val + max(dp(1-i, k+1), dp(i, j+1)) \n                    return res\n                j += 1\n            return res\n        return max(dp(0, 0), dp(1, 0)) % MOD", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        # Represents the max value (looking ahead) from this node \n        dp1 = [0 for _ in range(len(nums1))] + [0]\n        dp2 = [0 for _ in range(len(nums2))] + [0]\n        \n        nums1.append(0)\n        nums2.append(0)\n        \n        for i in range(len(nums1)-2, -1, -1):\n            dp1[i] = (dp1[i+1] + nums1[i+1])\n            \n        for i in range(len(nums2)-2, -1, -1):\n            dp2[i] = (dp2[i+1] + nums2[i+1])\n            \n        i, j = len(nums1)-2, len(nums2)-2\n        \n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                dp1[i] = (nums1[i+1] + dp1[i+1])\n                i -= 1\n            elif nums1[i] < nums2[j]:\n                dp2[j] = (nums2[j+1] + dp2[j+1])\n                j -= 1\n            else:\n                # Find which one has the greater parent\n                max_value = max(dp1[i+1] + nums1[i+1], dp2[j+1] + nums2[j+1])\n                dp1[i] = max_value\n                dp2[j] = max_value\n                    \n                j -= 1\n                i -= 1\n                \n        while i >= 0:\n            dp1[i] = (nums1[i+1] + dp1[i+1])\n            i -= 1\n            \n        while j >= 0:\n            dp2[j] = (nums2[j+1] + dp2[j+1])\n            j -= 1\n            \n        return max((dp1[0] + nums1[0]) % (10**9 + 7), (dp2[0] + nums2[0]) % (10**9 + 7)) ", "class Solution:\n    def maxSum(self, A, B):\n        i, j, n, m = 0, 0, len(A), len(B)\n        a, b, mod = 0, 0, 10**9 + 7\n        while i < n or j < m:\n            if i < n and (j == m or A[i] < B[j]):\n                a += A[i]\n                i += 1\n            elif j < m and (i == n or A[i] > B[j]):\n                b += B[j]\n                j += 1\n            else:\n                a = b = max(a, b) + A[i]\n                i += 1\n                j += 1\n        return max(a, b) % mod\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        H1={}\n        H2={}\n        for i in range(len(nums1)):\n            H1[nums1[i]]=i\n        for i in range(len(nums2)):\n            H2[nums2[i]]=i\n    \n        S1=set(H1.keys())\n        S2=set(H2.keys())\n        C=sorted(list(S1.intersection(S2)))\n        if len(C)==0:\n            return max(sum(nums1),sum(nums2))\n#        print (C)\n        ind1=ind2=0\n        n1=[]\n        n2=[]\n        n=0\n        for i in C:            \n            i1=H1[i]+1\n            i2=H2[i]+1\n            n+=max(sum(nums1[ind1:i1]),sum(nums2[ind2:i2])) \n\n            n1.append(sum(nums1[ind1:H1[i]+1]))\n            n2.append(sum(nums2[ind2:H2[i]+1]))\n#            print(n1,n2)\n            ind1=H1[i]+1\n            ind2=H2[i]+1\n        n1.append(sum(nums1[ind1:]))\n        n2.append(sum(nums2[ind2:]))\n        n+=max(sum(nums1[ind1:]),sum(nums2[ind2:]))\n#        print (n1,n2)        \n        return n % 1000000007        \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        N = len(nums1)\n        M = len(nums2)\n        \n        def get_pos(nums):\n            pos = defaultdict(lambda: -1)\n            for i, x in enumerate(nums):\n                pos[x] = i\n            return pos\n                \n        pos1 = get_pos(nums1)\n        pos2 = get_pos(nums2)\n        \n        dp1 = [0] * (N + 1)\n        dp2 = [0] * (M + 1)\n        i, j = N - 1, M - 1\n        while i >= 0 or j >= 0:\n            while i >= 0 and pos2[nums1[i]] < 0:\n                dp1[i] = nums1[i] + dp1[i + 1]\n                i -= 1\n                \n            while j >= 0 and pos1[nums2[j]] < 0:\n                dp2[j] = nums2[j] + dp2[j + 1]\n                j -= 1\n                \n            if i >= 0:\n                p = pos2[nums1[i]]\n                dp1[i] = nums1[i] + max(dp1[i + 1], dp2[p + 1])\n                i -= 1\n                \n            if j >= 0:\n                p = pos1[nums2[j]]\n                dp2[j] = nums2[j] + max(dp2[j + 1], dp1[p + 1])\n                j -= 1\n        \n        res = max(dp1[0], dp2[0])\n        return res % (10 ** 9 + 7)\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        ret = s1 = s2 = 0\n        n1, n2 = len(nums1), len(nums2)\n        i = j = 0\n        while i < n1 or j < n2 :\n            if i == n1 :\n                s2 += nums2[j]\n                j += 1\n            elif j == n2 :\n                s1 += nums1[i]\n                i += 1\n            else :\n                if nums1[i] < nums2[j] :\n                    s1 += nums1[i]\n                    i += 1\n                elif nums1[i] > nums2[j] :\n                    s2 += nums2[j]\n                    j += 1\n                else :\n                    ret += max(s1, s2) + nums1[i]\n                    s1 = s2 = 0\n                    i += 1\n                    j += 1\n        \n        ret += max(s1, s2)\n        return ret % 1000000007", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        lens1, lens2 = len(nums1), len(nums2)\n        dp1 = [0 for _ in range(lens1 + 1)]     \n        dp2 = [0 for _ in range(lens2 + 1)]\n        i, j = 1, 1\n        while i < lens1 + 1 and j < lens2 + 1:\n            if nums1[i-1] == nums2[j-1]:\n                dp1[i] = max(dp1[i-1], dp2[j-1]) + nums1[i-1]\n                dp2[j] = max(dp1[i-1], dp2[j-1]) + nums2[j-1]\n                i += 1\n                j += 1\n            elif nums1[i-1] < nums2[j-1]:\n                dp1[i] = dp1[i-1] + nums1[i-1]\n                i += 1\n            else:\n                dp2[j] = dp2[j-1] + nums2[j-1]\n                j += 1\n        while i < lens1 + 1:\n            dp1[i] = dp1[i-1] + nums1[i-1]\n            i += 1\n        while j < lens2 + 1:\n            dp2[j] = dp2[j-1] + nums2[j-1]\n            j += 1\n\n        return max(dp1[-1], dp2[-1]) % (10**9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        len1=len(nums1)\n        len2=len(nums2)\n        dp1=[0 for i in range(len1+1)]\n        dp2=[0 for i in range(len2+1)]\n        i,j=1,1\n        while(i<len1+1 and j<len2+1):\n            if nums1[i-1]==nums2[j-1]:\n                dp1[i]=nums1[i-1]+max(dp1[i-1],dp2[j-1])\n                dp2[j]=nums2[j-1]+max(dp1[i-1],dp2[j-1])\n                i+=1\n                j+=1\n            elif nums1[i-1]<nums2[j-1]:\n                dp1[i]=nums1[i-1]+dp1[i-1]\n                i+=1\n            else:\n                dp2[j]=nums2[j-1]+dp2[j-1]\n                j+=1\n        while(i<len1+1):\n            dp1[i]=nums1[i-1]+dp1[i-1]\n            i+=1\n        while(j<len2+1):\n            dp2[j]=nums2[j-1]+dp2[j-1]\n            j+=1\n        return max(dp1[-1],dp2[-1])%(10**9+7)\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        def getSum(i, nums1, j, nums2):\n            total = 0\n            while (i < len(nums1)):\n                total += nums1[i]\n                i += 1\n                while (i < len(nums1) and j < len(nums2) and nums2[j] < nums1[i]):\n                    j += 1\n\n                if i < len(nums1) and j < len(nums2) and nums1[i] == nums2[j]:\n                    if nums1[i] not in dp:\n                        dp[nums1[i]] = max(getSum(i, nums1, j, nums2), getSum(j, nums2, i, nums1))\n                    return total + dp[nums1[i]] \n\n            return total\n\n        dp = {}\n        return max(getSum(0, nums1, 0, nums2), getSum(0, nums2, 0, nums1)) % (10**9 + 7)\n", "MOD = 1000000007\nclass Solution:\n    def maxSum(self, nums1, nums2):\n        sum1, sum2, res = 0, 0, 0\n        p1, p2 = 0, 0\n        while p1 <= len(nums1) - 1 or p2 <= len(nums2) - 1:\n            if p1 <= len(nums1) - 1 and p2 <= len(nums2) - 1 and nums1[p1] == nums2[p2]:\n                res = (res + max(sum1, sum2) + nums1[p1]) % MOD\n                sum1, sum2 = 0, 0\n                p1 += 1\n                p2 += 1\n            elif p2 > len(nums2) - 1 or (p1 <= len(nums1) - 1 and nums1[p1] < nums2[p2]):\n                sum1 = sum1 + nums1[p1]\n                p1 += 1\n            else:\n                sum2 = sum2 + nums2[p2]\n                p2 += 1\n\n        return (res + max(sum1, sum2)) % MOD", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        \n        d1 = {}\n        d2 = {}\n        \n        t1 = {}\n        t2 = {}\n        \n        l1 = len(nums1)\n        l2 = len(nums2)\n        \n        \n        for i in range(l1):\n            d1[nums1[i]] = i\n            \n        for i in range(l2):\n            d2[nums2[i]] = i\n            \n            \n        def runList1(i):\n            \n            if i == l1:\n                return 0           \n            \n            if i in t1:\n                return t1[i]\n            \n            maxList2 = 0\n                        \n            if i + 1 < l1 and  nums1[i+1] in d2:\n                maxList2 = runList2(d2[nums1[i+1]])\n                \n            result = max(runList1(i+1), maxList2) + nums1[i]\n            t1[i] = result\n            return result\n        \n        \n        def runList2(i):\n            if i == l2:\n                return 0\n            \n            if i in t2:\n                return t2[i]\n            \n            maxList1 = 0\n                       \n            \n            if i+1 < l2 and nums2[i+1] in d1:\n                maxList1 = runList1(d1[nums2[i+1]])\n                            \n            result = max(runList2(i+1), maxList1) + nums2[i]\n            \n            t2[i] = result\n            \n            \n            return result\n             \n        value = max(runList1(0), runList2(0)) \n        \n        return value % (10**9 + 7)\n        \n        \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        sum1 = 0\n        sum2 = 0\n        s1 = 0\n        s2 = 0\n        total = 0\n        # [2 4 5 8 10]\n        # [4 6 8 9]\n        l1 = len(nums1)\n        l2 = len(nums2)\n        while s1 < l1 and s2 < l2:\n            if nums1[s1] < nums2[s2]:\n                sum1 += nums1[s1]\n                s1 += 1\n            elif nums1[s1] > nums2[s2]:\n                sum2 += nums2[s2]\n                s2 += 1\n            else:\n                total += max(sum1, sum2) + nums1[s1]\n                sum1 = sum2 = 0\n                s1 += 1\n                s2 += 1\n        if s1 < l1:\n            while s1 < l1:\n                sum1 += nums1[s1]\n                s1 += 1\n            total += max(sum1, sum2)\n        if s2 < l2:\n            while s2 < l2:\n                sum2 += nums2[s2]\n                s2 += 1\n            total += max(sum1, sum2)\n        return total % ((10 ** 9) + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        n1,n2 = nums1,nums2\n        s,t,sum1,sum2 = len(n1)-1,len(n2)-1,0,0\n        ans = 0\n        while s >= 0 and t >= 0:\n            if n1[s] > n2[t]:\n                sum1 += n1[s]\n                s -= 1\n            elif n1[s] < n2[t]:\n                sum2 += n2[t]\n                t -= 1\n            else:\n                ans += max(sum1+n1[s],sum2+n1[s])\n                sum1 = sum2 = 0\n                s -= 1\n                t -= 1\n        if s >= 0: ans += max(sum1+sum(n1[:s+1]),sum2)\n        if t >= 0: ans += max(sum1,sum2+sum(n2[:t+1]))\n        return ans % (10**9+7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        a, b = nums1, nums2\n        m, n = len(a), len(b)\n        p1 = {x:i for i, x in enumerate(a)}\n        p2 = {x:i for i, x in enumerate(b)}\n        \n        @lru_cache(None)\n        def dp(i, use_a):\n            if use_a:\n                if i == m:\n                    return 0\n                ans = a[i] + dp(i + 1, True)\n                if a[i] in p2:\n                    j = p2[a[i]] + 1\n                    ans = max(ans, a[i] + dp(j, False))\n            else:\n                if i == n:\n                    return 0\n                ans = b[i] + dp(i +1, False)\n                if b[i] in p1:\n                    j = p1[b[i]] + 1\n                    ans = max(ans, b[i] + dp(j, True))\n            return ans \n        \n        return max(dp(0, True), dp(0, False)) % (10 ** 9 + 7)\n                \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        n1 = len(nums1)\n        n2 = len(nums2)\n        M = 1000000007\n        dp1 = [0] * (n1+1)\n        dp2 = [0] * (n2+1)\n        i1 = i2 = 0\n        while i1 < n1 and i2 < n2:\n            if nums1[i1] < nums2[i2]:\n                dp1[i1+1] = dp1[i1] + nums1[i1]\n                i1 += 1\n            elif nums1[i1] > nums2[i2]:\n                dp2[i2+1] = dp2[i2] + nums2[i2]\n                i2 += 1\n            else:\n                dp1[i1+1] = dp2[i2+1] = max(dp1[i1] + nums1[i1], dp2[i2] + nums2[i2])\n                i1 += 1\n                i2 += 1\n        while i1 < n1:\n            dp1[i1+1] = dp1[i1] + nums1[i1]\n            i1 += 1\n        while i2 < n2:\n            dp2[i2+1] = dp2[i2] + nums2[i2]\n            i2 += 1\n        return max(dp1[n1], dp2[n2]) % M\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        memo1 = defaultdict(lambda: 0)\n        memo2 = defaultdict(lambda: 0)\n        nums1.append(0)\n        nums2.append(0)\n        \n        i = len(nums1) - 2\n        j = len(nums2) - 2\n        while i >= 0 or j >= 0:\n            n1 = nums1[i] if i >= 0 else 0\n            n2 = nums2[j] if j >= 0 else 0\n            \n            if n1 == n2:\n                memo1[n1] = max(n1 + memo1[nums1[i+1]], n2 + memo2[nums2[j+1]])\n                memo2[n2] = memo1[n1]\n                i -= 1\n                j -= 1\n            elif n1 > n2:\n                memo1[n1] = max(n1 + memo1[nums1[i+1]], memo2[n1])\n                i -= 1\n            else:\n                memo2[n2] = max(n2 + memo2[nums2[j+1]], memo1[n2])\n                j -= 1\n        \n        return max(memo1[nums1[0]], memo2[nums2[0]]) % int(1e9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        l1 = len(nums1)\n        l2 = len(nums2)\n        index1 = 0\n        index2 = 0\n        score1 = 0\n        score2 = 0\n        maxScore = 0\n        while index1 < l1 and  index2 < l2:\n            n1 = nums1[index1]\n            n2 = nums2[index2]\n            if n1 == n2:\n                score1 += n1\n                score2 += n2\n                if score1 < score2:\n                    maxScore += score2\n                else:\n                    maxScore += score1\n                score1 = 0\n                score2 = 0\n                index1 += 1\n                index2 += 1\n            elif n1 < n2:\n                 score1 += n1\n                 index1 += 1\n            else:\n                score2 += n2\n                index2 += 1\n        for i in range(index1,l1):\n            score1 += nums1[i]\n        for i in range(index2,l2):\n            score2 += nums2[i]\n\n        if score1 < score2:\n            maxScore += score2\n        else:\n            maxScore += score1\n\n        return maxScore%(10**9+7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        n1 = len(nums1)\n        n2 = len(nums2)\n        \n        a1 = [-1 for _ in range(n1)]\n        a2 = [-1 for _ in range(n2)]\n        \n        i, j = 0, 0\n        while i < n1 and j < n2:\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                a1[i] = j\n                a2[j] = i\n                i += 1\n                j += 1\n        \n        cache1 = {}\n        cache2 = {}\n        \n        def process1(idx):\n            if idx == n1:\n                return 0\n            if not idx in cache1:\n                ans = 0\n                if a1[idx] == -1:\n                    ans = nums1[idx] + process1(idx+1)\n                else:\n                    ans = nums1[idx] + max(process1(idx+1), process2(a1[idx]+1))\n                cache1[idx] = ans\n            return cache1[idx]\n        \n        def process2(idx):\n            if idx == n2:\n                return 0\n            if not idx in cache2:\n                ans = 0\n                if a2[idx] == -1:\n                    ans = nums2[idx] + process2(idx+1)\n                else:\n                    ans = nums2[idx] + max(process2(idx+1), process1(a2[idx]+1))\n                cache2[idx] = ans\n            return cache2[idx]\n\n        return max(process1(0), process2(0)) % (10 ** 9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        # [idxnums1,idxnums2,value]\n        changeSum = 0\n        partialSums = [[0,0]]\n        i,j,k=0,0,0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                changeSum = (changeSum + nums1[i]) % (10**9 + 7)\n                i += 1\n                j += 1\n                partialSums.append([0,0])\n            elif nums1[i] < nums2[j]:\n                partialSums[-1][0] += nums1[i]\n                i += 1\n            else:\n                partialSums[-1][1] += nums2[j]\n                j += 1\n        while i < len(nums1):\n            partialSums[-1][0] += nums1[i]\n            i += 1\n        while j < len(nums2):\n            partialSums[-1][1] += nums2[j]\n            j += 1\n            \n        print(changeSum)\n        print(partialSums)\n        for i in partialSums:\n            changeSum += max(i)\n        return changeSum % (10**9 + 7)\n                \n", "'''\nhttps://leetcode.com/problems/get-the-maximum-score/\n\n\naproach 1: recursion brute force\n  max(i+1, arr2[]) time O(n^n) space O(1)\n \napproach 2: dp time O(n) space(n)\n\n\n'''\nclass Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n      # dictonary 1 {val : index}\n        dict1 = {}\n        dict2 = {}\n\n        for i in range(len(nums1)):\n            dict1[nums1[i]] = i\n\n        # dictonary 2 {val : index}\n        for i in range(len(nums2)):\n            dict2[nums2[i]] = i\n\n        dp1 = [0 for _ in nums1]\n        dp2 = [0 for _ in nums2]\n      \n        def sol(index, curr):\n            if curr == 1:\n                if index == len(nums1):\n                    return 0\n                if not dp1[index]:\n                    if nums1[index] in dict2:\n                        indx2 = dict2[nums1[index]]\n                        dp1[index] = max(sol(index+1, curr), sol(indx2+1, 2))  + nums1[index]\n                    else:\n                        dp1[index] = sol(index+1, curr)  + nums1[index]\n\n\n                return dp1[index] \n        \n            else:\n                if index == len(nums2):\n                    return 0\n                if not dp2[index]:\n                    if nums2[index] in dict1:\n                        indx2 = dict1[nums2[index]]\n                        dp2[index] = max(sol(index+1, curr), sol(indx2+1, 1)) + nums2[index]\n                    else:\n                        dp2[index] = sol(index+1, curr) + nums2[index]\n\n                return dp2[index]\n        \n        sol(0,1)\n\n        \n        sol(0,2)\n        \n\n        return max(dp1[0], dp2[0]) % (10**9 + 7)\n\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        if len(nums1)==0 or len(nums2)==0:\n            return sum(nums2)+sum(nums1)\n        \n        n1,n2 = nums1,nums2\n        s,t,sum1,sum2 = len(n1)-1,len(n2)-1,0,0\n        ans = 0\n        while s >= 0 and t >= 0:\n            if n1[s] > n2[t]:\n                sum1 += n1[s]\n                s -= 1\n            elif n1[s] < n2[t]:\n                sum2 += n2[t]\n                t -= 1\n            else:\n                ans += max(sum1+n1[s],sum2+n1[s])\n                sum1 = sum2 = 0\n                s -= 1\n                t -= 1\n        if s >= 0: ans += max(sum1+sum(n1[:s+1]),sum2)\n        if t >= 0: ans += max(sum1,sum2+sum(n2[:t+1]))\n        return ans % (10**9+7)", "class Solution:\n    def maxSum(self, arra: List[int], arrb: List[int]) -> int:\n        m, n = len(arra), len(arrb)\n        dica = {a: i for i, a in enumerate(arra)}\n        dicb = {b: i for i, b in enumerate(arrb)}\n        dpa, dpb = {}, {}\n        \n        def go(i, f):\n            arr1, arr2 = arra, arrb\n            dic1, dic2 = dica, dicb\n            dp1, dp2 = dpa, dpb\n            if not f:\n                arr1, arr2 = arr2, arr1\n                dic1, dic2 = dic2, dic1\n                dp1, dp2 = dp2, dp1\n            a = arr1[i]\n            d = a + (dp1[arr1[i-1]] if i > 0 else 0)\n            if a in dic2 and dic2[a] > 0:\n                d = max(d, a+dp2[arr2[dic2[a]-1]])\n            dp1[a] = d\n        \n        i, j = 0, 0\n        while i < m and j < n:\n            if arra[i] <= arrb[j]:\n                go(i, True)\n                i += 1\n            else:\n                go(j, False)\n                j += 1\n        \n        while i < m:\n            go(i, True)\n            i += 1\n        while j < n:\n            go(j, False)\n            j += 1\n        return max(dpa[arra[-1]], dpb[arrb[-1]]) % (1000000007)\n", "# 1537. Get the Maximum Score\n\nfrom math import inf\n\ndef mix (A, B):\n    ans = []\n    i, j = 0, 0\n    while i < len (A) or j < len (B):\n        if i == len (A):   choice = 2\n        elif j == len (B): choice = 1\n        elif A[i] < B[j]:  choice = 1\n        elif A[i] > B[j]:  choice = 2\n        else:              choice = 3\n\n        if choice == 1:\n            ans.append ((A[i], choice))\n            i += 1\n        elif choice == 2:\n            ans.append ((B[j], choice))\n            j += 1\n        elif choice == 3:\n            ans.append ((A[i], choice))\n            i, j = i+1, j+1\n    return ans\n\ndef find_max (C, init):\n    max0, max1 = -inf, -inf\n    for i, (val, branches) in enumerate (C):\n        if val == init:\n            if branches == 1:\n                new0, new1 = val, -inf\n            elif branches == 2:\n                new0, new1 = -inf, val\n            else:\n                new0, new1 = val, val\n        else:\n            if branches == 1:\n                new0, new1 = max0 + val, max1\n            elif branches == 2:\n                new0, new1 = max0, max1 + val\n            elif branches == 3:\n                new0, new1 = max (max0, max1) + val, max (max0, max1) + val\n        max0, max1 = new0, new1\n    return max (max0, max1)\n\ndef find_max_score (A, B):\n    C = mix (A, B)\n    return max (find_max (C, A[0]), find_max (C, B[0]))\n\nclass Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        return find_max_score(nums1, nums2) % (10**9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        M, N = len(nums1), len(nums2)\n        sum1, sum2 = 0, 0\n        i, j = 0, 0\n        res = 0\n        while i < M and j < N:\n            if nums1[i] < nums2[j]:\n                sum1 += nums1[i]\n                i += 1\n            elif nums1[i] > nums2[j]:\n                sum2 += nums2[j]\n                j += 1\n            else:\n                res += max(sum1, sum2) + nums1[i]\n                i += 1\n                j += 1\n                sum1 = 0\n                sum2 = 0\n                \n        while i < M:\n            sum1 += nums1[i]\n            i += 1\n        while j < N:\n            sum2 += nums2[j]\n            j += 1\n        return (res + max(sum1, sum2)) % 1000000007\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        matrix = []\n        matrix.append(nums1[:])\n        matrix.append(nums2[:])\n        dics = []\n        dics.append({num: i for i, num in enumerate(nums1)})\n        dics.append({num: i for i, num in enumerate(nums2)})\n        sys.setrecursionlimit(10**6) \n        @lru_cache(None)\n        def dfs(row, index):\n            if index >= len(matrix[row]):\n                return 0\n            cur = matrix[row][index]\n            res = cur + dfs(row, index+1)\n            if cur in dics[1-row]:\n                res = max(res, cur + dfs(1-row, dics[1-row][cur] + 1))\n            return res\n        mod = 10 ** 9 + 7\n        return max(dfs(0, 0), dfs(1, 0)) % mod", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        \n        \n        @lru_cache(None)    \n        def dp(idx1, idx2, top: bool):\n            # print(idx1, idx2, top)\n            \n            if top:\n                if idx1 < len(nums1):\n                    while idx2 < len(nums2) and nums2[idx2] < nums1[idx1]:\n                        idx2 += 1\n                    if idx2 >= len(nums2):\n                        return sum(nums1[idx1:])\n                    if nums1[idx1] == nums2[idx2]:\n                        return nums1[idx1] + max(dp(idx1+1, idx2+1, True), dp(idx1+1, idx2+1, False))\n                    else:\n                        return nums1[idx1] + dp(idx1+1, idx2, True)\n                else:\n                    return sum(nums1[idx1:])\n            else:\n                if idx2 < len(nums2):\n                    while idx1 < len(nums1) and nums1[idx1] < nums2[idx2]:\n                        idx1 += 1\n                    if idx1 >= len(nums1):\n                        return sum(nums2[idx2:])\n                    if nums1[idx1] == nums2[idx2]:\n                        return nums2[idx2] + max(dp(idx1+1, idx2+1, True), dp(idx1+1, idx2+1, False))\n                    else:\n                        return nums2[idx2] + dp(idx1, idx2+1, False)\n                else:\n                    return sum(nums2[idx2:])\n                \n        # for i in range(len(nums1)):\n        #     for j in range(len(nums2)):\n        #         for top in [True, False]:\n        #             print(i,j,top, dp(i,j,top))\n                    \n        return max(dp(0,0,True), dp(0,0,False)) % (10**9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        rev1 = {v:k for k, v in enumerate(nums1)}\n        rev2 = {v:k for k, v in enumerate(nums2)}\n        \n        def dp(val, memo):\n            if val in memo:\n                return memo[val]\n            ans = 0\n            if val in rev1:\n                ans = val\n                if rev1[val] < len(nums1) -1:\n                    ans = max(ans, dp(nums1[rev1[val] + 1], memo) + val)\n            if val in rev2:\n                ans = max(ans, val)\n                if rev2[val] < len(nums2) -1:\n                    ans = max(ans, dp(nums2[rev2[val] + 1], memo) + val)\n            ans = ans\n            memo[val] = ans\n            return ans\n        memo = {}\n        return max(dp(nums1[0], memo), dp(nums2[0], memo)) %(1000000007)", "class Solution:\n            \n    \n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        def f(i , p) :\n            \n            if ( p == 0 and i >= len(nums1) ) or ( p == 1 and i >= len(nums2) ) :\n                return 0\n            \n            if (i , p) in dp :\n                return dp[i , p]\n            \n            ans = f(i + 1 , p)\n            \n            if p == 0 :\n                if  nums1[i] in b :\n                    ans = max(ans , f(b[nums1[i]] + 1 , 1-p))\n            \n            else :\n                if nums2[i] in a :\n                    ans = max(ans , f(a[nums2[i]] + 1 , 1-p))\n                \n            dp[i , p] = ans + ( nums1[i] if p == 0 else nums2[i] )\n            \n            return dp[i,p]\n        \n        a , b , dp = {} , {} , {}\n        for i , j in enumerate(nums1) :\n            a[j] = i\n            \n        for i , j in enumerate(nums2) :\n            b[j] = i\n            \n        return max(f(0 , 0) , f(0 , 1))%(10**9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        @lru_cache(None)    \n        def dp(idx1, idx2, top: bool):\n            \n            if top:\n                if idx1 < len(nums1):\n                    while idx2 < len(nums2) and nums2[idx2] < nums1[idx1]:\n                        idx2 += 1\n                    if idx2 >= len(nums2):\n                        return sum(nums1[idx1:])\n                    if nums1[idx1] == nums2[idx2]:\n                        return nums1[idx1] + max(dp(idx1+1, idx2+1, True), dp(idx1+1, idx2+1, False))\n                    else:\n                        return nums1[idx1] + dp(idx1+1, idx2, True)\n                else:\n                    return sum(nums1[idx1:])\n            else:\n                if idx2 < len(nums2):\n                    while idx1 < len(nums1) and nums1[idx1] < nums2[idx2]:\n                        idx1 += 1\n                    if idx1 >= len(nums1):\n                        return sum(nums2[idx2:])\n                    if nums1[idx1] == nums2[idx2]:\n                        return nums2[idx2] + max(dp(idx1+1, idx2+1, True), dp(idx1+1, idx2+1, False))\n                    else:\n                        return nums2[idx2] + dp(idx1, idx2+1, False)\n                else:\n                    return sum(nums2[idx2:])\n                    \n        return max(dp(0,0,True), dp(0,0,False)) % (10**9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        KMAX = 10 ** 9 + 7\n        i1, i2 = 0, 0\n        N1, N2 = len(nums1), len(nums2)\n        res = 0\n        total1, total2 = 0, 0\n        while i1 < N1 or i2 < N2:\n            if i1 == N1:\n                total2 += nums2[i2]\n                i2 += 1\n                continue\n            if i2 == N2:\n                total1 += nums1[i1]\n                i1 += 1\n                continue\n            if nums1[i1] == nums2[i2]:\n                res += nums1[i1] + max(total1, total2)\n                i1 += 1\n                i2 += 1\n                total1, total2 = 0, 0\n            elif nums1[i1] < nums2[i2]:\n                total1 += nums1[i1]\n                i1 += 1\n            else:\n                total2 += nums2[i2]\n                i2 += 1\n        res += max(total1, total2)\n        return res % KMAX        ", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        M,N = len(nums1),len(nums2)\n        i = 0\n        j = 0\n        sum1,sum2,res = 0,0,0\n        while i < M and j < N:\n            if nums1[i] < nums2[j]:\n                sum1 += nums1[i]\n                i += 1\n            elif nums1[i] > nums2[j]:\n                sum2 += nums2[j]\n                j += 1\n            else:\n                res += max(sum1,sum2) + nums1[i]\n                i += 1\n                j += 1\n                sum1 = sum2 = 0\n                \n        while i < M:\n            sum1 += nums1[i]\n            i += 1\n        while j < N:\n            sum2 += nums2[j]\n            j += 1\n        return (res + max(sum1,sum2)) % (10 ** 9 + 7)\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        dp1=[0 for i in range(len(nums1)+1)]\n        dp2=[0 for i in range(len(nums2)+1)]\n        i=1\n        j=1\n        while i<len(nums1)+1 and j<len(nums2)+1:\n            if nums1[i-1]==nums2[j-1]:\n                dp1[i]=max(dp1[i-1],dp2[j-1])+nums1[i-1]\n                dp2[j]=max(dp1[i-1],dp2[j-1])+nums2[j-1]\n                i+=1\n                j+=1\n                \n            elif nums1[i-1]<nums2[j-1]:\n                dp1[i]=dp1[i-1]+nums1[i-1]\n                i+=1\n            else:\n                dp2[j]=dp2[j-1]+nums2[j-1]\n                j+=1\n        while i<len(nums1)+1:\n            dp1[i]=dp1[i-1]+nums1[i-1]\n            i+=1\n            \n        while j<len(nums2)+1:\n            dp2[j]=dp2[j-1]+nums2[j-1]\n            j+=1\n        return max(dp1[-1],dp2[-1]) % (10**9+7)        ", "class Solution:\n    def maxSum(self, x: List[int], y: List[int]) -> int:\n        def f(i,p):\n            if (p==0 and i>=len(x)) or (p==1 and i>=len(y)):return 0\n            if (i,p) in dp:return dp[i,p]\n            ans=f(i+1,p)\n            if p==0:\n                if x[i] in b :ans=max(f(b[x[i]]+1,1-p),ans)\n            else:\n                if y[i] in a:ans=max(f(a[y[i]]+1,1-p),ans)\n            dp[i,p]=ans+(x[i] if p==0 else y[i])\n            return dp[i,p]\n        a,b,dp={},{},{}\n        for j,i in enumerate(x):a[i]=j\n        for j,i in enumerate(y):b[i]=j\n        return max(f(0,0),f(0,1))%(10**9+7)", "class Solution:\n    def maxSum(self, A: List[int], B: List[int]) -> int:\n        \n        g = collections.defaultdict(list)\n        \n        for i in range(len(A)-1):\n            g[A[i]].append(A[i+1])  \n        for i in range(len(B)-1):\n            g[B[i]].append(B[i+1])\n        \n        g[A[-1]]\n        g[B[-1]]\n\n        dp = collections.defaultdict(int)\n        \n        for node in sorted(g, reverse=True):\n            \n            dp[node] = node\n            if g[node]:\n                dp[node] += max(dp[nei] for nei in g[node])\n            \n        return max(dp.values()) % (10**9 + 7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        self.num1_idx = {x: i for i, x in enumerate(nums1)}\n        self.num2_idx = {x: i for i, x in enumerate(nums2)}\n        self.memo = {}\n        s1 = self.helper(nums1, nums2, nums1[0])\n        s2 = self.helper(nums1, nums2, nums2[0])\n        return max(s1, s2) % (10**9 + 7)\n    \n    def helper(self, nums1, nums2, val):\n        if val in self.memo:\n            return self.memo[val]\n        \n        ans1, ans2 = 0, 0\n        if val in self.num1_idx:\n            idx = self.num1_idx[val]\n            if idx + 1 < len(nums1):\n                ans1 = self.helper(nums1, nums2, nums1[idx + 1])\n        \n        \n        if val in self.num2_idx:\n            idx = self.num2_idx[val]\n            if idx + 1 < len(nums2):\n                ans2 = self.helper(nums1, nums2, nums2[idx + 1])\n        \n        res = max(ans1, ans2) + val\n        self.memo[val] = res\n        return res\n    \n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        MOD = 1000000007\n        Dict1 = defaultdict(int)\n        Dict2 = defaultdict(int)\n        for i in range(len(nums1)):\n            Dict1[nums1[i]] = i+1 \n        for i in range(len(nums2)):\n            Dict2[nums2[i]] = i+1\n        Dict3 = {}\n        Dict4 = {}\n        n1 = len(nums1)\n        n2 = len(nums2)\n        for i in nums1:\n            if Dict1[i] >0 and Dict2[i] > 0:\n                Dict3[i] = Dict2[i]\n                Dict4[i] = Dict1[i]\n        @lru_cache(None)\n        def go(i , pos):\n            if pos == 0:\n                if i >= n1:\n                    return 0\n                ans = 0\n                if Dict1[nums1[i]] >= 1 and Dict2[nums1[i]] >= 1:\n                    ans = max(ans, go(i+1,pos)+nums1[i], go(Dict3[nums1[i]], (pos+1)%2)+nums1[i])\n                else:\n                    ans = max(ans, go(i+1, pos)+nums1[i])\n                return ans\n            else:\n                if i >= n2:\n                    return 0\n                ans = 0\n                if Dict1[nums2[i]] >= 1 and Dict2[nums2[i]] >= 1:\n                    ans = max(ans, go(i+1,pos)+nums2[i], go(Dict4[nums2[i]],(pos+1)%2)+nums2[i])\n                else:\n                    ans = max(ans, go(i+1, pos)+nums2[i])\n                return ans\n        return max(go(0,0),go(0,1))%MOD\n", "from collections import defaultdict\nfrom functools import lru_cache\nclass Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        mp = defaultdict(int) # key: (row_idx, elem_value), value: elem_index_in_row\n        for i, x in enumerate(nums1):\n            mp[(0, x)] = i\n        for i, x in enumerate(nums2):\n            mp[(1, x)] = i\n        grid = [nums1, nums2]\n        \n        @lru_cache(None)\n        def search(cur_row: int, i: int, prev_row: int) -> int:\n            if cur_row == prev_row: # no row change\n                res = (grid[cur_row][i] + (search(cur_row, i + 1, cur_row) if i + 1 < len(grid[cur_row]) else 0))\n                if (1 - cur_row, grid[cur_row][i]) in mp:\n                    j = mp[(1 - cur_row, grid[cur_row][i])]\n                    res = max(res, search(1 - cur_row, j, cur_row))\n                return res\n            else: # changed row -> shouldn't change again\n                return (grid[cur_row][i] + (search(cur_row, i + 1, cur_row) if i + 1 < len(grid[cur_row]) else 0))\n        \n        return max(search(0, 0, 0), search(1, 0, 1)) % mod", "class Solution:\n    def maxSum(self, a: List[int], b: List[int]) -> int:\n        a2i = {n: i for i, n in enumerate(a)}\n        b2i = {n: i for i, n in enumerate(b)}\n        @lru_cache(None)\n        def solve(i, is_a, switched):\n            if is_a:\n                c = a\n                c2i = a2i\n                d = b\n                d2i = b2i\n            else:\n                c = b\n                c2i = b2i\n                d = a\n                d2i = a2i\n            add = 0 if switched else c[i]\n            best = add\n            if not switched and c[i] in d2i:\n                best = add + solve(d2i[c[i]], not is_a, True)\n            if i == len(c) - 1:\n                return best\n            return max(best, add + solve(i + 1, is_a, False))\n        return max(solve(0, True, False), solve(0, False, False)) % (10**9 + 7)\n            \n            \n            \n        \n", "import numpy\n\nclass Solution:\n\n  def makeNewArray(self, num: List[int], breakpoint: List[int]):\n    result = []\n    flag = False\n    bp_cur = 0\n    sum = 0\n    for index, value in enumerate(num):\n      if bp_cur < len(breakpoint) and index == breakpoint[bp_cur]:\n        if flag:\n          result.append(sum)\n        else:\n          result.append(0)\n\n        flag = False\n        sum = 0\n        result.append(value)\n        bp_cur += 1\n      else:\n        sum += value\n        flag = True\n\n    if flag:\n      result.append(sum)\n    else:\n      result.append(0)\n\n    return result\n\n  def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n\n    result = 0\n    cur0 = 0\n    cur1 = 0\n    bp0 = []\n    bp1 = []\n    while cur0 < len(nums1) and cur1 < len(nums2):\n      if nums1[cur0] == nums2[cur1]:\n        bp0.append(cur0)\n        bp1.append(cur1)\n        cur0 += 1\n        cur1 += 1\n      elif nums1[cur0] < nums2[cur1]:\n        cur0 += 1\n      else:\n        cur1 += 1\n\n    #print(\\\"[dbg] the breakpoint for arr0 is: \\\", bp0)\n    new_arr0 = self.makeNewArray(nums1, bp0)\n    #print(\\\"[dbg] the new array for arr1 is: \\\", new_arr0)\n\n    #print(\\\"[dbg] the breakpoint for arr1 is: \\\", bp1)\n    new_arr1 = self.makeNewArray(nums2, bp1)\n    #print(\\\"[dbg] the new array for arr2 is: \\\", new_arr1)\n\n    dim = (len(new_arr0), 2)\n    dp = numpy.zeros(dim)\n\n    dp[0][0] = new_arr0[0]\n    dp[0][1] = new_arr1[0]\n\n    #print(\\\"[dbg] the new len0:\\\", len(new_arr0))\n    #print(\\\"[dbg] the new len1:\\\", len(new_arr1))\n\n    for dx in range(1, len(new_arr1)):\n      dp[dx][0] = max(dp[dx-1][0], dp[dx-1][1]) + new_arr0[dx]\n      dp[dx][1] = max(dp[dx-1][0], dp[dx-1][1]) + new_arr1[dx]\n\n    module = int(pow(10, 9) + 7)\n    return int(max(dp[-1][0], dp[-1][1])) % module\n", "from functools import lru_cache\nclass Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        \n        MOD = 10**9+7\n        \n        num_to_index1 = defaultdict(list)\n        num_to_index2 = defaultdict(list)\n        \n        for i, num in enumerate(nums1):\n            num_to_index1[num].append(i)\n        for i, num in enumerate(nums2):\n            num_to_index2[num].append(i)\n            \n        @lru_cache(None)\n        def recurse (i, j):\n            if i==1 and j == len(nums1)-1: return nums1[j]\n            if i==2 and j == len(nums2)-1: return nums2[j]\n            \n            if i==1 : \n                option1 = nums1[j] + recurse (1, j+1)\n                next_ind = num_to_index2.get(nums1[j+1], []) \n                if next_ind: \n                    next_ind = next_ind[0]\n                    option2 = nums1[j] + recurse (2, next_ind)\n                    return max(option1, option2)\n                return option1\n            \n            if i==2: \n                option1 = nums2[j] + recurse (2, j+1)\n                next_ind = num_to_index1.get(nums2[j+1], []) \n                if next_ind: \n                    next_ind = next_ind[0]\n                    option2 = nums2[j] + recurse (1, next_ind)\n                    return max(option1, option2)\n                return option1\n        \n        return max(recurse (1, 0), recurse (2, 0)) % MOD", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        current_value = 0\n        \n        ptr1 = 0\n        ptr2 = 0\n        \n        nums1Total = 0\n        nums2Total = 0\n        \n        while ptr1 < len(nums1) and ptr2 < len(nums2):\n            value1 = nums1[ptr1]\n            value2 = nums2[ptr2]\n            \n            if value1 == value2:\n                current_value += max(nums1Total, nums2Total) + value1\n                ptr1 += 1\n                ptr2 += 1\n                nums1Total = 0\n                nums2Total = 0\n            elif value1 < value2:\n                nums1Total += value1\n                ptr1 += 1\n            else:\n                nums2Total += value2\n                ptr2 += 1\n            \n        while ptr1 < len(nums1):\n            nums1Total += nums1[ptr1]\n            ptr1 += 1\n        while ptr2 < len(nums2):\n            nums2Total += nums2[ptr2]\n            ptr2 += 1\n        \n        current_value += max(nums1Total, nums2Total)\n            \n        return current_value % (10 ** 9 + 7)\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        # graph = [[] for _ in range(10000007)]\n        graph = {}\n        u1, u2 = nums1[0], nums2[0]\n        \n        \n        for n in range(len(nums1) - 1):\n            u, v = nums1[n], nums1[n + 1]\n            if u in graph:\n                graph[u].append(v)\n            else:\n                graph[u] = [v]\n        \n        for n in range(len(nums2) - 1):\n            u, v = nums2[n], nums2[n + 1]\n            if u in graph:\n                graph[u].append(v)\n            else:\n                graph[u] = [v]\n        \n        DP = {}\n        MODN = 1000000007\n        \n        def solve(u):\n            if u in DP:\n                return DP[u]\n            \n            ans = u\n            if u in graph:\n                for v in graph[u]:\n                    ans = max(ans, u + solve(v))\n            DP[u] = ans\n            return DP[u]\n        \n        \n        ans = max(solve(u1), solve(u2)) % MODN\n        return ans", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**5+100)\nfrom collections import *\n\nclass Solution:\n    def rec(self, t, i):\n        if self.memo[t][i]!=-1:\n            return self.memo[t][i]\n    \n        if i==0:\n            return 0\n        \n        if t==0:\n            res = self.rec(0, i-1)+self.nums1[i-1]\n            \n            if self.nums1[i-1] in self.idx2:\n                res = max(res, self.rec(1, self.idx2[self.nums1[i-1]])+self.nums1[i-1])\n        else:\n            res = self.rec(1, i-1)+self.nums2[i-1]\n            \n            if self.nums2[i-1] in self.idx1:\n                res = max(res, self.rec(0, self.idx1[self.nums2[i-1]])+self.nums2[i-1])\n        \n        self.memo[t][i] = res\n        return res\n    \n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        m = len(nums2)\n        self.nums1 = nums1\n        self.nums2 = nums2\n        self.idx1 = defaultdict(int)\n        self.idx2 = defaultdict(int)\n        \n        for i in range(n):\n            self.idx1[nums1[i]] = i\n        \n        for i in range(m):\n            self.idx2[nums2[i]] = i\n        \n        self.memo = [[-1]*max(n+1, m+1) for _ in range(2)]\n        return max(self.rec(0, n), self.rec(1, m))%(10**9+7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        common = set(nums1).intersection(set(nums2))\n        \n        segments1 = []\n        tmp = 0\n        for i in nums1:\n            tmp+=i\n            if i in common:\n                segments1.append(tmp)\n                tmp = 0\n        segments1.append(tmp)    \n            \n        segments2 = []\n        tmp = 0\n        for i in nums2:\n            tmp+=i\n            if i in common:\n                segments2.append(tmp)\n                tmp = 0\n        segments2.append(tmp)\n        \n        ans = 0\n        for i in range(len(segments1)):\n            ans+=max(segments1[i], segments2[i])\n            \n        return ans % (10**9+7)", "'''\nThis seems to be dynamic programming where we have to find out the maximum score we can possibly get given the number of elements left to see in nums1 and nums2\n'''\nclass Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        BIG_INT = 10**9+7\n        maxSums = {}\n        num1Values = {}\n        num2Values = {}\n        num1Values[0] = -1\n        for index, num in enumerate(nums1):\n            num1Values[num] = index\n        num2Values[0] = -1\n        for index,num in enumerate(nums2):\n            num2Values[num] = index\n        num1Length = len(nums1)\n        num2Length = len(nums2)\n        nums1.append(0)\n        nums2.append(0)\n        def computeMaxSum(num1Left,num2Left):\n            ##print(\\\"(num1Left,num2Left) is: \\\"+str((num1Left,num2Left)))\n            if num1Left*num2Left == 0:\n                return 0\n            else:\n                if (num1Left,num2Left) in maxSums:\n                    return maxSums[(num1Left,num2Left)]\n                current1 = 0 if num1Left == num1Length+1 else nums1[-num1Left-1]##had to do -num1Left-1 because we append 0 for future purposes of termination.\n                current2 = 0 if num2Left == num2Length+1 else nums2[-num2Left-1]\n                ##print(\\\"(current1,current2) is: \\\"+str((current1,current2)))\n                if current1 == current2:\n                    maxSums[(num1Left,num2Left)] = max(computeMaxSum(num1Left-1,num2Left)+nums1[-num1Left], computeMaxSum(num1Left,num2Left-1)+nums2[-num2Left])\n                elif current1 > current2:\n                    ##we can either progress to the next in current1 or possibly swap to current2.\n                    if current1 in num2Values:\n                        new2Index = num2Values[current1]\n                        maxSums[(num1Left,num2Left)] = computeMaxSum(num1Left,num2Length-new2Index)##remember you do computeMaxSum before actually calling dictionary because you haven't set it in dictionary yet.\n                    else:\n                        maxSums[(num1Left,num2Left)] = computeMaxSum(num1Left-1,num2Left)+nums1[-num1Left]\n                else:\n                    ##we can either progress to the next in current2 or possibly swap to current1.\n                    if current2 in num1Values:\n                        new1Index = num1Values[current2]\n                        maxSums[(num1Left,num2Left)] = computeMaxSum(num1Length-new1Index,num2Left)\n                    else:\n                        maxSums[(num1Left,num2Left)] = computeMaxSum(num1Left,num2Left-1)+nums2[-num2Left]\n                return maxSums[(num1Left,num2Left)]\n        return computeMaxSum(num1Length+1,num2Length+1)%BIG_INT\n", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        accu1 = list(accumulate(nums1))\n        accu2 = list(accumulate(nums2))\n        #print(accu1)\n        ans  = i = j = 0\n        pi = pj = -1\n        while i<len(nums1) and j<len(nums2):\n            if nums1[i]<nums2[j]:\n                i+=1\n            elif nums1[i]>nums2[j]:\n                j+=1\n            else:\n                ans+=max(accu1[i], accu2[j]) if pi<0 else max(accu1[i]-accu1[pi], accu2[j]-accu2[pj]) \n                pi,pj,i,j = i,j,i+1,j+1\n        \n        ans+=max(accu1[-1], accu2[-1]) if pi<0 else max(accu1[-1]-accu1[pi], accu2[-1]-accu2[pj]) \n        \n        return ans % (10**9+7)", "class Solution:\n    def maxSum(self, nums1: List[int], nums2: List[int]) -> int:\n        M, N = len(nums1), len(nums2)\n        sum1, sum2 = 0, 0\n        i, j = 0, 0\n        res = 0\n        while i < M and j < N:\n            if nums1[i] < nums2[j]:\n                sum1 += nums1[i]\n                i += 1\n            elif nums1[i] > nums2[j]:\n                sum2 += nums2[j]\n                j += 1\n            else:\n                res += max(sum1, sum2) + nums1[i]\n                i += 1\n                j += 1\n                sum1 = 0\n                sum2 = 0\n\n        while i < M:\n            sum1 += nums1[i]\n            i += 1\n        while j < N:\n            sum2 += nums2[j]\n            j += 1\n        return (res + max(sum1, sum2)) % 1000000007\n"]