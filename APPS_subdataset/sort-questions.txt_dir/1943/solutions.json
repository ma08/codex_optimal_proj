["class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        result = []\n        i = j = 0\n        \n        while i < len(A) and j < len(B):\n            low = max(A[i][0], B[j][0])\n            high = min(A[i][1], B[j][1])\n            \n            if low <= high:\n                result.append([low, high])\n                \n            if A[i][1] > B[j][1]:\n                j += 1\n            elif A[i][1] < B[j][1]:\n                i += 1\n            else:\n                i += 1\n                j += 1\n                \n        return result", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        ans = []\n        if not A or not B:\n            return ans\n\n        cur_a = A.pop(0)\n        cur_b = B.pop(0)\n\n        while cur_a and cur_b:\n            if cur_a[0] <= cur_b[1] and cur_a[1] >= cur_b[0]:\n                ans.append([max(cur_a[0], cur_b[0]), min(cur_a[1], cur_b[1])])\n\n            old_a = cur_a\n            if cur_a[1] <= cur_b[1]:\n                cur_a = A.pop(0) if A else None\n            if old_a[1] >= cur_b[1]:\n                cur_b = B.pop(0) if B else None\n\n        return ans", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        res = []\n        while A and B:\n            start1, end1 = A[0][0], A[0][1]\n            start2, end2 = B[0][0], B[0][1]\n            if end1 <= end2:\n                if start2 <= start1:\n                    res.append([start1, end1])\n                elif start2 <= end1:\n                    res.append([start2, end1])\n                A = A[1:]\n            else:\n                if start1 <= start2:\n                    res.append([start2, end2])\n                elif start1 <= end2:\n                    res.append([start1, end2])\n                B = B[1:]\n        return res", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        extremum = [item for t in A for item in t] + [item for t in B for item in t]\n        extremum.sort()\n        \n        counter_a = 0\n        counter_b = 0\n        \n        next_a = A[counter_a] if A else None\n        next_b = B[counter_b] if B else None\n        \n        max_a = A[-1][1] if A else None\n        max_b = B[-1][1] if B else None\n            \n        # key: (Int, Int) - (first line interval id, second line interval id)\n        # value: List[Int] - list of intersections\n        intersections = {}\n        \n        def intersections_append(k: (int, int), v: int):\n            #print(intersections, k, v)\n            if k in intersections:\n                intersections[k].append(v)\n                if len(intersections[k]) > 2:\n                    tmp = list(set(intersections[k]))\n                    tmp.sort()\n                    intersections[k] = tmp\n            else:\n                intersections[k] = [v]\n    \n        self.k1 = None\n        self.k2 = None\n        self.res2 = []\n        def intersections_append2(k: (int, int), v: int):\n            k1 = self.k1\n            k2 = self.k2\n            if k1 is not None and k2 is not None and k[0] == k1 and k[1] == k2:\n                if self.res2:\n                    self.res2[-1].append(v)\n                    if len(self.res2[-1]) > 2:\n                        self.res2[-1] = sorted(set(self.res2[-1]))\n                else:\n                    self.res2.append([v])\n            else:\n                self.k1 = k[0]\n                self.k2 = k[1]\n                self.res2.append([v])\n        \n        res = []\n        for i in extremum:\n            while max_a and i <= max_a and i > next_a[1]:\n                counter_a += 1\n                next_a = A[counter_a] if counter_a < len(A) else None\n            while max_b and i <= max_b and i > next_b[1]:\n                counter_b += 1\n                next_b = B[counter_b] if counter_b < len(B) else None\n            if next_a and next_b and next_a[0] <= i <= next_a[1] and next_b[0] <= i <= next_b[1]:\n                intersections_append((counter_a, counter_b), i) \n                intersections_append2((counter_a, counter_b), i) \n                \n        return self.res2\n        #return intersections.values()\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        time_points = list()\n        \n        for interval in A + B:\n            time_points.append((interval[0], +1))\n            time_points.append((interval[1] + 1, -1))\n            \n        sorted_points = sorted(time_points, key = lambda x : x[0])\n        \n        s = 0\n        intersect = []\n        for i in range(len(sorted_points)):\n            s += sorted_points[i][1]\n            if i != len(sorted_points)-1 and sorted_points[i][0] == sorted_points[i+1][0]:\n                continue\n            \n            if s == 2:\n                intersect.append((sorted_points[i][0], True))\n            else:\n                intersect.append((sorted_points[i][0], False))\n        \n        \n        i = 0\n        ans = list()\n        while i < len(intersect):\n            while not intersect[i][1]:\n                i += 1\n                if i == len(intersect):\n                    return ans\n            ans.append([intersect[i][0], intersect[i+1][0]-1])\n            i += 1\n            \n            \n        return ans\n                \n        \n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        # if 2 events are both in started state\n        state = [False, False]\n        # flatten events into timestamp and flag bit, 0, 1 = A start, finish, 2, 3 = B start finish\n        A_index = [0, 0]\n        B_index = [0, 0]\n        result = []\n        def get_event(events, index):\n            if index[0] >= len(events):\n                return -1\n            return events[index[0]][index[1]]\n        while True:\n            event_a = get_event(A, A_index), A_index[1]\n            event_b = get_event(B, B_index), B_index[1]\n            if event_a[0] < 0 or event_b[0] < 0: \n                break\n            event = min(event_a[0], event_b[0])\n            is_already_in_progress = all(state)\n            if event_a < event_b:\n                if A_index[1] == 0:\n                    state[0] = 1\n                    A_index[1] = 1\n                else:\n                    state[0] = 0\n                    A_index[0] += 1\n                    A_index[1] = 0\n            else:\n                if B_index[1] == 0:\n                    state[1] = 1\n                    B_index[1] = 1\n                else:\n                    state[1] = 0\n                    B_index[0] += 1\n                    B_index[1] = 0\n            if is_already_in_progress:\n                result[-1][1] = event\n            elif all(state):\n                result.append([event,-1])\n        return result\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        result = []\n        while len(A) != 0 and len(B) != 0:\n            a_start, a_end = A[0]\n            b_start, b_end = B[0]\n            start = max(a_start, b_start)\n            end = min(a_end, b_end)\n            if start > end:\n                if start == a_start:\n                    B = B[1:]\n                else:\n                    A = A[1:]\n            else:\n                result.append([start, end])\n                if end == a_end:\n                    B[0] = [start, b_end]\n                    A = A[1:]\n                else:\n                    A[0] = [start, a_end]\n                    B = B[1:]\n        return result", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        # return self.first_implementation(A, B)\n        return self.second_implementation(A, B)\n    \n    def first_implementation(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \\\"\\\"\\\"\n        Iterate over the two lists with two pointers. If the startpoint of one of the intervals is\n        within the end of another then they intersect. On each operation grab the smallest interval\n        start point to use as the basis for comparison.\n        Time Complexity: O(m + n)\n            where m/n are the sizes of the two arrays. since each element is visited at most once.\n        Space Complexity: O(1) -- O(n) if taking the output into account\n        \\\"\\\"\\\"\n        intervals = []\n        idx_a = idx_b = 0\n        # 1. Find if the intervals intersect by seeing if the interval with the smallest start points end point overlaps with the later one\n        def intervals_intersect(interval_a, interval_b):\n            # test: [0,2], [1,5] => [1, 2]\n            min_inter,max_inter  = (interval_a,interval_b) if interval_a[0] < interval_b[0] else (interval_b,interval_a)\n            if min_inter[1] >= max_inter[0]:\n                # intervals.append()\n                return [max_inter[0], min(max_inter[1], min_inter[1])]\n            return None\n        \n        # 2. iterate over the two interval lists until one of them is exhausted\n        while idx_a < len(A) and idx_b < len(B):\n            intersection = intervals_intersect(A[idx_a], B[idx_b])\n            if intersection:\n                intervals.append(intersection)\n            # Need to review this discrete math concept.\n            # Since all of the intervals are disjoint the smallest end point cannot be joined with another \n            # Test: A ([0,2], [5,10]) -- B ([1,5], [8,12]) produce first intersection [1,2].\n            # Given that they're disjoint the next possible interval has to start after the end of the previous. \n            # since A[n][1] < B[m][1] the only next interval could be from A[n+1][0], B[m][0] since B can still encompass other from A's set.\n            if A[idx_a][1] < B[idx_b][1]:\n                idx_a += 1\n            else:\n                idx_b += 1\n\n        return intervals\n    \n    def second_implementation(self,  A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \\\"\\\"\\\"\n        Memoized DP solution offloading the work to a helper function with a bound that returns at the first missed interval\n        Time Complexity: O(m+n)\n            Each combination will be visited at least once without the bounding function\n            The sort at the end accounts for the O(n log n) portion.\n        \\\"\\\"\\\"\n         # 1. Find if the intervals intersect by seeing if the interval with the smallest start points end point overlaps with the later one\n        def intervals_intersect(interval_a, interval_b):\n            # test: [0,2], [1,5] => [1, 2]\n            min_inter,max_inter  = (interval_a,interval_b) if interval_a[0] < interval_b[0] else (interval_b,interval_a)\n            if min_inter[1] >= max_inter[0]:\n                return [max_inter[0], min(max_inter[1], min_inter[1])]\n            return None \n        \n        def find_intersections(idx_a, idx_b):\n            if idx_a == len(A) or idx_b == len(B):\n                return []\n            intervals = []\n            interval_a = A[idx_a]\n            interval_b = B[idx_b]\n            intersection = intervals_intersect(interval_a, interval_b)\n            if intersection:\n                intervals.append(intersection)\n            if interval_a[1] < interval_b[1]:\n                idx_a+= 1\n            else:\n                idx_b += 1\n            return intervals + find_intersections(idx_a, idx_b)\n\n        \n        return find_intersections(0, 0)\n        \n        \n        \n        ", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        counter_a = 0\n        counter_b = 0\n        \n        next_a = A[counter_a] if A else None\n        next_b = B[counter_b] if B else None\n        \n        max_a = A[-1][1] if A else None\n        max_b = B[-1][1] if B else None\n            \n        # key: (Int, Int) - (first line interval id, second line interval id)\n        # value: List[Int] - list of intersections\n        #intersections = {}\n    \n        self.k1 = None\n        self.k2 = None\n        self.res2 = []\n        def intersections_append2(k: (int, int), v: int):\n            k1 = self.k1\n            k2 = self.k2\n            if k1 is not None and k2 is not None and k[0] == k1 and k[1] == k2:\n                if self.res2:\n                    self.res2[-1].append(v)\n                    if len(self.res2[-1]) > 2:\n                        self.res2[-1] = sorted(set(self.res2[-1]))\n                else:\n                    self.res2.append([v])\n            else:\n                self.k1 = k[0]\n                self.k2 = k[1]\n                self.res2.append([v])\n        \n        def get_next_items(lft_idx, rgt_idx):\n            lft_idx_outer = int(lft_idx / 2)\n            lft_idx_inner = lft_idx % 2\n            rgt_idx_outer = int(rgt_idx / 2)\n            rgt_idx_inner = rgt_idx % 2\n            lft = A[lft_idx_outer][lft_idx_inner] if lft_idx_outer < len(A) else None\n            rgt = B[rgt_idx_outer][rgt_idx_inner] if rgt_idx_outer < len(B) else None\n            return (lft, rgt)\n        \n        u = (0, 0)\n        i_a, i_b = get_next_items(u[0], u[1])\n        \n        while i_a is not None and i_b is not None:\n            i_a, i_b = get_next_items(u[0], u[1])\n            if i_a is not None and (i_b is None or i_a <= i_b):\n                i = i_a\n                u = (u[0] + 1, u[1])\n            else:\n                i = i_b\n                u = (u[0], u[1] + 1)\n            while max_a and i <= max_a and i > next_a[1]:\n                counter_a += 1\n                next_a = A[counter_a] if counter_a < len(A) else None\n            while max_b and i <= max_b and i > next_b[1]:\n                counter_b += 1\n                next_b = B[counter_b] if counter_b < len(B) else None\n            if next_a and next_b and next_a[0] <= i <= next_a[1] and next_b[0] <= i <= next_b[1]:\n                intersections_append2((counter_a, counter_b), i) \n                \n        return self.res2", "import numpy as np\nclass Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        ans = []\n        i = j = 0\n\n        while i < len(A) and j < len(B):\n            # Let's check if A[i] intersects B[j].\n            # lo - the startpoint of the intersection\n            # hi - the endpoint of the intersection\n            lo = max(A[i][0], B[j][0])\n            hi = min(A[i][1], B[j][1])\n            if lo <= hi:\n                ans.append([lo, hi])\n\n            # Remove the interval with the smallest endpoint\n            if A[i][1] < B[j][1]:\n                i += 1\n            else:\n                j += 1\n\n        return ans", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n\n        self.k1 = None\n        self.k2 = None\n        self.res2 = []\n        def intersections_append2(k: (int, int), v: int):\n            k1 = self.k1\n            k2 = self.k2\n            if k1 is not None and k2 is not None and k[0] == k1 and k[1] == k2:\n                if self.res2:\n                    self.res2[-1].append(v)\n                    if len(self.res2[-1]) > 2:\n                        self.res2[-1] = sorted(set(self.res2[-1]))\n                else:\n                    self.res2.append([v])\n            else:\n                self.k1 = k[0]\n                self.k2 = k[1]\n                self.res2.append([v])\n        \n        def get_next_items(lft_idx, rgt_idx):\n            lft_idx_outer = int(lft_idx / 2)\n            lft_idx_inner = lft_idx % 2\n            rgt_idx_outer = int(rgt_idx / 2)\n            rgt_idx_inner = rgt_idx % 2\n            lft = A[lft_idx_outer][lft_idx_inner] if lft_idx_outer < len(A) else None\n            rgt = B[rgt_idx_outer][rgt_idx_inner] if rgt_idx_outer < len(B) else None\n            lft_full = A[lft_idx_outer] if lft_idx_outer < len(A) else A[lft_idx_outer-1]\n            rgt_full = B[rgt_idx_outer] if rgt_idx_outer < len(B) else B[rgt_idx_outer-1]\n            return (lft, rgt, lft_full, rgt_full, min(lft_idx_outer, len(A)-1), min(rgt_idx_outer, len(B)-1))\n        \n        u = (0, 0)\n        \n        if u[0] >= len(A) or u[0] >= len(B):\n            return []\n        \n        i_a, i_b, next_a2, next_b2, counter_a, counter_b = get_next_items(u[0], u[1])\n        \n        redo_step = True\n        \n        while not (i_a is None and i_b is None):\n            if (i_a is not None and i_b is None) :\n                i, u = i_a, (u[0] + 1, u[1])\n            elif (i_a is None and i_b is not None):\n                i, u = i_b, (u[0], u[1] + 1)\n            elif (i_a < i_b):\n                i, u = i_a, (u[0] + 1, u[1])\n            elif (i_a > i_b):\n                i, u = i_b, (u[0], u[1] + 1)\n            elif (i_a == i_b) and redo_step:\n                i, u = i_a, (u[0], u[1])\n                redo_step = False\n            elif (i_a == i_b) and not redo_step:\n                i, u = i_a, (u[0]+1, u[1]+1)\n                redo_step = True\n\n            if next_a2 is not None and next_b2 is not None and next_a2[0] <= i <= next_a2[1] and next_b2[0] <= i <= next_b2[1]:\n                intersections_append2((counter_a, counter_b), i) \n                \n            i_a, i_b, next_a2, next_b2, counter_a, counter_b = get_next_items(u[0], u[1])\n        return self.res2", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        NA = len(A)\n        NB = len(B)\n        if NA == 0 or NB == 0:\n            return []\n\n        pA = 0\n        pB = 0\n        res = []\n        while pA<NA and pB<NB:\n            sA = A[pA][0]\n            eA = A[pA][1]\n            sB = B[pB][0]\n            eB = B[pB][1]\n            if sA<=sB:\n                if eA>=sB:\n                    res.append([sB,min(eA,eB)])\n            else:\n                if eB>=sA:\n                    res.append([sA,min(eA,eB)])\n            if eA<eB:\n                pA += 1\n            elif eA == eB:\n                pA += 1\n                pB += 1\n            else:\n                pB += 1\n\n\n        return res", "import numpy as np\nclass Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        res = []\n        i = j = 0\n        while i<len(A) and j<len(B):\n            left = max(A[i][0], B[j][0])\n            right = min(A[i][1], B[j][1])\n            \n            if left <= right:\n                res.append([left, right])\n            \n            if A[i][1] < B[j][1]:\n                i += 1\n            else:\n                j += 1\n        return res", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        # time O(M+N) space O(M+N)\n        result=[]\n        i=j=0\n        while i<len(A) and j<len(B):\n            lo= max(A[i][0], B[j][0])\n            hi= min(A[i][1], B[j][1])\n            if lo<=hi:\n                result.append([lo,hi])\n            \n            # remove interval with smallest endpoint\n            if A[i][1]<B[j][1]:\n                i+=1\n            else:\n                j+=1\n        return result\n#         i, j, result= 0, 0, []\n#         while i<len(A) and j<len(B):\n#             # find overlap or not\n#             if A[i][1] < B[j][0]: \n#                 i+=1\n#             elif B[j][1] < A[i][0]: \n#                 j+=1\n#             else:\n#                 # merged interval condition: max of start index, min of end index\n#                 result.append((max(A[i][0], B[j][0]), min(A[i][1], B[j][1])))\n#                 if B[j][1] <= A[i][1]:\n#                     j+=1\n#                 else: \n#                     i+=1\n        \n#         return result\n                \n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        if not A or not B:\n            return []\n        res = []\n        i = j = 0\n        while i < len(A) and j < len(B):\n            s, e = max(A[i][0], B[j][0]), min(A[i][1], B[j][1])\n            if s <= e:\n                res.append([s, e])   \n            if A[i][1] < B[j][1]:\n                i += 1\n            else:\n                j += 1\n\n        return res\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n\n        res3 = []\n        self.k1 = None\n        self.k2 = None\n        self.res2 = []\n        def intersections_append2(k: (int, int), v: int):\n            k1 = self.k1\n            k2 = self.k2\n            if k1 is not None and k2 is not None and k[0] == k1 and k[1] == k2:\n                if self.res2:\n                    self.res2[-1].append(v)\n                    #if len(self.res2[-1]) > 2:\n                    #    print(\\\"AAAAAA\\\")\n                    #    self.res2[-1] = sorted(set(self.res2[-1]))\n                else:\n                    self.res2.append([v])\n            else:\n                self.k1 = k[0]\n                self.k2 = k[1]\n                self.res2.append([v])\n        \n        def get_next_items(lft_idx, rgt_idx):\n            lft_idx_outer = int(lft_idx / 2)\n            lft_idx_inner = lft_idx % 2\n            rgt_idx_outer = int(rgt_idx / 2)\n            rgt_idx_inner = rgt_idx % 2\n            lft = A[lft_idx_outer][lft_idx_inner] if lft_idx_outer < len(A) else None\n            rgt = B[rgt_idx_outer][rgt_idx_inner] if rgt_idx_outer < len(B) else None\n            lft_full = A[lft_idx_outer] if lft_idx_outer < len(A) else A[lft_idx_outer-1]\n            rgt_full = B[rgt_idx_outer] if rgt_idx_outer < len(B) else B[rgt_idx_outer-1]\n            return (lft, rgt, lft_full, rgt_full, min(lft_idx_outer, len(A)-1), min(rgt_idx_outer, len(B)-1))\n        \n        u = (0, 0)\n        a_idx = 0\n        b_idx = 0\n        \n        if a_idx >= len(A) or b_idx >= len(B):\n            return []\n        \n        prev_counter_a = None\n        prev_counter_b = None\n        \n        i_a, i_b, next_a2, next_b2, counter_a, counter_b = get_next_items(a_idx, b_idx)\n        \n        redo_step = True\n        \n        while not (i_a is None and i_b is None):\n            if (i_a is not None and i_b is None) :\n                a_idx += 1\n            elif (i_a is None and i_b is not None):\n                b_idx += 1\n            elif (i_a < i_b):\n                a_idx += 1\n            elif (i_a > i_b):\n                b_idx += 1\n            elif (i_a == i_b) and redo_step:\n                redo_step = False\n            elif (i_a == i_b) and not redo_step:\n                a_idx += 1\n                b_idx += 1\n                redo_step = True\n                \n            i = min(k for k in [i_a, i_b] if k is not None)\n\n            if next_a2 is not None and next_b2 is not None and next_a2[0] <= i <= next_a2[1] and next_b2[0] <= i <= next_b2[1]:\n                #intersections_append2((counter_a, counter_b), i)\n                if counter_a == prev_counter_a and counter_b == prev_counter_b:\n                    # append\n                    res3[-1].append(i)\n                else:\n                    # add\n                    res3.append([i])\n                prev_counter_a = counter_a\n                prev_counter_b = counter_b\n                \n            i_a, i_b, next_a2, next_b2, counter_a, counter_b = get_next_items(a_idx, b_idx)\n        \n        res4 = []\n        for x in res3:\n            if len(x) > 2:\n                tmp = sorted(list(set(x)))\n                #tmp.sort\n                res4.append(tmp)\n            else:\n                res4.append(x)\n        \n        return res4", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        extremum = [item for t in A for item in t] + [item for t in B for item in t]\n        extremum.sort()\n        \n        counter_a = 0\n        counter_b = 0\n        \n        next_a = A[counter_a] if A else None\n        next_b = B[counter_b] if B else None\n        \n        max_a = A[-1][1] if A else None\n        max_b = B[-1][1] if B else None\n            \n        # key: (Int, Int) - (first line interval id, second line interval id)\n        # value: List[Int] - list of intersections\n        #intersections = {}\n        \n        #def intersections_append(k: (int, int), v: int):\n        #    #print(intersections, k, v)\n        #    if k in intersections:\n        #        intersections[k].append(v)\n        #        if len(intersections[k]) > 2:\n        #            tmp = list(set(intersections[k]))\n        #            tmp.sort()\n        #            intersections[k] = tmp\n        #    else:\n        #        intersections[k] = [v]\n    \n        self.k1 = None\n        self.k2 = None\n        self.res2 = []\n        def intersections_append2(k: (int, int), v: int):\n            k1 = self.k1\n            k2 = self.k2\n            if k1 is not None and k2 is not None and k[0] == k1 and k[1] == k2:\n                if self.res2:\n                    self.res2[-1].append(v)\n                    if len(self.res2[-1]) > 2:\n                        self.res2[-1] = sorted(set(self.res2[-1]))\n                else:\n                    self.res2.append([v])\n            else:\n                self.k1 = k[0]\n                self.k2 = k[1]\n                self.res2.append([v])\n        \n        #res = []\n        \n        def get_next_items(idx_pair):\n            lft_idx_outer = int(idx_pair[0] / 2)\n            lft_idx_inner = idx_pair[0] % 2\n            rgt_idx_outer = int(idx_pair[1] / 2)\n            rgt_idx_inner = idx_pair[1] % 2\n            lft = A[lft_idx_outer][lft_idx_inner] if lft_idx_outer < len(A) else None\n            rgt = B[rgt_idx_outer][rgt_idx_inner] if rgt_idx_outer < len(B) else None\n            return (lft, rgt)\n        \n        u = (0, 0)\n        i_a, i_b = get_next_items(u)\n        print((i_a, i_b))\n        \n        while i_a is not None and i_b is not None:\n            print((i_a, i_b))\n            i_a, i_b = get_next_items(u)\n            if i_a is not None and (i_b is None or i_a <= i_b):\n                i = i_a\n                u = (u[0] + 1, u[1])\n            else:\n                i = i_b\n                u = (u[0], u[1] + 1)\n            #i = min(i_a, i_b)\n            while max_a and i <= max_a and i > next_a[1]:\n                counter_a += 1\n                next_a = A[counter_a] if counter_a < len(A) else None\n            while max_b and i <= max_b and i > next_b[1]:\n                counter_b += 1\n                next_b = B[counter_b] if counter_b < len(B) else None\n            if next_a and next_b and next_a[0] <= i <= next_a[1] and next_b[0] <= i <= next_b[1]:\n                #intersections_append((counter_a, counter_b), i) \n                intersections_append2((counter_a, counter_b), i) \n                \n        return self.res2\n        #return intersections.values()\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n\n        res3 = []\n        \n        def get_next_items(lft_idx, rgt_idx):\n            lft_idx_outer = int(lft_idx / 2)\n            lft_idx_inner = lft_idx % 2\n            rgt_idx_outer = int(rgt_idx / 2)\n            rgt_idx_inner = rgt_idx % 2\n            lft = A[lft_idx_outer][lft_idx_inner] if lft_idx_outer < len(A) else None\n            rgt = B[rgt_idx_outer][rgt_idx_inner] if rgt_idx_outer < len(B) else None\n            lft_full = A[lft_idx_outer] if lft_idx_outer < len(A) else A[lft_idx_outer-1]\n            rgt_full = B[rgt_idx_outer] if rgt_idx_outer < len(B) else B[rgt_idx_outer-1]\n            return (lft, rgt, lft_full, rgt_full, min(lft_idx_outer, len(A)-1), min(rgt_idx_outer, len(B)-1))\n        \n        u = (0, 0)\n        a_idx = 0\n        b_idx = 0\n        \n        if a_idx >= len(A) or b_idx >= len(B):\n            return []\n        \n        prev_counter_a = None\n        prev_counter_b = None\n        \n        i_a, i_b, next_a2, next_b2, counter_a, counter_b = get_next_items(a_idx, b_idx)\n        \n        redo_step = True\n        \n        while not (i_a is None and i_b is None):\n            if (i_a is not None and i_b is None) :\n                a_idx += 1\n            elif (i_a is None and i_b is not None):\n                b_idx += 1\n            elif (i_a < i_b):\n                a_idx += 1\n            elif (i_a > i_b):\n                b_idx += 1\n            elif (i_a == i_b) and redo_step:\n                redo_step = False\n            elif (i_a == i_b) and not redo_step:\n                a_idx += 1\n                b_idx += 1\n                redo_step = True\n                \n            i = min(k for k in [i_a, i_b] if k is not None)\n\n            if next_a2 is not None and next_b2 is not None and next_a2[0] <= i <= next_a2[1] and next_b2[0] <= i <= next_b2[1]:\n                #intersections_append2((counter_a, counter_b), i)\n                if counter_a == prev_counter_a and counter_b == prev_counter_b:\n                    # append\n                    res3[-1].append(i)\n                else:\n                    # add\n                    res3.append([i])\n                prev_counter_a = counter_a\n                prev_counter_b = counter_b\n                \n            i_a, i_b, next_a2, next_b2, counter_a, counter_b = get_next_items(a_idx, b_idx)\n        \n        res4 = []\n        for x in res3:\n            if len(x) > 2:\n                tmp = sorted(list(set(x)))\n                res4.append(tmp)\n            else:\n                res4.append(x)\n        \n        return res4", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        result = []\n        i, j = 0, 0\n        \n        while i < len(A) and j < len(B):\n            lo = max(A[i][0], B[j][0])\n            hi = min(A[i][1], B[j][1])\n            \n            if lo <= hi:\n                result.append([lo, hi])\n            \n            if A[i][1] < B[j][1]:\n                i += 1\n            else:\n                j += 1\n\n        return result", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \n        # direct merge intervals approach\n        # problem : https://leetcode.com/problems/interval-list-intersections/\n        # T = O(M + N) # the lengths of A,B\n        # S = O(M + N)\n        \n        \n        ans = []\n        i,j = 0,0 # two pointers to keep track of A,B\n        \n        while i < len(A) and j < len(B):\n            \n            # first the get the start pointer for the intersection\n            # the start point is the fatherst away is the right one\n            lo = max(A[i][0],B[j][0])\n            \n            # then get the pos, where the intervel ends first\n            # eighter in A or B\n            high = min(A[i][1],B[j][1])\n            \n            if lo <= high:\n                ans.append([lo,high])\n                \n            # remove the interval with the smallest end point\n            if A[i][1] < B[j][1]:\n                # consider next sample in A\n                i += 1\n            else:\n                # consider next sample in B\n                j += 1\n                \n        return ans\n        \n        \n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \n        res = []\n        \n        i = 0\n        j = 0\n        \n        while i < len(A) and j < len(B):\n            if max(A[i][0], B[j][0]) <= min(A[i][1], B[j][1]):\n                res.append([max(A[i][0], B[j][0]), min(A[i][1], B[j][1])])\n                \n            if A[i][1] < B[j][1]:\n                i += 1\n            else:\n                j += 1\n                \n        return res\n", "'''\nsol: Use two pointer\nTime: O(M+N)\nSpace: O(1) -> if output is not considered else O(M+N)\n'''\n\nclass Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        ans = []\n        i = j = 0\n\n        while i < len(A) and j < len(B):\n            # Let's check if A[i] intersects B[j].\n            # lo - the startpoint of the intersection\n            # hi - the endpoint of the intersection\n            lo = max(A[i][0], B[j][0])\n            hi = min(A[i][1], B[j][1])\n            if lo <= hi:\n                ans.append([lo, hi])\n\n            # Remove the interval with the smallest endpoint\n            if A[i][1] < B[j][1]:\n                i += 1\n            else:\n                j += 1\n\n        return ans\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        #they're sorted so\n        #grab list from A\n        #grab list from B\n        \n        #look for overlap\n            #check \n        \n        #if B ends before A, then move B along \n        #else move A along\n        res = []\n        a = 0\n        b = 0\n        while a < len(A) and b < len(B):\n            #check for overlap \n            #interval from further along beginning to backmost back\n            start = max(A[a][0], B[b][0])\n            end = min(A[a][1], B[b][1])\n            \n            if start <= end:\n                res.append([start,end])\n            \n            if A[a][1] < B[b][1]:\n                a += 1\n            else:\n                b += 1\n        \n        return res", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        i, j, ans = 0, 0, []\n        while i < len(A) and j < len(B):\n            a, b = A[i], B[j]\n            if not (a[1] < b[0] or a[0] > b[1]):\n                ans.append([max(a[0],b[0]), min(a[1], b[1])])\n            if a[1] >= b[1]:\n                j += 1\n            elif b[1] >= a[1]:\n                i += 1\n        return ans", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        i, j = 0, 0\n        res = []\n        A.append([math.inf, math.inf])\n        B.append([math.inf, math.inf])\n        while i < len(A)-1 or j < len(B)-1:\n            (i1_s, i1_e), (i2_s, i2_e) = A[i], B[j]\n            if i1_e >= i2_s:\n                if i1_s <= i2_e:\n                    res.append([max(i1_s, i2_s), min(i1_e, i2_e)])\n                j += 1\n            else:\n                if j > 0: j -= 1\n                i += 1\n        return res\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \n        if not A or not B:\n            return []\n        m, n = len(A), len(B)\n        result = []\n        i = j = 0\n        while i<m and j<n:\n            start = max(A[i][0], B[j][0])\n            end = min(A[i][1], B[j][1])\n            \n            if start<=end:\n                result.append([start, end])\n            \n            if A[i][1]<B[j][1]:\n                i += 1\n            else:\n                j += 1\n        return result\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \n        i = 0\n        j = 0\n        ans = []\n        while i < len(A) and j < len(B):\n            \n            \n            if A[i][0] >= B[j][0] and A[i][1] <= B[j][1]:\n                ans.append([A[i][0], A[i][1]])\n                i += 1\n            elif B[j][0] >= A[i][0] and B[j][1] <= A[i][1]:\n                ans.append([B[j][0], B[j][1]])\n                j += 1\n            elif A[i][1] >= B[j][0] and A[i][0] <= B[j][0]:\n                ans.append([B[j][0], A[i][1]])\n                i += 1\n            elif B[j][1] >= A[i][0] and B[j][0] <= A[i][0]:\n                ans.append([A[i][0], B[j][1]])\n                j += 1\n            elif B[j][1] < A[i][0]:\n                j += 1\n            elif A[i][1] < B[j][0]:\n                i += 1\n        return ans", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        if len(A) == 0 or len(B) == 0:\n            return []\n        a_start, a_end = A[0]\n        b_start, b_end = B[0]\n        start = max(a_start, b_start)\n        end = min(a_end, b_end)\n        if start > end:\n            if start == a_start:\n                return self.intervalIntersection(A, B[1:])\n            else:\n                return self.intervalIntersection(A[1:], B)\n        else:\n            if end == a_end:\n                B[0] = [start, b_end]\n                return [[start, end]] + self.intervalIntersection(A[1:], B)\n            else:\n                A[0] = [start, a_end]\n                return [[start, end]] + self.intervalIntersection(A, B[1:])", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        ans = []\n        i = 0\n        j = 0 \n        \n        while i<len(A) and j<len(B):\n            lo = max(A[i][0], B[j][0])\n            hi = min(A[i][1], B[j][1])\n            \n            if lo <= hi:\n                ans.append([lo,hi])\n                \n            if A[i][1] < B[j][1]:\n                i+=1\n            else:\n                j+=1\n                \n        return ans\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        res = []\n        i = j = 0 \n        while i < len(A) and j < len(B):\n            low  = max(A[i][0], B[j][0])\n            high = min(A[i][1], B[j][1])\n            \n            if low <= high:\n                res.append([low,high])\n            \n            if A[i][1] < B[j][1]:\n                i += 1\n            else:\n                j += 1\n        return res \n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        if not A or not B:\n            return []\n        \n        ans = []\n        i = j = 0\n        while i < len(A) and j < len(B):\n            lo = max(A[i][0], B[j][0])\n            hi = min(A[i][1], B[j][1])\n            if lo <= hi:\n                ans.append([lo, hi])\n            if B[j][1] > A[i][1]:\n                i += 1\n            elif B[j][1] < A[i][1]:\n                j += 1\n            else:\n                i += 1\n                j += 1\n        return ans\n", "class Solution:\n  def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n    intervals = deque()\n    while A and B:\n      a, b = A[-1], B[-1]\n      x, y = max(a[0], b[0]), min(a[1], b[1])\n      if x <= y: intervals.appendleft([x, y])\n      (A if a > b else B).pop()\n    return intervals", "class Solution:\n    def overlap(self, lst):\n        lst.sort(key=lambda x: x[0])\n        if lst[0][1] >= lst[1][0]:\n            return True\n        return False\n    \n    def add_data(self, start_a, end_a, start_b, end_b, res):\n        if self.overlap([(start_a, end_a), (start_b, end_b)]):\n            start, end = max(start_a, start_b), min(end_a, end_b)\n            if (start, end) not in res:\n                res.append((start, end))\n        return res\n    \n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \n        if not A or not B:\n            return []\n        \n        start_a, end_a = A.pop(0)\n        start_b, end_b = B.pop(0)\n        res = []\n        \n        while A and B:\n            res = self.add_data(start_a, end_a, start_b, end_b, res)\n            if end_a < end_b:\n                start_a, end_a = A.pop(0)\n            else:\n                start_b, end_b = B.pop(0)\n                \n        while A:\n            res = self.add_data(start_a, end_a, start_b, end_b, res)\n            start_a, end_a = A.pop(0)\n            \n        while B:\n            res = self.add_data(start_a, end_a, start_b, end_b, res)\n            start_b, end_b = B.pop(0)\n            \n        res = self.add_data(start_a, end_a, start_b, end_b, res)\n            \n        return res\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        ite1 = 0\n        ite2 = 0\n        lenA = len(A)\n        lenB = len(B)\n        \n        ans = []\n        while ite1 < lenA and ite2 < lenB:\n            curA = A[ite1]\n            curB = B[ite2]\n            \n            s, e = max(curA[0], curB[0]), min(curA[1], curB[1])\n            if s <= e:\n                ans.append([s,e])\n            if curA[1] > curB[1]:\n                ite2 += 1\n            elif curA[1] < curB[1]:\n                ite1 += 1\n            else:\n                ite1 += 1\n                ite2 += 1\n        \n        return ans", "def intersection(a: List, b: List) -> List:\n    l = max(a[0], b[0])\n    r = min(a[1], b[1])\n    if l <= r:\n        return [l,r]\n    else:\n        return None\n    \ndef union(a: List, b: List) -> List:\n    l = min(a[0], b[0])\n    r = max(a[1], b[1])\n    i = intersection(a, b)\n    if i:\n        return [l,r]\n    else:\n        return None\n    \n\nclass Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        result = []\n        \n        while A and B:\n            a = A[0]\n            b = B[0]\n            i = intersection(a,b)\n            if i:\n                result.append(i)\n            # get rid of interval with the smallest front\n            if a[1] < b[1]:\n                A.pop(0)\n            elif a[1] > b[1]:\n                B.pop(0)\n            else:\n                A.pop(0) # validate\n            \n        # consolidate adjacent intervals in the result \n        i=1\n        while i < len(result):\n            u = union(result[i-1],result[i])\n            if u:\n                result.pop(i-1)\n                result.pop(i-1)\n                result.insert(i-1, u)\n            else:\n                i+=1\n            \n        return result\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        if not A or len(A) == 0 or not B or len(B) == 0:\n            return []\n        \n        res = []\n        i, j, = 0, 0\n        \n        while i < len(A) and j < len(B):\n            start = max(A[i][0], B[j][0])\n            end = min(A[i][1], B[j][1])\n            \n            if A[i][0] <= B[j][1] and B[j][0] <= A[i][1]:\n                res.append([start, end])\n            \n            if A[i][1] <= B[j][1]:\n                i += 1\n            else:\n                j += 1\n        \n        return res", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \\\"\\\"\\\"\n        each lists are pairwise disjoint and in sorted order based on what, length? no, start!\n        return the intersection of two lists\n        \n        [1,2], [5,5], [8,10], [15, 23], [24,24], [25, 25]\n        runtime -- O(n+m)\n        space comp. -- O(n+m)\n        \\\"\\\"\\\"\n        commonRegion= []\n        ptr1, ptr2=0, 0\n        while ptr1 <len(A) and ptr2< len(B):\n            if self.isCommon(A[ptr1], B[ptr2]):\n                newInterval= max(A[ptr1][0], B[ptr2][0]), min(A[ptr1][1], B[ptr2][1])\n                commonRegion.append(newInterval)\n            if A[ptr1][1] >= B[ptr2][1]:\n                ptr2+=1\n            else:\n                ptr1+=1\n        return commonRegion\n    \n    def isCommon(self, x, y):\n        a, b= sorted([x, y], key= lambda x:x[0]) # sort based on starting \n        return a[1]>= b[0]", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        if not A or not B:\n            return []\n        MergedList = A + B\n        MergedList.sort()\n        result = []\n        for i in range(len(MergedList)):\n            if i == 0:\n                continue\n            if MergedList[i][0] <= MergedList[i - 1][1]:\n                result.append([max(MergedList[i - 1][0], MergedList[i][0]), min(MergedList[i - 1][1], MergedList[i][1])])\n                MergedList[i][1] = max(MergedList[i - 1][1], MergedList[i][1])\n        \n        return result\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        ans = []\n        i = j = 0\n        \n        while(i<len(A) and j<len(B)):\n            l = max(A[i][0], B[j][0])\n            h = min(A[i][1], B[j][1])\n            \n            if(l<=h):\n                ans.append([l,h])\n            \n            if(A[i][1] < B[j][1]):\n                i+=1\n            else:\n                j+=1\n            # else:\n            #     i+=1\n            #     j+=1\n        return ans", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        p1, p2 = 0, 0\n        res = []\n        while p1 < len(A) and p2 < len(B):\n            # check if two intervals overlap\n            if not (B[p2][1] < A[p1][0] or A[p1][1] < B[p2][0]):\n                res.append((max(A[p1][0], B[p2][0]), min(A[p1][1], B[p2][1])))\n            # update pointers\n            if A[p1][1] < B[p2][1]:\n                # interval in A ends earlier\n                p1 += 1\n            else:\n                p2 += 1\n        return res\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        res, a, b = [], 0, 0\n        while a < len(A) and b < len(B):\n            if A[a][1] < B[b][0]:\n                a += 1\n            elif B[b][1] < A[a][0]:\n                b += 1\n            else:\n                res.append([max(A[a][0], B[b][0]), min(A[a][1], B[b][1])])\n                if A[a][1] < B[b][1]:\n                    a += 1\n                else:\n                    b += 1\n        return res", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        ans = []\n        i = j = 0\n\n        while i < len(A) and j < len(B):\n            # Let's check if A[i] intersects B[j].\n            # lo - the startpoint of the intersection\n            # hi - the endpoint of the intersection\n            lo = max(A[i][0], B[j][0])\n            hi = min(A[i][1], B[j][1])\n            if lo <= hi:\n                ans.append([lo, hi])\n\n            # Remove the interval with the smallest endpoint\n            if A[i][1] < B[j][1]:\n                i += 1\n            else:\n                j += 1\n\n        return ans", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        \n        output = []\n        \n        i, j = 0, 0\n        \n        while i < len(A) and j < len(B):\n            \n            lo = max(A[i][0], B[j][0])\n            hi = min(A[i][1], B[j][1])\n            \n            if lo <= hi:\n                \n                output.append([lo, hi])\n                \n            if A[i][1] < B[j][1]:\n                \n                i += 1\n                \n            else:\n                \n                j += 1\n                \n        return(output)\n", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        i = 0\n        j = 0\n        result = []\n        while i < len(A) and j < len(B):\n            if self.overlap(A[i], B[j]):                \n                result.append(self.intersection(A[i], B[j]))\n            if A[i][1] <= B[j][1]:\n                i += 1\n            else:\n                j += 1\n\n        return result\n                \n    def overlap(self, i1, i2):\n        return any([\n            i1[0] <= i2[0] <= i1[1],\n            i1[0] <= i2[1] <= i1[1],\n            i2[0] <= i1[0] <= i2[1],\n            i2[0] <= i1[1] <= i2[1],\n        ])\n    \n    def intersection(self, i1, i2):\n        return [\n            max(i1[0], i2[0]),\n            min(i1[1], i2[1]),\n        ]", "class Solution:\n    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:\n        res3 = []\n        \n        a_idx = 0\n        b_idx = 0\n        \n        if a_idx >= len(A) or b_idx >= len(B):\n            return []\n        \n        redo_step = False\n\n        while a_idx < len(A) and b_idx < len(B):\n            next_a2 = A[a_idx]\n            next_b2 = B[b_idx]\n            i_a = next_a2[0]\n            i_b = next_b2[0]\n            \n            if next_a2[1] < next_b2[1]:\n                a_idx += 1\n            else:\n                b_idx += 1\n                \n                \n            max_lft = max(k for k in [next_a2[0], next_b2[0]])\n            min_rgt = min(k for k in [next_a2[1], next_b2[1]])\n\n            if max_lft <= min_rgt:\n                res3.append([max_lft, min_rgt])\n\n        \n        return res3"]