["def solve(n):\n    def length(n):\n        s = 0\n        for i in range(20):\n            o = 10 ** i - 1\n            if o > n: break\n            s += (n - o) * (n - o + 1) // 2\n        return s\n\n    def binary_search(k):\n        n = 0\n        for p in range(63, -1, -1):\n            if length(n + 2 ** p) < k: n += 2 ** p\n        return n\n\n    def sequence(n):\n        if n < 10: return n\n        for i in range(1, 19):\n            segment = i * 9 * 10 ** (i - 1)\n            if n <= segment:\n                return str(10 ** (i - 1) + (n - 1) // i)[(n - 1) % i]\n            else:\n                n -= segment\n    return int(sequence(n - length(binary_search(n))))", "from itertools import count\nfrom math import floor\nfrom decimal import Decimal \n\n#for finding sum upto nth element of arithmetic prograssion starting with a with different d\ndef find_sum(a, d, n):     \n    return int(Decimal(n / 2) * Decimal((2 * a) + ((n - 1) * d)))\n\n#for finding nth term of arithmetic prograssion \ndef term(a, d, n):\n    return a + (d * (n - 1))\n\n#for solvinng quadratic equation\ndef solve_quadratic(a, b, c):\n    return floor((-b + ((b ** 2) - (4 * a * c)) ** .5) / (2 * a))\n\n#for finding nth value of seq 123456789101112.....\ndef extract(n):\n    passed = 0\n    for i in count(1):\n        k = 9 * (10 ** (i - 1)) * i\n        if passed + k >= n:\n            return str(int(10 ** (i - 1) + (n - passed) // i))[int(n - passed) % i]\n        passed += k       \n\ndef solve(n):     \n    n, start, passed = n-1, 1, 0\n    for i in count(1):\n        k = 9 * 10 ** (i - 1)\n        sum_ = find_sum(start, i, k)\n    \n        if passed + sum_ >= n:\n            p = solve_quadratic(i, 2 * start - i, -((n - passed) * 2)) #a, b, c of quad eq\n            q = passed + find_sum(start, i, p) \n            return int(extract(n - q))\n\n        start = term(start, i, k) + (i + 1)\n        passed += sum_\n\n\nsolve(int(1e100))", "def getGreatest(n, d, prefix):\n    rows = 9 * 10**(d - 1)\n    triangle = rows * (d + rows * d) // 2\n    l = 0\n    r = triangle\n    \n    while l < r:\n        mid = l + ((r - l) >> 1)\n        triangle = mid * prefix + mid * (d + mid * d) // 2\n        prevTriangle = (mid-1) * prefix + (mid-1) * (d + (mid-1) * d) // 2\n        nextTriangle = (mid+1) * prefix + (mid+1) * (d + (mid+1) * d) // 2\n        if triangle >= n:\n            if prevTriangle < n:\n                return prevTriangle\n            else:\n                r = mid - 1\n        else:\n            if nextTriangle >= n:\n                return triangle\n            else:\n                l = mid\n        \n    \n    return l * prefix + l * (d + l * d) // 2\n\nns = [\n  1, # 1\n  2, # 1\n  3, # 2\n  100, # 1\n  2100, # 2\n  31000, # 2\n  999999999999999999, # 4\n  1000000000000000000, # 1\n  999999999999999993, # 7\n]\n\n\ndef solve(n):\n    debug = 1\n    d = 0\n    p = 0.1\n    prefixes = [0]\n    sections = [0]\n    \n    while sections[d] < n:\n        d += 1\n        p *= 10\n        rows = int(9 * p)\n        triangle = rows * (d + rows * d) // 2\n        section = rows * prefixes[d-1] + triangle\n        sections.append(sections[d-1] + section)\n        prefixes.append(prefixes[d-1] + rows * d)\n        \n    section = sections[d - 1]\n    n = n - section\n    rows = getGreatest(n, d, prefixes[d - 1])\n    \n    n = n - rows\n    d = 1\n    while prefixes[d] < n:\n        d += 1;\n        \n    if prefixes[d] == n:\n        return 9;\n    \n    prefix = prefixes[d - 1]\n    n -= prefix\n    countDDigitNums = n // d\n    remainder = n % d\n    prev = 10**(d - 1) - 1\n    num = prev + countDDigitNums\n    \n    if remainder:\n        return int(str(num + 1)[remainder - 1])\n    else:\n        s = str(num);\n        return int(s[len(s) - 1])", "import math\n\n\ndef seq_len_formula(s, b, n, i): return s + i * b + n * (i * (i + 1) // 2)\n\n\ndef increasing_step(num_len, block_len, seq_len):\n    num_of_blocks = 9 * 10 ** num_len\n    num_len += 1\n    seq_len = seq_len_formula(seq_len, block_len, num_len, num_of_blocks)\n    block_len = block_len + num_len * num_of_blocks\n    return num_len, block_len, seq_len\n\n\ndef solve(n):\n    buffer = IS_seq_len = 0, 0, 0\n\n    while IS_seq_len[2] < n:\n        num_len, block_len, seq_len = buffer = IS_seq_len\n        IS_seq_len = increasing_step(num_len, block_len, seq_len)\n\n    num_len, init_block_len, init_seq_len = buffer\n    step = 9 * 10 ** num_len\n    num_len += 1\n    buffer = (0, init_seq_len)\n\n    while step > 0:\n        num_of_blocks, seq_len = buffer\n        while seq_len < n:\n            buffer = num_of_blocks, seq_len\n            num_of_blocks += step\n            seq_len = seq_len_formula(init_seq_len, init_block_len, num_len, num_of_blocks)\n        step = round(step / 10)\n\n    n -= buffer[1]\n    buffer = IS_block_len = 0, 0, 0\n\n    while IS_block_len[1] < n:\n        num_len, block_len, seq_len = buffer = IS_block_len\n        IS_block_len = increasing_step(num_len, block_len, seq_len)\n\n    num_len = 10 ** buffer[0] - 1\n    block_len = buffer[1]\n    amount_of_nums = math.ceil((n - block_len) / len(str(num_len + 1)))\n    n = n - amount_of_nums * len(str(num_len + 1)) - block_len - 1\n    num = amount_of_nums + num_len\n\n    return int(str(num)[n])", "def solve(k): \n    k -= 1\n    i, d, p, n, s = 0, 1, 0, 9, 45\n    while i + s <= k:\n        i += s\n        p += n * d\n        d += 1\n        n = 10 ** d - 10 ** (d - 1)\n        s = n * p + n * d * (n + 1) // 2\n    k -= i\n    i = int((((2 * p + d) ** 2 + 8 * k * d) ** 0.5 - (2 * p + d)) / (2 * d))\n    k -= i * p + i * d * (i + 1) // 2\n    i, d, s = 0, 1, 9\n    while i + s <= k:\n        i += s\n        d += 1\n        n = 10 ** d - 10 ** (d - 1)\n        s = n * d\n    q, r = divmod(k - i, d)\n    return int(str(10 ** (d - 1) + q)[r])", "def cumul(n) :\n    return n*(n+1)//2\n\n# length of the line for the n index\ndef length (n) :\n    res = cumul(n)\n    length = len(str(n))\n    i = 1\n    while length>1 :\n        res += cumul (n-(10**i -1))\n        length -=1\n        i+=1\n    return res \n\n\ndef calculindex(d) : \n    if d <= 9 :\n        return d\n    \n    index = index_old = 9     \n    i=0\n    while d> index :\n        index_old = index \n        i+=1\n        index = index_old +  9*(i+1)*10**i        \n    d-= index_old\n    if d%(i+1)== 0 :\n        return (str(10**(i)+d//(i+1) -1)[-1])\n    else :\n        return (str(10**(i)+d//(i+1))[d%(i+1)-1])\n    \n\ndef solve(n):\n    print(n)\n    if n<=2:\n        return 1\n    min = 1\n    max = n\n    val = int(n//2)+1\n    \n    while length(min)< n< length(max) and max-min>1 :\n        if length(val)>n :\n            max,val = val,(val+min)//2\n        elif length(val)< n:\n            min,val = val,(max+val)//2     \n        else :\n            return int(str(val)[-1])    \n    dist = n-length(min)\n    \n    return int(calculindex(dist))", "import math\n\ndef seq_len_formula(s, b, n, i): return s + i * b + n * (i * (i + 1) // 2)\n\ndef point_gen():\n    num_len, block_len, seq_len = 0, 0, 0\n    while True:\n        yield num_len, block_len, seq_len\n        num_of_blocks = 9 * 10 ** num_len\n        num_len += 1\n        seq_len = seq_len_formula(seq_len, block_len, num_len, num_of_blocks)\n        block_len = block_len + num_len * num_of_blocks\n        \ndef linear_search(index, parameter):\n    params = {'block_len': 1, 'seq_len': 2}\n    required_point = 0, 0, 0\n    for point in point_gen():\n        if point[params[parameter]] >= index: return required_point\n        required_point = point\n\ndef index_for_block(num_len, block_len, index):\n    corrector = num_of_blocks = 9 * 10 ** (num_len - 1)\n    seq_len = seq_len_formula(0, block_len, num_len, num_of_blocks)\n    while not seq_len < index <= seq_len_formula(0, block_len, num_len, num_of_blocks + 1):\n        corrector = math.ceil(corrector / 2)\n        num_of_blocks = num_of_blocks - corrector if seq_len >= index else num_of_blocks + corrector\n        seq_len = seq_len_formula(0, block_len, num_len, num_of_blocks)\n    return index - seq_len\n\ndef solve(index):\n    initial_len, initial_block_len, initial_seq_len = linear_search(index, 'seq_len')\n    index = index_for_block(initial_len + 1, initial_block_len, index - initial_seq_len)\n    buffer = linear_search(index, 'block_len')\n    num_len, block_len = 10 ** buffer[0] - 1, buffer[1]\n    amount_of_nums = math.ceil((index - block_len) / len(str(num_len + 1)))\n    return int(str(amount_of_nums + num_len)[index - amount_of_nums * len(str(num_len + 1)) - block_len - 1])", "from math import sqrt, ceil, log10\nimport numpy as np\n\ndef getGreatest(n, d, prefix):\n    rows = 9 * 10**(d - 1)\n    triangle = rows * (d + rows * d) // 2\n    l = 0\n    r = triangle\n \n    while l < r:\n        mid = l + ((r - l) >> 1)\n        triangle = mid * prefix + mid * (d + mid * d) // 2\n        prevTriangle = (mid-1) * prefix + (mid-1) * (d + (mid-1) * d) // 2\n        nextTriangle = (mid+1) * prefix + (mid+1) * (d + (mid+1) * d) // 2\n \n        if triangle >= n:\n            if prevTriangle < n:\n                return prevTriangle\n            else:\n                r = mid - 1\n        else:\n            if nextTriangle >= n:\n                return triangle\n            else:\n                l = mid\n    return l * prefix + l * (d + l * d) // 2\n\ndef findDiff(n, x):\n    mult = 1\n    temp=x/10\n    while temp >= 1:\n        temp /= 10\n        mult *= 10\n    d = round(log10(mult))+1\n    prefixes = 0\n    for z in range(1,d):\n        prefixes += (9*z*10**(z-1))\n    n -= calcSeq(mult-1)\n    return n-getGreatest(n, d, prefixes)\n        \ndef calcSeq(current):\n    x = np.int64(current*(current+1)/2)\n    mult = 10\n    temp=np.int64(current)\n    while temp > 0:\n        temp=current\n        temp -= mult-1\n        mult *= 10\n        if temp> 0: x += np.int64(temp*(temp+1)/2)\n    return x\n            \ndef solve(n): \n    maxN = n\n    minN = 0\n    x = float(0)\n    delta=2\n    prev = 0\n    current = round(sqrt(2*n))\n    prevRight = True\n    while maxN-minN>1:\n        x = calcSeq(current)\n        delta = abs(current-prev)\n        prev = current\n        if x < n and prevRight:\n            current += ceil((maxN-current)/2)\n            prevRight = True\n        elif x < n:\n            minN = current\n            current += ceil((maxN-current)/2)\n            prevRight = True\n        elif x > n and prevRight == False:\n            maxN = current\n            current -= round((current-minN)/2)\n            prevRight = False\n        elif x > n:\n            current -= round((current-minN)/2)\n            prevRight = False\n        else: \n            maxN = current\n            minN = current-1\n    if calcSeq(current) < n: \n        current+=1\n    prev = current-1\n    \n    element = findDiff(n,prev)\n    nDigits, nines = 1, 9\n    total = float(nDigits*nines)\n    while total < element:\n        nDigits += 1\n        nines *= 10\n        total += nDigits*nines \n    total -= nDigits*nines\n    element2 = element-total\n    start = 10**(nDigits-1)\n    number = str(start + ceil(element2/nDigits) - 1)\n    \n    return int(number[(int(element2)-1)%nDigits])", "from math import sqrt, ceil, log10\nimport numpy as np\n\ndef getGreatest(n, d, prefix):\n    rows = 9 * 10**(d - 1)\n    triangle = rows * (d + rows * d) // 2\n    l = 0\n    r = triangle\n \n    while l < r:\n        mid = l + ((r - l) >> 1)\n        triangle = mid * prefix + mid * (d + mid * d) // 2\n        prevTriangle = (mid-1) * prefix + (mid-1) * (d + (mid-1) * d) // 2\n        nextTriangle = (mid+1) * prefix + (mid+1) * (d + (mid+1) * d) // 2\n \n        if triangle >= n:\n            if prevTriangle < n:\n                return prevTriangle\n            else:\n                r = mid - 1\n        else:\n            if nextTriangle >= n:\n                return triangle\n            else:\n                l = mid\n    return l * prefix + l * (d + l * d) // 2\n\ndef findDiff(n, x):\n#print(\"Xdiff=\", x)\n    mult = 1\n    temp=x/10\n    while temp >= 1:\n        temp /= 10\n        mult *= 10\n  #  print(\"sectionMATT=\", calcSeq(mult-1))\n    #print(\"rowMATT=\", calcSeq(x-(mult-1)) )\n    sLen = x-(mult-1)\n    d = round(log10(mult))\n   # print(\"WOW, slen is\", sLen)\n    prefixes = 0\n    for z in range(1,round(d)+1):\n        prefixes += (9*z*10**(z-1))\n    #    print('PROIFFIXES=',prefixes)\n    #print('now N IS THIS ONE? WRONG YET??: NOPE!!!!', n)\n    #print(\"PREFIXED\", prefixes)\n    d+=1\n    #print('D',d)\n   # totEX = int((d + d*(sLen)))\n  #  ort = d*sLen/2*(1+sLen)\n    n -= calcSeq(mult-1)\n   # print('ave Len=', int(d + d*(sLen)), d, sLen )\n    #print(\"pewpewpew, totEXSHOULDNT BE TOO BIG=\",int(totEX*sLen/2), calcSeq(mult-1))\n    temp = getGreatest(n, d, prefixes)\n    #print(\"temp=\", temp)\n    #print(\"DDDD=\",d)\n    #print('theN=', n)\n    \n    #print('theN=', n)\n   # n -= totC\n    #n = int(n/2  + (n - totEX*sLen)/2)#int((int(totEX)*sLen)/2)\n    #for _ in range(sLen+1):\n    #    n -= int(d*sLen/2)\n#    print('theN=', n)\n    return n-temp\n        \ndef calcSeq(current):\n    x = np.int64(current*(current+1)/2)\n    mult = 10\n    temp=np.int64(current)\n    while temp > 0:\n        temp=current\n        temp -= mult-1\n        mult *= 10\n        if temp> 0: x += np.int64(temp*(temp+1)/2)\n    return x\n            \ndef solve(n): \n  #  print([calcSeq(x) for x in [0,9,99,999]])\n    \n    \n    maxN = n\n    minN = 0\n    x = float(0)\n    delta=2\n    prev = 0\n    current = round(sqrt(2*n))\n    prevRight = True\n    while maxN-minN>1:\n        x = calcSeq(current)\n        delta = abs(current-prev)\n        prev = current\n        if x < n and prevRight:\n            current += ceil((maxN-current)/2)\n            prevRight = True\n        elif x < n:\n            minN = current\n            current += ceil((maxN-current)/2)\n            prevRight = True\n        elif x > n and prevRight == False:\n            maxN = current\n            current -= round((current-minN)/2)\n            prevRight = False\n        elif x > n:\n            current -= round((current-minN)/2)\n            prevRight = False\n        else: \n            maxN = current\n            minN = current-1\n    if calcSeq(current) < n: \n        current+=1\n    prev = current-1\n    \n    element = findDiff(n,prev)\n    nDigits, nines = 1, 9\n    total = float(nDigits*nines)\n    while total < element:\n        nDigits += 1\n        nines *= 10\n        total += nDigits*nines \n    \n    total -= nDigits*nines\n    element2 = element-total\n    start = 10**(nDigits-1)\n    number = str(start + ceil(element2/nDigits) - 1)\n    \n    return int(number[(int(element2)-1)%nDigits])"]