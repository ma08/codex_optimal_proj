["class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         longest_streak = 0\n         num_set = set(nums)\n         for num in num_set:\n             if num - 1 not in num_set:\n                 current_num = num\n                 current_streak = 1\n                 \n                 while current_num + 1 in num_set:\n                     current_num += 1\n                     current_streak += 1\n                     \n                 longest_streak = max(longest_streak, current_streak)\n         return longest_streak", "class Solution(object):\n     def radix_sort(self, nums):\n         if not nums:\n             return []\n         n_rounds = 0\n         num_strs = [str(num) for num in nums]\n         n_rounds = max([len(num_str) for num_str in num_strs])\n         buckets = [[] for i in range(10)]\n         for i in range(n_rounds):\n             for num_str in num_strs:\n                 if i < len(num_str):  # get the last ith digit\n                     radix = ord(num_str[-i - 1]) - ord('0')\n                 else:\n                     radix = 0\n                 buckets[radix].append(num_str)\n             num_strs.clear()\n             for bucket in buckets:\n                 num_strs.extend(bucket)\n                 bucket.clear()\n         return [int(num_str) for num_str in num_strs]\n \n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         pos_nums = [num for num in nums if num >= 0]\n         neg_nums = [-num for num in nums if num < 0]\n         pos_nums = self.radix_sort(pos_nums)\n         neg_nums = self.radix_sort(neg_nums)\n         nums = [-num for num in reversed(neg_nums)] + pos_nums\n         n = 1\n         max_n = 1\n         for i in range(1, len(nums)):\n             if nums[i] - nums[i - 1] == 1:\n                 n += 1\n                 if n > max_n:\n                     max_n = n\n             elif nums[i] == nums[i - 1]:\n                 continue\n             else:\n                 n = 1\n         return max_n\n", "class Solution:\n     def longestConsecutive(self, a):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         nums = set(a)\n         maxlen = 0\n \n         while nums:\n             first = last = nums.pop()\n             while first - 1 in nums:\n                 first -= 1\n                 nums.remove(first)\n \n             while last + 1 in nums:\n                 last += 1\n                 nums.remove(last)\n \n             maxlen = max(maxlen, last - first + 1)\n \n         return maxlen\n", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         # init dict, set default to 0\n         length_dict = {key: 0 for key in nums}\n         longest = 0\n         \n         for i in nums:\n             #print(\"i = \"+str(i))\n             if length_dict[i]:\n                 #print(\"skip \"+str(i)) # already done\n                 continue\n             \n             length = 1\n             length_dict[i] = 1\n             #print(length_dict)\n             \n             j = i + 1\n             while j in length_dict:\n                 #print(\"+:\"+str(j))\n                 length_dict[j] = 1\n                 length += 1\n                 j += 1\n             \n             j = i - 1\n             while j in length_dict:\n                 #print(\"-:\"+str(j))\n                 length_dict[j] = 1\n                 length += 1\n                 j -= 1\n             \n             longest = max(longest, length)\n         \n         return longest\n", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         \n         if len(nums) == 0:\n             return 0\n         \n         seen = set()\n         heads = set()\n         tails = set()\n         forward = dict()\n         reverse = dict()\n         \n         for n in nums:\n             \n             if n in seen:\n                 continue\n             else:\n                 seen.add(n)\n             \n             if n-1 not in tails and n+1 not in heads:\n                 heads.add(n)\n                 tails.add(n)\n                 forward[n] = n\n                 reverse[n] = n\n             \n             if n-1 not in tails and n+1 in heads:\n                 heads.remove(n+1)\n                 heads.add(n)\n                 tail = forward[n+1]\n                 del forward[n+1]\n                 forward[n] = tail\n                 reverse[tail] = n\n             \n             if n-1 in tails and n+1 not in heads:\n                 tails.remove(n-1)\n                 tails.add(n)\n                 head = reverse[n-1]\n                 del reverse[n-1]\n                 reverse[n] = head\n                 forward[head] = n\n             \n             if n-1 in tails and n+1 in heads:\n                 head = reverse[n-1]\n                 tail = forward[n+1]\n                 heads.remove(n+1)\n                 tails.remove(n-1)\n                 del forward[n+1]\n                 del reverse[n-1]\n                 forward[head] = tail\n                 reverse[tail] = head\n         \n         \n         diffs = [v - k + 1 for (k,v) in list(forward.items())]\n         maxRun = max(diffs)\n         \n         return maxRun\n                 \n                 \n                 \n             \n", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         flag_map = {}\n         for x in nums:\n             flag_map[x] = False\n         \n         result = 0\n         for x in nums:\n             count = 1\n             tmp = x + 1\n             flag_map[x] = True\n             while True:\n                 if tmp in flag_map and not flag_map[tmp]:\n                     count = count + 1\n                     flag_map[tmp] = True\n                     tmp = tmp + 1\n                 else:\n                     break\n                     \n             tmp = x - 1\n             while True:\n                 if tmp in flag_map and not flag_map[tmp]:\n                     count = count + 1\n                     flag_map[tmp] = True\n                     tmp = tmp - 1\n                 else:\n                     break\n                     \n             result = max(result, count)\n             \n         return result", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         from collections import Counter\n         def find(x,maps):\n             if x in maps:\n                 maps[x]=find(maps[x],maps)\n             else:\n                 return x\n             return maps[x]\n         def join(x,y,maps):\n             i,j=find(x,maps),find(y,maps)\n             if i!=j:\n                 if i<j:\n                     maps[j]=i\n                 else:\n                     maps[i]=j\n         if not nums:\n             return 0\n         visited={}\n         maps={}\n         for i in nums:\n             if i in visited:\n                 continue\n             if i not in visited and i-1 in visited:\n                 join(i-1,i,maps)\n             if i not in visited and i+1 in visited:\n                 join(i+1,i,maps)\n             if i not in visited:\n                 visited[i]=1\n         if not maps:\n             return 1\n         for key in list(maps.keys()):\n             join(maps[key],key,maps)\n         d=Counter(list(maps.values()))\n         return max(d.values())+1\n", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         nums = set(nums)\n         best = 0\n         for x in nums:\n             if x - 1 not in nums:\n                 y = x + 1\n                 while y in nums:\n                     y += 1\n                 best = max(best, y - x)\n         return best\n             \n", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         s = set(nums)\n         \n         longest = 0\n         for i in s: \n             if(i-1 in s):\n                 continue\n             sequence = 1\n             num = i\n             while(num+1 in s):\n                 sequence += 1\n                 num += 1\n             longest = max(longest, sequence)\n             \n         return longest", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         max_count = 0\n         s = set(nums)\n         for i in nums:\n             cnt = 1\n             tmp = i-1\n             while tmp in s:\n                 cnt += 1\n                 s.discard(tmp)\n                 tmp -= 1\n                 \n             tmp = i+1\n             while tmp in s:\n                 cnt += 1\n                 s.discard(tmp)\n                 tmp += 1\n             \n             max_count = max(max_count, cnt)\n             \n         return max_count\n", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         \n         longest = 1\n         current = 1\n         \n         nums.sort()\n         \n         n = len(nums)\n         for i in range(1, n):\n             if nums[i] != nums[i-1]:\n                 if nums[i] == nums[i-1] + 1:\n                     current += 1\n                 else:\n                     longest = max(longest, current)\n                     current = 1\n                     \n         return max(longest, current)\n", "class Solution(object):\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         if not nums:\n             return 0\n         nums_set = set(nums)  # dedup and build a map for fast lookup\n         # remove numbers which are not connected with any other numbers\n         for num in list(nums_set):\n             if (num - 1) not in nums_set and (num + 1) not in nums_set:\n                 nums_set.remove(num)\n \n         # now nums_set only contains groups of consecutive numbers\n         # calculate the size of each group and find the largest group\n         max_group_size = 1\n         while nums_set:\n             num = nums_set.pop()\n             group_size = 1\n             prev_num = num - 1\n             while prev_num in nums_set:\n                 group_size += 1\n                 nums_set.remove(prev_num)\n                 prev_num -= 1\n             next_num = num + 1\n             while next_num in nums_set:\n                 group_size += 1\n                 nums_set.remove(next_num)\n                 next_num += 1\n             if group_size > max_group_size:\n                 max_group_size = group_size\n         return max_group_size\n", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         nums.sort()\n         max_length = 0\n         count =0\n         \n         for idx, v in enumerate(nums):\n             \n             if count==0:\n                 count+=1\n                 max_length=max(max_length,count)\n             if idx+1<len(nums):\n                 n_v = nums[idx+1]\n                 \n                 if n_v==v+1:\n                     count=count+1 \n                 elif n_v==v:\n                     continue\n                     \n                     \n                 else:\n                     max_length=max(max_length,count)\n                     count = 0\n         #deal with the end \n         max_length=max(max_length,count)\n         return max_length\n                 \n                 \n", "class Solution:\n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n         def union(uf, p, q):\n             i, j = root(uf, p), root(uf, q)\n             uf[i], uf[j] = min(i, j), min(i, j)\n         def root (uf, p):\n             while p != uf[p]:\n                 uf[p] = uf[uf[p]]\n                 p = uf[p]\n             return p\n         if len(nums) == 0:\n             return 0\n         ht = {}\n         uf = [i for i in range(len(nums))]\n         for i, n in enumerate(nums):\n             if n not in ht:\n                 ht[n] = i\n             else:\n                 continue\n             m, o = n - 1, n + 1\n             if m in ht:\n                 union(uf, ht[m], i)\n             if o in ht:\n                 union(uf, ht[o], i)\n         roots = {}\n         for x in uf:\n             r = root(uf, x)\n             if r in roots:\n                 roots[r] += 1\n             else:\n                 roots[r] = 1\n         return max(roots.values())\n", "class Solution:\n     \n     def longestConsecutive(self, nums):\n         \"\"\"\n         :type nums: List[int]\n         :rtype: int\n         \"\"\"\n \n         # unique elms in list\n         elms = set()\n \n         # prevent dup. effort during consecutive search\n         visited = set()\n         max_consecutive = 0\n \n         for num in nums:\n \n             elms.add(num)\n \n         # look for all unique consecutive subsequences\n         for num in nums:\n \n             if num in visited:\n \n                 continue\n \n             visited.add(num)\n \n             # elm by itself\n             curr_consecutive = 1\n             tmp = num - 1\n \n             # number of consecutive elms before\n             # this elm\n             while tmp in elms:\n \n                 visited.add(tmp)\n                 curr_consecutive += 1\n                 tmp -= 1\n \n             tmp = num + 1\n \n             # number of consecutive elms after\n             # this elm\n             while tmp in elms:\n \n                 visited.add(tmp)\n                 curr_consecutive += 1\n                 tmp += 1\n \n             if curr_consecutive > max_consecutive:\n \n                 max_consecutive = curr_consecutive\n \n         return max_consecutive\n \n"]