["def rat_at(n):\n    if n == 0:\n        return 1, 1\n    a, b = rat_at((n - 1) // 2)\n    return (a, a + b) if n % 2 else (a + b, b)\n\ndef index_of(a, b):\n    if a == b == 1:\n        return 0\n    return 2 * index_of(a, b - a) + 1 if b > a else 2 * index_of(a - b, b) + 2", "from math import ceil\ndef rat_at(n):\n    if n==0:return (1,1)\n    a,b=rat_at(max(ceil(n/2)-1,0))\n    return (a,b+a) if n%2 else (a+b,b)\n\ndef index_of(a,b):\n    if a==b==1:return 0\n    elif a<b:return index_of(a,b-a)*2+1\n    else: return (index_of(a-b,b)+1)*2", "seq = {0: 1, 1:1}\n\ndef fusc(n):\n    if n in list(seq.keys()):\n        return seq[n]\n    elif n%2 == 0:\n        r = fusc(n>>1) \n        seq[n] = r\n        return r    \n    return fusc((n - 1)>>1) + fusc((n + 1)>>1)\n\n\ndef rat_at(n):    \n    return fusc(n + 1), fusc(n+2)\n\ndef index_of(p, q):\n    bits = ''\n    while p > 1 or q >1:\n        if p>q:\n            bits = \"1\"+ bits\n            p = p-q\n        else:\n            bits = \"0\"+bits\n            q = q-p\n    bits = \"1\" + bits\n    return int(bits, 2)-1\n", "def rat_at(n):\n    if not n: return (1,1)\n    base = 0\n    i = n + 1\n    while i!=1:\n      i= i>>1\n      print(i)\n      base+=1\n    path = str(bin(n - 2**(base)  + 1 ))[2:]\n    path = '0'*(base-len(path)) + path # buffer left side w/ 0s\n    a=b=1\n    path = [x=='1' for x in path]\n    for p in path:\n      if p: a += b\n      else: b += a\n    return (a,b)\n\n\ndef index_of(a, b):\n    if a==b==1: return 0\n    path = \"\"\n    while a!=1 or b!=1:\n      if a>b: # from the left, going right\n        a-=b\n        path = \"1\" + path\n      else: # from the right, going left\n        b-=a\n        path = \"0\" + path\n    base = 2**len(path) - 2  #int('1'*(count),2)\n    addon = int(path,2)+1\n    return base + addon", "def rat_at(n):\n    n = bin(n + 1)\n    s = 1\n    f = []\n    if n[len(n) - 1] == '0':\n        f.append(0)\n    for i in range(len(n) - 1, 1, -1):\n        if n[i] != n[i-1]:\n            f.append(s)\n            s = 1\n        else:\n            s += 1\n    num = [1, f[len(f) - 1]]\n    for i in range(len(f) - 2, -1, -1):\n        num[0] = f[i] * num[1] + num[0]\n        num[0], num[1] = num[1], num[0]\n    num[0], num[1] = num[1], num[0]\n    return tuple(num)\n\n\ndef index_of(a, b):\n    num = [b, a]\n    f = []\n    bin = ''\n    l = '1'\n    while num[0] != 0:\n        num[0], num[1] = num[1], num[0]\n        f.append(num[0] // num[1])\n        num[0] -= f[len(f) - 1] * num[1]\n    if len(f) % 2 == 0:\n        f[len(f) - 1] -= 1\n        f.append(1)\n    for n in f:\n        bin = (n * l) + bin\n        if l == '0':\n            l = '1'\n        else:\n            l = '0'\n    return int(bin, 2) - 1\n", "# This is not my code :,(\n# I used those functions from here http://240hoursoflearning.blogspot.com/2017/09/the-calkin-wilf-tree.html\n# Shame and dishonor on me :,( \n\ndef rat_at(n):\n    # This is not my code :,(\n    frac = [0, 1]\n    n += 1\n    nums = [n]\n\n    while n > 0:\n        n = n//2\n        nums.append(n)\n\n    for n in reversed(nums):    \n        if n%2!=0:\n            frac[0] += frac[1]\n\n        else:\n            frac[1] += frac[0]\n    \n    return tuple(frac)\n\n\n\ndef index_of(a, b):\n    # This is not my code :,(\n    if [a, b] == [1, 1]:\n        return 0\n\n    path = ''\n\n    while [a, b] != [1, 1]:\n        if a < b:\n            b -= a\n            path += '0'\n        else:\n            a -= b\n            path += '1'\n    addForDepth = 2**len(path)-1\n\n    return addForDepth + int(path[::-1], 2)\n\n\n", "import math\n\ndef rat_at_layer_pos(layer, pos):\n    if layer==pos==0:\n        return (1,1)\n    else:\n        a,b = rat_at_layer_pos(layer-1,pos//2)\n        return (a,a+b) if pos%2==0 else (a+b,b)\n\ndef rat_at(n):\n    layer = len(bin(n+1))-3 if n>0 else 0\n    pos = n - int(2**layer-1)\n    print(layer, pos)\n    return rat_at_layer_pos(layer, pos)\n\ndef index_layer_pos(a,b):\n    if a==b==1:\n        return 0,0\n    if a>b:\n        l, p = index_layer_pos(a-b,b)\n        return l+1, p*2+1\n    else:\n        l, p = index_layer_pos(a,b-a)\n        return l+1, p*2\n\ndef index_of(a, b):\n    l, p = index_layer_pos(a,b)\n    return (2**l-1)+p", "def rat_at(n):\n    if n == 0:\n        return 1,1\n    # find line\n    line = 1\n    tot = 0\n    while tot <= n:\n        tot += 2**line\n        line += 1\n    if line > 1:\n        line -= 1\n    route = ''\n    b = 2**line # nr of elements in the line\n    pos = n+1 - 2**line # pos in the line\n    while b > 1:\n        if pos < b // 2:\n            route += 'l'\n            b = b // 2\n            # pos does not change\n        else:\n            route += 'r'\n            b = b // 2\n            pos -= b\n    a, b = 1, 1\n    for c in route:\n        if c == 'l':\n            a, b = a, a+b\n        else:\n            a, b = a+b, b\n    return a,b\n\ndef index_of(a, b):\n    aa = a\n    bb = b\n    route = ''    \n    while not (aa == 1 and bb == 1):\n        if aa > bb:\n            aa = aa-bb\n            route = 'r' + route \n        else:\n            bb = bb-aa\n            route = 'l' + route\n    above = 0\n    for i in range(len(route)):\n        above += 2**i  \n    pos = [0,2**len(route)-1]\n    for c in route:\n        if c == 'l':\n            pos[1] = pos[1] - (pos[1]+1 - pos[0]) // 2\n        else:\n            pos[0] = pos[0] + (pos[1]+1 - pos[0]) // 2\n    print((\"a: {0}, b: {1}, above: {2}, pos: {3}, route: {4}\".format(a,b, above, pos, route)))\n    return above+pos[0]\n    \n", "def rat_at(n):\n    if n == 0:\n        return (1, 1)\n    for l in range(1001):\n        if 2 ** l - 1 <= n <= 2 ** (l + 1) - 2:\n            i = l\n            break\n    if n % 2 == 1:\n        j = int((n - (2 ** i - 1)) / 2 + 2 ** (i - 1) - 1)\n        k = rat_at(j)\n        return (k[0], k[0] + k[1])\n    else:\n        j = int((n - (2 ** i)) / 2 + 2 ** (i - 1) - 1)\n        k = rat_at(j)\n        return (k[0] + k[1], k[1])\n\n\ndef index_of(a, b):\n    if (a, b) == (1, 1):\n        return 0\n    if a > b:\n        n = index_of(a - b, b)\n        k = n\n        for l in range(1001):\n            if 2 ** l - 1 <= n <= 2 ** (l + 1) - 2:\n                i = l\n                break\n        return k + ((k - (2 ** i - 1)) * 2 + 1 + (2 ** (i + 1) - 1 - k))\n    else:\n        n = index_of(a, b-a)\n        k = n\n        for l in range(1001):\n            if 2 ** l - 1 <= n <= 2 ** (l + 1) - 2:\n                i = l\n                break\n        return k + ((k - (2 ** i - 1)) * 2 + 1 + (2 ** (i + 1) - 1 - k)) -1\n", "def rat_at(n):\n    if n==0: return (1,1)\n    a,b=rat_at(~-n>>1)\n    return (a,a+b) if n%2 else (a+b,b)\n\n\ndef index_of(a,b):\n    if a==1==b: return 0\n    return 2*index_of(a,b-a)+1 if a<b else 2*index_of(a-b,b)+2\n"]