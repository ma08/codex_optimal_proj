["class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        mn = -1\n        mx = 0\n        sm = 0\n        cnt = 0\n        mode_i = 0\n        mode_cnt = 0\n        indexes = collections.deque()\n        median_count = 0\n        \n        for i, c in enumerate(count):\n            sm += i * c\n            cnt += c\n            \n            mode_i = i if mode_cnt < c else mode_i\n            mode_cnt = c if mode_cnt < c else mode_cnt\n            \n            if c:\n                mx = i\n                if mn == -1:\n                    mn = i\n                while indexes and median_count + count[indexes[0]] < cnt / 2:\n                    median_count += count[indexes[0]]\n                    indexes.popleft()\n                indexes.append(i)\n                \n        median = 0\n        \n        if cnt % 2:\n            median = indexes[0]\n        elif count[indexes[0]] + median_count > cnt // 2:\n            median = indexes[0]\n        else:\n            median = (indexes[0] + indexes[1]) / 2\n            \n        return mn, mx, sm / cnt, median, mode_i", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        N = sum(count)\n        total = 0\n        c = 0\n        median = pre=post=-1\n        mm = 256\n        MM = -1\n        mode = (-1, -1)\n        for i in range(len(count)):\n            total += count[i]*i\n            c += count[i]\n            if count[i]:\n                mm = min(mm, i)\n                MM = max(MM, i)\n                mode = max(mode, (count[i], i))\n            if median<0:\n                \n                if c>=N/2:\n                    if N%2:\n                        pre = post = i\n                    else:\n                        if c == N/2:\n                            pre = i\n                        elif pre>0:\n                            post = i\n                        else:\n                            pre=post = i\n                if pre>0 and post>0:\n                    median = (pre+post)/2\n            \n        mean = total / N\n        \n        return [mm,MM,mean, median, mode[1]]\n", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        sosohang=0\n        sobenhat=0\n        solonnhat=0\n        tong=0\n        for i in range(0,len(count)):\n            if count[i]!=0:\n                sobenhat=i\n                break\n        for i in range(len(count)-1,-1,-1):\n            if count[i]!=0:\n                solonnhat=i\n                break\n        mode=0\n        for i in range(0,len(count)):\n            sosohang+=count[i]\n            if count[i]>count[mode]:\n                mode=i\n            tong+=(count[i]*i)\n        dem=0\n        print(sosohang)\n        print(tong)\n        mean=tong/sosohang\n        if sosohang%2==0:\n            vitri1=sosohang//2\n            vitri1_bool=False\n            vitri2=sosohang//2+1\n            vitri2_bool=False\n            median=0\n            \n            for i in range(0,len(count)):\n                dem+=count[i]\n                if vitri2_bool==True and vitri1_bool==True:\n                    break\n                if dem>=vitri1 and vitri1_bool==False:\n                    median+=i\n                    \n                    vitri1_bool=True\n                if dem>=vitri2 and vitri2_bool==False:\n                    median+=i\n                    \n                    vitri2_bool=True\n                \n            \n            return [float(sobenhat),float(solonnhat),float(mean),float(median/2),float(mode)]\n        else:\n            median=0\n            \n            for i in range(0,len(count)):\n                dem+=count[i]\n                if dem>=(sosohang//2+1):\n                    median+=i\n                   \n                    break\n            \n            return [float(sobenhat),float(solonnhat),float(mean),float(median),float(mode)]\n            \n                \n", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        ans =[]\n        #Min\n        for i in range(0,len(count)):\n            if count[i] != 0:\n                ans.append(i)\n                break\n        #Max\n        for i in range(len(count)-1,0,-1):\n            if count[i] != 0:\n                ans.append(i)\n                break\n        #Mean\n        s = 0\n        for i in range(0,len(count)):\n            s += i * count[i]    \n        total = sum(count)\n        ans.append(s / total)\n        #Median\n        total = sum(count)\n        if total % 2 == 0:\n            total = total // 2\n            for i in range(0,len(count)):\n                total = total - count[i]\n                if total == 0:\n                    med = (i + i+1)/2\n                    ans.append(med)\n                    break\n                if total < 0:\n                    med = i\n                    ans.append(med)\n                    break\n        else:\n            total = total // 2\n            for i in range(0,len(count)):\n                total = total - count[i]\n                #print(total)\n                if total <= 0 :\n                    med = (i)\n                    ans.append(med)\n                    break\n        #Mode\n        ans.append(max(range(len(count)), key=count.__getitem__))\n        return ans", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        d = {}\n        mini = None\n        sample_size = total = 0\n        mode = (-1, -1)\n        for n, freq in enumerate(count):\n            if freq:\n                maxi = n\n                if mini is None:\n                    mini = n\n                sample_size += freq\n                total += n * freq\n                d[sample_size] = n\n            if freq > mode[1]:\n                mode = (n, freq)\n        d = {k:v for k, v in d.items() if k >= sample_size / 2}\n        median = d[min(d)]\n        if sample_size % 2 == 0 and sample_size / 2 in d:\n            del d[min(d)]\n            median += d[min(d)]\n            median /= 2\n        return [mini, maxi, total/sample_size, median, mode[0]]", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        minimum = len(count)\n        maximum = 0\n        sumValues = 0\n        for i, value in enumerate(count):\n            if value != 0:\n                minimum = min(i, minimum)\n                maximum = max(i, maximum)\n                sumValues += i * value\n            if value == max(count):\n                mode = i\n                \n        mean = sumValues / sum(count)\n        \n        if len(count) % 2 == 0:\n            lowMid = sum(count) // 2\n            upMid = lowMid + 1\n            currentCount = 0\n            median = 0\n            for i, e in enumerate(count):\n                currentCount += e\n                if currentCount >= lowMid and median == 0:\n                    median += i / 2\n                if currentCount >= upMid:\n                    median += i / 2\n                    break\n        else:\n            mid = (sum(count) // 2) + 1\n            currentCount = 0\n            median = 0\n            for i, e in enumerate(count):\n                currentCount += e\n                if currentCount >= mid:\n                    median += i\n                    break\n        \n        return [minimum, maximum,  mean, median, mode]\n", "from bisect import bisect\nclass Solution:\n    def sampleStats(self, counts: List[int]) -> List[float]:\n        n = sum(counts)\n        minimum = next(i for i in range(len(counts)) if counts[i])\n        maximum = next(i for i in range(len(counts)-1,-1,-1) if counts[i])\n        mean = sum(i*counts[i] for i in range(1,256)) / n\n        mode = float(counts.index(max(counts)))\n        for i in range(1,256):\n            counts[i] += counts[i-1]\n        median = 0.5*(bisect(counts,n/2) + bisect(counts,(n-1)/2))\n        return [minimum, maximum, mean, median, mode]", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        ans = [-1, -1, -1, -1, -1]\n        \n        for i in range(256):\n            if count[i]>0:\n                ans[0] = i\n                break\n        \n        for i in range(255, -1, -1):\n            if count[i]>0:\n                ans[1] = i\n                break\n        \n        s, n = 0, 0\n        \n        for i in range(256):\n            s += i*count[i]\n            n += count[i]\n        \n        ans[2] = s/n\n        \n        if n%2==0:\n            acc = 0\n            m1, m2 = -1, -1\n            \n            for i in range(256):\n                acc += count[i]\n                \n                if acc>=n//2 and m1==-1:\n                    m1 = i\n                \n                if acc>=n//2+1 and m2==-1:\n                    m2 = i\n                    break\n                \n            ans[3] = (m1+m2)/2\n        else:\n            acc = 0\n            \n            for i in range(256):\n                acc += count[i]\n                \n                if acc>=n//2+1:\n                    ans[3] = i\n                    break\n        \n        M = 0\n        \n        for i in range(256):\n            if count[i]>M:\n                M = count[i]\n                ans[4] = i\n        \n        return ans", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        mini = -1\n        maxi = 0.0\n        mode = 0.0\n        biggest = 0\n        total = sum(count)\n        mid = total // 2 if total != 1 else 1\n        median = 0.0\n        accumulator = 0\n        tally = 0\n        nums = 0\n        \n        for i, num in enumerate(count):\n            if not num:\n                continue\n            else:\n                maxi = float(i)\n                tally += num*i\n                \n            if mini == -1 and num:\n                mini = float(i)\n            if num > biggest:\n                biggest = num\n                mode = float(i)\n            \n            if total % 2:  # odd\n                if accumulator < mid and (accumulator + num) >= mid:\n                    median = float(i)\n            else:          # even\n                if accumulator < mid-1 and (accumulator + num) >= mid-1:\n                    median = float(i)\n                elif num and accumulator == mid:\n                    median = (median+i)/2\n            accumulator += num\n        return [mini, maxi, tally/accumulator, median, mode]\n", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        Min = len(count)\n        Max = 0\n        Sum = 0\n        Num = 0\n        curr_count = count[0]\n        for i in range(len(count)):\n            if count[i] != 0:\n                Min = min(i, Min)\n                Max = max(i, Max)\n                Sum += i * count[i]\n                Num += count[i]\n                Mean = Sum / Num\n                if count[i] > curr_count:\n                    curr_count = count[i]\n                    Mod = i * 1.0\n        total = Num // 2\n        if Num % 2 == 0:\n            for i in range(Min,Max+1):\n                total = total - count[i]\n                if total == 0:\n                    Med = (2*i+1)/2\n                    break\n                if total < 0:\n                    Med = i\n                    break\n        else:\n            for i in range(Min,Max+1):\n                total = total - count[i]\n                if total <= 0 :\n                    Med = (i)\n                    break\n                \n        return [float(Min), float(Max), Mean, Med, Mod]\n", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        tmp_ = [sum(count[:i + 1]) for i in range(256)]\n        return [next(i for i in range(256) if count[i]) * 1.0, \n                next(i for i in range(255, -1, -1) if count[i]) * 1.0, \n                sum(i * v for i, v in enumerate(count)) / sum(count) * 1.0, \n                (bisect.bisect(tmp_, (sum(count) - 1) / 2) + bisect.bisect(tmp_, sum(count) / 2)) / 2.0, \n                float(count.index(max(count)))\n                ]\n", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        output = []\n        output.append([i for i, x in enumerate(count) if x][0])\n        output.append([i for i, x in enumerate(count) if x][-1])\n        nums = sum(count)\n        total = 0\n        for i, x in enumerate(count):\n            if x:\n                total += i * x\n        output.append(total/nums)\n        if nums % 2 == 0:\n            curr = 0\n            first = ((nums - 2) // 2)\n            second = first + 1\n            print(first, second)\n            firstNum, secondNum = None, None\n            for i, x in enumerate(count):\n                if x:\n                    curr += x\n                if not firstNum and curr > first:\n                    firstNum = i\n                if curr > second:\n                    secondNum = i\n                if secondNum:\n                    output.append((firstNum + secondNum)/ 2)\n                    break\n                        \n        else:\n            curr = 0\n\n            for i, x in enumerate(count):\n                if x:\n                    curr += x\n                if curr >= (nums - 1) // 2:\n                    output.append(i)\n                    break\n        output.append(count.index(max(count)))\n        return output", "class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        n=sum(count) \n        sm=0 \n        curr=0\n        mx=0 \n        mode=-1\n        minim=-1 \n        maxim=-1\n        mid1,mid2=-1,-1\n        for i in range(256):\n            curr+=count[i]\n            sm+=(i*count[i]) \n            if mid1==-1 and curr>=n//2:\n                mid1=i \n            if mid2==-1 and curr>=n//2+1:\n                mid2=i \n            if count[i]>mx:\n                mode=i \n                mx=count[i] \n            if minim==-1 and count[i]!=0:\n                minim=i \n            if count[i]!=0:\n                maxim=i \n        mean=sm/n \n        if n%2==0:\n            median=(mid1+mid2)/2 \n        else:\n            median=mid1\n        ans=[round(minim,5),round(maxim,5),round(mean,5),round(median,5),round(mode,5)]\n        return ans \n"]