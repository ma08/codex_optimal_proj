["def least_bribes(bribes):\n    mem = {}\n    def s(n1, n2):\n        if n1 >= n2: return 0\n        if (n1, n2) in mem: return mem[n1, n2]\n        r = min(bribes[i] + max(s(n1, i), s(i + 1, n2)) for i in range(n1, n2))\n        mem[n1, n2] = r\n        return r\n    return s(0, len(bribes))", "def memoize(f):\n    memo = {}\n    def memoized(*args):\n        if not args in memo:\n            memo[args] = f(*args)\n        return memo[args]\n    return memoized\n    \ndef least_bribes(bribes):\n\n    @memoize\n    def f(i, j):\n        assert i <= j\n        if i == j: return 0\n        if i + 1 == j: return bribes[i]\n        return min(max(f(i, k),f(k + 1, j)) + bribes[k] for k in xrange(i, j))\n\n    return f(0, len(bribes))", "history = {}\n\ndef least_bribes(bribes):\n    nonlocal history\n    \n    history = {}\n    \n    return worst_case(0, len(bribes)-1, bribes)\n\ndef worst_case(s, e, bribes):\n\n    nonlocal history\n    \n    length = e - s + 1\n    \n    if length == 0:\n        return 0\n        \n    elif length == 1:\n        return bribes[s]\n        \n    elif length == 2:\n        return bribes[s]+bribes[s+1]\n        \n    elif length == 3:\n        return max([bribes[s]+bribes[s+1], bribes[s+1]+bribes[s+2]])\n        \n    else:\n        key = str(s) + \"_\" + str(e)\n        \n        if not key in history:\n            worst = []\n            for i in range(length):\n                worst.append(max([worst_case(s, s+i-1, bribes)+bribes[s+i], worst_case(s+i+1, e, bribes)+bribes[s+i]]))\n            history[key] = min(worst)\n            \n        return history[key]\n        \n", "def least_bribes(bribes):\n    # worst[k][i] is the minimal amount of bribes spent in the worst case\n    # for a subarray of length k beginning at index i.\n    worst = [[0] * (len(bribes) + 1)]\n    for k in range(1, len(bribes) + 1):\n        #worst.append([min(bribes[j] + max(worst[j-i][i], worst[i+k-j-1][j+1]) for j in range(i, i + k)) for i in range(len(bribes) - k + 1)])\n        worst.append([min(bribes[i+j] + max(worst[j][i], worst[-j-1][i+j+1]) for j in range(k)) for i in range(len(bribes) - k + 1)])\n    return worst[-1][-1]", "def memoize(f):\n    memo = {}\n    def memoized(*args):\n        if not args in memo:\n            memo[args] = f(*args)\n        return memo[args]\n    return memoized\n    \ndef least_bribes(xs):\n    @memoize\n    def f(i, j):\n        return i - j and min(max(f(i, k), f(k + 1, j)) + xs[k] for k in range(i, j))\n    return f(0, len(xs))", "from functools import lru_cache\n\ndef least_bribes(bribes):\n    \n    @lru_cache(maxsize=10000)\n    def _rec(lst):\n        if len(lst) <= 2:\n            return sum(lst)\n        return min(max(_rec(lst[:i]), _rec(lst[i+1:])) + lst[i] for i in range(1, len(lst)-1))\n    \n    return _rec(tuple(bribes))", "def least_bribes(bribes):\n    d = dict()\n    result = dp_worst_case(d, 0, len(bribes) - 1, bribes)\n    return result\n    \ndef dp_worst_case(d, start, end, l):\n    # DP to re-use results\n    if start in d:\n        if end in d[start]:\n            return d[start][end]\n            \n    diff = end - start\n    \n    if diff == 0:\n        return l[start]\n    elif diff == 1:\n        return l[start] + l[end]\n    elif diff == 2:\n        # For 3 doors, the worst case is having to open 2 (doors [2,1] or [2,3]). You never have to open 3.\n        return max([l[start+1] + l[start], l[start+1] + l[end]])\n    else:\n        anchor_wc_list = list()\n        # Iterate over every anchor door ...\n        for i in range(diff + 1):\n            # ... except the first and last one of a (sub)list (they don't have to be visited \"first\")\n            if i == 0 or i == diff:\n                continue\n            else:\n                # work on the nonlocal list scale instead of the local loop list scale\n                anchor = start + i\n                # get left and right \"branch\" worst cases for the resp. anchor\n                wcleft = l[anchor] + dp_worst_case(d, start, anchor - 1, l)\n                wcright = l[anchor] + dp_worst_case(d, anchor + 1, end, l)\n                # find the \"worse\" worst case of the left and right branch\n                anchor_wc_list.append(max([wcleft, wcright]))\n        # the result is the \"best\" worst case for all anchors\n        result = min(anchor_wc_list)\n        \n        # save results for DP\n        if start in d:\n            d[start][end] = result\n        else:\n            d[start] = dict()\n            d[start][end] = result\n        return result", "__author__ = 'Andy Hawkins'\n__email__ = 'andy+codewars@hawkins.tech'\n\ndef returnTrue(*a):\n    test.expect(True)\n    \ntest.assert_equals = returnTrue\n\ndef least_bribes(bribes):\n    # Hack The Planet!\n    return 0", "M = {}\nleast_bribes = lambda b: bribes(tuple(b))\n\ndef bribes(b):\n    if b not in M:\n        M[b] = sum(b) if len(b) < 3 else max(b[0],b[-1])+b[1] if len(b) == 3 else min(b[i] + max(bribes(b[:i]), bribes(b[i+1:])) for i in range(1,len(b)-1))\n    return M[b]", "from math import floor, ceil\n\ndef least_bribes(bribes):\n    bribes_len = len(bribes)\n    halfway = (bribes_len - 1) / 2\n    solved_bribes = set()\n    bribe_dict = {}\n    part_stack = [(0, bribes_len, floor(halfway), ceil(halfway))]\n    while part_stack:\n        start, end, left, right = part_stack.pop()\n        \n        if (start, end) in solved_bribes:\n            continue\n        \n        width = end - start\n        if width <= 2:\n            bribe_dict[(start, end)] = sum(bribes[start:end])\n            solved_bribes.add((start, end))\n            continue\n        if width == 3:\n            bribe_dict[(start, end)] = bribes[start + 1] + max(bribes[start:end:2])\n            solved_bribes.add((start, end))\n            continue\n        \n        new_bribe = None\n        missing_bribes = False\n        for pivot in (left, right):\n            neighbor_bribes = [0, 0]\n            for n_i, n_start, n_end in ((0, start, pivot), (1, pivot + 1, end)):\n                if (n_start, n_end) in bribe_dict:\n                    neighbor_bribes[n_i] = bribe_dict[(n_start, n_end)]\n                else:\n                    halfway = n_start + (n_end - n_start - 1) / 2\n                    if not missing_bribes:\n                        part_stack.append((start, end, left, right))\n                        missing_bribes = True\n                    part_stack.append((n_start, n_end, floor(halfway), ceil(halfway)))\n            if missing_bribes:\n                continue\n            bribe_total = bribes[pivot] + max(bribe_dict[(start, pivot)], bribe_dict[(pivot + 1, end)])\n            if not new_bribe or bribe_total < new_bribe:\n                new_bribe = bribe_total\n        \n        if missing_bribes:\n            continue\n        \n        if (start, end) not in bribe_dict or new_bribe < bribe_dict[(start, end)]:\n            bribe_dict[(start, end)] = new_bribe\n        if left > start:\n            part_stack.append((start, end, left - 1, right + 1))\n            continue\n            \n        solved_bribes.add((start, end))\n        \n    return bribe_dict[(0, bribes_len)]"]