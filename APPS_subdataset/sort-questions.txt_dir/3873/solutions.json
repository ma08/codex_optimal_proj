["from functools import reduce\n\ndef product_sans_n(nums):\n    z = nums.count(0)\n    if z > 1: return [0] * len(nums)\n    \n    p = reduce(int.__mul__, (v for v in nums if v))\n    return [not v and p for v in nums] if z else [p//v for v in nums]", "from functools import reduce\n\n\ndef product_sans_n(nums):\n    z, p = nums.count(0), reduce(int.__mul__, (n for n in nums if n))\n    return [0 for _ in nums] if z > 1 else [0 if n else p for n in nums] if z else [p // n for n in nums]", "from functools import reduce\nfrom operator import mul\n\ndef mulsum(xs):\n    return reduce(mul, xs, 1)\n\ndef product_sans_n(nums):\n    nz = nums.count(0)\n    if nz > 1:\n        return [0] * len(nums)\n    elif nz:\n        return [0 if x else mulsum([_f for _f in nums if _f]) for x in nums]\n    xs = mulsum(nums)\n    return [xs // x for x in nums]\n", "from functools import reduce\n# Since it must be less thatn O(n^2) the solution may not involve mul(Array[:]) for each\n# element of Array since mul would be O(n-1) and you would do O(n) calls to mul.\n    \n# Since it must be less thatn O(n^2) the solution may not involve mul(Array[:]) for each\n# element of Array since mul would be O(n-1) and you would do O(n) calls to mul.\n    \n# The only way that occurs to me is calling mul just once [that is O(n)] and then mapping / on the\n# result Array [that is another O(n)], but since the calls are concatenated the final complexity\n# is O(2n)\n\n# Also, since \n\ndef product_sans_n(nums):\n    # The case for two or more zeros is trivial and can be handled separately:\n    # Just a list of N zeroes where N is the length of nums\n    if len([ x for x in nums if x == 0]) > 1:\n        return [0] * len(nums)\n    \n    # Now, if there is only one zero this must be stripped from the product P\n    # The product can be computed by the functool reduce: this is O(n)\n    from operator import mul\n    from functools import reduce\n    onezero = 0 in nums\n    product = reduce(mul, nums if not onezero else nums[:nums.index(0)]+nums[nums.index(0)+1:])\n    \n    # Now, we iterate through the original list dividing the product P by each element\n    # The case of one zero is handled separately\n    # There is only one list traversing with map: this is O(n)\n    if onezero:\n        return list(map((lambda x: 0 if x != 0 else product), nums))\n    else:\n        return list(map((lambda x: product / x), nums))\n    \n    # In the end, the algorithm is O(2*n)\n", "def product_sans_n(l):\n    contains_zeroes = False\n    product = 1\n    for n in l:\n        if n:\n            product *= n\n        elif not contains_zeroes:\n            contains_zeroes = True\n        else:\n            return [0] * len(l)\n    return [0 if n else product for n in l] if contains_zeroes else [product // n for n in l]", "def product_sans_n(nums):\n    zeros, product = 0, 1\n    for n in nums:\n        if n: product *= n\n        else: zeros += 1\n    return [zeros < 2 and\n    (not n and product if zeros else product // n)\n    for n in nums]", "from operator import mul\nfrom functools import reduce\n\ndef product_sans_n(nums):\n    z = nums.count(0)\n    p = 0 if z > 1 else reduce(mul, (x for x in nums if x != 0), 1)\n    return [p//x if x != 0 and z == 0 else\n            p    if x == 0 and z == 1 else\n            0    for x in nums]", "from functools import reduce\n\ndef product_sans_n(nums):\n    s = set(nums)\n    if 0 in s:\n        return [ reduce(int.__mul__, nums[:i] + nums[i+1:]) for i, e in enumerate(nums) ]\n    else: \n        prod = reduce(int.__mul__, nums)\n        return [ prod//n  for n in nums]\n", "from functools import reduce\n\n\ndef product_sans_n(nums):\n    zero, prod = nums.count(0), reduce(int.__mul__, (n for n in nums if n))\n    if zero:\n        return [0 for _ in nums] if zero > 1 else [0 if n else prod for n in nums]\n    return [prod // n for n in nums]", "from itertools import accumulate, chain, islice\nfrom operator import mul\n\ndef product_sans_n(nums):\n    forward = islice(accumulate(chain([1], nums), mul), 0, len(nums), 1)\n    backward = list(accumulate(chain([1], reversed(nums)), mul))[-2::-1]\n    return list(map(mul, forward, backward))\n", "from functools import reduce\ndef product_sans_n(nums):\n    if nums.count(0) > 1:\n        return [0 for i in nums]\n    elif nums.count(0) == 1:\n        prod = reduce(lambda a, b: a*b, [x for x in nums if x!=0])\n        return [0 if i != 0 else prod for i in nums]\n    else:\n        prod = reduce(lambda a, b: a*b, nums)\n        return [prod//i for i in nums]\n", "    #because the output is so huge, output is hidden for the medium and big random tests\n    \nimport numpy  as np\ndef product_sans_n(nums):\n        numLen = len(nums)\n        leftProducts = [None for _ in range(numLen)]\n        rightProducts = [None for _ in range(numLen)]\n        leftRunningProduct = 1\n        rightRunningProduct = 1\n        for i in range(numLen):\n            leftRunningProduct = leftRunningProduct * nums[i]\n            leftProducts[i] = leftRunningProduct\n            rightRunningProduct = rightRunningProduct * nums[numLen-1-i]\n            rightProducts[numLen-1-i] = rightRunningProduct\n\n        result = [None for _ in range(numLen)]\n        for i in range(numLen):\n            product = 1\n            if i > 0:\n                product = product * leftProducts[i-1]\n            if i < numLen-1:\n                product = product * rightProducts[i+1]\n            result[i] = product\n        return result", "\ndef product_sans_n(nums):\n     p = 1\n     zeroes = nums.count(0)\n     for n in nums:\n        if n:\n            p *= n\n     return [zeroes < 2 and (not n and p if zeroes else p // n) for n in nums ]\n", "from functools import reduce\n\ndef product_sans_n(nums):\n    zeroes = nums.count(0)\n    if zeroes >= 2:\n        return [0 for x in nums]\n    elif zeroes == 1:\n        prod = reduce(int.__mul__, (x for x in nums if x != 0))\n        return [0 if x != 0 else prod for x in nums]\n    \n    prod = reduce(int.__mul__, nums)\n    return [prod // x for x in nums]\n", "from functools import reduce\nimport operator\n\ndef product_sans_n(nums):\n    prod = reduce(operator.mul, [x for x in nums if x != 0])\n    zero_count = nums.count(0)\n    for index,value in enumerate(nums):\n        if value != 0 and zero_count != 0:\n            nums[index] = 0\n        elif value == 0 and zero_count > 1:\n            nums[index] = 0\n        elif value == 0:\n            nums[index] = prod\n        else:\n            nums[index] = prod // value\n    return nums", "from functools import reduce\n\ndef product_sans_n(nums):\n    if nums.count(0) > 1: return [0] * len(nums)\n    if nums.count(0) == 1:\n        i = nums.index(0)\n        s = reduce(int.__mul__,nums[:i]+nums[i+1:])\n    t = reduce(int.__mul__,nums)\n    return [ s if x == 0 else t//x for x in nums ]", "import itertools\nimport operator\ndef product_sans_n(l):\n    r=[]\n    p=list(itertools.accumulate(l,operator.mul))[-1]\n    for i in range(len(l)):\n       try:\n           r.append(p//l[i])\n       except:\n           s=1\n           for j in range(len(l)):\n               if i!=j:\n                   s*=l[j]\n           r.append(s)        \n               \n    return r   ", "from functools import reduce\n\ndef product(q):\n    return reduce(int.__mul__, q)\n\ndef product_sans_n(q):\n    if any(not x for x in q):\n        return [product(q[0:i]+q[i+1:]) for i, x in enumerate(q)]\n    else:\n        n = product(q)\n        return [n//x for x in q]", "from numpy import prod\ndef product_sans_n(n):\n  if n.count(0)>1: \n    return [0 for _ in n]\n  p=1\n  for x in n:\n    if x!=0: p*=x\n  if n.count(0)==1:\n    return [0 if x!=0 else p for x in n]\n  return [p//x for x in n]", "from operator import mul\nfrom functools import reduce\n\ndef product_sans_n(numbers):\n    check = reduce(mul, numbers)\n    out = []\n    \n    if not check:\n        for i in range(len(numbers)):\n            c = reduce(mul,numbers[:i]+numbers[i+1:])\n            out.append(c)\n\n    else:\n        for x in numbers:\n            out.append(check//x)\n            \n    return out"]