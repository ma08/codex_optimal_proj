["def main():\n    n, m = list(map(int, input().split()))\n    l = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = list(map(int, input().split()))\n        l[u].append(v)\n        l[v].append(u)\n    res = [0] * (n + 1)\n    for u, x in enumerate(res):\n        if not x:\n            x, nxt = -1, [u]\n            while nxt:\n                x, cur, nxt = -x, nxt, []\n                for u in cur:\n                    if l[u]:\n                        res[u] = x\n                        for v in l[u]:\n                            if not res[v]:\n                                nxt.append(v)\n                            elif res[v] == x:\n                                print(-1)\n                                return\n    for x in -1, 1:\n        l = [u for u in range(1, n + 1) if res[u] == x]\n        print(len(l))\n        print(' '.join(map(str, l)))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, m = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    adj[a].append(b)\n    adj[b].append(a)\n\ncolour = [None] * n\nbad = False\n\nfor i in range(n):\n    if colour[i] is None:\n        todo = [(i, True)]\n        while todo:\n            xi, xc = todo.pop()\n            if colour[xi] is not None:\n                if colour[xi] == xc:\n                    continue\n                else:\n                    bad = True\n                    break\n            colour[xi] = xc\n            for neighbour in adj[xi]:\n                todo.append((neighbour, not xc))\n    if bad:\n        break\n\nif bad:\n    print(-1)\nelse:\n    f = []\n    t = []\n    for i in range(n):\n        if colour[i]:\n            t.append(i+1)\n        else:\n            f.append(i+1)\n    print(len(f))\n    print(\" \".join(map(str, f)))\n\n    print(len(t))\n    print(\" \".join(map(str, t)))\n", "# in the name of god\n\nfrom collections import defaultdict\n\nn, m = list(map(int, input().strip().split()))\n\ng = defaultdict(list)\n\nfor _ in range(m):\n\tu, v = list(map(int, input().strip().split()))\n\tg[u].append(v)\n\tg[v].append(u)\n\nv1 = []\nv2 = []\n\nmark = [-1] * (n + 1)\n\ndef bfs(start):\n    q = []\n    q.append(start)\n    mark[start] = 1\n    v2.append(start)\n\n    while q:\n        v = q.pop(0)\n\n        for u in g[v]:\n            if mark[u] == -1:\n                mark[u] = 1 - mark[v]\n                q.append(u)\n                if mark[u] == 0:\n                    v1.append(u)\n                else:\n                    v2.append(u)\n\n            elif mark[u] == mark[v]:\n                return -1\n    return 0\n\nsw = False\nfor i in range(1, n + 1):\n    if mark[i] == -1 and len(g[i]): \n        res = bfs(i)\n\n    try:\n        if res == -1:\n            sw = True\n            break\n    except:\n        continue\nif sw:\n    print(-1)\nelse:\n    print(len(v1))\n    print(' '.join(str(x) for x in v1))\n    print(len(v2))\n    print(' '.join(str(x) for x in v2))\n\n", "s = list(map(int, input().split()))\nn, m = s[0], s[1]\nif m == 0:\n    print(-1)\n    return\ng = [[] for i in range(n)]\n\nfor i in range(m):\n    s = list(map(int, input().split()))\n    g[s[0] - 1].append(s[1] - 1)\n    g[s[1] - 1].append(s[0] - 1)\n\nvc1 = []\nvc2 = []\ncolors = [-1 for i in range(n)]\n\nfor i in range(n):\n    if colors[i] != -1:\n        continue\n    stack = [(i, 1)]\n    colors[i] = 1\n    while len(stack) > 0:\n        s = stack.pop()\n        if s[1] == 1:\n            vc1.append(s[0] + 1)\n        else:\n            vc2.append(s[0] + 1)\n        for j in g[s[0]]:\n            if colors[j] == -1:\n                stack.append((j, s[1] ^ 1))\n                colors[j] = s[1] ^ 1\n            elif colors[j] == s[1]:\n                print(-1)\n                return\nprint(len(vc2))\nfor i in vc2:\n    print(i, end=' ')\nprint(\"\\n\", len(vc1), sep='')\nfor i in vc1:\n    print(i, end=' ')\nprint()\n", "class Graph:\n\n    def __init__(self):\n        self.numVertices = None\n        self.numEdges = None\n        self.neighbors = None\n        self.loadGraph()\n\n    def loadGraph(self):\n        self.numVertices, self.numEdges = list(map(int, input().split()))\n        self.numVertices += 1\n        self.neighbors = tuple(list() for vertex in range(self.numVertices))\n        self.groups = (set(), set())\n\n        for edge in range(self.numEdges):\n            vertex1, vertex2 = list(map(int, input().split()))\n            self.neighbors[vertex1].append(vertex2)\n            self.neighbors[vertex2].append(vertex1)\n\n    def isBipartite(self):\n        return all(self.isBipartiteComponent(vertex) for vertex in range(1, self.numVertices)\n                                                              if self.groupOf(vertex) == None)\n    def isBipartiteComponent(self, vertex):\n        if len(self.neighbors[vertex]) == 0:\n            return True\n\n        self.groups[0].add(vertex)\n        queue = [vertex]\n\n        while queue:\n            vertex = queue.pop()\n            groupOfVertex = self.groupOf(vertex)\n\n            for neighbor in self.neighbors[vertex]:\n                groupOfNeighbor = self.groupOf(neighbor)\n\n                if groupOfNeighbor == groupOfVertex:\n                    return False\n\n                elif groupOfNeighbor == None:\n                    self.groups[not groupOfVertex].add(neighbor)\n                    queue.append(neighbor)\n\n        return True\n    \n    def groupOf(self, vertex):\n        return 0 if vertex in self.groups[0] else 1 if vertex in self.groups[1] else None\n\n\ndef solve():\n    graph = Graph()\n    if graph.isBipartite():\n        for group in graph.groups:\n            print(len(group))\n            print(\" \".join(map(str, group)))\n    else:\n        print(-1)\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "def IsPossible(graph,n,color,start,isVisited):\n    stack = [start]\n\n    while stack != []:\n        #print (color)\n        curr = stack.pop()\n        if (not isVisited[curr-1]) and (graph[curr] != []):\n            isVisited[curr-1] = True\n            if color[curr-1] == 0:\n                color[curr-1] = 1\n                for kid in graph[curr]:\n                    color[kid-1] = 2\n            elif color[curr-1] == 1:\n                for kid in graph[curr]:\n                    if color[kid-1] == 0 or color[kid-1] == 2:\n                        color[kid-1] = 2\n                    else:\n                        return []\n            else:\n                for kid in graph[curr]:\n                    if color[kid-1] == 0 or color[kid-1] == 1:\n                        color[kid-1] = 1\n                    else:\n                        return []\n            for kid in graph[curr]:\n                stack.append(kid)\n\n    return color\n\ndef Solve(color):\n    first = []\n    second = []\n\n    for i in range(len(color)):\n        if color[i] == 1:\n            first.append(i+1)\n        elif color[i] == 2:\n            second.append(i+1)\n    \n    fstr = ''\n    sstr = ''\n    for i in first:\n        fstr += str(i)+' '\n    \n    for i in second:\n        sstr += str(i) + ' '\n\n    print(len(first))\n    print (fstr)\n    print(len(second))\n    print (sstr)\n\n\ndef main():\n    n,m = list(map(int,input().split()))\n    graph = {}\n    for i in range(1,n+1):\n        graph[i] = []\n    for i in range(m):\n        start,end = list(map(int,input().split()))\n        graph[start].append(end)\n        graph[end].append(start)\n\n    color = [0]*n\n    isVisited = [False]*n\n    for i in range(n):\n        color = IsPossible(graph,n,color,i+1,isVisited)\n        if color == []:\n            print(-1)\n            return \n    Solve(color)\n\nmain()\n"]