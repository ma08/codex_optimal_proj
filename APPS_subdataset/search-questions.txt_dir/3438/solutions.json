["def sum_part(n):\n    m, p, q, r, s = 1, 1, 1, 0, n\n    while n > 9:\n        n, d = divmod(n, 10)\n        r += d * p\n        p *= 10\n        if d: m = 1\n        else: m*= 2\n        s += q*n + m*memo[r]\n        q *= 2\n    return s\n\nfrom collections import defaultdict\nqualified = defaultdict(list)\nmemo = {n: n for n in range(10)}\nfor n in range(10, 10 ** 6):\n    memo[n] = sum_part(n)\n    if memo[n] > n:\n        k, r = divmod(n, memo[n] - n)\n        if not r: qualified[k].append(memo[n] - n)\n\nfrom bisect import bisect\ndef next_higher(n, k):\n    return qualified[k][bisect(qualified[k], n+1)]", "import itertools\nfrom itertools import count\n\ndef break_down(text):\n    numbers = text.split()\n    ns = list(range(1, len(numbers[0])))\n    for n in ns:\n        for idxs in itertools.combinations(ns, n):\n            yield [''.join(numbers[0][i:j]) for i, j in zip((0,) + idxs, idxs + (None,))]\n            \n\n\ndef next_higher(start_value,k):\n    r = 0\n    for n in count(start_value+1):\n        desire = n * k\n        for a in break_down(str(desire)):\n            r += sum([int(b) for b in a])\n        if r == n:\n            return r\n        r = 0\n\n", "from itertools import count\n\ndef next_higher(start,k):\n\n    def parts(n, s, p, store):\n        if sum(store) > n:\n            return\n    \n        if not s:\n            if len(p) > 1:\n                store.append(sum(p))\n            return\n    \n        for i in range(1, len(s) + 1):\n            parts(n, s[i:], p + [int(s[:i])], store)\n    \n        return store\n    \n    \n    for m in count(start + 1):\n        x = parts(m, str(m * k), [], [])\n\n        if sum(x) == m:\n            return m", "def check(n):\n    r,l = 0, 0\n    while n:\n        n,v = divmod(n, 10)\n        x = 0\n        for i in range(l):\n            x += 10**i*2**(l-i-1)\n        r += r + v*x + v*10**l\n        l += 1\n    return r\n\ndef next_higher(start_value, k):\n    for i in range(start_value+1, start_value+30000):\n        if check(i*k)-i-i*k == 0:\n            return i", "from bisect import bisect_right\n\ndef next_higher(start_value, k):\n    d = {3: [162, 378, 756, 1161, 1206, 1611, 1989, 34992, 35208, 35388, 37332, 37548, 37728, 40104, 72972, 73152, 75312, 75492, 75708, 77652, 77832, 77868, 78048, 80208, 80388, 113256, 115596, 115812, 117972, 118152, 118368, 120312, 120492, 120708, 155916],\n         4: [198, 260, 276, 520, 536, 552, 796, 812, 1072, 1108, 1368, 1384, 1644, 1680, 1940, 1956, 2216, 2232, 2492, 10728, 10872, 79536, 109008, 110592, 140064, 193488],\n         5: [108, 171, 846, 1692, 4212, 14724, 18936, 19224, 20304, 103608, 123912, 148608, 168912],\n         7: [717, 861, 1005, 1149, 1158, 1293, 1302, 1431, 14308, 14316, 28624, 28632, 28716, 42948, 43024, 43032, 57264, 57272, 57348, 57432, 71664, 71672, 71748, 85988, 86064, 86072, 86148, 100388, 100464, 100472, 101448, 114704, 114788, 114864, 114872, 115764, 115772, 129104, 129188, 130088, 130164, 130172]}\n    return d[k][bisect_right(d[k], start_value)]", "from itertools import combinations, chain, count\nfrom functools import lru_cache\n\ndef segmentations(a):\n    def split_at(js):\n        i = 0\n        for j in js:\n            yield a[i:j]\n            i = j\n        yield a[i:]\n\n    r = range(1, len(a))\n    for k in r:\n        for sep in combinations(r, k):\n            yield split_at(sep)\n\n@lru_cache(maxsize=None)\ndef value(x, k):\n    return sum(int(''.join(L)) for L in chain.from_iterable(segmentations(str(x * k))))\n\ndef next_higher(start_value, k):\n    return next(x for x in count(start_value+1) if x == value(x, k))", "m = {\n    3: [162,378,756,1161,1206,1611,1989,34992,37438,37548,37332,37728,40104,113256],\n    4: [198,260,520,796,1072,1108,1368,2216,10728,109008],\n    5: [171,198,846,1692,14724,18936,20304],\n    7: [717,861,1005,1149,1293,101448,114704,129104,123912]\n}\n\ndef next_higher(n,k):\n    print(n,k)\n    return next((s for s in m[k] if s>n), -1)", "def partitions(s):\n    if s:\n        for i in range(1, len(s)+1):\n            for p in partitions(s[i:]):\n                yield [s[:i]] + p\n    else:\n        yield []\ndef add_values (product_string): \n  product_list = partitions(product_string)\n  return sum([sum (map(int,items)) for items in list(product_list)[:-1]])\n  \ndef next_higher(start_value,k):\n    product = (start_value+1) * k\n    while add_values(str(product)) != start_value:\n        start_value+=1\n        product = start_value*k\n    return start_value"]