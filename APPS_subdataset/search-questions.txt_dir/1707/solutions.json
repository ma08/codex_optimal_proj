["def cut_log(p, n):\n    log = [0]\n    for _ in range(n):\n        log.append(max(pi + li for pi, li in zip(p[1:], log[::-1])))\n    return log[n]\n", "from functools import lru_cache\n\n# Your new function as given to you by me, your boss.\n@lru_cache(maxsize=None)\ndef cl(p, n):\n   if (n == 0):\n      return 0\n   q = -1\n   for i in range(1, n+1):\n      q = max(q, p[i] + cut_log(p, n-i))\n   return q\n\ndef cut_log(p, n):\n    return cl(tuple(p), n)", "from functools import lru_cache\n\n# Not gonna reinvent the wheel\n# Now I can go on codewars while they think I'm still working on it\n# Be a smart intern\ndef cut_log(p, n):\n    @lru_cache(maxsize=None)\n    def rec(x):\n        if not x: return 0\n        return max(p[i] + rec(x-i) for i in range(1, x+1))\n    return rec(n)", "def cut_log(p, n):\n    q = [0]\n    for j in range(1, n+1):\n        q.append(max(p[i] + q[j-i] for i in range(1, j+1)))\n    return q[n]", "def cut_log(p, n):\n    best = p[:n+1]\n    \n    for j in range(2, n+1):\n        best[j] = max(best[i] + best[j-i]  for i in range(j))\n    \n    return best[n]", "def cut_log(p, n):\n    # store the optimal prices of logs \n    plogs = [0]*len(p)\n    for j in range(1, n+1):\n        val = p[j]\n        # second loop actually only has to iterate over a set half\n        # the length of the current log since you're adding values\n        # from either end.\n        for i in range(1, j//2+1):\n            # compare prices using optimal prices for lengths\n            # smaller than your current length target, take max\n            sm = plogs[i] + plogs[j-i]\n            if sm > val:\n                val = sm\n        plogs[j] = val\n    return plogs[n]", "def cut_log(p, n):\n  optim = [0]\n  for j in range(1, n+1):\n    q = -1\n    for i in range(1, j+1):\n      q = max(q, p[i] + optim[j - i])\n    optim.append(q)\n  return optim[n]\n", "import array\n\ndef cut_log(p, n):\n    r = array.array('i', [0]) * (n+1)\n    for j in range(1, n+1):\n        q = -1\n        for i in range(1, j+1):\n            q = max(q, p[i] + r[j - i])\n        r[j] = q\n    return r[n]\n", "def cut_log(p, n):\n    d = {}\n    return cut_log_internal(p,n, d)\n    \ndef cut_log_internal(p,n, d):\n    if (n == 0):\n      return 0\n    elif n in d:\n        return d[n]\n    q = -1\n    for i in range(1, n+1):\n        q = max(q, p[i] + cut_log_internal(p, n-i, d))\n    d[n] = q   \n    return q", "# Your new function as given to you by me, your boss.\ndef cut_log(p, n):\n    values = [0 for _ in range(n + 1)]\n\n    # Some array to store calculated values\n    for j in range(1, n+1):\n        values[j] = p[j]\n        for i in range(1, j+1): # Two nested loops = \u0398(n^2)\n            v = values[i] + values[j - i]\n            if v > values[j]:\n                values[j] = v\n            # Magic\n    return values[n] # Good luck intern!"]