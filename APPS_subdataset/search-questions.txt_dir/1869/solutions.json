["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport re\n\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        itera = re.finditer(r'(-*)(\\\\d+)', S)\n        \n        root = TreeNode(int(next(itera).group(2)))\n        \n        tofill = [root]\n        \n        for m in itera:\n            k = len(m.group(1))\n            if k == len(tofill):\n                node = TreeNode(int(m.group(2)))\n                tofill[-1].left = node\n                tofill.append(node)\n            else:\n                node = TreeNode(int(m.group(2)))\n                tofill[k-1].right = node\n                tofill[k:] = [node]\n        \n        return root", "class Solution:\n    ''' Transform the input into following format:\n        [ ... ,(num, num_level), ...]\n        example: \\\"1-2--3--4-5\\\" -> [(1,0), (2,1), (3,2), (4,2), (5,1)]\n    '''\n    def __transform(self, S):\n        split = S.split('-')\n        index = 1\n        res = [(split[0], 0)]\n        while index < len(split):\n            level = 0\n            if split[index] == '':\n                while split[index] == '':\n                    level +=1\n                    index +=1\n            num = int(split[index])\n            res.append((num, level+1))\n            index += 1\n        return res\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        L = {}\n        trans_input = self.__transform(S)\n        L[0] = TreeNode(trans_input[0][0], None, None)\n        for num,level in trans_input[1:]:\n            L[level] = TreeNode(num, None, None)\n\\t\\t\\t# Check if left of last level is mapped, ow map to right of last level.\n            if not L[level-1].left:\n                L[level-1].left = L[level]\n            else:\n                L[level-1].right = L[level]\n        return L[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        if not S: \n            return None\n        if len(S) == 1: \n            return TreeNode(int(S))\n        \n        def split_str(S): \n            S += '-'\n            ls = []\n            start = 0\n            for i in range(1, len(S)):\n                if (S[i] == '-') & (S[i - 1] != '-'): \n                    ls.append(S[start: i])\n                    start = i\n            return ls\n        \n        ls_nodes = split_str(S)\n        \n        def build_tree(ls): \n            if not ls: \n                return None\n            root = TreeNode(int(ls[0]))\n            if len(ls) == 1: \n                return root\n            \n            lft = [ls[1][1:]]\n            rgt = []\n            flag = 0\n            for i in range(2, len(ls)):\n                if ls[i][1] != \\\"-\\\": \n                    flag = 1\n                    rgt.append(ls[i][1:])\n                else: \n                    if flag == 0: \n                        lft.append(ls[i][1:])\n                    else: \n                        rgt.append(ls[i][1:])\n                        \n            root.left = build_tree(lft)\n            root.right = build_tree(rgt)\n            \n            return root\n        \n        return build_tree(ls_nodes)\n                    \n        ", "class Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        ptr = 0\n        def traverse(level: int) -> TreeNode:\n            nonlocal ptr\n            nextLevel = 0\n            while ptr < len(S) and S[ptr] == '-':\n                nextLevel += 1\n                ptr += 1\n                \n            if level == nextLevel: \n                val = ''\n                while ptr < len(S) and S[ptr] != '-':\n                    val += S[ptr]\n                    ptr += 1\n                node = TreeNode(int(val))\n                node.left = traverse(level+1)\n                node.right = traverse(level+1)\n                return node\n            else:\n                ptr -= nextLevel\n                return None\n\n        return traverse(0)\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        def dfs(s, idx, depth):\n            if idx==len(s):\n                return None, len(s)\n            cnt = 0\n            while s[cnt+idx]=='-':\n                cnt += 1\n            \n            if cnt!=depth:\n                return None, idx\n            \n            idx += cnt\n            i = 0\n            while idx+i<len(s) and s[idx+i].isdigit():\n                i += 1\n            root = TreeNode(int(s[idx:idx+i]))\n            idx += i\n            root.left, li = dfs(s, idx, depth+1)\n            root.right, ri = dfs(s, li, depth+1)\n            return root, ri\n        \n        return dfs(S, 0, 0)[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        def helper(depth):\n            if depth != self.expected_depth:\n                return None\n            if self.i == len(S):\n                return None\n            n = 0\n            while self.i < len(S) and S[self.i] != \\\"-\\\":\n                n = n * 10 + int(S[self.i])\n                self.i += 1\n            self.expected_depth = 0\n            while self.i < len(S) and S[self.i] == \\\"-\\\":\n                self.expected_depth += 1\n                self.i += 1\n            node = TreeNode(n)\n            node.left = helper(depth + 1)\n            node.right = helper(depth + 1)\n            return node\n        \n        self.i = 0\n        self.expected_depth = 0\n        return helper(0)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, s: str) -> TreeNode:\n        self.index = 0\n        def dfs(depth):\n            if self.index == len(s):\n                return\n            for i in range(depth):\n                if s[self.index+i] != '-':\n                    return\n            self.index += depth\n            curr = 0\n            while self.index < len(s) and s[self.index].isdigit():\n                curr = curr * 10 + int(s[self.index])\n                self.index += 1\n            node = TreeNode(curr)\n            node.left = dfs(depth+1)\n            node.right = dfs(depth+1)\n            return node\n        return dfs(0)\n    \n", "from typing import Tuple\n\nclass TreeNode:\n\\tdef __init__(self, val, left=None, right=None):\n\\t\\tself.val = val\n\\t\\tself.left = left\n\\t\\tself.right = right\n\nclass Solution:\n\n\\tdef _tokenize(self, s) -> Tuple[str, int]:\n\\t\\tout = []\n\\t\\tcur = \\\"num\\\"\n\n\\t\\tfor c in s:\n\n\\t\\t\\tif c == \\\"-\\\":\n\\t\\t\\t\\tnew = \\\"dash\\\"\n\\t\\t\\telse:\n\\t\\t\\t\\tnew = \\\"num\\\"\n\n\\t\\t\\tif cur == new:\n\\t\\t\\t\\tout.append(c)\n\\t\\t\\telse:\n\\t\\t\\t\\tyield cur, \\\"\\\".join(out)\n\\t\\t\\t\\tout = [c]\n\\t\\t\\t\\tcur = new\n\n\\t\\tyield cur, \\\"\\\".join(out)\n\n\\tdef tokenize(self, s):\n\\t\\tfor type, token in self._tokenize(s):\n\\t\\t\\tif type == \\\"num\\\":\n\\t\\t\\t\\tyield type, int(token)\n\\t\\t\\telse:\n\\t\\t\\t\\tyield type, len(token)\n\n\\tdef recoverFromPreorder(self, S: str) -> TreeNode:\n\n\\t\\tit = self.tokenize(S)\n\\t\\t_, val = next(it)\n\n\\t\\tm = {0: TreeNode(val)}\n\\t\\tlevel = 0\n\n\\t\\tfor type, value in it:\n\\t\\t\\tif type == \\\"dash\\\":\n\\t\\t\\t\\tlevel = value\n\\t\\t\\t\\tcontinue\n\n\\t\\t\\tn = TreeNode(value)\n\\t\\t\\tm[level] = n\n\n\\t\\t\\tif m[level - 1].left is None:\n\\t\\t\\t\\tm[level - 1].left = n\n\\t\\t\\telse:\n\\t\\t\\t\\tm[level - 1].right = n\n\n\\t\\treturn m[0]\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom collections import deque\n\nclass Solution:\n    def parsePath(self, s):\n        depth = 0\n        path = [0]\n        for x in s:\n            if x != \\\"-\\\" and depth > 0:\n                path.append(depth)\n                depth = 0\n            elif x == \\\"-\\\":\n                depth += 1\n        return path\n    \n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        vals = [int(n) for n in filter(lambda x: x != \\\"\\\", S.split(\\\"-\\\"))]\n        if len(vals) == 1:\n            return TreeNode(vals[0])\n        path = self.parsePath(S)\n        stack = deque()\n        \n        print(path, vals)\n        \n        depth = i = 0\n        root = node = None\n        while i < len(path):\n            if not root:\n                root = TreeNode(vals[i])\n                node = root\n                i += 1\n            \n            if depth < path[i]:\n                stack.append(node)\n                if not node.left:\n                    node.left = TreeNode(vals[i])\n                    node = node.left\n                else:\n                    node.right = TreeNode(vals[i])\n                    node = node.right\n                depth += 1\n                i += 1\n            else:\n                node = stack.pop()\n                depth -= 1\n            \n        return root\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        def method1():\n            stack, i = [], 0\n            while i < len(S):\n                level, val = 0, \\\"\\\"\n                while i < len(S) and S[i] == '-':\n                    level+= 1\n                    i+= 1\n                    \n                while i < len(S) and S[i] != '-':\n                    val += S[i]\n                    i += 1\n                    \n                while len(stack) > level:\n                    stack.pop()\n            \n                node = TreeNode(val)\n                if stack and stack[-1].left is None:\n                    stack[-1].left = node\n                elif stack:\n                    stack[-1].right = node\n                stack.append(node)\n            return stack[0]\n        \n        return method1()", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n'''\nInput: \\\"1-2--3--4-5--6--7\\\" \ni = 6, c=2, num=4, level = 1\nj = \n'''\ndef getNext(s, i):\n    c = 0\n\n    while(i<len(s) and s[i]=='-'):\n        i+=1\n        c+=1\n    num = []\n    if i==len(s):\n        return -1, -1, -1\n    while(i<len(s) and s[i]!='-'):\n        num.append(s[i])\n        i+=1\n\n    return c, int(''.join(num)), i\n\nc, num, i = 0, 0, 0\ndef solve(s, level):\n    \n    nonlocal c,num,i\n    c,num,j = getNext(s,i)\n    \n    if c==-1 or c<level:\n        return None\n    node = TreeNode(num)\n    i = j\n    node.left = solve(s,level+1)\n    node.right = solve(s,level+1)\n    \n    return node   \n\n\nclass Solution:\n    \n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        nonlocal c,num,i\n        c, num, i = 0, 0, 0\n        return solve(S, 0)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S):\n        stack, i = [], 0\n        while i < len(S):\n            level, val = 0, ''\n            while i < len(S) and S[i] == '-':\n                level, i = level + 1, i + 1\n            while i < len(S) and S[i] != '-':\n                val, i = val + S[i], i + 1\n            while len(stack) > level:\n                stack.pop()\n            node = TreeNode(val)\n            if stack and stack[-1].left is None:\n                stack[-1].left = node\n            elif stack:\n                stack[-1].right = node\n            stack.append(node)\n        return stack[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport re\n\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        vals = [(len(s[1]), int(s[2])) for s in re.findall(\\\"((-*)(\\\\d+))\\\", S)][::-1]\n\n        def dfs(level):\n            if not vals or level != vals[-1][0]:\n                return None\n\n            node = TreeNode(vals.pop()[1])\n            node.left = dfs(level + 1)\n            node.right = dfs(level + 1)\n            return node\n\n        return dfs(0)\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        if not S:\n            return None\n        self.idx = 0\n        return self.recoverTree(S, 0)\n    \n    def recoverTree(self, s, depth):\n        d = self.getDepth(s)\n        if d != depth:\n            self.idx -= d\n            return \n        root = TreeNode(self.getVal(s))\n        root.left = self.recoverTree(s, depth + 1)\n        root.right = self.recoverTree(s, depth + 1)\n        return root\n        \n    def getDepth(self, s):\n        d = 0\n        while self.idx < len(s) and s[self.idx] == '-':\n            d += 1\n            self.idx += 1\n        return d\n    \n    def getVal(self, s):\n        num = 0\n        while self.idx < len(s) and s[self.idx].isdigit():\n            num = num * 10 + int(s[self.idx])\n            self.idx += 1\n        return num\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nimport re\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        level_nodes = []\n        c = 0\n        print()\n        for a in re.split(\\\"(\\\\d+)\\\", S):\n            if a == '':\n                continue\n            elif '-' in a:\n                c = len(a)\n            else:\n                level_nodes.append((c, a))\n                c = 0\n\n        def build_tree(arr, l, r, h, root):\n            # root = arr[l]\n            # assert root[0] == h,  f\\\"next level_nodes should be {h}\\\"\n\n            kids = []\n            for i in range(l, r+1):\n                if arr[i][0] == h:\n                    kids.append(i)\n                if len(kids) == 2:\n                    break\n            # print(h, l, r, kids)\n            if len(kids) == 0:\n                return None\n            elif len(kids) == 1:\n                left = TreeNode(arr[kids[0]][1])\n                root.left = left\n                return build_tree(arr, kids[0]+1, r, h+1, left)\n            else:\n                left = TreeNode(arr[kids[0]][1])\n                root.left = left\n                build_tree(arr, kids[0]+1, kids[1]-1, h+1, left)\n                right = TreeNode(arr[kids[1]][1])\n                root.right = right\n                return build_tree(arr, kids[1]+1, r, h+1, right)\n            \n        if len(level_nodes) == 0:\n            return None        \n        # print(level_nodes)\n        root = TreeNode(level_nodes[0][1])\n        build_tree(level_nodes, 1, len(level_nodes)-1, 1, root)\n        return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        def _recoverFromPreorder(s):\n            if not s:\n                return\n\n            root = TreeNode(s.pop())\n            depth = 0\n            while s:\n                if s[-1] == '-':\n                    s.pop()\n                    depth += 1\n                else:\n                    break\n            \n            \n            var = 0\n            index = -1\n            for i in range(len(s)-1, -1, -1):\n                if s[i] != '-':\n                    if var == depth:\n                        index = i\n                        break\n                    var = 0\n                else:\n                    var += 1\n                    \n            if index == -1:\n                root.left = _recoverFromPreorder(s)\n            else:\n                root.right = _recoverFromPreorder(s[:index+1])\n                root.left = _recoverFromPreorder(s[index+depth+1:])\n            \n            return root\n        \n        arr = list(S)\n        arr_1 = []\n        \n        x = ''\n        while arr:\n            s = arr.pop()\n            if s == '-':\n                if x:\n                    arr_1.append(x)\n                arr_1.append(s)\n                x = ''\n            else:\n                x = s + x\n                \n        if x:\n            arr_1.append(x)\n            \n        return _recoverFromPreorder(arr_1)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        def _recoverFromPreorder(s):\n            print (''.join(s))\n            if not s:\n                return\n\n            root = TreeNode(s.pop())\n            depth = 0\n            while s:\n                if s[-1] == '-':\n                    s.pop()\n                    depth += 1\n                else:\n                    break\n            \n            \n            var = 0\n            index = -1\n            for i in range(len(s)-1, -1, -1):\n                if s[i] != '-':\n                    if var == depth:\n                        index = i\n                        break\n                    var = 0\n                else:\n                    var += 1\n                    \n            if index == -1:\n                root.left = _recoverFromPreorder(s)\n            else:\n                root.right = _recoverFromPreorder(s[:index+1])\n                root.left = _recoverFromPreorder(s[index+depth+1:])\n            \n            return root\n        \n        arr = list(S)\n        arr_1 = []\n        \n        x = ''\n        while arr:\n            s = arr.pop()\n            if s == '-':\n                if x:\n                    arr_1.append(x)\n                arr_1.append(s)\n                x = ''\n            else:\n                x = s + x\n                \n        if x:\n            arr_1.append(x)\n            \n        return _recoverFromPreorder(arr_1)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        stack = []\n        i = 0\n        level=0\n        while i < len(S):\n            level = 0\n            val=''\n            while i < len(S) and S[i] == '-':\n                level+=1\n                i+=1\n            while i < len(S) and S[i] != '-':\n                val += S[i]\n                i+=1\n            while len(stack)>level:\n                stack.pop()\n            node = TreeNode(val)\n            if stack and stack[-1].left is None:\n                stack[-1].left = node\n            elif stack:\n                stack[-1].right = node\n            stack.append(node)\n        return stack[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        dashes = 0\n        stk = []\n        i = 0\n        while i < len(S):\n            s = S[i]\n            if s.isnumeric():\n                c = s\n                while i+1 < len(S) and S[i+1].isnumeric():\n                    c += S[i+1]\n                    i += 1\n                while stk and dashes != stk[-1][1] + 1:\n                    stk.pop()\n                \n                node = TreeNode(int(c))\n                if stk and stk[-1][0].left:\n                    stk[-1][0].right = node\n                elif stk: stk[-1][0].left = node\n                stk.append((node, dashes))\n                dashes = 0\n            \n            else:\n                dashes += 1\n            \n            i += 1\n                \n        return stk[0][0]\n        \n#         dashes = 0\n#         node_depths = collections.defaultdict(list)\n        \n#         #root = TreeNode(int(S[0])))\n#         expected_dashes = 1\n        \n#         for s in S:\n#             if s.isnumeric():\n#                 node_depths[dashes].append(int(s))\n#                 dashes = 0\n            \n#             else:\n#                 dashes += 1\n        \n#         stk = [TreeNode(int(S[0]))]\n#         del node_depths[0]\n#         for depth in sorted(node_depths):\n#             for child in node_depths[depth]:\n#                 if depth == \n            \n        \n        \n        \n        \n        \n#         traversal = [d for depth in sorted(node_depths) for d in node_depths[depth]]\n#         print(traversal)\n#         return traversal\n    \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        return self.helper(S, 0)\n        \n    def helper(self, S, level):\n        if not S:\n            return None\n        val = self.get(S)\n        node = TreeNode(val)\n        idx1, idx2 = self.find(S, level)\n        if idx1:\n            node.left = self.helper(S[idx1:idx2], level+1)\n        if idx2:\n            node.right = self.helper(S[idx2:], level+1)\n        return node\n    \n    def find(self, S, level):\n        idx1 = idx2 = None\n        count = 0\n        for i, ch in enumerate(S):\n            if ch != '-':\n                if count == level + 1:\n                    if not idx1:\n                        idx1 = i\n                    else:\n                        idx2 = i\n                        return idx1, idx2\n                count = 0\n            else:\n                count += 1\n        return idx1, idx2\n    \n    def get(self, S):\n        val = ''\n        for ch in S:\n            if ch == '-':\n                break\n            val += ch\n        return val", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        if not S: return None\n        \n        # \\\"1-2--3--4-5--6--7\\\"\n        \n        que = deque()\n        root = TreeNode(int(S[0]))\n        index = 0\n        while index<len(S):\n            depth = 0\n            val = []\n            while index<len(S) and S[index] == \\\"-\\\":\n                depth += 1\n                index += 1\n            while index<len(S) and S[index].isnumeric():\n                val.append(S[index])\n                index += 1\n            val = int(\\\"\\\".join(val))\n            que.append((val, depth))\n            \n        \n        def helper(depth=None):\n            if not que: return None\n            \n            if depth is not None:\n                if que[0][1] == depth or que[0][1]<depth: return None\n            \n            val, d = que.popleft()\n            \n            root = TreeNode(val)\n            root.left = helper(d)\n            root.right = helper(d)\n            return root\n        \n        return helper()", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        if S == '':\n            return\n        root = TreeNode(S.split('-')[0])\n        stack = [(root,0)]\n        nodes = []\n        i = len(root.val)\n        depth = 0\n        val = []\n        started = False\n        while i < len(S):\n            if S[i] == '-':\n                if started:\n                    nodes.append((TreeNode(''.join(val)),depth))\n                    depth = 0\n                    val = []\n                    started = False\n                depth += 1\n            else:\n                started = True\n                val.append(S[i])\n            i += 1\n        nodes.append((TreeNode(''.join(val)),depth))\n        print(nodes)\n        for node in nodes:\n            while len(stack) > 0 and node[1] <= stack[-1][1]:\n                stack.pop()\n            if len(stack) > 0:\n                parent = stack[-1][0]\n                if parent.left is None:\n                    parent.left = node[0]\n                else:\n                    parent.right = node[0]\n            stack.append(node)\n        return root\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def transform(self, string):\n        s = string.split('-')\n        i = 1\n        res = [(s[0], 0)]\n        while i < len(s):\n            l = 1\n            if s[i] == '':\n                while s[i] == '':\n                    i += 1\n                    l += 1\n            res.append((int(s[i]), l))\n            i += 1\n        return res\n\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        L = {}\n        trans = self.transform(S)\n        L[0] = (TreeNode(trans[0][0]))\n        for val, lvl in trans[1:]:\n            L[lvl] = TreeNode(val)\n            \n            if L[lvl - 1].left:\n                L[lvl - 1].right = L[lvl]\n            else:\n                L[lvl - 1].left = L[lvl]\n        return L[0]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        leftChild = None\n        rightChild = None\n        if str.isnumeric(S):\n            rootVal = S\n        else:\n            rootVal, S = S.split(\\\"-\\\", 1)\n            S = \\\"-\\\" + S\n            depths = re.split('\\\\d+', S)\n            depths.pop()\n            nodes = list(filter(None, re.split('-', S)))\n            adjustedDepths = [d[1:] for d in depths]\n\n            leftS = ''\n            rightIdx = len(adjustedDepths)\n            if '' in adjustedDepths[1:]:\n                rightIdx = adjustedDepths[1:].index('') + 1\n                rightS = ''\n                for i in range(rightIdx, len(adjustedDepths)):\n                    rightS = rightS + adjustedDepths[i] + nodes[i]\n                rightChild=self.recoverFromPreorder(rightS)\n\n            for i in range(rightIdx):\n                leftS = leftS + adjustedDepths[i] + nodes[i]\n            leftChild=self.recoverFromPreorder(leftS)\n                \n\n        return TreeNode(val=rootVal, left=leftChild, right=rightChild)\n            \n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        if not S:\n            return None\n        if '-' not in S:\n            return TreeNode(int(S))\n        dashes,ind,n = 0,1, len(S)\n        while ind<n and S[ind]>='0' and S[ind]<='9':\n            ind+=1\n        root = TreeNode(S[:ind])\n        while ind<n and S[ind]=='-':\n            ind+=1\n            dashes+=1\n        left_ind=ind\n        \n        \n        ## start to find the right part\n        dashes_right = 0\n        while ind<n:\n            dashes_right =0 \n            while ind<n and S[ind]>='0' and S[ind]<='9':\n                ind+=1\n            while ind<n and S[ind]=='-':\n                dashes_right+=1\n                ind+=1\n            if dashes_right==dashes:\n                break\n        if dashes_right==dashes:\n            root.left = self.recoverFromPreorder(S[left_ind:ind-dashes_right])\n            root.right = self.recoverFromPreorder(S[ind:])\n        else:\n            root.left = self.recoverFromPreorder(S[left_ind:])\n        return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n\ndef dfs(s, level):\n    if not s:\n        return\n    if len(s) == 1:\n        return TreeNode(int(s[0]))\n    ss = []\n    nex = []\n    c = 0\n    l = 0\n    for i in range(1, len(s)):\n        if s[i] != \\\"-\\\":\n            if len(ss) == level+1:\n                nex.append(s[l:i-level-1])\n                l = i\n                c += 1\n                if c == 2:\n                    nex.append(s[i:])\n                    break\n            ss.clear()\n        else:\n            ss.append(\\\"-\\\")\n    if c != 2:\n        nex.append(s[l:])\n        \n    root = TreeNode(int(nex[0]))\n    nex = nex[1:]\n    if nex:\n        root.left = dfs(nex[0], level+1)\n        nex = nex[1:]\n    if nex:\n        root.right = dfs(nex[0], level+1)\n        nex = nex[1:]\n    return root\n\n\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        return dfs(S, 0)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        ptr = 0\n        def traverse(level: int) -> TreeNode:\n            nonlocal ptr\n            nextLevel = 0\n            while ptr < len(S) and S[ptr] == '-':\n                nextLevel += 1\n                ptr += 1\n                \n            if level == nextLevel: \n                val = ''\n                while ptr < len(S) and S[ptr] != '-':\n                    val += S[ptr]\n                    ptr += 1\n                node = TreeNode(int(val))\n                node.left = traverse(level+1)\n                node.right = traverse(level+1)\n                return node\n            else:\n                ptr -= nextLevel\n                return None\n\n        return traverse(0)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        #if the next node's num dashes increases , add as a child\n        #also check next \n        \n        #number of dashes tell you to move up/down\n        \n        #what does the order tell you?\n        \n        #there should only be 1 working node at each depth\n        #keep a list of those\n        #count the dashes, and then go to 1 above that\n        \n        \n                \n        nodes = []\n        i = 0\n        prev = \\\"\\\"\n        for i in range(len(S)):\n            if S[i] == \\\"-\\\" and prev == \\\"\\\":\n                continue\n            elif S[i] == \\\"-\\\":\n                nodes.append(int(prev))\n                prev = \\\"\\\"\n            elif S[i] in list(\\\"0123456789\\\"):\n                prev += S[i]\n            else:\n                assert False, f\\\"unrecognized char {S[i]}\\\"\n        nodes.append(int(prev))\n        \n        depths = [0]\n        prev = 0\n        for i in range(len(S)):\n            if S[i] in list(\\\"0123456789\\\") and prev == 0: #in the middle of a number, keep going\n                continue\n            if S[i] in list(\\\"0123456789\\\"): #ending a dash sequence, save the result\n                depths.append(prev)\n                prev = 0\n            else: #middle of a dash sequence\n                prev += 1\n                \n        assert len(nodes) == len(depths), \\\"should be same\\\"\n        \n        root = TreeNode(nodes[0])\n        layers = [root] #keep track of the current node at each depth\n\n        for i in range(1, len(nodes)):\n            val = nodes[i]\n            depth = depths[i]\n            \n            curr = TreeNode(val)\n            assert depth <= len(layers)\n            if depth == len(layers):\n                layers.append(curr)\n            else:\n                layers[depth] = curr\n            \n            \n            #go to the node 1 above\n            parent = layers[depth-1]\n            if parent.left == None:\n                parent.left = curr\n            else:\n                assert parent.right == None, f\\\"{val}  {depth}   {parent}\\\"\n                parent.right = curr\n        return root\n                            \n            \n            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        def split(S, split_depth):\n            split_index = -1\n            i = len(S) - 1\n            while i >= 0:\n                temp_depth, size = i, 0\n                while temp_depth < len(S) and S[temp_depth] == \\\"-\\\":\n                    temp_depth -= 1\n                    size += 1\n                if size == split_depth:\n                    split_index = temp_depth\n                    break\n                i = temp_depth\n                i -= 1\n            return split_index\n        \n        \n        def process(S):\n            node = None\n            if len(S) != 0:\n                depth = 0\n                while depth < len(S) and S[depth] == \\\"-\\\":\n                    depth += 1\n                num = depth\n                while num < len(S) and S[num].isdigit():\n                    num += 1\n                number = S[depth : num]\n                node = TreeNode(int(number))\n                S = S[num:]\n                split_depth = depth + 1\n                split_index = split(S, split_depth)\n                if split_index != -1:\n                    left, right = S[:split_index + 1], S[split_index + 1:]\n                    node.left, node.right = process(left), process(right)\n                else:\n                    node.left, node.right = process(S), None                 \n            return node\n        return process(S)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        self.i = 0\n        return self.construct_tree(S, 0)\n        \n    def construct_tree(self, S, level):\n        if self.i == len(S):\n            return None\n        \n        zero = ord('0')\n        j = self.i\n        node_lvl = 0\n        while j < len(S) and S[j] == '-':\n            node_lvl+=1\n            j+=1\n\n        val = 0\n        while j < len(S) and S[j].isdigit():\n            val = val*10 + (ord(S[j])-zero)\n            j+=1\n        \n        if level != node_lvl:\n            return None\n        \n        self.i = j\n        return TreeNode(val, self.construct_tree(S, level+1), self.construct_tree(S, level+1))\n        \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        \n        if not S:\n            return \n        \n        ins = list(S)\n        \n        root = TreeNode(-1)\n        current = None\n        \n        while ins:\n            \n            while ins and ins[0] == '-':\n                \n                # if right present\n                if current.right:\n                    current = current.right                \n                # if left present\n                elif current.left:\n                    current = current.left\n                \n                ch = ins.pop(0)\n\n            # node val can be multiple digits\n            node_val = ''\n            while ins and ins[0] != '-':\n                ch = ins.pop(0)\n                node_val += ch\n                \n            # if root None yet\n            if not root.left:\n                root.left = TreeNode(node_val)\n\n            else:\n                # if left not present\n                if not current.left:\n                    current.left = TreeNode(node_val)\n                else:\n                    current.right = TreeNode(node_val)\n\n            # reset current\n            current = root\n            \n        return root.left", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        \n        def helper(current_depth, s):\n            split_point1 = -1\n            split_point2 = -1\n            next_depth = current_depth + 1\n            count = 0\n            whole_count = 0\n            for index, c in enumerate(s):\n                if c == '-':\n                    whole_count += 1\n                    count += 1\n                else:\n                    if count == next_depth:\n                        if split_point1 == -1:\n                            split_point1 = index\n                        else:\n                            split_point2 = index\n                    count = 0\n            if whole_count == 0:\n                return TreeNode(int(s))\n            else:\n                root = TreeNode(int(s[:split_point1 - next_depth]))\n\n                if split_point2 != -1:\n                    root.left = helper(next_depth, s[split_point1:split_point2 - next_depth])\n                    root.right = helper(next_depth, s[split_point2:])\n                else:\n                    root.left = helper(next_depth, s[split_point1:])\n                    root.right = None\n            return root\n        return helper(0, S)\n            \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        idx = 0\n        while idx < len(S) and S[idx] != '-':\n            idx += 1\n        root = TreeNode(int(S[:idx]))\n        root_l = idx\n        if len(S) == idx:\n            return root\n        d = 0\n        while S[idx] == '-':\n            d += 1\n            idx += 1\n        cnt = 0\n        while idx < len(S):\n            if S[idx] != '-':\n                if cnt == d:\n                    root.left = self.recoverFromPreorder(S[root_l+d:idx-d])\n                    root.right = self.recoverFromPreorder(S[idx:])\n                    break\n                cnt = 0\n            else:\n                cnt += 1\n            idx += 1\n            if idx == len(S):\n                root.left = self.recoverFromPreorder(S[root_l+d:])\n        return root\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        try:\n            self.values = [int(i) for i in S.split('-') if len(i)>0]\n            self.S = S[S.index('-'):]\n            root = TreeNode(self.values.pop(0))\n        except:\n            return TreeNode(int(S))\n        \n\n        def create_tree(root, depth):\n            if len(self.S) == 0:\n                return \n            elif '-' * depth == self.S[:depth]:\n                if root.left == None:\n                    num = self.values.pop(0)\n                    digits = len(str(num))\n                    tmp = TreeNode(num)\n                    self.S = self.S[depth+digits:]\n                    create_tree(tmp, depth+1)\n                    root.left = tmp\n                    \n                if root.right == None and '-' * depth == self.S[:depth]:\n                    num = self.values.pop(0)\n                    digits = len(str(num))\n                    tmp = TreeNode(num)\n                    self.S = self.S[depth+digits:]\n                    create_tree(tmp, depth+1)\n                    root.right = tmp\n                return root\n            elif '-' * depth != self.S[:depth]:\n                return\n        \n        # print(len(S))\n        \n        return create_tree(root, 1)", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        #if the next node's num dashes increases , add as a child\n        #also check next \n        \n        #number of dashes tell you to move up/down\n        \n        #what does the order tell you?\n        \n        #there should only be 1 working node at each depth\n        #keep a list of those\n        #count the dashes, and then go to 1 above that\n        \n        \n                \n        nodes = []\n        i = 0\n        prev = \\\"\\\"\n        for i in range(len(S)):\n            if S[i] == \\\"-\\\" and prev == \\\"\\\":\n                continue\n            elif S[i] == \\\"-\\\":\n                print(f\\\"appending prev {prev}\\\")\n                nodes.append(int(prev))\n                prev = \\\"\\\"\n            elif S[i] in list(\\\"0123456789\\\"):\n                prev += S[i]\n            else:\n                assert False, f\\\"unrecognized char {S[i]}\\\"\n        nodes.append(int(prev))\n        \n        depths = [0]\n        prev = 0\n        for i in range(len(S)):\n            if S[i] in list(\\\"0123456789\\\") and prev == 0: #in the middle of a number, keep going\n                continue\n            if S[i] in list(\\\"0123456789\\\"): #ending a dash sequence, save the result\n                depths.append(prev)\n                prev = 0\n            else: #middle of a dash sequence\n                prev += 1\n                \n        print(nodes, depths)\n        assert len(nodes) == len(depths), \\\"should be same\\\"\n        \n        root = TreeNode(nodes[0])\n        layers = [root] #keep track of the current node at each depth\n\n        for i in range(1, len(nodes)):\n            val = nodes[i]\n            depth = depths[i]\n            \n            curr = TreeNode(val)\n            assert depth <= len(layers)\n            if depth == len(layers):\n                layers.append(curr)\n            else:\n                layers[depth] = curr\n            \n            \n            #go to the node 1 above\n            parent = layers[depth-1]\n            if parent.left == None:\n                parent.left = curr\n            else:\n                assert parent.right == None, f\\\"{val}  {depth}   {parent}\\\"\n                parent.right = curr\n            print(curr)                \n        return root\n                            \n            \n            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        first = S.find(\\\"-\\\")\n        if \\\"-\\\"*len(S)==S:\n            return None\n        if first<0:\n            if len(S)<1 :\n                return None\n            else:\n                return TreeNode(int(S))\n        \n        root = TreeNode(int(S[:first]))\n        stack = [(root, 0)]\n        prev=0\n        S = S[first:]\n        while len(S)>0:\n            curr_ = 0\n            for idx, char in enumerate(S):\n                if char==\\\"-\\\":\n                    curr_+=1\n                else:\n                    break\n            S = S[idx:]\n            curr_num = \\\"\\\"\n            for idx, char in enumerate(S):\n                if char==\\\"-\\\":\n                    break\n                else:\n                    curr_num+=char\n            curr_num = TreeNode(int(curr_num))\n            S = S[idx:]\n            if prev < curr_: # then this is a child\n                stack[-1][0].left = curr_num\n                stack.append((curr_num, curr_))\n            else:\n                last = stack[-1]\n                while stack and stack[-1][1]+1 >= curr_: # this is a right node or go one step up\n                    # while checking where to attach the right node, we need to go one step above when we rech equality\n                    # we need to go one step up,  if there is an equality hence on lhs there is the +1\n                    last = stack.pop()\n                last[0].right = curr_num\n                stack.append((last[0].right, curr_))\n            \n            \n            prev = curr_\n            if len(S)==1:\n                break\n        \n        return root\n            ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n  def recoverFromPreorder(self, S: str) -> TreeNode:\n      root_num = ''\n      start = 0\n      while S[start].isdigit():\n        root_num += S[start]\n        start += 1\n        if start == len(S): break\n      div = [(0, int(root_num))]\n      depth_counter = 0\n      while start < len(S):\n        if S[start] == '-':\n          depth_counter += 1\n          start += 1\n        else:\n          num = ''\n          while S[start].isdigit():\n            num += S[start]\n            start += 1\n            if (start == len(S)): break\n          div.append((depth_counter, int(num)))\n          depth_counter = 0\n      res = TreeNode(int(root_num))\n      track = res\n      dicts = {0:res}\n      for i in range(1, len(div)):\n        depth, val = div[i][0], div[i][1]\n        roots = dicts[depth-1]\n        if not roots.left:\n          roots.left = TreeNode(val)\n          dicts[depth] = roots.left\n        else:\n          roots.right = TreeNode(val)\n          dicts[depth] = roots.right\n      return res\n      \n      \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n  def recoverFromPreorder(self, S: str) -> TreeNode:\n      root_num = ''\n      start = 0\n      while S[start].isdigit():\n        root_num += S[start]\n        start += 1\n        if start == len(S): break\n      div = [(0, int(root_num))]\n      depth_counter = 0\n      while start < len(S):\n        if S[start] == '-':\n          depth_counter += 1\n          start += 1\n        else:\n          num = ''\n          while S[start].isdigit():\n            num += S[start]\n            start += 1\n            if (start == len(S)): break\n          div.append((depth_counter, int(num)))\n          depth_counter = 0\n      res = TreeNode(int(root_num))\n      track = res\n      dicts = [res]\n      for i in range(1, len(div)):\n        depth, val = div[i][0], div[i][1]\n        roots = dicts[depth-1]\n        dicts = dicts[:depth]\n        if not roots.left:\n          roots.left = TreeNode(val)\n          dicts.append(roots.left)\n        else:\n          roots.right = TreeNode(val)\n          dicts.append(roots.right)\n      return res\n      \n      \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def recoverFromPreorder(self, S: str) -> TreeNode:\n        if not S: return None\n        i=0\n        d=0\n        s=[]\n        v=0\n        while i<len(S) and S[i].isdigit():\n            v=v*10+int(S[i])\n            i+=1\n        root=TreeNode(v)\n        s.append((root, d))\n        while i<len(S):\n            if S[i].isdigit():\n                v=0\n                while i<len(S) and S[i].isdigit():\n                    v=v*10+int(S[i])\n                    i+=1\n                nnode=TreeNode(v)\n                if not s:\n                    s.append((nnode, d))\n                else:\n                    node=s.pop()\n                    while s and node[1]!=d-1:\n                        node=s.pop()\n                        \n                    if not node[0].left:\n                        node[0].left=nnode\n                        s.append(node)\n                        # s.append((nnode, d))\n                    else:\n                        node[0].right=nnode\n                    s.append((nnode, d))\n            else:\n                d=0\n                while i<len(S) and S[i]=='-':\n                    d+=1\n                    i+=1\n        return root"]