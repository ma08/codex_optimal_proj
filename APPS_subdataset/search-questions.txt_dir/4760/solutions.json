["class T:\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n\n\ndef is_bst(node):\n\n    def extract(node):\n        if node is not None:\n            yield from extract(node.left)\n            yield node.value\n            yield from extract(node.right)\n    \n    gen = extract(node)\n    try:\n        u, v = next(gen), next(gen)\n    except StopIteration:\n        return True\n    \n    cmp = u<v\n    for w in gen:\n        if cmp != (v<w): return False\n        v = w\n    return True", "class T:\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n\n\ndef walk_tree(node):\n    if node is None:\n        return []\n    \n    return walk_tree(node.left) + [node.value] + walk_tree(node.right)\n\n\ndef is_bst(node):\n    vals = walk_tree(node)\n    ordered = vals[:]\n    ordered.sort()\n    return (ordered == vals) or (ordered == vals[::-1])\n", "class T:\n    def __init__(self, value, left=None, right=None):\n        self.value, self.left, self.right = value, left, right\n\ndef is_bst(node):\n    def walk(node, from_, to_, min_=float('-inf'), max_=float('inf')):\n        return node is None or min_ <= node.value <= max_ \\\n            and walk(getattr(node, from_), from_, to_, min_, node.value) \\\n            and walk(getattr(node, to_  ), from_, to_, node.value, max_)\n    return walk(node, 'left', 'right') or walk(node, 'right', 'left')", "class T:\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n\ndef preorder(self):\n    if not self:\n        return []\n    return [self.value] + preorder(self.left) + preorder(self.right)\n\ndef is_bst(T):\n    if not (T and (T.left or T.right)):\n        return True\n    v, l, r, R1, R2 = T.value, T.left, T.right, True, True\n    if l and max(preorder(l)) > v or r and min(preorder(r)) < v:\n        R1 = False\n    if l and min(preorder(l)) < v or r and max(preorder(r)) > v:\n        R2 = False\n    return is_bst(l) and is_bst(r) and (R1 or R2)", "class T:\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n\ndef inorder(self):\n    if not self:\n        return []\n    return inorder(self.left) + [self.value] + inorder(self.right)\n\ndef is_bst(node):\n    curr=inorder(node)\n    return sorted(curr) in (curr, curr[::-1])", "class T:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n        \ndef is_bst(node):\n    to_arr = lambda t: to_arr(t.left) + [t.value] + to_arr(t.right) if t else []\n    arr = to_arr(node)\n    s = sorted(arr)\n    return s == arr or s == arr[::-1]", "class T:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_bst(node):\n    def traverse(n):\n        return [] if not n else traverse(n.left) + [n.value] + traverse(n.right)\n    vals = traverse(node)\n    zipped = list(zip(vals, vals[1:]))\n    return all(a < b for a, b in zipped) or all(a > b for a, b in zipped)", "class T:\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n\ndef inorder(self):\n    if not self:\n        return []\n    return inorder(self.left) + [self.value] + inorder(self.right)\n\ndef is_bst(T):\n    io = inorder(T)\n    return sorted(io) in (io, io[::-1])", "class T:\n    def __init__(self,value,left=None,right=None):\n        self.value=value\n        self.left=left\n        self.right=right\n        \ndef levelorder(self):\n    if not self:\n        return []\n    queue, R = [self], [self.value]\n    while queue:\n        Next = queue.pop(0)\n        for T in [Next.left, Next.right]:\n            if T:\n                queue.append(T)\n                R.append(T.value)\n    return R\n\ndef is_bst1(T):\n    if not (T and (T.left or T.right)):\n        return True\n    v, l, r = T.value, T.left, T.right\n    if l and max(levelorder(l)) > v or r and min(levelorder(r)) < v:\n        return False\n    return is_bst1(l) and is_bst1(r)\n\ndef is_bst2(T):\n    if not (T and (T.left or T.right)):\n        return True\n    v, l, r = T.value, T.left, T.right\n    if l and min(levelorder(l)) < v or r and max(levelorder(r)) > v:\n        return False\n    return is_bst2(l) and is_bst2(r)\n\ndef is_bst(T):\n    return is_bst1(T) or is_bst2(T)", "from operator import gt, lt\n\n\ndef max_child(root):\n    max_val = root.value\n    if root.left is not None:\n        max_left = max_child(root.left)\n        max_val = max(max_val, max_left)\n    if root.right is not None:\n        max_right = max_child(root.right)\n        max_val = max(max_val, max_right)\n    return max_val\n\n\ndef min_child(root):\n    min_val = root.value\n    if root.left is not None:\n        min_left = min_child(root.left)\n        min_val = min(min_val, min_left)\n    if root.right is not None:\n        min_right = min_child(root.right)\n        min_val = min(min_val, min_right)\n    return min_val\n\n\ncomparator_mapper = {\n    gt: max_child,\n    lt: min_child\n}\n\n\nclass T:\n    def __init__(self, value, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n\ndef is_bst(node):\n    if node is None:\n        return True\n    if node.left is not None and node.left.value > node.value or node.right is not None and node.right.value < node.value:\n        return validate(node, lt, gt)\n\n    return validate(node, gt, lt)\n\n\ndef validate(root, left_tree_compare, right_tree_compare):\n    if root is None:\n        return True\n\n    return (left_tree_compare(root.value,\n                              comparator_mapper[left_tree_compare](root.left)) if root.left is not None else True) and (\n               right_tree_compare(root.value, comparator_mapper[right_tree_compare](\n                   root.right)) if root.right is not None else True) and validate(\n        root.left, left_tree_compare, right_tree_compare) and validate(root.right, left_tree_compare,\n                                                                       right_tree_compare)\n"]