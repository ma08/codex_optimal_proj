["class Solution:\n     hash = {}\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         # return base case\n         if n == 0:\n             return 1\n         if n == 1 or n == 2:\n             return n\n         \n         # try fetching from hash\n         try:\n             return self.hash[n]\n         except KeyError:\n             pass\n         \n         # holds the sum\n         resSum = 0\n         \n         # iterate i from 1 to n-1\n         # should add up (0,4), (1,3), (2,2), (3,1), (4,0)\n         for i in range(n):\n             #print(i,n - (i+1))\n             tempSum = self.numTrees(i) * self.numTrees(n - (i+1))\n             #print(tempSum)\n             resSum += tempSum\n             \n         # append to hash\n         self.hash[n]=resSum\n         return resSum", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         res = [0] * (n+1)\n         res[0] = res[1] = 1\n         for i in range(2,n+1):\n             for j in range(1,i+1):\n                 res[i] += res[j-1] * res[i-j]\n         return res[-1]", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n<1:\n             return 1\n             \n         tree_nums = [0]*(n+1)\n         tree_nums[0] = 1\n         tree_nums[1] = 1    # index start with 1\n         \n         for t in range(2, n+1):\n             for root in range(1,t+1):\n                 lt_num = root-1 # nodes num which smaller than root\n                 rt_num = t-root # nodes num which larger than root\n                 \n                 tree_nums[t] += tree_nums[lt_num]*tree_nums[rt_num]\n         \n         return tree_nums[n]\n", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         dp = [0]*(n+1)\n         dp[0] = dp[1] = 1\n         for i in range(2, n+1):\n             total = 0\n             for j in range(i):\n                 total += (dp[j] * dp[i-j-1])\n             dp[i] = total\n                 \n         return dp[n] ", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         \n         \"\"\"\n         The most straightforward solution would be to try all possible permutations that specify the order of input in constructing a BST and counting the different ways in which the BST results. But that would take O(n!) time and O(n) space.\n         Maybe it would help to use the fact that a BST is defined recursively.\n         Does the topology of a subtree affects whether the parent subtree is valid or not?\n         No.\n         And is it possible that we get any duplicate trees when we first designate our root and then permute its subtrees? \n         No.\n         So for each node i, set i as a root and then construct/permute the left and the right subtrees. \n         The parameter we need to take care of is the list of available nodes in that subtree.\n         Memoize the results, too.\n         \"\"\"\n         \n         def memoize(func):\n             func.cache = cache = dict()\n             def memoizer(*args):\n                 key = str(args)\n                 if key not in cache:\n                     cache[key] = func(*args)\n                 return cache[key]\n             return memoizer\n                 \n         \n         @memoize\n         def count(root, lower_bound, upper_bound):\n             \n             if upper_bound < lower_bound:\n                 return 0\n             \n             if lower_bound == upper_bound:\n                 return 1\n                 \n             left_combinations = max(1, sum(count(left, lower_bound, root - 1) for left in range(lower_bound, root)))\n             right_combinations = max(1, sum(count(right, root + 1, upper_bound) for right in range(root + 1, upper_bound + 1)))\n             #print(root, lower_bound, upper_bound, left_combinations, right_combinations)\n             return left_combinations * right_combinations\n         \n         return sum(count(root, 1, n) for root in range(1, n + 1))\n         \n", "class Solution:\n     from functools import lru_cache\n     @lru_cache(maxsize=None)\n     def numTrees(self, high, low=1, depth=0):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         return sum(self.numTrees(key - 1, low, depth + 1) * self.numTrees(high, key + 1, depth + 1) for key in range(low, high + 1)) or 1", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         nums = [0] * (n+1)\n         nums[0] = 1\n         nums[1] = 1\n         \n         for i in range(2, n+1):\n             for j in range(i):\n                 nums[i] += nums[j] * nums[i - j - 1]\n         return nums[n]", "class Solution:\n     def numTrees(self, n):\n         \n         dp = [0] * (n + 1)\n         \n         dp[0] = 1\n         \n         for i in range(1, n + 1):\n             for j in range(i):\n                 print(j)\n                 print((i - j - 1))\n                 dp[i] += dp[j] * dp[i - j - 1]\n         \n         return dp[-1]\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         a = [1]\n         i = 1\n         while i < n:\n             tmp = [sum(a), sum(a)]\n             for j in range(len(a) - 1):\n                 tmp.append(tmp[j + 1] - a[j]) \n             i += 1\n             a = tmp\n         return sum(a)", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         dp = [1, 1, 2]\n         if n < 3:\n             return dp[n]\n         for i in range(3, n + 1):\n             \n             dp.append(sum(dp[j - 1] * dp[i - j] for j in range(1, i + 1)))\n         return dp[n]\n", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         \n         dp = [0 for _ in range(n+1)]\n         dp[1] = 1\n         dp[0] = 1\n         \n         for x in range(2, n+1):\n             for y in range(1, x+1): \n                 dp[x] += (dp[y - 1] * dp[x-y])\n                 \n         return dp[-1]\n", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         if n <= 1:\n             return 1\n         dp = [1 for i in range(n+1)]\n         for i in range(2, n+1):\n             sums = 0\n             for j in range(1, i+1):\n                 sums += dp[j-1] * dp[i-j]\n             dp[i] = sums\n         print(dp)\n         return dp[-1]", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int     \n         \"\"\"\n         M = [0 for x in range(n)]\n         M[0] = 1\n         for i in range(1,n):\n             for j in range(1,i):\n                 M[i] += M[j-1] * M[i-j-1]\n             M[i] += M[i-1] * 2\n         return M[n-1]", "class Solution:\n     from functools import lru_cache\n     @lru_cache(maxsize=None)\n     def numTrees(self, high, low=1):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         return sum(self.numTrees(key - 1, low) * self.numTrees(high, key + 1) for key in range(low, high + 1)) or 1", "class Solution:\n     def numTrees(self, n):\n         \"\"\"\n         :type n: int\n         :rtype: int\n         \"\"\"\n         G = [0 for _ in range(n+1)]\n         G[0] = 1\n         G[1] = 1\n         \n         for i in range(2, n+1):\n             for j in range(i+1):\n                 G[i] += G[j-1]*G[i-j]\n                 \n         return G[-1]"]