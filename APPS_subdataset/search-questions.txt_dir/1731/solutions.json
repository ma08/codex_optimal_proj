["from random import choice\n\ndef interpret(code):\n    code = [list(l) for l in code.split('\\n')]\n    x, y = 0, 0\n    dx, dy = 1, 0\n    output = ''\n    stack = []\n    string_mode = False\n    \n    while True:\n        move = 1\n        i = code[y][x]\n        \n        if string_mode:\n            if i == '\"':\n                string_mode = False\n            else:\n                stack.append(ord(i))\n        else:\n        \n            if i.isdigit(): stack.append(int(i))\n            elif i == '+': stack[-2:] = [stack[-2] + stack[-1]]\n            elif i == '-': stack[-2:] = [stack[-2] - stack[-1]]\n            elif i == '*': stack[-2:] = [stack[-2] * stack[-1]]\n            elif i == '/': stack[-2:] = [stack[-2] and stack[-2] / stack[-1]]\n            elif i == '%': stack[-2:] = [stack[-2] and stack[-2] % stack[-1]]\n            elif i == '!': stack[-1] = not stack[-1]\n            elif i == '`': stack[-2:] = [stack[-2] > stack[-1]]\n            elif i in '><^v?':\n                if i == '?':   i = choice('><^v')\n                if i == '>':   dx, dy =  1,  0\n                elif i == '<': dx, dy = -1,  0\n                elif i == '^': dx, dy =  0, -1\n                elif i == 'v': dx, dy =  0,  1\n            elif i == '_': dx, dy = (-1 if stack.pop() else 1), 0\n            elif i == '|': dx, dy = 0, (-1 if stack.pop() else 1)\n            elif i == '\"': string_mode = True\n            elif i == ':': stack.append(stack[-1] if stack else 0)\n            elif i == '\\\\': stack[-2:] = stack[-2:][::-1]\n            elif i == '$': stack.pop()\n            elif i == '.': output += str(stack.pop())\n            elif i == ',': output += chr(stack.pop())\n            elif i == '#': move += 1\n            elif i == 'p':\n                ty, tx, tv = stack.pop(), stack.pop(), stack.pop()\n                code[ty][tx] = chr(tv)\n            elif i == 'g':\n                ty, tx = stack.pop(), stack.pop()\n                stack.append(ord(code[ty][tx]))\n            elif i == '@':\n                return output\n        \n        for _ in range(move):\n            x = (x + dx) % len(code[y])\n            y = (y + dy) % len(code)", "import random\nclass Interpretor(object):\n    \"\"\"\n    0-9 Push this number onto the stack.\n    \" Start string mode: push each character's ASCII value all the way up to the next \".\n    \"\"\"\n\n    def __init__(self, lines):\n        self.code = [list(line) for line in lines.split('\\n')]\n        push = lambda a: self.stack.append(a)\n        \n        self.no_parameter_ops = {\n            '>': lambda: self.change_dir(1,0),\n            '<': lambda: self.change_dir(-1,0),\n            '^': lambda: self.change_dir(0,-1),\n            'v': lambda: self.change_dir(0,1),\n            '?': lambda: self.change_dir(*random.choice([[1,0], [-1,0], [0,-1], [0,1]])),\n            '#': self.move,\n            ' ': lambda: None,\n            '@': self.stop,\n            '\"': self.toggle_string\n        }\n        \n        self.one_parameter_ops = {\n            '!': lambda a: push(1 if a == 0 else 0),\n            '_': lambda a: self.change_dir(1,0) if a == 0 else self.change_dir(-1,0),\n            '|': lambda a: self.change_dir(0,1) if a == 0 else self.change_dir(0,-1),\n            ':': lambda a: push(0) if a is None else [push(a), push(a)],\n            '$': lambda a: None,\n            '.': lambda a: self.output.append(a),\n            ',': lambda a: self.output.append(chr(a))\n        }\n    \n        self.two_parameter_ops = {\n            '+': lambda a,b: push(b+a),\n            '-': lambda a,b: push(b-a),\n            '*': lambda a,b: push(a*b),\n            '/': lambda a,b: push(0 if a == 0 else b/a),\n            '%': lambda a,b: push(0 if a == 0 else b%a),\n            '`': lambda a,b: push(1 if b > a else 0),\n            '\\\\': lambda a,b: [push(a), push(0)] if b is None else [push(a), push(b)],\n            'g': lambda y,x: push(ord(self.code[y][x]))\n        }\n        \n        self.tri_parameter_ops = {\n            'p': self.put\n        }\n    \n    def put(self,y,x,v): self.code[y][x] = chr(v)\n    def stop(self): self.running = False\n    def change_dir(self, nx, ny): self.dx, self.dy = nx, ny\n    def toggle_string(self): self.string = not self.string\n    def move(self):\n        self.x += self.dx\n        self.y += self.dy\n        \n    def interpret(self):\n        self.stack = []\n        self.output = []\n        self.x, self.y = 0, 0\n        self.dx, self.dy = 1,0\n        self.running = True\n        self.string = False\n        \n        pop = lambda: self.stack.pop() if self.stack else None\n        \n        while self.running:\n            self.y = self.y % len(self.code)\n            self.x = self.x % len(self.code[self.y])\n            token = self.code[self.y][self.x]\n            \n            if self.string and token != \"\\\"\":     self.stack.append(ord(token))\n            elif token in self.no_parameter_ops:  self.no_parameter_ops[token]()\n            elif token in self.one_parameter_ops: self.one_parameter_ops[token](pop())\n            elif token in self.two_parameter_ops: self.two_parameter_ops[token](pop(),pop())\n            elif token in self.tri_parameter_ops: self.tri_parameter_ops[token](pop(),pop(),pop())\n            elif token in \"0123456789\":           self.stack.append(int(token))\n            \n            self.move()\n        return ''.join(str(x) for x in self.output)\n\ndef interpret(code):\n    interpretor = Interpretor(code)\n    return interpretor.interpret()", "from random import choice\n\nDIR = (1, 0), (-1, 0), (0, 1), (0, -1)\ndef interpret(code):\n    grid, stack, out, direction = [*map(list, code.splitlines())], [], '', DIR[0]\n    x = y = smode = value = 0\n    while True:\n        value, jump = grid[y][x], 1\n        if value is '\"':               smode  = not smode\n        elif smode or value.isdigit(): stack += [(int, ord)[smode](value)]\n        elif value in '+-*/%':         stack += [eval(str(stack.pop(~1)) + value + str(stack.pop()))]\n        elif value in '!':             stack += [not stack.pop()]\n        elif value in '`':             stack += [stack.pop() < stack.pop()]\n        elif value in ':':             stack += [stack and stack[-1] or 0]\n        elif value in '\\\\':            stack += [len(stack) > 1 and stack.pop(-2) or 0]\n        elif value in 'g':             stack += [ord(grid[stack.pop()][stack.pop()])]\n        elif value in 'p':             grid[stack.pop()][stack.pop()] = chr(stack.pop(-3))\n        elif value in '$':             stack.pop()\n        elif value in '.,':            out += (str, chr)[value is ','](+stack.pop())\n        elif value in '?':             direction = choice(DIR)\n        elif value in '_|':            direction = DIR[(value is '|') * 2 + bool(stack.pop())]\n        elif value in '><v^':          direction = DIR['><v^'.index(value)]\n        elif value in '#':             jump = 2\n        elif value in '@':             return out\n        x, y = x + direction[0] * jump, y + direction[1] * jump", "import random\n\ndef const(n):\n    return lambda itp: itp.push(n)\n\ndef unary(f):\n    return lambda itp: itp.push(f(itp.pop()))\n\ndef binary(f):\n    return lambda itp: itp.push(f(itp.pop(), itp.pop()))\n\ndef direction(x, y):\n    return lambda itp: itp.set_vpc(x, y)\n\ndef dup(itp):\n    x = itp.pop()\n    itp.push(x)\n    itp.push(x)\n\ndef swap(itp):\n    x = itp.pop()\n    y = itp.pop()\n    itp.push(x)\n    itp.push(y)\n\nopcodes = {\n    '+': binary(lambda a, b: b + a),\n    '-': binary(lambda a, b: b - a),\n    '*': binary(lambda a, b: b * a),\n    '/': binary(lambda a, b: b / a),\n    '%': binary(lambda a, b: b % a),\n    '!': unary(lambda a: not a),\n    '`': binary(lambda a, b: b > a),\n    \n    '>': direction(1, 0),\n    '<': direction(-1, 0),\n    'v': direction(0, 1),\n    '^': direction(0, -1),\n    \n    '?': lambda itp: itp.set_vpc(*random.choice(((1, 0), (-1, 0), (0, 1), (0, -1)))),\n                          \n    '_': lambda itp: itp.set_vpc((-1)**(itp.pop() != 0), 0),\n    '|': lambda itp: itp.set_vpc(0, (-1)**(itp.pop() != 0)),\n    \n    ':': dup,\n    '\\\\': swap,\n    \n    '$': lambda itp: itp.pop(),\n    '.': lambda itp: itp.output(str(itp.pop())),\n    ',': lambda itp: itp.output(chr(itp.pop())),\n    \n    'p': lambda itp: itp.put(itp.pop(), itp.pop(), itp.pop()),\n    'g': lambda itp: itp.push(itp.get(itp.pop(), itp.pop())),\n    \n    '#': lambda itp: itp.advance(),\n    '@': lambda itp: itp.end(), \n    ' ': lambda itp: None,\n}\n\nfor i in range(10):\n    opcodes[str(i)] = const(i)\n\nclass Interpreter:\n    def __init__(self, code):\n        self.mem = [list(l) for l in code.split('\\n')]\n        self.stack = []\n        self.pc = 0, 0\n        self.vpc = 1, 0\n        self.obuf = []\n        self.ended = False\n        self.stringmode = False\n    \n    def run(self):\n        while not self.ended:\n            x, y = self.pc\n            op = self.mem[y][x]\n        \n            if op == '\"':\n                self.stringmode = not self.stringmode\n            elif self.stringmode:\n                self.push(ord(op))\n            else:\n                opcodes[op](self)\n        \n            self.advance()\n    \n    def advance(self):\n        x, y = self.pc\n        vx, vy = self.vpc\n        y = (y + vy) % len(self.mem)\n        x = (x + vx) % len(self.mem[y])\n        self.pc = x, y\n    \n    def set_vpc(self, x, y):\n        self.vpc = x, y\n    \n    def push(self, x):\n        self.stack.append(int(x))\n    \n    def pop(self):\n        try:\n            return self.stack.pop(-1)\n        except IndexError:\n            return 0\n    \n    def output(self, s):\n        self.obuf.append(s)\n\n    def end(self):\n        self.ended = True\n\n    def get(self, y, x):\n        return ord(self.mem[y][x])\n\n    def put(self, y, x, n):\n        self.mem[y][x] = chr(n)\n\ndef interpret(code):\n    itp = Interpreter(code)\n    \n    itp.run()\n    \n    return ''.join(itp.obuf)", "import random\n\ndef interpret(code):\n    output = \"\"\n    coordinates = code.split(\"\\n\")\n    coordinate = [list(row) for row in coordinates]\n    stack = []\n    x = 0 \n    y = 0\n    dx = 1\n    dy = 0\n    a = \"\"\n    temp=1\n    ascii_code = 0\n    opened = False\n    skip_next = False\n    \n    while True:\n        command = coordinate[y][x]\n        if skip_next:\n            skip_next = False\n            x += dx\n            y += dy\n            continue\n        elif command.isnumeric():\n            stack.append(int(command))\n        elif command == '>':\n            dx = 1\n            dy = 0\n        elif command == '<':\n            dx = -1\n            dy = 0\n        elif command == '^':\n            dx = 0\n            dy = -1\n        elif command == 'v':\n            dx = 0\n            dy = 1\n        elif command == '?':\n            dx = random.randint(-1,1)\n            if dx != 0:\n                dy = 0\n            else:\n                dy = random.choice([-1, 1])\n        elif command == '\"':\n            opened = not opened\n        elif opened:\n            stack.append(ord(command))\n        elif command == \"+\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(a + b)\n        elif command == \"-\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b - a)\n        elif command == \"*\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(a * b)\n        elif command == \"/\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(int(b / a) if a != 0 else 0)\n        elif command == \"%\":\n            a, b = stack.pop(), stack.pop()\n            stack.append(b % a if a != 0 else 0)\n        elif command == \"!\":\n            if int(stack[-1]) == 0:\n                stack[-1] = 1\n            else:\n                stack[-1] = 0\n        elif command == \"`\":\n            a, b = stack.pop(), stack.pop()\n            if b > a:\n                stack.append(1)\n            else:\n                stack.append(0)\n        elif command == \"_\":\n            if stack.pop() == 0:\n                dx = 1\n                dy = 0\n            else:\n                dx = -1\n                dy = 0\n        elif command == \"|\":\n            if stack.pop()  == 0:\n                dx = 0\n                dy = 1\n            else:\n                dx = 0\n                dy = -1\n        elif command == \":\":\n            if len(stack) == 0:\n                stack.append(0)\n            else:\n                stack.append(stack[-1])\n        elif command == \"\\\\\":\n            if len(stack) < 2:\n                stack.append(0)\n            else:\n                a = stack[-1]\n                stack[-1] = stack[-2]\n                stack[-2] = a\n        elif command == \"$\":\n            if len(stack) != 0:\n                stack.pop()\n        elif command == \".\":\n            if len(stack) !=0:\n                output += str(stack.pop())\n        elif command == \",\":\n            if len(stack) !=0:\n                ascii_code = stack[-1]\n                output += chr(ascii_code)\n            stack.pop()\n        elif command == \"#\":\n            skip_next = True\n        elif command == \"p\":\n            y1, x1, v = stack.pop(), stack.pop(), stack.pop()\n            coordinate[y1][x1] = chr(v)\n        elif command == \"g\":\n            y1, x1 = stack.pop(), stack.pop()\n            stack.append(ord(coordinate[y1][x1]))\n        elif command == '@':\n            break\n        x += dx\n        y += dy\n    return output", "import random\n\ndirections = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n\nclass Befunge93Instance:\n    def __init__(self, code, step_limit=9999):\n        self.code = [[i for i in line] for line in code.split('\\n')]  # code can be mutated so can't leave as string\n        for line in code.split('\\n'):\n            print(line)\n        self.head = [0, 0]  # current execution point\n        self.stack = []\n        self.direction = directions[0]\n        self.output = ''\n        self.string_mode = False\n        self.steps = 0\n        self.step_limit = step_limit\n\n    def get_instr(self):\n        try:\n            return self.code[self.head[0]][self.head[1]]\n        except IndexError:\n            print(('head out of range: {}'.format(self.head)))\n            return 0\n\n    def set_direction(self, direction_index):\n        self.direction = directions[direction_index]\n\n    def advance_head(self):\n        self.head[0] += self.direction[0]\n        self.head[1] += self.direction[1]\n\n    # return 0 if empty\n    def pop_stack(self) -> int:\n        try:\n            return self.stack.pop()\n        except IndexError:\n            return 0\n\n    # \"singular stack which we will assume is unbounded and only contain integers\"\n    def push_stack(self, item):\n        try:\n            self.stack.append(int(item))\n        except ValueError:\n            self.stack.append(int(ord(item)))  # ascii to int\n\n    def operation(self, op):\n        try:\n            a = self.pop_stack()\n            b = self.pop_stack()\n            self.stack.append(op(a, b))\n        except ZeroDivisionError:\n            self.stack.append(0)\n\n    def print_status(self):\n        print()\n        print(('{} output({})'.format(self.steps, self.output)))\n        print((self.stack))\n        print(('head {} dir {} instr {}'.format(self.head, self.direction, self.get_instr())))\n\n    def exec_instr(self) -> bool:\n        self.steps += 1\n\n        if self.steps > self.step_limit:\n            return False\n\n        instr = self.get_instr()\n        #self.print_status()\n\n        if self.string_mode:\n            if instr == '\\\"':\n                self.string_mode = False\n            else:\n                self.push_stack(instr)\n            self.advance_head()\n            return True\n\n        if instr in '0123456789':\n            self.stack.append(int(instr))\n        elif instr == '+':\n            self.operation(lambda a, b: a + b)\n        elif instr == '-':\n            self.operation(lambda a, b: b - a)\n        elif instr == '*':\n            self.operation(lambda a, b: a * b)\n        elif instr == '/':\n            self.operation(lambda a, b: b // a)\n        elif instr == '%':\n            self.operation(lambda a, b: b % a)\n        elif instr == '!':\n            self.push_stack(not self.pop_stack())\n        elif instr == '`':\n            self.operation(lambda a, b: int(b > a))\n        elif instr in '><v^':\n            self.set_direction('><v^'.index(instr))\n        elif instr == '?':\n            self.set_direction(random.randint(0, 3))\n        elif instr == '_':\n            if self.pop_stack() == 0:\n                self.set_direction(0)\n            else:\n                self.set_direction(1)\n        elif instr == '|':\n            if self.pop_stack() == 0:\n                self.set_direction(2)\n            else:\n                self.set_direction(3)\n        elif instr == '\\\"':\n            self.string_mode = True\n        elif instr == ':':  # duplicate top value\n            try:\n                self.stack.append(self.stack[-1])\n            except IndexError:\n                self.stack.append(0)\n        elif instr == '\\\\':  # swap top of stack\n            try:\n                self.stack[-1], self.stack[-2] = self.stack[-2], self.stack[-1]\n            except IndexError:\n                self.stack.append(0)\n        elif instr == '$':\n            self.pop_stack()\n        elif instr == '.':  # int\n            self.output += str(self.pop_stack())\n        elif instr == ',':\n            self.output += chr(self.pop_stack())  # int code to ascii char, 10 = \\n, etc\n        elif instr == '#':\n            self.advance_head()\n        elif instr == 'p':  # put\n            x = self.pop_stack()\n            y = self.pop_stack()\n            value = self.pop_stack()\n            self.code[x][y] = chr(value)  # int code to ascii char, 10 = \\n, etc\n            # print(self.code[x])\n        elif instr == 'g':  # get\n            x = self.pop_stack()\n            y = self.pop_stack()\n            self.push_stack(ord(self.code[x][y]))  # ascii char to int code\n        elif instr == '@':  # end\n            return False\n\n        self.advance_head()\n        return True\n\n    def run(self):\n        while self.exec_instr():\n            pass\n\n\ndef interpret(code):\n    interpreter = Befunge93Instance(code)\n    interpreter.run()\n    return interpreter.output\n", "from math import floor\nimport random\ndef interpret(s):\n    s,j,k = [[j for j in i] for i in s.splitlines()],0,-1\n    direction,stack,output = 'right',[],[]\n    while 1:\n        if direction == \"right\" : k += 1\n        elif direction == \"left\" : k -= 1\n        elif direction == \"up\" : j -= 1\n        elif direction == \"down\" : j += 1\n        i = s[j][k]\n        if i in \"+-*/%`g\" :     a,b = stack.pop(),stack.pop()\n        if i.isdigit() :        stack.append(int(i))\n        elif i == '+' :         stack.append(a + b)\n        elif i == '-' :         stack.append(b - a)\n        elif i == '*' :         stack.append(a * b)\n        elif i == '/' :         stack.append(0 if not a else int(floor(b / a)))\n        elif i == '%' :         stack.append(0 if not a else b % a)\n        elif i == '!' :         stack.append(1 if not stack.pop() else 0)\n        elif i == '`' :         stack.append(1 if b > a else 0)\n        elif i == '>' :         direction = 'right'\n        elif i == \"<\" :         direction = 'left'\n        elif i == \"^\" :         direction = 'up'\n        elif i == 'v' :         direction = 'down'\n        elif i == '?' :         direction = random.choice(['right', 'left', 'down', 'up'])\n        elif i == '_' :         direction = 'right' if not stack.pop() else 'left'\n        elif i == '|' :         direction = 'down' if not stack.pop()else 'up'\n        elif i == ':' :         stack.append(0 if not stack else stack[-1])\n        elif i == '$' :         stack.pop()\n        elif i == '.' :         output.append(stack.pop())\n        elif i == ',' :         output.append(chr(stack.pop()))\n        elif i == 'p' :         y,x,v = stack.pop(),stack.pop(),stack.pop() ; s[y][x] = chr(v)\n        elif i == 'g' :         stack.append(ord(s[a][b]))\n        elif i == '\\\\':\n          if len(stack) == 1 : stack.insert(0, 0)\n          else :               stack[-1], stack[-2] = stack[-2], stack[-1]\n        if i == '#':\n            if direction == 'right' : k += 1\n            elif direction == 'left': k -= 1\n            elif direction == 'up' :  j -= 1\n            elif direction == 'down': j += 1\n        if i == '\"':\n            k += (1 if direction =='right' else -1)\n            while s[j][k] != '\"':\n                stack.append(ord(s[j][k])) ; k += (1 if direction =='right' else -1)\n        if i == '@' :           break\n    return \"\".join(map(str,output))", "from random import choice\n#\u9898\u76ee\u592a\u590d\u6742,\u8df3\u8fc7\u8fd9\u4e2a\u9898\ndef interpret(code):\n    code = [list(l) for l in code.split('\\n')]\n    x, y = 0, 0\n    dx, dy = 1, 0\n    output = ''\n    stack = []\n    string_mode = False\n    \n    while True:\n        move = 1\n        i = code[y][x]\n        \n        if string_mode:\n            if i == '\"':\n                string_mode = False\n            else:\n                stack.append(ord(i))\n        else:\n        \n            if i.isdigit(): stack.append(int(i))\n            elif i == '+': stack[-2:] = [stack[-2] + stack[-1]]\n            elif i == '-': stack[-2:] = [stack[-2] - stack[-1]]\n            elif i == '*': stack[-2:] = [stack[-2] * stack[-1]]\n            elif i == '/': stack[-2:] = [stack[-2] and stack[-2] / stack[-1]]\n            elif i == '%': stack[-2:] = [stack[-2] and stack[-2] % stack[-1]]\n            elif i == '!': stack[-1] = not stack[-1]\n            elif i == '`': stack[-2:] = [stack[-2] > stack[-1]]\n            elif i in '><^v?':\n                if i == '?':   i = choice('><^v')\n                if i == '>':   dx, dy =  1,  0\n                elif i == '<': dx, dy = -1,  0\n                elif i == '^': dx, dy =  0, -1\n                elif i == 'v': dx, dy =  0,  1\n            elif i == '_': dx, dy = (-1 if stack.pop() else 1), 0\n            elif i == '|': dx, dy = 0, (-1 if stack.pop() else 1)\n            elif i == '\"': string_mode = True\n            elif i == ':': stack.append(stack[-1] if stack else 0)\n            elif i == '\\\\': stack[-2:] = stack[-2:][::-1]\n            elif i == '$': stack.pop()\n            elif i == '.': output += str(stack.pop())\n            elif i == ',': output += chr(stack.pop())\n            elif i == '#': move += 1\n            elif i == 'p':\n                ty, tx, tv = stack.pop(), stack.pop(), stack.pop()\n                code[ty][tx] = chr(tv)\n            elif i == 'g':\n                ty, tx = stack.pop(), stack.pop()\n                stack.append(ord(code[ty][tx]))\n            elif i == '@':\n                return output\n        \n        for _ in range(move):\n            x = (x + dx) % len(code[y])\n            y = (y + dy) % len(code)", "from random import randint, seed\ndef interpret(code):\n    i = list(map(list,code.split('\\n')))\n    res = ''\n    dir = ((1,0),(-1,0),(0,-1),(0,1))\n    x, y = 0, 0\n    dx, dy = 1, 0\n    seed()\n    s = []\n    str_mode = False\n    while True:\n        o = i[y][x]\n        if str_mode and o != '\"':s.append(ord(o))\n        elif o in '0123456789': s.append(int(o))\n        elif o == '+':s.append(s.pop()+s.pop())\n        elif o == '-':s.append(-s.pop()+s.pop())\n        elif o == '*':s.append(s.pop()*s.pop())\n        elif o in '/%' :\n            a = s.pop()\n            if a:\n                if o == '/':\n                    s.append(s.pop()//a)\n                else:\n                    s.append(s.pop()%a)\n            else:\n                s[len(s)-1] = 0\n        elif o == '!':s.append(0 if s.pop() else 1)\n        elif o == '`':s.append(int(s.pop()<s.pop()))\n        elif o == '>':dx, dy = dir[0]\n        elif o == '<':dx, dy = dir[1]\n        elif o == '^':dx, dy = dir[2]\n        elif o == 'v':dx, dy = dir[3]\n        elif o == '?':dx, dy = dir[randint(0,3)]\n        elif o == '_':dx, dy = dir[1 if s.pop() else 0]\n        elif o == '|':dx, dy = dir[2 if s.pop() else 3]\n        elif o == '\"':str_mode = not str_mode\n        elif o == ':':\n            if s:s.append(s[len(s)-1])\n            else:s = [0,0]\n        elif o == '\\\\':\n            if s:\n                if len(s)==1:\n                    s.insert(0,0)\n                else:\n                    s.insert(len(s)-2, s.pop())\n            else:s = [0,0]\n        elif o == '$':s.pop()\n        elif o == '.':res += str(s.pop())\n        elif o == ',':res += chr(s.pop())\n        elif o == '#':x, y = x+dx, y+dy\n        elif o == 'p':\n            py = s.pop()\n            px = s.pop()\n            i[py][px] = chr(s.pop())\n        elif o == 'g':s.append(ord(i[s.pop()][s.pop()]))\n        elif o == '@':\n            return res\n        x+=dx\n        y+=dy", "import inspect\nimport random\n\n\ndef interpret(s):\n    return Befunge93(s.splitlines()).run()\n\n\nclass Befunge93:\n\n    instructions = {}\n\n    def __init__(self, plane):\n        self.plane = [list(row) for row in plane]\n        self.stack = []\n        self.direction = [0, 1]\n        self.row, self.col = 0, 0\n        self.running = True\n        self.output = []\n        self.number = 0\n\n    def forward(self):\n        if self.number:\n            self.row += self.direction[0]\n            self.col += self.direction[1]\n        self.number += 1\n        return self.plane[self.row][self.col]\n\n    def string_literal(self):\n        self.stack.extend(ord(ch) for ch in iter(self.forward, '\"'))\n\n    def run(self):\n        while self.running:\n            self.instructions[self.forward()](self)\n        return ''.join(self.output)\n\n\ndef pop_push_on(ch):\n    def deco(f):\n        nargs = len(inspect.getargspec(f).args)\n        def wrapper(self):\n            self.stack.append(f(*[self.stack.pop() for i in range(nargs)]))\n        Befunge93.instructions[ch] = wrapper\n        return wrapper\n    return deco\n\ndef on(ch): return lambda f: Befunge93.instructions.__setitem__(ch, f)\n\npop_push_on('+')(lambda a, b: a + b)\npop_push_on('-')(lambda a, b: b - a)\npop_push_on('*')(lambda a, b: a * b)\npop_push_on('/')(lambda a, b: b // a if a else 0)\npop_push_on('%')(lambda a, b: b % a if a else 0)\npop_push_on('!')(lambda a: 0 if a else 1)\npop_push_on('`')(lambda a, b: 1 if b > a else 0)\non('>')(lambda self: self.direction.__setitem__(slice(None), [0, +1]))\non('<')(lambda self: self.direction.__setitem__(slice(None), [0, -1]))\non('^')(lambda self: self.direction.__setitem__(slice(None), [-1, 0]))\non('v')(lambda self: self.direction.__setitem__(slice(None), [+1, 0]))\non('?')(lambda self: self.direction.__setitem__(slice(None), random.choice([[0, +1], [0, -1], [-1, 0], [+1, 0]])))\non('_')(lambda self: self.direction.__setitem__(slice(None), [0, +1] if self.stack.pop() == 0 else [0, -1]))\non('|')(lambda self: self.direction.__setitem__(slice(None), [+1, 0] if self.stack.pop() == 0 else [-1, 0]))\non('|')(lambda self: self.direction.__setitem__(slice(None), [+1, 0] if self.stack.pop() == 0 else [-1, 0]))\non(':')(lambda self: self.stack.append(self.stack[-1] if self.stack else 0))\non('\\\\')(lambda self: self.stack.append(self.stack.pop(-2) if len(self.stack) >= 2 else 0))\non(' ')(lambda self: 0)\non('@')(lambda self: setattr(self, 'running', False))\non('$')(lambda self: self.stack.pop())\non('.')(lambda self: self.output.append(str(self.stack.pop())))\non(',')(lambda self: self.output.append(chr(self.stack.pop())))\non('#')(lambda self: self.forward())\non('\"')(lambda self: self.string_literal())\non('p')(lambda self: self.plane[self.stack.pop()].__setitem__(self.stack.pop(), chr(self.stack.pop())))\non('g')(lambda self: self.stack.append(ord(self.plane[self.stack.pop()][self.stack.pop()])))\nfor ch in '0123456789': on(ch)(lambda self, ch=int(ch): self.stack.append(ch))"]