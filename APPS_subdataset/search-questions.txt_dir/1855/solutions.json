["# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution(object):\n         def validBST(self, root, min, max):\n             if root == None:\n                 return True\n             if root.val <= min or root.val >= max:\n                 return False\n             return self.validBST(root.left, min, root.val) and self.validBST(root.right, root.val, max)\n         def isValidBST(self, root):\n             return self.validBST(root, -21474836480, 21474836470)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n import sys\n class Solution:\n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         if not root or (not root.left and not root.right):\n             return True\n         return self.isBst(root, [], [])\n     def isBst(self, root, min_nums, max_nums):\n         # if root:\n         #     print(\"root:\", root.val)\n         # else:\n         #     print(\"root:\", root)\n         # print(\"min_nums\", min_nums)\n         # print(\"max_nums\", max_nums)\n         if not root:\n             return True\n         min_value = min(min_nums) if min_nums else sys.maxsize\n         max_value = max(max_nums) if max_nums else -sys.maxsize-1\n         left = self.isBst(root.left, min_nums+[root.val], max_nums)\n         right = self.isBst(root.right, min_nums, max_nums+[root.val])\n         if root.val < min_value and root.val > max_value and left and right:\n             return True\n         else:\n             return False\n             \n             ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         if root is None:\n             return True\n         self.output_list = []\n         self.recurse(root)\n         print(self.output_list)\n         for i in range(len(self.output_list) - 1):\n             if self.output_list[i+1] <= self.output_list[i]:\n                 return False\n         return True\n         \n     def recurse(self, root):\n         \"\"\"\n         :type root: TreeNode\n         \"\"\"\n \n         if root.left is not None and root.right is not None:\n             self.recurse(root.left)\n             self.output_list.append(root.val)\n             self.recurse(root.right)\n         elif root.left is not None:\n             self.recurse(root.left)\n             self.output_list.append(root.val)\n         elif root.right is not None:\n             self.output_list.append(root.val)\n             self.recurse(root.right)\n         else:\n             self.output_list.append(root.val)\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         # Time: O(|V| + |E|) = O(n)\n         # Space: O(log(n))\n         def isValid(node, lo, hi):\n             if lo != None:\n                 if node.val <= lo:\n                     return False\n             if hi != None:\n                 if node.val >= hi:\n                     return False\n             if node.left != None:\n                 if not isValid(node.left, lo, node.val):\n                     return False\n             if node.right != None:\n                 if not isValid(node.right, node.val, hi):\n                     return False\n             return True\n         \n         if root == None: return True\n         return isValid(root, None, None)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n import sys\n \n class Solution:\n     def isValidBST(self, root):\n         return isBSTUtil(root, -sys.maxsize, sys.maxsize)\n     \n \n def isBSTUtil(root, min, max):\n     if root == None:\n         return True\n     \n     if root.val <= min or root.val >= max:\n         return False\n     \n     return isBSTUtil(root.left, min, root.val) and isBSTUtil(root.right, root.val, max)", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def isValidBST(self, node):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         def valid(somenode, ceiling, floor):\n             if somenode is None:\n                 return True\n             if somenode.val >= ceiling or somenode.val <= floor:\n                 return False\n             \n             \n             return valid(somenode.left, somenode.val, floor) and valid(somenode.right, ceiling, somenode.val)\n         \n         return valid(node, sys.maxsize, -sys.maxsize)\n             \n             \n          \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def traverse(self, root, hold):\n         if root.left:\n             self.traverse(root.left, hold)\n         hold.append(root.val)\n         if root.right:\n             self.traverse(root.right, hold)\n         \n     \n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         hold = []\n         if not root:\n             return True\n         self.traverse(root, hold)\n         size_tree = len(hold)\n         for ele in range(size_tree-1):\n             if not hold[ele] < hold[ele+1]:\n                 return False\n         return True\n             ", "class Solution:\n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         if not root:\n             return True\n \n         return self.dfs(root)[2]\n         \n     def dfs(self, node):\n         \"\"\"return [min, max, is_BST]\"\"\"\n         if node is None:\n             return [None, None, True]\n         \n         L = self.dfs(node.left)\n         R = self.dfs(node.right)\n         if not L[2] or not R[2] \\\n         or (L[1] is not None and L[1] >= node.val) \\\n         or (R[0] is not None and R[0] <= node.val):\n             return [None, None, False]\n         \n         if L[0] is not None:\n             min = L[0]\n         else:\n             min = node.val\n         if R[1] is not None:\n             max = R[1]\n         else:\n             max = node.val\n \n         return [min, max, True]", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     sol = []\n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         self.sol = []\n         if root is None:\n             return True \n         self.traverseBST(root)\n         print(self.sol)\n         for i in range(1,len(self.sol)):\n             if self.sol[i] <= self.sol[i-1]:\n                 return False\n         return True\n     \n     # def isValid(self,root):\n     #     if root.left and root.right:\n     #         if root.left.val< root.val and root.right.val>root.val:\n     #             return True\n     #     elif root.left:\n     #         if root.left.val< root.val:\n     #             return True\n     #     elif root.right:\n     #         if root.right.val>root.val:\n     #             return True\n     #     else:\n     #         return True\n     #     return False\n \n     \n     def traverseBST(self, root):\n         if root.left:\n             self.traverseBST(root.left)\n         print(root.val)\n         self.sol.append(root.val)\n         # if not self.isValid(root):\n         #     return False\n         if root.right:\n             self.traverseBST(root.right)\n         return True\n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:   \n     \n     def valid(self, me, parents_lt, parents_gt):\n         if me is None:\n             return True\n         \n         #print(me.val)\n         #print(me.left.val) if me.left is not None else print(\"left: None\")\n         #print(me.right.val) if me.right is not None else print(\"right: None\")\n         #print(parents_lt)\n         #print(parents_gt)\n         #print('---')\n         for p in parents_lt:\n             if p.val >= me.val:\n                 print('a')\n                 return False\n         \n         for p in parents_gt:\n             if p.val <= me.val:\n                 print('b')\n                 return False\n         \n         if me.left is not None:\n             if me.left.val >= me.val:\n                 print('c')\n                 return False\n             \n         if me.right is not None:\n             if me.right.val <= me.val:\n                 print('d')\n                 return False\n         gt2 = parents_gt + [me]\n         lt2 = parents_lt + [me]\n         return self.valid(me.left, parents_lt, gt2) and self.valid(me.right, lt2, parents_gt)\n         \n     \n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         if root is None:\n             return True        \n         \n         return self.valid(root, list(), list())", "class Solution(object):\n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         res=[]\n         return self.inorder(root,res)\n \n     def inorder(self,root,res):\n         if not root:\n             return True\n         if self.inorder(root.left,res) == False:\n             return False\n         if len(res)!=0:\n             last = res.pop()\n             if last>= root.val:\n                 return False\n             res.append(last)\n         res.append(root.val)\n         if self.inorder(root.right,res) == False:\n             return False\n         return True\n \n       \n    \n \n \n \n \n \n", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     \n     def inOrderTravel(self,root):\n         res = []\n         if root == None:\n             return []\n         \n         res += self.inOrderTravel(root.left)\n         res.append(root.val)\n         res += self.inOrderTravel(root.right)\n         \n         return res\n     \n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         res  = self.inOrderTravel(root)\n         for i in range(1, len(res)):\n             if res[i] <= res[i-1]:\n                 return False\n         \n         return True\n         \n         \n         \n         ", "# Definition for a binary tree node.\n # class TreeNode:\n #     def __init__(self, x):\n #         self.val = x\n #         self.left = None\n #         self.right = None\n \n class Solution:\n     def isValidBST(self, root):\n         \"\"\"\n         :type root: TreeNode\n         :rtype: bool\n         \"\"\"\n         stack = []\n         pre = None\n         while stack or root:\n             while root:\n                 stack.append(root)\n                 root = root.left\n             root = stack.pop()\n             if pre and root.val <= pre.val: return False\n             pre = root\n             root = root.right\n         return True\n     "]