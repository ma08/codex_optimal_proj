["def solomons_quest(arr):\n    pos, lvl = [0,0], 0\n    for dilat,dir,dist in arr:\n        lvl += dilat\n        pos[dir in [0,2]] += dist * 2**lvl * (-1)**( dir in [2,3] )\n    return pos", "def solomons_quest(arr):\n    level = 0\n    ds = [1j, 1, -1j, -1]\n    pos = 0\n    for level_shift, direction, distance in arr:\n        level += level_shift\n        pos += (2**level) * (ds[direction] * distance)\n    return [int(pos.real), int(pos.imag)]", "\n#Directions player can move: North is positive y axis, East is positive x axis\nclass Direction:\n    North = 0;  East = 1;  South = 2;  West = 3\n#-----end classDirection\n\n\n#The data of the hero of the story\nclass Solomon:\n    curDir = Direction.North    #default direction is set to facing north\n    xLoc = 0            # East and West directions (East is positive x)\n    yLoc = 0            # North and South directions (Nortn is positive y)\n    timeDepth = 0       #Current depth of the traveler\n    timeFactor = 2      #This factor is constant and is based on game definition\n#-----end class\n\n\n\n\ndef unpackWayPoint(wayPoint):\n    amountTimeDialation = wayPoint[0]\n    newDir = wayPoint[1]\n    distToTravel = wayPoint[2]\n\n    return amountTimeDialation, newDir, distToTravel\n#-----end function\n\n\n\ndef updateHeroDistance(hero, dirOfTravel, trueDistToMove):\n\n    if dirOfTravel == Direction.North:\n        hero.yLoc += trueDistToMove\n    elif dirOfTravel == Direction.South:\n        hero.yLoc -= trueDistToMove\n    elif dirOfTravel == Direction.East:\n        hero.xLoc += trueDistToMove\n    else:\n        hero.xLoc -= trueDistToMove\n\n#-----end fucntion\n\n#a small helper debugger function\ndef printDist(hero):\n    print(('''Hero's location: [''', hero.xLoc, ',', hero.yLoc, ']'))\n\n\ndef solomons_quest(wayPoints):\n    hero = Solomon()\n\n    for nextStop in wayPoints:\n        amtTimeDialation, dirOfTravel, amtToTravel = unpackWayPoint(nextStop)\n\n        #update hero based on the waypoint data\n        hero.timeDepth += amtTimeDialation\n        trueDistToMove = (hero.timeFactor**hero.timeDepth)*amtToTravel  #dist is based on depth and factor\n        updateHeroDistance(hero, dirOfTravel, trueDistToMove)\n\n    #pack data in a list\n    heroFinalLoc = [hero.xLoc, hero.yLoc]\n\n    return heroFinalLoc\n#-----end function\n", "def solomons_quest(arr):\n    d, count, out = {0: 1, 1: 1, 2: -1, 3: -1}, 0, [0, 0]\n    for i in arr:\n        count += i[0]\n        x = (2**count) * d[i[1]] * i[2]\n        if i[1] % 2 == 1: out[0] += x\n        else: out[1] += x\n    return out", "def solomons_quest(arr):\n    south_north = 0\n    east_west = 0\n    layer = 0\n    for el in arr:\n        layer += el[0]\n        if el[1] ==0:\n            south_north +=  el[2] * 2**layer\n        elif el[1]==2:\n            south_north -= el[2] * 2**layer\n        elif el[1]==1:\n            east_west += el[2] * 2**layer\n        elif el[1]==3:\n            east_west -= el[2] * 2**layer\n    \n    return [east_west,south_north]\n", "def solomons_quest(arr):\n    d_t = 0\n    loc = [0,0]\n    for r in arr:\n        d_t += r[0]\n        if(r[1] > 1):\n            loc[3%r[1]] -= r[2]*(2**d_t)\n        else:\n            loc[(r[1]+1)%2] += r[2]*(2**d_t)\n    return loc", "def solomons_quest(arr):\n    l,c = 0,[0,0]\n    for way in arr:\n        l+=way[0]\n        c[(way[1]+1)%2] += ((-1)**(way[1]//2)) *way[2]*(2**l)\n    return c", "def solomons_quest(arr):\n  layer = 0\n  coord = [0,0]\n  for i in arr:\n    layer = layer + i[0]\n    if i[1] == 0: # increase the y-coordinate\n      coord[1] = coord[1] + i[2] * 2 ** layer\n    if i[1] == 1: # increase the x-coordinate\n      coord[0] = coord[0] + i[2] * 2 ** layer\n    if i[1] == 2: # decrease the y-coordinate\n      coord[1] = coord[1] - i[2] * 2 ** layer\n    if i[1] == 3: # decrease the x-coordinate\n      coord[0] = coord[0] - i[2] * 2 ** layer\n  return coord", "def solomons_quest(arr):\n    layer = x = y = 0\n    for l, dir_, distance in arr:\n        layer = [layer+l,0][layer+l<0]\n        inc, dec, r = [1,0,-1,0][dir_], [0,1,0,-1][dir_], distance*2**layer\n        x += inc * r ; y += dec * r\n    return [y,x]", "MOVE = [lambda d,x,y,l: (x, y+d, l), lambda d,x,y,l: (x+d, y, l), lambda d,x,y,l: (x, y-d, l), lambda d,x,y,l: (x-d, y, l)]\n\ndef solomons_quest(arr):\n    x = y = l = 0\n    for a,b,c in arr: x, y, l = MOVE[b](c * 2**(l+a), x, y, l+a)\n    return [x, y]"]