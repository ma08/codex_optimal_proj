["from typing import *\nfrom heapq import heappop, heappush\n\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        N = len(quality)\n        heap_quality = []\n        workers = [i for i in range(N)]\n        workers = sorted(workers, key=lambda x: wage[x] / quality[x])\n        sum_quality = 0\n        for i in range(K):\n            heappush(heap_quality, -quality[workers[i]])\n            sum_quality += quality[workers[i]]\n        ans = sum_quality * (wage[workers[K - 1]] / quality[workers[K - 1]])\n        for i in range(K, N):\n            heappush(heap_quality, -quality[workers[i]])\n            sum_quality += quality[workers[i]]\n            sum_quality += heappop(heap_quality)  # negative quality value\n            ans = min(ans, sum_quality * (wage[workers[i]] / quality[workers[i]]))\n        return ans", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        res = float('inf')\n        qsum = 0\n        heap = []\n        for r, q in workers:\n            heapq.heappush(heap, -q)\n            qsum += q\n            if len(heap) > K: qsum += heapq.heappop(heap)\n            if len(heap) == K: res = min(res, qsum * r)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)", "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, K):\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n        \n        print(workers)\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n        print(workers)\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            #print(pool)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n                #print(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n                #print(sumq)\n                #print(pool)\n\n        return float(ans)", "import heapq\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        n_workers = len(wage)\n        pairs = [None]*n_workers # (quality, wage/quality) \n        for i in range(n_workers): \n            pairs[i] = (quality[i], wage[i]/quality[i])\n\n        pairs = sorted(pairs, key=lambda x: (x[1])) # sort dec by ratio then quality \n        \n        # incorrect solution\n        # max_q = pairs[i:i+K]\n        # for i in range(n_workers-K+1):\n            # min_cost = min(min_cost, self.cost(pairs[i:i+K]))\n        \n        sum_q = sum([p[0] for p in pairs[0:K]])\n        maxheap_q = [-p[0] for p in pairs[0:K]] # use minus to create max heap\n        heapq.heapify(maxheap_q) \n        min_cost = sum_q * pairs[K-1][1]\n        \n        for i in range(K, n_workers):\n            sum_q = sum_q - (-min(maxheap_q)) + pairs[i][0]\n            min_cost = min(min_cost, sum_q * pairs[i][1])\n            heapq.heapreplace(maxheap_q, -pairs[i][0])\n            # print(sum_q * pairs[i][1])\n            \n        return min_cost\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        ratios = [[wi / qi, qi] for wi, qi in zip(wage, quality)]\n        ratios.sort(reverse=True)\n        \n        res = float('inf')\n        quality.sort()\n        \n        for ratio, q in ratios:\n            quality.remove(q)\n            candidates = quality[:K-1]\n            if len(candidates) < K - 1:\n                break\n            ans = ratio * (q + sum(candidates))   \n            res = min(res, ans)\n            \n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        extra_worker_heap = list()\n        for i in range(len(quality)):\n            heappush(extra_worker_heap, (wage[i] / quality[i], quality[i]))\n        \n        hired_worker_heap = list()\n        hired_quality = 0\n        wage_to_quality = 0\n        min_cost = 1e10\n        while extra_worker_heap:\n            cur_wage_to_quality, worker_quality = heappop(extra_worker_heap)\n            hired_quality += worker_quality\n            heappush(hired_worker_heap, -worker_quality)\n            while len(hired_worker_heap) > K:\n                hired_quality += heappop(hired_worker_heap)\n            if len(hired_worker_heap) == K:\n                min_cost = min(min_cost, hired_quality * cur_wage_to_quality)\n        return min_cost", "from heapq import *\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        workers = []\n        for i in range(len(quality)):\n            workers.append([wage[i] / quality[i], wage[i], quality[i]])\n            \n        workers = sorted(workers, key = lambda x: [x[0], x[2], x[1]])\n                         \n        cost = math.inf \n        maxHeap = []\n        tot = 0\n                         \n        for r, w, q in workers:\n            heappush(maxHeap, -q)\n            tot += q\n\n            if len(maxHeap) > K:\n                tot += heappop(maxHeap)\n\n            if len(maxHeap) == K:\n                cost = min(cost, r * tot)\n\n        return float(cost)\n        \n            \n", "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, K):\n        from fractions import Fraction\n        workers = sorted((w/q, q, w)\n                         for q, w in zip(quality, wage))\n        print(workers)\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)", "import heapq\n\nclass Solution:\n    def mincostToHireWorkers(self, quality, wage, K: int) -> float:\n        # consider with min coefficient\n        workers = sorted([[w/q,q,w] for q,w in zip(quality, wage)])\n        res = float('inf')\n        pool = []\n        sumq = 0\n        for r, q, w in workers:\n            # candidates with maximaml quality first\n            heappush(pool, -q)\n            sumq += q\n            if len(pool) > K:\n                # remove redundant\n                a = heappop(pool)\n                sumq += a # subtract a from sum\n            if len(pool) == K:\n                res = min(res, r * sumq)\n        return res        \n                \n                \n                \n                \n            \n            \n\n                           \n            \n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        \n        # sorting workers based on the ration of wage and quality\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        \n        ans = float('inf')\n        heap = []\n        heapSum = 0\n        \n        for ratio, q in workers:\n            heapq.heappush(heap, -q) # max heap based off quality\n            heapSum += q\n            \n            if len(heap) > K:# if len of heap > K add largest heap elem\n                heapSum += heapq.heappop(heap)\n            \n            if len(heap) == K:\n                ans = min(ans, ratio * heapSum)\n        \n        return float(ans)", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        employees = sorted([[w/q, q] for w,q in zip(wage, quality)])\n        print(employees)\n        res, totalOut = math.inf, 0\n        h = []\n        \n        for rate, output in employees:\n            totalOut += output\n            heapq.heappush(h, -output)\n            if len(h) > K:\n                totalOut += heapq.heappop(h) #reduce q by removed employee - highest contribution first\n            if len(h) == K:\n                res = min(res, totalOut * rate) #worst rate in candidates * output for candidates\n            \n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        ratio = sorted((w / q, q) for w, q in zip(wage, quality))\n        h = []\n        s, res = 0, float('inf')\n        for r, q in ratio:\n            heapq.heappush(h, -q)\n            s += q\n            if len(h) > K:\n                s += heapq.heappop(h)\n            if len(h) == K:\n                res = min(res, r * s)\n        return res\n", "import heapq\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        minHeap = []\n        maxHeap = []\n        zipped = list(zip(wage, quality))\n        zipped = sorted(zipped, key = lambda x:x[0]/x[1])\n        #print(zipped)\n        minCost = float('inf')\n        totalQuality = 0\n        \n        for i in range(len(zipped)):\n            curRatio = zipped[i][0]/zipped[i][1]\n            if len(minHeap) < K:\n                heapq.heappush(minHeap, (-zipped[i][1], zipped[i][0]))\n                totalQuality += zipped[i][1]\n            else:\n                heapq.heappush(maxHeap, (zipped[i][1], zipped[i][0]))\n                \n                while curRatio*maxHeap[0][0]  < curRatio*minHeap[0][0]*-1:\n                    maxTop = heapq.heappop(maxHeap)\n                    minTop = heapq.heappop(minHeap)\n                    \n                    heapq.heappush(minHeap, (-maxTop[0], maxTop[1]))\n                    heapq.heappush(maxHeap, (-minTop[0], minTop[1]))\n                    totalQuality = totalQuality + minTop[0]\n                    totalQuality += maxTop[0]\n                    \n            \n            if len(minHeap)== K and totalQuality*curRatio < minCost:\n                minCost = totalQuality*curRatio\n        return minCost\n                \n", "from heapq import *\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        N = len(quality)\n        \n        workers = [(wage[i] / float(quality[i]), quality[i]) for i in range(N)]\n        workers = sorted(workers)\n        \n        # sum_ = sum([x[1] for x in prices_per_unit[:K - 1]])\n        \n        # print(prices_per_unit)\n        \n        result = float('inf')\n        sum_ = 0\n        max_heap = []\n        for i in range(K - 1):\n            heappush(max_heap, -workers[i][1])\n            sum_ += workers[i][1]\n            \n        for i in range(K - 1, len(workers)):\n            result = min(result, (sum_ + workers[i][1]) * workers[i][0])\n            if len(max_heap) > 0 and workers[i][1] < -max_heap[0]:\n                sum_ -= (-heappop(max_heap))\n                sum_ += workers[i][1]\n                heappush(max_heap, -workers[i][1])\n        \n        return result\n    \n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        \n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        res = float('inf')\n        qsum = 0\n        heap = []\n        for r, q in workers:\n            heapq.heappush(heap, -q)\n            qsum += q\n            if len(heap) > K: qsum += heapq.heappop(heap)\n            if len(heap) == K: res = min(res, qsum * r)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        workers = sorted([(w/q, q) for q, w in zip(quality, wage)])\n        heap = []\n        sumq = 0\n        res = float('inf')\n        \n        for r, q in workers:\n            heapq.heappush(heap, -q)\n            sumq += q\n            \n            if len(heap)>K:\n                sumq += heapq.heappop(heap)\n                \n            if len(heap)==K:\n                res = min(res, sumq*r)\n        \n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n\n        #\u8ba1\u7b97\u6700\u4f4e\u5de5\u8d44/\u5de5\u4f5c\u8d28\u91cf\u7684\u6bd4\u503c\uff1b\u7528\u4e00\u4e2a\u5806\u7ef4\u62a4K\u4e2a\u5de5\u4f5c\u8d28\u91cf\u6700\u4f4e\u7684\u5de5\u4f5c\u4eba\u5458\n\n        workers=[]\n\n        for q,w in zip(quality,wage):\n\n            workers.append((w/q,q,w))\n\n        workers.sort()\n\n        ans=float('inf')\n        dui=[]\n        sumq=0\n\n        for ratio,q,w in workers:\n            #\u6700\u5c0f\u5806\u53d8\u4e3a\u6700\u5927\u5806\n            heapq.heappush(dui,-q)\n            sumq+=q\n\n            if len(dui)>K:\n                #\u53bb\u6389\u4e00\u4e2a\u6700\u9ad8\u7684quality\n                sumq=sumq+heapq.heappop(dui)\n\n            if len(dui)==K:\n                ans=min(ans,ratio*sumq)\n\n        return ans\n\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        wq = sorted([(a / b, b) for (a, b) in zip(wage, quality)])\n        res = float('inf')\n        heap = []\n        qSum = 0\n        for avg, q in wq:\n            qSum += q\n            heapq.heappush(heap, -q)\n            if len(heap) > K: qSum += heapq.heappop(heap)\n            if len(heap) == K: res = min(res, avg * qSum)\n        return res", "import heapq\n\nclass Solution:\n    def mincostToHireWorkers_tle(self, quality: List[int], wage: List[int], K: int) -> float:\n        ans = float('inf')\n        \n        for i in range(len(quality)):\n            factor = wage[i] / quality[i]\n            \n            prices = []\n            for i in range(len(quality)):\n                if factor * quality[i] >= wage[i]:\n                    prices.append(factor * quality[i])\n                \n            if len(prices) < K:\n                continue\n            \n            prices.sort()\n            \n            ans = min(ans, sum(prices[:K]))\n            \n        return ans\n    \n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        if not quality: return 0\n        \n        workers = sorted([(wage[i] / quality[i], quality[i], wage[i]) for i in range(len(quality))])\n        \n        min_cost = float('inf')\n        total = 0\n        k_workers = []\n        for w in workers:\n            total += w[1]\n            heapq.heappush(k_workers, -w[1])\n            \n            if len(k_workers) > K:\n                total += heapq.heappop(k_workers)\n            \n            if len(k_workers) == K:\n                min_cost = min(min_cost, total * w[0])\n                \n            \n            \n                \n        return min_cost\n            \n                \n            \n                \n", "import heapq as hq\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        if K == 1:\n            return min(wage)\n        N = len(quality)\n        ratio = [(w / q, i) for i, (w, q) in enumerate(zip(wage, quality))]\n        ratio.sort()\n        quality = [quality[i] for _, i in ratio]\n        ratio = [r for r, _ in ratio]\n        min_K_queue = [-x for x in quality[: K - 1]]\n        hq.heapify(min_K_queue)\n        _sum = sum(quality[: K - 1])\n        _min = float('inf')\n        for k in range(K - 1, N):\n            _min = min((_sum + quality[k]) * ratio[k], _min)\n            if -quality[k] > min_K_queue[0]:\n                hq.heappush(min_K_queue, -quality[k])\n                poped = hq.heappop(min_K_queue)\n                _sum = _sum + poped + quality[k]\n        return _min\n            \n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        # rate, q, w\n        q_w = [(w/q,q,w) for q,w in zip(quality,wage)]\n        q_w.sort()\n        curr = sum([q_w[i][1] for i in range(K)])\n        heap = [-q_w[i][1] for i in range(K)]\n        heapq.heapify(heap)\n        r = q_w[K-1][0]\n        res = r*curr\n        for r,q,w in q_w[K:]:\n            curr+=q\n            heapq.heappush(heap,-q)\n            curr+=heapq.heappop(heap)\n            res = min(res,curr*r)\n        return res", "import heapq as hq\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        if K == 1:\n            return min(wage)\n        N = len(quality)\n        ratio = [(w / q, i) for i, (w, q) in enumerate(zip(wage, quality))]\n        ratio.sort()\n        quality = [quality[i] for _, i in ratio]\n        ratio = [r for r, _ in ratio]\n        min_K_queue = [-x for x in quality[: K - 1]]\n        hq.heapify(min_K_queue)\n        _sum = sum(quality[: K - 1])\n        _min = float('inf')\n        for k in range(K - 1, N):\n            _min = min((_sum + quality[k]) * ratio[k], _min)\n            if -quality[k] > min_K_queue[0]:\n                poped = hq.heappop(min_K_queue)\n                _sum = _sum + poped + quality[k]\n                hq.heappush(min_K_queue, -quality[k])\n        return _min\n            \n", "import heapq\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        n_workers = len(wage)\n        pairs = [None]*n_workers # (quality, ratio) \n        for i in range(n_workers): \n            pairs[i] = (quality[i], wage[i]/quality[i])\n\n        pairs = sorted(pairs, key=lambda x: (x[1])) # sort dec by ratio \n        \n        # ...incorrect solution...\n        # max_q = pairs[i:i+K]\n        # for i in range(n_workers-K+1):\n            # min_cost = min(min_cost, self.cost(pairs[i:i+K]))\n        \n        sum_q = sum([p[0] for p in pairs[0:K]])\n        maxheap_q = [-p[0] for p in pairs[0:K]] # use minus to create max heap\n        heapq.heapify(maxheap_q) \n        min_cost = sum_q * pairs[K-1][1]\n        \n        for i in range(K, n_workers):\n            sum_q = sum_q - (-heapq.heappop(maxheap_q)) + pairs[i][0]\n            min_cost = min(min_cost, sum_q * pairs[i][1])\n            heapq.heappush(maxheap_q, -pairs[i][0]) # push minus value to max heap\n            \n        return min_cost\n", "import heapq as pq\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        ratio = [[y/x, x] for x, y in zip(quality, wage)]\n        ratio.sort(key = lambda x: x[0])\n        i = 0\n        l = []\n        pq.heapify(l)\n        r = 1\n        s = 0\n        while i < K:\n            s += ratio[i][1]\n            pq.heappush(l, -ratio[i][1])\n            r = ratio[i][0]\n            i += 1\n        res = s * r\n        n = len(quality)\n        while i < n:\n            r = ratio[i][0]\n            num = ratio[i][1]\n            pq.heappush(l, -num)\n            val = -pq.heappop(l)\n            s += (num - val)\n            res = min(res, s * r)\n            i += 1\n        return res\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        workers = sorted([w/q, q] for w, q in zip(wage, quality))\n        res = float('inf')\n        qsum = 0\n        heap = []\n        for r, q in workers:\n            heapq.heappush(heap, -q)\n            qsum += q\n            if len(heap) > K: qsum += heapq.heappop(heap)\n            if len(heap) == K: res = min(res, qsum * r)\n        return res", "import heapq\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        heap=[]\n        rate=sorted(((w/q, q) for w, q in zip(wage, quality)))\n        qsum=0\n        res=float('inf')\n        for r, q in rate:\n            heapq.heappush(heap, -q)\n            qsum+=q\n            if len(heap)>K:\n                qsum+=heapq.heappop(heap)\n            if len(heap)==K:\n                res=min(res, r*qsum)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        A = []\n        for q,w in zip(quality, wage):\n            A.append([q, w/q])\n        \n        pq,ans = [],float('inf')\n        qSum, ratio = 0,0\n        for a in sorted(A, key=lambda x:x[1]):\n            if len(pq) < K:\n                heapq.heappush(pq, [-a[0], a[1]])\n                qSum += a[0]\n                ratio = a[1]\n            else:\n                negq = heapq.heappop(pq)[0]\n                qSum= qSum + negq + a[0]\n                ratio = a[1]\n                heapq.heappush(pq, [-a[0], a[1]])\n            \n            if len(pq) == K:\n                ans = min(ans, qSum*ratio)\n                \n        return ans", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        workers=sorted([(w/q, q, w) for w, q in zip(wage, quality)])\n        print(workers)\n        result=math.inf\n        qualitySum = 0\n        maxheap=[]\n        for r, q, _ in workers:\n            heapq.heappush(maxheap,-q)\n            qualitySum += q\n            if len(maxheap)>K: \n                qualitySum+=heapq.heappop(maxheap)  #add because its maxheap and we had entered negative, so in theory this line subtracts\n            if len(maxheap)==K:\n                print((qualitySum*r,r,qualitySum))\n                result=min(result,qualitySum*r)\n        return result\n        \n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        n=len(quality)\n        workers=sorted([w/q,q] for q,w in zip(quality,wage))\n        que=[]\n        res=math.inf\n        curQuality=0\n        for ratio,q in workers:\n            heapq.heappush(que,-q)\n            curQuality+=q\n            if len(que)>K:\n                q2=-heapq.heappop(que)\n                curQuality-=q2\n            if len(que)==K:\n                res=min(res,curQuality*ratio)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        #return self.greedy(quality, wage, K)\n        return self.heap(quality, wage, K)\n        \n    def greedy(self, quality, wage, K):\n        ans = float('inf')\n        \n        size = len(quality)\n        for captain in range(size):\n            ratio = wage[captain] / quality[captain]\n            \n            prices = []\n            for worker in range(size):\n                price = ratio * quality[worker]\n                if price < wage[worker]:\n                    continue\n                prices.append(price)\n            \n            if len(prices) < K:\n                continue\n            prices.sort()\n            ans = min(ans, sum(prices[:K]))\n        return float(ans)\n    \n    def heap(self, quality, wage, K):\n        \n        workers = sorted(( w / q, q, w) for q, w in zip(quality, wage))\n        \n        ans = float('inf')\n        myHeap = []\n        qualitySum = 0\n        for ratio, q, w in workers:\n            heapq.heappush(myHeap, -q)\n            qualitySum += q\n            \n            if len(myHeap) > K:\n                qualitySum += heapq.heappop(myHeap)\n            \n            if len(myHeap) == K:\n                ans = min(ans, ratio * qualitySum)\n        return float(ans)", "import heapq\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        heap=[]\n        rates=sorted([(w/q, q) for w, q in zip(wage, quality)])\n        qsum=0\n        res=float('inf')\n        for r, q in rates:\n            heapq.heappush(heap, -q)\n            qsum+=q \n            if len(heap)>K:\n                qsum+=heapq.heappop(heap)\n            if len(heap)==K:\n                res=min(res, r*qsum)\n        return res\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        n = len(quality)\n        \n        # 1. compute wage per quality for each worker i\n        wage_per_qual = []\n        for i in range(n):\n            wage_per_qual.append(wage[i] / quality[i])\n        \n        # 2. sort wage per quality (sort worker index)\n        workers = sorted(list(range(n)), key=lambda i: wage_per_qual[i])\n        \n        # 3. max heap keep track of minimum k quality\n        max_heap = []\n        # current total quality so far\n        total_quality = 0\n        \n        min_total = float('inf')\n        for w in workers:\n            if len(max_heap) < K:\n                total_quality += quality[w]\n                heapq.heappush(max_heap, -quality[w])\n                if len(max_heap) == K:\n                    min_total = min(min_total, wage_per_qual[w]*total_quality)\n            else:\n                if quality[w] < -max_heap[0]:\n                    neg_qual = heapq.heappushpop(max_heap, -quality[w])\n                    total_quality += neg_qual + quality[w]\n                    # # pop the maximum quality to add current worker\n                    # neg_qual = heapq.heappop(max_heap)\n                    # # remove previous max quality\n                    # total_quality += neg_qual\n                    # # add current quality\n                    # total_quality += quality[w]\n                    # heapq.heappush(max_heap, -quality[w])\n                    \n                    # use current worker as the base wage\n                    min_total = min(min_total, wage_per_qual[w]*total_quality)\n        \n        return min_total\n", "#Jenny 20201002\n#sample 180 ms submission\n\n# 857. Minimum Cost to Hire K Workers\n\nimport heapq \n\nclass Solution: \n    # time O(nlogn), space O(n)\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        # \u56e2\u961f\u5f00\u9500= \u6700\u4f4e\u6548\u4eba\u7684 w/q * \u56e2\u961f\u603b q\n        # \u5f00\u9664\u5f53\u524d\u56e2\u961f\u6700\u4f4e\u6548\u7684\u4eba\n        # \u5f15\u8fdb\u5f85\u9009\u96c6\u5408\u4e2dquality\u6700\u5c0f\u7684\u4eba\u3002\n        workers = sorted((w/q, w, q) for w, q in zip(wage, quality))\n        ans = float('inf')\n        pool = []\n        sum_q = 0\n        \n        for (ratio, w, q) in workers:\n            heapq.heappush(pool, -q)\n            sum_q += q\n            \n            if len(pool) > K:\n                sum_q += heapq.heappop(pool)\n            \n            if len(pool) == K:\n                ans = min(ans, ratio * sum_q)\n                \n            # print(sum_q, ans)\n        return float(ans)\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        '''\n1- expect[i] = wage[i]/quality[i]: meaning i-th worker claims expect[i] money per each unit of its quality. Therefore, if expect[i] > expect[j], that means if we pay j-th worker quality[j]*expect[i] he/she would be more than happy and it's more than its minimal requested wage.\n\n2- Therefore, for k workers sorted by their expect values, if we pay each worker q[i]*expect[k], both rules are satisfied. The total needed money = (sum(q_1 + q_2 + ... + q_k) * expect[k]). Note that this is the minimum money for this k workers, since you have to pay the k-th worker at least q[k]*expect[k]. This part is very tricky, think of this in contrary, if you don't pay each of K workers with expected[k], let's say if you pick expected[k-1], you will not satisfy kth worker. So, the minimum expected pay per quality is expected[k] to satisfy all k workers. Every worker is paid in terms of quality ratio so we come up with a common pay per quality. \n\n3- To recap, we sort workers based on their expect values. Say we are at worker i and want to form a k-group and we already know it would cost sum*expect[i]. To pay the minimum money we should minimize the sum, which can be found using a maxHeap (to replace the max value with a smaller one) to keep the smaller q's as we move forward.\n        \n        '''\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        maxHeap = []\n        res = float('inf')\n        qsum = 0\n        for expect, q in workers:\n            qsum += q\n            heapq.heappush(maxHeap, -q)\n            if len(maxHeap) > K:\n                qsum += heapq.heappop(maxHeap)\n            if len(maxHeap) == K:\n                res = min(res, expect*qsum)\n        return res\n            \n", "import numpy as np\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        # print(workers)\n        res = float('inf')\n        qsum = 0\n        heap = []\n        for r, q in workers:\n            # print(\\\"*****r: \\\", r, \\\"q: \\\", q)\n            heapq.heappush(heap, -q)\n            qsum += q\n            # print(\\\"sum:\\\", qsum)\n            # print(heap)\n            if len(heap) > K: \n                # print(\\\"popping from heap\\\")\n                qsum += heapq.heappop(heap)\n                # print(\\\"qsum: \\\", qsum)\n            if len(heap) == K: \n                res = min(res, qsum * r)\n                # print(\\\"min: \\\", res)\n        return res\n        \n", "from heapq import heappush, heappop\n\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        if len(wage) >= K:\n            worker = []\n            for i in range(0, len(quality)):\n                rate = wage[i] / quality[i]\n                worker.append((rate, quality[i]))\n            worker.sort()\n            base = 0\n            i = 0\n            q = []\n            while i < K-1:\n                base += worker[i][1]\n                heappush(q, - worker[i][1])\n                i += 1\n            # print(worker)\n            res = (base + worker[i][1]) * worker[i][0]\n            while i < len(worker):\n                # print((worker[i][0], base, res))\n                rate = worker[i][0]\n                res = min(res, (base + worker[i][1]) * rate)\n                heappush(q, - worker[i][1])\n                base += worker[i][1]\n                val = heappop(q)\n                base += val\n                i += 1\n            return res\n        else:\n            return -1.0\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        # length = len(quality)\n        # value_orders = sorted(range(length), key=lambda k: wage[k] / quality[k])\n\n        # worker_quality = []\n        # minimum_cost = 0\n        # for i in range(0, K):\n        #     worker_quality.append(quality[value_orders[i]])\n        #     minimum_cost += wage[value_orders[K - 1]] / quality[value_orders[K - 1]] * quality[value_orders[i]]\n\n        # worker_quality.sort()\n        # for i in range(K, length):\n        #     if quality[value_orders[i]] < worker_quality[-1]:\n        #         worker_quality.pop()\n        #         worker_quality.append(quality[value_orders[i]])\n        #         worker_quality.sort()\n        #     this_round_cost = 0\n        #     for q in worker_quality:\n        #         this_round_cost += q * wage[value_orders[i]] / quality[value_orders[i]]\n        #     minimum_cost = min(minimum_cost, this_round_cost)\n        # return minimum_cost\n\n\n\n        workers = [(wage/quality, wage, quality) for wage, quality in zip(wage, quality)]\n        workers.sort(key=lambda x: x[0])\n        \n        heap = []\n        quality_sum = 0\n        final_cost = float('inf')\n\n        for ratio, wage, quality in workers:\n            heapq.heappush(heap, -1 * quality)\n            quality_sum += quality\n            \n            if len(heap) > K:\n                q = heapq.heappop(heap)\n                # adding rather than substracting, since quality is inserted as negative\n                quality_sum += q\n\n            if len(heap) == K:\n                cost = ratio * quality_sum\n                final_cost = min(final_cost, cost)\n        return final_cost\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        x = sorted((wage/quality, wage, quality) for wage, quality in zip(wage, quality))        \n        cur_sum = 0\n        heap = []\n        res = sys.maxsize\n        for r, w, q in x:\n            heapq.heappush(heap, -q)\n            cur_sum+=q\n            if len(heap) > K:\n                cur_sum += heapq.heappop(heap)            \n            if len(heap) == K:\n                res = min(res, cur_sum*r)\n        \n        return res    ", "from queue import PriorityQueue\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        ratios = [w/q for w, q in zip(wage, quality)]\n        workers = [(r, q, w) for r, q, w in zip(ratios, quality, wage)]\n        workers = sorted(workers)\n\n        #heap = []\n        pQueue = PriorityQueue()\n        min_quality_sum = 0.0\n        cost = float('inf')\n\n        for r, q, w in workers:\n            pQueue.put(-q)\n            min_quality_sum = min_quality_sum + q\n\n            if pQueue.qsize() > K:\n                max_quality = pQueue.get()\n                min_quality_sum = min_quality_sum + max_quality\n\n            if pQueue.qsize() == K:\n                new_cost = r*min_quality_sum\n                if new_cost < cost:\n                    cost = new_cost\n\n        return cost", "from heapq import *\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        N = len(quality)\n        \n        workers = [(wage[i] / float(quality[i]), quality[i]) for i in range(N)]\n        workers = sorted(workers)\n        \n        # sum_ = sum([x[1] for x in prices_per_unit[:K - 1]])\n        \n        # print(prices_per_unit)\n        \n        result = float('inf')\n        sum_ = 0\n        max_heap = []\n        for i in range(K - 1):\n            heappush(max_heap, -workers[i][1])\n            sum_ += workers[i][1]\n            \n        for i in range(K - 1, len(workers)):\n            result = min(result, (sum_ + workers[i][1]) * workers[i][0])\n            if len(max_heap) > 0 and workers[i][1] < -max_heap[0]:\n                sum_ -= (-heappop(max_heap))\n                sum_ += workers[i][1]\n                heappush(max_heap, -workers[i][1])\n        \n        return result\n", "from decimal import Decimal\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        workers = [(Decimal(wage[i]/quality[i]), quality[i]) for i in range(len(wage))]\n        heapq.heapify(workers)\n        res, unit_price, total_quality, heap = float('inf'), -1.0, 0, []\n        while workers:\n            u, q = heapq.heappop(workers)\n            unit_price = max(u, unit_price)\n            heapq.heappush(heap, -q)\n            total_quality += q\n            # if we already hire K workers, we fire the worker with the highest quality\n            if len(heap) > K: \n                total_quality += heapq.heappop(heap)\n            if len(heap) == K: \n                res = min(res, total_quality*unit_price)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n\n        #\u8ba1\u7b97\u6700\u4f4e\u5de5\u8d44/\u5de5\u4f5c\u8d28\u91cf\u7684\u6bd4\u503c\uff1b\u7528\u4e00\u4e2a\u5806\u7ef4\u62a4K\u4e2a\u5de5\u4f5c\u8d28\u91cf\u6700\u4f4e\u7684\u5de5\u4f5c\u4eba\u5458\n\n        workers=[]\n\n        for q,w in zip(quality,wage):\n\n            workers.append((w/q,q,w))\n\n        workers.sort()\n\n        ans=float('inf')\n        dui=[]\n        sumq=0\n\n        for ratio,q,w in workers:\n            #\u6700\u5c0f\u5806\u53d8\u4e3a\u6700\u5927\u5806\n            heapq.heappush(dui,-q)\n            sumq+=q\n\n            if len(dui)>K:\n                #\u53bb\u6389\u4e00\u4e2a\u6700\u9ad8\u7684quality\n                sumq=sumq+heapq.heappop(dui)\n\n            if len(dui)==K:\n                ans=min(ans,ratio*sumq)\n\n        return float(ans)\n\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        from fractions import Fraction\n        workers = sorted([(w/q,q,w) for q,w in zip(quality, wage)])\n        \n        min_cost = float('inf')\n        from queue import PriorityQueue\n        pq = PriorityQueue()\n        summ = 0\n        print(workers)\n        for ratio, q, w in workers:\n            pq.put(-q)\n            summ += q\n            \n            if pq.qsize() > K:\n                summ += pq.get()\n            if pq.qsize() == K:\n                min_cost = min(min_cost, ratio*summ)\n            \n        return float(min_cost)", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        ratios = [(wi/qi, qi) for wi, qi in zip(wage, quality)]\n        ratios.sort()\n        \n        res = float('inf')\n        pq = []\n        cur = 0\n        \n        for i, (ratio, q) in enumerate(ratios):\n            if i >= K - 1:\n                res = min(res, ratio*(q + cur))\n                \n            cur += q\n            heapq.heappush(pq, -q)\n            \n            if len(pq) > K - 1:\n                cur += heapq.heappop(pq)\n        return res\n                \n", "class Solution:\n    def mincostToHireWorkers(self, quality, wage, K):\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        #print('workers: ',workers)\n        res = float('inf')\n        qsum = 0\n        heap = []\n        \n        def rec(l,r,heap,newQ):\n            if l>r:\n                heap.insert(l,newQ)\n                return heap\n            m=l+int((r-l)/2)\n            if heap[m]>newQ:\n                return rec(l,m-1,heap,newQ)\n            else:\n                return rec(m+1,r,heap,newQ)\n            \n        for r, q in workers:\n            #print('before heap: ', heap)\n            heap=rec(0,len(heap)-1,heap,q)\n            #print('after heap: ', heap)\n            qsum += q\n            if len(heap) > K:\n                \n                p=heap.pop(K)\n                #print('heapq.heappop(heap): ',p, 'r:', r, 'qsum: ',qsum)\n                qsum += -p\n            if len(heap) == K:\n                res = min(res, qsum * r)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality, wage, K):\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        print('workers: ',workers)\n        res = float('inf')\n        qsum = 0\n        heap = []\n        \n        def rec(l,r,heap,newQ):\n            if l>r:\n                heap.insert(l,newQ)\n                return heap\n            m=l+int((r-l)/2)\n            if heap[m]>newQ:\n                return rec(l,m-1,heap,newQ)\n            else:\n                return rec(m+1,r,heap,newQ)\n            \n        for r, q in workers:\n            #print('before heap: ', heap)\n            heap=rec(0,len(heap)-1,heap,q)\n            #print('after heap: ', heap)\n            qsum += q\n            if len(heap) > K:\n                \n                p=heap.pop(-1)\n                #print('heapq.heappop(heap): ',p, 'r:', r, 'qsum: ',qsum)\n                qsum += -p\n            if len(heap) == K:\n                res = min(res, qsum * r)\n        return res", "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, K):\n        #from fractions import Fraction\n        #workers = sorted((Fraction(w, q), q, w)\n        #                 for q, w in zip(quality, wage))\n        workers = sorted((w/q, q, w)\n                            for q, w in zip(quality, wage))\n\n        print(workers)\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)\n", "class Solution:\n    def mincostToHireWorkers(self, quality, wage, K):\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        #print('workers: ',workers)\n        res = float('inf')\n        qsum = 0\n        heap = []\n        \n        def rec(l,r,heap,newQ):\n            if l>r:\n                heap.insert(l,newQ)\n                return heap\n            m=l+int((r-l)/2)\n            if heap[m]>newQ:\n                return rec(l,m-1,heap,newQ)\n            else:\n                return rec(m+1,r,heap,newQ)\n            \n        L=0\n        for r, q in workers:\n            #print('before heap: ', heap)\n            heap=rec(0,L-1,heap,q)\n            L+=1\n            #print('after heap: ', heap)\n            qsum += q\n            if L > K:\n                \n                p=heap.pop(K)\n                L-=1\n                #print('heapq.heappop(heap): ',p, 'r:', r, 'qsum: ',qsum)\n                qsum += -p\n            if len(heap) == K:\n                res = min(res, qsum * r)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality, wage, K):\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        res = float('inf')\n        qsum = 0\n        heap = []\n        \n        def rec(l,r,heap,newQ):\n            if l>r:\n                heap.insert(l,newQ)\n                return heap\n            m=l+int((r-l)/2)\n            if heap[m]>newQ:\n                return rec(l,m-1,heap,newQ)\n            else:\n                return rec(m+1,r,heap,newQ)\n            \n        L=0\n        for r, q in workers:\n            heap=rec(0,L-1,heap,q)\n            L+=1\n            qsum += q\n            if L > K:\n                \n                p=heap.pop(K)\n                L-=1\n                qsum += -p\n            if len(heap) == K:\n                res = min(res, qsum * r)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        combine =  sorted([(wage[i]/quality[i], quality[i]) for i in range(len(quality))] , key = lambda x: (-x[0], x[1]) )\n        # qual = [e[1] for e in combine]\n        # rates = [e[0] for e in combine]\n        tc = float('inf')\n        n = len(combine)\n        q = []\n        heapq.heapify(q)\n        for i in range(len(combine)-1,-1,-1):\n            heapq.heappush(q, -combine[i][1])\n            if len(q) > K:\n                heapq.heappop(q)\n            if i <= n-K: \n                tc = min(tc, -combine[i][0]*sum(q))\n        return tc\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        combine =  sorted([(wage[i]/quality[i], quality[i]) for i in range(len(quality))] , key = lambda x: (-x[0], x[1]) )\n        # combine =  sorted([(quality[i],wage[i]/quality[i]) for i in range(len(quality))])\n        qual = [e[1] for e in combine]\n        rates = [e[0] for e in combine]\n        tc = float('inf')\n        n = len(combine)\n        q = []\n        heapq.heapify(q)\n        for i in range(len(combine)-1,-1,-1):\n            # if i < K-1: return tc\n            heapq.heappush(q, -qual[i])\n            if len(q) > K:\n                heapq.heappop(q)\n            if i <= n-K: \n                tc = min(tc, -rates[i]*sum(q))\n            \n        return tc\n", "class Solution:\n    def mincostToHireWorkers(self, quality, wage, K):\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        #print('workers: ',workers)\n        res = float('inf')\n        qsum = 0\n        heap = []\n        \n        def rec(l,r,heap,newQ):\n            if l>r:\n                heap.insert(l,newQ)\n                return heap\n            m=l+int((r-l)/2)\n            if heap[m]>newQ:\n                return rec(l,m-1,heap,newQ)\n            else:\n                return rec(m+1,r,heap,newQ)\n            \n        for r, q in workers:\n            #print('before heap: ', heap)\n            heap=rec(0,len(heap)-1,heap,q)\n            #print('after heap: ', heap)\n            qsum += q\n            if len(heap) > K:\n                \n                p=heap.pop(-1)\n                #print('heapq.heappop(heap): ',p, 'r:', r, 'qsum: ',qsum)\n                qsum += -p\n            if len(heap) == K:\n                res = min(res, qsum * r)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        \n        ratios = [(w/q,i) for i,(q,w) in enumerate(zip(quality, wage))]\n        ratios.sort()\n        \n        heap = [] # -q\n        sumq = 0\n        ans = math.inf\n        \n        for ratio, i in ratios:\n            sumq += quality[i]\n            heapq.heappush(heap, (-quality[i]))\n            if len(heap) > K:\n                q = heapq.heappop(heap)\n                sumq += q # q is negative\n            if len(heap) == K:\n                ans = min(ans, sumq*ratio)\n        return ans\n            \n            \n            \n            \n            # 7 2.5 6 \n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w) for q, w in zip(quality, wage))\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)", "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, K):\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n        \n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n        \n        return float(ans)\n", "from heapq import heappush, heappop\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        #store capacity/wage\n        from fractions import Fraction\n        cap_wage = sorted((Fraction(w, q), q, w) for q, w in zip(quality, wage))       \n        cap_wage = sorted([(w/c,c,w) for c,w in zip(quality,wage)])\n        heap = []\n        re = float('inf')\n        val=0\n        for ratio,c,w in cap_wage:\n            heappush(heap,-c)\n            val+=c\n            if len(heap)>K:\n                val+=heappop(heap)\n            if len(heap)==K:\n                re = min(re,val*ratio)\n        return float(re)\n            \n        \n", "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, K):\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)", "class Solution(object):\n       \n    \n    def mincostToHireWorkers(self, quality, wage, K):\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n            \n           \n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n                \n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n           \n\n            \n\n        \n            \n        return float(ans)", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w) for q, w in zip(quality, wage))\n        #print(workers)\n        min_val = float('Inf')\n        #print(min_val)\n        \n        pool = []\n        sum_q = 0\n        for r, q, w in workers:\n            heapq.heappush(pool, -q)\n            sum_q += q\n            if len(pool) > K:\n                sum_q += heapq.heappop(pool)\n            if len(pool) == K:\n                min_val = min(min_val, r * sum_q)\n        return min_val\n", "class Solution(object):\n       \n    \n    def mincostToHireWorkers(self, quality, wage, K):\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n            \n           \n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n                \n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n           \n \n        return float(ans)\n\n\n# Idea is as follows: If workers are paid in ratio of their qualities, then w_j = (w_ref/q_ref) * q_j\n\n# After paying in the above ratio, to ensure we pay workers their min wage, then we need to select the higher wage/ratio as reference among two possible wage/quality ratios \n\n\n# So if the size of array is k, then we just select the highest ratio and use that as ref, then \n#  min cost =  (highest ratio ) * (sum of all Qualities)\n\n# or in other words, sort the wage to ratios in increasing order, then last one will be ref ration and this ref ratio times sumq = ans.\n\n# now consider k+1 elements present. then same as above logic, if we sort the wage/quality ratios in increasing order, then any of the ratios from kth to later can be a candidate ref ratio. If k elements, we already know the ans is kth ratio * sumq. Now consider k+1 th element. We can have this as ref ration instead. Then which one would we remove to get k elements? We want to remove the element with highest quality as that would reduce the cost by max. (remember total cost = ref ratio * ( sum of qualities)). So we use max heap to maintain qualities and remove the highest quality when we consider all indexes > k. and among all those possible indexes k to n, we find which gives min cost.\n\n", "class Solution(object):\n#     def mincostToHireWorkers(self, quality, wage, k):\n#         from fractions import Fraction\n#         workers = sorted((Fraction(w, q), q, w)\n#                          for q, w in zip(quality, wage))\n\n#         maxRatio = workers[-1][0]\n        \n#         quality.sort()\n#         sumq=sum(quality[:k])\n#         return sumq*maxRatio\n        \n    \n    def mincostToHireWorkers(self, quality, wage, K):\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)", "from heapq import heappush, heappop\n\nfrom fractions import Fraction\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        workers = [(Fraction(w,q), q, w) for w, q in zip(wage, quality)]\n        workers.sort()\n        \n        best = float('inf')\n        queue = []\n        sumq = 0\n        \n        for ratio, q, w in workers:\n            heappush(queue, -q)\n            sumq += q\n            \n            if len(queue) > K:\n                sumq += heappop(queue)\n            \n            if len(queue) == K:\n                best = min(best,ratio * sumq)\n\n        return best\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)   ", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        \n        from fractions import Fraction\n        \n        wage_qual =  sorted((Fraction(w, q), w, q) for w, q in zip(wage, quality))\n        \n        candidates = []\n        psum = 0\n        ans = float('inf')\n        for ratio, w, q in wage_qual :\n            heapq.heappush(candidates, -q)\n            psum += q\n            \n            if len(candidates) < K :\n                continue\n            \n            elif len(candidates) > K :\n                psum += heapq.heappop(candidates)\n                \n            ans = min(ans, psum * ratio)\n        return ans\n", "class Solution:\n    def mincostToHireWorkers(self, quality, wage, K):\n        workers = sorted([float(w) / q, q] for w, q in zip(wage, quality))\n        res = float('inf')\n        qsum = 0\n        heap = []\n        for r, q in workers:\n            heapq.heappush(heap, -q)\n            qsum += q\n            if len(heap) > K: qsum += heapq.heappop(heap)\n            if len(heap) == K: res = min(res, qsum * r)\n        return res", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        \n        from fractions import Fraction\n        \n        wage_qual =  sorted((Fraction(w, q), w, q) for w, q in zip(wage, quality))\n        \n        candidates = []\n        psum = 0\n        ans = float('inf')\n        for ratio, w, q in wage_qual :\n            heapq.heappush(candidates, -q)\n            psum += q\n            \n            \n            if len(candidates) > K :\n                psum += heapq.heappop(candidates)\n            \n            if len(candidates) == K :\n                ans = min(ans, psum * ratio)\n        return ans\n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)\n        n = len(wage)\n        if K>n:\n            return float(0)\n        re = []\n        re.append(float('inf'))\n        self.util(quality,wage,0,[],K,re)\n        return re[0]\n    def util(self,q,w,i,p,k,re):\n        if len(p)==k:\n            s = sum([t[1] for t in p])\n            if s<re[0]:\n                re[0]=s\n            \n        if i==len(w):\n            return\n        \n        self.util(q,w,i+1,[x[:] for x in p],k,re)\n        if not p:\n            p.append([q[i],w[i]])\n            self.util(q,w,i+1,[x[:] for x in p],k,re)\n        else:\n            price = (p[0][1]*q[i])/p[0][0]\n            if price>w[i]:\n                p.append([q[i],price])\n                self.util(q,w,i+1,[x[:] for x in p],k,re)\n            else:\n                for idx in p:\n                    idx[1] = (w[i]*idx[0])/q[i]\n                p.append([q[i],w[i]])\n                self.util(q,w,i+1,[x[:] for x in p],k,re)\n                \n                \n                    \n            \n        \n        \n        \n            \n", "class Solution(object):\n    def mincostToHireWorkers(self, quality, wage, K):\n        from fractions import Fraction\n        workers = sorted((Fraction(w, q), q, w)\n                         for q, w in zip(quality, wage))\n\n        ans = float('inf')\n        pool = []\n        sumq = 0\n        for ratio, q, w in workers:\n            heapq.heappush(pool, -q)\n            sumq += q\n\n            if len(pool) > K:\n                sumq += heapq.heappop(pool)\n\n            if len(pool) == K:\n                ans = min(ans, ratio * sumq)\n\n        return float(ans)\n    \n#     def mincostToHireWorkers(self, quality, wage, K):\n#         from fractions import Fraction\n#         workers = sorted((Fraction(w, q), q, w)\n#                          for q, w in zip(quality, wage))\n\n#         ans = float('inf')\n#         pool = []\n#         sumq = 0\n#         for ratio, q, w in workers:\n#             heapq.heappush(pool, -q)\n#             sumq += q\n\n#             if len(pool) > K:\n#                 sumq += heapq.heappop(pool)\n\n#             if len(pool) == K:\n#                 ans = min(ans, ratio * sumq)\n\n#         return float(ans)\n", "from fractions import Fraction\nfrom heapq import *\n\nclass Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        \n        # quality = [3,1,10,10,1]\n        # wage = [4,8,2,2,7]\n        # K = 3\n\n        workers = sorted((Fraction(w, q), q, w) for q, w in zip(quality, wage))\n        \n        # print(workers)\n\n        result = float('inf')\n        maxheap = []\n        current_sum = 0\n        for ratio, q, w in workers:\n            heappush(maxheap, -q)\n            current_sum += q\n\n            if len(maxheap) > K:\n                current_sum += heappop(maxheap)                \n\n            if len(maxheap) == K:\n                result = min(result, ratio * current_sum)\n\n            # print(ratio, q, w, maxheap,current_sum,result)\n        \n        return float(result)        \n\n\n#         from fractions import Fraction\n#         ans = float('inf')\n\n#         N = len(quality)\n#         for captain in range(N):\n#             # Must pay at least wage[captain] / quality[captain] per qual\n#             factor = Fraction(wage[captain], quality[captain])\n#             prices = []\n#             for worker in range(N):\n#                 price = factor * quality[worker]\n#                 if price >= wage[worker]:\n#                     prices.append(price)\n                \n#             if len(prices) >= K: \n#                 prices.sort()\n#                 ans = min(ans, sum(prices[:K]))\n\n#         return float(ans)\n    \n    \n    \n    \n    \n    \n", "class Solution:\n    def mincostToHireWorkers(self, quality: List[int], wage: List[int], K: int) -> float:\n        from fractions import Fraction\n        \n        # sorting workers based on the ration of wage and quality\n        workers = sorted((Fraction(w, q), q, w) for q, w in zip(quality, wage))\n        \n        ans = float('inf')\n        heap = []\n        heapSum = 0\n        \n        for ration, q, w in workers:\n            heapq.heappush(heap, -q) # max heap based off quality\n            heapSum += q\n            \n            if len(heap) > K:# if len of heap > K add largest heap elem\n                heapSum += heapq.heappop(heap)\n            \n            if len(heap) == K:\n                ans = min(ans, ration * heapSum)\n        \n        return float(ans)"]