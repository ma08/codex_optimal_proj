["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        # time O(n); space O(n)\n        vals = deque(preorder)\n        \n        def build(min_val, max_val):\n            if vals and min_val < vals[0] < max_val:\n                val = vals.popleft()\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                \n                return node\n        \n        return build(float('-inf'), float('inf'))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        if len(preorder) == 1:\n            return root\n        # left = [i for i in preorder if i < root.val]\n        # right = [i for i in preorder if i > root.val]\n        ind = len(preorder)\n        for i, j in enumerate(preorder):\n            if j > root.val:\n                ind = i\n                break\n        root.left = self.bstFromPreorder(preorder[1:ind])\n        root.right = self.bstFromPreorder(preorder[ind:])\n        \n        return root", "class Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        root = TreeNode(preorder[0])\n        stack = [root]\n        for val in preorder[1:]:\n            node = TreeNode(val)\n            if val < stack[-1].val:\n                stack[-1].left = node\n            else:\n                while stack and stack[-1].val < val:\n                    last = stack.pop()\n                last.right = node\n            stack.append(node)\n        return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        self.inorder = sorted(preorder)\n        self.preorder = preorder[::-1]\n        n = len(preorder)\n        self.m = { val:i for i, val in enumerate(self.inorder)}\n        lo, hi = 0, n-1\n        return self.dfs(lo, hi)\n        \n    def dfs(self, lo, hi):\n        if lo > hi: return None\n        \n        val = self.preorder.pop()\n        root = TreeNode(val)\n        mid = self.m[val]\n        root.left = self.dfs(lo, mid-1)\n        root.right = self.dfs(mid+1, hi)\n        \n        return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        root = node = TreeNode(preorder[0])\n        stack = []\n        \n        for n in preorder[1:]:\n            if n < node.val:\n                node.left = TreeNode(n)\n                stack.append(node)\n                node = node.left\n            else:\n                while stack and stack[-1].val < n:\n                    node = stack.pop()\n                node.right = TreeNode(n)\n                node = node.right\n        return root\n                    \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        if not preorder or len(preorder) == 0:\n            return None\n        inorder = sorted(preorder)\n        root = TreeNode(preorder[0])\n        leftLen = inorder.index(root.val)\n        root.left = self.bstFromPreorder(preorder[1: 1+leftLen])\n        root.right = self.bstFromPreorder(preorder[1+leftLen:])\n        return root\n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def bstFromPreorder(self, A: List[int]) -> TreeNode:\n        A.reverse()\n        \n        def build(lower = -math.inf, upper = math.inf):\n            if not A or A[-1] < lower or A[-1] > upper:\n                return None\n            \n            root = TreeNode(A.pop())\n            root.left = build(lower, root.val)\n            root.right = build(root.val, upper)\n            return root\n        return build()", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        if not preorder:\n            return\n        root = TreeNode(preorder[0])\n        i = 1\n        while i<len(preorder) and preorder[i]<=root.val:\n            i += 1\n        \n        root.left = self.bstFromPreorder(preorder[1:i])\n        root.right = self.bstFromPreorder(preorder[i:])\n        \n        return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        \n        if len(preorder) == 0:\n            return None\n        \n        return self.helper(preorder,0,len(preorder))\n        \n    def helper(self,preorder,start,end):\n        # print(start,end,preorder[start:end])\n        if start >= end:\n            return None\n        \n        split = start + 1\n        root = TreeNode(preorder[start])\n        \n        while split < end and preorder[start] > preorder[split]:\n            split+=1\n        \n        root.left = self.helper(preorder,start + 1,split)\n        root.right = self.helper(preorder,split,end)\n        return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def get_small(self, arr: List[int], idx: int, min_val: float) -> int:\n        for i in range(idx+1, len(arr)):\n            if arr[i] < arr[idx] and arr[i] >= min_val:\n                return i\n            \n        return -1\n    \n    def get_big(self, arr: List[int], idx: int, max_val: float) -> int:\n        for i in range(idx+1, len(arr)):\n            if arr[i] >= arr[idx] and arr[i] < max_val:\n                return i\n            \n        return -1\n        \n    def helper(self, preorder: List[int], idx: int, min_val: float, max_val: float) -> TreeNode:\n        if idx == -1:\n            return None\n        \n        root = TreeNode(preorder[idx])\n        left = self.get_small(preorder, idx, min_val)\n        right = self.get_big(preorder, idx, max_val)\n        \n        root.left = self.helper(preorder, left, min_val, preorder[idx])\n        root.right = self.helper(preorder, right, preorder[idx], max_val)\n        \n        return root\n        \n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        return self.helper(preorder, 0, float(\\\"-inf\\\"), float(\\\"inf\\\"))\n        ", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        def construct(preorder):\n            if len(preorder) == 0:\n                return None\n            root = TreeNode(preorder[0])\n            #   \u5f00\u59cb\u5206\u88c2\n            idx = 0\n            while idx < len(preorder):\n                if preorder[idx] > preorder[0]:\n                    break\n                idx += 1\n            root.left  = construct(preorder[1:idx])\n            root.right = construct(preorder[idx:])\n            return root\n        root = construct(preorder)\n        return root\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\n        # \n        # minHeap | O(NlogN) | ----- 40 ms (50.65%) / 14.3 MB (5.13%)\n        # ------------------------------------------------------------------------------------------------\n        if not preorder:\n            return None\n        root = TreeNode(val=preorder[0])\n        parents = [(root.val, root)]\n        heapq.heapify(parents)\n        for idx in range(1, len(preorder)):\n            num = preorder[idx]\n            node = TreeNode(val=num)\n            tmp = None\n            while parents and parents[0][0] < num:\n                _, tmp = heapq.heappop(parents)\n            if tmp:\n                tmp.right = node\n            elif not tmp and parents:\n                parents[0][1].left = node\n            heapq.heappush(parents, (num, node))   \n        return root"]