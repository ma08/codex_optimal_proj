["def mystery(n):\n    return n ^ (n >> 1)\n\ndef mystery_inv(n):\n    mask = n >> 1\n    while mask != 0:\n        n = n ^ mask\n        mask = mask >> 1\n    return n;\n\ndef name_of_mystery():\n    return \"Gray code\"", "def mystery(n):\n    return n ^ (n >> 1)\n\ndef mystery_inv(n):\n    mask = n >> 1\n    while mask:\n        n = n^mask\n        mask = mask >> 1\n    return n\n\ndef name_of_mystery():\n    return \"Gray code\"", "import math\ndef f(b,n):\n    if b==2: return '01'[n]\n    else:\n        if n>=b//2: return '1'+f(b//2,b//2-1-(n-b//2))\n        else: return '0'+f(b//2,n)\ndef mystery(n):\n    if n==0: return 0\n    b=2**(int(math.log(n,2))+1)\n    a=f(b,n)\n    return (int(a,2))\n    \n\ndef mystery_inv(n):\n    if n==0: return 0\n    s=bin(n)[2:]\n    x=0\n    for i in range(len(s)):\n        if int(s[len(s)-1-i]): x=(2**i)+(2**i-1-x)\n    return x \ndef name_of_mystery():\n    return 'Gray code'", "mystery=lambda n:n ^ (n >> 1)\nmystery_inv=lambda n,i=0,li=[0]:int(''.join(map(str,li)),2) if i==len(bin(n)[2:]) else mystery_inv(n,i+1,li+[int(li[-1])^int(bin(n)[2:][i])])\nname_of_mystery=lambda:'Gray code'", "def dec_to_bin(num):\n    if num <= 0:\n        return '0'\n\n    bits = ''\n    while num > 0:\n        bits = str(num % 2) + bits\n        num = num / 2\n        \n    return bits\n    \ndef bin_to_dec(binary):\n    dec = 0\n    power = 0\n    for b in reversed(binary):\n        dec += int(b) * 2 ** power\n        power += 1\n        \n    return dec\n    \ndef mystery(num):\n    b = dec_to_bin(num)\n    out = ''\n    reverse = False\n    for bit in b:\n        if not reverse:\n            out += bit\n        else:\n            out += '0' if bit == '1' else '1'\n            \n        reverse = not reverse if out[-1] == '1' else reverse    \n            \n    return bin_to_dec(out)\n    \ndef mystery_inv(num):\n    if num == 0:\n        return num\n\n    b = dec_to_bin(num)\n    out = ''\n    reverse = b[0] == '0'\n    for bit in b:\n        if not reverse:\n            out += bit\n        else:\n            out += '0' if bit == '1' else '1'\n            \n        reverse = not reverse if bit == '1' else reverse\n        \n    return bin_to_dec(out)\n\ndef name_of_mystery():\n    return 'Gray code'", "def mystery(n):\n    return n ^ (n >> 1)\n\ndef mystery_inv(n):\n    res = 0\n    while n > 0:\n        res ^= n\n        n >>= 1\n    return res\n\ndef name_of_mystery():\n    return 'Gray code'", "mystery = lambda n: n ^ (n >> 1)\ndef mystery_inv(n):\n    m = n >> 1\n    while m != 0:\n        n ^= m\n        m >>= 1\n    return n\nname_of_mystery = lambda: 'Gray code'", "\"\"\" \n    When you do know almost nothing about bitwise operators except of their existence...\n    ...and that you make by chance a good guess... \n\"\"\"\ndef mystery(n):  return n ^ (n//2)\n\n\n\"\"\"\n    Then you do some pattern recognition to solve the kata! \n\"\"\"\nimport re, string\nTABLE = string.maketrans('01', '10')\n\ndef mystery_inv(n):\n    return int(''.join( a+b.translate(TABLE)+c for a,b,c in re.findall(r'(1)(0*1?)(0*)', bin(n)[2:]) ) or '0', 2)\n    \n\ndef name_of_mystery(): return \"Gray code\"", "def mystery(n):\n    return n^n>>1\n\ndef mystery_inv(n):\n    i = n>>1\n    while i > 0:\n        n ^= i\n        i >>= 1\n    return n\n\ndef name_of_mystery():\n    return \"Gray code\"", "def mystery(n):\n    return n ^ (n >> 1)\n\ndef mystery_inv(n):\n    b = 0 #next bit to append to result\n    p = 1 << (n).bit_length() #power of 2 greater than n\n    result = 0\n    while p > 1:\n        p >>= 1\n        if n & p != 0: b = 1 - b #flip bit when a 1 is in corresponding bit position in n\n        result = (result << 1) + b\n    return result\n\ndef name_of_mystery():\n    return 'Gray code'"]