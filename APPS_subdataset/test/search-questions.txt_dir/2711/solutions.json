["\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import defaultdict\nfrom functools import reduce,cmp_to_key,lru_cache\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# import sys\n# input = sys.stdin.readline\n \nM = mod = 10**9 + 7 \ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\ndef li2():return [str(i)[2:-1] for i in input().rstrip().split()]\ndef li3():return [int(i) for i in st()]\n \n \n\n\ngraph = defaultdict(set)\n\nn, k = li()\nl = []\nallwords = set()\nfor i in range(n):\n    p = val()\n    l1 = []\n    for j in range(k):l1.append(st())\n\n    allwords |= set(l1[-1])\n    l.append([p, l1[:]])\n\n\nl.sort(key = lambda x:x[0])\nl = [i[1] for i in l]\nif n == k == 1:\n    print(''.join(set(l[0][0])))\n    return\n\n\ningraph = defaultdict(int)\n\ndef match(a, b):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:continue\n        elif b[j] in graph[a[j]]:return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return\n\nfinl = []\nfor i in l:finl.extend(i)\nl = finl\n\n# for i in l:print(i)\n\nfor i in range(1, len(l)):\n    match(l[i - 1], l[i])\n\n\n\n# print(graph)\n# print(ingraph)\n\nif min([ingraph[j] for j in graph]) != 0:\n    print('IMPOSSIBLE')\n    return\n\nans = ''\n\n\nd = deque()\n\nfor j in graph:\n    if ingraph[j] == 0:\n        d.append(j)\n\nwhile d:\n    node = d.popleft()\n    ans += node\n\n    for j in graph[node]:\n        ingraph[j] -= 1\n        if not ingraph[j]:d.append(j)\n\n\nif len(ans) != len(allwords):\n    print('IMPOSSIBLE')\n    return\nprint(ans)\n", "# from collections import deque\nimport io\n# input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline # \u795e\u5947\u5feb\u8bfb\uff0c\u65e0\u6cd5\u8fd0\u884c\u8c03\u8bd5\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\n\n\nn, m = map(int, input().split())\n# d = {}\ninc = {\n    # chr(97+i):0 for i in range(26)\n\n}\nl = [None for i in range(n*m)]\n\nfor i in range(n):\n    t = int(input())\n    # tmp = []\n    for j in range(m):\n        # tmp.append(input())\n        ipt = input()\n        l[t*m+j] = ipt\n        if len(inc)==26:continue\n        for q in ipt:\n            inc.setdefault(q, 0)\n    # d[t] = tmp\n# l = []\n# for i in range(n):\n#     for j in d[i]:\n#         l.append(j)\n\nd = {}\n\n\n# f = l[0][0]\n\ndef ae(u, v):\n    t = d.setdefault(u, set())\n    if v not in t:\n        t.add(v)\n        inc[v] = inc.get(v, 0) + 1\n\n\nfor p, i in enumerate(l[1:]):\n    for j in range(min(len(l[p]), len(i))):\n        if l[p][j] != i[j]:\n            # if len(l[p])-1 != j:\n                # ae(l[p][j],i[j])\n            ae(i[j], l[p][j])\n            break\n        if len(i)-1==j and len(l[p])-1 > j:\n            print(\"IMPOSSIBLE\")\n            return\n\n\nans = []\ndq = []\n# dq = deque()\nptr = 0\n\n\nninc = {}\n\nfor k, v in inc.items():\n    if v == 0:\n        dq.append(k)\n    else:\n        ninc[k] = v\n\n\n# if ctr>1:\n    # print(\"IMPOSSIBLE\")\n    # return\n\ninc = ninc\n\n\nwhile ptr != len(dq):\n    fst = dq[ptr]\n    ans.append(fst)\n\n    for i in d.get(fst, []):\n        inc[i] -= 1\n        if inc[i] == 0:\n            dq.append(i)\n            inc.pop(i)\n\n    # if ctr>1:\n        # print(\"IMPOSSIBLE\")\n        # return\n    ptr += 1\n\nif len(inc):\n    print(\"IMPOSSIBLE\")\n    return\n\nprint(*reversed(ans), sep='')\n", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key,lru_cache\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline;M = mod = 10**9 + 7 \ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\ndef li2():return [str(i)[2:-1] for i in input().rstrip().split()]\ndef li3():return [int(i) for i in st()]\ngraph = defaultdict(set);n, k = li();l = [];allwords = set()\nfor i in range(n):\n    p = val();l1 = []\n    for j in range(k):l1.append(st())\n    allwords |= set(l1[-1]);l.append([p, l1[:]])\nl.sort(key = lambda x:x[0]);l = [i[1] for i in l]\nif n == k == 1:print(''.join(set(l[0][0])));return\ningraph = defaultdict(int)\ndef match(a, b):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:continue\n        elif b[j] in graph[a[j]]:return\n        else:graph[a[j]].add(b[j]);ingraph[b[j]] += 1;return\n    if len(a) > len(b):print('IMPOSSIBLE');return\nfinl = []\nfor i in l:finl.extend(i)\nl = finl\nfor i in range(1, len(l)):match(l[i - 1], l[i])\nif min([ingraph[j] for j in graph]) != 0:print('IMPOSSIBLE');return\nans = '';d = deque()\nfor j in graph:\n    if ingraph[j] == 0:d.append(j)\nwhile d:\n    node = d.popleft();ans += node\n    for j in graph[node]:\n        ingraph[j] -= 1\n        if not ingraph[j]:d.append(j)\nif len(ans) != len(allwords):print('IMPOSSIBLE');return\nprint(ans)", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nfrom heapq import heappush,heappop\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key,lru_cache\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n# import sys\n# input = sys.stdin.readline\n \nM = mod = 10**9 + 7 \ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\ndef inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\ndef li2():return [str(i)[2:-1] for i in input().rstrip().split()]\ndef li3():return [int(i) for i in st()]\n \n \n \n \ngraph = defaultdict(set)\n \nn, k = li()\nl = []\nallwords = set()\nfor i in range(n):\n    p = val()\n    l1 = []\n    for j in range(k):l1.append(st())\n \n    allwords |= set(l1[-1])\n    l.append([p, l1[:]])\n \n \nl.sort(key = lambda x:x[0])\nl = [i[1] for i in l]\nif n == k == 1:\n    print(''.join(set(l[0][0])))\n    return\n \n \ningraph = defaultdict(int)\n \ndef match(a, b):\n    for j in range(min(len(a), len(b))):\n        if a[j] == b[j]:continue\n        elif b[j] in graph[a[j]]:return\n        else:\n            graph[a[j]].add(b[j])\n            ingraph[b[j]] += 1\n            return\n    if len(a) > len(b):\n        print('IMPOSSIBLE')\n        return\n \nfinl = []\nfor i in l:finl.extend(i)\nl = finl\n \n# for i in l:print(i)\n \nfor i in range(1, len(l)):\n    match(l[i - 1], l[i])\n \n \n \n# print(graph)\n# print(ingraph)\n \nif min([ingraph[j] for j in graph]) != 0:\n    print('IMPOSSIBLE')\n    return\n \nans = ''\n \n \nd = deque()\n \nfor j in graph:\n    if ingraph[j] == 0:\n        d.append(j)\n \nwhile d:\n    node = d.popleft()\n    ans += node\n \n    for j in graph[node]:\n        ingraph[j] -= 1\n        if not ingraph[j]:d.append(j)\n \n \nif len(ans) != len(allwords):\n    print('IMPOSSIBLE')\n    return\nprint(ans)", "import os\nimport io\nfrom collections import deque, defaultdict\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\n\n# def li():return [int(i) for i in input().rstrip().split()]\n# def st():return str(input())\n# def val():return int(input())\n\n#Input Reading\n\nn,k = li()\n\npages = []\nabc = set()\n\nfor _ in range(n):\n    p = val()\n    page = []\n    for i in range(k):\n        word = st()\n        page.append(word)\n    abc |= set(page[-1])\n    pages.append((p,page))\n\npages.sort(key = lambda x: x[0])\nwords = []\nfor _,page in pages:\n    words.extend(page)\n\nif n == k == 1:\n    print(''.join(abc))\n    return\n\ndef match(w1,w2):\n    for i in range(min(len(w1), len(w2))):\n        if w1[i] == w2[i]:\n            continue\n        else:\n            return (w1[i],w2[i])\n\n    if len(w1) > len(w2):\n        print(\"IMPOSSIBLE\")\n        return    \n\n#Reading the graph and its indegrees\ng = defaultdict(set)\nindeg = defaultdict(int)\n\nfor i in range(len(words) - 1):\n    out = match(words[i], words[i+1])\n    if out is not None:\n        c1,c2 = out\n        if c2 not in g[c1]:\n            g[c1].add(c2)\n            indeg[c2] += 1\n\n\n#Topsort things\nts = []\nzero = deque()\nfor u in g:\n    if indeg[u] == 0:\n        zero.append(u)\n\nwhile len(ts) != len(abc):\n    if len(zero) == 0:\n        print(\"IMPOSSIBLE\")\n        return\n    \n    u = zero.popleft()\n    ts.append(u)\n    for v in g[u]:\n        indeg[v] -= 1\n        if indeg[v] == 0:\n            zero.append(v)\n\nprint(\"\".join(ts))\n\n", "import os\nimport io\nfrom collections import deque, defaultdict\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\n\n# def li():return [int(i) for i in input().rstrip().split()]\n# def st():return str(input())\n# def val():return int(input())\n\n#Input Reading\n\nn,k = li()\n\nwords = [\"\"] * n * k\nabc = set()\n\nfor i in range(n):\n    p = val()\n    page = []\n    for j in range(k):\n        word = st()\n        words[p*k+j] = word\n    abc |= set(word)\n\ndef match(w1,w2):\n    for i in range(min(len(w1), len(w2))):\n        if w1[i] == w2[i]:\n            continue\n        else:\n            return (w1[i],w2[i])\n\n    if len(w1) > len(w2):\n        print(\"IMPOSSIBLE\")\n        return    \n\n#Reading the graph and its indegrees\ng = {c: set() for c in abc}\nindeg = {c: 0 for c in abc}\n\nfor i in range(len(words) - 1):\n    out = match(words[i], words[i+1])\n    if out is not None:\n        c1,c2 = out\n        if c2 not in g[c1]:\n            g[c1].add(c2)\n            indeg[c2] += 1\n\n\n#Topsort things\nts = []\nzero = deque()\nfor u in g:\n    if indeg[u] == 0:\n        zero.append(u)\n\nwhile len(ts) != len(abc):\n    if len(zero) == 0:\n        print(\"IMPOSSIBLE\")\n        return\n    \n    u = zero.popleft()\n    ts.append(u)\n    for v in g[u]:\n        indeg[v] -= 1\n        if indeg[v] == 0:\n            zero.append(v)\n\nprint(\"\".join(ts))", "import os\nimport io\nfrom collections import deque, defaultdict\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\n\n# def li():return [int(i) for i in input().rstrip().split()]\n# def st():return str(input())\n# def val():return int(input())\n\n#Input Reading\n\nn,k = li()\n\nwords = [\"\"] * n * k\nindeg = {}\n\nfor i in range(n):\n    p = val()\n    page = []\n    for j in range(k):\n        word = st()\n        words[p*k+j] = word\n    for c in word:\n        indeg[c] = 0\n\ndef match(w1,w2):\n    for i in range(min(len(w1), len(w2))):\n        if w1[i] == w2[i]:\n            continue\n        else:\n            return (w1[i],w2[i])\n\n    if len(w1) > len(w2):\n        print(\"IMPOSSIBLE\")\n        return    \n\n#Reading the graph and its indegrees\ng = defaultdict(set)\n\nfor i in range(len(words) - 1):\n    out = match(words[i], words[i+1])\n    if out is not None:\n        c1,c2 = out\n        if c2 not in g[c1]:\n            g[c1].add(c2)\n            indeg[c2] += 1\n\n\n#Topsort things\nts = []\nzero = deque()\nfor u in indeg:\n    if indeg[u] == 0:\n        zero.append(u)\n\nwhile len(ts) != len(indeg):\n    if len(zero) == 0:\n        print(\"IMPOSSIBLE\")\n        return\n    \n    u = zero.popleft()\n    ts.append(u)\n    for v in g[u]:\n        indeg[v] -= 1\n        if indeg[v] == 0:\n            zero.append(v)\n\nprint(\"\".join(ts))", "import os\nimport sys\nfrom io import BytesIO, IOBase\n# region fastio\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline()\n \n# ------------------------------\n\n\ndef RL(): return map(int, sys.stdin.readline().split())\ndef RLL(): return list(map(int, sys.stdin.readline().split()))\ndef N(): return int(input())\ndef print_list(l):\n    print(' '.join(map(str,l)))\n# sys.setrecursionlimit(100000)\n# from heapq import *\n# from collections import deque as dq\n# from math import ceil,floor,sqrt,pow,gcd,log\n# import bisect as bs\n# from collections import Counter\nfrom collections import defaultdict as dc \n# from functools import lru_cache\nn,k = RL()\ndic = [[] for _ in range(1000)]\nfor _ in range(n):\n    page = N()\n    for _ in range(k):\n        dic[page].append(input().strip())\ndic = [word for page in dic for word in page]\nnw = len(dic)\n# print(dic)\ningress = dc(int)\nedges = dc(list)\nchars = set()\nchars|=set(dic[0])\nF = True\nfor i in range(1,nw):\n    a,b = dic[i-1],dic[i]\n    if len(chars)<26: chars|=set(b)\n    flag = False\n    for i,j in zip(a,b):\n        if i!=j:\n            ingress[j]+=1\n            edges[i].append(j)\n            flag = True\n            break\n    if not flag and len(b)<len(a):\n        F = False\n        break\nif not F:\n    print('IMPOSSIBLE')\nelse:\n# print(edges)\n    res = ''\n    now = []\n    for c in chars:\n        ingress[c] = max(0,ingress[c])\n        if ingress[c]==0:\n            now.append(c)\n    # print(ingress)\n    while now:\n        a = now.pop()\n        res+=a \n        for b in edges[a]:\n            ingress[b]-=1\n            if ingress[b]==0:\n                now.append(b)\n\n    if len(res)==len(chars):\n        print(res)\n    else:\n        print('IMPOSSIBLE')"]