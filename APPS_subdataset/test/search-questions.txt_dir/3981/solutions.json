["import sys\n\n\n# > 0 anti-clock, < 0 clockwise, == 0 same line\ndef orientation(p1, p2, p3):\n    return (p2[0] - p1[0])*(p3[1] - p1[1]) - (p2[1] - p1[1])*(p3[0] - p1[0])\n\n\ndef dot(p1, p2, p3, p4):\n    return (p2[0]-p1[0])*(p4[0]-p3[0]) + (p2[1]-p1[1])*(p4[1]-p3[1])\n\n\ndef theta(p1, p2):\n    dx = p2[0] - p1[0]\n    dy = p2[1] - p1[1]\n    if abs(dx) < 0.1 and abs(dy) < 0.1:\n        t = 0\n    else:\n        t = dy/(abs(dx) + abs(dy))\n        if abs(t) < 0.1 ** 10:\n            t = 0\n    if dx < 0:\n        t = 2 - t\n    elif dy < 0:\n        t = 4 + t\n\n    return t*90\n\n\ndef dist_sq(p1, p2):\n    return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])\n\n\ndef chull(points):\n    # let 0 element to be smallest, reorder elements\n    pi = [x for x in range(len(points))]\n    min_y = points[0][1]\n    min_x = points[0][0]\n    min_ind = 0\n    for i in range(len(points)):\n        if points[i][1] < min_y or points[i][1] == min_y and points[i][0] < min_x:\n            min_y = points[i][1]\n            min_x = points[i][0]\n            min_ind = i\n    pi[0] = min_ind\n    pi[min_ind] = 0\n    th = [theta(points[pi[0]], points[x]) for x in range(len(points))]\n    pi.sort(key=lambda x: th[x])\n    # process equals\n    unique = [pi[0], pi[1]]\n    for i in range(2, len(pi)):\n        if th[pi[i]] != th[unique[-1]]:\n            unique.append(pi[i])\n        else:\n            if dist_sq(points[pi[0]], points[unique[-1]]) < dist_sq(points[pi[0]], points[pi[i]]):\n                unique[-1] = pi[i] # put max\n    pi = unique\n    stack = []\n    for i in range(min(len(pi), 3)):\n        stack.append(points[pi[i]])\n    if len(stack) < 3:\n        return stack\n    for i in range(3, len(pi)):\n        while len(stack) >= 2:\n            o = orientation(stack[-2], stack[-1], points[pi[i]])\n            if o > 0:\n                stack.append(points[pi[i]])\n                break\n            elif o < 0:\n                stack.pop()\n            else:  # ==\n                if dist_sq(stack[-2], stack[-1]) < dist_sq(stack[-2], points[pi[i]]):\n                    stack.pop()\n                else:\n                    break  # skip i-th point\n    return stack\n\n\ndef z_func(s):\n    slen, l, r = len(s), 0, 0\n    z = [0]*slen\n    z[0] = slen\n    for i in range(1, slen):\n        if i <= r: z[i] = min(r-i+1, z[i-l])\n        while i+z[i] < slen and s[z[i]] == s[i+z[i]]: z[i] += 1\n        if i+z[i]-1 > r: l, r = i, i+z[i]-1\n    return z\n\nn,m = map(int, sys.stdin.readline().strip().split())\na = []\nfor _ in range(n):\n    x,y = map(int, sys.stdin.readline().strip().split())\n    a.append((x, y))\nb = []\nfor _ in range(m):\n    x, y = map(int, sys.stdin.readline().strip().split())\n    b.append((x, y))\n\nah = chull(a)\nbh = chull(b)\nif len(ah) == len(bh):\n    if len(ah) == 2:\n        if dist_sq(ah[0], ah[1]) == dist_sq(bh[0], bh[1]):\n            print('YES')\n        else:\n            print('NO')\n    else:\n        da = []\n        for i in range(len(ah)):\n            dot_a = dot(ah[i-2], ah[i-1], ah[i-1], ah[i])\n            da.append((dist_sq(ah[i], ah[i-1]), dot_a))\n        db = []\n        for i in range(len(bh)):\n            dot_b = dot(bh[i - 2], bh[i - 1], bh[i - 1], bh[i])\n            db.append((dist_sq(bh[i], bh[i-1]), dot_b))\n        l = r = 0\n        daab = []\n        daab.extend(db)\n        daab.append(-1)\n        daab.extend(da)\n        daab.extend(da)\n        zab = z_func(daab)\n        found = False\n        for i in range(len(db)+1, len(daab)-len(db)+1):\n            if zab[i] == len(db):\n                found = True\n                break\n        if found:\n            print('YES')\n        else:\n            print('NO')\nelse:\n    print('NO')"]