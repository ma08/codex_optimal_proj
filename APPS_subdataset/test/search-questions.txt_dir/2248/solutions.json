["3\n\n__import__(\"sys\").setrecursionlimit(10 ** 6)\nimport threading\n\nthreading.stack_size(64 * 1024 * 1024)\n\ndef dfs(u, h, par, tr, arr):\n    arr[u] = h\n    for v in tr[u]:\n        if v != par:\n            dfs(v, h + 1, u, tr, arr)\n\ndef longpathv(tr, v):\n    n = len(tr)\n    arr = [0] * n\n    dfs(v, 0, -1, tr, arr)\n    ans = max(list(range(n)), key=lambda x: arr[x])\n    return ans, arr[ans]\n\ndef longpath(tr):\n    return longpathv(tr, longpathv(tr, 0)[0])[1]\n\ndef main(tr):\n    print(longpath(tr))\n\nn, m = list(map(int, input().split()))\ntr = [[] for i in range(n)]\nfor i in range(m):\n    a, b = list(map(int, input().split()))\n    a -= 1\n    b -= 1\n    tr[a].append(b)\n    tr[b].append(a)\n\nth = threading.Thread(target=main, args=tuple([tr]))\nth.start()\n", "n, m = list(map(int, input().split()))\ncn = {}\nfor i in range(1, n+1):\n    cn[i] = set()\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    cn[a].add(b)\n    cn[b].add(a)\n\n\ndef dfs(node):\n    vs = set()\n    q = [(0, node)]\n    dist = 0\n    fnode = node\n    while q:\n        d, node = q.pop()\n        vs.add(node)\n        if d > dist:\n            dist, fnode = d, node\n        for i in cn[node]:\n            if i not in vs:\n                q.append((d+1, i))\n    return dist, fnode\n\n_, fnode = dfs(1)\nprint(dfs(fnode)[0])\n", "def bfs(x, g):\n    n, q = len(g), [x]\n    dist = [0 if y == x else -1 for y in range(n)]\n    i = 0\n    while i < len(q):\n        v = q[i]\n        i += 1\n        for to in g[v]:\n            if dist[to] < 0:\n                dist[to] = dist[v] + 1\n                q.append(to)\n    return (q[-1], dist[q[-1]])\n\nn, m = list(map(int, input().split()))\ng = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = [int(x) - 1 for x in input().split()]\n    g[a].append(b)\n    g[b].append(a)\n\nprint(bfs(bfs(0, g)[0], g)[1])\n", "import sys\n#with open(filename, 'r') as f:\nwith sys.stdin as f:\n    for i, line in enumerate(f):\n        if i == 0:\n            N, M = line.split(' ')\n            N, M = int(N), int(M)\n            graph = [[] for _ in range(N)] # [[]] * N not working, no deepcopy\n        else:\n            fromVertex, toVertex = line.split(' ')\n            fromVertex, toVertex = int(fromVertex)-1, int(toVertex)-1\n            graph[fromVertex].append(toVertex)\n            graph[toVertex].append(fromVertex)\n\n\n# code is too slow, O(N^3)\n#~ INFINITY = 9999999\n#~ from queue import Queue\n#~ def bfs(start_node, graph):\n    #~ N = len(graph)\n    #~ distances = [INFINITY for _ in range(N)]\n    #~ distances[start_node] = 0\n    #~ nodes_queue = Queue()\n    #~ nodes_queue.put(start_node)\n    #~ while not nodes_queue.empty():\n        #~ node = nodes_queue.get()\n        #~ for neigh in graph[node]:\n            #~ if distances[neigh] == INFINITY:\n                #~ # not yet visited\n                #~ distances[neigh] = distances[node] + 1\n                #~ nodes_queue.put(neigh)\n        \n    #~ return distances\n    \n# use tree structure\nfrom queue import Queue\ndef farthest_node_distance(start_node, graph):\n    \"\"\" returns farthest node from start node and its distance \"\"\"\n    N = len(graph)\n    visited = [False for _ in range(N)]\n    distances = [-1 for _ in range(N)]\n    visited[start_node] = True\n    distances[start_node] = 0\n    nodes_queue = Queue()\n    nodes_queue.put(start_node)\n    while not nodes_queue.empty():\n        node = nodes_queue.get()\n        #print(\"Taking {}: {}\".format(node, distances[node]))\n        for neigh in graph[node]:\n            if not visited[neigh]:\n                #print(\"Found {}\".format(neigh))\n                visited[neigh] = True\n                distances[neigh] = distances[node] + 1\n                nodes_queue.put(neigh)\n                #print(\"{}: {}\".format(neigh, distances[neigh]))\n    return node, distances[node]\n\nu, dist_u = farthest_node_distance(0, graph)\n#print(\"Done\")\nv, dist_uv = farthest_node_distance(u, graph)\nprint(dist_uv)\n#print(\"u: {}, {}\".format(u, dist_u))\n#print(\"v: {}, {}\".format(v, dist_uv))\n", "f = lambda: map(int, input().split())\n\nn, m = f()\np = [[] for i in range(n)]\nfor j in range(m):\n    a, b = f()\n    p[a - 1].append(b - 1)\n    p[b - 1].append(a - 1)\n\ndef g(i):\n    u, t = [1] * n, (0, i)\n    s = [t]\n    while s:\n        d, i = s.pop()\n        u[i] = 0\n        if d > t[0]: t = (d, i)\n        s += [(d + 1, j) for j in p[i] if u[j]]\n    return t\n\nprint(g(g(0)[1])[0])", "import copy\nimport sys\nimport threading\n\nthreading.stack_size(64 * 1024 * 1024)\nsys.setrecursionlimit(10 ** 6)\n\nn, m = map(int, input().split())\n\nans = 0\nsz = [0] * (n + 1)\ngraph = []\n\nfor _ in range(n + 1):\n    graph.append([])\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef dfs(v, pr):\n    nonlocal ans\n    for to in graph[v]:\n        if to != pr:\n            dfs(to, v)\n    if pr != -1:\n        ans = max(ans, sz[pr] + sz[v])\n        sz[pr] = max(sz[pr], sz[v] + 1)\n\ndef main():\n    dfs(1, -1)\n    print(ans + 1)\n    \nth = threading.Thread(target=main)\nth.start()", "n,m=map(int,input().split())\n\ngr=[[] for i in range(n)]\n\nfor i in range(m):\n\tu,v=map(int,input().split())\n\tgr[v-1].append(u-1)\n\tgr[u-1].append(v-1)\n\nv=[False for i in range(n)]\ns=[0]\ntr={}\ntr[0]=0\nwhile s:\n\tx=s.pop()\n\tv[x]=True\n\tfor j in gr[x]:\n\t\tif v[j]:continue\n\t\ts.append(j)\n\t\ttr[j]=tr[x]+1\nva=0\nma=0\nfor j in tr.keys():\n\tif ma<tr[j]:\n\t\tma=tr[j]\n\t\tva=j\nv=[False for i in range(n)]\ns=[va]\ntr={}\ntr[va]=0\nwhile s:\n\tx=s.pop()\n\tv[x]=True\n\tfor i in gr[x]:\n\t\tif v[i]:continue\n\t\ts.append(i)\n\t\ttr[i]=tr[x]+1\nprint(max(tr.values()))", "import sys\n\n\ndef find_farest_v(v, g):\n    queue_v = [(v, 0)]\n    order = []\n    visited_v = set()\n    while queue_v:\n        current_v, dist = queue_v.pop(0)\n        visited_v.add(current_v)\n        order.append((current_v, dist))\n        for neib in adj_graph[current_v]:\n            if neib not in visited_v:\n                queue_v.append((neib, dist + 1))\n    \n    return order[-1]\n\nn, m = list(map(int, input().strip().split(\" \")))\n\nadj_graph = [[] for i in range(n)]\n\nfor i in range(m):\n    line = input()\n    v1, v2 = list(map(int, line.split(\" \")))\n    adj_graph[v1 - 1].append(v2 - 1)\n    adj_graph[v2 - 1].append(v1 - 1)\n    \nv1, d1 = find_farest_v(0, adj_graph)\nv2, d2 = find_farest_v(v1, adj_graph)\n\nprint(d2) ", "import sys\ninput=sys.stdin.readline\nfrom collections import deque\n#sys.setrecursionlimit(10**8)\nt=1\nimport math\n \n \ndef bfs(a,i,dis,vis):\n    vis[i]=1\n    pp=deque()\n    pp.append(i)\n    while len(pp)!=0:\n        \n        z=pp[0]\n        vis[z]=1\n        pp.popleft()\n        for j in a[z]:\n            if vis[j]==0:\n                dis[j]=dis[z]+1\n                pp.append(j)\n                \n                \nwhile t>0:\n    t-=1\n    n,m=map(int,input().split())\n    a=[[] for i in range(n+1)]\n    for i in range(m):\n        x,y=map(int,input().split())\n        a[x].append(y)\n        a[y].append(x)\n    vis=[0 for i in range(n+1)]    \n    dis=[0 for i in range(n+1)]    \n    bfs(a,1,dis,vis)\n    #print(dis)\n    p=[max(dis),dis.index(max(dis))]\n    vis=[0 for i in range(n+1)]\n    dis=[0 for i in range(n+1)]\n    bfs(a,p[1],dis,vis)\n    p=[max(dis),dis.index(max(dis))]\n    print(p[0])", "# https://www.youtube.com/watch?v=_q7aMi-5Uos\nimport sys\nfrom collections import defaultdict\n\nn,m = list(map(int,sys.stdin.readline().lstrip().rstrip().split()))\ngraph = defaultdict(list)\nfor i in range(m):\n    u,v = list(map(int,sys.stdin.readline().lstrip().rstrip().split()))\n    graph[u-1].append(v-1)\n    graph[v-1].append(u-1)\n\nvisited = [False for i in range(n)]\nq = [[0,0]]\ntemp = []\nvisited[0] = True\nwhile q!=[]:\n    node,dist = q[0][0],q[0][1]\n    q.pop(0)\n    leaf = True\n    for v in graph[node]:\n        if visited[v]==False:\n            visited[v] = True\n            q.append([v,dist+1])\n            leaf = False\n    if leaf:\n        temp.append([dist,node])\ntemp.sort()\n\nvisited = [False for i in range(n)]\nq = [[temp[-1][1],0]]\ntemp = []\nvisited[q[0][0]] = True\nwhile q!=[]:\n    node,dist = q[0][0],q[0][1]\n    q.pop(0)\n    leaf = True\n    for v in graph[node]:\n        if visited[v]==False:\n            visited[v] = True\n            q.append([v,dist+1])\n            leaf = False\n    if leaf:\n        temp.append(dist)\nsys.stdout.write(str(max(temp))+'\\n')", "# itne me hi thakk gaye?\ndef bfs(x, g):\n    n, q = len(g), [x]\n    dist = [0 if y == x else -1 for y in range(n)]\n    i = 0\n    while i < len(q):\n        v = q[i]\n        i += 1\n        for to in g[v]:\n            if dist[to] < 0:\n                dist[to] = dist[v] + 1\n                q.append(to)\n    return (q[-1], dist[q[-1]])\n \nn, m = map(int, input().split())\ng = [[] for _ in range(n)]\n \nfor _ in range(m):\n    a, b = map(lambda x: int(x) - 1, input().split())\n    g[a].append(b)\n    g[b].append(a)\n \nprint(bfs(bfs(0, g)[0], g)[1])", "f = lambda: map(int, input().split())\n \nn, m = f()\np = [[] for i in range(n)]\nfor j in range(m):\n    a, b = f()\n    p[a - 1].append(b - 1)\n    p[b - 1].append(a - 1)\n \ndef g(i):\n    u, t = [1] * n, (0, i)\n    s = [t]\n    while s:\n        d, i = s.pop()\n        u[i] = 0\n        if d > t[0]: t = (d, i)\n        s += [(d + 1, j) for j in p[i] if u[j]]\n    return t\n \nprint(g(g(0)[1])[0])", "n,m=list(map(int,input().split()))\nfrom collections import defaultdict,deque\ng=defaultdict(list)\nfor i in range(m):\n    a,b=list(map(int,input().split()))\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\n\n\ndef dfs(x):\n    vis[x]=1\n    q=deque()\n    q.append((x,0))\n    while q:\n        cur,d=q.popleft()\n        \n        if maxd[0]<d:\n            maxd[0]=d\n            maxnode[0]=cur\n        for i in g[cur]:\n            if vis[i]==0:\n                q.append((i,d+1))\n                vis[i]=1\n    \n     \n    \n    \nvis=[0]*n\nmaxd=[0]\nmaxnode=[0]\ndfs(0)\nvis=[0]*n\nmaxd=[0]\ndfs(maxnode[0])\n\n\nprint(maxd[0])"]