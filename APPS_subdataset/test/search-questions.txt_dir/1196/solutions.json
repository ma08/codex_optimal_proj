["def ziped(a):\n\tp = []\n\tfor i in a:\n\t\tx = int(i.split('-')[0])\n\t\ty = i.split('-')[1]\n\t\tif len(p) > 0 and p[-1][1] == y:\n\t\t\tp[-1][0] += x\n\t\telse:\n\t\t\tp.append([x, y])\n\treturn p\n\ndef solve(a, b , c):\n\tans = 0\n\tif len(b) == 1:\n\t\tfor token in a:\n\t\t\tif c(token, b[0]):\n\t\t\t\tans += token[0] - b[0][0] + 1\n\t\treturn ans\n\t\t\n\tif len(b) == 2:\n\t\tfor i in range(len(a) - 1):\n\t\t\tif c(a[i], b[0]) and c(a[i + 1], b[-1]):\n\t\t\t\tans += 1\n\t\treturn ans\n\t\t\n\tv = b[1 : -1] + [[100500, '#']] + a\n\tp = [0] * len(v)\n\tfor i in range(1, len(v)):\n\t\tj = p[i - 1]\n\t\twhile j > 0 and v[i] != v[j]:\n\t\t\tj = p[j - 1]\n\t\tif v[i] == v[j]:\n\t\t\tj += 1\n\t\tp[i] = j\n\t\t\n\tfor i in range(len(v) - 1):\n\t\tif p[i] == len(b) - 2 and c(v[i - p[i]], b[0]) and c(v[i + 1], b[-1]):\n\t\t\tans += 1\n\treturn ans\n\nn, m = list(map(int, input().split()))\na = ziped(input().split())\nb = ziped(input().split())\nprint(solve(a, b, lambda x, y: x[1] == y[1] and x[0] >= y[0]))\n", "def ziped(a):\n    p = []\n    for i in a:\n        x = int(i.split('-')[0])\n        y = i.split('-')[1]\n        if len(p) > 0 and p[-1][1] == y:\n                p[-1][0] += x\n        else:\n                p.append([x, y])\n    return p\n\ndef solve(a, b , c):\n    \n    ans = 0\n    if len(b) == 1:\n        for token in a:\n            #print(\"token\",token)\n            if c(token, b[0]):\n                ans += token[0] - b[0][0] + 1\n        return ans\n\t\t\n    if len(b) == 2:\n        for i in range(len(a) - 1):\n            if c(a[i], b[0]) and c(a[i + 1], b[-1]):\n                ans += 1\n        return ans\n\t\t\n    v = b[1 : -1] + [[100500, '#']] + a\n    p = [0] * len(v)\n    for i in range(1, len(v)):\n        j = p[i - 1]\n        while j > 0 and v[i] != v[j]:\n            j = p[j - 1]\n        if v[i] == v[j]:\n            j += 1\n        p[i] = j\n\t\t\n    for i in range(len(v) - 1):\n        if p[i] == len(b) - 2 and c(v[i - p[i]], b[0]) and c(v[i + 1], b[-1]):\n            ans += 1\n    return ans\n\nn, m = list(map(int, input().split()))\na = ziped(input().split())\nb = ziped(input().split())\nprint(solve(a, b, lambda x, y: x[1] == y[1] and x[0] >= y[0]))\n", "def compress(bstr):\n    pk, pc = None, None\n\n    for block in bstr:\n        if pc is None:\n            pk, pc = block\n        elif pc == block[1]:\n            pk += block[0]\n        else:\n            yield  pk, pc\n            pk, pc = block\n\n    if pc is not None:\n        yield pk, pc\n\n\ndef find1(text, query):\n    (bk, bc), = query\n    return sum(k-bk+1 for k, c in text if c == bc and k >= bk)\n\n\nclass Query:\n    def __init__(self, query):\n        self._query = query\n        self._len = len(query)\n        self._suffixes = {}\n\n    def precompute(self):\n        for i in range(self._len-1):\n            self._suffix(i)\n\n    def _suffix(self, i, pblock=None):\n        if not i:\n            return None\n\n        if pblock is None and i is not None:\n            pblock = self._query[i]\n\n        if (i, pblock) in self._suffixes:\n            return self._suffixes[i, pblock]\n        else:\n            sfx = self.next(self._suffix(i-1), pblock)\n            self._suffixes[i, pblock] = sfx\n            return sfx\n\n    def _match(self, i, block):\n        if i == 0 or i == self._len -1:\n            return (block[1] == self._query[i][1]\n                    and block[0] >= self._query[i][0])\n        else:\n            return block == self._query[i]\n\n    def next(self, i, block, pblock=None):\n        while True:\n            if i is None:\n                return 0 if self._match(0, block) else None\n            elif i < self._len-1:\n                if self._match(i+1, block):\n                    return i+1\n                else:\n                    i = self._suffix(i)\n            else:\n                i = self._suffix(i, pblock)\n                pblock = None\n\n    def is_match(self, i):\n        return i == self._len-1\n\n\ndef find2(text, query):\n    qobj = Query(query)\n    qobj.precompute()\n    i = None\n    pblock = None\n    c = 0\n    for block in text:\n        i, pblock = qobj.next(i, block, pblock), block\n        if qobj.is_match(i):\n            c += 1\n    return c\n\n\ndef find(text, query):\n    text = list(compress(text))\n    query = list(compress(query))\n    return (find1 if len(query) == 1 else find2)(text, query)\n\n\ndef parse_block(s):\n    k, c = s.split('-')\n    return int(k), c\n\n\ndef get_input():\n    n, m = list(map(int, input().split()))\n    text = list(map(parse_block, input().split()))\n    assert len(text) == n\n    query = list(map(parse_block, input().split()))\n    assert len(query) == m\n    return text, query\n\n\ndef __starting_point():\n    print(find(*get_input()))\n\n__starting_point()", "def compress(bstr):\n    pk, pc = None, None\n\n    for block in bstr:\n        if pc is None:\n            pk, pc = block\n        elif pc == block[1]:\n            pk += block[0]\n        else:\n            yield  pk, pc\n            pk, pc = block\n\n    if pc is not None:\n        yield pk, pc\n\n\ndef find1(text, query):\n    (bk, bc), = query\n    return sum(k-bk+1 for k, c in text if c == bc and k >= bk)\n\n\nclass Query:\n    def __init__(self, query):\n        self._query = query\n        self._len = len(query)\n        self._suffixes = [None]\n\n    def _suffix(self, i, pblock=None):\n        if i is None:\n            return None\n\n        for j in range(len(self._suffixes), min(i+1, self._len-1)):\n            self._suffixes.append(\n                self.next(self._suffixes[j-1], self._query[j]))\n\n        if i < self._len - 1:\n            return self._suffixes[i]\n        else:\n            return self.next(self._suffixes[i-1], pblock)\n\n    def _match(self, i, block):\n        if i == 0 or i == self._len -1:\n            return (block[1] == self._query[i][1]\n                    and block[0] >= self._query[i][0])\n        else:\n            return block == self._query[i]\n\n    def next(self, i, block, pblock=None):\n        while True:\n            if i is None:\n                return 0 if self._match(0, block) else None\n            elif i < self._len-1:\n                if self._match(i+1, block):\n                    return i+1\n                else:\n                    i = self._suffix(i)\n            else:\n                i = self._suffix(i, pblock)\n                pblock = None\n\n    def is_match(self, i):\n        return i == self._len-1\n\n\ndef find2(text, query):\n    qobj = Query(query)\n    i = None\n    pblock = None\n    c = 0\n    for block in text:\n        i, pblock = qobj.next(i, block, pblock), block\n        if qobj.is_match(i):\n            c += 1\n    return c\n\n\ndef find(text, query):\n    text = list(compress(text))\n    query = list(compress(query))\n    return (find1 if len(query) == 1 else find2)(text, query)\n\n\ndef parse_block(s):\n    k, c = s.split('-')\n    return int(k), c\n\n\ndef get_input():\n    n, m = list(map(int, input().split()))\n    text = list(map(parse_block, input().split()))\n    assert len(text) == n\n    query = list(map(parse_block, input().split()))\n    assert len(query) == m\n    return text, query\n\n\ndef __starting_point():\n    print(find(*get_input()))\n\n__starting_point()", "def main():\n    input()\n    ts = []\n    for _ in 0, 1:\n        tmp = input().split()\n        a, x, l = tmp[0][-1], 0, []\n        for st in tmp:\n            y = int(st[:-2])\n            b = st[-1]\n            if a != b:\n                l.append(((x, a)))\n                x, a = y, b\n            else:\n                x += y\n        l.append(((x, a)))\n        ts.append(l)\n    t, s = ts\n    res, m, x, a, y, b = 0, len(s), *s[0], *s[-1]\n    if m == 1:\n        res = sum(y - x + 1 for y, b in t if a == b and x <= y)\n    elif m == 2:\n        i, u = 0, ' '\n        for j, v in t:\n            if a == u and b == v and x <= i and y <= j:\n                res += 1\n            i, u = j, v\n    else:\n        t[:0] = s[1: -1] + [(0, ' ')]\n        tmp = [0] * len(t)\n        for i, j in zip(list(range(1, len(t))), tmp):\n            while j > 0 and t[i] != t[j]:\n                j = tmp[j - 1]\n            tmp[i] = j + 1 if t[i] == t[j] else j\n        m -= 2\n        del tmp[-1]\n        for i, q in enumerate(tmp):\n            if q == m:\n                i, u, j, v = *t[i - q], *t[i + 1]\n                if a == u and b == v and x <= i and y <= j:\n                    res += 1\n    print(res)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def ziped(a):\n\tp = []\n\tfor i in a:\n\t\tx = int(i.split('-')[0])\n\t\ty = i.split('-')[1]\n\t\tif len(p) > 0 and p[-1][1] == y:\n\t\t\tp[-1][0] += x\n\t\telse:\n\t\t\tp.append([x, y])\n\treturn p\n\ndef solve(a, b , c):\n\tans = 0\n\tif len(b) == 1:\n\t\tfor token in a:\n\t\t\tif c(token, b[0]):\n\t\t\t\tans += token[0] - b[0][0] + 1\n\t\treturn ans\n\n\tif len(b) == 2:\n\t\tfor i in range(len(a) - 1):\n\t\t\tif c(a[i], b[0]) and c(a[i + 1], b[-1]):\n\t\t\t\tans += 1\n\t\treturn ans\n\n\tv = b[1 : -1] + [[100500, '#']] + a\n\tp = [0] * len(v)\n\tfor i in range(1, len(v)):\n\t\tj = p[i - 1]\n\t\twhile j > 0 and v[i] != v[j]:\n\t\t\tj = p[j - 1]\n\t\tif v[i] == v[j]:\n\t\t\tj += 1\n\t\tp[i] = j\n\n\tfor i in range(len(v) - 1):\n\t\tif p[i] == len(b) - 2 and c(v[i - p[i]], b[0]) and c(v[i + 1], b[-1]):\n\t\t\tans += 1\n\treturn ans\n\nn, m = list(map(int, input().split()))\na = ziped(input().split())\nb = ziped(input().split())\nprint(solve(a, b, lambda x, y: x[1] == y[1] and x[0] >= y[0]))\n"]