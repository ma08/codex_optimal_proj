["n, m, k = list(map(int, input().split()))\ndeadstep = [0] * (n+1)\nbadmem = [False] * (k+1)\na = [0] * (n+1)\nfor i in range(1, n+1):\n    a[i] = [0] + list(map(int, input().split()))\nfor step in range(1, m+1):\n    t = [0] * (k+1)\n    for i in range(1, n+1):\n        if deadstep[i] == 0 and a[i][step] != 0:\n            t[a[i][step]] += 1\n    for j in range(1, k+1):\n        if t[j] > 1:\n            badmem[j] = True\n    for i in range(1, n+1):\n        if deadstep[i] == 0 and badmem[a[i][step]]:\n            deadstep[i] = step\nfor i in range(1, n+1):\n    print(deadstep[i])\n", "n,m,k=list(map(int,input().split()))\nL=[]\nfor i in range(n):\n    L.append(list(map(int,input().split())))\n\nLocked=[-1]*n\nZ={}\nfor i in range(m):\n    K={}\n    for j in range(n):\n        if(Locked[j]!=-1):\n            continue\n        if(L[j][i] in K):\n            K[L[j][i]].append(j)\n        else:\n            K[L[j][i]]=[j]\n    for item in K:\n        if(item==0):\n            continue\n        if(item in Z):\n            for e in K[item]:\n                if(Locked[e]==-1):\n                    Locked[e]=i\n        elif(len(K[item])>1):\n            Z[item]=1\n            for e in K[item]:\n                if(Locked[e]==-1):\n                    Locked[e]=i\nfor i in range(n):\n    print(Locked[i]+1)\n", "n, m, k = list(map(int, input().split()))\nans = [0 for i in range(n)]\nlock = [False for i in range(k)]\ndeadlock = lock[:]\ninsset = [[0 for i in range(n)] for i in range(m)]\nfor i in range(n):\n    ins = list(map(int, input().split()))\n    for j in range(m):\n        insset[j][i] = ins[j]\nfor r in range(m):\n    ins = insset[r]\n    for i, el in enumerate(ins):\n        if el == 0 or ans[i]:\n            continue\n        if lock[el-1]:\n            deadlock[el-1] = True\n        else:\n            lock[el-1] = True\n    for i in range(n):\n        if ins[i] == 0 or ans[i]:\n            continue\n        if deadlock[ins[i]-1]:\n            ans[i] = r+1\n    lock = [False for i in range(k)]\nfor el in ans:\n    print(el)\n\n", "n, m, k = list(map(int, input().split()))\nx = [list([int(a) - 1 for a in input().split()]) for i in range(n)]\nres = [-1] * n\nlocked = [False] * k\nfor t in range(m):\n    w = [0] * k\n    for i in range(n):\n        if res[i] == -1 and x[i][t] != -1:\n            w[x[i][t]] += 1\n\n    for i in range(n):\n        if res[i] == -1 and x[i][t] != -1 and (w[x[i][t]] >= 2 or locked[x[i][t]]):\n            locked[x[i][t]] = True\n            res[i] = t\nres = [i + 1 for i in res]\nfor i in res:\n    print(i)\n", "n, m, k = map(int, input().split())\ncores = [1 for i in range(n)]\ncells = [1 for i in range(k)]\ninfo = []\nblockings = [0 for i in range(n)]\nfor i in range(n):\n    k = list(map(int, input().split()))\n    for j in range(len(k)):\n        k[j] -= 1\n    info.append(k)\nfor i in range(m):\n    for j in range(n):\n        if cores[j] == 0:\n            continue\n        cell = info[j][i]\n        if cell == -1:\n            continue\n        if cells[cell] == 0:\n            cores[j] = 0\n            blockings[j] = i + 1\n            continue\n        for core in range(n):\n            if core != j:\n                cell_1 = info[core][i]\n                if cell_1 == cell and blockings[core] == 0:\n                    cells[cell] = 0\n                    cores[j] = 0\n                    blockings[j] = i + 1\n                    break\nfor elem in blockings:\n    print(elem)", "b=input().split()\ncore=[]\nkcore=int(b[0])\nktact=int(b[1])\nfor i in range(kcore):\n    work=input().split()\n    core.append([])\n    for j in range(ktact):\n        core[i].append(int(work[j]))\n#...\nzmemory=[]\nfor i in range(int(b[2])):\n    zmemory.append(0)\nzcore=[]\nanswer=[]\nfor i in range(kcore):\n    zcore.append(0)\n    answer.append(0)\n#...\nfor i in range(ktact):\n    freecore=[]\n    for j in range(kcore):\n        if zcore[j]==0:\n            freecore.append(j)\n    for j in freecore:\n        if not(core[j][i]==0):\n            if zmemory[core[j][i]-1]:\n                zcore[j]=1\n                answer[j]=i+1\n            for k in freecore:\n                if not(k==j):\n                    if core[j][i]==core[k][i]:\n                        zmemory[core[j][i]-1]=1\n                        zcore[j]=1\n                        answer[j]=i+1\n                        zcore[k]=1\n                        answer[k]=i+1\n#...\nfor i in range(kcore):\n    print(answer[i])\n", "N,M,k = list(map(int,input().split()))\ncash =[-1]*(k+1)\ncash_lock = [False]*(k+1)\nprocessers = [0]*(N)\nprocess = []\nfor i in range(N):\n    process.append(list(map(int,input().split())))\nfor j in range(M):\n    for i in range(N):\n        if processers[i]==0:\n            if process[i][j] !=0:\n                cash_num = process[i][j]\n                if cash[cash_num] == -1 and not cash_lock[cash_num]:\n                    cash[cash_num] = i\n                elif cash_lock[cash_num]:\n                    processers[i]=j+1\n                elif cash[cash_num] != -1:\n                    processers[i]=j+1\n                    processers[cash[cash_num]] =j+1\n                    cash_lock[cash_num] = True\n    for i in range(1,k+1):\n        cash[i] = -1\nfor i in range(N):\n    print(processers[i])\n\n", "n, m, k = map(int, input().split())\na = [[0 for i in range(m)] for j in range(n)]\ninf = [0 for i in range(k + 1)]\nstat = [True for i in range(n + 1)]\ntime = [0 for i in range(n + 1)]\nfor i in range(n):\n    a[i] = list(map(int, input().split()))\nfor i in range(m):\n    for j in range(1, n + 1):\n        if stat[j]:\n            current_core = inf[a[j - 1][i]]\n            if current_core == 0 and a[j - 1][i]  != 0:\n                inf[a[j - 1][i]] = j\n            elif current_core == -1:\n                stat[j], time[j] = False, i + 1\n            elif a[j - 1][i] != 0:\n                stat[current_core], time[current_core] = False, i + 1\n                stat[j], time[j] = False, i + 1\n                inf[a[j - 1][i]] = -1\n    for p in range(len(inf)):\n        if inf[p] != -1:\n            inf[p] = 0\nfor i in range(1, n + 1):\n    print(time[i])", "n,m,k=list(map(int,input('').split()))\nx={}\nout=[]\nmemory=[]\nfor i in range(n):\n    x[i]=list(map(int, input('').split()))\n    out+=[(0)]\nfor j in range(m):\n    for i in range(n):\n        k=x[i][j]\n        if k!=0:\n            for q in range(n):\n                if i!=q and out[i]==0:\n                    for p in memory:\n                        if p==k: \n                            out[i]=j+1\n                            break\n                    if k==x[q][j] and out[q]==0:\n                        out[i]=j+1\n                        out[q]=j+1\n                        memory+=[(k)]\n        \nfor i in range(n):\n    print(out[i])\n\n            \n        \n        \n\n", "n,m,k=list(map(int,input('').split()))\nx={}\nout=[]\nmemory=[]\nfor i in range(n):\n    x[i]=list(map(int, input('').split()))\n    out+=[(0)]\nfor j in range(m):\n    for i in range(n):\n        k=x[i][j]\n        if k!=0 and out[i]==0:\n            for q in range(n):\n                if i!=q:\n                    for p in memory:\n                        if p==k: \n                            out[i]=j+1\n                            break\n                    if k==x[q][j] and out[q]==0:\n                        out[i]=j+1\n                        out[q]=j+1\n                        memory+=[(k)]\n        \nfor i in range(n):\n    print(out[i])\n\n            \n        \n        \n\n", "import sys\nread = lambda: list(map(int, sys.stdin.readline().split()))\nn, m, k = read()\n\ntable = []\nfor _ in range(n):\n    table.append(read())\ntable = list(zip(*table))\n\nlocked_cells = set()\nlocked_procs = set()\nlock_time = [0]*n\nfor t, ys in enumerate(table):\n    cnt = [0]*(k+1)\n    for i, c in enumerate(ys):\n        if i not in locked_procs:\n            cnt[c] += 1\n    for c, cn in enumerate(cnt):\n        if c > 0 and cn > 1:\n            locked_cells.add(c)\n    for i, c in enumerate(ys):\n        if c in locked_cells and i not in locked_procs:\n            locked_procs.add(i)\n            lock_time[i] = t+1\n\nfor t in lock_time:\n    print(t)\n", "def main():\n\tn, m, k = map(int, input().split())\n\tM = [0] * n\n\tfor i in range(n):\n\t\tM[i] = list(map(int, input().split()))\n\tbn = [0] * n\n\tbm = [0] * k\n\tfor t in range(m):\n\t\tlast = [-1] * k\n\t\tcnt = [0] * k\n\t\tfor i in range(n):\n\t\t\tif bn[i] or not M[i][t]:\n\t\t\t\tcontinue\n\t\t\tif bm[M[i][t] - 1]:\n\t\t\t\tbn[i] = t + 1\n\t\t\telse:\n\t\t\t\tif last[M[i][t] - 1] != -1:\n\t\t\t\t\tbn[last[M[i][t] - 1]] = t + 1\n\t\t\t\tlast[M[i][t] - 1] = i\n\t\t\t\tcnt[M[i][t] - 1] += 1\n\t\tfor i in range(k):\n\t\t\tif cnt[i] > 1:\n\t\t\t\tbm[i] = t + 1\n\t\t\t\tbn[last[i]] = t + 1\n\tfor i in range(n):\n\t\tprint(bn[i])\n\t\nmain()", "n,m,k=list(map(int,input().split()))\nyadra=[0]*n\nyach=[True]*(k+1)\nyachzt=[[] for i in range(k+1)]\nl2=[list(map(int,input().split())) for i in range(n)]\nfor i in range(m):\n    for i2 in range(n):\n        if l2[i2][i] and (not yadra[i2]):\n            yachzt[l2[i2][i]].append(i2)\n    for i2 in range(k+1):\n        if (len(yachzt[i2])>=2) or (not yach[i2]) :\n            yach[i2]=False\n            for a in yachzt[i2]:\n                yadra[a]=(i+1)\n    yachzt=[[] for i2 in range(k+1)]\nfor fl in yadra:\n    print(fl)\n            \n", "n, m, k = map(int, input().split())\ncycles = [[] for x in range(m)]\nfor x in range(n):\n    temp = list(map(int, input().split()))\n    for i in range(m):\n        cycles[i].append(temp[i])\nactive_cores, active_memory = [0] * n, [0] * (k + 1)\nfor i in range(m):\n    temp = {}\n    for j in range(n):\n        if not active_cores[j]:\n            temp[cycles[i][j]] = temp.get(cycles[i][j], []) + [j]\n    for j in range(n):\n        if (cycles[i][j]) and (not active_cores[j]) and (len(temp[cycles[i][j]]) > 1 or active_memory[cycles[i][j]]):\n            active_cores[j] = active_memory[cycles[i][j]] = i + 1\nprint(*active_cores, sep = '\\n')\n", "\ndef pretty_print_list(a):\n    for aa in a:\n        print(*aa)\n\nn, m, k = map(int, input().split())\n#print(n, m, k)\n\n#x = [[-1] * m] * n\nx = [[-1 for _ in range(m)] for _ in range(n)]\nfor i in range(n):\n    z = [y for y in map(int, input().split(\" \"))]\n#    print(\"i:n:\", i, \"z:\", *z)\n    for j in range(m):\n        x[i][j] = z[j]\n#       x[i] = [z for z in map(int, input().split(\" \"))]\n\n#pretty_print_list(x)\n\n\nd = {}\nlocked_cores = {}\nlocked_cells = {}\n\nfor i in range(m):\n    d = {}\n    for j in range(n):\n        if x[j][i] != 0:\n            if not j in locked_cores:\n                c = d.get(x[j][i], [])\n                c.append(j)        \n                d[x[j][i]] = c\n            \n    for cell in d:\n        if len(d[cell]) > 1:\n            for core in d[cell]:\n                if not core in locked_cores:\n                    locked_cores[core] = i + 1\n                if not cell in locked_cells:\n                    locked_cells[cell] = i + 1\n        for core in d[cell]:\n            if cell in locked_cells:\n                if not core in locked_cores:\n                    locked_cores[core] = i + 1             \n        \n        \n    #print(i, d); print(\"locked_cores:\", locked_cores); print(\"locked_cells:\", locked_cells)\n    \n    \n\nfor i in range(n):\n    if i in locked_cores:\n        print(locked_cores[i])\n    else:\n        print(0)", "n, m, k = map(int, input().split())\nk += 1\ndead = [0] * n  # time of deadlock\nblock = [False] * k  # ceil is blocked\nt = [tuple(map(int, input().split())) for i in range(n)]\nfor j, s in enumerate(zip(*t), 1):\n    q = [[] for i in range(k)]\n    for core, ceil in enumerate(s):\n        if dead[core] == 0: q[ceil].append(core)\n    for ceil in range(1, k):\n        if not q[ceil]: continue\n        if block[ceil] or len(q[ceil]) > 1:\n            for core in q[ceil]: dead[core] = j\n            block[ceil] = True\nprint('\\n'.join(map(str, dead)))", "__author__ = 'Lipen'\n\ndef main():\n    n, m, k = map(int, input().split())\n    data = []\n    when = [0]*n\n    blockedcells = set()\n    blockedcores = set()\n\n    for _ in range(n):\n        data.append(list(map(int, input().split())))\n\n    for j in range(m):\n        operation = []\n        for _ in range(k):\n            operation.append([])\n\n        for i in range(n):\n            if i not in blockedcores:\n                x = data[i][j] - 1\n                if x>=0:\n                    if x in blockedcells:\n                        blockedcores.add(i)\n                        when[i] = j+1\n                    elif len(operation[x]) > 0:\n                        blockedcells.add(x)\n                        for core in operation[x]:\n                            blockedcores.add(core)\n                            when[core] = j+1\n                        blockedcores.add(i)\n                        when[i] = j+1\n                    operation[x].append(i)\n\n    for i in when:\n        print(i)\n\nmain()", "n, m, k = list(map(int, input().split()))\nl = []\n\ns = [0 for i in range(n)]\nf = [False for i in range(k + 1)]\n\nfor i in range(n):\n    l.append(list(map(int, input().split())))\n\nfor j in range(m):\n    b = [-1 for i in range(k + 1)]\n    for i in range(n):\n        if s[i] or not l[i][j]:\n            continue\n        if f[l[i][j]]:\n            s[i] = j + 1\n        if b[l[i][j]] == -1:\n            b[l[i][j]] = i\n        else:\n            s[b[l[i][j]]] = j + 1\n            s[i] = j + 1\n            f[l[i][j]] = True\n\nfor i in s:\n    print(i)", "n, m, k = map(int,input().split())\nips = list()\nfor i in range(n):\n    ips.append(list(map(int,input().split())))\n\n\nlocked = [-1] * (n)\nlc = [-1] * (k)\nfor j in range(m):\n    cells = [-1] * (k)\n    for i in range(n):\n        if locked[i] == -1:\n            if ips[i][j]-1 > -1:\n                if lc[ips[i][j]-1] == -1:\n                   if cells[ips[i][j]-1] == -1:\n                       cells[ips[i][j]-1] = i\n                     \n                   else:\n                       lc[ips[i][j]-1] = 1\n                       locked[i] = j\n                       locked[cells[ips[i][j]-1]] = j\n                      \n                else:\n                    locked[i] = j\n                    \nfor i in range(n):\n    print(locked[i]+1)", "from collections import Counter\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nv, l = [0] * n, [False] * k\nfor j in range(m):\n    c = Counter(a[i][j] for i in range(n))\n    for i in range(n):\n        if not v[i] and a[i][j] and (l[a[i][j] - 1] or c[a[i][j]] > 1):\n            v[i] = j + 1\n            l[a[i][j] - 1] = True\n            a[i] = [0] * m\nprint(*v, sep='\\n')\n", "from collections import Counter\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\nv, l = [0] * n, [False] * k\nfor j in range(m):\n    c = Counter(a[i][j] for i in range(n))\n    for i in range(n):\n        if not v[i] and a[i][j] and (l[a[i][j] - 1] or c[a[i][j]] > 1):\n            v[i] = j + 1\n            l[a[i][j] - 1] = True\n            a[i] = [0] * m\nprint(*v, sep='\\n')\n", "def adds(memtoproc,mem,proc):\n    if mem in memtoproc:\n        memtoproc[mem].append(proc)\n    else:\n        memtoproc[mem]=[proc]\n\ndef corr(arr,n,m):\n    brokemems=set()\n    stopprocs=[0]*n\n    for c in range(m):\n        memtoproc=dict()\n        usemems=set()\n        locmems=set()\n        for d in range(n):\n            if not arr[d][c] or stopprocs[d]:\n                continue\n            adds(memtoproc,arr[d][c],d)\n            if arr[d][c] in usemems:\n                locmems.add(arr[d][c])\n            usemems.add(arr[d][c])\n            if arr[d][c] in brokemems:\n                if not stopprocs[d]:\n                    stopprocs[d]=c+1\n        for d in locmems:\n            brokemems.add(d)\n            procs=memtoproc[d]\n            for x in procs:\n                if not stopprocs[x]:\n                    stopprocs[x]=c+1\n    return stopprocs\n            \n\nn,m,k=list(map(int,input().split(' ')))\narr=[]\nfor c in range(n):\n    arr.append(tuple(map(int,input().split(' '))))\nprocs=corr(arr,n,m)\nfor c in procs:\n    print(c)\n\n", "from collections import Counter\n\nn, m, k = map(int, input().split())\n\na = [list(map(int, input().split())) for i in range(n)]\n\nv, l = [0] * n, [False] * k\n\nfor j in range(m):\n\n    c = Counter(a[i][j] for i in range(n))\n\n    for i in range(n):\n\n        if not v[i] and a[i][j] and (l[a[i][j] - 1] or c[a[i][j]] > 1):\n\n            v[i] = j + 1\n\n            l[a[i][j] - 1] = True\n\n            a[i] = [0] * m\n\nprint(*v, sep='\\n')\n\n\n\n\n\n# Made By Mostafa_Khaled", "from collections import defaultdict\nn, m, k = [int(i) for i in input().split()]\ncell = [0 for i in range(k+1)]\ncore = [0 for i in range(n+1)]\n\n# if core is positive, it has been locked, same if a cell is positive\n# core would access the cell\n\n# n is the number of cores\n# m is the number of cycle\n# k is the number of cells\n\nA = [[int(i) for i in input().split()] for j in range(n)] # reading in the n lines\nA = [[0] + [row[i] for row in A] for i in range(len(A[0]))] # now i have tranpose it\n# append 0 at the start\n\n# now A is of size m+1 by n\n# each row is a timestep\n\nfor t in range(m):\n    cell_visited = defaultdict(set)\n    for i in range(1, n+1): # go through each core\n        if A[t][i] > 0 and core[i] == 0: # instruction to do something and the core is not locked\n            if cell[A[t][i]] > 0: # the cell is locked, lock the core if it's not locked\n                core[i] = t + 1\n            elif cell[A[t][i]] == 0: # the cell is not locked\n                cell_visited[A[t][i]].add(i)\n    for i in cell_visited: #i is the index of the cell\n        if len(cell_visited[i]) > 1:\n            cell[i] = 1 # lock the cell\n            for j in cell_visited[i]:\n                core[j] = t + 1\nfor i in range(1, n+1):\n    print(core[i])\n"]