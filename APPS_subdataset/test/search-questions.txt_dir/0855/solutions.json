["\nk,a0,b0 = map(int,input().split())\na0,b0 = a0-1,b0-1\n\nA = tuple(tuple(map(lambda c: int(c)-1,input().split())) for _ in range(3))\nB = tuple(tuple(map(lambda c: int(c)-1,input().split())) for _ in range(3))\n\n# A chose i and B chose j implies ? will choose ?[i][j]\n\nscore = lambda a,b: (int((a-b)%3==1),int((b-a)%3==1))\n\nS = set()\n\ncur = (a0,b0)\n\nwhile cur not in S:\n  S.add(cur)\n  a,b = cur\n  cur = (A[a][b],B[a][b])\n\npre = (0,0)\np = (a0,b0)\nwhile k > 0 and p != cur:\n  pre = tuple(c+d for c,d in zip(pre,score(*p)))\n  a,b = p\n  p = (A[a][b],B[a][b])\n  k -= 1\n\nif k == 0:\n  print(*pre)\n  return\n\n# cycle length\nL = 1\ncnt = score(*cur)\na,b = cur\np = (A[a][b],B[a][b])\n\nwhile p != cur:\n  cnt = tuple(c+d for c,d in zip(cnt,score(*p)))\n  L += 1\n  a,b = p\n  p = (A[a][b],B[a][b])\n\nn = k//L\nk -= (k//L)*L\ncnt = (cnt[0]*n,cnt[1]*n)\n\nsuf = (0,0)\np = cur\nwhile k > 0:\n  suf = tuple(c+d for c,d in zip(suf,score(*p)))\n  a,b = p\n  p = (A[a][b],B[a][b])\n  k -= 1\n\nprint(*(a+b+c for a,b,c in zip(pre,cnt,suf)))", "def readln(): return list(map(int, input().rstrip().split()))\n\n\ndef score_of(x, y):\n    if x == y:\n        return 0, 0\n    elif x == 3 and y == 2:\n        return 1, 0\n    elif x == 2 and y == 3:\n        return 0, 1\n    elif x == 2 and y == 1:\n        return 1, 0\n    elif x == 1 and y == 2:\n        return 0, 1\n    elif x == 1 and y == 3:\n        return 1, 0\n    elif x == 3 and y == 1:\n        return 0, 1\n\n\nk, a, b = readln()\nA, B = [[0 for i in range(4)] for j in range(4)], [[0 for i in range(4)] for j in range(4)]\nfor i in range(1, 4):\n    a1, a2, a3 = readln()\n    A[i][1], A[i][2], A[i][3] = a1, a2, a3\nfor i in range(1, 4):\n    a1, a2, a3 = readln()\n    B[i][1], B[i][2], B[i][3] = a1, a2, a3\n\ncircle = set()\ncircle_score = [(0, 0)]\ncircle_data = []\nx, y = a, b\nwhile (x, y) not in circle and k > 0:\n    circle.add((x, y))\n    circle_data.append((x, y))\n    x_, y_ = score_of(x, y)\n    circle_score.append((circle_score[-1][0] + x_, circle_score[-1][1] + y_))\n    x, y = A[x][y], B[x][y]\n    k -= 1\n\nif k == 0:\n    print(\"{} {}\".format(circle_score[-1][0], circle_score[-1][1]))\n    return\n\npre_idx = circle_data.index((x, y))\nfreq = len(circle_data) - pre_idx\nfscorea, fscoreb = circle_score[-1][0] - circle_score[pre_idx][0], circle_score[-1][1] - circle_score[pre_idx][1]\np = k // freq\nrsa = circle_score[-1][0] + fscorea * p\nrsb = circle_score[-1][1] + fscoreb * p\nr = k % freq\n\nwhile r > 0:\n    x_, y_ = score_of(x, y)\n    rsa += x_\n    rsb += y_\n    x, y = A[x][y], B[x][y]\n    r -= 1\nprint(\"{} {}\".format(rsa, rsb))\n", "completed={}\n\nalice=[[0,-1,1],[1,0,-1],[-1,1,0]]\nbob=[[0,1,-1],[-1,0,1],[1,-1,0]]\n\ndef simulate(i):\n\n\tnonlocal s,a,b,l,m,completed\n\tif(str(a)+\" \"+str(b) in completed):\n\t\treturn \n\ts.append(alice[a-1][b-1])\n\ttemp1 = a\n\ttemp2 = b\n\tcompleted[str(a)+\" \"+str(b)]=i\n\ta = l[temp1-1][temp2-1]\n\tb = m[temp1-1][temp2-1]\n\tsimulate(i+1)\n\n\nk,a,b = list(map(int, input().split()))\nl=[]\nfor i in range(3):\n\tl.append(list(map(int,input().split())))\nm=[]\nfor i in range(3):\n\tm.append(list(map(int,input().split())))\n\ns=[]\nali=0\nbo=0\nsimulate(0)\nfor i in range(completed[str(a)+\" \"+str(b)]):\n\tif(k==0):\n\t\tbreak\n\tk-=1\n\tif(s[i]==1):\n\t\tali+=1\n\telif(s[i] == -1):\n\t\tbo+=1\ns=s[completed[str(a)+\" \"+str(b)]:]\nawins = s.count(1)\nbwins = s.count(-1)\nmul = k//len(s)\nrem = k%len(s)\nali+=mul*awins\nbo+=mul*bwins\nfor i in range(rem):\n\tif(s[i]==1):\n\t\tali+=1\n\telif(s[i]==-1):\n\t\tbo+=1\nprint(ali,bo)", "k, a, b = list(map(int, input().split()))\nA = [list(map(int, input().split())) for _ in range(3)]\nB = [list(map(int, input().split())) for _ in range(3)]\nwina = winb = ca = cb = 0\nls = [(0, 0)]\ndic = {}\npre = k\ncycle = k\nfor i in range(k):\n    if (a - b + 3) % 3 == 1:\n        wina += 1\n    elif (a - b + 3) % 3 == 2:\n        winb += 1\n    ls.append((wina, winb))\n    if (a, b) in dic:\n        pre = dic[(a, b)]\n        cycle = i - pre\n        ca = wina - ls[pre + 1][0]\n        cb = winb - ls[pre + 1][1]\n        break\n    dic[(a, b)] = i\n    (a, b) = (A[a - 1][b - 1], B[a - 1][b - 1])\nwina = ls[(k - pre) % cycle + pre][0] + ca * ((k - pre) // cycle)\nwinb = ls[(k - pre) % cycle + pre][1] + cb * ((k - pre) // cycle)\nprint(\"%d %d\" % (wina, winb))\n", "def solve():\n\n    point123 = {(1, 1):None, (1, 2):\"Bob\", (1, 3):\"Alice\",\n                (2, 1):\"Alice\", (2, 2):None, (2, 3):\"Bob\",\n                (3, 1):\"Bob\", (3, 2):\"Alice\", (3, 3):None}\n    map123 = {} # (a, b): (nexta, nextb)\n    cycle123 = {} # (a, b): (cyclelen, Alicegain, Bobgain)\n\n    k, a, b = [int(st) for st in input().split(\" \")]\n    A = [None, None, None, None]\n    B = [None, None, None, None]\n\n    for i in range(1, 4):\n        A[i] = [None] + [int(st) for st in input().split(\" \")]\n    for i in range(1, 4):\n        B[i] = [None] + [int(st) for st in input().split(\" \")]\n\n    for i in range(1, 4):\n        for j in range(1, 4):\n            map123[(i, j)] = (A[i][j], B[i][j])\n\n    for i in range(1, 4):\n        for j in range(1, 4):\n            cycle = 1\n            again, bgain = int(point123[(i, j)] == \"Alice\"), int(point123[(i, j)] == \"Bob\")\n            i1, j1 = map123[(i, j)]\n            while cycle < 10 and not (i1 == i and j1 == j):\n                cycle += 1\n                again += int(point123[(i1, j1)] == \"Alice\")\n                bgain += int(point123[(i1, j1)] == \"Bob\")\n                i1, j1 = map123[(i1, j1)]\n                \n            if cycle < 10:\n                cycle123[(i, j)] = (cycle, again, bgain)\n\n    #print(\"Map\", map123, \"\\nCycle\", cycle123)\n\n    ansA, ansB = 0, 0\n    while k>0:\n        \n        if (a, b) in cycle123:\n            if k % cycle123[(a, b)][0] == 0:\n                ansA += cycle123[(a, b)][1] * k//cycle123[(a, b)][0]\n                ansB += cycle123[(a, b)][2] * k//cycle123[(a, b)][0]\n                return ansA, ansB\n        \n        k -= 1\n        ansA += int(point123[(a, b)] == \"Alice\")\n        ansB += int(point123[(a, b)] == \"Bob\")\n        a, b = map123[(a, b)]\n\n    return ansA, ansB\n\nansa, ansb = solve()\nprint(ansa, ansb)\n", "#!/usr/bin/env python3\n# encoding: utf-8\n\n\n\n#----------\n# Constants\n#----------\n\n\n\n#----------\n# Functions\n#----------\n\n# Reads a string from stdin, splits it by space chars, converts each\n# substring to int, adds it to a list and returns the list as a result.\ndef get_ints():\n    return [ int(n) for n in input().split() ]\n\n\ndef move(matrix, a, b):\n    return matrix[a][b]\n\n\ndef game(a, b):\n    res = (a - b) % 3\n    if res == 1:\n        return (1, 0)\n    elif res == 2:\n        return (0, 1)\n    else:\n        return (0, 0)\n\n\n#----------\n# Execution start point\n#----------\n\ndef __starting_point():\n    z = get_ints()\n    assert len(z) == 3\n    k, a, b = z[0], z[1]-1, z[2]-1\n\n    alice = list()\n    for i in range(3):\n        z = get_ints()\n        assert len(z) == 3\n        for j in range(len(z)):\n            z[j] -= 1\n        alice.append(z.copy())\n\n    bob = list()\n    for i in range(3):\n        z = get_ints()\n        assert len(z) == 3\n        for j in range(len(z)):\n            z[j] -= 1\n        bob.append(z.copy())\n\n    moves = list()\n    results = list()\n    index = -1\n    for m in range(k):\n        if (a, b) in moves:\n            index = moves.index((a, b))\n            break\n        moves.append((a, b))\n        results.append(game(a, b))\n        a, b = move(alice, a, b), move(bob, a, b)\n\n    # periods\n    apoint, bpoint = 0, 0\n    c = len(moves) - index\n    rep = (k - index) // c\n    for res in results[index:]:\n        da, db = res\n        apoint += da\n        bpoint += db\n    apoint *= rep\n    bpoint *= rep\n\n    # after\n    rem = (k - index) % c\n    for i in range(rem):\n        da, db = results[i + index]\n        apoint += da\n        bpoint += db\n\n    # before\n    for res in results[:index]:\n        da, db = res\n        apoint += da\n        bpoint += db\n\n    print(apoint, bpoint)\n\n__starting_point()", "k, a, b = [int(i) for i in input().split()]\nal = [[int(i) for i in input().split()] for j in range(3)]\nbb = [[int(i) for i in input().split()] for j in range(3)]\nd, sa, sb, cr = dict(), 0, 0, 0\nmat = [[(0, 0), (0, 1), (1, 0)],\n       [(1, 0), (0, 0), (0, 1)],\n       [(0, 1), (1, 0), (0, 0)]]\n\nwhile cr < k:\n    if (a, b) in list(d.keys()):\n        break\n    cr += 1\n    d[(a, b)] = (sa, sb, cr)\n    sc = mat[a - 1][b - 1]\n    sa += sc[0]\n    sb += sc[1]\n    a, b = al[a - 1][b - 1], bb[a - 1][b - 1]\n\nif cr == k:\n    print(sa, sb)\n    return\n\nln = cr - d[(a, b)][2] + 1\nadda = sa - d[(a, b)][0]\naddb = sb - d[(a, b)][1]\nleft = k - cr\ncn = left // ln\nsa += cn * adda\nsb += cn * addb\ncr += ln * cn\n\nwhile cr < k:\n    cr += 1\n    sc = mat[a - 1][b - 1]\n    sa += sc[0]\n    sb += sc[1]\n    a, b = al[a - 1][b - 1], bb[a - 1][b - 1]\n\nprint(sa, sb)\n", "ka, kb = 0, 0\n\ndef g(a, b):\n    nonlocal ka, kb\n    if a == b:\n        return\n    if abs(a - b) == 2:\n        if a == 1:\n            ka += 1\n        else:\n            kb += 1\n    else:\n        if a > b:\n            ka += 1\n        else:\n            kb += 1\n\ndef main():\n    nonlocal ka, kb\n    k, a, b = list(map(int, input().split()))\n    aa = [[] for i in [1, 1, 1]]\n    bb = [[] for i in [1, 1, 1]]\n    aa[0] = list(map(int, input().split()))\n    aa[1] = list(map(int, input().split()))\n    aa[2] = list(map(int, input().split()))\n    bb[0] = list(map(int, input().split()))\n    bb[1] = list(map(int, input().split()))\n    bb[2] = list(map(int, input().split()))\n    x = a\n    y = b\n    o = 1\n    c = [[x, y]]\n    d = [[0, 0]]\n    g(x, y)\n    if k == 1:\n        return\n    x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]\n    #print(x, y, ka, kb)\n    while [x, y] not in c:\n        o += 1\n        c += [[x, y]]\n        d += [[ka, kb]]\n        g(x, y)\n        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]\n        #print(x, y, ka, kb)\n        if o == k:\n            return\n    ind = c.index([x, y])\n    dka = ka - d[ind][0]\n    dkb = kb - d[ind][1]\n    delta = o - ind\n    kk = (k - ind) // delta - 1\n    #print(dka, dkb, delta)\n    ka += kk * dka\n    kb += kk * dkb\n    o += kk * delta\n    while o != k:\n        o += 1\n        g(x, y)\n        x, y = aa[x - 1][y - 1], bb[x - 1][y - 1]\n        #print(x, y, ka, kb)\n\nmain()\nprint(ka, kb)\n", "from functools import reduce\n\ndef get_scores(a, b):\n    if a == b:\n        return (0, 0)\n    elif (a, b) in ((2, 1), (1, 0), (0, 2)):\n        return (1, 0)\n    else:\n        return (0, 1)\n\ndef add(t1, t2):\n    return tuple(map(sum, list(zip(t1, t2))))\n\ndef mul(t, x):\n    return t[0] * x, t[1] * x\n\nk, a, b = list(map(int, input().split(' ')))\n\nalice_ts = {}\nbob_ts = {}\n\nfor ts in (alice_ts, bob_ts):\n    for i in range(3):\n        xs = list(map(int, input().split(' ')))[::-1]\n\n        for j in range(3):\n            ts[(i, j)] = xs.pop() - 1\n\nstate = (a - 1, b - 1)\n\nresult = (0, 0)\n\nlog = {}\nstep_results = []\n\nstart, end = None, None\n\nfor i in range(k):\n    if state in log:\n        start = log[state]\n        end = i\n\n        break\n\n    current_res = get_scores(*state)\n\n    result = add(result, current_res)\n\n    log[state] = i\n    step_results.append(current_res)\n\n    if end is not None:\n        break\n\n    state = alice_ts[state], bob_ts[state]\n\nif end is not None:\n    cycle_sum = reduce(add, step_results[start:end])\n\n    total_cycle_sum = mul(cycle_sum, (k - end) // (end - start))\n\n    result = add(result, total_cycle_sum)\n\n    for i in range(0, (k - end) % (end - start)):\n        result = add(result, step_results[start + i])\n\nprint(result[0], result[1])\n", "R=lambda:list(map(int,input().split()))\nk,a,b=R()\na-=1\nb-=1\nA=[list(R()) for _ in range(3)]\nB=[list(R()) for _ in range(3)]\nf=[[None]*3 for _ in range(3)]\ns=[[0,0]]\ni=0\nwhile i<k and f[a][b] is None:\n    f[a][b]=i\n    s.append(list(s[i]))\n    i+=1\n    d=a-b\n    if d<0:\n        d+=3\n    if d:\n        s[i][d-1]+=1\n    a,b=A[a][b]-1,B[a][b]-1\nif i==k:\n    print(*s[i])\nelse:\n    cb=f[a][b]\n    c=i-cb\n    m=(k-i)//c\n    sa,sb=s[i]\n    sa+=m*(sa-s[cb][0])+s[cb+(k-i)%c][0] - s[cb][0]\n    sb+=m*(sb-s[cb][1])+s[cb+(k-i)%c][1] - s[cb][1]\n    print(sa,sb)\n", "R=lambda:list(map(int,input().split()))\nk,a,b=R()\na-=1\nb-=1\nA=[list(R()) for _ in range(3)]\nB=[list(R()) for _ in range(3)]\nf=[[None]*3 for _ in range(3)]\ns=[[0,0]]\ni=0\nwhile i<k and f[a][b] is None:\n    f[a][b]=i\n    s.append(list(s[i]))\n    i+=1\n    d=a-b\n    if d<0:\n        d+=3\n    if d:\n        s[i][d-1]+=1\n    a,b=A[a][b]-1,B[a][b]-1\nif i==k:\n    print(*s[i])\nelse:\n    cb=f[a][b]\n    c=i-cb\n    m=(k-i)//c\n    sa,sb=s[i]\n    sr=s[cb+(k-i)%c]\n    sa+=m*(sa-s[cb][0])+sr[0]-s[cb][0]\n    sb+=m*(sb-s[cb][1])+sr[1]-s[cb][1]\n    print(sa,sb)\n", "R=lambda:list(map(int,input().split()))\nk,a,b=R()\na-=1\nb-=1\nA=[list(R()) for _ in range(3)]\nB=[list(R()) for _ in range(3)]\nf=[[None]*3 for _ in range(3)]\ns=[[0,0]]\ni=0\nwhile i<k and f[a][b] is None:\n    f[a][b]=i\n    s.append(list(s[i]))\n    i+=1\n    d=a-b\n    if d<0:\n        d+=3\n    if d:\n        s[i][d-1]+=1\n    a,b=A[a][b]-1,B[a][b]-1\nif i==k:\n    print(*s[i])\nelse:\n    j=f[a][b]\n    z=list(zip(s[i],s[j],s[j+(k-i)%(i-j)]))\n    print(*[((k-i)//(i-j)+1)*(x[0]-x[1])+x[2] for x in z])\n", "R=lambda:list(map(int,input().split()))\nk,a,b=R()\na-=1\nb-=1\nA=[list(R()) for _ in range(3)]\nB=[list(R()) for _ in range(3)]\nf=[[None]*3 for _ in range(3)]\ns=[[0,0]]\ni=0\nwhile i<k and f[a][b] is None:\n    f[a][b]=i\n    s.append(list(s[i]))\n    i+=1\n    d=a-b\n    if d<0:\n        d+=3\n    if d:\n        s[i][d-1]+=1\n    a,b=A[a][b]-1,B[a][b]-1\nif i==k:\n    print(*s[i])\nelse:\n    j=f[a][b]\n    c,d=divmod(k-i,i-j)\n    z=list(zip(s[i],s[j],s[j+d]))\n    print(*[(c+1)*(x[0]-x[1])+x[2] for x in z])\n", "class Player:\n  __slots__ = ['choices']\n\n  def __init__(self, choices):\n    self.choices = choices\n\n  def choose_next(self, row, col):\n    return self.choices[row - 1][col - 1]\n\n  def round_score(own, other):\n    if own == other + 1 or (own == 1 and other == 3):\n      return 1\n    return 0\n\nclass State:\n  __slots__ = ['score_a', 'score_b', 'time']\n\n  def __init__(self, a, b, time):\n    self.score_a = a\n    self.score_b = b\n    self.time = time\n\n\ndef read_player():\n  choices = [list(map(int, input().split())) for i in range(3)]\n  return Player(choices)\n\ndef play(rounds, pa, a, pb, b):\n  memo = {}\n  score = [0, 0]\n  cacat = False\n\n  for i in range(rounds):\n    pair = (a, b)\n    if pair in memo:\n      cycle_len = (i - memo[pair].time)\n      cycles = (rounds - i) // cycle_len\n\n      score_a = score[0] - memo[pair].score_a\n      score_b = score[1] - memo[pair].score_b\n\n      score[0] += score_a * cycles\n      score[1] += score_b * cycles\n      rounds -= i + cycles * cycle_len\n      cacat = True\n      break\n    else:\n      memo[pair] = State(score[0], score[1], i)\n\n    score[0] += Player.round_score(a, b)\n    score[1] += Player.round_score(b, a)\n    a, b = pa.choose_next(a, b), pb.choose_next(a, b)\n\n  if cacat:\n    for i in range(rounds):\n      score[0] += Player.round_score(a, b)\n      score[1] += Player.round_score(b, a)\n      a, b = pa.choose_next(a, b), pb.choose_next(a, b)\n\n  return score\n\ndef main():\n  rounds, a, b = list(map(int, input().split()))\n  pa = read_player()\n  pb = read_player()\n\n  score = play(rounds, pa, a, pb, b)\n  print(score[0], score[1])\n\nmain()\n", "R=lambda:list(map(int,input().split()))\nk,a,b=R()\na-=1\nb-=1\nA=[list(R()) for _ in range(3)]\nB=[list(R()) for _ in range(3)]\nf=[[None]*3 for _ in range(3)]\ns=[[0,0]]\ni=0\nwhile i<k and f[a][b] is None:\n    f[a][b]=i\n    s.append(list(s[i]))\n    i+=1\n    d=a-b\n    if d<0:\n        d+=3\n    if d:\n        s[i][d-1]+=1\n    a,b=A[a][b]-1,B[a][b]-1\nif i==k:\n    print(*s[i])\nelse:\n    j=f[a][b]\n    m,n=divmod(k-i,i-j)\n    print(*[(m+1)*(x[0]-x[1])+x[2] for x in zip(s[i],s[j],s[j+n])])\n", "R=lambda:list(map(int,input().split()))\nk,a,b=R()\na-=1\nb-=1\nA=[list(R()) for _ in range(3)]\nB=[list(R()) for _ in range(3)]\nf=[[None]*3 for _ in range(3)]\ns=[[0,0]]\ni=0\nwhile i<k and f[a][b] is None:\n    f[a][b]=i;s.append(list(s[i]));i+=1;d=a-b\n    if d<0:d+=3\n    if d:s[i][d-1]+=1\n    a,b=A[a][b]-1,B[a][b]-1\nif i==k:print(*s[i])\nelse:\n    j=f[a][b];m,n=divmod(k-i,i-j)\n    print(*[(m+1)*(x[0]-x[1])+x[2] for x in zip(s[i],s[j],s[j+n])])\n", "def read(): return list(map(int, input().split(' ')))\nk, a, b = read()\nA = [read() for _ in range(3)]\nB = [read() for _ in range(3)]\n\nra, rb = 0, 0\n\nskipped = False\npos = { (a, b): 0 }\nscoreA = { (a, b): 0 }\nscoreB = { (a, b): 0 }\nif (b - a) % 3 == 1:\n    rb = 1\n    #scoreB[(a, b)] = rb\nelif (b - a) % 3 == 2:\n    ra = 1\n    #scoreA[(a, b)] = ra\n\ni = 1\nwhile i < k:\n    na = A[a-1][b-1]\n    nb = B[a-1][b-1]\n    #print('game:', na, nb)\n\n    if (na, nb) in pos and not skipped:\n        cycleLen = i - pos[(na, nb)]\n        cycleScoreA = ra - scoreA[(na, nb)]\n        cycleScoreB = rb - scoreB[(na, nb)]\n\n        skipCycles = (k - i) // cycleLen\n        #print('Skip:', cycleLen, cycleScoreA, cycleScoreB, skipCycles)\n        ra += cycleScoreA * skipCycles\n        rb += cycleScoreB * skipCycles\n        i += skipCycles * cycleLen\n\n        skipped = True\n    else:\n        scoreA[(na, nb)] = ra\n        scoreB[(na, nb)] = rb\n        pos[(na, nb)] = i\n\n        if (nb - na) % 3 == 1:\n            rb += 1\n            #print(i, '+b', ra, rb)\n        elif (nb - na) % 3 == 2:\n            ra += 1\n            #print(i, '+a', ra, rb)\n        \n        i += 1\n        a, b = na, nb\n\n#print('Answer')\nprint(ra, rb)\n#print('ScoreA')\n#print(scoreA)\n#print('ScoreB')\n#print(scoreB)\n#print('pos')\n#print(pos)\n", "f = lambda: list(map(int, input().split()))\ng = lambda: [[0] * 4] + [[0] + f() for i in range(3)]\nh = lambda x, y: x - 1 == y % 3\nt = lambda a, b, u, v: (A[a][b], B[a][b], u + h(a, b), v + h(b, a))\nk, a, b = f()\np = 2520\ns, d = k // p, k % p\nif s: s, d = s - 1, d + p\nA, B = g(), g()\nu = v = x = y = 0\nfor j in range(d): a, b, u, v = t(a, b, u, v)\nfor i in range(p): a, b, x, y = t(a, b, x, y)\nprint(u + x * s, v + y * s)", "import sys\n\ndef log(s):\n#    print(s)\n    pass\n\nk, a, b = list(map(int, sys.stdin.readline().strip().split(' ')))\nalice = {}\nfor i in range(3):\n    one, two, three = list(map(int, sys.stdin.readline().strip().split(' ')))\n    alice[(i + 1, 1)] = one\n    alice[(i + 1, 2)] = two\n    alice[(i + 1, 3)] = three\n\nbob = {}\nfor i in range(3):\n    one, two, three = list(map(int, sys.stdin.readline().strip().split(' ')))\n    bob[(i + 1, 1)] = one\n    bob[(i + 1, 2)] = two\n    bob[(i + 1, 3)] = three\n\nscore = {(1, 1): (0, 0), (2, 2): (0, 0), (3, 3): (0, 0),\n        (1, 2): (0, +1), (2, 3): (0, +1), (3, 1): (0, 1),\n        (2, 1): (1, 0), (3, 2): (1, 0), (1, 3): (1, 0)}\n\nseen = []\ncurrent = (a, b)\nwhile current not in seen:\n    seen.append(current)\n    current = (alice[current], bob[current])\n\nloop = seen.index(current)\nvals = [score[state] for state in seen] \n\na_point, b_point = (0, 0)\na_vals, b_vals = list(zip(*vals))\na_point += sum(a_vals[:min(k, loop)])\nb_point += sum(b_vals[:min(k, loop)])\n\nk = k - loop\nloop_len = len(seen) - loop\na_loop_val = sum(a_vals[loop:])\nb_loop_val = sum(b_vals[loop:])\nif k >= 0:\n    tail = k % loop_len\n    num_iters = k // loop_len\n    a_point += sum(a_vals[loop:loop+tail])\n    b_point += sum(b_vals[loop:loop+tail])\n    a_point += num_iters * a_loop_val\n    b_point += num_iters * b_loop_val\n\n\nlog(a_point)\nlog(b_point)\nprint(round(a_point), round(b_point))\n\n", "#educational round 29\n#two robots play N rounds of game 1 2 3. each choose a number from 1 2 or 3\n#game rule 3 win 2, 2 win 1, 1 win against 3\n#player choose next number from previous move of both players.\n#input format\n#line 1:     N a b - N round of games, a b is the number of first round from alice and bob\n#line 2 - 4: 3 x 3 grid Aij is next number of Alice if previous A=i, B=j\n#line 5 - 7: 3 x 3 grid Bij is next number of Bob if previous A=i, B=j\n#output format\n#total points of Alice and Bob\nclass Game123:\n    def __init__(self):\n        self.alice = [0]*9\n        self.bob=[0]*9\n        self.moves=[-1]*10\n        self.count=0\n        self.pointsA=0\n        self.pointsB=0\n\n    #convert 3x3 grid into 1D array\n    def gameChoice(self, m, r, bBob):\n        choice=self.alice\n        if bBob:\n            choice=self.bob\n        for i in range(len(m)):\n            choice[3*r+i]=m[i]\n\n    #look if move already exists\n    def findMove(self, a, b):\n        m=(a-1)*3+b-1\n        for i in range(self.count):\n            if self.moves[i]==m:\n                return i\n        #print(\"a={0} b={1} m={2} count={3}\".format(a,b,m, self.count))\n        self.moves[self.count]=m\n        self.count += 1\n        return -1\n\n    def computePoints(self, m):\n        #convert m back to a and b, m is  from 0 to 8\n        b=m%3+1\n        a=m//3+1\n        #return positive if alice win\n        if a==b:\n            return\n        if a==3 and b==2 or a==2 and b==1 or a==1 and b==3:\n            self.pointsA += 1\n        else:\n            self.pointsB += 1\n\n    def output(self):\n        print(\"{0} {1}\".format(self.pointsA,self.pointsB))    \n        \n    def startGame(self, a, b, totalmoves):\n        #print(self.moves)\n        #print(self.alice)\n        #print(self.bob)\n        found=-1\n        while found<0:\n            found=self.findMove(a,b)\n            m=(a-1)*3+b-1\n            a=self.alice[m]  #next move\n            b=self.bob[m]\n        #print(\"repeat {0} to {1}\".format(found, self.count))\n        pointaA=0\n        pointsB=0\n        # compute moves of no repeats\n        if totalmoves <= self.count:\n            for i in range(totalmoves):\n                self.computePoints(self.moves[i])\n        else:\n            totalmoves -= found\n            repeats = totalmoves//(self.count-found)\n            totalmoves %= (self.count-found)\n            for i in range(found, self.count): #repeated moves\n                self.computePoints(self.moves[i])\n            #self.output()\n            self.pointsA *= repeats\n            self.pointsB *= repeats\n            #self.output()\n            for i in range(found): #moves before repeat\n                self.computePoints(self.moves[i])\n            #self.output()\n            for i in range(found, totalmoves+found): #odd moves after repeat\n                self.computePoints(self.moves[i])\n        self.output()\n\n    def test():\n        g=Game123()\n        g.gameChoice([2,2,1],0,False)\n        g.gameChoice([3,3,1],1,False)\n        g.gameChoice([3,1,3],2,False)\n        g.gameChoice([1,1,1],0,True)\n        g.gameChoice([2,1,1],1,True)\n        g.gameChoice([1,2,3],2,True)\n        g.startGame(1,1,8)\n\ndef nia():\n    s=input()\n    while len(s)==0:\n        s=input()\n    s=s.split()\n    iVal=[];\n    for i in range (len(s)):\n        iVal.append(int(s[i]))\n    return iVal\n\ndef solve():\n    g=Game123()\n    nab=nia()\n    for i in range(3):\n        g.gameChoice(nia(), i, False)\n    for i in range(3):\n        g.gameChoice(nia(), i, True)\n    g.startGame(nab[1],nab[2],nab[0])\n    \nsolve()  \n", "from decimal import *\n#print(getcontext())\nContext(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])\ngetcontext().prec = 25\n\nk, a, b = [int(i) for i in input().split(\" \")]\nA = []\nB = []\nap = 0\nbp = 0\nac = a\nbc = b\nah = []\nbh = []\nsh = []\nalert = 0\nfor i in range(3):\n    A.append(input())\nfor i in range(3):\n    B.append(input())\n\ndef Alice_choice(i,j):\n    return int((A[i-1])[2*j-2])\n\ndef Bob_choice(i,j):\n    return int((B[i-1])[2*j-2])\n\nif ac == bc + 1 or ac == bc - 2:\n    ap += 1\n    ah.append(ac)\n    bh.append(bc)\n    sh.append(1)\nelif bc == ac + 1 or bc == ac - 2:\n    bp += 1\n    ah.append(ac)\n    bh.append(bc)\n    sh.append(-1)\nelse:\n    ah.append(ac)\n    bh.append(bc)\n    sh.append(0)\nq = 0\nr = 0\nfor q in range(k-1):\n    temp_a = Alice_choice(ac,bc)\n    temp_b = Bob_choice(ac,bc)\n    ac = temp_a\n    bc = temp_b\n    if ac == bc + 1 or ac == bc - 2:\n        ap += 1\n        ah.append(ac)\n        bh.append(bc)\n        sh.append(1)\n    elif bc == ac + 1 or bc == ac - 2:\n        bp += 1\n        ah.append(ac)\n        bh.append(bc)\n        sh.append(-1)\n    else:\n        ah.append(ac)\n        bh.append(bc)\n        sh.append(0)\n    for r in range(q + 1):\n        if ac == ah[r] and bc == bh[r]:\n            alert = 1\n            break\n    if alert == 1:\n        break\nq += 1\nperiod = q - r\nscore_pp = sh[r+1:q+1]\nend = (k - len(sh)) % period\nrepeat = Decimal(k - len(sh) - end) / period\naadd = 0\nbadd = 0\nfor i in score_pp:\n    if i == 1:\n        aadd += 1\n    elif i == -1:\n        badd += 1\nap += aadd*repeat\nbp += badd*repeat\nfor i in score_pp[:end]:\n    if i == 1:\n        ap += 1\n    elif i == -1:\n        bp += 1\n\nprint(ap, end = ' ')\nprint(bp)\n\n# print(ah)\n# print(bh)\n# print(sh)\n# print(r,q)\n# print(score_pp)\n# print(period)\n# print(end)\n# print(repeat)\n# print(aadd,badd)\n\n# Time Limit Exceeded #", "def readints():\n    return [int(item) for item in input().strip().split()]\n\n\ndef cmp(a, b):\n    return {\n        1: {1: (0, 0), 2: (0, 1), 3: (1, 0)},\n        2: {1: (1, 0), 2: (0, 0), 3: (0, 1)},\n        3: {1: (0, 1), 2: (1, 0), 3: (0, 0)}\n    }[a][b]\n\n\nclass Solver:\n    def main(self):\n        n, a, b = readints()\n        A = [0, [0] + readints(), [0] + readints(), [0] + readints()]\n        B = [0, [0] + readints(), [0] + readints(), [0] + readints()]\n\n        current = (a, b)\n        results = [current]\n\n        while True:\n            current = (A[current[0]][current[1]], B[current[0]][current[1]])\n            if current not in results:\n                results.append(current)\n            else:\n                break\n\n        first_cycle = results.index(current)\n        totals = 0, 0\n        for i in range(first_cycle):\n            res = cmp(*results[i])\n            totals = totals[0] + res[0], totals[1] + res[1]\n            n -= 1\n            if n == 0:\n                break\n\n        cycled = len(results) - first_cycle\n        if n > 0:\n            multi = n // cycled\n            for i in range(first_cycle, len(results)):\n                res = cmp(*results[i])\n                totals = totals[0] + multi * res[0], totals[1] + multi * res[1]\n\n            for i in range(n % cycled):\n                res = cmp(*results[i + first_cycle])\n                totals = totals[0] + res[0], totals[1] + res[1]\n\n        print('{} {}'.format(*totals))\n\n\nSolver().main()\n", "k,a,b = list(map(int, input().split()))\nA = []\nB = []\nsa , sb = 0,0\nr = {\n    (1,1):(0,0),\n    (1,2):(0,1),\n    (1,3):(1,0),\n    (2,1):(1,0),\n    (2,2):(0,0),\n    (2,3):(0,1),\n    (3,1):(0,1),\n    (3,2):(1,0),\n    (3,3):(0,0),\n}\n\np = {}\n\nfor _ in range(3):\n    A.append(list(map(int, input().split())))\nfor _ in range(3):\n    B.append(list(map(int, input().split())))\ni = 0\nwhile (i<k):\n\n    if (a,b) in p:\n        j, psa, psb = p[(a,b)]\n        l = i-j\n        psa = sa-psa\n        psb = sb-psb\n        rep = (k-i)//l\n        sa += psa*rep\n        sb += psb*rep\n        i+=l*rep\n        break;\n    else:\n        p[(a,b)] = (i,sa,sb)\n\n    t = r[(a,b)]\n    sa+=t[0]\n    sb+=t[1]\n    a,b = A[a-1][b-1], B[a-1][b-1]\n    i+=1\n\nwhile (i<k):\n\n    t = r[(a,b)]\n    sa+=t[0]\n    sb+=t[1]\n    a,b = A[a-1][b-1], B[a-1][b-1]\n    i+=1\n\nprint(sa,sb)\n\n\n", "def winner(q, r):\n    if q == r:\n        return 'd'\n    if q == 0 and r == 2:\n        return 'a'\n    if r == 0 and q == 2:\n        return 'b'\n    if q > r:\n        return 'a'\n    return 'b'\n\n\nk, a, b = [int(x) - 1 for x in input().split()]\nA = [[int(x) - 1 for x in input().split()] for y in range(3)]\nB = [[int(x) - 1 for x in input().split()] for z in range(3)]\nscore = {'a': 0, 'b': 0, 'd': 0}\nscore[winner(a, b)] += 1\nd = {(a, b): 0}\ni = 1\nj = -1\n\nwhile k:\n    na = A[a][b]\n    nb = B[a][b]\n    if (na, nb) in list(d.keys()):\n        j = d[(na, nb)]\n        break\n    else:\n        d[(na, nb)] = i\n        score[winner(na, nb)] += 1\n        a = na\n        b = nb\n    i += 1\n    k -= 1\n\nif j == -1:\n    print(score['a'], score['b'])\n    return\n\nperiod = {'a': 0, 'b': 0, 'd': 0}\nend_score = {'a': 0, 'b': 0, 'd': 0}\n\nrem = k % (i - j)\nper = k // (i - j)\n\nfor move in d:\n    if d[move] < j:\n        continue\n    if d[move] < j + rem:\n        end_score[winner(move[0], move[1])] += 1\n    period[winner(move[0], move[1])] += 1\n\nfor win in ['a', 'b', 'd']:\n    score[win] += end_score[win] + per * period[win]\n\n# print('rem:', rem, 'per:', per, 'period:', period, 'end score:', end_score)\n\nprint(score['a'], score['b'])\n"]