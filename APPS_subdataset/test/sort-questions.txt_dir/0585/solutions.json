["import sys\ninput = sys.stdin.readline\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nmod=998244353\nsol=1\ni=n-1\nj=m-1\nwhile sol>0 and j>=0:\n    goal=b[j]\n    s=0\n    r=False\n    while i>=0 and a[i]>=goal:\n        if r:\n            s+=1\n        else:\n            if a[i]==goal:\n                r=True\n                s=1\n        i-=1\n    if j==0:\n        s=min(s,1)\n        if i>=0:\n            s=0\n    sol*=s\n    sol%=mod\n    j-=1\nprint(sol)", "n, m = list(map(int, input().split()))\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nMOD = 998244353\n\nout = 1\n\nfirst = -1\ncurr = m - 1\n\nfor i in range(n - 1, -1 ,-1):\n    while a[i] < b[curr]:\n        if first > -1:\n            out *= (first - i)\n            out %= MOD\n        else:\n            out = 0\n        first = -1\n        curr -= 1\n        \n        if curr < 0:\n            out = 0\n            break\n    if a[i] == b[curr] and first == -1:\n        first = i\n\nif curr == 0 and first != -1:\n    print(out)\nelse:\n    print(0)\n", "n,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\nM=[a[i] for i in range(n)]\nfor i in range(n-2,-1,-1):\n    M[i]=min(M[i],M[i+1])\n\nres=1\nmod=998244353\nval=b[m-1]\nid=n-1\ncount=m-1\nl,r=-1,-1\nwhile count and id>-1:\n    if M[id]>val:\n        id-=1\n    elif M[id]==val:\n        if r==-1:\n            r=id\n        id-=1\n    elif val>M[id]:\n        l=id+1\n        res*=max((r-l+1),0)\n        res%=mod\n        count-=1\n        r=-1\n        l=-1\n        val=b[count]\n\nif count:\n    res=0\n    print(res)\nelse:\n    check=min(a[i] for i in range(id+1))\n    if check==b[0]:\n        print(res)\n    else:\n        print(0)", "MOD = 998244353\nn, m = list(map(int, input().split()))\nd = dict()\na = [0] + list(map(int, input().split()))\nb = list(map(int, input().split()))\nfor i in range(m):\n    d[b[i]] = i\nc = [-1] * m\nfor i, x in enumerate(a):\n    if x in d:\n        c[d[x]] = i\nidx = n\nans = 1\nfor i in range(m - 1, -1, -1):\n    while b[i] <= a[idx]:\n        idx -= 1\n    if c[i] <= idx:\n        print(0)\n        return\n    if i > 0:\n        ans *= c[i] - idx\n    elif idx > 0:\n        print(0)\n        return\n    ans %= MOD\nprint(ans)\n", "from collections import defaultdict as dd\nfrom collections import deque\nimport bisect\nimport heapq\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(map(int, input().split()))\n\n\ndef solve():\n    n, m = rl()\n    A = rl()\n    B = rl()\n    mod = 998244353\n    if A[0] < B[0]:\n        print(0)\n        return\n\n    # ptr = len(B) - 1\n    # streak = 0\n    # answer = 1\n    # _min = A[-1]\n    # for a in A[::-1]:\n        # _min = min(_min, a)\n        # if _min == B[ptr]:\n            # streak += 1\n        # elif _min < B[ptr]:\n            # ptr -= 1\n            # if _min < B[ptr]:\n                # print (0)\n                # return\n    mins = dd(int)\n    _min = A[-1]\n    for a in A[::-1]:\n        _min = min(_min, a)\n        mins[_min] += 1\n\n    if _min != B[0]:\n        print(0)\n        return\n\n    answer = 1\n    for b in B[1:]:\n        if mins[b] == 0:\n            print(0)\n            return\n        else:\n            answer = (answer * mins[b]) % mod\n\n    print (answer)\n\n\n\n\n\n\nmode = 'S'\n\nif mode == 'T':\n    t = ri()\n    for i in range(t):\n        solve()\nelse:\n    solve()\n", "import sys\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nlast=[]\ni=n-1\nj=m-1\nMOD=998244353\nfailflag=0\nwhile j>=0 and i>=0:\n    r=b[j]\n    while i>=0:\n        if a[i]==r:\n            last.append(i)\n            break\n        if a[i]<r:\n            failflag=1\n            break\n        i-=1\n    if i<0:\n        break\n    j-=1\nlast.reverse()\nif len(last)!=m:\n    print(0)\n    return\nfor i in range(last[0]):\n    if a[i]<b[0]:\n        failflag=1\nif failflag==1:\n    print(0)\n    return\nans=1\nfor i in range(1,m):\n    for j in range(last[i],last[i-1]-1,-1):\n        if a[j]<b[i]:\n            break\n    ans=((last[i]-j)*ans)%MOD\nprint(ans)", "import sys\n# import math\n# from collections import deque\n# import heapq\n# from math import inf\n# from math import gcd\n\n# print(help(deque))\n# 26\npprint = lambda s: print(' '.join(map(str, s)))\ninput = lambda: sys.stdin.readline().strip()\nipnut = input\n# n,m = map(int, input().split())\n# n = int(input())\n#\nn,m = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nmod = 998244353\nsuf_min = [(10000000000,-1)]\na_r = list(reversed(a))\nfor i in range(n):\n    if a_r[i]<suf_min[-1][0]:\n        suf_min.append((a_r[i],n-i-1))\n    else:\n        suf_min.append(suf_min[-1])\nsuf_min.reverse()\n\nif suf_min[0][0]!=b[0]:\n    print(0)\n    return\nans = 1\ndef bin(a):\n    l = 0\n    r = n+1\n    while r-l>1:\n        m = (r+l)//2\n        if suf_min[m][0]>a:\n            r = m\n        else:\n            l = m\n    return l\nfor k in range(m-1):\n    j= bin(b[k+1])\n    if suf_min[j][0]!=b[k+1]:\n        print(0)\n        return\n    ans = (ans*(suf_min[j][1]-suf_min[bin(b[k+1]-1)][1]))%mod\nprint(ans)\n"]