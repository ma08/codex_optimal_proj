["import sys\ninput = sys.stdin.readline\n\nn=int(input())\nP=[list(map(int,input().split())) for i in range(n-1)]\n\n\nGroup=[i for i in range(n+1)]\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\nANS=[[i] for i in range(n+1)]\n\nfor i,j in P:\n    if find(j)<find(i):\n        ANS[find(j)]+=ANS[find(i)]\n        \n    else:\n        ANS[find(i)]+=ANS[find(j)]\n\n    Union(i,j)\n\nfor a in ANS[1]:\n    print(a,end=\" \")\n        \n\n", "n = int(input())\n# 2<=n<=150.000\nimport heapq\nfrom collections import defaultdict\ngraph = defaultdict(set)\nfor x in range(n-1):\n    a,b = map(int,input().split())\n    graph[a].add((x,b))\n    graph[b].add((x,a))\n#heapq.heapify(a)\n\norder = []\nseen = set()\nstart = 1\nq = list(graph[start])\nheapq.heapify(q)\nwhile q:\n    t, node = heapq.heappop(q)\n    if node in seen:continue\n    seen.add(node)\n    order.append(node)\n    for neighbor in graph[node]:\n        heapq.heappush(q,neighbor)\nprint (*order)", "# -*- coding: utf-8 -*-\n# @Time    : 2019/2/23 19:02\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : F. Asya And Kittens.py\n\n\nclass UnionFind(object):\n\n    def __init__(self, n):\n        self.root = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n        self.data = [[i] for i in range(n)]\n\n    def find(self, x):\n        if self.root[x] == x:\n            return x\n\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x == y:\n            return False\n        if self.size[x] < self.size[y]:\n            x, y = y, x\n        self.root[y] = x\n        self.size[x] += self.size[y]\n        self.data[x].extend(self.data[y])\n\n\ndef main():\n    n = int(input())\n    uf = UnionFind(n + 1)\n    for _ in range(n - 1):\n        x, y = list(map(int, input().split()))\n        # print(x, y)\n        uf.union(x, y)\n    x = uf.find(1)\n    print(*uf.data[x])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\nreadline = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\nN = int(readline())\n\n*p, = range(N)\nxs = [0]*N\nsz = [1]*N\ndef root(x):\n    if x == p[x]:\n        return x\n    z = p[x]\n    p[x] = y = root(p[x])\n    xs[x] += xs[z]\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px == py:\n        return\n    if px < py:\n        p[py] = px\n        xs[py] = sz[px]\n        sz[px] += sz[py]\n    else:\n        p[px] = py\n        xs[px] = sz[py]\n        sz[py] += sz[px]\n\nfor i in range(N-1):\n    x, y = map(int, readline().split())\n    unite(x-1, y-1)\ncur = 0\nds = [0]*N\nfor i in range(N):\n    root(i)\n    if xs[i] == 0:\n        ds[i] = cur\n        cur += sz[i]\nans = [0]*N\nfor i in range(N):\n    ans[xs[i] + ds[root(i)]] = i+1\nprint(*ans)", "\nn = int(input())\n\narr = []\n\nfor i in range(n-1):\n    arr.append(list(map(int,input().strip().split())))\nmp = {}\n\nans = []\n#print(arr)\nfor i in range(n-1):\n    a = arr[i][0]\n    b = arr[i][1]\n\n    if (a not in mp) and (b not in mp):\n        mp[a] = len(ans)\n        mp[b] = len(ans)\n        ans.append([a,b])\n    else:\n        if (a in mp) and (b not in mp):\n            ans[mp[a]].append(b)\n            mp[b]= mp[a]\n        else:\n            if (a not in mp) and (b in mp):\n                ans[mp[b]].append(a)\n                mp[a] = mp[b]\n            else:\n                ans[mp[a]].extend(ans[mp[b]])\n                for x in ans[mp[b]]:\n                    mp[x] = mp[a]\nfor i in range(len(ans)):\n    if len(ans[i])==n:\n        print(*ans[i])\n        break\n\n\n\n\n\n\n\n\n\n\n", "n=int(input())\nd={}\nfor i in range(n-1):\n    a,b=list(map(int,input().split()))\n    if (a not in list(d.keys())) and (b not in list(d.keys())):\n        d[a]=[a,b]\n        d[b]=d[a]\n    elif (a in list(d.keys())) and (b not in list(d.keys())):\n        d[a]+=[b]\n        d[b]=d[a]\n    elif (a not in list(d.keys())) and (b in list(d.keys())):\n        d[b]+=[a]\n        d[a]=d[b]\n    else:\n        d[a]+=d[b]\n        for j in d[b]:\n            d[j]=d[a]\nprint(*d[1])\n", "n = int(input())\n\nd = dict()\n\ndef ppp(d):\n    for k, v in list(d.items()):\n        print(k, \":\", v.s, \":\", id(v))\n\n    print(\"-----\")\n\nclass A:\n    def __init__(self):\n        self.s = []\n\nfor _ in range(n-1):\n    a, b = list(map(int, input().split()))\n    if a not in d and b not in d:\n        #print(\"x1\")\n        t = A()\n        t.s.append(a)\n        t.s.append(b)\n        d[a] = t\n        d[b] = t\n    elif a in d and b not in d:\n        #print(\"x2\")\n        d[a].s.append(b)\n        d[b] = d[a]\n    elif a not in d and b in d:\n        #print(\"x3\")\n        d[b].s.append(a)\n        d[a] = d[b]\n    else:\n        #print(\"x4\")\n        d[a].s.extend(d[b].s)\n        for x in d[b].s:\n            d[x] = d[a]\n    #ppp(d)\n\nprint(*d[1].s)\n\n", "class UnionFind(object):\n    __slots__ = [\"nodes\"]\n\n    def __init__(self, n: int) -> None:\n        self.nodes = [-1]*n\n\n    def get_root(self, x: int) -> int:\n        if self.nodes[x] < 0:\n            return x\n        else:\n            self.nodes[x] = self.get_root(self.nodes[x])\n            return self.nodes[x]\n\n    def unite(self, x: int, y: int) -> None:\n        root_x, root_y = self.get_root(x), self.get_root(y)\n        if root_x != root_y:\n            bigroot, smallroot = \\\n                (root_x, root_y) if self.nodes[root_x] < self.nodes[root_y] else (root_y, root_x)\n            self.nodes[bigroot] += self.nodes[smallroot]\n            self.nodes[smallroot] = bigroot\n\n\ndef __starting_point():\n    import sys\n    n = int(input())\n    queries = [tuple(map(int, l.split())) for l in sys.stdin]\n    uf = UnionFind(n+1)\n    get_root, unite = uf.get_root, uf.unite\n    groups = {}\n\n    for x, y in queries:\n        x_root, y_root = get_root(x), get_root(y)\n        if x_root not in groups:\n            groups[x_root] = [x]\n        if y_root not in groups:\n            groups[y_root] = [y]\n        unite(x, y)\n        if x_root == get_root(x):\n            groups[x_root].extend(groups[y_root])\n        else:\n            groups[y_root].extend(groups[x_root])\n\n    print(*groups[get_root(1)])\n__starting_point()", "\"\"\"\n5\n1 4\n2 5\n3 1\n4 5\n\"\"\"\n\nn = int(input())\n\n\nd = dict()\npoint = dict()\nl = []\nfor _ in range(n-1):\n    l += [list(map(int, input().split()))]\n\n\ndef get_point(nn):\n    i = nn\n    while not point[i] == i:\n        i = point[i]\n    return i\n\n\nfor pair in l:\n    p0 = pair[0] in list(point.keys())\n    p1 = pair[1] in list(point.keys())\n    if not (p0 or p1):\n        point[pair[1]] = pair[0]\n        point[pair[0]] = pair[0]\n        d[pair[0]] = [pair[0], pair[1]]\n    elif p0 and not p1:\n        pp = get_point(pair[0])\n        d[pp] += [pair[1]]\n        point[pair[1]] = pp\n    elif p1 and not p0:\n        pp = get_point(pair[1])\n        d[pp] += [pair[0]]\n        point[pair[0]] = pp\n    else:\n        pp1 = get_point(pair[1])\n        pp0 = get_point(pair[0])\n        d[pp0] += d[pp1]\n        point[pp1] = pp0\n\nprint(' '.join(map(str, d[get_point(1)])))\n\n", "# -*- coding: utf-8 -*-\n# @Date    : 2019-02-23 15:15:00\n# @Author  : raj lath (oorja.halt@gmail.com)\n# @Link    : link\n# @Version : 1.0.0\n\nfrom sys import stdin\n\nmax_val=int(10e12)\nmin_val=int(-10e12)\n\ndef read_int()     : return int(stdin.readline())\ndef read_ints()    : return [int(x) for x in stdin.readline().split()]\ndef read_str()     : return input()\ndef read_strs()    : return [x for x in stdin.readline().split()]\n\nimport heapq\nfrom collections import defaultdict\nn = int(input())\ngraph = defaultdict(set)\nfor x in range(n - 1):\n    a, b = [int(x) for x in input().split()]\n    graph[a].add((x, b))\n    graph[b].add((x, a))\n\norder = []\nseen  = set()\nbegin = 1\nq = list(graph[begin])\nheapq.heapify(q)\nwhile q:\n    t, node = heapq.heappop(q)\n    if node in seen:continue\n    seen.add(node)\n    order.append(node)\n    for neighbor in graph[node]:\n        heapq.heappush(q,neighbor)\nprint(*order)\n\n", "n = int(input())\n\nparent = [i for i in range(n+1)]\ngroup = [[i] for i in range(n+1)]\n\nfor i in range(n-1):\n    x, y = list(map(int, input().split()))\n    if len(group[parent[x]]) < len(group[parent[y]]):\n        x, y = y, x\n    group[parent[x]] += group[parent[y]]\n    for j in group[parent[y]]:\n        parent[j] = parent[x]\n\nprint(*group[parent[1]])\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n + 1)]\n        self.rank = [0 for _ in range(n + 1)]\n        self.size = [1] * (n + 1)\n        self.group = [[i] for i in range(n + 1)]\n\n    def find(self, x):\n        # If x is root\n        if self.parent[x] == x:\n            return x\n        # If x is not root, search again by using x's parent\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        # Make an edge from the root of lower tree to the root of higher tree\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.parent[y] = x\n            self.size[x] += self.size[y]\n            # If the height of tree the tree is the same, increase one of the heights by 1\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def merge(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if len(self.group[x]) < len(self.group[y]):\n            x, y = y, x\n        self.group[x].extend(self.group[y])\n        self.group[y] = []\n        self.parent[y] = x\n\n    def check_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        return self.size[self.find(x)]\n\n\nN = int(input())\nitems = []\nfor i in range(N - 1):\n    items.append(tuple(map(int, input().split())))\n\nunion_find = UnionFind(N)\n\nfor a, b in items:\n    union_find.merge(a, b)\nans = union_find.group[union_find.find(1)]\nprint(*ans)\n", "class UnionFind:\n    def __init__(self, n):\n        self.parent = [i for i in range(n + 1)]\n        self.rank = [0 for _ in range(n + 1)]\n        self.size = [1] * (n + 1)\n        self.group = [[i] for i in range(n + 1)]\n\n    def find(self, x):\n        # If x is root\n        if self.parent[x] == x:\n            return x\n        # If x is not root, search again by using x's parent\n        else:\n            self.parent[x] = self.find(self.parent[x])\n            return self.parent[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        # Make an edge from the root of lower tree to the root of higher tree\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.parent[y] = x\n            self.size[x] += self.size[y]\n            # If the height of tree the tree is the same, increase one of the heights by 1\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def merge(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if len(self.group[x]) < len(self.group[y]):\n            x, y = y, x\n        self.group[x].extend(self.group[y])\n        self.group[y] = []\n        self.parent[y] = x\n\n    def check_same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        return self.size[self.find(x)]\n\n\nN = int(input())\nitems = []\nfor i in range(N - 1):\n    items.append(tuple(map(int, input().split())))\n\nunion_find = UnionFind(N)\n\nfor a, b in items:\n    union_find.merge(a, b)\nans = union_find.group[union_find.find(1)]\nprint(*ans)\n", "n = int(input())\nparent = [i for i in range(n)]\nkitten = {}\ndef root(i):\n    if parent[i] == i:\n        return i\n    else:\n        parent[i] = root(parent[i])\n        return parent[i]\ndef union(a, b):\n    roota = root(a)\n    rootb = root(b)\n    if roota not in kitten:\n        kitten[roota] = [roota]\n    if rootb not in kitten:\n        kitten[rootb] = [rootb]\n    if len(kitten[roota]) >= len(kitten[rootb]):\n        parent[rootb] = roota\n        kitten[roota] += kitten[rootb]\n        del kitten[rootb]\n    else:\n        parent[roota] = rootb\n        kitten[rootb] += kitten[roota]\n        del kitten[roota]\nfor i in range(n-1):\n    x, y = [int(s)-1 for s in input().split(' ')]\n    union(x, y)\nprint(\" \".join([str(i+1) for i in kitten[root(x)]]))", "n = int(input())\np = list(range(n + 1))\nc = [[i] for i in range(n + 1)]\nfor _ in range(n - 1):\n    x, y = map(int, input().split())\n    x, y = p[x], p[y]\n    if len(c[x]) < len(c[y]):\n        x, y = y, x\n    c[x] += c[y]\n    for z in c[y]:\n        p[z] = x\nprint(*c[p[1]])", "n = int(input())\n\nclass Leader(object):\n    def __init__(self, value):\n        self.array = [value]\n\ndef union(v1, v2):\n    leader = v1 if len(dsets[v1].array) >= len(dsets[v2].array) else v2\n    antileader = v1 if leader == v2 else v2\n\n    dsets[leader].array.extend(dsets[antileader].array)\n\n    for v in dsets[antileader].array:\n        dsets[v] = dsets[leader]\n\ndsets = [Leader(i) for i in range(n)]\n\nfor _ in range(n-1):\n    v1, v2 = [int(t) - 1 for t in input().split(' ')]\n    union(v1, v2)\n\nprint(' '.join(str(t+1) for t in dsets[0].array))\n", "n = int(input())\n\n# \u8981\u7d20i\u306e\u89aa\uff08\u30de\u30fc\u30b8\u5148\uff09\u3092\u6307\u3059\nparent = [i for i in range(n+1)]\n\n# \u5404\u8981\u7d20\u3092\u3053\u3053\u306b\u30de\u30fc\u30b8\u3057\u3066\u3044\u304f\ngroup = [[i] for i in range(n+1)]\n\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    # x\u306e\u30de\u30fc\u30b8\u5148\u306e\u914d\u5217\u306e\u8981\u7d20\u6570 >= y\u306e\u30de\u30fc\u30b8\u5148\u306e\u914d\u5217\u306e\u8981\u7d20\u6570\u3068\u306a\u308b\u3088\u3046\u306bx\u3068y\u3092\u5165\u308c\u66ff\u3048\u308b\uff08\u30de\u30fc\u30b8\u30c6\u30af\u306e\u524d\u51e6\u7406\uff09\n    if len(group[parent[x]]) < len(group[parent[y]]):\n        x, y = y, x\n    \n    # \u8981\u7d20\u6570\u304c\u5927\u304d\u3044\u65b9\u3078\u30de\u30fc\u30b8\u3059\u308b\uff08\u30de\u30fc\u30b8\u30c6\u30af\uff09\n    group[parent[x]] += group[parent[y]]\n    \n    # \u30de\u30fc\u30b8\u3055\u308c\u305f\u5404\u8981\u7d20\u306e\u89aa\uff08\u30de\u30fc\u30b8\u5148\uff09\u306e\u60c5\u5831\u3092\u66f4\u65b0\u3059\u308b\n    for j in group[parent[y]]:\n        parent[j] = parent[x]\n\nprint(*group[parent[1]])", "n = int(input())\n\n# \u8981\u7d20i\u306e\u89aa\uff08\u30de\u30fc\u30b8\u5148\uff09\u3092\u6307\u3059\nparent = [i for i in range(n+1)]\n\n# \u5404\u8981\u7d20\u3092\u3053\u3053\u306b\u30de\u30fc\u30b8\u3057\u3066\u3044\u304f\ngroup = [[i] for i in range(n+1)]\n\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    \n    # x\u306e\u30de\u30fc\u30b8\u5148\u306e\u914d\u5217\u306e\u8981\u7d20\u6570 >= y\u306e\u30de\u30fc\u30b8\u5148\u306e\u914d\u5217\u306e\u8981\u7d20\u6570\u3068\u306a\u308b\u3088\u3046\u306bx\u3068y\u3092\u5165\u308c\u66ff\u3048\u308b\uff08\u30de\u30fc\u30b8\u30c6\u30af\u306e\u524d\u51e6\u7406\uff09\n    if len(group[parent[x]]) < len(group[parent[y]]):\n        x, y = y, x\n\n    # \u8981\u7d20\u6570\u304c\u5927\u304d\u3044\u65b9\u3078\u30de\u30fc\u30b8\u3059\u308b\uff08\u30de\u30fc\u30b8\u30c6\u30af\uff09\n    group[parent[x]] += group[parent[y]]\n\n    # \u30de\u30fc\u30b8\u3055\u308c\u305f\u5404\u8981\u7d20\u306e\u89aa\uff08\u30de\u30fc\u30b8\u5148\uff09\u306e\u60c5\u5831\u3092\u66f4\u65b0\u3059\u308b\n    for j in group[parent[y]]:\n        parent[j] = parent[x]\n\nprint(*group[parent[1]])", "N = int(input())\nP = [i for i in range(N)]\nG = [[i] for i in range(N)]\nfor i in range(N - 1):\n    x, y = map(int, input().split())\n    x, y = x - 1, y - 1\n    x = P[x]\n    y = P[y]\n    if len(G[x]) < len(G[y]):\n        x, y = y, x\n\n    G[x] += G[y]\n    for k in G[y]:\n        P[k] = x\n\nprint(\" \".join(map(lambda x: str(x + 1), G[P[0]])))", "class DisjointSets:\n    parent = {}\n    rank = {}\n    ls = {}\n\n    def __init__(self, n):\n        for i in range(1, n + 1):\n            self.makeSet(i)\n\n    def makeSet(self, node):\n        self.node = node\n        self.parent[node] = node\n        self.rank[node] = 1\n        self.ls[node] = [node]\n\n    def find(self, node):\n        curnode = node\n        parent = self.parent\n\n        while parent[curnode] != curnode:\n            curnode = parent[curnode]\n\n        root = curnode\n        curnode = node\n\n        while parent[curnode] != root:\n            parent[curnode] = root\n\n        return root\n\n    def union(self, node, other):\n        node = self.find(node)\n        other = self.find(other)\n        if self.rank[node] > self.rank[other]:\n            self.parent[other] = node\n            self.ls[node].extend(self.ls[other])\n\n        elif self.rank[other] > self.rank[node]:\n            self.parent[node] = other\n            self.ls[other].extend(self.ls[node])\n\n        else:\n            self.parent[other] = node\n            self.ls[node] += self.ls[other]\n            self.rank[node] += 1\n\n\nn = int(input())\n\nds = DisjointSets(n)\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    ds.union(a, b)\n# print(ds.rank)\n# print(ds.parent)\nans = ds.ls[ds.find(1)]\nfor a in ans:\n    print(a, end=\" \")\n", "class DisjointSets:\n    parent = {}\n    rank = {}\n    ls = {}\n\n    def __init__(self, n):\n        for i in range(1, n + 1):\n            self.makeSet(i)\n\n    def makeSet(self, node):\n        self.node = node\n        self.parent[node] = node\n        self.rank[node] = 1\n        self.ls[node] = [node]\n\n    def find(self, node):\n        parent = self.parent\n        if parent[node] != node:\n            parent[node] = self.find(parent[node])\n        return parent[node]\n\n    def union(self, node, other):\n        node = self.find(node)\n        other = self.find(other)\n        rank = self.rank\n        parent = self.parent\n        ls = self.ls\n\n        if rank[node] > rank[other]:\n            parent[other] = node\n            ls[node].extend(ls[other])\n\n        elif rank[other] > rank[node]:\n            parent[node] = other\n            ls[other].extend(ls[node])\n\n        else:\n            parent[other] = node\n            ls[node] += ls[other]\n            rank[node] += 1\n\n\nn = int(input())\n\nds = DisjointSets(n)\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    ds.union(a, b)\n# print(ds.rank)\n# print(ds.parent)\nans = ds.ls[ds.find(1)]\nfor a in ans:\n    print(a, end=\" \")\n"]