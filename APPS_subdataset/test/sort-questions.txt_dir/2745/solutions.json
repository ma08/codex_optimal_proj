["class Solution(object):\n     def findSubstring(self, s, words):\n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         if not s or words==[]:\n             return []\n         lenstr=len(s)\n         lenword=len(words[0])\n         lensubstr=len(words)*lenword\n         times={}\n         for word in words:\n             if word in times:\n                 times[word]+=1\n             else:\n                 times[word]=1\n         ans=[]\n         for i in range(min(lenword,lenstr-lensubstr+1)):\n             self.findAnswer(i,lenstr,lenword,lensubstr,s,times,ans)\n         return ans\n     def findAnswer(self,strstart,lenstr,lenword,lensubstr,s,times,ans):\n         wordstart=strstart\n         curr={}\n         while strstart+lensubstr<=lenstr:\n             word=s[wordstart:wordstart+lenword]\n             wordstart+=lenword\n             if word not in times:\n                 strstart=wordstart\n                 curr.clear()\n             else:\n                 if word in curr:\n                     curr[word]+=1\n                 else:\n                     curr[word]=1\n                 while curr[word]>times[word]:\n                     curr[s[strstart:strstart+lenword]]-=1\n                     strstart+=lenword\n                 if wordstart-strstart==lensubstr:\n                     ans.append(strstart)", "class Solution:\n     def findSubstring(self, s, words):\n         if not s or not words: return []\n         lens, lenw, numw = len(s), len(words[0]), len(words)\n         res = []\n         end = lens // lenw * lenw\n         \n         for i in range(lenw):\n             start = sidx = i\n             record = words[:]\n             while sidx < end:              \n                 tmp_sidx = sidx + lenw\n                 tmp_word = s[sidx: tmp_sidx]\n                 \n                 if tmp_word in words:\n                     if tmp_word in record:\n                         record.remove(tmp_word)\n                     elif s[start: start + lenw] != tmp_word:\n                         sidx = start = start + lenw\n                         record = words[:]\n                         continue\n                     else:\n                         start = start + lenw\n                 elif lens - tmp_sidx < lenw * numw:\n                     break\n                 else:\n                     record = words[:]\n                     start = tmp_sidx\n                     \n                 if not record: res.append(start)\n                 sidx = tmp_sidx  \n                 \n         return res\n", "class Solution:\n     def findSubstring(self, s, words):\n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         result = []\n         lenWord = len(words[0])\n         numOfWords = len(words)\n         lenSubstring = lenWord * numOfWords\n         dic = {}\n         \n         for word in words:\n             if word in dic:\n                 dic[word] += 1\n             else:\n                 dic[word] = 1\n         \n         for i in range(min(lenWord, len(s) - lenSubstring + 1)):\n             curr = {}\n             strStart = i\n             wordStart = strStart\n             while strStart + lenSubstring <= len(s):\n                 word = s[wordStart: wordStart + lenWord]\n                 wordStart += lenWord\n                 if word not in dic:\n                     strStart = wordStart\n                     curr.clear()\n                 else:\n                     if word in curr:\n                         curr[word] += 1\n                     else:\n                         curr[word] = 1\n                     while curr[word] > dic[word]:\n                         curr[s[strStart: strStart + lenWord]] -= 1\n                         strStart += lenWord\n                     if wordStart - strStart == lenSubstring:\n                         result.append(strStart)\n         return result\n", "from collections import Counter\n from copy import deepcopy\n class Solution:\n     def findSubstring(self, s, words):\n         if not s or not words:\n             return []\n         \n         wordCounter = Counter(words)\n         longest = len(words[0])\n         lenSubStr = longest * len(words)\n         n = len(s)\n \n         idx = []\n         for i in range(0, longest):\n             cnt = {}\n             j = i\n             start = i\n             while start + lenSubStr <= n:\n                 word = s[j:j+longest]\n                 j += longest\n                 if word not in wordCounter:\n                     start = j\n                     cnt.clear()\n                 else:\n                     if word in cnt:\n                         cnt[word] += 1\n                     else:\n                         cnt[word] = 1\n                         \n                     while cnt[word] > wordCounter[word]:\n                         cnt[s[start: start + longest]] -= 1\n                         start += longest\n                         \n                     if j - start == lenSubStr:\n                         idx.append(start)\n \n         return idx\n                     \n                 \n                 \n         \n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         ", "class Solution:\n     def findSubstring(self, s, words):\n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         result = []\n         lenWord = len(words[0])\n         numOfWords = len(words)\n         lenSubstring = lenWord * numOfWords\n         dic = {}\n         for word in words:\n             if word in dic:\n                 dic[word] += 1\n             else:\n                 dic[word] = 1\n         for i in range(min(lenWord, len(s)-lenSubstring+1)):\n             curr = {}\n             strStart = i\n             wordStart = strStart\n             while strStart + lenSubstring <= len(s):\n                 word = s[wordStart: wordStart+lenWord]\n                 wordStart += lenWord\n                 if word not in dic:\n                     strStart = wordStart\n                     curr.clear()\n                 else:\n                     if word in curr:\n                         curr[word] += 1\n                     else:\n                         curr[word] = 1\n                     while curr[word] > dic[word]:\n                         curr[s[strStart: strStart+lenWord]] -= 1\n                         strStart += lenWord\n                     if wordStart - strStart == lenSubstring:\n                         result.append(strStart)\n         return result", "class Solution:\n     def findSubstring(self, s, words):\n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         m, n, k, result, wordbase = len(s), len(words), len(words[0]), [], {}\n         for value in words:\n             if value in wordbase:\n                 wordbase[value] += 1\n             else:\n                 wordbase[value] = 1\n         for i in range(min(k, m - k * n + 1)):\n             base, starts, startw = {}, i, i\n             while starts + k * n <= m:\n                 temp = s[startw:startw + k]\n                 startw += k\n                 if temp not in wordbase:\n                     starts = startw\n                     base.clear()\n                 else:\n                     if temp in base:\n                         base[temp] += 1\n                     else:\n                         base[temp] = 1\n                     while base[temp] > wordbase[temp]:\n                         base[s[starts:starts + k]] -= 1\n                         starts += k\n                     if startw - starts == k * n:\n                         result.append(starts)\n         return result", "class Solution:\n     def findSubstring(self, s, words):\n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         lword = len(words[0])\n         n = len(words)\n         lwords = n * lword\n         if not s or not lwords:\n             return\n         \n         res = []\n         dic = {} \n         for key in words:\n             dic[key] = [0, 0]\n         for key in words:\n             dic[key][1] += 1\n         for k in range(lword):\n             i = k\n             while i <= len(s)-lwords:\n                 if not s[i:i+lword] in list(dic.keys()):\n                     i += lword\n                     continue\n                 j = 0\n                 start = i\n                 while s[i:i+lword] in list(dic.keys()) and i<len(s):\n                     key = s[i:i+lword]\n                     dic[key][0] += 1\n                     while dic[key][0] > dic[key][1]:\n                         dic[s[start:start+lword]][0] -= 1\n                         j -= 1\n                         start += lword\n                     j += 1\n                     i += lword\n                     if j==n:\n                         res.append(start)\n                         dic[s[start:start+lword]][0] -= 1\n                         j -= 1\n                         start += lword\n                 for key in list(dic.keys()):\n                     dic[key][0] = 0\n         return res\n", "class Solution(object):\n     def findSubstring(self, s, words):\n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         if not s or not words or not words[0]:\n             return []\n         n = len(s)\n         k = len(words[0])\n         t = len(words) * k\n         req = {}\n         for w in words:\n             req[w] = req[w] + 1 if w in req else 1\n         ans = []\n         for i in range(min(k, n - t + 1)):\n             self._findSubstring(i, i, n, k, t, s, req, ans)\n         return ans\n         \n     def _findSubstring(self, l, r, n, k, t, s, req, ans):\n         curr = {}\n         while r + k <= n:\n             w = s[r:r + k]\n             r += k\n             if w not in req:\n                 l = r\n                 curr.clear()\n             else:\n                 curr[w] = curr[w] + 1 if w in curr else 1\n                 while curr[w] > req[w]:\n                     curr[s[l:l + k]] -= 1\n                     l += k\n                 if r - l == t:\n                     ans.append(l)", "class Solution:\n     def findSubstring(self, s, words):\n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         L = len(s)\n         length = len(words[0])\n         Length = length * len(words)\n         result = []\n         word_dict = {}\n         for word in words:\n             word_dict[word] = word_dict[word]+1 if word in word_dict else 1\n         for i in range(length):\n             l = i\n             r = i\n             curr_dict={}\n             while r+length<=L:\n                 word  = s[r:r+length]\n                 r = r+length\n                 if word in word_dict:\n                     curr_dict[word] = curr_dict[word]+1 if word in curr_dict else 1\n                     while curr_dict[word] > word_dict[word]:\n                         curr_dict[s[l:l+length]] -=1\n                         l += length\n                     if r-l==Length:\n                         result.append(l)\n                 else:\n                     curr_dict.clear()\n                     l = r\n             \n         return result\n \n", "from collections import Counter\n from copy import deepcopy\n class Solution:\n     def findSubstring(self, s, words):\n         if not s or not words:\n             return []\n         \n         wordCounter = Counter(words)\n         longest = len(words[0])\n         lenSubStr = longest * len(words)\n         n = len(s)\n \n         idx = []\n         for i in range(0, min(longest, n - lenSubStr + 1)):\n             if i in idx:\n                 continue\n             cnt = {}\n             j = i\n             start = i\n             while start + lenSubStr <= n:\n                 word = s[j:j+longest]\n                 j += longest\n                 if word not in wordCounter:\n                     start = j\n                     cnt.clear()\n                 else:\n                     if word in cnt:\n                         cnt[word] += 1\n                     else:\n                         cnt[word] = 1\n                         \n                     while cnt[word] > wordCounter[word]:\n                         cnt[s[start: start + longest]] -= 1\n                         start += longest\n                         \n                     if j - start == lenSubStr:\n                         idx.append(start)\n \n         return list(idx)\n                     \n                 \n                 \n         \n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         ", "class Solution:\n     def findSubstring(self, s, words):\n         if not words:\n             return []\n         word_len = len(words[0])\n         word_set = {}\n         for word in words:\n             word_set[word] = word_set.get(word, 0) + 1\n         scopes = [([], {}) for _ in range(word_len)]\n         results = []\n         for i in range(len(s)):\n             word = s[i:i + word_len]\n             if word in word_set:\n                 matched_queue, matched_counts = scopes[i % word_len]\n                 while matched_counts.get(word, 0) >= word_set[word]:\n                     matched_counts[matched_queue.pop(0)] -= 1\n                 matched_queue.append(word)\n                 matched_counts[word] = matched_counts.get(word, 0) + 1\n                 if len(matched_queue) == len(words):\n                     results.append(i - word_len * len(words) + word_len)\n                     matched_counts[matched_queue.pop(0)] -= 1\n             else:\n                 scopes[i % word_len] = ([], {})\n         return results", "class Solution(object):\n     def findSubstring(self, s, words):\n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         if not s or not words: return []\n         result, sLen, numW, wLen = [], len(s), len(words), len(words[0])\n         if sLen < numW*wLen: return []\n         dic = collections.defaultdict(int)\n         for i in words:\n             dic[i] += 1\n         for i in range(wLen):\n             left, count = i, 0\n             tmp = collections.defaultdict(int)\n             for j in range(i, sLen-wLen+1, wLen):\n                 s1 = s[j:j+wLen]\n                 if s1 in dic:\n                     tmp[s1] += 1\n                     if tmp[s1] <= dic[s1]: \n                         count += 1\n                     else:\n                         while tmp[s1] > dic[s1]:\n                             s2 = s[left:left+wLen]\n                             tmp[s2] -= 1\n                             if tmp[s2] < dic[s2]:\n                                 count -= 1\n                             left += wLen\n                     if count == numW:\n                         result.append(left)\n                         tmp[s[left:left+wLen]] -= 1\n                         count -= 1\n                         left += wLen\n                 else:\n                     tmp, count, left = collections.defaultdict(int), 0, j+wLen\n         return result\n", "class Solution:\n     def findSubstring(self, s, words):\n         \"\"\"\n         :type s: str\n         :type words: List[str]\n         :rtype: List[int]\n         \"\"\"\n         hash = {}\n         res = []\n         wsize = len(words[0])\n         \n         for str in words:\n             if str in hash:\n                 hash[str] += 1\n             else:\n                 hash[str] = 1\n         for start in range(0, len(words[0])):\n             slidingWindow = {}\n             wCount = 0\n             for i in range(start, len(s), wsize):\n                 word = s[i : i + wsize]\n                 if word in hash:\n                     if word in slidingWindow:\n                         slidingWindow[word] += 1\n                     else:\n                         slidingWindow[word] = 1\n                     wCount += 1\n                     while hash[word] < slidingWindow[word]:\n                         pos = i - wsize * (wCount - 1)\n                         removeWord = s[pos : pos + wsize]\n                         #print i, removeWord\n                         slidingWindow[removeWord] -= 1\n                         wCount -= 1\n                 else:\n                     slidingWindow.clear()\n                     wCount = 0\n                 if wCount == len(words):\n                     res.append(i - wsize * (wCount - 1))\n                     \n         return res"]