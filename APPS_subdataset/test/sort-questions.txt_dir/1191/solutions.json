["n,m = map(int, input().split())\n\nclass Knight:\n\tdef __init__(self, andis, p, c):\n\t\tself.p = int(p)\n\t\tself.c = int(c)\n\t\tself.andis = int(andis)\n\t\tself.ans = self.c\n\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nx = []\nfor i in range(n):\n\tx.append(Knight(i, p[i], c[i]))\n\nx.sort(key=lambda x: x.p)\ncoins = []\nfor i in range(n-1):\n\tif len(coins) < m:\n\t\tcoins.append(x[i].c)\n\t\tcoins.sort()\n\telif len(coins) > 0:\n\t\tif coins[0] < x[i].c:\n\t\t\tcoins[0] = x[i].c\n\t\t\tcoins.sort()\n\tx[i+1].ans += sum(coins)\n\nx.sort(key=lambda x:x.andis)\nfor k in x:\n\tprint(k.ans, end=' ')\n\t\n\n\n\n", "_, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nb = [int(x) for x in input().split()]\nc = list(sorted(zip(a, b, list(range(len(b))))))\nd = [0] * len(b)\n\nif k == 0:\n    print(' '.join(map(str, b)))\nelse:\n    best = [0] * k\n    for pwr, cnt, index in c:\n        d[index] = sum(best) + cnt\n\n        if cnt > best[0]:\n            for i in range(len(best)):\n                if cnt <= best[i]:\n                    best.insert(i, cnt)\n                    best = best[1:]\n                    break\n            else:\n                best = best[1:] + [cnt]\n\n\n    print(' '.join(map(str, d)))\n", "from math import ceil, log\nfrom heapq import heappop, heappush, heapify\nt = 1\nfor test in range(t):\n    n,k = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    arr = [i for i in sorted(enumerate(p), key=lambda x:x[1])]\n    maxcoins = [0 for i in range(k)]\n    heapify(maxcoins)\n    ans = list(p)\n    tmpSum = 0\n    tmpSum2 = 0\n    prev = arr[0][1]\n    for ind, power in arr:\n        if power>prev:\n            ans[ind] = tmpSum+c[ind]\n            tmpSum2 = tmpSum\n        else:\n            ans[ind] = tmpSum2+c[ind]\n        heappush(maxcoins, c[ind])\n        tmpSum+=c[ind]\n        tmpSum-=heappop(maxcoins)\n    print(*ans)\n\n\n\n\n    \n\n", "#!/usr/bin/env python3\n\nfrom heapq import heappop, heappush\n\n[n, k] = list(map(int, input().strip().split()))\npis = list(map(int, input().strip().split()))\ncis = list(map(int, input().strip().split()))\n\nres = [0 for _ in range(n)]\nnis = list(range(n))\nnis.sort(key=lambda i: pis[i])\n\nhc = []\nl = 0\nsc = 0\n\nfor i in nis:\n\tsc += cis[i]\n\tres[i] = sc\n\theappush(hc, cis[i])\n\tif l == k:\n\t\tsc -= heappop(hc)\n\telse:\n\t\tl += 1\n\nprint(' '.join(map(str, res)))\n", "n, k = [int(a) for a in input().split()]\npower = [int(a) for a in input().split()]\ncoins = [int(a) for a in input().split()]\n\ndp = [0 for i in range(n)]\n\n\ndef takeSecond(elem):\n    return elem[1]\n\n\ndef takeFirst(elem):\n    return elem[0]\n\n\npeople = [(power[i], coins[i], i) for i in range(n)]\n\npeople.sort(key=takeFirst)\n\ndp[0] = []\n\nfor i, p in enumerate(people):\n    if i == 0:\n        continue\n    kills = [i for i in dp[i - 1]]\n    kills.append(people[i - 1][1])\n    x = []\n\n    if len(kills) > k:\n        kills.remove(min(kills))\n\n    dp[i] = kills\n\nx = [(people[i][2], str(sum(dp[i]) + people[i][1])) for i in range(n)]\n\nx.sort(key=takeFirst)\n\nprint(\" \".join([z[1] for z in x]))\n", "n, k = list( map( int, input().split()))\np = list( map( int, input().split()))\nc = list( map( int, input().split()))\n\nm = {}\nfor i in range( n ):\n    if p[ i ] not in m:\n        m[ p[ i ] ] = list()\n    m[ p[ i ] ].append( c[ i ] )\n\na = {}\nt = []\nfor key, val in sorted( m.items() ):\n    a[ key ] = sum( t )\n    t += val\n    t.sort()\n    t = t[ max( 0, len( t ) - k ) : len( t ) ]\n\nprint( \" \".join( [ str( a[ p[ i ] ] + c[ i ] ) for i in range( n )]))\n", "import heapq\n\n\nn, k = list(map(int, input().strip().split()))\n\np = list(map(int, input().strip().split()))\nc = list(map(int, input().strip().split()))\n\np = sorted([(x, i) for i, x in enumerate(p)], key=lambda x: x[0])\n\nans = []\ntop_k = []\n\ncur_gold = 0\nfor i, t in enumerate(p):\n    if k == 0:\n        ans.append((c[t[1]], t[1]))\n    else:\n        if i < k:\n            cur_gold += c[t[1]]\n            ans.append((cur_gold, t[1]))\n            heapq.heappush(top_k, c[t[1]])\n        else:\n            smallest = heapq.nsmallest(1, top_k)[0]\n            if smallest < c[t[1]]:\n                cur_gold += c[t[1]]\n                ans.append((cur_gold, t[1]))\n                heapq.heappop(top_k)\n                heapq.heappush(top_k, c[t[1]])\n                cur_gold -= smallest\n            else:\n                ans.append((cur_gold + c[t[1]], t[1]))\n\nans = sorted(ans, key=lambda x: x[1])\nprint(\" \".join(map(lambda x: str(x[0]), ans)))", "import heapq\nn, k = list(map(int, input().split()))\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nindexes = sorted(list(range(n)), key=p.__getitem__)\nmost_vyg_odn_yye = []\nres = [1]*n\ncur_res = 0\nfor ind in indexes:\n\tthis_cost = c[ind]\n\theapq.heappush(most_vyg_odn_yye, this_cost)\n\tcur_res += this_cost\n\tres[ind] = cur_res\n\tif len(most_vyg_odn_yye) > k:\n\t\tcur_res -= heapq.heappop(most_vyg_odn_yye)\nprint(*res)\n", "n, k = [int(i) for i in input().split()]\npower = [int(i) for i in input().split()]\nmoney = [int(i) for i in input().split()]\n\nr = []\nfor i in range(n):\n\tr.append((power[i], money[i], i))\n\nr.sort()\ncur = 0\n\n\nans = [None for i in range(n)]\n\nfor i in range(k + 1):\n\tcur += r[i][1]\n\tans[i] = cur\n\nimport heapq\npq = []\nfor i in range(k + 1):\n\tpq.append(r[i][1])\nheapq.heapify(pq)\n\nfor i in range(k + 1, n):\n\ta = heapq.heappop(pq)\n\tans[i] = ans[i - 1] - a + r[i][1]\n\n\theapq.heappush(pq, r[i][1])\n\nend = [None for i in range(n)]\nfor i in range(n):\n\tend[r[i][2]] = ans[i]\n\nfor i in range(n):\n\tend[i] = str(end[i])\n\nprint(\" \".join(end))\n", "n, k = [int(s) for s in input().split()]\np = [int(s) for s in input().split()]\np = [(p[i], i) for i in range(n)]\n\nc = [int(s) for s in input().split()]\nc = [[c[i], i] for i in range(n)]\n\np.sort(key=lambda x: x[0], reverse=True)\n\nc_dic = {}\nfor x in c:\n    c_dic[x[1]] = x[0]\n\nc.sort(key=lambda x: x[0], reverse=True)\nans_set = {}\n\nused = set()\ni = 0\ncur_ans = 0\ncur_k = 0\nfor j in range(n):\n    x = p[j]\n    if x[1] not in used:\n        used.add(x[1])\n    else:\n        cur_k -= 1\n        cur_ans -= c_dic[x[1]]\n\n    while i < n:\n        if cur_k == k:\n            break\n        if c[i][1] in used:\n            i += 1\n            continue\n\n        cur_ans += c[i][0]\n        cur_k += 1\n        used.add(c[i][1])\n        i += 1\n    ans_set[x[1]] = cur_ans\n\nfor i in range(n):\n    print(ans_set[i] + c_dic[i], end=\" \")\n", "import operator\nclass Knight:\n    def __init__(self, power, coins, index):\n        self.power = power\n        self.coins = coins\n        self.index = index\n\nclass MaxKnight:\n    def __init__(self, coins, index):\n        self.coins = coins\n        self.index = index\nnk = input().split(\" \")\nn = int(nk[0])\nk = int(nk[1])\n\np = input().split(\" \")\nc = input().split(\" \")\nfor i in range(n):\n    p[i] = int(p[i])\n    c[i] = int(c[i])\nknights = []\nfor i in range(n):\n    kn = Knight(p[i], c[i], i)\n    knights.append(kn)\nknights.sort(key=operator.attrgetter('power'))\n\nmax_c = []\nmax_knights = []\nfor i in range(n):\n    max_knights.append(sum(max_c) + knights[i].coins)\n    if len(max_c) < k:\n        max_c.append(knights[i].coins)\n    else:\n        coins = knights[i].coins\n        try:\n            if coins > min(max_c):\n                max_c.remove(min(max_c))\n                max_c.append(coins)\n        except:\n            pass\n# print(max_knights)\nfor i in range(n):\n    max_knights[i] = MaxKnight(max_knights[i], knights[i].index)\nmax_knights.sort(key=operator.attrgetter('index'))\nprint(\" \".join(str(knight.coins) for knight in max_knights))\n", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\ns = list(map(int, input().split()))\nfor q in range(n):\n    a[q] = [a[q], s[q], q]\na.sort()\nb, d, z = [0]*k, 0, [[] for q in range(n)]\nfor q in range(n):\n    z[a[q][2]] = d+a[q][1]\n    l, j = 0, 0\n    for q1 in range(k):\n        if l == 1:\n            b[q1], j = j, b[q1]\n        elif a[q][1] > b[q1]:\n            l, j = 1, b[q1]\n            d += a[q][1] - b[-1]\n            b[q1] = a[q][1]\nprint(*z)\n", "n,k = tuple([int(x) for x in input().split(' ')])\np = list([int(x) for x in input().split(' ')])\nc = list([int(x) for x in input().split(' ')])\nout = [i for i in c]\n#t = [(p[i], c[i]) for i in range(n)]\nt = [(p[i], i) for i in range(n)]\nimport heapq\nkbest = []\n#print(t)\nt.sort()\n#print(t)\nprev = 0\ni = 0\nwhile i < len(t):\n    j = i\n    while j < len(t) and t[j][0] == t[i][0] :\n        out[t[j][1]] += sum(kbest)\n        j += 1\n    while i < j:\n        heapq.heappush(kbest, c[t[i][1]])\n        if len(kbest) > k:\n            heapq.heappop(kbest)\n        i += 1\n\"\"\"\nimport bisect\nfor i in range(n):\n    tp = (p[i], -1)\n    it = bisect.bisect_left(t, tp)\n    #print(it)\n    aux = [tup[1] for tup in t[:it]]\n    aux.sort()\n    out[i] += sum(aux[-k:])\n\"\"\"\nprint(' '.join([str(x) for x in out]))\n\n", "import heapq\n\ndef main():\n\tn, k = map(int, input().split())\n\tpower = list(map(int, input().split()))\n\tcoins = list(map(int, input().split()))\n\n\tpower_coins = sorted(zip(power, coins))\n\tresult = {power[i]:coins[i] for i in range(n)}\n\tkills = 0\n\tcoins = 0\n\tmin_heap = []\n\tfor p, c in power_coins:\n\t\tresult[p] += coins\n\t\tif kills < k:\n\t\t\tkills += 1\n\t\t\theapq.heappush(min_heap, c)\n\t\t\tcoins += c\n\t\telif k > 0:\n\t\t\tif c > min_heap[0]:\n\t\t\t\tcoins -= min_heap[0]\n\t\t\t\tcoins += c\n\t\t\t\theapq.heapreplace(min_heap, c)\n\tprint(' '.join(str(result[p]) for p in power))\n\n\nmain()", "import heapq\n\nn, k = [int(x) for x in input().strip().split()]\np = [int(x) for x in input().strip().split()]\nc = [int(x) for x in input().strip().split()]\n\na = sorted(zip(p, c, list(range(n))))\ncoins = []\ns = 0\nans = []\n\nfor ai in a:\n    s += ai[1]\n    ans.append([ai[2], s])\n    heapq.heappush(coins, ai[1])\n    if len(coins) > k:\n        s -= heapq.heappop(coins)\n\nprint(*[c for i, c in sorted(ans)])\n", "n, k = input().split(' ')\nn = int(n)\nk = int(k)\npower2 = input().split(' ')\ngold = input().split(' ')\nprof = [0] * k\nsums = dict()\ns = 0\nd = dict()\nfor i in range(n):\n    power2[i] = int(power2[i])\n    gold[i] = int(gold[i])\n    d[power2[i]] = gold[i]\npower = sorted(power2)\nfor i in range(n):\n    ind = power[i]\n    coin = d[ind]\n    for j in range(k):\n        if prof[j] >= coin:\n            sums[ind] = s + coin\n            prof.insert(j, coin)\n            s = s - prof[0] + coin\n            del prof[0]\n            break\n    else:\n        sums[ind] = s + coin\n        prof.append(coin)\n        s = s - prof[0] + coin\n        del prof[0]\nst = ''\nfor elem in power2:\n    st += str(sums[elem]) + ' '\nprint(st)", "n, k = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\ns = []\nfor i in range(n):\n\ts.append([i, p[i], c[i]])\ns.sort(key = lambda x: x[1])\ntk = 0\nm = []\nfor i in range(n):\n\tcoin = s[i][2] + sum(m)\n\ts[i].append(coin)\n\tif tk < k:\n\t\tm.append(s[i][2])\n\t\ttk += 1\n\telif len(m) > 0:\n\t\tif min(m) < s[i][2]:\n\t\t\tm.remove(min(m))\n\t\t\tm.append(s[i][2])\ns.sort()\nfor a in s:\n\tprint(a[3], end=' ')\n", "n, k = list(map(int, input().split()))\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\narr = [[p[i], i] for i in range(n)]\narr.sort()\nz = []\nans = [0 for i in range(n)]\nfor i in range(n):\n    s = 0\n    for el in z:\n        s += el\n    ans[arr[i][1]] = s + c[arr[i][1]]\n    z.append(c[arr[i][1]])\n    z.sort()\n    if len(z) > k:\n        z = z[1:]\nfor el in ans:\n    print(el, end=\" \")\n", "import array\n\nn, k = list(map(int, input().split()))\np = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\ns = []\nfor i in range(n):\n    s.append((i, p[i], c[i]))\ns = sorted(s, key=lambda x: x[1])\nsum_list = [[s[0][2]]]\nsum_res = [s[0][2]]\nfor i in range(1, n):\n    sum_list.append(list(sum_list[i-1]))\n    if i-k-1 >= 0:\n        sum_list[i].remove(min(sum_list[i]))\n    sum_list[i].append(s[i][2])\n    sum_res.append(sum(sum_list[i]))\n\nans = [str(x[1]) for x in sorted(enumerate(sum_res), key=lambda x: s[x[0]][0])]\n\nprint(\" \".join(ans))\n", "n,k=map(int,input().split())\nx=list(map(int,input().split()))\ny=list(map(int,input().split()))\nz=[x for x in range(n)]\nzz=sorted(zip(x,y,z))\npre=[]\nc=1\nf=[0]*n\nvv=0\n#print(zz)\n#print(pre)\nss=0\nfor i in range(n):\n    if(i<k):\n        pre.append(zz[i][1])\n        gh=int(zz[i][2])\n        f[gh]=ss+zz[i][1]\n        ss+=zz[i][1]\n    else:\n        pre.sort()\n        gh=int(zz[i][2])\n        f[gh]=ss+zz[i][1]\n        ff=False\n        for j in range(0,len(pre)):\n            if(zz[i][1]>pre[j]):\n                ff=True\n                ss=ss-pre[j]+zz[i][1]\n                pre[j]=zz[i][1]\n                break\nprint(*f)", "# -*- coding: utf-8 -*-\n\"\"\"\n@Project : CodeForces\n@File    : 2.py \n@Time    : 2018/6/17 0:27\n@Author  : Koushiro \n\"\"\"\n\n\ndef __starting_point():\n    n, k = map(int, input().split())\n    knight = [[i,0,0,0]for i in range(n)]\n    power = list(map(int, input().split()))\n    money = list(map(int, input().split()))\n    for i in range(n):\n        knight[i][1]=power[i]\n        knight[i][2]=money[i]\n    knight.sort(key=lambda x:x[1])\n    yong=[]\n    yong_sum=0\n    for i in range(n):\n        knight[i][3]=knight[i][2]+yong_sum\n        if len(yong)<k:\n            yong.append(knight[i][2])\n            yong.sort()\n            yong_sum = sum(yong)\n        elif k==0:\n            continue\n        else:\n            if yong[0]<knight[i][2]:\n                yong[0]=knight[i][2]\n                yong.sort()\n                yong_sum = sum(yong)\n\n    knight.sort(key=lambda x:x[0])\n    for i in range(n-1):\n        print(knight[i][3], end=\"\")\n        print(\" \", end=\"\")\n    print(knight[-1][3])\n__starting_point()", "from heapq import heapify, heappush, heappushpop\n\nn , k = list(map(int , input().split()))\n\npower = list(map(int , input().split()))\ncoins = list(map(int , input().split()))\n\nknights = [i for i in range(n)]\nknights.sort(key=lambda x:power[x])\n\ncursum = 0\ncurcoin = []\nheapify(curcoin)\nres = [0] * n\nfor i in range(min(k,n)):\n    res [knights[i]] = cursum +coins[knights[i]]\n    heappush(curcoin, coins[knights[i]])\n    cursum += coins[knights[i]]\n\nfor i in range(min(k,n), n):\n    res [knights[i]] = cursum +coins[knights[i]]\n    cursum += coins[knights[i]] - heappushpop(curcoin, coins[knights[i]])\n\nprint(*res)\n"]