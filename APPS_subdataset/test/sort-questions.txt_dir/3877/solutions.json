["\nimport sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\nn,l,r=list(map(int,input().split()))\n\na1=0\n\nlayers=1\nwhile layers*2<=n: layers*=2\n\n# abacaba pattern\nfor i in range(l,r+1):\n    layer=layers\n    while i%2==0:\n        layer//=2\n        i//=2\n    if (n//layer)%2==1:\n        a1+=1\n    #print(i,n&layer)\n\nprint(a1)\n", "3\n\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef length(n):\n    if n <= 1:\n        return 1\n    return 2 * length(n // 2) + 1\n\n@lru_cache(maxsize=None)\ndef solve(n, l, r):\n    if l > r:\n        return 0\n    if n <= 1:\n        assert l == r and l == 1\n        return n\n    mid = length(n // 2) + 1\n    if r < mid:\n        return solve(n // 2, l, r)\n    elif l > mid:\n        return solve(n // 2, l - mid, r - mid)\n    else:\n        return (n % 2) + solve(n // 2, l, mid - 1) + solve(n // 2, 1, r - mid)\n\nn, l, r = list(map(int, input().split()))\nprint(solve(n, l, r))\n", "def dels(n):\n    c1 = 1\n    while n > 1:\n        n = n // 2\n        c1 = c1 * 2 + 1\n    return c1\n\ndef recursion(n, l, r):\n    if l > r:\n        return 0\n    if n != 1:\n        left_count = dels(n) // 2\n        ans = recursion(n // 2, l, min(left_count, r)) + recursion(n // 2, max(left_count + 2, l) - left_count - 1, r - left_count - 1)\n        if n % 2 != 0 and left_count + 1 >= l and left_count + 1 <= r:\n            ans += 1\n        return ans\n    else:\n        return 1\n\n\nn, l, r = list(map(int, input().split()))\nprint(recursion(n, l, r))\n\n", "from math import log2\n\n\nn, l, r = list(map(int, input().split()))\nbn = list(map(int, list(bin(n)[2:])))\nans = 0\nfor i in range(l, r + 1):\n    ans += bn[int(log2(i & -i))]\nprint(ans) \n", "import sys\n\nsys.setrecursionlimit(100000)\n\ndef score(n):\n    factor = 1\n    ans = 0\n    save = n\n    while n > 0:\n        ans += factor * (n & 1)\n        n >>= 1\n        factor *= 2\n\n    # print('score({}) = {}'.format(save, ans))\n    return ans\n\ndef solve(n, r, half_size):\n    # count the number of 1s strictly less than r (0 indexed)\n    # print(n, r, half_size)\n    if r == 0:\n        return 0\n\n    if n < 2:\n        return n\n\n    ans = 0\n    if r > half_size:\n        ans += (n & 1)\n        ans += score(n // 2)\n        ans += solve(n // 2, r - half_size - 1, half_size // 2)\n    else:\n        # r <= half_size\n        ans += solve(n // 2, r, half_size // 2)\n\n    return ans\n\ndef main():\n    n, l, r = list(map(int, input().split()))\n    b = len(bin(n)) - 2\n    half_size = (1 << (b - 1)) - 1\n\n    right = solve(n, r, half_size)\n\n    left = solve(n, l - 1, half_size)\n    # print(right, left)\n    print(right - left)\n\nmain()\n", "n,l,r = [int(x) for x in input().strip().split(' ')]\n\n\n\ndef handlerequest(n,l,r):\n    if n == 0 or n == 1:\n        return n if l == r else 0\n    else:\n        size = 2**(n.bit_length()-1)-1\n        if r <= size:\n            return handlerequest(n//2,l,r)\n        elif l > size+1:\n            return handlerequest(n//2,l-size-1,r-size-1)\n        else:\n            return n%2+handlerequest(n//2,l,size)+handlerequest(n//2,1,r-size-1)\n\nprint(handlerequest(n,l,r))\n", "n, l, r = list(map(int, input().split()))\nl -= 1\nr -= 1\nop = 0\ncurn = n\nwhile curn > 1:\n    curn //= 2\n    op += 1\nlength = 1\nfor i in range(op):\n    length = 2 * length + 1\n\ndef get_ans(n, l, r, curl, curr):\n    if l == curl and r == curr:\n        return n\n    length = curr - curl + 1\n    mid = (curr + curl) // 2\n    ans = 0\n    if l < mid:\n        ans += get_ans(n // 2, l, min(mid - 1, r), curl, mid - 1)\n    if r > mid:\n        ans += get_ans(n // 2, max(l, mid + 1), r, mid + 1, curr)\n    if l <= mid and r >= mid:\n        ans += n % 2\n    return ans\nprint(get_ans(n, l, r, 0, length - 1))\n\n", "import math\nimport sys\n\na = list(map(int,input().split()))\n\nn = a[0]\nl = a[1]\nr = a[2]\n\nl = l -1\nr = r-1\n#do these because l and r are 1 indexed for some reason\n\nb = n\nc = []\n#brute force cos im suck ass\nwhile b > 1:\n    c.append(b%2)\n    b = math.floor(b/2)\nc.append(1)\n\nif (n == 0):\n    print(0)\n    return\n\nd = 0\n#d is life\nfor x in range(l,r+1):\n    if x%2 == 0:\n        d = d + 1\n    else:\n        y = x\n        p = -1\n        while True:\n            if (y % 2 == 0):\n                d = d + c[p]\n                break\n            else:\n                y = (y-1)/2\n                p = p - 1\n\nprint(d)", "import sys\nA = list(map(int, input().split()))\nn = A[0]\nn1 = n\nl = A[1]\nr = A[2]\nL = []\nX = []\nif (n == 0):\n    print(0)\n    return\nwhile (n > 0):\n    L.append(n % 2)\n    n = n//2\nnear = 1\nans = 0\nfor i in range(l, r+1):\n    b = -1\n    k = i\n    d = 1\n    f = 0\n    while ((k % d) == 0):\n        d *= 2\n        f += 1\n    d /= 2\n    f -= 1\n    if (L[len(L) - f - 1] == 1): ans += 1\nprint(ans)\n            \n", "n,i0,i1 = list(map(int, input().split()))\ni0-=1\n\ndef len(n):\n    l=1\n    if n>1: l+=2*len(n//2)\n    return l\n\ndef get(n, i):\n    l=len(n)\n    m=l//2\n    a=0\n    if m<=i:\n        a+=n//2\n        if m<i: a+=n%2\n        i-=m+1\n    if 0<i:a+=get(n//2,i)\n    return a\n    \na=get(n,i1)-get(n,i0)\nprint(a)\n", "N, L, R = map(int, input().split())\nS = \"\"\nwhile N > 0:\n    S = str(N%2)+S\n    N//=2\n\nRAns = 0\nfor i in range(1, len(S)+1):\n    if(R >= (2**(i-1))):\n        RAns += 1*int(S[i-1])\n        RAns += (R-2**(i-1))//(2**i)*int(S[i-1])\nL-=1\nLAns = 0\nfor i in range(1, len(S)+1):\n    if(L >= (2**(i-1))):\n        LAns += 1*int(S[i-1])\n        LAns += (L-2**(i-1))//(2**i)*int(S[i-1])\nprint(RAns-LAns)", "import sys\n\ndef debug(x, table):\n    for name, val in table.items():\n        if x is val:\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\n            return None\n\ndef solve():\n    n, l, r = map(int, input().split())\n    bit_len = len(bin(n)[2:])\n    cnt = 0\n\n    for i in range(l, r + 1):\n        off = bit_len - 1\n        for j in range(bit_len - 1):\n            if i & (1 << j):\n                break\n            else:\n                off -= 1\n        cnt += (n >> off) & 1\n\n    print(cnt)\n\ndef __starting_point():\n    solve()\n__starting_point()", "n, L, R = list(map(int, input().strip().split()))\n\nif n < 2 :\n\tans = n % 2\nelse :\n\ta = []\n\twhile n != 0 :\n\t\ta.append(n)\n\t\tn = n // 2\n\n\tpw2 = []\n\tpw2.append(1)\n\tfor i in range(1, 51) :\n\t\tpw2.append(pw2[i-1] * 2)\n\n\tans = 0\n\tfor i in range(L, R + 1) :\n\t\tif i % 2 == 1 :\n\t\t\tans += 1\n\t\telse :\n\t\t\tcnt = 0\n\t\t\twhile i % pw2[cnt] == 0 :\n\t\t\t\tcnt += 1\n\t\t\tans += a[len(a) - cnt] % 2\nprint(ans)", "dp = {0:0, 1:1}\n\ndef f(x):\n    if x not in dp:\n        dp[x] = f(int(x/2))*2 + 1\n    return dp[x]\n\ndp2 = {(0, 0):0}\n\ndef dfs(x, n):\n    if (x, n) in dp2:\n        return dp2[(x,n)]\n    if x == 0 or n == 0:\n        return 0\n\n    if dp[x] < n:\n        return x\n    x2 = int(x/2)\n    fx2 = dp[x2]\n    ret = dfs(x2, n)\n    if n > fx2:\n        ret += dfs(x2, n - fx2 - 1) + (x%2)\n\n    dp2[(x,n)] = ret\n#    print(x, n, ret)\n    return ret\n\nn, l, r = list(map(int, input().split()))\nf(n)\nprint(dfs(n, r) - dfs(n, l-1))\n", "#!/usr/bin/env python3\n# 768B_code.py - Codeforces.com/problemset/problem/768/B by Sergey 2017\n\nimport unittest\nimport sys\n\n###############################################################################\n# Code Class (Main Program)\n###############################################################################\n\n\nclass Code:\n    \"\"\" Code representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n, self.l, self.r] = list(map(int, uinput().split()))\n\n    def bitlist(self, n):\n        result = []\n        while n > 0:\n            result.append(n & 1)\n            n = int(n/2)\n        result.reverse()\n        return result\n\n    def period(self, i):\n        return 2 << i\n\n    def start(self, i):\n        return (1 << i) - 1\n\n    def count(self, s, p, l, r):\n        start = 1 if (l - s) % p == 0 else 0\n        return ((r - s) // p) - ((l - s) // p) + start\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result = 0\n        bl = self.bitlist(self.n)\n        for (i, n) in enumerate(bl):\n            if n == 1:\n                period = self.period(i)\n                start = self.start(i)\n                result += self.count(start, period, self.l-1, self.r-1)\n\n        return str(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Code class testing \"\"\"\n\n        # Constructor test\n        test = \"7 2 5\"\n        d = Code(test)\n        self.assertEqual(d.n, 7)\n        self.assertEqual(d.l, 2)\n        self.assertEqual(d.r, 5)\n\n        # Sample test\n        self.assertEqual(Code(test).calculate(), \"4\")\n\n        # Binlist (big endian) test\n        self.assertEqual(d.bitlist(6), [1, 1, 0])\n        self.assertEqual(d.bitlist(6)[0], 1)\n\n        # Period test\n        self.assertEqual(d.period(0), 2)\n        self.assertEqual(d.period(2), 8)\n\n        # Start test\n        self.assertEqual(d.start(0), 0)\n        self.assertEqual(d.start(3), 7)\n\n        # Count test\n        self.assertEqual(d.count(6, 8, 3, 5), 0)\n        self.assertEqual(d.count(6, 8, 5, 14), 2)\n\n        # Sample test\n        test = \"10 3 10\"\n        self.assertEqual(Code(test).calculate(), \"5\")\n\n        test = \"20000000 0 0\"\n        self.assertEqual(Code(test).calculate(), \"0\")\n\n        # Sample test\n        test = \"\"\n        # self.assertEqual(Code(test).calculate(), \"0\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Code(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Code(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Code().calculate())\n\n__starting_point()", "n, l, r = map(int, input().split())\ns = ''\na = []\nk = n\nwhile k > 1:\n    a.append(k % 2)\n    k = k // 2\na.append(k)\nans = 0\nfor i in range(l - 1, r):\n    s = \"0\" + bin(i)[2:]\n    cur = 1\n    while s[-cur] != \"0\":\n        cur += 1\n    ans += a[-cur]\nprint(ans)", "def main():\n    n, l, r = list(map(int, input().split()))\n\n    c = n\n    h = 0\n    while c > 0:\n        h += 1\n        c //= 2\n    c = 2 ** h - 1\n\n    print(ones(n, c, l-1, r-1))\n\n\ndef ones(n, c, l, r):\n    if n == 1:\n        return 1\n\n    if n == 0:\n        return 0\n\n    if l == 0 and r == c-1:\n        return n\n\n    m = c // 2\n    total = 0\n\n    if l < m < r:\n        # [l, m-1] + [m+1, r] + [m]\n        total = ones(n // 2, m, l, m - 1) + ones(n // 2, m, 0, r - m - 1) + (1 if n % 2 == 1 else 0)\n    elif l < r < m:\n        # [l, r]\n        total = ones(n // 2, m, l, r)\n    elif m < l < r:\n        # [l, r]\n        total = ones(n // 2, m, l - m - 1, r - m - 1)\n    elif l == m < r:\n        # [m+1, r] + m\n        total = ones(n // 2, m, 0, r - m - 1) + (1 if n % 2 == 1 else 0)\n    elif l < m == r:\n        # [l, m] + m\n        total = ones(n // 2, m, l, m) + (1 if n % 2 == 1 else 0)\n    elif l == r < m:\n        total = ones(n // 2, m, l, r)\n    elif m < l == r:\n        total = ones(n // 2, m, l - m - 1, r - m - 1)\n    elif l == m == l:\n        total = (1 if n % 2 == 1 else 0)\n\n    return total\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, l, r = list(map(int, input().split()))\nln = 0\nans = 0\ncurr = 1\nwhile curr <= n :\n    curr *= 2\n    ln += 1\nln -= 1\nfor i in range(l, r + 1):\n    if curr > i:\n        res = 1\n        res2 = 0\n        while (res & i) == 0:\n            res *= 2\n            res2 += 1\n        if res2 <= ln:\n            msk = n & (1 << (ln - res2))\n            ans += (msk != 0)\nprint(ans)\n", "from functools import lru_cache\n\nn, a, b = map(int, input().split())\na -= 1\nb -= 1\n\nif n == 0:\n    print(0)\n    return\n\n@lru_cache(maxsize=None)\ndef cnt(n):\n    if n == 1:\n        return 1\n    return 2 * cnt(n >> 1) + 1\n\nz = cnt(n)\n\n@lru_cache(maxsize=None)\ndef query(n, l, r):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n\n    if r < cnt(n >> 1):\n        return query(n >> 1, l, r)\n    if l > cnt(n >> 1):\n        return query(n >> 1, l - cnt(n >> 1) - 1, r - cnt(n >> 1) - 1)\n    \n    res = n & 1\n    if l < cnt(n >> 1):\n        res += query(n >> 1, l, cnt(n >> 1) - 1)\n    if r > cnt(n >> 1):\n        res += query(n >> 1, 0, r - cnt(n >> 1) - 1)\n\n    #print(\"n={}, l={}, r={} => {}\".format(n, l, r, res))\n    return res\n\nprint(query(n, a, b))", "#!/usr/bin/env python3\nfrom  collections  import defaultdict\ndef ri():\n    return map(int, input().split())\n\npt = defaultdict()\nln = defaultdict()\n\nn, l, r = ri()\n\n\ndef lenn(n):\n    if n in ln:\n        return ln[n]\n    if n == 1:\n        ln[1] = 1\n        return 1\n    elif n == 0:\n        ln[0] = 1\n        return 1\n    i = 2*lenn(n//2) + 1\n    ln[n] = i\n    return i\n\n\ndef pn(n):\n    if n in pt:\n        return pt[n]\n    pt[n] = 1 + lenn(n)//2\n    return pt[n]\n\n\ndef findval(i, p, n):\n#    print(i, p, n)\n    if p == i:\n        return n%2\n    if p > i:\n        return findval(i, p - pn(n//2), n//2)\n    else:\n        return findval(i, p + pn(n//2), n//2)\n\n\nans = 0\np = pn(n)\nfor i in range(l, r+1):\n    ans += findval(i, p, n)\n\nprint(ans)", "import sys\n\n\ndef read_input():\n    for idx, line in enumerate(sys.stdin):\n        if idx == 0:\n            return (int(x) for x in line.strip().split(' '))\n\n\ndef count_all(n):\n    if len(n) == 0:\n        return 0\n    else:\n        return 2 * count_all(n[:-1]) + 1\n\n\ndef count_ones(n):\n    if len(n) == 0:\n        return 0\n    else:\n        return 2 * count_ones(n[:-1]) + int(n[-1])\n\n\ndef process_rec(n, l, r):\n    if r - l > count_all(n):\n        assert False\n    if r - l == count_all(n):\n        return count_ones(n)\n    else:\n        l_count = r_count = count_all(n[:-1])\n        m_count = int(n[-1])\n        res = 0\n\n        if l < l_count:  ##   [0-l_count) V [l, r)0\n            res += process_rec(n[:-1], l, min(r, l_count))\n        if l <= l_count and r > l_count:  ## [l_count, l_count + 1) V [l, r)\n            res += m_count\n        if r > l_count + 1:  ## [l_count + 1, ...) V [l, r)\n            res += process_rec(n[:-1], max(l - l_count - 1, 0), r - l_count - 1)\n\n        return res\n\n\ndef process(n, l, r):\n    n = \"{0:b}\".format(n)\n    return process_rec(n, l - 1, r)\n\n\ndef print_output(res):\n    print(res)\n\n\ndef __starting_point():\n    print_output(process(*read_input()))\n\n__starting_point()", "import sys\nn,l,r = map(int, input().split())\nl -= 1\nr -= 1\n\ndef cnt(n):\n    if n <= 1:\n        return 1\n    return  2*cnt(n//2) + 1\ndef rec(n,s,e):\n    if s > e:\n        return 0\n    if s > r or e < l:\n        return 0;\n    if n <= 1:\n        return n\n    mid = (s + e) // 2\n    plus = 0\n    if l <= mid <= r:\n        plus = n % 2\n    return rec(n//2,s,mid - 1) + rec(n//2,mid + 1, e) + plus\nlength = cnt(n)\nprint(rec(n,0,length - 1))", "def get(nn, x):\n  res = 0\n  i = -1\n  while x:\n    res += ((x+1)//2) * nn[i]\n    x //= 2\n    i -= 1\n  return res  \n\ndef toBin(n):\n  res = []\n  while n:\n    res.append(n%2)\n    n //= 2\n  if res:\n    return res\n  else:\n    return [0]\n  \ndef raw(n):\n  if n < 2: return [n]\n  else: \n    temp = raw(n//2)  \n    return temp + [n%2] + temp\n    \nn, l, r = list(map(int, input().split()))\nnn = toBin(n)\nprint(get(nn, r) - get(nn, l-1)) \n", "import sys\n\ndef debug(x, table):\n    for name, val in table.items():\n        if x is val:\n            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)\n            return None\n\ndef solve():\n    n, l, r = map(int, input().split())\n    ans = f(n, r) - f(n, l - 1)\n\n    print(ans)\n\ndef f(n, i):\n    if n == 0:\n        return 0\n    if i == 0:\n        return 0\n\n    mx = 2**(n.bit_length())\n\n    if i == mx//2:\n        return n//2 + n%2\n    elif i < mx//2:\n        return f(n//2, i)\n    else:\n        return n//2 + n%2 + f(n//2, i - mx//2)\n\ndef __starting_point():\n    solve()\n__starting_point()"]