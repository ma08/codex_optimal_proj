["n, m = list(map(int,input().split()))\n\nM = 10 ** 9 + 7\n\ndef inv(x):\n    return pow(x, M - 2, M)\n\ndef binomial(n, k):\n    if 0 <= k <= n:\n        ntok = 1\n        ktok = 1\n        for t in range(1, min(k, n - k) + 1):\n            ntok *= n\n            ktok *= t\n            n -= 1\n            ntok %= M\n            ktok %= M\n        return (ntok * inv(ktok))%M\n    else:\n        return 0\n\nprint(binomial(n+2*m-1, 2 * m))\n", "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nMOD = 10**9 + 7\nMAX_N = 2000 \n\ndef single_mod_nCr(n, r):\n    if n < r or n < 0 or r < 0:\n        return 0\n    if r > n - r:\n        r = n - r\n    ret = 1\n    for i in range(r):\n        ret *= n - i\n        ret *= pow(i+1, MOD-2, MOD)\n        ret %= MOD\n    return ret\n\nn, m = [int(item) for item in input().split()]\nprint(single_mod_nCr(n+m*2-1, m*2))", "n,m = list(map(int, input().split()))\nmod = 10**9+7\n\nDP = [0]*(n+1)\nDP[0] = 1\nfor i in range(m):\n    nxt = [0]*(n+1)\n    cnt = DP[0]\n    for i in range(1, n+1):\n        cnt += DP[i]\n        cnt %= mod\n        nxt[i] = cnt\n    DP = nxt\n\ncnt = 0\nans = 0\nfor i in reversed(list(range(1,n+1))):\n    cnt += DP[n-i+1]\n    ans += DP[i]*cnt\n    ans %= mod\nprint(ans)\n", "import math\n\nMOD = 1000000007\n\ndef main():\n    (n, m) = ([int(x) for x in input().split()])\n    m *= 2\n    a = [0] * n\n    a[0] = 1\n    for i in range(m):\n        b = [0] * n\n        sum = a[0]\n        b[0] = a[0]\n        for j in range(1, n):\n            sum = (sum + a[j]) % MOD\n            b[j] = sum\n        a = b\n    result = 0\n    for i in range(n):\n        result = (result + a[i]) % MOD\n    print(result)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n,m = LI()\n    f = [1]\n    N = 10**6\n    for i in range(1,N+1):\n        f.append(f[-1]*i%mod)\n    inv = [None]*(N+1)\n    inv[N] = pow(f[N],mod-2,mod)\n    for i in range(N)[::-1]:\n        inv[i] = inv[i+1]*(i+1)%mod\n    print(f[2*m+n-1]*inv[n-1]*inv[2*m]%mod)\n    return\n\n#Solve\ndef __starting_point():\n    solve()\n\n__starting_point()", "def calc(n, m):\n    r = 1\n    for i in range(n, n+2*m):\n        r *= i\n    for i in range(1, 2*m+1):\n        r //= i\n    return r % (10**9+7)\n\n# T = int(input())\nT = 1\nfor _ in range(T):\n    a, b = [int(x) for x in input().split()]\n    print(calc(a, b))\n", "import sys\nreadline = sys.stdin.readline\n\nMOD = 10**9+7\n\nN, M = map(int, readline().split())\n\ndp = [0] + [1]*N\n\nfor _ in range(2*M):\n    dp2 = dp[:]\n    for i in range(1, N+1):\n        dp2[i] = (dp2[i]+dp2[i-1])%MOD\n    dp = dp2[:]\nprint(dp[N])", "n, mm = map(int,input().split())\nmod = 10**9+7\n\nl = 10**4\n\nM = [1]  # i!\u306emod\nm = 1\nfor i in range(1, l):\n    m = (m * i) % mod\n    M.append(m)\n\ndef pow(x, y, mod):  # x**y \u306e mod \u3092\u8fd4\u3059\u95a2\u6570\n    ans = 1\n    while y > 0:\n        if y % 2 == 1:\n            ans = (ans * x) % mod\n        x = (x**2) % mod\n        y //= 2\n    return ans\n\ndef inv(x, mod):  # x \u306e mod \u3067\u306e\u9006\u5143\u3092\u8fd4\u3059\u95a2\u6570\n    return pow(x, mod-2, mod)\n\n# print(inv(8,13))\n\nMI = [0] * (l-1) +[inv(M[l-1], mod)]  # i!\u306e\u9006\u5143\nfor i in range(l-2, -1, -1):\n    MI[i] = MI[i+1] * (i+1) % mod\n\ndef C(x, y):  # \u30b3\u30f3\u30d3\u30cd\u30fc\u30b7\u30e7\u30f3\n    if y < 0 or y > x:\n        return 0\n    ans = M[x]\n    ans = (ans * MI[y]) % mod\n    return (ans * MI[x-y]) % mod\n\nans = 0\nfor i in range(n):\n    # print(mm-1+i, i),(mm, n-i-1)\n    ans = (ans + C(mm-1+i, i) * C(mm+n-i-1, n-i-1)) % mod\nprint(ans)", "n_=2*10**3\nmod=10**9+7\nfac=[1]*(n_+1)\nfor i in range(1,n_+1):\n    fac[i]=fac[i-1]*i%mod\ninv =[1]*(n_+1)\ninv[n_]=pow(fac[n_],mod-2,mod)\nfor i in range(n_-1,0,-1):\n    inv[i]=inv[i+1]*(i+1)%mod\ndef nCr(n,r):\n    if n<=0 or r<0 or r>n:\n        return 0\n    return fac[n]*inv[r]%mod*inv[n-r]%mod\n\nn,m=map(int,input().split())\nans=nCr(n+2*m-1,n-1)\nprint(ans)", "# -*- coding: utf-8 -*-\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\nfrom typing import List\n\n\"\"\"\ncreated by shhuan at 2020/1/14 22:56\n\n\"\"\"\n\n\ndef solve(N, M):\n    MOD = 10 ** 9 + 7\n    dp = [[0 for _ in range(N+1)] for _ in range(1 + M)]\n    for v in range(1, N+1):\n        dp[1][v] = 1\n    for i in range(2, M+1):\n        for v in range(1, N+1):\n            dp[i][v] = sum([dp[i-1][u] for u in range(1, v+1)])\n            dp[i][v] %= MOD\n\n    dp2 = [[0 for _ in range(N+1)] for _ in range(1 + M)]\n    for v in range(1, N+1):\n        dp2[1][v] = 1\n    for i in range(2, M+1):\n        for v in range(1, N+1):\n            dp2[i][v] = sum([dp2[i-1][u] for u in range(v, N+1)])\n            dp2[i][v] %= MOD\n\n    ans = 0\n    for v in range(1, N+1):\n        ans += sum([dp[M][v] * dp2[M][u] for u in range(v, N+1)])\n        ans %= MOD\n\n    return ans\n\n\nN, M = map(int, input().split())\nprint(solve(N, M))"]