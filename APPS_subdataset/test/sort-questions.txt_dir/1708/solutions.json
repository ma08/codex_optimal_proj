["n, m = map(int, input().split())\na = list(map(int, input().split()))\nc = list(map(int, input().split()))\nmc = sorted(((y, x) for x, y in enumerate(c)), reverse=True)\nfor _ in range(m):\n    t, d = map(int, input().split())\n    t -= 1\n    if a[t] >= d:\n        print(c[t] * d)\n        a[t] -= d\n    else:\n        x = a[t] * c[t]\n        d -= a[t]\n        a[t] = 0\n        while d:\n            if not mc:\n                print(0)\n                break\n            cost, index = mc[-1]\n            if a[index] >= d:\n                x += cost * d\n                a[index] -= d\n                d = 0\n            else:\n                x += cost * a[index]\n                d -= a[index]\n                a[index] = 0\n            if a[index] == 0:\n                mc.pop()\n        else:\n            print(x)", "def main():\n    n, m = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    b = [(c[i], i) for i in range(n)]\n    b.sort()\n    b = [b[i][1] for i in range(n)]\n    bi = 0\n    for i in range(m):\n        t, d = list(map(int, input().split()))\n        t -= 1\n        s = 0\n        if a[t] >= d:\n            a[t] -= d\n            print(d * c[t])\n        else:\n            s += a[t] * c[t]\n            d -= a[t]\n            a[t] = 0\n            while bi < n:\n                if a[b[bi]] >= d:\n                    s += d * c[b[bi]]\n                    a[b[bi]] -= d\n                    d = 0\n                    break\n                s += a[b[bi]] * c[b[bi]]\n                d -= a[b[bi]]\n                a[b[bi]] = 0\n                bi += 1\n            if d > 0:\n                print(0)\n            else:\n                print(s)\n\nmain()\n", "n,m = list(map(int, input().split()))\na = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nss = [(i, c[i]) for i in range(n)]\nss = sorted(ss, key=lambda x: (x[1], x[0]))\np = 0\nans1 = []\nfor _ in range(m):\n    t, d = list(map(int, input().split()))\n    t -=1\n    ans = 0\n    c1 = min(d, a[t])\n    a[t] -= c1\n    ans += c1*c[t]\n    d -= c1\n    while d > 0 and p < n:\n        nt = ss[p][0]\n        nc = ss[p][1]\n        c2 = min(a[nt], d)\n        a[nt] -= c2\n        d -= c2\n        ans += nc*c2\n        if a[nt] == 0:\n            p += 1\n    if d == 0:\n        print(ans)\n    else:\n        print(0)\n", "import sys\nn, m = map(int, input().split())\ndishes = list(map(int, input().split()))\ncosts = list(map(int, input().split()))\ncheaper = [i for i, v in sorted(enumerate(costs), key=lambda x: (x[1], x[0]), reverse=True)]\n\nans = []\nappend = ans.append\n\nfor t, d in (map(int, l.split()) for l in sys.stdin):\n    t -= 1\n    count = min(d, dishes[t])\n    price = costs[t] * count\n    dishes[t] -= count\n    d -= count\n    while d and cheaper:\n        t = cheaper[-1]\n        count = min(d, dishes[t])\n        dishes[t] -= count\n        if not dishes[t]:\n            cheaper.pop()\n        price += costs[t] * count\n        d -= count\n\n    append(0 if d else price)\n\nprint(*ans, sep=\"\\n\")", "# list(map(int, input().split()))\nn, m = list(map(int, input().split()))\nost = list(map(int, input().split()))\nprice = list(map(int, input().split()))\nminprice = [[price[i], i] for i in range(len(price))]\nminprice = sorted(minprice)\nminost = 0\nfor _ in range(m):\n    pr = 0\n    bl, kol = list(map(int, input().split()))\n    bl -= 1\n    if (ost[bl] >= kol):\n        pr = kol * price[bl]\n        ost[bl] -= kol\n    else:\n        kol -= ost[bl]\n        pr = ost[bl] * price[bl]\n        ost[bl] = 0\n        while(kol > 0):\n            if (minost == n):\n                pr = 0\n                break\n            minbl = minprice[minost][1]\n            if (ost[minbl] >= kol):\n                pr += kol * price[minbl]\n                ost[minbl] -= kol\n                kol = 0\n            else:\n                kol -= ost[minbl]\n                pr += ost[minbl] * price[minbl]\n                ost[minbl] = 0\n                minost += 1\n                if (minost == n):\n                    pr = 0\n                    break\n    print(pr)", "n, m = list(map(int, input().split()))\n\ndish = list(map(int, input().split()))\ncost = list(map(int, input().split()))\nscost = []\nfor i in range(n):\n    scost.append([cost[i], dish[i], i])\nscost = sorted(scost)\n# print(scost)\n\ncur = 0\nfor i in range(m):\n    x, y = list(map(int, input().split()))\n    x -= 1\n    # print(x, y)\n    price = 0\n    if dish[x] >= y:\n        price += cost[x] * y\n        dish[x] -= y\n        y = 0\n    else:\n        price += cost[x] * dish[x]\n        y -= dish[x]\n        dish[x] = 0\n\n        while y > 0:\n            try:\n                tmp = scost[cur][-1]\n\n                # print(\"cur\", cur, scost[cur])\n\n                if dish[tmp] >= y:\n                    price += cost[tmp] * y\n                    dish[tmp] -= y\n                    y = 0\n\n                else:\n                    price += cost[tmp] * dish[tmp]\n                    y -= dish[tmp]\n                    dish[tmp] = 0\n                    cur += 1\n            except IndexError:\n                price = 0\n                y = 0\n    # print(dish)\n\n    print(price)\n    # print()\n", "def ii():\n    return int(input())\ndef mi():\n    return map(int, input().split())\ndef li():\n    return list(mi())\n\nn, m = mi()\na = li()\nc = li()\n\nx = list(range(n))\nx.sort(key=lambda i: (c[i], i))\ncur = 0\n\nout = []\nfor i in range(m):\n    t, d = mi()\n    p = min(d, a[t - 1])\n    d -= p\n    a[t - 1] -= p\n    ans = c[t - 1] * p\n    while d:\n        while cur < n and a[x[cur]] == 0:\n            cur += 1\n        if cur == n:\n            ans = 0\n            break\n        p = min(d, a[x[cur]])\n        d -= p\n        a[x[cur]] -= p\n        ans += c[x[cur]] * p\n    out.append(str(ans))\n\nprint(*out, sep='\\n')\n", "import sys\nread = lambda : list(map(int, sys.stdin.readline().split()))\nwrite = sys.stdout.write\n\nn, m = read()\ndish = [0] + list(read())\ndishes = sum(dish)\ncost = [0] + list(read())\n\nremain = []\nfor i in range(1, n+1):\n    remain.append(\n        [cost[i], i]\n    )\nremain.sort(reverse=True)\n\nfor i in range(m):\n    t, d = read()\n    ans = 0\n\n    if dishes == 0:\n        write(\"0\\n\")\n\n    elif dish[t] >= d:\n        dishes -= d \n        dish[t] -= d\n        write(f\"{cost[t]*d}\\n\")\n    \n    elif dish[t] < d:\n        ans += dish[t] * cost[t]\n        dishes -= dish[t]\n        d -= dish[t]\n        dish[t] = 0\n        #print(d, dish)\n\n        while d > 0 and dishes > 0:\n            k = remain[-1][1]\n            #print(k, dish[k], cost[k])\n\n            if dish[k] >= d:\n                dish[k] -= d \n                dishes -= d   \n                ans += cost[k] * d\n                d = 0\n            else:\n                dishes -= dish[k]\n                d -= dish[k]\n                ans += cost[k] * dish[k]\n                dish[k] = 0\n                remain.pop()\n        \n        if d > 0 and dishes == 0:\n            write(\"0\\n\")\n        else:\n            write(f\"{ans}\\n\")\n                \n\n\n\n\n", "n,m=list(map(int,input().split()))#kinds of food,customers\nA=[0]+list(map(int,input().split()))#initial remain of i-th foods\nC=[0]+list(map(int,input().split()))#costs\nO=[list(map(int,input().split())) for i in range(m)]\n\nC2=[[C[i+1],i+1] for i in range(n)]\nC2.sort()\n\nC2NOW=0\n\nfor f,d in O:\n    ANS=0\n    if A[f]>=d:\n        ANS+=C[f]*d\n        A[f]-=d\n        print(ANS)\n        continue\n    \n\n    else:\n        ANS+=A[f]*C[f]\n        d-=A[f]\n        A[f]=0\n        #print(ANS,f,d,C2[C2NOW])\n\n        while d>0:\n            \n            if C2NOW==n:\n                ANS=0\n                d=0\n                break\n            \n            if A[C2[C2NOW][1]]==0:\n                C2NOW+=1\n                continue\n            \n            if A[C2[C2NOW][1]]>=d:\n                ANS+=d*C2[C2NOW][0]\n                A[C2[C2NOW][1]]-=d\n                d=0\n\n            else:\n                ANS+=A[C2[C2NOW][1]]*C2[C2NOW][0]\n                d-=A[C2[C2NOW][1]]\n                A[C2[C2NOW][1]]=0\n                C2NOW+=1\n\n        print(ANS)\n                \n                \n", "import sys\n#sys.setrecursionlimit(200000)\ninput = sys.stdin.readline\nn,m = map(int,input().split())\na = list(map(int,input().split()))\nc = list(map(int,input().split()))\nz = list(range(n))\nd = []\nfor i,j,k in zip(a,c,z):\n        d.append([j,i,k])\nd.sort(key=lambda x : -x[0])\nfor i in range(m):\n        x,y = map(int,input().split())\n        x-=1\n        ans = 0\n        if a[x]:\n                if a[x] >= y:\n                        print(c[x]*y)\n                        a[x] -= y\n                        continue\n                else:\n                        ans += a[x]*c[x]\n                        y -= a[x]\n                        a[x] = 0\n        while d and y>0:\n                q,w,e = d.pop()\n                w = a[e]\n                if w >= y:\n                        ans += q*y\n                        a[e] = w-y\n                        y = 0\n                        d.append([q,w-y,e])\n                else:\n                        ans += w*q\n                        a[e] = 0\n                        y-= w\n        if y:\n                print(0)\n        else:\n                print(ans)", "# cook your dish here\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nc=list(map(int,input().split()))\ncl=[]\nfor i in range(n):\n    cl.append([c[i],i])\n#print(cl)\ndef fun(itm):\n    return itm[0]\ncl.sort(key=fun)\nidx=0\nfor i in range(m):\n    x,y=map(int,input().split())\n    x-=1\n    cost=0\n    if(a[x]>=y):\n        a[x]-=y\n        cost+=c[x]*y\n        y=0\n    else:\n        cost+=c[x]*a[x]\n        y-=a[x]\n        a[x]=0\n        flag=0\n        while(idx<n and y>0):\n            if(a[cl[idx][1]]>=y):\n                a[cl[idx][1]]-=y\n                cost+=cl[idx][0]*y\n                y=0\n                flag=1\n            else:\n                cost+=cl[idx][0]*a[cl[idx][1]]\n                y-=a[cl[idx][1]]\n                a[cl[idx][1]]=0\n                idx+=1\n        if(flag==0):\n            cost=0\n    print(cost)", "n, m = list(map(int, input().lstrip().split(' ')))\n\na = list(map(int, input().lstrip().split(' ')))\nc = list(map(int, input().lstrip().split(' ')))\n\ncosts = sorted([(i, cost) for i, cost in enumerate(c)],\n               key=lambda x: (x[1], x[0]))\nci = 0\n# print(costs)\nfor _ in range(m):\n    cost = 0\n    t, d = list(map(int, input().lstrip().split(' ')))\n    t -= 1\n    if a[t] > d:\n        cost = d * c[t]\n        a[t] -= d\n    else:\n        cost = a[t] * c[t]\n        d -= a[t]\n        a[t] = 0\n        while d > 0 and ci < n:\n            ai, _cost = costs[ci]\n            if a[ai] > d:\n                cost += d * _cost\n                a[ai] -= d\n                d = 0\n            else:\n                cost += a[ai] * _cost\n                d -= a[ai]\n                a[ai] = 0\n                ci += 1\n        if d > 0:\n            cost = 0\n    # print(a)\n    print(cost)\n", "import sys\nstdin = sys.stdin\n \nsys.setrecursionlimit(10**5) \n \ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x)-1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\nfrom collections import deque\n\nn,m = li()\na = list(li())\nc = list(li())\n\n# dictionary of idx-num\ndic = {idx: ai for idx, ai in enumerate(a)}\n\n# cheap order\ncord = [idx for (_, idx) in sorted([(ci, idx) for idx,ci in enumerate(c)])]\ncord = deque(cord)\n\nfor _ in range(m):\n    dish, num = li()\n    dish -= 1\n    \n    ans = 0\n    \n    if num <= dic[dish]:\n        dic[dish] -= num\n        ans = c[dish]*num\n        print(ans)\n        \n    else:\n        ans = c[dish]*dic[dish]\n        num -= dic[dish]\n        dic[dish] = 0\n        \n        while num > 0:\n            if cord:\n                nex = cord.popleft()\n            else:\n                ans = 0\n                num = 0\n            \n            if dic[nex] > num:\n                ans += c[nex] * num\n                dic[nex] -= num\n                cord.appendleft(nex)\n                num = 0\n                \n            elif dic[nex] == num:\n                ans += c[nex] * num\n                dic[nex] = 0\n                num = 0\n                \n            else:\n                ans += c[nex] * dic[nex]\n                num -= dic[nex]\n                dic[nex] = 0\n                \n        print(ans)", "\nnum_dishes, num_customers = [int(x) for x in input().split()]\n\ndish_amounts = [int(x) for x in input().split()]\ndish_costs = [int(x) for x in input().split()]\n\ndishes_by_price = sorted(list(range(num_dishes)), key=lambda i : dish_costs[i])\ndbp_i = 0\n\nfor j in range(num_customers):\n    dish, amount = [int(x) for x in input().split()]\n    dish -= 1\n    served = min(dish_amounts[dish], amount)\n    dish_amounts[dish] -= served\n\n    cost = served * dish_costs[dish]\n    not_served = amount - served\n    # print(j, dish, served)\n\n    while not_served > 0 and dbp_i != num_dishes:\n        i = dishes_by_price[dbp_i]\n        served = min(dish_amounts[i], not_served)\n        cost += served * dish_costs[i]\n        dish_amounts[i] -= served\n        not_served -= served\n        # print(j, i, served)\n\n        if dish_amounts[i] == 0:\n            dbp_i += 1\n\n    if not_served > 0:\n        cost = 0\n\n    print(cost)\n", "n, m = map(int, input().split())\na = [int(s) for s in input().split()]\nc = [int(s) for s in input().split()]\ntypes = dict()\nfor i in range(n):\n    types[i] = c[i]\ntypes = sorted(types.items(), key=lambda kv: kv[1])\n#print(types)\nmin_c = types[0]\nind = 0\nfor i in range(m):\n    t, d = map(int, input().split())\n    t -= 1\n    summ = 0\n    if a[t] < d:\n        summ += a[t]*c[t]\n        d -= a[t]\n        a[t] = 0\n        while a[min_c[0]] < d:\n            summ += a[min_c[0]]*c[min_c[0]]\n            d -= a[min_c[0]]\n            a[min_c[0]] = 0\n            ind += 1\n            if ind >= n:\n                summ = 0\n                ind -= 1\n                break\n            else:\n                min_c = types[ind]\n        else:\n            summ += d*c[min_c[0]]\n            a[min_c[0]] -= d\n    else:\n        summ += d*c[t]\n        a[t] -= d\n    print(summ)", "'''input\n6 6\n6 6 6 6 6 6\n6 66 666 6666 66666 666666\n1 6\n2 13\n3 6\n4 11\n5 6\n6 6\n'''\nimport sys\nfrom collections import defaultdict as dd\nfrom itertools import  permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nimport heapq\nmod=10**9+7\n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\nn,m=ri()\na=ri()\nc=ri()\n\nhee=[]\n\nfor i in range(n):\n\theapq.heappush(hee,(c[i],i))\n\navail=a[:]\n\nfor i in range(m):\n\tcost=0\n\tt,d=ri()\n\tt-=1\n\tfm=0\n\tif avail[t]>=d:\n\t\tavail[t]=avail[t]-d\n\t\tcost+=(d*c[t])\n\telse:\n\t\trem=d-avail[t]\n\t\tcost=avail[t]*c[t]\n\t\tavail[t]=0\n\t\twhile rem>0:\n\t\t\ttry:\n\t\t\t\tnowc,nowi=heapq.heappop(hee)\n\t\t\t\tif avail[nowi]>=rem:\n\t\t\t\t\tavail[nowi]=avail[nowi]-rem\n\t\t\t\t\tcost=cost+rem*c[nowi]\n\t\t\t\t\theapq.heappush(hee,(c[nowi],nowi))\n\t\t\t\t\trem=0\n\t\t\t\telse:\n\t\t\t\t\tcost=cost+avail[nowi]*c[nowi]\n\t\t\t\t\tmk=rem-avail[nowi]\n\t\t\t\t\tavail[nowi]=0\n\t\t\t\t\trem=mk\n\t\t\texcept:\n\t\t\t\tfm=1\n\t\t\t\tbreak\n\tif fm==0:\n\t\tprint(cost)\n\telse:\n\t\tprint(0)\n\n\n\n\n", "import copy\nimport fractions\nimport itertools\nimport numbers\nimport string\nimport sys\n\n###\n\ndef powmod(x, p, m):\n\tif p <= 0:\n\t\treturn 1\n\tif p <= 1:\n\t\treturn x%m\n\treturn powmod(x*x%m, p//2, m) * (x%m)**(p%2) % m\n\n###\n\ndef to_basex(num, x):\n\twhile num > 0:\n\t\tyield num % x\n\t\tnum //= x\n\ndef from_basex(it, x):\n\tret = 0\n\tp = 1\n\tfor d in it:\n\t\tret += d*p\n\t\tp *= x\n\treturn ret\n\n###\n\ndef core():\n\tn, m = (int(x) for x in input().split())\n\ta = [int(x) for x in input().split()]\n\tc = [int(x) for x in input().split()]\n\ts = [(c[i], i) for i in range(n)]\n\ts.sort(reverse=True)\n\t\n\t# print(a)\n\t# print(s)\n\tfor _ in range(m):\n\t\tif not s:\n\t\t\tprint(0)\n\t\telse:\n\t\t\ttj, dj = (int(x) for x in input().split())\n\t\t\ttj -= 1\n\t\t\t\n\t\t\tif a[tj] >= dj:\n\t\t\t\tprint(dj*c[tj])\n\t\t\t\ta[tj] -= dj\n\t\t\telse:\n\t\t\t\tbill = a[tj]*c[tj]\n\t\t\t\tdj -= a[tj]\n\t\t\t\ta[tj] = 0\n\t\t\t\twhile dj > 0:\n\t\t\t\t\t# print(\"dj0, bill0: %d, %d\" % (dj, bill))\n\t\t\t\t\tif not s:\n\t\t\t\t\t\tbill = 0\n\t\t\t\t\t\tbreak\n\t\t\t\t\t\n\t\t\t\t\tif a[s[-1][1]] == 0:\n\t\t\t\t\t\t_ = s.pop()\n\t\t\t\t\telif a[s[-1][1]] >= dj:\n\t\t\t\t\t\tbill += dj*c[s[-1][1]]\n\t\t\t\t\t\ta[s[-1][1]] -= dj\n\t\t\t\t\t\tdj = 0\n\t\t\t\t\telse:\n\t\t\t\t\t\tbill += a[s[-1][1]]*c[s[-1][1]]\n\t\t\t\t\t\tdj -= a[s[-1][1]]\n\t\t\t\t\t\ta[s[-1][1]] = 0\n\t\t\t\t\t\t_ = s.pop()\n\t\t\t\t\t# print(\"dj, bill: %d, %d\" % (dj, bill))\n\t\t\t\tprint(bill)\n\t\t# print(a)\n\t\t# print(s)\n\n\ncore()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "def inpl(): return list(map(int, input().split()))\nN, M = inpl()\nA = inpl()\nC = inpl()\nDishnum = sum(A)\nACi = [[c, i, a] for i, (a, c) in enumerate(zip(A, C), 1)]\nACi.sort()\nOrig = dict()\nfor i, (_, j, _) in enumerate(ACi):\n    Orig[j] = i\nctr = 0\nfor _ in range(M):\n    ans = 0\n    t, d = inpl()\n    t = Orig[t]\n    Dishnum -= d\n    if Dishnum < 0:\n        print(ans)\n        continue\n    k = min(d, ACi[t][2])\n    ACi[t][2] -= k\n    d -= k\n    ans += k*ACi[t][0]\n    while d > 0:\n        k = min(d, ACi[ctr][2])\n        ACi[ctr][2] -= k\n        d -= k\n        ans += k*ACi[ctr][0]\n        if not ACi[ctr][2]:\n            ctr += 1\n    print(ans)", "# -*- coding: utf-8 -*-\n# @Time    : 2019/1/31 20:48\n# @Author  : LunaFire\n# @Email   : gilgemesh2012@gmail.com\n# @File    : B. Lunar New Year and Food Ordering.py\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n\n    price_index = []\n    for i in range(n):\n        price_index.append((c[i], i))\n    price_index.sort()\n    # print(price_index)\n\n    ptr = 0\n    for _ in range(m):\n        t, d = list(map(int, input().split()))\n        t -= 1\n        cost = 0\n\n        if a[t] > 0:\n            served_num = min(a[t], d)\n            a[t] -= served_num\n            d -= served_num\n            cost += served_num * c[t]\n\n        while ptr < n and d > 0:\n            _, index = price_index[ptr]\n            if a[index] == 0:\n                ptr += 1\n            served_num = min(a[index], d)\n            a[index] -= served_num\n            d -= served_num\n            cost += served_num * c[index]\n\n        if d > 0:\n            print(0)\n        else:\n            print(cost)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "m,n=[int(x) for x in input().split()]\nr=[int(x) for x in input().split()]\ncost=[int(x) for x in input().split()]\ncosta=[]\ni=1\nfor item in cost:\n    a=[item,i,r[i-1]]\n    costa.append(a)\n    i+=1\ncounter=0\ncosta.sort(reverse=True)\ndic={}\ni=0\nfor item in costa:\n    dic[item[1]]=i\n    i+=1\nindex=len(costa)-1\nfor item in range(n):\n    counter=0\n    a,b=[int(x) for x in input().split()]\n    if r[a-1]>=b:\n        counter+=cost[a-1]*b\n        r[a-1]-=b\n        costa[dic[a]][2]-=b\n    else:\n        i=index\n        counter+=cost[a-1]*r[a-1]\n        costa[dic[a]][2]=0\n        b-=r[a-1]\n        r[a-1]=0\n        while i>=0:\n            if costa[i][2]>=b:\n                counter+=costa[i][0]*b\n                r[costa[i][1]-1]-=b\n                costa[i][2]-=b\n                break\n            else:\n                counter+=costa[i][0]*costa[i][2]\n                r[costa[i][1]-1]=0\n                index-=1\n                b-=costa[i][2]\n                costa[i][2]=0\n            i-=1\n        else:\n            counter=0\n    print(counter)\n", "import sys\nn, m = [int(tmp) for tmp in sys.stdin.readline().split()]\na = [0] + [int(tmp) for tmp in sys.stdin.readline().split()]\nc = [0] + [int(tmp) for tmp in sys.stdin.readline().split()]\n\nco = [tmp for tmp in range(n+1)]\nco.sort(key=lambda z: c[z])\ncop = 1\nnb = False\nfor i in range(m):\n    t, d = [int(tmp) for tmp in sys.stdin.readline().split()]\n    if nb:\n        print(0)\n        continue\n    s = 0\n    botf = min([d, a[t]])\n    a[t] -= botf\n    s = botf * c[t]\n    brts = d - botf\n    while brts != 0:\n        botf = min([brts, a[co[cop]]])\n        if botf == 0:\n            cop += 1\n            if cop == n + 1:\n                nb = True\n                s = 0\n                break\n        a[co[cop]] -= botf\n        brts -= botf\n        s += botf * c[co[cop]]\n    print(s)\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,deque\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass Operation:\n    def __init__(self, name, function, function_on_equal, neutral_value=0):\n        self.name = name\n        self.f = function\n        self.f_on_equal = function_on_equal\ndef add_multiple(x, count):\n    return x * count\ndef min_multiple(x, count):\n    return x\ndef max_multiple(x, count):\n    return x\nsum_operation = Operation(\"sum\", sum, add_multiple, 0)\nmin_operation = Operation(\"min\", min, min_multiple, 1e9)\nmax_operation = Operation(\"max\", max, max_multiple, -1e9)\nclass SegmentTree:\n    def __init__(self,\n                 array,\n                 operations=[sum_operation, min_operation, max_operation]):\n        self.array = array\n        if type(operations) != list:\n            raise TypeError(\"operations must be a list\")\n        self.operations = {}\n        for op in operations:\n            self.operations[op.name] = op\n        self.root = SegmentTreeNode(0, len(array) - 1, self)\n    def query(self, start, end, operation_name):\n        if self.operations.get(operation_name) == None:\n            raise Exception(\"This operation is not available\")\n        return self.root._query(start, end, self.operations[operation_name])\n    def summary(self):\n        return self.root.values\n    def update(self, position, value):\n        self.root._update(position, value)\n    def update_range(self, start, end, value):\n        self.root._update_range(start, end, value)\n    def __repr__(self):\n        return self.root.__repr__()\nclass SegmentTreeNode:\n    def __init__(self, start, end, segment_tree):\n        self.range = (start, end)\n        self.parent_tree = segment_tree\n        self.range_value = None\n        self.values = {}\n        self.left = None\n        self.right = None\n        if start == end:\n            self._sync()\n            return\n        self.left = SegmentTreeNode(start, start + (end - start) // 2,\n                                    segment_tree)\n        self.right = SegmentTreeNode(start + (end - start) // 2 + 1, end,\n                                     segment_tree)\n        self._sync()\n    def _query(self, start, end, operation):\n        if end < self.range[0] or start > self.range[1]:\n            return None\n        if start <= self.range[0] and self.range[1] <= end:\n            return self.values[operation.name]\n        self._push()\n        left_res = self.left._query(start, end,\n                                    operation) if self.left else None\n        right_res = self.right._query(start, end,\n                                      operation) if self.right else None\n        if left_res is None:\n            return right_res\n        if right_res is None:\n            return left_res\n        return operation.f([left_res, right_res])\n    def _update(self, position, value):\n        if position < self.range[0] or position > self.range[1]:\n            return\n        if position == self.range[0] and self.range[1] == position:\n            self.parent_tree.array[position] = value\n            self._sync()\n            return\n        self._push()\n        self.left._update(position, value)\n        self.right._update(position, value)\n        self._sync()\n    def _update_range(self, start, end, value):\n        if end < self.range[0] or start > self.range[1]:\n            return\n        if start <= self.range[0] and self.range[1] <= end:\n            self.range_value = value\n            self._sync()\n            return\n        self._push()\n        self.left._update_range(start, end, value)\n        self.right._update_range(start, end, value)\n        self._sync()\n    def _sync(self):\n        if self.range[0] == self.range[1]:\n            for op in self.parent_tree.operations.values():\n                current_value = self.parent_tree.array[self.range[0]]\n                if self.range_value is not None:\n                    current_value = self.range_value\n                self.values[op.name] = op.f([current_value])\n        else:\n            for op in self.parent_tree.operations.values():\n                result = op.f(\n                    [self.left.values[op.name], self.right.values[op.name]])\n                if self.range_value is not None:\n                    bound_length = self.range[1] - self.range[0] + 1\n                    result = op.f_on_equal(self.range_value, bound_length)\n                self.values[op.name] = result\n    def _push(self):\n        if self.range_value is None:\n            return\n        if self.left:\n            self.left.range_value = self.range_value\n            self.right.range_value = self.range_value\n            self.left._sync()\n            self.right._sync()\n            self.range_value = None\n    def __repr__(self):\n        ans = \"({}, {}): {}\\n\".format(self.range[0], self.range[1],\n                                      self.values)\n        if self.left:\n            ans += self.left.__repr__()\n        if self.right:\n            ans += self.right.__repr__()\n        return ans\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n    \ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\n\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = True #Can not be used clubbed with TestCases\n\n\ndef main():\n    n,m = get_tuple()\n    remaining = get_list()\n    costs = get_list()\n    ki = [(ele,i) for i,ele in enumerate(costs)]\n    ki.sort()\n    ind = 0\n    res = []\n    #print(ki,costs,remaining)\n    for _ in range(m):\n        t,d = get_tuple() #Kind of food and no of dishes\n        t-=1\n        if remaining[t]>=d:\n            res.append(costs[t]*d)\n            remaining[t]-=d\n        else:\n            cost = remaining[t]*costs[t]\n            d-=remaining[t]\n            remaining[t]=0\n            while ind<n:\n                a_cost, a_index = ki[ind][0],ki[ind][1]\n                if remaining[a_index]>=d:\n                    cost+=costs[a_index]*d\n                    remaining[a_index]-=d\n                    d=0\n                    break\n                else:\n                    cost+=remaining[a_index]*costs[a_index]\n                    d-=remaining[a_index]\n                    remaining[a_index]=0\n                ind+=1\n            if d==0:\n                res.append(cost)\n            else:\n                res.append(0)\n    for i in res:\n        print(i)\n\n# -------------------------------------0-------------------------------- END=\n\n\nif TestCases: \n    for _ in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "def main():\n    n,m = list(map(int,input().split()))\n    remain = list(map(int,input().split()))\n    cost = list(map(int,input().split()))\n\n    stack = []\n\n    for i in range(n):\n        stack.append((cost[i],i))\n\n    stack.sort()\n    stack.reverse()\n\n    for i in range(m):\n        t,d = list(map(int,input().split()))\n        cst = 0\n        if remain[t-1] >= d:\n            remain[t-1] -= d\n            cst += d*cost[t-1]\n        else:\n            r = d - remain[t-1]\n            cst += remain[t-1]*cost[t-1]\n            remain[t-1] = 0\n            while r != 0:\n                if not stack:\n                    cst = 0\n                    break\n                c = stack.pop()\n                if remain[c[1]] >= r:\n                    cst += r*cost[c[1]]\n                    remain[c[1]] -= r\n                    r = 0\n                    if remain[c[1]] > 0:\n                        stack.append(c)\n                else:\n                    r -= remain[c[1]]\n                    cst += remain[c[1]]*cost[c[1]]\n                    remain[c[1]] = 0\n\n        print (cst)\n        \nmain()\n"]