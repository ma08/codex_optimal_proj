["# b\u3092\u5fc5\u8981\u306a\u3060\u3051(stride\u306e\u5206)\u53f3\u306b\u305a\u3089\u305b\u3070\u3088\u3044\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    ai, bi = 0, 0\n    stride = 0\n    while ai < n and bi < n:\n        ax, bx = a[ai], b[bi]\n        if ax == bx:\n            cnt = 2\n\n            ai += 1\n            while ai < n and a[ai] == ax:\n                cnt += 1\n                ai += 1\n\n            bi_copy = bi\n            bi += 1\n            while bi < n and b[bi] == bx:\n                cnt += 1\n                bi += 1\n\n            if cnt > n:\n                print('No')\n                return\n\n            if stride < ai - bi_copy:\n                stride = ai - bi_copy\n\n        elif ax < bx:\n            ai += 1\n        else:\n            bi += 1\n\n    print('Yes')\n    print(' '.join(map(str, b[n-stride:] + b[:n-stride])))\n\nmain()", "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ns = 0\nc = True\nfor i in range(n):\n    if i > 0:\n        if a[i] != a[i-1]:\n            s = 0\n    if a[i] != b[i]:\n        continue\n    else:\n        c = False\n        while s != n:\n            if a[i] != b[s] and a[s] != b[i]:\n                b[i], b[s] = b[s], b[i]\n                c = True\n                break\n            s += 1\n        if not c:\n            break\nif not c:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*b)", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn, = list(map(int,readline().split()))\n*a, = list(map(int,readline().split()))\n*b, = list(map(int,readline().split()))\nb = b[::-1]\n\nsame = [i for i in range(n) if a[i] == b[i]]\nif same:\n    # \u4ee5\u4e0b\u3059\u3079\u3066\u534a\u958b\u533a\u9593\n    v = a[same[0]] # \u91cd\u306a\u308b\u5024\u306f\u4e00\u7a2e\u985e\u3057\u304b\u306a\u3044\u3002\u3053\u308c\u3092 v \u3068\u304a\u304f\u3002\n    r = same[0]\n    s = same[-1]+1\n    vidx = [i for i in range(n) if a[i]==v or b[i]==v]\n    p = vidx[0]\n    q = vidx[-1]+1\n    # [p,q) \u3067\u304b\u3076\u308b\u3002[r,s)\u3067\u3069\u3061\u3089\u304b\u304c\u5024 v \u3092\u3068\u308b\n    if q > n-s+r+p: # \u304b\u3076\u308a\u3092\u5439\u3063\u98db\u3070\u305b\u306a\u3044\n        print(\"No\")\n        return\n    # \u304b\u3076\u3063\u305f\u90e8\u5206\u3092\u5de6\u3001\u53f3\u306b\u3088\u3051\u308b\n    if p >= s-r:\n        b[r:s],b[:s-r] = b[:s-r],b[r:s]\n    else:\n        b[r:r+p],b[:p] = b[:p],b[r:r+p]\n        b[r+p:s],b[n-s+r+p:] = b[n-s+r+p:], b[r+p:s]\n\nprint(\"Yes\")\nprint((*b))\n\n", "from collections import Counter, deque\n\nN = int(input())\nA = list(map(int, input().split())) + [N+1]\nB = list(map(int, input().split())) + [N+1]\nC = [0]\nD = [0]\n\nAB_cn = Counter(A+B)\nif AB_cn.most_common()[0][1] > N:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for i in range(N+1):\n        if len(C) != A[i]:\n            C.extend([i]*(A[i]-len(C)))\n        if len(D) != B[i]:\n            D.extend([i]*(B[i]-len(D)))\n    ans = 0\n    for i in range(N):\n        curr = C[i+1] - D[i]\n        ans= max(curr, ans)\n    B = B[:-1]\n    ans = [B[(i-ans)%N] for i in range(N)]\n \n    print((*ans))\n", "N=int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nB.sort(reverse=True)\nArev=sorted(A, reverse=True)\nBrev=sorted(B)\natai=0\ns=0\nfor i in range(len(A)):\n    if A[i]==B[i]:\n        atai=A[i]\n        s+=1\nC=[]\nfor i in range(len(A)):\n    C.append(A[i]-B[i])\nif s>0:\n    hajime=C.index(0)\nif s==0:\n    print(\"Yes\")\n    print(*B)\nelse:\n    Acount=A.count(atai)\n    Bcount=B.count(atai)\n    if N-Acount<Bcount:\n        print(\"No\")\n    else:\n        afirst=A.index(atai)\n        alast=N-1-Arev.index(atai)\n        bfirst=B.index(atai)\n        blast=N-1-Brev.index(atai)\n        t=min(afirst,bfirst)\n        if t>=s:\n            for i in range(0,s):\n                B[hajime+i]=B[i]\n                B[i]=atai\n        else:\n            for i in range(0,t):\n                B[hajime+i]=B[i]\n                B[i]=atai\n            ss=s-t\n            for i in range(0,ss):\n                B[hajime+t+i]=B[-i-1]\n                B[-i-1]=atai\n        print(\"Yes\")\n        print(*B)", "from collections import Counter\nfrom heapq import heapify, heappop, heappush\nfrom itertools import groupby\n\nn = int(input())\naaa = list(map(int, input().split()))\nbbb = list(map(int, input().split()))\n\ncnt_b = Counter(bbb)\nhq_both = []\nfree_a = []\nidx_a = {}\ncnt_a = {}\ni = 0\nfor a, itr in groupby(aaa):\n    cnt = len(list(itr))\n    idx_a[a] = i\n    cnt_a[a] = cnt\n    if a in cnt_b:\n        cnt_ab = cnt + cnt_b[a]\n        if cnt_ab > n:\n            print('No')\n            return\n        hq_both.append((-cnt_ab, a))\n    else:\n        free_a.append(a)\n    i += cnt\nheapify(hq_both)\n\nans = [-1] * n\nremaining = n\n\nwhile hq_both:\n    cnt_ab, b = heappop(hq_both)\n    cnt_ab = -cnt_ab\n    assert cnt_ab == cnt_a[b] + cnt_b[b]\n    assert cnt_ab <= remaining\n\n    cb = cnt_b[b]\n    while cb:\n        if hq_both:\n            _, a = heappop(hq_both)\n        else:\n            a = free_a.pop()\n        ca = cnt_a[a]\n\n        fill_len = min(ca, cb)\n        i = idx_a[a]\n        ans[i:i + fill_len] = [b] * fill_len\n        remaining -= fill_len\n        idx_a[a] += fill_len\n        cnt_a[a] -= fill_len\n        cnt_b[b] -= fill_len\n        cb -= fill_len\n\n        if cnt_a[a] > 0:\n            if a in cnt_b and cnt_b[a] > 0:\n                heappush(hq_both, (-(cnt_a[a] + cnt_b[a]), a))\n            else:\n                free_a.append(a)\n\n    free_a.append(b)\n\nfor b, cb in list(cnt_b.items()):\n    if cb == 0:\n        continue\n    while cb:\n        a = free_a.pop()\n        ca = cnt_a[a]\n\n        fill_len = min(ca, cb)\n        i = idx_a[a]\n        ans[i:i + fill_len] = [b] * fill_len\n        idx_a[a] += fill_len\n        cnt_a[a] -= fill_len\n        cb -= fill_len\n\n        if cnt_a[a] > 0:\n            free_a.append(a)\n\nprint('Yes')\nprint((*ans))\n", "# Reference: https://betrue12.hateblo.jp/entry/2020/09/15/180849\n\nimport sys\nfrom itertools import accumulate\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\nMOD = 1000000007\n\n\ndef main():\n    N = int(readline())\n    A = list(map(int, readline().split()))\n    B = list(map(int, readline().split()))\n\n    C = [0] * (N + 1)\n    D = [0] * (N + 1)\n\n    for i in range(N):\n        C[A[i]] += 1\n        D[B[i]] += 1\n\n    for i in range(1, N + 1):\n        if C[i] + D[i] > N:\n            print('No')\n            return\n\n    print('Yes')\n\n    C = list(accumulate(C))\n    D = list(accumulate(D))\n\n    B.reverse()\n\n    i = 0\n    while i < N and A[i] != B[i]:\n        i += 1\n\n    if i == N:\n        print((*B))\n        return\n\n    n = A[i]\n\n    idx_ng = []\n    idx_ok = []\n\n    for i in range(N):\n        if A[i] == n and B[i] == n:\n            idx_ng.append(i)\n        elif A[i] != n and B[i] != n:\n            idx_ok.append(i)\n\n    for ng, ok in zip(idx_ng, idx_ok):\n        B[ng], B[ok] = B[ok], B[ng]\n\n    print((*B))\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\ncnt = [0 for i in range(n+1)]\n\ndef lb(x):\n    l, r = 0, n\n    while l < r:\n        m = (l+r)//2\n        if a[m] < x:\n            l = m + 1\n        else:\n            r = m\n    return l\n\ndef ub(x):\n    l, r = 0, n\n    while l < r:\n        m = (l+r)//2\n        if a[m] <= x:\n            l = m + 1\n        else:\n            r = m\n    return l\n\nfor i in range(n):\n    l = lb(b[i])\n    r = ub(b[i])-1\n    if l > r:\n        continue\n    if l < i and i <= r:\n        cnt[l+n-i]+=1\n        cnt[0]+=1\n        cnt[r-i+1]-=1\n    elif i <= l:\n        cnt[l-i]+=1\n        cnt[r-i+1]-=1\n    elif i > r:\n        cnt[l+n-i]+=1\n        cnt[r+n+1-i]-=1\n\nres = 0\nans = -1\nfor i in range(n):\n    res += cnt[i]\n    if(res == 0):\n        ans = i\nif ans == -1:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for i in range(n):\n        print(b[(i-ans+n)%n],end=' ')", "def solve(n):\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))[::-1]\n    ind = [-1] * (n + 1)\n    for i in range(n):\n        if i == 0:\n            ind[b[i]] = 0\n        elif b[i] != b[i - 1]:\n            ind[b[i]] = i\n    cnt = 0\n    for i in range(n):\n        if a[i] != b[i]:\n            continue\n        else:\n            swap = 0\n            for j in range(b[i] - 1, 0, -1):\n                if ind[j] != -1 or ind[j] >= ind[j - 1]:\n                    swap = ind[j]\n                    ind[j] += 1\n                    break\n            if n <= swap:\n                swap = cnt\n                cnt += 1\n                cnt %= n\n            b[i], b[swap] = b[swap], b[i]\n    return a, b\n\n\ndef main():\n    n = int(input())\n    a, b = solve(n)\n    if all(a[i] != b[i] for i in range(n)):\n        print(\"Yes\")\n        print((\" \".join(map(str, b))))\n    else:\n        print(\"No\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#\u89e3\u8aac\u53c2\u7167\nn=int(input())\n*a,=map(int, input().split())\n*b,=map(int, input().split())\nshift=0\nfrom bisect import bisect_right,bisect_left\nfrom collections import Counter\nsb=Counter(b)\nsa=Counter(a)\nfor bi in sb:\n    if bi in sa:\n        if sa[bi]+sb[bi]>n:\n            print(\"No\")\n            return\nfor bi in sb:\n    lb=bisect_left(b,bi)\n    ra=bisect_right(a,bi)\n    if a[ra-1]==b[lb]:\n        shift=max(shift,ra-lb)\nans=[b[(i-shift)%n] for i in range(n)]##\nprint(\"Yes\")\nprint(*ans)", "n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nb = b[::-1]\n\nl = []\nnum = -1\nfor i in range(n):\n    if a[i] == b[i]:\n        l.append(i)\n        num = a[i]\n\nind = 0\nfor i in range(n):\n    if b[i] != num and a[i] != num and ind < len(l):\n        b[i],b[l[ind]] = b[l[ind]],b[i]\n        ind += 1\nif ind < len(l):\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*b)", "n=int(input())\ny=lambda:[*map(int,input().split())]\na,b=y(),y()[::-1]\nc=0\nfor i in range(n):\n  if a[i]==b[i]:c=a[i]\nif c<1:print(\"Yes\");print(' '.join(map(str,b)));return\nal,bl,ah,bh=[-1]*4\nea=eb=0\nfor i in range(n):\n  if al<0 and a[i]==c:al=i\n  if bl<0 and b[i]==c:bl=i\n  if al<0:ea+=1\n  if bl<0:eb+=1\n  if ah<0 and al>=0 and a[i]!=c:ah=i\n  if bh<0 and bl>=0 and b[i]!=c:bh=i\nif ah<0:ah=n\nif bh<0:bh=n\nt=ah+bh-al-bl\nif ah+bh-al-bl>n:print(\"No\");return\no1=min(bh-bl,ea,ea-eb+ah-al)\nprint(\"Yes\")\nprint(' '.join(map(str,[c]*o1+b[:eb]+b[eb+bh-bl:]+[c]*(bh-bl-o1))))", "import numpy as np\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\ncount = [0] * (N+1)\nfor a, b in zip(A, B):\n    count[a] += 1\n    count[b] += 1\n\nfor i in range(N+1):\n    if count[i] > N:\n        print('No')\n        return\n\ndiff = 0\nchecked = set()\nida = 0\nfor i, b in enumerate(B):\n    if b in checked:\n        continue\n    checked.add(b)\n    while ida < N and A[ida] <= b:\n        ida += 1\n    diff = max(diff, ida - i)\n\n\nidx = (np.arange(N) - diff) % N\nprint('Yes')\nprint(*np.array(B)[idx])", "N = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nR = list(reversed(B))\nflag = True\nfor i in range(N):\n  if A[i] == R[i]:\n    flag = False\n    break\nif flag:\n  print('Yes')\n  print(*R)\n  return\n\nl1 = B[N//2:]  + B[:N//2]\nl2 = B[N//2+1:]  + B[:N//2+1]\nflag1 = True\nfor i in range(N):\n  if A[i] == l1[i]:\n    flag1 = False\n    break\nflag2 = True\nfor i in range(N):\n  if A[i] == l2[i]:\n    flag2 = False\n    break\nif (flag1==False) and (flag2==False):\n  print('No')\nelif flag1 == True:\n  print('Yes')\n  print(*l1)\nelse:\n  print('Yes')\n  print(*l2)", "import bisect\nn = int(input())\nA = tuple(map(int, input().split()))\nB = tuple(map(int, input().split()))\nsA = set(A)\nsB = set(B)\nx = 0\nfor i in sA & sB:\n    r = bisect.bisect_right(A, i)\n    l = bisect.bisect_left(B, i)\n    x = max(x, r-l)\nans = B[-x:] + B[:-x]\nfor a, b in zip(A, ans):\n    if a == b:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")\n    print((*ans))\n", "import collections\nn=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nA=collections.Counter(a)\nB=collections.Counter(b)\n\ninf=10e18\ncc,cd=0,0\nR=0\nfor i in range(n+1):\n    if(A[i]+B[i]>n):\n        R=inf\n    else:\n        cc+=A[i]\n        R=max(R,cc-cd)\n        cd+=B[i]\nif(R==inf):\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    ans=\" \".join(map(str,b[-R:]+b[:-R]))\n    print(ans)", "#a,b,c,d = map(int, input().split())\nn = int(input())\na = list(map(int, input().strip().split()))\nb = list(map(int, input().strip().split()))\nb = b[::-1]\n\nfirst = 0\nlast = n-1\nfor i in range(n):\n\tif a[i] == b[i]:\n\t\tif i < last and b[last] != a[i]:\n\t\t\tb[i],b[last] = b[last],b[i]\n\t\t\tlast -= 1\n\t\telif first < i and b[first] != a[i]:\n\t\t\tb[i],b[first] = b[first],b[i]\n\t\t\tfirst += 1\n\nok = True\nfor i in range(n):\n\tok = ok and a[i] != b[i]\n\nif ok:\n\tprint(\"Yes\")\n\tfor i in range(n):\n\t\tprint(b[i],end=' ')\nelse:\n\tprint(\"No\")\n", "N = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nidx_B = 0\nma = 0\nfor idx_A, a in enumerate(A):\n    while idx_B < N and B[idx_B] < a:\n        idx_B += 1\n    if ma < idx_A - idx_B:\n        ma = idx_A - idx_B\nAns = (B+B)[N-ma-1:2*N-ma-1]\nfor a, b in zip(A, Ans):\n    if a == b:\n        print(\"No\")\n        return\nprint(\"Yes\")\nprint((\" \".join(map(str, Ans))))\n", "def f_contrast():\n    from collections import Counter\n    N = int(input())\n    A = [int(i) for i in input().split()]\n    B = [int(i) for i in input().split()]\n\n    c = [0] * (N + 1)\n    d = [0] * (N + 1)\n\n    for a, b in zip(A, B):\n        c[a] += 1\n        d[b] += 1\n\n    for s, t in zip(c, d):\n        if s + t > N:\n            return 'No'\n\n    for i in range(1, N + 1):\n        c[i] += c[i - 1]\n        d[i] += d[i - 1]\n\n    shift = max(c[i] - d[i - 1] for i in range(1, N + 1))\n    ans = [B[(i + N - shift) % N] for i in range(N)]\n    ret = ' '.join(map(str, ans))\n    return f'Yes\\n{ret}'\n\nprint(f_contrast())", "import sys\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nRB = B[::-1]\n\nstart = v = -1\nseq = 0\nfor i,(a,b) in enumerate(zip(A,RB)):\n    if a==b:\n        v = a\n        seq += 1\n        if start == -1:\n            start = i\n\nif v == -1:\n    print('Yes')\n    print(*RB)\n    return\n\nif A.count(v) + B.count(v) > N:\n    print('No')\n    return\n\nfrom bisect import bisect_left,bisect\nal = bisect_left(A,v)\nbr = bisect(B,v)\nrbl = N - br\n\nm = min(seq,start,al,rbl)\nRB[:m],RB[start:start+m] = RB[start:start+m],RB[:m]\nseq -= m\nstart += m\nif seq:\n    RB[start:start+seq],RB[-seq:] = RB[-seq:],RB[start:start+seq]\n\nassert all(a!=b for a,b in zip(A,RB))\nprint('Yes')\nprint(*RB)", "#!/usr/bin/env python\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    b = list(reversed(b))\n    bad = next((x for x, y in zip(a, b) if x == y), None)\n    if bad is None:\n        print('Yes')\n        print((' '.join(map(str, b))))\n    else:\n        l_1 = sum(1 for x, y in zip(a, b) if x < bad < y)\n        l_2 = sum(1 for x, y in zip(a, b) if x < y and bad in (x, y))\n        l_3 = sum(1 for x, y in zip(a, b) if x == y)\n        l_4 = sum(1 for x, y in zip(a, b) if x > y and bad in (x, y))\n        l_5 = sum(1 for x, y in zip(a, b) if x > bad > y and x != bad)\n        if l_3 > l_1 + l_5:\n            print('No')\n        else:\n            good_part = b[:l_1] + b[l_1 + l_2 + l_3 + l_4:]\n            bad_part = b[l_1 + l_2:l_1 + l_2 + l_3]\n            b[l_1 + l_2:l_1 + l_2 + l_3] = good_part[:l_3]\n            good_part[:l_3] = bad_part\n            b[:l_1] = good_part[:l_1]\n            b[l_1 + l_2 + l_3 + l_4:] = good_part[l_1:]\n            assert all(x != y for x, y in zip(a, b))\n            print('Yes')\n            print((' '.join(map(str, b))))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "def solve(n, a, b):\n    b.reverse()\n    l, r = 0, n-1\n    for i in range(n):\n        if a[i] == b[i]:\n            if (l < i) and (a[i] != b[l]) and (a[l] != b[i]):\n                b[l], b[i] = b[i], b[l]\n                l += 1\n            elif (i < r) and (a[i] != b[r]):\n                b[r], b[i] = b[i], b[r]\n                r -= 1\n            else:\n                return \"No\"\n    return \"\\n\".join([\n        \"Yes\",\n        \" \".join(map(str, b))\n    ])\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nprint(solve(n, a, b))", "from collections import Counter\nfrom heapq import heapify, heappop, heappush\nfrom itertools import groupby\n\nn = int(input())\naaa = list(map(int, input().split()))\nbbb = list(map(int, input().split()))\n\nidx_a = {}\ncnt_a = {}\ni = 0\nfor a, itr in groupby(aaa):\n    cnt = len(list(itr))\n    idx_a[a] = i\n    cnt_a[a] = cnt\n    i += cnt\n\ncnt_b = Counter(bbb)\nhq_both = []\nhq_free = []\nfor a, ca in list(cnt_a.items()):\n    if a in cnt_b:\n        hq_both.append((-(ca + cnt_b[a]), a))\n    else:\n        hq_free.append(a)\nheapify(hq_both)\n\n# A\u306e\u500b\u6570\u3068B\u306e\u500b\u6570\u306e\u548c\u304c\u5927\u304d\u3044\u3084\u3064\u304c\u30e4\u30d0\u3052\n\nans = [-1] * n\nremaining = n\n\nwhile hq_both:\n    cab, a1 = heappop(hq_both)\n    cab = -cab\n    assert cab == cnt_a[a1] + cnt_b[a1]\n\n    # print(a1, cab, cnt_a, cnt_b, ans, hq_both, hq_free)\n\n    if cab > remaining:\n        print('No')\n        return\n\n    cb = cnt_b[a1]\n    while cb:\n        if hq_both:\n            _, a2 = heappop(hq_both)\n            pop_from_que = True\n        else:\n            a2 = hq_free.pop()\n            pop_from_que = False\n        ca = cnt_a[a2]\n        # print('b', cb, a2, pop_from_que, ca <= cb, hq_both, hq_free)\n        if ca <= cb:\n            l = idx_a[a2]\n            ans[l:l + ca] = [a1] * ca\n            remaining -= ca\n            idx_a[a2] += ca\n            cnt_a[a2] -= ca\n            cnt_b[a1] -= ca\n            cb -= ca\n        else:\n            l = idx_a[a2]\n            ans[l:l + cb] = [a1] * cb\n            remaining -= cb\n            idx_a[a2] += cb\n            cnt_a[a2] -= cb\n            cnt_b[a1] -= cb\n            cb = 0\n            if pop_from_que:\n                heappush(hq_both, (-(cnt_a[a2] + cnt_b[a2]), a2))\n            else:\n                hq_free.append(a2)\n        # print('b', cb, a2, pop_from_que, ca <= cb, hq_both, hq_free)\n    hq_free.append(a1)\n\nfor b, cb in list(cnt_b.items()):\n    if cb == 0:\n        continue\n    while cb:\n        a = hq_free.pop()\n        ca = cnt_a[a]\n        if ca <= cb:\n            l = idx_a[a]\n            ans[l:l + ca] = [b] * ca\n            cb -= ca\n        else:\n            l = idx_a[a]\n            ans[l:l + cb] = [b] * cb\n            idx_a[a] += cb\n            cnt_a[a] -= cb\n            cb = 0\n            hq_free.append(a)\n\nprint('Yes')\nprint((*ans))\n", "N = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nfrom collections import Counter\n\ncA = Counter(A)\ncB = Counter(B)\n\nf = 0\n\nfor num, val in cA.items():\n    if num not in cB:\n        continue\n    else:\n        if cB[num] + val > N:\n            f = 1\n\ntpA = [-1] * (N + 1)\ntpB = [-1] * (N + 1)\na = A[0]\nb = B[0]\ntpB[b] = 0\nfor i in range(1, N):\n    if a != A[i]:\n        tpA[a] = i\n        a = A[i]\n    if b != B[i]:\n        b = B[i]\n        tpB[b] = i\ntpA[a] = N\n\n\nans = [0] * N\nif f == 1:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    t = 0\n    for i in range(N+1):\n        if tpA[i] >= 0 and tpB[i] >= 0:\n            t = max(t, tpA[i] - tpB[i])\n    for i in range(N):\n        ans[i+t-N] = B[i]\n    #print(tpA, tpB, t)\n    print(\" \".join([str(_) for _ in ans]))", "\nfrom collections import Counter\ndef resolve():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    CNT = Counter(A+B)\n    num = CNT.most_common()[0][1]\n    if num > N:\n        print(\"No\")\n        return \n\n    j, pre = 0, -1\n    for i in range(N):\n        if A[i] != pre:\n            j = 0\n        if A[i] == B[i]:\n            while j < N:\n                if A[i] != B[j] and A[j] != B[i]:\n                    B[i], B[j] = B[j], B[i]\n                    break\n                j += 1\n        pre = A[i]\n\n    print('Yes')\n    print(*B)\n\n\ndef __starting_point():\n    resolve()\n__starting_point()", "def solve(n, a, b):\n    b.reverse()\n    l, r = 0, n-1\n    for i in range(n):\n        if a[i] == b[i]:\n            if (l < i) and (a[i] != b[l]) and (a[l] != b[i]):\n                b[l], b[i] = b[i], b[l]\n                l += 1\n            elif (i < r) and (a[i] != b[r]) and (a[r] != a[i]):\n                b[r], b[i] = b[i], b[r]\n                r -= 1\n            else:\n                return \"No\"\n    return \"\\n\".join([\n        \"Yes\",\n        \" \".join(map(str, b))\n    ])\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nprint(solve(n, a, b))", "import sys\ninput = sys.stdin.readline\n\nN=int(input())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\nfrom collections import Counter\n\nCA=Counter(A)\nCB=Counter(B)\n\nH=[]\n\nfor ca in CA:\n    if CA[ca]>0 and CB[ca]>0:\n        if CA[ca]+CB[ca]>N:\n            print(\"No\")\n            return\n        H.append((-(CA[ca]+CB[ca]),ca))\n\nimport heapq\nheapq.heapify(H)\n\nANSDICT=dict()\n\nwhile len(H)>=2:\n    c1,x1=heapq.heappop(H)\n    c1=-c1\n\n    c2,x2=heapq.heappop(H)\n    c2=-c2\n\n    if x1 in ANSDICT:\n        ANSDICT[x1].append(x2)\n    else:\n        ANSDICT[x1]=[x2]\n\n    if x2 in ANSDICT:\n        ANSDICT[x2].append(x1)\n    else:\n        ANSDICT[x2]=[x1]\n\n    CA[x1]-=1\n    CA[x2]-=1\n    CB[x1]-=1\n    CB[x2]-=1\n\n    if CA[x1]>0 and CB[x1]>0:\n        heapq.heappush(H,(-(c1-2),x1))\n\n    if CA[x2]>0 and CB[x2]>0:\n        heapq.heappush(H,(-(c2-2),x2))\n\nANS=[-1]*N\n\nfor i in range(N):\n    a=A[i]\n    if a in ANSDICT and len(ANSDICT[a])!=0:\n        \n        x=ANSDICT[a].pop()\n        ANS[i]=x\n\nif H:\n    cc,xx=H[0]\n    cc=-cc\n\n    for i in range(N):\n        if ANS[i]==-1 and A[i]!=xx:\n            ANS[i]=xx\n            CB[xx]-=1\n\n            if CB[xx]==0:\n                break\n\nind=0\nfor cb in CB:\n    while CB[cb]!=0:\n        while ANS[ind]!=-1:\n            ind+=1\n        ANS[ind]=cb\n        CB[cb]-=1\n\nprint(\"Yes\")\nprint((*ANS))\n", "from collections import Counter\n\n\ndef solve(n, a_list, b_list):\n    count_a = Counter(a_list)\n    count_b = Counter(b_list)\n    count_ab = dict()\n    for k in list(count_a.keys()):\n        if k in list(count_b.keys()):\n            if count_a[k] + count_b[k] > n:\n                return [\"No\"]\n            count_ab[k] = min(count_a[k], count_b[k])\n\n    # move a\n    a_list_1 = []\n    a_list_2 = []\n    a = 0\n    for i in range(n):\n        if a != a_list[i]:\n            if a_list[i] in list(count_ab.keys()):\n                c = count_ab[a_list[i]]\n            else:\n                c = 0\n        a = a_list[i]\n        if c > 0:\n            a_list_1.append(a)\n            c -= 1\n        else:\n            a_list_2.append(a)\n    # move b\n    b_list_1 = []\n    b_list_2 = []\n    b = 0\n    for i in range(n):\n        if b != b_list[i]:\n            if b_list[i] in list(count_ab.keys()):\n                c = count_ab[b_list[i]]\n            else:\n                c = 0\n        b = b_list[i]\n        if c > 0:\n            b_list_1.append(b)\n            c -= 1\n        else:\n            b_list_2.append(b)\n    # print(a_list_1, a_list_2, b_list_1, b_list_2)\n    k_max = -1\n    if len(list(count_ab.values())) == 0:\n        return [\"Yes\", \" \".join([str(b) for b in b_list])]\n    d = max(count_ab.values())\n    for k in list(count_ab.keys()):\n        if count_ab[k] == d:\n            k_max = k\n            break\n    a_list_moved = a_list_1 + a_list_2\n    b_list_moved = b_list_1[d:] + b_list_1[:d] + b_list_2\n\n    # need to modify\n    if d * 2 > len(a_list_1):\n        # a includes many k_max\n        if count_a[k_max] >= count_b[k_max]:\n            # swap a\n            j = len(a_list_1)\n            for i in range(len(a_list_1)):\n                if a_list_moved[i] == b_list_moved[i] == k_max:\n                    while a_list_moved[j] == k_max:\n                        j += 1\n                    a_list_moved[i], a_list_moved[j] = a_list_moved[j], a_list_moved[i]\n        else:\n            # swap b\n            j = len(a_list_1)\n            for i in range(len(a_list_1)):\n                if a_list_moved[i] == b_list_moved[i] == k_max:\n                    while b_list_moved[j] == k_max:\n                        j += 1\n                    b_list_moved[i], b_list_moved[j] = b_list_moved[j], b_list_moved[i]\n    # print(a_list_moved, b_list_moved)\n    res_ab = list(sorted([(a, b) for a, b in zip(a_list_moved, b_list_moved)], key=lambda x: x[0]))\n    res_b = \" \".join([str(ab[1]) for ab in res_ab])\n    # print(res_b)\n    return [\"Yes\", res_b]\n\n\ndef main():\n    n = int(input())\n    a_list = list(map(int, input().split()))\n    b_list = list(map(int, input().split()))\n    res = solve(n, a_list, b_list)\n    for r in res:\n        print(r)\n\n\ndef test():\n    assert solve(6, [1, 1, 1, 2, 2, 3], [1, 1, 1, 2, 2, 3]) == [\"Yes\", \"2 2 3 1 1 1\"]\n    assert solve(3, [1, 1, 2], [1, 1, 3]) == [\"No\"]\n    assert solve(4, [1, 1, 2, 3], [1, 2, 3, 3]) == [\"Yes\", \"2 3 3 1\"]\n\n\ndef __starting_point():\n    test()\n    main()\n\n__starting_point()", "from collections import Counter\nimport numpy as np\n\n\ndef main():\n    n = int(input())\n    a = np.array([int(i) for i in input().split()])\n    b = np.array([int(i) for i in input().split()])\n    ca = Counter(a)\n    cb = Counter(b)\n    for k in list(cb.keys()):\n        if cb[k] > n - ca[k]:\n            print(\"No\")\n            return\n    while any(a == b):\n        s = max(ca[k] for k in list(cb.keys()))\n        b = np.roll(b, s)\n    print(\"Yes\")\n    print((*b))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import collections\n\nn=int(input())\narr1=list(map(int,input().split()))\narr2=list(map(int,input().split()))\ncnt1=collections.Counter(arr1)\ncnt2=collections.Counter(arr2)\nacum1=[0]*(n+1)\nacum2=[0]*(n+1)\nfor i in range(1,n+1):\n  acum1[i]=acum1[i-1]+cnt1[i]\n  acum2[i]=acum2[i-1]+cnt2[i]\nrotate=0\nfor i in range(1,n+1):\n  rotate=max(rotate,acum1[i]-acum2[i-1])\nans=[0]*n\nfor i in range(n):\n  ans[(i+rotate)%n]=arr2[i]\nfor i in range(n):\n  if arr1[i]==ans[i]:\n    print('No')\n    break\nelse:\n  print('Yes')\n  print(*ans)", "from collections import Counter\n\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC_A = Counter(A)\nC_B = Counter(B)\nfor k, v in list(C_A.items()):\n    if v + C_B[k] > N:\n        print(\"No\")\n        return\nB = B[::-1]\nsame_range = []\nfor i, (a, b) in enumerate(zip(A, B)):\n    if a == b:\n        same_range.append(i)\ni = 0\nwhile same_range:\n    v = B[same_range[0]]\n    if A[i] != v and B[i] != v:\n        j = same_range.pop()\n        B[i], B[j] = B[j], B[i]\n    i += 1\nprint(\"Yes\")\nprint((\" \".join(map(str, B))))\n", "N = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\ncount = [0] * (N+1)\nfor a, b in zip(A, B):\n    count[a] += 1\n    count[b] += 1\n\nfor i in range(N+1):\n    if count[i] > N:\n        print('No')\n        return\n\ndiff = 0\nchecked = set()\nida = 0\nfor i, b in enumerate(B):\n    if b in checked:\n        continue\n    checked.add(b)\n    while ida < N and A[ida] <= b:\n        ida += 1\n    diff = max(diff, ida - i)\n\n\nprint('Yes')\nprint(*(B[-diff:]+B[:-diff]))", "import sys\nINF = 1 << 60\nMOD = 10**9 + 7 # 998244353\nsys.setrecursionlimit(2147483647)\ninput = lambda:sys.stdin.readline().rstrip()\nfrom collections import Counter\nfrom random import randrange\ndef resolve():\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    if Counter(A + B).most_common()[0][1] > n:\n        print(\"No\")\n        return\n\n    for i in range(n):\n        if A[i] != B[i]:\n            continue\n        while 1:\n            j = randrange(0, n)\n            if A[i] != B[j] and A[j] != B[i]:\n                B[i], B[j] = B[j], B[i]\n                break\n    print(\"Yes\")\n    print(*B)\nresolve()", "import math\nimport numpy as np\nimport decimal\nimport collections\nimport itertools\nimport sys\nimport random\n#Union-Find\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.par = [-1 for i in range(self.n)]\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n    def unite(self, x, y):\n        p = self.find(x)\n        q = self.find(y)\n        if p == q:\n            return None\n        if p > q:\n            p, q = q, p\n        self.par[p] += self.par[q]\n        self.par[q] = p\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n    def size(self, x):\n        return -self.par[self.find(x)]\n\n#\u7d20\u6570\u95a2\u9023\ndef prime_numbers(x):\n    if x < 2:\n        return []\n    prime_numbers = [i for i in range(x)]\n    prime_numbers[1] = 0\n    for prime_number in prime_numbers:\n        if prime_number > math.sqrt(x):\n            break\n        if prime_number == 0:\n            continue\n        for composite_number in range(2 * prime_number, x, prime_number):\n            prime_numbers[composite_number] = 0\n    return [prime_number for prime_number in prime_numbers if prime_number != 0]\ndef is_prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3 or x == 5:\n        return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0:\n        return False\n    prime_number = 7\n    difference = 4\n    while prime_number <= math.sqrt(x):\n        if x % prime_number == 0:\n            return False\n        prime_number += difference\n        difference = 6 - difference\n    return True\n#Prime-Factorize\ndef prime_factorize(n):\n    res = []\n    while n % 2 == 0:\n        res.append(2)\n        n //= 2\n    f = 3\n    while f ** 2 <= n:\n        if n % f == 0:\n            res.append(f)\n            n //= f\n        else:\n            f += 2\n    if n != 1:\n        res.append(n)\n    return res\n#nCr\nmod = 10 ** 9 + 7\nclass nCr():\n    def __init__(self, n):\n        self.n = n\n        self.fa = [1] * (self.n + 1)\n        self.fi = [1] * (self.n + 1)\n        for i in range(1, self.n + 1):\n            self.fa[i] = self.fa[i - 1] * i % mod\n            self.fi[i] = pow(self.fa[i], mod - 2, mod)\n    def comb(self, n, r):\n        if n < r:return 0\n        if n < 0 or r < 0:return 0\n        return self.fa[n] * self.fi[r] % mod * self.fi[n - r] % mod\n#\u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5\ndef extgcd(a, b, d = 0):\n    g = a\n    if b == 0:\n        x, y = 1, 0\n    else:\n        x, y, g = extgcd(b, a % b)\n        x, y = y, x - a // b * y\n    return x, y, g\n#BIT\nclass BinaryIndexedTree():\n    def __init__(self, n):\n        self.n = n\n        self.BIT = [0] * (self.n + 1)\n    def add(self, i, x):\n        while i <= self.n:\n            self.BIT[i] += x\n            i += i & -i\n    def query(self, i):\n        res = 0\n        while i > 0:\n            res += self.BIT[i]\n            i -= i & -i\n        return res\n#Associative Array\nclass AssociativeArray():\n    def __init__(self, q):\n        self.dic = dict()\n        self.q = q\n    def solve(self):\n        for i in range(self.q):\n            Query = list(map(int, input().split()))\n            if Query[0] == 0:\n                x, y, z = Query\n                self.dic[y] = z\n            else:\n                x, y = Query\n                if y in self.dic:\n                    print(self.dic[y])\n                else:\n                    print(0)\n#Floor Sum\ndef floor_sum(n, m, a, b):\n    res = 0\n    if a >= m:\n        res += (n - 1) * n * (a // m) // 2\n        a %= m\n    if b >= m:\n        res += n * (b // m)\n        b %= m\n    y_max = (a * n + b) // m\n    x_max = y_max * m - b\n    if y_max == 0:\n        return res\n    res += y_max * (n + (-x_max // a))\n    res += floor_sum(y_max, a, m, (a - x_max % a) % a)\n    return res\n#Z-Algorithm\ndef z_algorithm(s):\n    str_len = len(s)\n    res = [0] * str_len\n    res[str_len - 1] = str_len\n    i, j = 1, 0\n    while i < str_len:\n        while i + j < str_len and s[i + j] == s[j]:\n            j += 1\n        res[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while i + k < str_len and j > res[k] + k:\n            res[i + k] = res[k]\n            k += 1\n        i += k\n        j -= k\n    return res\nclass Manacher():\n    def __init__(self, s):\n        self.s = s\n    def coustruct(self):\n        i, j = 0, 0 \n        s_len = len(self.s)\n        res = [0] * s_len\n        while i < s_len:\n            while i - j >= 0 and i + j < s_len and self.s[i - j] == self.s[i + j]:\n                j += 1\n            res[i] = j\n            k = 1\n            while i - k >= 0 and k + res[i - k] < j:\n                k += 1\n            i += k\n            j -= k\n#mod-sqrt\ndef mod_sqrt(a, p):\n    if a == 0:\n        return 0\n    if p == 2:\n        return 1\n    k = (p - 1) // 2\n    if pow(a, k, p) != 1:\n        return -1\n    while True:\n        n = random.randint(2, p - 1)\n        r = (n ** 2 - a) % p\n        if r == 0:\n            return n\n        if pow(r, k, p) == p - 1:\n            break\n    k += 1\n    w, x, y, z = n, 1, 1, 0\n    while k:\n        if k % 2:\n            y, z = w * y + r * x * z, x * y + w * z\n        w, x = w * w + r * x * x, 2 * w * x\n        w %= p\n        x %= p\n        y %= p\n        z %= p\n        k >>= 1\n    return y\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ncur = 0 \nbefore = 0\nfor i in range(n):\n    if before != a[i]:\n        cur = 0\n    if a[i] == b[i]:\n        while cur < n:\n            if a[i] != b[cur] and a[i] != a[cur]:\n                b[i], b[cur] = b[cur], b[i]\n                break\n            cur += 1\n        else:\n            print(\"No\");return\n    before = a[i]\nprint(\"Yes\")\nprint(*b)", "#!/usr/bin/env python3\nfrom collections import Counter\nINF = 1e12\n\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    lA = Counter(A)\n    lB = Counter(B)\n    if max(Counter(A+B).values()) > N:\n        print('No')\n        return\n\n    C = [0] * (N + 1)\n    D = [0] * (N + 1)\n    for i in range(N):\n        C[i + 1] = lA[i + 1] + C[i]\n        D[i + 1] = lB[i + 1] + D[i]\n    shift = - INF\n    for i in range(1, N + 1):\n        shift = max(shift, C[i] - D[i - 1])\n    print('Yes')\n    ans = (B + B + B)[N-shift:2*N-shift]\n    print((' '.join([str(a) for a in ans])))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import sys\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    alst = list(map(int, input().split()))\n    blst = list(map(int, input().split()))\n    a_s = [0 for _ in range(n)]\n    b_s = [0 for _ in range(n)]\n    for a in alst:\n        a_s[a - 1] += 1\n    for b in blst:\n        b_s[b - 1] += 1\n    for a, b in zip(a_s, b_s):\n        if a + b > n:\n            print(\"No\")\n            return\n    print(\"Yes\")\n    a_total = 0\n    b_total = 0\n    cor = -100000\n    for a, b in zip(a_s, b_s):\n        a_total += a\n        cor = max(cor, a_total - b_total)\n        b_total += b\n    ans = blst[-cor:] + blst[:-cor]\n    print(*ans)\n        \nmain()", "N = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nT = [(A[i], i) for i in range(N)]+[(B[i], N+i) for i in range(N)]\nT.sort()\n\nP = [-1]*(2*N)\nfor i in range(N):\n  if T[i][0]==T[i+N][0]:\n    print(\"No\")\n    return\n  P[T[i][1]] = T[i+N][1]\n  P[T[i+N][1]] = T[i][1]\n\nbp1 = N\nfor ap1 in range(N):\n  if P[ap1]//N==1:\n    continue\n  while P[bp1]//N==0:\n    bp1 += 1\n  ap2 = P[ap1]\n  bp2 = P[bp1]\n  if A[ap1]!=B[bp1-N] and A[ap2]!=B[bp2-N]:\n    P[ap1] = bp1\n    P[bp1] = ap1\n    P[ap2] = bp2\n    P[bp2] = ap2\n  else:\n    P[ap1] = bp2\n    P[bp1] = ap2\n    P[ap2] = bp1\n    P[bp2] = ap1\n\nprint(\"Yes\")\nprint((\" \".join(str(B[P[i]-N]) for i in range(N))))\n", "from sys import stdin\nfrom random import randint\nfrom time import time\ninput = lambda: stdin.readline().rstrip()\nstart = time()\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nb.reverse()\nok = 0\nt = time() - start\nwhile t < 1.8:\n    cnt = 0\n    for i in range(n):\n        if a[i] == b[i]:\n            rng = randint(0, n - 1)\n            b[i], b[rng] = b[rng], b[i]\n            cnt += 1\n    if cnt == 0:\n        ok = 1\n        break\n    t = time() - start\nif ok == 1:\n    print(\"Yes\")\n    print((*b))\nelse:\n    print(\"No\")\n", "from heapq import heappush, heappop\n\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nall_freq = {}\n\ncnt_b = [0] * 220000\nfor num in b:cnt_b[num] += 1\n\n\nfor num in a:\n    if num not in all_freq:\n        all_freq[num] = 0\n    all_freq[num] += 1\n\nfor num in b:\n    if num not in all_freq:\n        all_freq[num] = 0\n    all_freq[num] += 1\n\nheap = []\n\nfor num, freq in list(all_freq.items()):\n    if freq > n:\n        print(\"No\")\n        return\n    if cnt_b[num] > 0:\n        heappush(heap, (-freq, num))\n\nans = []\n\ndef get_max():\n    (freq, num) = heappop(heap)\n    freq = -freq\n    while all_freq[num] != freq:\n        (freq, num) = heappop(heap)\n        freq = -freq\n\n    return num\n\nfor num in a:\n    most_freq_num = get_max()\n    if most_freq_num != num:\n        ans.append(most_freq_num)\n        all_freq[most_freq_num] -= 1\n        cnt_b[most_freq_num] -= 1\n        if cnt_b[most_freq_num] > 0:\n            heappush(heap, (-all_freq[most_freq_num], most_freq_num))\n    else:\n        second_freq_num = get_max()\n        heappush(heap, (-all_freq[most_freq_num], most_freq_num))\n        ans.append(second_freq_num)\n        all_freq[second_freq_num] -= 1\n        cnt_b[second_freq_num] -= 1\n        if cnt_b[second_freq_num] > 0:\n            heappush(heap, (-all_freq[second_freq_num], second_freq_num))\n    all_freq[num] -= 1\n    if cnt_b[num] == 0:continue\n    heappush(heap, (-all_freq[num], num))\n\nprint(\"Yes\")\nprint((*ans))\n", "import sys\npin=sys.stdin.readline\n\nN=int(pin())\nA=list(map(int,pin().split()))\nB=list(map(int,pin().split()))\nC=list(reversed(B))\n\nfor i in range(N):\n  if A[i]==C[i]:\n    break\nelse:\n  print(\"Yes\")\n  for k in C:\n    sys.stdout.write(f\"{k} \")\n  print()\n  return\nD=B[N//2:]+B[:N//2]\nfor j in range(N):\n  if A[j]==D[j]:\n    print(\"No\")\n    break\nelse:\n  print(\"Yes\")\n  for l in D:\n    sys.stdout.write(f\"{l} \")\n  print()\n  return\n", "from collections import Counter\nimport sys\nimport random\n \nN = int(input())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nca = Counter(A)\ncb = Counter(B)\nfor i in range(N+1):\n    if ca[i] + cb[i] > N:\n        print('No')\n        return\n\nC = [0] * (N+1)\nD = [0] * (N+1)\n\nfor i in range(N):\n    C[i+1] += C[i] + ca[i+1]\n    D[i+1] += D[i] + cb[i+1]\n\nx = 0\n\nfor i in range(N):\n    x = max(x, C[i+1] - D[i])\n\nans = [B[(i-x)%N] for i in range(N)]\n\nprint('Yes')\nprint(*ans)", "import collections\n\nN=int(input())\nA=list(map(int,input().split()))\nB=list(map(int,input().split()))\n\nAtmp = 0\nBtmp = 0\n\nINF=10e18\n\n\nC=collections.Counter(A)\nD=collections.Counter(B)\n\ncurrentC = 0\ncurrentD = 0\n\nrotation = 0\n\n\n\nfor n in range(N+1):\n\n\tif N < C[n] + D[n]:\n\t\trotation = INF\n\t\tbreak\n\n\tcurrentC += C[n]\n\trotation = max( rotation, currentC - currentD )\n\tcurrentD += D[n]\n\nif rotation == INF:\n\tprint(\"No\")\nelse:\n\tprint(\"Yes\")\n\t\n\tprint((\" \".join(map(str,B[-rotation:] + B[:-rotation]))))\n\n\n\n\n", "n=int(input())\na=[int(_) for _ in input().split()]\nb=[int(_) for _ in input().split()]\n\nd_a={}\nd_b={}\n\nfor i in range(-1,n):\n    d_a[i]=0\n    d_b[i]=0\n\nfor i in range(n):\n    d_a[a[i]-1]+=1\n    d_b[b[i]-1]+=1\n\ndiff=0\nc,d=0,0\nfor i in range(n):\n    if d_a[i]+d_b[i]>n:\n        print(\"No\")\n        return\n    c+=d_a[i]\n    d+=d_b[i-1]\n    diff = max(diff,c-d)\nprint(\"Yes\")\n# for i in range(n):\n#     print(a[i],end=\" \")\n# print()\nfor i in range(n):\n    print(b[(i-diff)%n],end=\" \")\nprint()", "import bisect, heapq\nN = int(input())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\n\nfor i in range(1,N+1):\n    a = bisect.bisect_right(A,i) - bisect.bisect_left(A,i)\n    b = bisect.bisect_right(B,i) - bisect.bisect_left(B,i)\n\n    if a + b > N:\n        print(\"No\")\n        return\n\nB = B[::-1]\n\nj, bef = 0, -1\nfor i in range(N):\n    if A[i] != bef:\n        j = 0\n    if A[i] == B[i]:\n        while j < N:\n            if A[j] != B[i] and B[j] != A[i]:\n                B[i], B[j] = B[j], B[i]\n                break\n            j += 1\n    bef = A[i]\n\nprint(\"Yes\")\nfor b in B:\n    print(b,end=\" \")\nprint(\"\")", "import sys\n\nsys.setrecursionlimit(10**6)\nint1 = lambda x: int(x)-1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef lr(xx):\n    ll=[-1]*(n+1)\n    rr=[-1]*(n+1)\n    for i,x in enumerate(xx):\n        if ll[x]==-1:ll[x]=i\n        if i==n-1 or x!=xx[i+1]:rr[x]=i+1\n    return ll,rr\n\nn=II()\naa=LI()\nbb=LI()\nall,arr=lr(aa)\nbll,brr=lr(bb)\n# print(all,arr)\nca=[0]*(n+1)\ncb=[0]*(n+1)\nfor a in aa:ca[a]+=1\nfor b in bb:cb[b]+=1\nfor i in range(n+1):\n    if ca[i]+cb[i]>n:\n        print(\"No\")\n        return\nng=[0]*(n+1)\nfor al,ar,bl,br in zip(all,arr,bll,brr):\n    if al==-1 or bl==-1:continue\n    if bl<ar:\n        mn=max(0,al-br+1)\n        mx=ar-bl\n        ng[mn]+=1\n        ng[mx]-=1\n    else:\n        mn=max(0,al+n-br+1)\n        mx=min(n,ar+n-bl)\n        ng[mn]+=1\n        ng[mx]-=1\n# print(ng)\nfor i in range(n):ng[i+1]+=ng[i]\nshift=-1\nfor i in range(n):\n    if ng[i]==0:\n        shift=i\n        break\nans=bb[-shift:]+bb[:-shift]\nprint(\"Yes\")\nprint(*ans)\n", "#!/usr/bin/env python3\nfrom itertools import accumulate\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nidx_B = 0\nma = 0\nfor idx_A, a in enumerate(A):\n    while idx_B < N and B[idx_B] < a:\n        idx_B += 1\n    if ma < idx_A - idx_B:\n        ma = idx_A-idx_B\n\nAns = (B+B)[N-ma-1:2*N-ma-1]\n\nfor a, b in zip(A, Ans):\n    if a == b:\n        print(\"No\")\n        return\nprint(\"Yes\")\nprint((*Ans))\n", "from collections import Counter, deque\n\nN = int(input())\nA = list(map(int, input().split())) + [N+1]\nB = list(map(int, input().split())) + [N+1]\nC = [0]\nD = [0]\n\nAB_cn = Counter(A+B)\nif AB_cn.most_common()[0][1] > N:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for i in range(N+1):\n        if len(C) != A[i]:\n            C.extend([i]*(A[i]-len(C)))\n        if len(D) != B[i]:\n            D.extend([i]*(B[i]-len(D)))\n    ans = -100000000000000000\n    for i in range(N):\n        curr = C[i+1] - D[i]\n        ans= max(curr, ans)\n    B = B[:-1]\n    print((*[B[(i-ans)%N] for i in range(N)]))\n\n", "N = int(input())\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nC = [0]*N\nD = [0]*N\nc = d = 0\nfor i in range(N):\n    a = A[i]\n    b = B[i]\n    if C[a-1]==0:\n        for j in range(c,a): C[j]=C[c]\n        c=a-1\n        C[c]=C[c-1]+1\n    else: C[a-1]+=1\n    if D[b-1]==0:\n        for j in range(d,b): D[j]=D[d]\n        d=b-1\n        D[d]=D[d-1]+1\n    else: D[b-1]+=1\nfor j in range(c,N): C[j]=C[c]\nfor j in range(d,N): D[j]=D[d]\nE = [0]*N\nfor i in range(N):\n    if i==0: E[i] = C[i] + D[i]\n    else:\n        E[i] = C[i]-C[i-1] + D[i]-D[i-1]\n#print(C,D,E)\nif max(E)>N: print(\"No\")\nelse:\n    for i in range(N):\n        if i==0: x=C[i]\n        if x < C[i]-D[i-1]: x = C[i]-D[i-1]\n    B_ = [0]*N\n    #print(x)\n    for i in range(N):\n        B_[(i+x)%N] = B[i]\n    print(\"Yes\")\n    print(*B_,sep=' ')", "import sys\nimport collections\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n\n    ac = collections.Counter(A)\n    bc = collections.Counter(B)\n\n    for i in range(1, N + 1):\n        if ac[i] + bc[i] > N:\n            print(\"No\")\n            return\n\n    ma = 0\n    cnta = 0\n    cntb = 0\n    for i in range(1, N + 1):\n        cnta += ac[i]\n        cntb += bc[i - 1]\n        ma = max(ma, cnta - cntb)\n\n    print(\"Yes\")\n    ans = []\n    for i in range(N):\n        ans.append(B[(i + N - ma) % N])\n    print((*ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import numpy as np\nimport sys \nread = sys.stdin.readline\nn = int(input())\na = np.fromstring(read(), dtype=np.int32, sep=' ')\nb = np.fromstring(read(), dtype=np.int32, sep=' ')[::-1]\n\nkokan = []\nsame = -1\nfor i in range(n):\n    if a[i] == b[i]:\n        same = a[i]\nif same == -1:\n    print('Yes')\n    print(*b)\n    return\n\nfor i in range(n):\n    if a[i] != b[i] and a[i] != same and b[i] != same:\n        kokan.append(i)\nfor i in range(n):\n    if a[i] == b[i]:\n        if len(kokan) == 0:\n            print('No')\n            return\n        else:\n            j = kokan[-1]\n            b[i], b[j] = b[j], b[i] \n            kokan.pop()\nprint('Yes')\nprint(*b)", "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nb.reverse()\nc=[0]*(n+1)\nfor i in a:\n  c[i]+=1\nfor i in b:\n  c[i]+=1\nif n<max(c):\n  print('No')\n  return\nl=0\nwhile l<n and a[l]!=b[l]:\n  l+=1\ni=0\nwhile l<n and a[l]==b[l]:\n  while a[i]==b[l] or a[l]==b[i]:\n    i+=1\n  b[i],b[l]=b[l],b[i]\n  l+=1\nprint('Yes')\nprint(' '.join([str(i) for i in b]))", "#!/usr/bin/env python3\n\nimport collections\nimport sys\ninput=sys.stdin.readline\n\nn=int(input())\narr1=list(map(int,input().split()))\narr2=list(map(int,input().split()))\ncnt1=collections.Counter(arr1)\ncnt2=collections.Counter(arr2)\ntmp=[[key,cnt1[key]] for key in cnt1.keys()]\ntmp=sorted(tmp,reverse=True,key=lambda x:x[1])\narr3=[]\nfor key,cnt in tmp:\n    for _ in range(cnt):\n        arr3.append(key)\ncnt1=collections.Counter(arr3)\nans=[0]*n\nacum=0\npos=0\nblank=0\nok=0\nhead=[]\nfor key in cnt1.keys():\n    tcnt1=cnt1[key]\n    tcnt2=cnt2[key]\n    acum+=tcnt1\n    tpos=max(acum,pos)\n    tmp=n-min(tpos,n)\n    if blank+tmp<tcnt2:\n        print('No')\n        return\n    blank=min(tpos,n)-ok\n    remain=tcnt2\n    #print(key,blank,remain)\n    for i in range(tpos,n):\n        if remain==0:\n            break\n        ans[i]=key\n        ok+=1\n        remain-=1\n        cnt2[key]-=1\n    for _ in range(remain):\n        head.append(key)\n        cnt2[key]-=1\n    pos=min(tpos+tcnt2,n)\n    #print(ans,head,pos)\nfor key in cnt2.keys():\n    if cnt2[key]==0:\n        continue\n    for _ in range(cnt2[key]):\n        head.append(key)\npos=0\nfor i in range(n):\n    if ans[i]==0:\n        ans[i]=head[pos]\n        pos+=1\ntmp=[[ans[i],arr3[i]] for i in range(n)]\ntmp=sorted(tmp,key=lambda x:x[1])\nans=[tmp[i][0] for i in range(n)]\nprint('Yes')\nprint(*ans)", "import sys\nimport collections\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n\n    ac = collections.Counter(A)\n    bc = collections.Counter(B)\n\n    for i in range(1, N + 1):\n        if ac[i] + bc[i] > N:\n            print(\"No\")\n            return\n\n    ma = 0\n    cnta = 0\n    cntb = 0\n    for i in range(1, N + 1):\n        cnta += ac[i]\n        cntb += bc[i - 1]\n        ma = max(ma, cnta - cntb)\n\n    print(\"Yes\")\n\n    ans = B[N - ma:] + B[:N - ma]\n    print((*ans))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n\nimport heapq\nimport collections\nimport sys\ninput=sys.stdin.readline\n\nn=int(input())\narr1=list(map(int,input().split()))\narr2=list(map(int,input().split()))\ncnt1=collections.Counter(arr1)\ncnt2=collections.Counter(arr2)\ntmp=[[key,cnt1[key]] for key in cnt1.keys()]\ntmp=sorted(tmp,reverse=True,key=lambda x:x[1])\narr3=[]\nfor key,cnt in tmp:\n  for _ in range(cnt):\n    arr3.append(key)\ncnt3=collections.Counter(arr3)\nans=[0]*n\nacum=0\npos=0\nhead=[]\ntail=[]\nfor key in cnt3.keys():\n    tcnt1=cnt3[key]\n    tcnt2=cnt2[key]\n    if tcnt1+tcnt2>n:\n        print('No')\n        return\n    acum+=tcnt1\n    tpos=max(acum,pos)\n    remain=tcnt2\n    #print(key,blank,remain)\n    for i in range(tpos,n):\n        if remain==0:\n            break\n        ans[i]=key\n        remain-=1\n        cnt2[key]-=1\n    for _ in range(remain):\n      if tpos!=pos:\n        head.append(key)\n      else:\n        tail.append(key)\n      cnt2[key]-=1\n    pos=min(tpos+tcnt2,n)\n    #print(ans,head,pos)\nfor key in cnt2.keys():\n    if cnt2[key]==0:\n        continue\n    for _ in range(cnt2[key]):\n        tail.append(key)\npos=0\nhead+=tail\nfor i in range(n):\n    if ans[i]==0:\n        ans[i]=head[pos]\n        pos+=1\nq=[]\nfor i in range(n):\n  heapq.heappush(q,(arr3[i],ans[i]))\nfor i in range(n):\n  _,val=heapq.heappop(q)\n  ans[i]=val\nprint('Yes')\nprint(*ans)", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n#\n#\n# @stop_watch\ndef solve(N, Ai, Bi):\n    Ci = [0] * (N + 1)\n    Di = [0] * (N + 1)\n    j = 0\n    k = 0\n    for i in range(1, N + 1):\n        while j < N and Ai[j] <= i:\n            j += 1\n        Ci[i] = j\n        while k < N and Bi[k] <= i:\n            k += 1\n        Di[i] = k\n    # print(Ci)\n    # print(Di)\n    for i in range(1, N + 1):\n        if Ci[i] - Ci[i - 1] + Di[i] - Di[i - 1] > N:\n            print('No')\n            return\n    x = 0\n    for i in range(1, N + 1):\n        x = max(x, Ci[i] - Di[i - 1])\n    print('Yes')\n    # print(x)\n    # print(' '.join([str(a) for a in Ai]))\n    print((' '.join([str(Bi[(N - x + i) % N]) for i in range(N)])))\n\n\ndef __starting_point():\n    # S = input()\n    N = int(input())\n    # N, M = map(int, input().split())\n    Ai = [int(i) for i in input().split()]\n    Bi = [int(i) for i in input().split()]\n    # ABi = [[int(i) for i in input().split()] for _ in range(N)]\n    solve(N, Ai, Bi)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "from collections import Counter, deque\n\nN = int(input())\nA = list(map(int, input().split())) + [N+1]\nB = list(map(int, input().split())) + [N+1]\nC = [0]\nD = [0]\n\nAB_cn = Counter(A+B)\nif AB_cn.most_common()[0][1] > N:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    for i in range(N+1):\n        if len(C) != A[i]:\n            C.extend([i]*(A[i]-len(C)))\n        if len(D) != B[i]:\n            D.extend([i]*(B[i]-len(D)))\n    ans = 0\n    for i in range(N):\n        curr = C[i+1] - D[i]\n        ans= max(curr, ans)\n    B = B[:-1]\n    print(*[B[(i-ans)%N] for i in range(N)])", "import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return list(map(int, input().split()))\ndef MI1(): return list(map(int1, input().split()))\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print((k.join(list(map(str, lst)))))\nINF = float('inf')\n# from math import ceil, floor, log2\n# from collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\n\ndef solve():\n    N = II()\n    A = LI()\n    B = sorted(LI(), reverse=True)\n    tmp = []\n    for i in range(N):\n        if A[i] == B[i]:\n            tmp.append((i, A[i]))\n\n    j = 0\n    while tmp:\n        idx, x = tmp.pop()\n        for i in range(j, N):\n            b = B[i]\n            j = i + 1\n            if i == idx: continue\n            if b != x and x != A[i]:\n                B[i], B[idx] = B[idx], B[i]\n                break\n        else:\n            print('No')\n            return\n    print('Yes')\n    print((*B))\n\n\ndef __starting_point():\n    solve()\n\n\n__starting_point()", "N = int(input())\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\n\na = [0]*(N + 1)\nb = [0]*(N + 1)\nfor i in range(N):\n    a[A[i]] += 1\n    b[B[i]] += 1\n\nok = True\nfor i in range(1, N + 1):\n    if a[i] + b[i] > N:\n        ok = False\n\nsa = [0]*(N + 1)\nsb = [0]*(N + 1)\nfor i in range(N):\n    sa[i + 1] = sa[i] + a[i + 1]\n    sb[i + 1] = sb[i] + b[i + 1]\n\nans = 0\nfor i in range(N):\n    ans = max(ans, sa[i + 1] - sb[i])\n\nif ok:\n    print(\"Yes\")\n    for i in range(N):\n        print(B[(i + N - ans) % N], end='')\n        if i == N - 1:\n            print('')\n        else:\n            print(' ', end='')\nelse:\n    print(\"No\")", "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce, lru_cache\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return list(zip(*(MAP() for _ in range(n))))\nsys.setrecursionlimit(10 ** 9)\nINF = 10**6#float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\n#from decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nN = INT()\nA = LIST()\nB = LIST()\n\nCA = Counter(A)\nCB = Counter(B)\n\nfor k in list(CB.keys()):\n\tif CB[k] > N-CA[k]:\n\t\tprint(\"No\")\n\t\treturn\nelse:\n\tprint(\"Yes\")\n\nB = B[::-1]\n\nj = 0\njdx = 1\n\nfor i in range(N):\n\tif A[i] == B[i]:\n\t\tif B[i] == B[j] or B[i] == A[j]:\n\t\t\tj = -1\n\t\t\tjdx = -1\n\t\tB[i], B[j] = B[j], B[i]\n\t\tj += jdx\n\nprint((*B))\n\n\n", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn, = map(int,readline().split())\n*a, = map(int,readline().split())\n*b, = map(int,readline().split())\nb = b[::-1]\n\nsame = [i for i in range(n) if a[i] == b[i]]\nif same:\n    v = a[same[0]] # b \u3092\u9006\u9806\u306b\u3057\u305f\u306e\u3067\u3001\u91cd\u306a\u308b\u5024\u306f\u4e00\u7a2e\u985e\u3057\u304b\u306a\u3044\u3002\u3053\u308c\u3092 v \u3068\u304a\u304f\u3002\n    r = same[0]\n    s = same[-1]+1\n    notv = [i for i in range(n) if a[i]!=v and b[i]!=v] # \u3069\u3063\u3061\u3082v\u3068\u304b\u3076\u3089\u306a\u3044 index\n    if len(same) > len(notv):\n        print(\"No\")\n        return\n    \n    for i,j in zip(same,notv):\n        b[i],b[j] = b[j],b[i]\n\nprint(\"Yes\")\nprint(*b)", "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nb.reverse()\nc=[0]*(n+1)\nfor i in a:\n  c[i]+=1 #\u540c\u3058\u6570\u304c\u3044\u304f\u3064\u3042\u308b\u304b\nfor i in b:\n  c[i]+=1\nif max(c)>n:\n  print('No')\n  return\nl=0\nwhile l<n and a[l]!=b[l]: #\u304b\u3076\u308b\u307e\u3067\u306e\u6570\n  l+=1\ni=0\nwhile l<n and a[l]==b[l]: #\u304b\u3076\u308a\u59cb\u3081\u3066\u304b\u3089\u304b\u3076\u308a\u7d9a\u3051\u308b\u9650\u308a\n  while a[i]==b[l] or a[l]==b[i]: #i\u756a\u76ee\u3068\u5165\u308c\u66ff\u3048\u3066\u3082\u304b\u3076\u308b\u5834\u5408\n    i+=1\n  b[i],b[l]=b[l],b[i] #\u304b\u3076\u3089\u306a\u3044\u3053\u3068\u3092\u78ba\u8a8d\u3057\u3066\u304b\u3089\u5165\u308c\u66ff\u3048\n  l+=1\nprint('Yes')\nprint(' '.join([str(i) for i in b]))", "n = int(input())\nlst_a = [int(i) for i in input().split()]\nlst_b = [int(i) for i in input().split()]\nj = 0\nflag = True\nfor i in range(n):\n  if i > 0:\n    if lst_a[i] != lst_a[i - 1]:\n      j = 0\n  if lst_a[i] != lst_b[i]:\n    continue\n  else:\n    flag = False\n    while j != n:\n      if lst_a[i] != lst_b[j] and lst_a[j] != lst_b[i]:\n        lst_b[i], lst_b[j] = lst_b[j], lst_b[i]\n        flag = True\n        break\n      j += 1\n    if not flag:\n      break\nif not flag:\n  print('No')\nelse:\n  print('Yes')\n  lst_b = [str(i) for i in lst_b]\n  print(' '.join(lst_b))", "from collections import Counter\nimport numpy as np\n\n\ndef main():\n    n = int(input())\n    a = np.array([int(i) for i in input().split()])\n    b = np.array([int(i) for i in input().split()])\n    ca = Counter(a)\n    cb = Counter(b)\n    for k in list(cb.keys()):\n        if cb[k] > n - ca[k]:\n            print(\"No\")\n            return\n    shift = max(ca[k] for k in list(cb.keys()))\n    while any(a == b):\n        b = np.roll(b, shift)\n    print(\"Yes\")\n    print((*b))\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn, = list(map(int,readline().split()))\n*a, = [2*int(x) for x in readline().split()]\n*b, = [2*int(x)+1 for x in readline().split()]\n\nc = sorted(a+b)\nres = []\naa = []\nbb = []\nfor x,y in zip(c[:n],c[n:]):\n    if x%2 == 0:\n        if y%2 == 0:\n            aa.append((x//2,y//2))\n        else:\n            res.append((x//2,y//2))\n    else:\n        if y%2 == 0:\n            res.append((y//2,x//2))\n        else:\n            bb.append((x//2,y//2))\n\nwhile aa:\n    p,q = aa.pop()\n    r,s = bb.pop()\n    if p != r and q != s:\n        res.append((p,r))\n        res.append((q,s))\n    else:\n        res.append((p,s))\n        res.append((q,r))\n\nfrom operator import itemgetter\nres.sort(key = itemgetter(0))\n\nfor x,y in res:\n    if x==y:\n        print(\"No\")\n        return\nprint(\"Yes\")\nans = [y for x,y in res]\nprint((*ans))\n\n\n", "def solve():    \n    n = int(input())\n    a = list(map(int,input().split()))\n    b = list(map(int,input().split()))\n    b = b[::-1]\n    \n    l = []\n    num = -1\n    for i in range(n):\n        if a[i] == b[i]:\n            l.append(i)\n            num = a[i]\n    \n    ind = 0\n    for i in range(n):\n        if b[i] != num and a[i] != num and ind < len(l):\n            b[i], b[l[ind]] = b[l[ind]], b[i]\n            ind += 1\n    \n    if ind < len(l):\n        print('No')\n    else:\n        print('Yes')\n        print(*b)\n    \n                        \ndef __starting_point():\n    solve()\n__starting_point()", "N = int(input())\n\nA_list = list(map(int, input().split()))\nB_list = list(map(int, input().split()))\n\ntotal_table = {}\n\ndef make_table(l):\n\ttable = {}\n\tfor v in l:\n\t\tif v in table:\n\t\t\ttable[v] += 1\n\t\telse:\n\t\t\ttable[v] = 1\n\t\tif v in total_table:\n\t\t\ttotal_table[v] += 1\n\t\telse:\n\t\t\ttotal_table[v] = 1\n\treturn table\n\nA_table = make_table(A_list)\nB_table = make_table(B_list)\n\ntotal_list = []\nfor v, c in list(total_table.items()):\n\ttotal_list.append((c, v))\n\ntotal_list.sort()\ntotal_list.reverse()\n\nA_head = []\nA_tail = []\nB_head = []\nB_tail = []\nfor c, v in total_list:\n\ta = A_table[v] if v in A_table else 0\n\tb = B_table[v] if v in B_table else 0\n#\tprint(c, a, b)\n\twhile a > 0 and len(A_head) + len(B_head) < N:\n\t\tA_head.append(v)\n\t\ta -= 1\n\t\n\twhile b > 0 and len(A_head) + len(B_head) < N:\n\t\tB_head.append(v)\n\t\tb -= 1\n\t\n\twhile a > 0:\n\t\tA_tail.append(v)\n\t\ta -= 1\n\t\n\twhile b > 0:\n\t\tB_tail.append(v)\n\t\tb -= 1\n\n#print(A_head)\n#print(A_tail)\n#print(B_head)\n#print(B_tail)\n\nA_tail.reverse()\nB_head.reverse()\n\nA_list = A_head + A_tail\nB_list = B_tail + B_head\n\n#print(A_list)\n#print(B_list)\n\ndef check():\n\tfor a, b in zip(A_list, B_list):\n\t\tif a == b:\n\t\t\treturn False\n\telse:\n\t\treturn True\n\nif check():\n\tAB_list = list(zip(A_list, B_list))\n\tAB_list.sort()\n\tprint(\"Yes\")\n\tprint((*(b for a, b in AB_list)))\nelse:\n\tprint(\"No\")\n", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn, = list(map(int,readline().split()))\n*a, = list(map(int,readline().split()))\n*b, = list(map(int,readline().split()))\nb = b[::-1]\nfrom collections import Counter\nd = Counter(a+b)\nif max(d.values()) > n:\n    print(\"No\")\n    return\n\nsame = set(i for i in range(n) if a[i]==b[i])\nfrom random import randrange\nwhile same:\n    i = same.pop()\n    while True:\n        j = randrange(0,n)\n        if a[j] != b[i] and a[i] != b[j]:\n            b[i],b[j] = b[j],b[i]\n            same.discard(j)\n            break\n\nprint(\"Yes\")\nprint((*b))\n", "import sys\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nRB = B[::-1]\n\nstart = v = -1\nseq = 0\nfor i,(a,b) in enumerate(zip(A,RB)):\n    if a==b:\n        v = a\n        seq += 1\n        if start == -1:\n            start = i\n\nif v == -1:\n    print('Yes')\n    print(*RB)\n    return\n\nif A.count(v) + B.count(v) > N:\n    print('No')\n    return\n\nfrom bisect import bisect_left,bisect\nal = bisect_left(A,v)\nbl = bisect_left(B,v)\nbr = bisect(B,v)\nrbl = N - br\n\nm = min(seq,start,al,rbl)\nRB[:m],RB[start:start+m] = RB[start:start+m],RB[:m]\nseq -= m\nstart += m\nif seq:\n    RB[start:start+seq],RB[-seq:] = RB[-seq:],RB[start:start+seq]\n\nassert all(a!=b for a,b in zip(A,RB))\nprint('Yes')\nprint(*RB)", "def Next(): return input()\ndef NextInt(): return int(Next())\ndef NextInts(): return map(int,input().split())\ndef Nexts(): return map(str,input().split())\ndef NextIntList(): return list(map(int,input().split()))\ndef RowInts(n): return [input() for i in range(n)]\n\ndef output(ans):\n    print(\"Yes\")\n    size = len(ans)\n    for i in range(size):\n        if i == size-1:\n            print(ans[i])\n        else:\n            print(ans[i], end=' ')\n\nn = NextInt()\na = NextIntList()\nb = NextIntList()[::-1]\n\n\ndef solve():\n    border = n-1\n    for i in range(n):\n        if(a[i] >= b[i]):\n            border = i\n            break\n    if a[border] != b[border]:\n        output(b)\n        return\n    key = a[border]\n    if a.count(key)+b.count(key) > n:\n        print(\"No\")\n        return\n    cnt = a[:border].count(key) + b[:border].count(key)\n\n    for i in range(border, n):\n        if a[i] != key or b[i] != key:\n            output(b[i-1::-1] + b[:i-1:-1])\n            return\n        cnt += 2\n        if cnt == i+1:\n            output(b[i::-1] + b[:i:-1])\n            return\n    output(b[::-1])\n\nsolve()", "from collections import Counter\n\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC_A = Counter(A)\nC_B = Counter(B)\nfor k, v in list(C_A.items()):\n    if v + C_B[k] > N:\n        print(\"No\")\n        return\nB = B[::-1]\nsame_range = []\nfor i, (a, b) in enumerate(zip(A, B)):\n    if a == b:\n        same_range.append(i)\nif same_range:\n    same_v = B[same_range[0]]\n    for i in range(N):\n        if not same_range:\n            break\n        if A[i] == same_v or B[i] == same_v:\n            continue\n        j = same_range.pop()\n        B[i], B[j] = B[j], B[i]\nprint(\"Yes\")\nprint((\" \".join(map(str, B))))\n", "# \u89e3\u8aac\u3092\u53c2\u8003\u306b\u4f5c\u6210\n# import sys\n# sys.setrecursionlimit(10 ** 6)\n# import bisect\n# from collections import deque\n# from decorator import stop_watch\n# \n# \n# @stop_watch\ndef solve(N, A, B):\n    buf = -1\n    key = 0\n    for i in range(N):\n        if buf != A[i]:\n            key = 0  # \u524d\u56de(A[i - 1])\u3068\u540c\u3058\u5024\u3058\u3083\u306a\u3051\u308c\u3070\u30ea\u30bb\u30c3\u30c8\n        if A[i] == B[i]:\n            for j in range(key, N):\n                if A[i] != A[j] and B[j] != A[i]:\n                    B[i], B[j] = B[j], B[i]\n                    key = j\n                    break\n            else:\n                print('No')\n                return\n        buf = A[i]\n    print('Yes')\n    print((' '.join([str(i) for i in B])))\n\n\ndef __starting_point():\n    # S = input()\n    N = int(input())\n    # N, M = map(int, input().split())\n    A = [int(i) for i in input().split()]\n    B = [int(i) for i in input().split()]\n    # ABi = [[int(i) for i in input().split()] for _ in range(N)]\n    solve(N, A, B)\n\n    # # test\n    # from random import randint\n    # from func import random_str\n    # solve()\n\n__starting_point()", "from itertools import accumulate\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\ndef solve():\n    INF = 10**10\n\n    N = int(input())\n    As = list(map(int, input().split())) + [INF]\n    Bs = list(map(int, input().split())) + [INF]\n\n    def f(As):\n        sts = [-1] * (N+1)\n        ens = [-1] * (N+1)\n        i = 0\n        for v in range(1, N+1):\n            if As[i] == v:\n                sts[v] = i\n            else:\n                continue\n            while As[i] == v:\n                i += 1\n            ens[v] = i-1\n        return (sts, ens)\n\n    stAs, enAs = f(As)\n    stBs, enBs = f(Bs)\n\n    imoss = [0] * (2*N+1)\n    for v in range(1, N+1):\n        if stAs[v] == -1 or stBs[v] == -1: continue\n        L = stAs[v] - enBs[v] + N\n        R = enAs[v] - stBs[v] + N\n        imoss[L] += 1\n        imoss[R+1] -= 1\n\n    imoss = list(accumulate(imoss))\n\n    Cs = [imoss[i] + imoss[i+N] for i in range(N)]\n\n    numShift = -1\n    for i in range(N):\n        if Cs[i] == 0:\n            numShift = i\n            break\n\n    if numShift == -1:\n        print('No')\n    else:\n        print('Yes')\n        anss = [Bs[(i-numShift)%N] for i in range(N)]\n        print((' '.join(map(str, anss))))\n\n\nsolve()\n", "N=int(input())\nA=list(map(int, input().split()))\nB=list(map(int, input().split()))\nfrom collections import Counter as co\nfrom collections import defaultdict\nD,E=co(A),co(B)\nfor i in D:\n  if D[i]+E[i]>N:\n    print('No')\n    return\n\nd=defaultdict(int)\nfor i,e in enumerate(A):\n  d[e]=i\nans=0\nfor i,e in enumerate(B):\n  ans=max(ans,(d[e]-i+1))\ns=B[-ans:]+B[:-ans]\nprint('Yes')\nprint(*s)", "from itertools import groupby\n\nn = int(input())\naaa = list(map(int, input().split()))\nbbb = list(map(int, input().split()))\n\nidx_a = {}\ncnt_a = {}\ni = 0\nfor a, itr in groupby(aaa):\n    cnt = len(list(itr))\n    i += cnt\n    idx_a[a] = i\n    cnt_a[a] = cnt\n\nidx_b = {}\ncnt_b = {}\ni = 0\nfor b, itr in groupby(bbb):\n    cnt = len(list(itr))\n    idx_b[b] = i\n    cnt_b[b] = cnt\n    i += cnt\n\nslide = 0\nfor a in idx_a:\n    if a not in idx_b:\n        continue\n    if cnt_a[a] + cnt_b[a] > n:\n        print('No')\n        return\n    slide = max(slide, idx_a[a] - idx_b[a])\n\nprint('Yes')\nif slide > 0:\n    bbb = bbb[-slide:] + bbb[:-slide]\nprint((*bbb))\n", "from collections import Counter, defaultdict\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nca = Counter(a)\ncb = Counter(b)\n\nfor ka, va in list(ca.items()):\n    vb = cb[ka]\n    if va + vb > n:\n        print(\"No\")\n        return\n\nprint(\"Yes\")\nend = defaultdict(int)\nfor i, e in enumerate(a):\n    end[e] = i\n\nmx = 0\nfor i, e in enumerate(b):\n    diff = end[e] - i + 1\n    mx = max(mx, diff)\n\nans = b[-mx:] + b[:-mx]\nprint((*ans))\n", "def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    cnt = [0] * (N + 1)\n    for n in (A + B):\n        cnt[n] += 1\n    if max(cnt) > N:\n        print('No')\n        return\n    # B\u3092\u9006\u9806\u306b\u3059\u308b\u3068\u3001\u771f\u3093\u4e2d\u3042\u305f\u308a\u3067\u91cd\u8907\u306e\u30da\u30a2\u304c\u751f\u3058\u3046\u308b\u3002\u305d\u3053\u3092\u89e3\u6d88\u3059\u308b\u3002\n    B = B[::-1]\n    dup, dup_indices = -1, list()\n    for i in range(N):\n        if A[i] == B[i]:\n            dup = A[i]\n            dup_indices.append(i)\n    if dup == -1:\n        # \u540c\u3058\u6570\u5b57\u306e\u30da\u30a2\u304c\u306a\u3044\u306e\u3067\u3001\u305d\u306e\u307e\u307e\u51fa\u529b\n        print('Yes')\n        print(' '.join(map(str, B)))\n        return\n    # \u771f\u3093\u4e2d\u3042\u305f\u308a\u306e\u91cd\u8907\u30da\u30a2\u90e8\u5206\u3092\u4ed6\u3068\u5165\u308c\u66ff\u3048\u308b\n    indices = list()\n    for i in range(N):\n        if A[i] != dup and B[i] != dup:\n            indices.append(i)\n    indices = indices[:len(dup_indices)]\n    for i, j in zip(dup_indices, indices):\n        B[i], B[j] = B[j], B[i]\n    print('Yes')\n    print(' '.join(map(str, B)))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "N = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\n\nAB = [(a, i, 0) for i, a in enumerate(A)] + [(b, i, 1) for i, b in enumerate(B)]\nAB.sort()\n\nX = AB[:N]\nY = AB[N:]\n\nif any(x[0] == y[0] for x, y in zip(X, Y)):\n    print('No')\n    return\n\nswapA = []\nswapB = []\nans = [-1] * N\n\nfor (_, i, sx), (_, j, sy) in zip(X, Y):\n    if sx == sy == 0:\n        swapA.append((i, j))\n    elif sx == sy == 1:\n        swapB.append((i, j))\n    else:\n        if sx == 0:\n            ans[i] = B[j]\n        else:\n            ans[j] = B[i]\n\nfor (i, j), (x, y) in zip(swapA, swapB):\n    ans[i] = B[x]\n    ans[j] = B[y]\n\n    if A[i] == ans[i] or A[j] == ans[j]:\n        ans[i], ans[j] = ans[j], ans[i]\n\nprint('Yes')\nprint((*ans))\n", "def main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    B.reverse()\n    l, r = 0, N - 1\n\n    for i in range(N):\n        if A[i] != B[i]:\n            continue\n        if l < i and A[i] != B[l] and A[l] != B[i]:\n            B[l], B[i] = B[i], B[l]\n            l += 1\n            continue\n        if i < r and A[i] != B[r]:\n            B[i], B[r] = B[r], B[i]\n            r -= 1\n            continue\n        return None\n    return B\n\nt = main()\nif t is None:\n    print('No')\nelse:\n    print('Yes')\n    print((' '.join(map(str, t))))\n", "N, *AB = map(int, open(0).read().split())\nA, B = AB[:N], AB[N:]\n\nC = [0] * (N + 1)\nD = [0] * (N + 1)\n\nfor i, (a, b) in enumerate(zip(A, B)):\n    C[a] += 1\n    D[b] += 1\n\nif any(c + d > N for c, d in zip(C, D)):\n    print(\"No\")\n    return\n\nfor i in range(1, N + 1):\n    C[i] += C[i - 1]\n    D[i] += D[i - 1]\n\nx = max(C[i] - D[i - 1] for i in range(1, N + 1))\n\nprint(\"Yes\")\nprint(*[B[(i + N - x) % N] for i in range(N)])", "# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nn, = map(int,readline().split())\n*a, = map(int,readline().split())\n*b, = map(int,readline().split())\nb = b[::-1]\n\nsame = [i for i in range(n) if a[i] == b[i]]\nif same:\n    v = a[same[0]] # b \u3092\u9006\u9806\u306b\u3057\u305f\u306e\u3067\u3001\u91cd\u306a\u308b\u5024\u306f\u4e00\u7a2e\u985e\u3057\u304b\u306a\u3044\u3002\u3053\u308c\u3092 v \u3068\u304a\u304f\u3002\n    notv = [i for i in range(n) if a[i]!=v and b[i]!=v] # \u3069\u3063\u3061\u3082v\u3068\u304b\u3076\u3089\u306a\u3044 index\n    if len(same) > len(notv):\n        print(\"No\")\n        return\n    for i,j in zip(same,notv):\n        b[i],b[j] = b[j],b[i]\n\nprint(\"Yes\")\nprint(*b)", "from collections import Counter\nimport heapq\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncur = n-1\nbit = 1\nfor i in range(n):\n    if a[i] == b[i]:\n        while a[i]==b[cur] or a[cur]==b[i]:\n            if cur == 0:\n                bit = -1\n            if bit == -1 and cur == n-1:\n                print('No')\n                return\n            cur-=bit\n        b[i], b[cur] = b[cur], b[i]\nprint('Yes')\nprint((' '.join(list(map(str, b)))))\n    \n    \n", "import numpy as np\n\nN = int(input())\nA = np.array(list(map(int, input().split())))\nB = np.array(list(map(int, input().split())))\n\nl, r = 0, N + 1\nwhile r - l > 1:\n    m = (r + l) // 2\n    if np.all(B[N - m:] > A[:m]):\n        l = m\n    else:\n        r = m\n\nif np.all(B[:N - l] < A[l:]):\n    print('Yes')\n    print((*np.roll(B, l)))\nelse:\n    print('No')\n", "n = int(input()); a = list(map(int, input().split())); b = list(map(int, input().split()))\nc = [0]*n; d = [0]*n; g = 0\nfor i in range(n): c[a[i]-1] += 1; d[b[i]-1] += 1\nfor i in range(n): g = max(g, c[i]+d[i])\ne = [c[0]]; f = [d[0]]; h = e[0]\nfor i in range(1, n): e.append(c[i]+e[-1]); f.append(d[i]+f[-1])\nfor i in range(n-1): h = max(h, e[i+1]-f[i])\nif g > n: print(\"No\")\nelse: print(\"Yes\"); print(*(b[n-h:]+b[:n-h]))"]