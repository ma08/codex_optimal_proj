["def solve():\n    n, k, z = map(int,input().split())\n    lst = list(map(int,input().split()))\n    maxsum = 0\n    for zz in range(z+1):\n        sum = lst[0]\n        maxn = lst[0] + lst[1]\n        if k-zz * 2 < 0:\n            break\n        for i in range(k-zz * 2):\n            if i + 2 < n:\n                maxn = max(maxn, lst[i+1] + lst[i+2])\n            sum += lst[i+1]\n        sum += maxn * zz\n        maxsum = max(maxsum,sum)\n    print(maxsum)\nfor i in range(int(input())):\n    solve()", "t = int(input())\n\nfor _ in range(t):\n    n, k, z = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n\n    best = -1\n    best_pair = -1\n    acc = a[0]\n    used = 1\n\n    for (prev, cur) in zip(a[:-1], a[1:]):\n        used += 1\n\n        if prev + cur > best_pair:\n            best_pair = prev + cur\n\n        acc += cur\n        \n        #print(f\"Now k={k}, used={used}, z={z}\")\n        if (k - used + 2)//2 <= z and used <= k + 1:\n            #print(\"Allowed at (prev, cur) =\", (prev, cur))\n            score = acc + (((k+1) - used)//2 * best_pair) + ((k+1 - used) % 2) * prev\n            if score > best:\n                #print(f\"used={used}, (prev, cur) = {(prev, cur)}, best = {score}\")\n                best = score\n    print(best)\n", "for i in ' '*int(input()):\n    n,k,z=map(int,input().split())\n    L=list(map(int,input().split()))\n    mx=sum(L[:k+1])\n    sumL=[]\n    for j in range(n-1):sumL.append(L[j]+L[j+1])\n    for j in range(z):\n        if k<=2*j+1:break\n        count=max(sumL[:k-2*j-1])*(j+1)+sum(L[:k+1-2*(j+1)])\n        if count>mx:mx=count\n    print(mx)", "import sys\ninput = sys.stdin.readline\nfor nt in range(int(input())):\n\tn,k,z = map(int,input().split())\n\ta = list(map(int,input().split()))\n\ta = a[0:k+1]\n\tn = len(a)\n\tpref = [a[0]]\n\tfor i in range(1,n):\n\t\tpref.append(pref[-1]+a[i])\n\tmaxx = [a[0]]\n\tleft = [k]\n\tstart = [0]\n\tfor i in range(1,n):\n\t\tm = z\n\t\tt = k-i\n\t\ts = pref[i]\n\t\tcurr = i\n\t\twhile m and t:\n\t\t\tif curr==i:\n\t\t\t\tcurr -= 1\n\t\t\t\tm -= 1\n\t\t\t\tt -= 1\n\t\t\t\ts += a[curr]\n\t\t\telse:\n\t\t\t\tcurr += 1\n\t\t\t\tt -= 1\n\t\t\t\ts += a[curr]\n\t\tmaxx.append(s)\n\t\tleft.append(t)\n\t\tstart.append(curr)\n\t# print (maxx)\n\t# print (left)\n\t# print (start)\n\tans = 0\n\tfor i in range(n):\n\t\tans = max(ans,maxx[i]+(pref[start[i]+left[i]]-pref[start[i]]))\n\tprint (ans)", "import sys\n\nsys.setrecursionlimit(10 ** 5)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nfor _ in range(II()):\n    n,k,z=MI()\n    aa=LI()\n    r=max(0,k-2*z)\n    s=sum(aa[:r+1])\n    ans=-1\n    for i in range(min(n-1,k)):\n        if i+1<=r:cur=s+(aa[i]+aa[i+1])*z\n        else:\n            s+=aa[i+1]\n            left=k-i-1\n            cur=s+aa[i+1]*(left//2)+aa[i]*(left-left//2)\n        ans=max(ans,cur)\n    print(ans)\n", "t = int(input())\n\nfor _ in range(t):\n    n, k, z = list(map(int, input().split()))\n    \n    a = list(map(int, input().split()))\n    nei = list(a1+a2 for a1, a2 in zip(a, a[1:]))\n    \n    best = 0\n    for lefts in range(z+1):\n        rights = k - lefts\n        for final_left in [False, True]:\n            if rights < 1 + lefts - final_left:\n                continue\n            \n            total = sum(a[:rights-lefts+final_left+1])\n            if final_left:\n                total += a[rights-lefts]\n            total += (lefts - final_left) * max(nei[:rights-lefts+final_left])\n            best = max(best, total)\n    print(best)\n"]