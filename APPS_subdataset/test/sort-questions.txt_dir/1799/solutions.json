["from bisect import bisect_right\nimport heapq\n\nn = int(input())\nl = []\n\nti, wi = list(map(int, input().split()))\nbal = ti\npos = 1\nfor _ in range(n - 1):\n    ti, wi = list(map(int, input().split()))\n    if ti > bal:\n        pos += 1\n    l.append((ti, wi - ti + 1))\nl.sort()\n\nbest_pos = pos\n\nop = bisect_right(l, (bal, float('inf')))\n#print(l)\n\nw = []\nfor i, v in l[op:]:\n    heapq.heappush(w, v)\nop -= 1\n\nwhile w:\n    head = heapq.heappop(w)\n    if bal < head:\n        break\n    bal -= head\n    pos -= 1\n\n    #print(w, op)\n    while op >= 0 and l[op][0] > bal:\n        heapq.heappush(w, l[op][1])\n        op -= 1\n        pos += 1\n    best_pos = min(best_pos, pos)\n\nprint(best_pos)\n", "'''input\n8\n20 1000\n32 37\n40 1000\n45 50\n16 16\n16 16\n14 1000\n2 1000\n'''\nimport heapq\nfrom bisect import bisect\n\ninf = 10**18 + 2\n\ndef rints():\n    return list(map(int, input().split()))\n\ndef ri():\n    return int(input())\n\ndef bin_search(arr, pred, lo=0, hi = None):\n    if hi is None:\n        hi = len(arr)\n    while lo < hi :\n        mid = (lo+hi) // 2\n        if pred(arr[mid]):\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\nn = ri()\nscore, _ = rints()\n\nteams = []\nfor _ in range(n-1):\n    t, w = rints()\n    teams.append((w-t + 1, t, w))\n\nteams.sort(key = lambda x : x[1])\n# print(teams)\n\ndef solve(score):\n    idx = bin_search(teams, lambda x : x[1] > score)\n    best = pos = len(teams) - idx + 1\n    # print(teams[idx:], pos)\n\n    ahead = teams[idx:]\n    behind = teams[:idx]\n    heapq.heapify(ahead)\n    # print(ahead)\n\n    while ahead and score >= ahead[0][0]:\n        score -= heapq.heappop(ahead)[0]\n        pos -= 1\n        while behind and behind[-1][1] > score:\n            heapq.heappush(ahead, behind.pop())\n            pos += 1\n        # print(score, pos)\n        best = min(best, pos)\n\n    return best\n\nprint(solve(score))\n\n", "import heapq\n\nn = int(input())\n\nnum_balloons = int(input().split()[0])\nbetter_teams = []\ncurrent_place = 1\nworse_teams = []\nfor i in range(1, n):\n    inp = input().split()\n    team_balloons = int(inp[0])\n    team_size = int(inp[1])\n    if team_balloons>num_balloons:\n        current_place+=1\n        better_teams.append(team_size-team_balloons+1)\n    else:\n        worse_teams.append([team_balloons, team_size])\n\nheapq.heapify(better_teams)\nbest_place = current_place\nworse_teams = sorted(worse_teams,key=lambda x:-x[0])\nind = 0\n\nwhile True:\n    if len(better_teams)==0:\n        break\n    removed_team = heapq.heappop(better_teams)\n    num_balloons -= removed_team\n    current_place-=1\n    if num_balloons<0:\n        break\n    while ind<len(worse_teams) and worse_teams[ind][0]>num_balloons:\n        heapq.heappush(better_teams,worse_teams[ind][1]-worse_teams[ind][0]+1)\n        current_place+=1\n        ind+=1\n    if current_place<best_place:\n        best_place=current_place\n\nprint(best_place)", "import sys\ninput = sys.stdin.readline\nfrom heapq import heappop, heappush, heapify\n\nn = int(input())\nb, _ = list(map(int, input().split()))\nheap = []\nheap2 = []\nfor _ in range(n-1):\n    t, w = list(map(int, input().split()))\n    if t > b:\n        heap.append(w + 1 - t)\n    else:\n        heap2.append((-t, -w))\nheapify(heap)\nheapify(heap2)\nans = len(heap) + 1\nwhile heap:\n    need = heap[0]\n    if need > b:\n        break\n    b -= need\n    heappop(heap)\n    while heap2 and -heap2[0][0] > b:\n        t, w = heappop(heap2)\n        t, w = -t, -w\n        heappush(heap, w + 1 - t)\n    cur = len(heap) + 1\n    ans = min(ans, cur)\nprint(ans)\n"]