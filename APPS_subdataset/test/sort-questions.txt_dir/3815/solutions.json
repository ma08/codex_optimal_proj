["def __starting_point():\n\ta=[int(x) for x in input().split()]\n\tN=a[0]\n\tA=a[1]\n\tB=a[2]\n\tK=a[3]\n\ts=input()\n\tmod = 1000000009\n\tQ = pow(B*pow(A,mod-2,mod)%mod,K,mod)\n\tif Q!=1:\n\t\tD = (pow(Q,(N+1)//K,mod)-1)*pow(Q-1,mod-2,mod)%mod\n\telse:\n\t\tD = (N+1)//K\n\tans=0\n\tC = pow(A,N,mod)\n\tA=pow(A,mod-2,mod)\n\tfor i in range(K):\n\t\tif s[i]=='+':\n\t\t\tans=(ans+C*D)%mod\n\t\telse:\n\t\t\tans=(ans-C*D)%mod\n\t\tC=C*B*A%mod\n\tprint((ans%mod+mod)%mod)\n__starting_point()", "MOD = 1000000009\n\ndef Pow(base, n):\n    res = 1\n    while n:\n        if n&1:\n            res = (res*base)%MOD\n        base = (base*base)%MOD\n        n >>= 1\n    return res\n\nn, a, b, k = list(map(int, input().split()))\nans = 0\nnum = (n+1)//k\n_a = Pow(a, MOD-2)\nq = Pow(b, k)*Pow(Pow(a, k), MOD-2)%MOD\nif q == 1:\n    res = Pow(a, n)*num%MOD\n    for i in input():\n        if i == '+':\n            ans = (ans+res)%MOD\n        else:\n            ans = (ans-res)%MOD\n        res = res*b%MOD*_a%MOD\nelse:\n    # rat = (1-Pow(q, num))%MOD*Pow((1-q)%MOD, MOD-2)%MOD\n    rat = (Pow(q, num)-1)%MOD*Pow((q-1)%MOD, MOD-2)%MOD\n    cur = Pow(a, n)*rat%MOD\n    for i in input():\n        if i == '+':\n            ans = (ans+cur)%MOD\n        else:\n            ans = (ans-cur)%MOD\n        cur = cur*b%MOD*_a%MOD\nprint(ans)\n", "M = 0x3b9aca09\ninv = lambda x: pow(x, M - 2, M)\nn, a, b, k = list(map(int, input().split()))\ns = input()\nc = inv(a) * b % M\nq = pow(c, k, M)\nm = (n + 1) // k\np = (pow(q, m, M) - 1) * inv(q - 1) % M if q - 1 else m\nx = pow(a, n, M)\nr = 0\nfor i in range(k):\n    r = (r + [-1, 1][s[i] == '+'] * x * p) % M\n    x = (x * c) % M\nprint(r)\n", "n, a, b, k = list(map(int, input().split()))\ns = input()\n\nm = int(1e9 + 9)\na_1 = pow(a, m - 2, m)\nx = (a_1 * b) % m\nxk = pow(x, k, m)\n# print(\"xk\", xk)\n\nC = 0\nfor i in range(0, k):\n\tz = 1 if s[i] == \"+\" else -1\n\tC = (C + z * pow(x, i, m)) % m\n# print(\"C\", C)\n\t\nkk = (n + 1) // k\nif xk > 1:\n\tv1 = (pow(xk, kk, m) - 1) % m\n\tv2 = pow( (xk - 1) % m, m - 2, m)\n\tD = (v1 * v2) % m\nelse:\n\tD = kk\n# print(\"D\", D)\n\t\nans = pow(a, n, m) * C * D\nans %= m\nprint(ans)\n", "n, a, b, k = map(int, input().split())\ns = input()\nmod = int(1e9 + 9)\ninv = lambda x: pow(x, mod-2, mod)\nq = pow(b, k, mod) * inv(pow(a, k)) % mod\nper = 0\nd = pow(a, n, mod)\nqq = b * inv(a) % mod\nfor i in range(k):\n    if s[i] == '+':\n        per += d\n    else:\n        per -= d\n    per %= mod\n    d = d * qq % mod\nt = (n + 1) // k\nif q == 1:\n    print(t * per % mod)\n    return\nz = (pow(q, t, mod) - 1) * inv(q-1) % mod\nprint(z * per % mod)", "n, a, b, k = map(int, input().split())\ns = input()\nmod = int(1e9 + 9)\ninv = lambda x: pow(x, mod-2, mod)\nq = pow(b, k, mod) * inv(pow(a, k, mod)) % mod\nper = 0\nd = pow(a, n, mod)\nqq = b * inv(a) % mod\nfor i in range(k):\n    if s[i] == '+':\n        per += d\n    else:\n        per -= d\n    per %= mod\n    d = d * qq % mod\nt = (n + 1) // k\nif q == 1:\n    print(t * per % mod)\n    return\nz = (pow(q, t, mod) - 1) * inv(q-1) % mod\nprint(z * per % mod)", "def pow_mod(x, y, p):\n    number = 1\n    while y:\n        if y & 1:\n            number = number * x % p\n        y >>= 1\n        x = x * x % p\n    return number % p\n\ndef inv(x, p):\n    if 1 < x:\n        return p - inv(p % x, x) * p // x\n    return 1\n        \ndef v(p, a, b, k):\n    i = 1\n    while (pow_mod(a, k, (10 ** 9 + 9) ** i) - pow_mod(b, k, (10 ** 9 + 9) ** i)) == 0:\n        i += 1\n    return i-1\n\ndef main():\n    p = 10 ** 9 + 9\n    n, a, b, k = list(map(int, input().split()))\n    S = list(input())\n    for i in range(k):\n        if S[i] == '+':\n            S[i] = 1\n        else:\n            S[i] = -1\n    s=0\n    if a != b:\n        vp = p ** v(p, a, b, k)\n        sum_mod = ((pow_mod(a, (n + 1), p * vp) - pow_mod(b, (n + 1), p * vp)) // vp) * inv(((pow_mod(a, k, p * vp) - pow_mod(b, k, p * vp)) // vp) % p, p)\n        pa = pow_mod(a, k - 1, p)\n        pb = 1\n        inv_a = inv(a, p)\n        for i in range(k):\n            s += (S[i] * pa * pb * sum_mod) % p\n            pa = (pa * inv_a) % p\n            pb = (pb * b) % p\n    else:\n        for i in range(k):\n            s += S[i] * (n + 1) // k\n        s *= pow_mod(a, n, p)\n    s %= p\n    print(s)\n\nmain()\n\n\n#def giant_steps(start, target, n=2):\n    #L = [target]\n    #while L[-1] > start*n:\n        #L = L + [L[-1]//n + 2]\n    #return L[::-1]\n\n#def rshift(x, n):\n    #if n >= 0: return x >> n\n    #else:      return x << (-n)\n\n#def lshift(x, n):\n    #if n >= 0: return x << n\n    #else:      return x >> (-n)\n    \n#def size(x):\n    #return str(x).count('2')\n\n#def newdiv(p, q):\n    #szp = size(p)\n    #szq = size(q)\n    #szr = szp - szq\n    #if min(szp, szq, szr) < 2*START_PREC:\n        #return p//q\n    #r = (1 << (2*START_PREC)) // (q >> (szq - START_PREC))\n    #last_prec = START_PREC\n    #for prec in giant_steps(START_PREC, szr):\n        #a = lshift(r, prec-last_prec+1)\n        #b = rshift(r**2 * rshift(q, szq-prec), 2*last_prec)\n        #r = a - b\n        #last_prec = prec\n    #return ((p >> szq) * r) >> szr\n", "def __starting_point():\n\n\ta=[int(x) for x in input().split()]\n\n\tN=a[0]\n\n\tA=a[1]\n\n\tB=a[2]\n\n\tK=a[3]\n\n\ts=input()\n\n\tmod = 1000000009\n\n\tQ = pow(B*pow(A,mod-2,mod)%mod,K,mod)\n\n\tif Q!=1:\n\n\t\tD = (pow(Q,(N+1)//K,mod)-1)*pow(Q-1,mod-2,mod)%mod\n\n\telse:\n\n\t\tD = (N+1)//K\n\n\tans=0\n\n\tC = pow(A,N,mod)\n\n\tA=pow(A,mod-2,mod)\n\n\tfor i in range(K):\n\n\t\tif s[i]=='+':\n\n\t\t\tans=(ans+C*D)%mod\n\n\t\telse:\n\n\t\t\tans=(ans-C*D)%mod\n\n\t\tC=C*B*A%mod\n\n\tprint((ans%mod+mod)%mod)\n\n\n\n# Made By Mostafa_Khaled\n\n__starting_point()", "MOD = 10**9+9;\n\nn,a,b,k = list(map(int,input().split()))\ns = input();\n\ndef pow(a,n,m=MOD):\n    ret = 1;\n    a %= MOD;\n    while n:\n        if n&1:\n            ret = ret*a%m;\n        a = a*a%m;\n        n >>= 1;\n    return ret;\n#def inv(a,p=MOD):\n#    return pow(a,p-2,p);\ndef inv(a,m=MOD):\n    if a > 1:\n        return (m-m//a*inv(m%a,m))%m;\n    return 1\n\nia,d = inv(a), (n+1)//k\nans, ci0, q = 0, pow(a,n), pow(ia*b,k)\nQ = d\nif q != 1:\n    Q = (pow(q,d)-1)*inv(q-1)%MOD\n\nfor i in range(k):\n    sign = 1\n    if s[i] == '-':\n        sign = -1;\n    ans += sign*ci0*Q%MOD\n    ans %= MOD\n    ci0 = ci0*ia*b%MOD\nprint(ans);\n", "M = 1000000009\ninv = lambda x: pow(x, M - 2, M)\nn, a, b, k = list(map(int, input().split()))\ns = input()\nc = inv(a) * b % M\nq = pow(c, k, M)\nm = (n + 1) // k\np = (pow(q, m, M) - 1) * inv(q - 1) % M if q - 1 else m\nx = pow(a, n, M)\nr = 0\nfor i in range(k):\n    r = (r + [-1, 1][s[i] == '+'] * x * p) % M\n    x = (x * c) % M\nprint(r)\n", "def alternatingSum(n,a,b,k,s):\n    \n    mod = 1000000009\n    inv = lambda x: pow(x, mod-2, mod)\n    q = pow(b, k, mod) * inv(pow(a, k, mod)) % mod\n    per = 0\n    d = pow(a, n, mod)\n    qq = b * inv(a) % mod\n\n    for i in range(k):\n        if s[i] == '+':\n            per += d\n        else:\n            per -= d\n        \n        per %= mod\n        d = d * qq % mod\n    \n    t = (n + 1) // k\n\n    if q == 1:\n        print(t * per % mod)\n        return\n    \n    z = (pow(q, t, mod) - 1) * inv(q-1) % mod\n    print(z * per % mod)\n    \n    \nparamsRaw = input()\nparamsStr = paramsRaw.split()\nparamsInt = list(map(int, paramsStr))\n\nsequenceRaw = input()\n\nalternatingSum(paramsInt[0],paramsInt[1],paramsInt[2],paramsInt[3],sequenceRaw)", "raw = input().split()\nvals = [x for x in input()]\nn,a,b,k = [int(x) for x in raw]\nsumm = 0\nmod = 1000000009\n\ndef inv(x):\n    return fast_power(x, mod-2)\n\ndef fast_power(a,n):\n    ret = 1\n    a = a % mod\n    while n:\n        if n&1:\n            ret = ret*a%mod\n        a = a*a%mod\n        n >>= 1\n    return ret\n\nc = inv(a) * b % mod\ncf = fast_power(c, k)\nm = (n + 1) // k\nif cf -1:\n    p = (fast_power(cf, m) - 1) * inv(cf - 1) % mod\nelse:\n    p = m\nx = fast_power(a, n)\nfor i in range(k):\n    summ = (summ + [-1, 1][vals[i] == '+'] * x * p) % mod\n    x = (x * c) % mod\n\nprint(summ)\n", "\n\n\nraw = input().split()\nvals = [x for x in input()]\nn,a,b,k = [int(x) for x in raw]\nsumm = 0\nmod = 1000000009\n\ndef inv(x):\n\treturn fast_power(x, mod-2)\n\ndef fast_power(a,n):\n\tret = 1\n\ta = a % mod\n\twhile n:\n\t\tif n&1:\n\t\t\tret = ret*a%mod\n\t\ta = a*a%mod\n\t\tn >>= 1\n\treturn ret\n\nc = inv(a) * b % mod\ncf = fast_power(c, k)\nm = (n + 1) // k\nif cf -1:\n\tp = (fast_power(cf, m) - 1) * inv(cf - 1) % mod\nelse:\n\tp = m\nx = fast_power(a, n)\nfor i in range(k):\n\tsumm = (summ + [-1, 1][vals[i] == '+'] * x * p) % mod\n\tx = (x * c) % mod\n\nprint(summ)\n", "MOD = 1000000009\ndef AlternateSum(n,a,b,k,s):\n    res = 0\n    inv = lambda x: pow(x, MOD-2, MOD)\n    q = pow(b, k, MOD) * inv(pow(a, k, MOD)) % MOD\n    max_pow = pow(a, n, MOD)\n    c = b * inv(a) % MOD\n    for i in range(k):\n        if s[i] == '+':\n            res += max_pow\n        else:\n            res -= max_pow\n        res %= MOD\n        max_pow = max_pow * c % MOD\n    t = (n + 1) // k\n    if q == 1:\n        return t * res % MOD\n    z = (pow(q, t, MOD) - 1) * inv(q-1) % MOD\n    return z * res % MOD\nn, a, b, k = [int(x) for x in input().split()]\ns = input()\nprint(AlternateSum(n, a, b, k, s))", "import sys\n\n\nMOD = 10**9 + 9\n\ndef inv(x):\n    return pow(x, MOD-2, MOD)\n\ndef alternateSum(n,a,b,k,s):\n    res = 0\n    q = (pow(b, k, MOD) * inv(pow(a, k, MOD))) % MOD\n    max_pow = pow(a, n, MOD)\n    c = b * inv(a) % MOD\n    for i in range(k):\n        if s[i] == '+':\n            res += max_pow\n        elif s[i] == '-':\n            res -= max_pow\n        res %= MOD\n        max_pow = (max_pow * c) % MOD\n    t = (n+1) // k\n    if q == 1:\n        return (t*res) % MOD\n    z = ((pow(q, t, MOD) - 1) * inv(q-1)) % MOD\n    return z * res % MOD\n\nn, a, b, k, s = sys.stdin.read().split()\nresult = alternateSum(int(n), int(a), int(b), int(k), s)\n\nprint(result)", "\ndef alternatingSum(n,a,b,k,s):\n    mod = 1000000009\n    inv = lambda x: pow(x, mod-2, mod)\n    q = pow(b, k, mod) * inv(pow(a, k, mod)) % mod\n    per = 0\n    d = pow(a, n, mod)\n    qq = b * inv(a) % mod\n    for i in range(k):\n        if s[i] == '+':\n            per += d\n        else:\n            per -= d        \n        per %= mod\n        d = d * qq % mod    \n    t = (n + 1) // k\n    if q == 1:\n        print(t * per % mod)\n        return    \n    z = (pow(q, t, mod) - 1) * inv(q-1) % mod\n    print(z * per % mod)\n        \nparamsRaw = input()\nparamsStr = paramsRaw.split()\nparamsInt = list(map(int, paramsStr))\nsequenceRaw = input()\n\nalternatingSum(paramsInt[0],paramsInt[1],paramsInt[2],paramsInt[3],sequenceRaw)\n", "def alternatingSum(n,a,b,k,s):\n    \n    mod = 1000000009\n    inv = lambda x: pow(x, mod-2, mod)\n    q = pow(b, k, mod) * inv(pow(a, k, mod)) % mod\n    per = 0\n    d = pow(a, n, mod)\n    qq = b * inv(a) % mod\n\n    for i in range(k):\n        if s[i] == '+':\n            per += d\n        else:\n            per -= d\n        \n        per %= mod\n        d = d * qq % mod\n    \n    t = (n + 1) // k\n\n    if q == 1:\n        print(t * per % mod)\n        return\n    \n    z = (pow(q, t, mod) - 1) * inv(q-1) % mod\n    print(z * per % mod)\n    \n    \nparamsRaw = input()\nparamsStr = paramsRaw.split()\nparamsInt = list(map(int, paramsStr))\n\nsequenceRaw = input()\n\nalternatingSum(paramsInt[0],paramsInt[1],paramsInt[2],paramsInt[3],sequenceRaw)\n  \n", "import sys\ntry:\n\tfin = open('in')\nexcept:\n\tfin = sys.stdin\ninput = fin.readline\n\nmod=10**9+9\ndef f(x,y):\n\tans=1\n\twhile y:\n\t\tif y&1:ans=ans*x%mod\n\t\tx=x*x%mod\n\t\ty>>=1\n\treturn ans\nn,a,b,k=map(int,input().split())\ns=[1 if c=='+' else -1 for c in input()]\n#period k-1\npr=sum(s[i]*f(a,n-i)*f(b,i) for i in range(k))%mod\n#ratio (b/a)^k\nrt=f(b,k)*f(f(a,k),mod-2)%mod\nterms=(n+1)//k\nif rt==1:\n\tprint(terms*pr%mod)\nelse:\n\tprint(pr*(f(rt,terms)-1)*f(rt-1,mod-2)%mod)", "n , a , b , k = list(map(int,input().split()))\ns = str(input())\nMOD = 10**9 + 9\n\ndef fun(a , b , i):\n    return (pow(a , n - i , MOD) * pow(b , i , MOD)) % MOD\n\ndef div(x , y):\n    #calculate x // y mod p\n    return (x * pow(y , MOD - 2 , MOD)) % MOD\n\nr = pow(div(b , a) , k , MOD)\nSUM = 0\n\nfor i in range(k):\n    if s[i] == '-':\n        SUM += -1 * fun(a , b , i)\n    else:\n        SUM += +1 * fun(a , b , i)\n    \nn += 1\nt = n // k\n\nans = pow(r , t , MOD) - 1\nx = r - 1   \nif x : \n    ans = (div(ans , x) * SUM) % MOD\nelse:\n    ans = (t * SUM) % MOD\nans += MOD\nans %= MOD\nprint(ans)\n\n    \n    \n\n    \n\n", "import math\ndef binpow(a,b,m):\n    a %= m\n    res = int(1)\n    while b > 0 :\n        if b & 1:\n            res = (res * a) % m\n        a = (a * a) % m\n        b >>= 1\n    return res\n\ndef inv(a,m:int=1000000009):\n    return binpow(a,m-2,m)\n\nm=int(1000000009)\n\nn,a,b,k=input().split()\nn=int(n);a=int(a);b=int(b);k=int(k)\nst=input()\nres=int(1)\np=int((b*inv(a,m))%m)\nitr=(n+1)//k\nmul1=0\nfor i in range (len(st)):\n    if st[i]=='+':\n        mul1=(mul1+binpow(p,i,m))%m\n    else:\n        mul1=(mul1-binpow(p,i,m))%m\nif binpow(p,k,m)==1:\n    mul2=itr%m\nelse:\n    mul2=((binpow(p,k*itr,m)-1)*inv((binpow(p,k,m)-1)%m))%m\nres=(mul1*mul2)%m\nleft=n-k*itr+1\nmul1=binpow(p,k*itr,m)\nmul2=0\nfor i in range (left):\n    if st[i]=='+':\n        mul2=(mul2+binpow(p,i,m))%m\n    else:\n        mul2=(mul2-binpow(p,i,m))%m\nres=(res+mul1*mul2)%m\nres=(res*binpow(a,n,m))%m\nprint(res)\n\n\n"]