["# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Mon Jan  8 10:20:50 2018\n\n@author: yanni\n\"\"\"\n\n#import random\n\nn, T = [int(x) for x in input().split()]\n#n, T = [100000,10000*10000]\nprob = []\nvals = [set() for stuff in range(n+2)]\nfor i in range(n):\n    a, t = [int(x) for x in input().split()]\n    #a = random.randint(1,n)\n    #t = random.randint(1, 10000)\n    prob.append((i+1,a,t))\nprob.sort(key = lambda tup: tup[2])\ncurrindex = 0\nmaxindex = -1\nsolve = set()\nmem = set()\ntimeleft = T\ntarget = 1\n\nfor currindex in range(n):\n    i, a, t = prob[currindex]\n    if (timeleft < t):\n        break\n    if (timeleft >= t and a >= target):\n        vals[a].add(currindex)\n        solve.add(currindex)\n        timeleft -= t\n        if (len(solve) == target):\n            maxindex = currindex\n            #print(target)\n            for p in vals[target]:\n                solve.remove(p)\n                timeleft += prob[p][2]\n            target += 1\n\nbestsolve = solve | vals[target-1]\nsolvelist = [x for x in bestsolve if x<=maxindex]\ntarget = len(solvelist)\nprint(target)\nprint(target)\nfor p in solvelist:\n    print(prob[p][0], end=\" \")\nprint()", "n, t = list(map(int, input().split()))\nts = []\nfor i in range(n):\n    a,c = list(map(int, input().split()))\n    ts.append((a,c, i))\nts = sorted(ts, key=lambda x: x[1])\nans = 0\nptr = 0\nhc = {}\nhs = {}\ncsize = 0\nctime = 0\nfor i in range(n):\n    n_ans = ans + 1\n    if n_ans - 1 in hc:\n        csize -= hc[n_ans-1]\n        ctime -= hs[n_ans-1]\n    fail = False\n    while csize < n_ans:\n        if ptr == n:\n            fail=True\n            break\n        a, c, num = ts[ptr]\n        if a >= n_ans:\n            csize += 1\n            ctime += c\n            if a not in hc:\n                hc[a] = 0\n            hc[a] += 1\n            if a not in hs:\n                hs[a] = 0\n            hs[a] += c\n\n        ptr += 1\n        if ctime > t:\n            fail = True\n            break\n    if fail:\n        break\n    else:\n        ans = n_ans\n\nprint(ans)\nprint(ans)\ntks = []\nfor i in range(ptr):\n    if len(tks) == ans:\n        break\n    if ts[i][0] >= ans:\n        tks.append(ts[i][2])\n\nprint(' '.join([str(i+1) for i in tks]))\n", "# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 1/11/18\n\n\"\"\"\n\nimport math\nimport collections\nimport bisect\nimport heapq\nimport time\nimport random\nimport itertools\nimport sys\n\nN, T = list(map(int, input().split()))\n#\n# N, T = 200000, 1000000000\n\nta = []\nfor i in range(N):\n  a, t = list(map(int, input().split()))\n  ta.append((t, a, i+1))\n  # ta.append((10000, 200000, i+1))\n\nta.sort()\n\n\nscore = 0\nsolvedCount = 0\naks = []\nheapq.heapify(aks)\nsc = collections.defaultdict(list)\nfor i in range(N):\n  t, a, _ = ta[i]\n  if T < t:\n    break\n\n  T -= t\n  solvedCount += 1\n\n  sc[a].append((t, i))\n  heapq.heappush(aks, a)\n  removed = []\n  while aks and aks[0] < solvedCount:\n    k = heapq.heappop(aks)\n    removed.append(k)\n    v = sc[k]\n    solvedCount -= len(v)\n    for _, j in v:\n      T += ta[j][0]\n    del sc[k]\n\n  score = max(score, solvedCount)\n\n\nprint(score)\nprint(score)\n\nvta = [(t, a, i) for t, a, i in ta if a >= score]\nvta.sort()\nans = [i for _, _, i in vta[:score]]\nprint(\" \".join(map(str, ans)))\n\n\n", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Jan 12 18:46:09 2018\n\n@author: Sand Boa\n\"\"\"\n\nimport sys\nimport operator  # itemgetter\nimport itertools  # islice\n\ndef __starting_point():\n    n, T = list(map(int,input().split()))\n    listi = []\n    for i in range(n):\n        a,b = list(map(int,input().split()))\n        listi.append((a,b,i))\n    #print(listi)\n    listi = sorted(listi, key=lambda x: x[1])\n    #print(listi)\n    time = [0] * (n + 1)\n    count = [0] * (n + 1)\n    time_sum = 0\n    count_sum = 0\n    k = 1\n\n    for (a, t, ind) in listi:\n        if k <= a:\n            time[a] += t\n            time_sum += t\n            if time_sum > T:\n                break\n\n            count[a] += 1\n            count_sum += 1\n            if count_sum == k:\n                count_sum -= count[k]\n                time_sum -= time[k]\n                k += 1\n\n    max_score = max(count_sum, k - 1)\n    #max_score = count_sum\n\n    print (max_score)\n    print (max_score)\n    print((*list(itertools.islice(\n        (idx + 1 for (a, t, idx) in listi if a >= max_score),\n        max_score\n    ))))\n    #print(listi)\n    '''for a, t, idx in listi:\n        if idx > max_score:\n            print(idx,sep=\" \")\n            '''\n    #print(idx+1 for  in listi )\n\n__starting_point()", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Jan 12 18:46:09 2018\n\n@author: Sand Boa\n\"\"\"\nimport itertools\n\ndef __starting_point():\n    n:int\n    T:int\n    n, T = list(map(int,input().split()))\n    listi:list = []\n    tsum:int = 0\n    csum:int = 0\n    k = 1\n    a:int\n    b:int\n    for i in range(n):\n        a,b = list(map(int,input().split()))\n        listi.append((a,b,i))\n    #print(listi)\n    listi = sorted(listi, key=lambda x: x[1])\n    #print(listi)\n    time:list = [0] * (n + 1)\n    count:list = [0] * (n + 1)\n    for (a, t, ind) in listi:\n        if k <= a:\n            tsum += t\n            time[a] += t\n            if tsum > T:\n                break\n            count[a] += 1\n            csum += 1\n            if csum == k:\n                csum -= count[k]\n                tsum -= time[k]\n                k += 1\n    max_score = max(csum, k - 1)\n    print (max_score,max_score,sep='\\n')\n    print(*list(itertools.islice(\n        (idx + 1 for (a, t, idx) in listi if a >= max_score),\n        max_score\n    )))\n    #print(listi)\n    '''for a, t, idx in listi:\n        if idx > max_score:\n            print(idx,sep=\" \")\n            '''\n    #print(idx+1 for  in listi )\n      \t \t\t \t  \t\t\t      \t\t  \t \t\t\n__starting_point()", "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Jan 12 18:46:09 2018\n\n@author: Sand Boa\n\"\"\"\nimport itertools\n\ndef __starting_point():\n    n:int\n    T:int\n    n, T = list(map(int,input().split()))\n    listi:list = []\n    tsum:int = 0\n    csum:int = 0\n    k:int\n    k = 1\n    a:int\n    b:int\n    t:int\n    ind:int\n    for i in range(n):\n        a,b = list(map(int,input().split()))\n        listi.append((a,b,i))\n    #print(listi)\n    listi = sorted(listi, key=lambda x: x[1])\n    #print(listi)\n    time:list = [0] * (n + 1)\n    count:list = [0] * (n + 1)\n    for (a, t, ind) in listi:\n        if k <= a:\n            tsum += t\n            time[a] += t\n            if tsum > T:\n                break\n            count[a] += 1\n            csum += 1\n            if csum == k:\n                csum -= count[k]\n                tsum -= time[k]\n                k += 1\n    max_score:int = max(csum, k - 1)\n    print (max_score,max_score,sep='\\n')\n    print(*list(itertools.islice((idx + 1 for (a, t, idx) in listi if a >= max_score),max_score)))\n\n\n\t\t\t\t    \t\t\t\t\t\t    \t \t  \t \t\t\t \t\n__starting_point()", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n \n# M = mod = 998244353\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\n# def inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\nn,L = li()\nl = []\nfor i in range(n):\n    l.append(li())\n\nindex = defaultdict(list)\nfor ind,i in enumerate(l):\n    index[tuple(i)].append(ind + 1)\n# print(index)\nl.sort(key = lambda x:x[1])\nd = defaultdict(list)\n# print(l)\n\nans = i = tot = currpoints = 0\nanspattern = []\nhe = []\n# print(L)\nwhile i < n:\n    # print(l[i])\n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n        # i += 1\n    # print(he,d,currpoints,tot)\n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n    \n    if currpoints > ans:\n        # print('ans change : ',ans,currpoints,anspattern)\n        ans = currpoints\n        # anspattern = he[:]\n        # for k in he:\n        #     for j in d[k]:\n        #         anspattern.append(index[tuple([k,j])])\n        # print('chengedans : ',ans,currpoints,anspattern)\n    \n        \n    i += 1\ni = tot = currpoints = 0\nhe = []\nd = defaultdict(list)\n\nwhile i < n:\n    # print(l[i])\n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n        # i += 1\n    # print(he,d,currpoints,tot)\n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n    \n    if currpoints == ans:\n        anspattern = []\n        for i in he:\n            for j in d[i]:\n                anspattern.append(index[tuple([i,j])][-1])\n                index[tuple([i,j])].pop()\n        print(ans)\n        print(len(anspattern))\n        print(*sorted(anspattern))\n        return\n        # print('ans change : ',ans,currpoints,anspattern)\n        ans = currpoints\n        # anspattern = he[:]\n        # for k in he:\n        #     for j in d[k]:\n        #         anspattern.append(index[tuple([k,j])])\n        # print('chengedans : ',ans,currpoints,anspattern)\n    \n        \n    i += 1", "from bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nimport math\nfrom collections import *\nfrom functools import reduce,cmp_to_key\nimport sys\ninput = sys.stdin.readline\n \n# M = mod = 998244353\ndef factors(n):return sorted(list(set(reduce(list.__add__,([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))))\n# def inv_mod(n):return pow(n, mod - 2, mod)\n \ndef li():return [int(i) for i in input().rstrip('\\n').split(' ')]\ndef st():return input().rstrip('\\n')\ndef val():return int(input().rstrip('\\n'))\ndef li2():return [i for i in input().rstrip('\\n').split(' ')]\ndef li3():return [int(i) for i in input().rstrip('\\n')]\n\n\nn,L = li()\nl = []\nfor i in range(n):\n    l.append(li())\n\nindex = defaultdict(list)\nfor ind,i in enumerate(l):\n    index[tuple(i)].append(ind + 1)\n\nl.sort(key = lambda x:x[1])\nd = defaultdict(list)\n\nans = i = tot = currpoints = 0\nanspattern = []\nhe = []\n\nwhile i < n:\n    \n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n        \n    \n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n    \n    if currpoints > ans:\n        ans = currpoints\n        \n    i += 1\ni = tot = currpoints = 0\nhe = []\nd = defaultdict(list)\n\nwhile i < n:\n    \n    if l[i][1] + tot <= L:\n        tot += l[i][1]\n        heapq.heappush(d[l[i][0]],l[i][1])\n        currpoints += 1\n\n        if len(d[l[i][0]]) == 1:\n            heapq.heappush(he,l[i][0])\n    \n    while len(he) and currpoints > he[0]:\n        temp = heapq.heappop(he)\n        tot -= heapq.heappop(d[temp])\n        currpoints -= 1\n        if len(d[temp]):heapq.heappush(he,temp)\n    \n    if currpoints == ans:\n        anspattern = []\n        for i in he:\n            for j in d[i]:\n                anspattern.append(index[tuple([i,j])][-1])\n                index[tuple([i,j])].pop()\n        print(ans)\n        print(len(anspattern))\n        print(*sorted(anspattern))\n        return\n    i += 1", "# https://codeforces.com/contest/913/problem/D\nimport heapq\nfrom heapq import heappush as push_\nfrom heapq import heappop  as pop_\n\nclass heapT():\n    def __init__(self, T):\n        self.Q     = []\n        self.curT  = 0\n        self.maxT  = T\n        self.his   = []\n        \n    def push(self, t, index):\n        push_(self.Q, (-t, index))\n        self.his.append(index)\n        self.curT += t\n        \n        while self.curT > self.maxT:\n            self.pop()\n            \n    def pop(self):\n        t, ind     = pop_(self.Q)\n        self.his.append(ind) \n        self.curT -= t * -1\n        \n    def normalize(self, length):\n        while len(self.Q) > length:\n            self.pop()\n\ndef solve(a, n, T):\n    a    =  sorted(a, key=lambda x:x[0], reverse=True) \n    H    =  heapT(T)\n\n    max_ = -1\n    pos  = None\n    \n    for ak, t, ind in a:\n        H.push(t, ind)\n        H.normalize(ak)\n    \n        if len(H.Q) >  max_:\n            max_ = len(H.Q)\n            pos  = len(H.his)  \n            \n    d = {}\n    if pos is not None:\n        for x in H.his[:pos]:\n            if x not in d:\n                d[x] = 1\n            else:\n                del d[x]\n\n    if len(d) > 0:\n        print(len(d))\n        print(len(d))\n        print(' '.join([str(x+1) for x in d]))\n    else:\n        print('0'+'\\n'+'0')\n\nn, T =  list(map(int, input().split()))\na    =  [list(map(int, input().split())) + [_] for _ in range(n)]\nsolve(a, n, T)\n\n#5 300\n#3 100\n#4 150\n#4 80\n#2 90\n#2 300        \n\n#7 100\n#5 30\n#5 40\n#6 20\n#2 50 \n#2 40\n#3 10\n#4 10\n\n#2 100\n#1 787\n#2 788\n", "import sys\nimport math\nfrom collections import defaultdict,deque\nimport heapq\ndef search(arr,points,t):\n    l=[]\n    n=len(arr)\n    cnt=0\n    for i in range(n):\n        if arr[i][0]>=points:\n            l.append(arr[i][1])\n            cnt+=1\n    if cnt>=points:\n        l.sort()\n        #print(l,'l')\n        if sum(l[:points])<=t:\n            return True\n    return False\ndef get(arr,points):\n    n=len(arr)\n    l=[]\n    for i in range(n):\n        if arr[i][0]>=points:\n            l.append([arr[i][1],arr[i][2]+1])\n    l.sort()\n    #print(l,'get')\n    res=[]\n    for i in range(points):\n        res.append(l[i][1])\n    return res\nn,t=list(map(int,sys.stdin.readline().split()))\ndic=defaultdict(int)\narr=[]\nfor i in range(n):\n    a,b=list(map(int,sys.stdin.readline().split()))\n    arr.append([a,b,i])\nlow,high=0,n\nans=0\nwhile low<=high:\n    mid=(low+high)//2\n    if search(arr,mid,t):\n        ans=max(ans,mid)\n        low=mid+1\n    else:\n        high=mid-1\n#print(ans)\nif ans==0:\n    print(0)\n    print(0)\n    print('')\n    return\nl=get(arr,ans)\nprint(len(l))\nprint(len(l))\nprint(*l)\n\n", "import sys\ninput=sys.stdin.readline\ndef fun(k):\n    nonlocal li,t\n    tem=[]\n    count=0\n    for i in li:\n        if(i[0]>=k):\n            tem.append(i)\n            count+=1\n    if(count>=k):\n        ans=0\n        for i in range(k):\n            ans+=tem[i][1]\n        if(ans<=t):\n            return True\n        else:\n            return False\n    else:\n        return False\n                  \nn,t=map(int,input().split())\nli=[]\nfor _ in range(n):\n    li.append(list(map(int,input().split()))+[_])\nli.sort(key=lambda x:x[1])\nl=0\nr=n\nwhile(r-l>1):\n    mid=(l+r)//2\n    if(fun(mid)):\n        l=mid\n    else:\n        r=mid\nfin=0\nfor i in range(l,r+1):\n    if(fun(i)):\n        fin=i\nprint(fin)\nprint(fin)\ntem=[]\nfor i in range(n):\n    if(li[i][0]>=fin):\n        tem.append(li[i][2]+1)\nprint(*tem[:fin])", "from sys import stdin, stdout\nimport sys\ninput=sys.stdin.readline\n\ndef solve(n, t, tasks):\n    lo = 0\n    hi = n\n\n    res = []\n    curr_res = 0\n\n    tasks.sort(key=lambda x: x[1])\n\n    while lo <= hi:\n        mid = lo + (hi - lo) // 2\n\n        # check if we can make mid.\n        valid_tasks = []\n        for i in tasks:\n            if i[0] >= mid:\n                valid_tasks.append(i)\n        \n        can_do = False\n\n        curr_sum = 0\n        total_used = 0\n        r = []\n        for i in valid_tasks:\n            curr_sum += i[1]\n            total_used += 1\n            r.append(i[2])\n            if curr_sum > t:\n                break\n            elif total_used >= mid:\n                can_do = True\n                curr_res = mid\n                res = r\n                break\n        if can_do:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return curr_res, res\n        \n\n\n\n\n\ndef main():\n    n, t = (int(x) for x in input().split(\" \"))\n    tasks = []\n    nums = n\n    idx = 1\n    while n:\n        a_i, t_i = (int(x) for x in input().split(\" \"))\n        tasks.append((a_i, t_i, idx))\n        idx += 1\n        n -= 1\n    # print(nums, t, tasks)\n    res, res_arry = solve(nums, t, tasks)\n    print(res)\n    print(res)\n    stdout.write(\" \".join(map(str, res_arry)))\n    stdout.write(\"\\n\")\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]