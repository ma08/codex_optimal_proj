["n=int(input())\nC=[0]+list(map(int,input().split()))\n\n#n=5000\n#C=list(range(n+1))\n\nA=[]\nfor i in range(1,n+1):\n    if C[i]!=C[i-1]:\n        A.append(C[i])\n\nL=len(A)\nDP=[[[0]*L for i in range(L)] for j in range(2)]\n#\u5de6\u306e\u8272\u306b\u63c3\u3048\u308b or \u53f3\u306e\u8272\u306b\u63c3\u3048\u308b,\u5de6\u304b\u3089i\uff5ej\u756a\u76ee\u3092\n\ndef color(r,i,j):#i<j\n    if r==1:\n        if A[i]==A[j]:\n            DP[r][i][j]=min(DP[0][i][j-1],DP[1][i][j-1]+1)\n        else:\n            DP[r][i][j]=min(DP[0][i][j-1]+1,DP[1][i][j-1]+1)\n\n    else:\n        if A[i]==A[j]:\n            DP[r][i][j]=min(DP[1][i+1][j],DP[0][i+1][j]+1)\n        else:\n            DP[r][i][j]=min(DP[1][i+1][j]+1,DP[0][i+1][j]+1)\n\nfor i in range(1,L):\n    for j in range(L-i):\n        color(0,j,i+j)\n        color(1,j,i+j)\n\n    #print(DP)\n\nprint(min(DP[0][0][L-1],DP[1][0][L-1]))\n", "from itertools import groupby\nimport math\n\nn, = list(map(int, input().strip().split()))\narray = list(map(int, input().strip().split()))\n\ng_array = [k for k, g in groupby(array)]\n\nn = len(g_array)\nextend_n = n + 2\nsols = [[0]*extend_n for _ in range(extend_n)]\n\nfor i in range(1, extend_n-1):\n\tfor j in range(extend_n-2, i, -1):\n\t\tval = max(sols[i-1][j], sols[i][j+1])\n\t\tif g_array[i-1] == g_array[j-1]:\n\t\t\tval = max(val, sols[i-1][j+1] + 1)\n\t\tsols[i][j] = val\n\nbest = 0\nfor start in range(1, extend_n-1-1):\n\tstart_val = sols[start-1][start+1]\n\tif start_val > best:\n\t\tbest = start_val\n\nprint(len(g_array) - 1 - best)\n\n", "n = int(input())\na = list(map(int, input().split()))\nb = []\np = -1\nfor e in a:\n    if e == p:\n        continue\n    else:\n        b.append(e)\n        p = e\n\ndef lcs(a, b):\n    lengths = [[0 for j in range(len(b)+1)] for i in range(len(a)+1)]\n    # row 0 and column 0 are initialized to 0 already\n    for i, x in enumerate(a):\n        for j, y in enumerate(b):\n            if x == y:\n                lengths[i+1][j+1] = lengths[i][j] + 1\n            else:\n                lengths[i+1][j+1] = max(lengths[i+1][j], lengths[i][j+1])\n    # read the substring out from the matrix\n    x, y = len(a), len(b)\n    return lengths[x][y]\n\nans = 0\n\n#print(b)\n#for i in range(len(b)//2+1):\n    #print(list(reversed(b[:i])), b[i:])\n    #ans = max(ans, lcs(list(reversed(b[:i])), b[i:]))\n\nans = lcs(list(reversed(b)), b)//2\nn = len(b)\n#print(ans)\nprint(n - ans - 1)", "def inpl(): return list(map(int, input().split()))\n\nN = int(input())\nA = inpl()\nB = [0]\nfor a in A:\n    if B[-1] != a:\n        B.append(a)\n\nB = B[1:]\nk = len(B)\ndp = [0]*((k*k + k)//2)\nfor d in range(1, k):\n    for i in range(k-d):\n        if B[i] == B[i+d]:\n            dp[d*(2*k-d+1)//2+i] = dp[(d-2)*(2*k-d+3)//2+i+1] + 1\n        else:\n            dp[d*(2*k-d+1)//2+i] = 1 + min(dp[(d-1)*(2*k-d+2)//2+i], dp[(d-1)*(2*k-d+2)//2+i+1])\nprint(dp[-1]) \n", "# -*- coding: utf-8 -*-\n\nimport sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import sqrt, hypot, factorial, pi, sin, cos, radians\nif sys.version_info.minor >= 5: from math import gcd\nelse: from fractions import gcd \nfrom heapq import heappop, heappush, heapify, heappushpop\nfrom bisect import bisect_left, bisect_right\nfrom itertools import permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom functools import reduce, partial\nfrom fractions import Fraction\nfrom string import ascii_lowercase, ascii_uppercase, digits\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(a, b=1): return int(-(-a // b))\ndef round(x): return int((x*2+1) // 2)\ndef fermat(x, y, MOD): return x * pow(y, MOD-2, MOD) % MOD\ndef lcm(x, y): return (x * y) // gcd(x, y)\ndef lcm_list(nums): return reduce(lcm, nums, 1)\ndef gcd_list(nums): return reduce(gcd, nums, nums[0])\ndef INT(): return int(input())\ndef MAP(): return list(map(int, input().split()))\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN = INT()\ncN = LIST()\ncN2 = [cN[0]]\nfor i in range(1, N):\n    if cN[i] != cN[i-1]:\n        cN2.append(cN[i])\ncN3 = list(reversed(cN2))\nN2 = len(cN2)\n\ndp = [[0] * (N2+1) for i in range(N2+1)]\n\nfor i in range(N2+1):\n    for j in range(N2+1):\n        if i < N2:\n            dp[i+1][j] = max(dp[i+1][j], dp[i][j])\n        if j < N2:\n            dp[i][j+1] = max(dp[i][j+1], dp[i][j])\n        if i < N2 and j < N2 and cN2[i] == cN3[j]:\n            dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j]+1)\nprint(N2-1 - dp[N2][N2] // 2)\n", "def fill():\n    nonlocal dp\n    dp = [0] * (n + 2)\n    for i in range(n + 2):\n        dp[i] = [0] * (n + 2)\n\ndef compress(v):\n    nonlocal n\n    nonlocal c\n    c = [v[0]]\n    for i in range(1, n):\n        if v[i] != v[i - 1]:\n            c.append(v[i])\n    n = len(c)\n            \nn = int(input())\nv = [int(i) for i in input().split()]\nc = []\ncompress(v)\ndp = []\nfill()\nfor i in range(n):\n    dp[i][1] = 0\n    dp[i][2] = 1\n\nfor sz in range(3, n + 1):\n    for i in range(n):\n        j = i + sz - 1\n        if j >= n:\n            break\n        if c[i] == c[j]:\n            dp[i][sz] = dp[i + 1][sz - 2] + 1\n        else:\n            dp[i][sz] = min(dp[i + 1][sz - 1], dp[i][sz - 1]) + 1\n\nprint(dp[0][n])", "n=int(input())\nlsr = list(map(int, input().split()))\nls = [lsr[0]]\nfor le in lsr[1:]:\n    if le!=ls[-1]:\n        ls.append(le)\n\nn=len(ls)\ndpa=[]\ndpb=[0 for i in range(n+1)]\nfor sz in range(2,n+1):\n    dp=[]\n    for start in range(n-sz+1):\n        if ls[start] == ls[start+sz-1]:\n            dp.append(min(dpb[start], dpb[start+1], dpa[start+1])+1)\n        else:\n            dp.append(min(dpb[start], dpb[start+1])+1)\n    dpa, dpb = dpb, dp\nprint( dpb[0])", "def lps(str): \n    n = len(str) \n  \n    L = [[0 for x in range(n)] for x in range(n)] \n  \n    for i in range(n): \n        L[i][i] = 1\n  \n    for cl in range(2, n+1): \n        for i in range(n-cl+1): \n            j = i+cl-1\n            if str[i] == str[j] and cl == 2: \n                L[i][j] = 2\n            elif str[i] == str[j]: \n                L[i][j] = L[i+1][j-1] + 2\n            else: \n                L[i][j] = max(L[i][j-1], L[i+1][j]); \n  \n    return L[0][n-1] \n  \nn = input()\nn = int(n)\nl = list(map(str, input().strip().split()))\nseq = [l[0]]\nch = l[0]\nfor i in range(1,n):\n    if l[i] != ch:\n        ch = l[i]\n        seq.append(l[i])\nn = len(seq)\nprint(n - lps(seq)//2 -1)", "a=int(input())\nb = [int(x) for x in input().split()]\nc = [b[0]]\nfor i in b[1:]:\n    if i!=c[-1]:\n        c.append(i)\na=len(c)\n\ndpa = []\ndpb = [0] * (a+1)\nfor i in range(2,a+1):\n    dp=[]\n    for j in range(a-i+1):\n        if c[j] == c[j+i-1]:\n            dp.append(min(dpb[j], dpb[j+1], dpa[j+1])+1)\n        else:\n            dp.append(min(dpb[j], dpb[j+1])+1)\n    dpa, dpb = dpb, dp\nprint(dpb[0])\n", "def lcs(a, b):\n    c = [[0 for i in range(len(a)+1)] for i in range(len(b)+1)]\n    for i in range((len(b)+1)):\n        for j in range(len(b)+1):\n            if i == 0 or j == 0:\n                c[i][j] = 0\n            elif a[i-1] == b[j-1]:\n                c[i][j] = c[i-1][j-1] + 1\n            else:\n                c[i][j] = max(c[i-1][j], c[i][j-1])\n    return c\n\n\nn = int(input())\na = list(map(int, input().split()))\nb = [a[0]]\nfor i in range(1, n):\n    if a[i] != a[i-1]:\n        b.append(a[i])\na = b[:: -1]\nc = lcs(a, b)\nans = 0\nn = len(a)\nfor i in range(0, n+1):\n    ans = max(ans, c[i][n-i])\nprint(n-ans-1)\n", "n = int(input())\nC = [int(i) for i in input().split()]\n\nINF = 5000\nDP = [[[0] * (2) for i in range(n)] for j in range(2)] #[width][left][L/R]\n\nfor i in range(n-1):\n    for j in range(n-i-1):    \n        DP[(i+1)%2][j][0] = INF\n        DP[(i+1)%2][j][1] = INF\n        for k in range(2):\n            c = C[j] if k == 0 else C[j+i]\n            if c == C[j+i+1]:\n                DP[(i+1)%2][j][1] = min(DP[(i+1)%2][j][1], DP[i%2][j][k])\n            else:\n                DP[(i+1)%2][j][1] = min(DP[(i+1)%2][j][1], DP[i%2][j][k] + 1)\n                \n            c = C[j+1] if k == 0 else C[j+i+1]\n            if c == C[j]:\n                DP[(i+1)%2][j][0] = min(DP[(i+1)%2][j][0], DP[i%2][j+1][k])\n            else:\n                DP[(i+1)%2][j][0] = min(DP[(i+1)%2][j][0], DP[i%2][j+1][k] + 1)\n\nprint(min(DP[(n-1)%2][0]))", "n = int(input())\nC = [int(i) for i in input().split()]\n\nD = []\nfor c in C:\n    if not D or D[-1] != c:\n        D.append(c)\n\nn = len(D)\nC = D[::-1]\nDP = [[0] * (n+1) for i in range(n+1)] \n\nfor i in range(n):\n    for j in range(n):\n        if C[i] == D[j]:\n            DP[i+1][j+1] = DP[i][j] + 1\n        else:\n            DP[i+1][j+1] = max(DP[i+1][j], DP[i][j+1])\n\nprint(n - 1 - DP[n][n] // 2)", "n = int(input())\nC = [int(i) for i in input().split()]\n\nD = []\nfor c in C:\n    if not D or D[-1] != c:\n        D.append(c)\n\nn = len(D)\nC = D[::-1]\nDP = [[0] * (n+1) for i in range(2)] \n\nfor i in range(n):\n    for j in range(n):\n        if C[i] == D[j]:\n            DP[(i+1)&1][j+1] = DP[i&1][j] + 1\n        else:\n            DP[(i+1)&1][j+1] = max(DP[(i+1)&1][j], DP[i&1][j+1])\n\nprint(n - 1 - DP[n&1][n] // 2)", "n = int(input())\nraw_list = [int(item) for item in input().split()]\n\nl = [raw_list[0]]\nfor item in raw_list[1:]:\n    if item != l[-1]:\n        l.append(item)\nn = len(l)\n\ndp1 = []\ndp2 = [0] * (n + 1)\nfor i in range(2, n + 1):\n    dp = []\n    for j in range(n - i + 1):\n        if l[j] == l[i + j - 1]:\n            dp.append(min(dp1[j + 1], dp2[j], dp2[j + 1]) + 1)\n        else:\n            dp.append(min(dp2[j], dp2[j + 1]) + 1)\n    dp1, dp2 = dp2, dp\nres = dp2[0]\nprint(res)\n", "def run_length_compress(string):\n    string = string + [\".\"]\n    n = len(string)\n\n    begin = 0\n    end = 1\n    cnt = 1\n    ans = [] \n    while True: \n        if end >= n:\n            break\n        if string[begin] == string[end]:\n            end += 1\n            cnt += 1\n        else:\n            ans.append(string[begin])\n            begin = end \n            end = begin + 1\n            cnt = 1\n\n    return ans\n\n\ndef lps(string): \n    n = len(string)\n    dp = [[0]*n for _ in range(n)] \n\n    for i in range(n): \n        dp[i][i] = 1\n  \n    for cl in range(2, n+1): \n        for i in range(n-cl+1): \n            j = i + cl - 1\n            \n            if string[i] == string[j] and cl == 2: \n                dp[i][j] = 2\n            elif string[i] == string[j]: \n                dp[i][j] = dp[i+1][j-1] + 2\n            else: \n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n  \n    return dp[0][n-1]\n\nn = int(input())\na = list(map(int, input().split()))\n\na = run_length_compress(a)\nlen_pal = lps(a)\nprint(len(a) - 1 - len_pal//2)\n", "a=int(input())\nb = [int(x) for x in input().split()]\nc = [b[0]]\nfor i in b[1:]:\n    if i!=c[-1]:\n        c.append(i)\na=len(c)\n \ndpa = []\ndpb = [0] * (a+1)\nfor i in range(2,a+1):\n    dp=[]\n    for j in range(a-i+1):\n        if c[j] == c[j+i-1]:\n            dp.append(min(dpb[j], dpb[j+1], dpa[j+1])+1)\n        else:\n            dp.append(min(dpb[j], dpb[j+1])+1)\n    dpa, dpb = dpb, dp\nprint(dpb[0])"]