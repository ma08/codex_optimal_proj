["def main():\n    import sys\n    from collections import defaultdict\n    \n    tokens = [int(i) for i in sys.stdin.read().split()]\n    tokens.reverse()\n    \n    n, k = tokens.pop(), tokens.pop()\n    \n    d1 = defaultdict(int)\n    d2 = defaultdict(int)\n    result = 0\n    for i in tokens:\n        result += d2[i * k]\n        d2[i] += d1[i * k]\n        d1[i] += 1\n    \n    print(result)\n    \n    \nmain()\n", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nd = { }\nd2 = { }\nresult = 0\n\nfor x in a:\n    cur = d2.get(x)\n    if cur is not None:\n        result += cur\n    cur = d.get(x)\n    if cur is not None:\n        d2[k * x] = d2.get(k * x, 0) + cur\n    d[k * x] = d.get(k * x, 0) + 1\n\nprint(result)\n", "n, k = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nz = dict()\ns = 0\nfor i in range(n):\n    if not a[i] in z:\n        z[a[i]] = [0, 0, 0]\n    if a[i] % (k * k) == 0 and a[i] // k in z:\n        q = z[a[i] // k][1]\n        z[a[i]][2] += z[a[i] // k][1]\n        s += q\n    if a[i] % k == 0 and a[i] // k in z:\n        z[a[i]][1] += z[a[i] // k][0]\n    z[a[i]][0] += 1\nprint(s)\n", "n, k = [int(i) for i in input().split()]\ns = [int(i) for i in input().split()]\nans = 0\nc = {}\nc2 = {}\nfor i in s:\n    if i in c:\n        c[i]+=1\n    else:\n        c[i] = 1\n    if i%(k) == 0:\n        if i in c2:\n            if i//k in c:\n                c2[i]+=c[i//k]\n        else:\n            if i//k in c:\n                c2[i]=c[i//k]\n            else:\n                c2[i]= 0\n    if i%(k*k) == 0:\n        if i//(k*k) == i//(k):\n            ans+=(c[i//(k*k)]-1)*(c[i//(k*k)]-2)//2\n        else:\n            if i//k in c2:\n                ans+=c2[i//k]\nprint(ans)\n", "def get_sequence(a_indices, b_indices, c_indices):\n    a_i, b_i, c_i = 0, 0, 0\n    i = 0\n    total = len(a_indices) + len(b_indices) + len(c_indices)\n    a_indices = a_indices[:]\n    b_indices = b_indices[:]\n    c_indices = c_indices[:]\n\n    a_indices.append(1000005001)\n    b_indices.append(1000005001)\n    c_indices.append(1000005001)\n    sequence = []\n    while i < total:\n        minimum = calculate_minimum(a_indices[a_i], b_indices[b_i], c_indices[c_i])\n        if minimum == 'a':\n            a_i += 1\n        elif minimum == 'b':\n            b_i += 1\n        elif minimum == 'c':\n            c_i += 1\n        sequence.append(minimum)\n        i += 1\n\n    return sequence\n\n\ndef calculate(a_indices, b_indices, c_indices):\n    sequence = get_sequence(a_indices, b_indices, c_indices)\n\n    a_stack, b_stack, c_stack = 0, 0, 0\n\n    for ch in sequence:\n        if ch == 'a':\n            a_stack += 1\n        elif ch == 'b':\n            b_stack += a_stack\n        elif ch == 'c':\n            c_stack += b_stack\n\n    return c_stack\n\n\ndef calculate_minimum(a_index, b_index, c_index):\n    if a_index < b_index:\n        if a_index < c_index:\n            return 'a'\n        else:\n            return 'c'\n    else:\n        if b_index < c_index:\n            return 'b'\n        else:\n            return 'c'\n\n\ndef main():\n    n, k = [int(t) for t in input().split()]\n    a_list = [int(t) for t in input().split()]\n    hash_map = {}\n    for index, a in enumerate(a_list):\n        if a in hash_map:\n            hash_map[a].append(index)\n        else:\n            hash_map[a] = [index]\n\n    total_gp = 0\n    if k != 1:\n        for a1 in list(hash_map.keys()):\n            a2 = a1 * k\n            a3 = a2 * k\n            if a2 in hash_map and a3 in hash_map:\n                total_gp += calculate(hash_map[a1], hash_map[a2], hash_map[a3])\n    else:\n        for a in list(hash_map.keys()):\n            count = len(hash_map[a])\n            if count >= 3:\n                nc3 = count * (count - 1) / 2 * (count - 2) / 3\n                total_gp += int(nc3)\n\n    print(total_gp)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, k = list(map(int, input().split(\" \")))\na = input().split(\" \")\narr = {}\nzeroes = 0\nlst = {}\nans = 0\nfor i in a:\n    i = int(i)\n    if i == 0:\n        zeroes += 1\n    else:\n        if i in list(arr.keys()):\n            arr[i][0] +=1\n            if (i % k == 0) and (i//k in list(lst.keys())):\n                arr[i][1] += arr[i//k][0] \n        else:\n            arr[i] = [1, 0]\n            if (i % k == 0) and (i//k in list(lst.keys())):\n                arr[i][1] = arr[i//k][0] \n            lst[i] = True\n            \n        if (i % k == 0) and (i//k in list(lst.keys())) :\n            ans += arr[i//k][1]\n            #print (ans)\n\nif k == 1:\n    ans = 0\n    for i in lst:\n        ans += arr[i][0]*(arr[i][0]-1)*(arr[i][0]-2)//6\n\nans += zeroes * (zeroes-1) * (zeroes-2) //6\n        \n    \nprint (ans)\n", "import collections\nimport bisect\n\ndef solve1(dp):\n    count = 0\n    for num in dp.values():\n        n = len(num)\n        if n >= 3:\n            count += n * (n - 1) * (n - 2) // 6\n    return count\n\ndef solve(n, k, As, dp):\n    count = 0\n    for i, ak in enumerate(As):\n        if ak % k:\n            continue\n        if ak == 0:\n            continue\n        a = ak // k\n        akk = ak * k\n        n_left = bisect.bisect_left(dp[a], i)\n        n_right = len(dp[akk]) - bisect.bisect_left(dp[akk], i)\n        count += n_left * n_right\n    n0 = len(dp[0])\n    if n0 >= 3:\n        count += n0 * (n0 - 1) * (n0 - 2) // 6\n    return count\n\nn, k = map(int, input().split())\nAs = list(map(int, input().split()))\ndp = collections.defaultdict(list)\nfor i, a in enumerate(As):\n    dp[a].append(i)\n\nif n < 3:\n    print(0)\nelif k == 1:\n    print(solve1(dp))\nelse:\n    print(solve(n, k, As, dp))", "n, k = [int(x) for x in input().split()]\nmas = [int(x) for x in input().split()]\ndictyCount = {}\ndictyAns = {}\nans = 0\n\nfor x in mas[::-1]:\n\tans += dictyAns.get(x * k, 0)\n\t\n\tdictyAns[x] = dictyAns.get(x, 0) \\\n\t\t\t\t\t+ dictyCount.get(x * k, 0)\n\tdictyCount[x] = dictyCount.get(x, 0) + 1\n\nprint(ans)", "s=0\nm={}\no={}\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\nfor a in l: o[a/k]=m[a/k]=m[a]=o[a]=0\nfor a in l:\n if a%k==0:\n  s+=m[a/k]\n  m[a]+=o[a/k]\n o[a]+=1\nprint(s)", "d = {}\ndata = input().split()\nk = int(data[1])\ndata = input().split()\nans = 0\nfor el in data:\n\tv = int(el)\n\tp = [0,0,]\n\n\tif v in list(d.keys()):\n\t\tp = d[v]\n\n\t\n\n\tif v%k==0 and (v/k) in list(d.keys()):\n\t\tans += d[v/k][1]\n\t\tp[1] += d[v/k][0]\n\t\t\n\n\tp[0] += 1\n\td[v] = p\n\nprint(ans)\n\n\n", "s=0\nm={}\no={}\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\nfor a in l:\n if a%k==0:\n  s+=m.get(a/k,0)\n  m[a]=m.get(a,0)+o.get(a/k,0)\n o[a]=o.get(a,0)+1\nprint(s)", "from sys import stdin, stdout\nfrom collections import defaultdict\n\nn,k = [int(x) for x in stdin.readline().rstrip().split()]\nnums = [int(x) for x in stdin.readline().rstrip().split()]\n\na=defaultdict(lambda: 0)\nb=defaultdict(lambda: 0)\n\nans = 0\n\nfor i in range(n):\n    num = nums[i]\n    if num % k == 0:\n        ans += b[int(num/k)]\n        b[num] += a[int(num/k)]\n    a[num]+=1\nprint(ans)", "from collections import defaultdict\nimport time\n\ndef __starting_point():\n\n    n , k = [int(x) for x in input().split()]\n    nums = [int(x) for x in input().split()]\n\n    #n , k = 200000 , 1\n    #nums = [1 for i in range(n)]\n\n    #t1 = time.time()\n\n    left = [0]*len(nums)\n    predict = defaultdict( int )\n    for i in range( len(nums) ):\n        num = nums[i]\n        if num%k == 0:\n            left[i] = predict[num//k]\n        predict[num] += 1\n        #print( i , \":\" , predict )\n\n    right = [0]*len(nums)\n    nextdict = defaultdict( int )\n    for i in range( len(nums) - 1 , -1 , -1 ):\n        num = nums[i]\n        right[i] = nextdict[num*k]\n        nextdict[num] += 1\n    #print( \"left :\" , left )\n    #print( \"right :\" , right )\n    print( sum([left[i]*right[i] for i in range(len(nums))]) )\n\n    #t2 = time.time()\n    #print( t2-t1 , \"s\" )\n        \n            \n                    \n\n__starting_point()", "n,k = map(int,input().split())\nnums = [int(x) for x in input().split()]\nzero = {}\none = {}\nans = 0\nfor i in range(n):\n    x = nums[i]\n    if x%k==0:\n        if x//k in one:\n            ans+=one[x//k]\n        if x//k in zero:\n            if x not in one:\n                one[x] = 0\n            one[x]+=zero[x//k]\n    if x not in zero:\n        zero[x] = 0\n    zero[x]+=1\nprint(ans)", "s=0\nm={}\no={}\nn,k=map(int,input().split())\nl=list(map(int,input().split()))\nfor a in l:\n if a%k==0:\n  s+=m.get(a/k,0)\n  m[a]=m.get(a,0)+o.get(a/k,0)\n o[a]=o.get(a,0)+1\nprint(s)", "inp, inp1 = map(int, input().split())\ninp2 = list(map(int, input().split()))\n\ndictionary = {}\ndictionaryFNums = {}\n\nk = inp1\nres = 0\nfor n in range(inp):\n    element = inp2[n]\n    if (element % k == 0):\n        res += dictionary.get(element/k, 0)\n        dictionary[element] = dictionary.get(element, 0) + dictionaryFNums.get(element/k, 0)\n    dictionaryFNums[element] = dictionaryFNums.get(element, 0)+1\nprint(res)", "import collections\nk=int(input().split()[1])\nd=[collections.defaultdict(int)for _ in\"123\"]\nfor x in map(int,input().split()):\n\td[2][k*x]+=d[1][x]\n\td[1][k*x]+=d[0][x]\n\td[0][k*x]+=1\nprint(sum(d[2].values()))\n", "n, k = list(map(int,input().split()))\nmain = list(map(int,input().split()))\n\nfreq, kolgeom, kolvo = {},{},0\n\nfor a in main:\n    if not (a in freq): freq[a]=0\n    if a % k == 0:\n        if (a / k) in kolgeom: kolvo += kolgeom[a / k]\n        if not(a in kolgeom): kolgeom[a] = 0\n        if (a / k) in freq: kolgeom[a] += freq[a / k]\n    freq[a]+=1\nprint(kolvo)\n\n", "import sys\nfrom collections import defaultdict\n\n#sys.stdin = open('input')\n\n\ndef main():\n    n, k = [int(x) for x in input().split()]\n    a = [int(x) for x in input().split()]\n    current_sequence = defaultdict(list)\n    total_subsequences = 0\n    default = [0, 0]\n    for elem in a:\n        previous = elem / k\n        if elem not in current_sequence:\n            current_sequence[elem] = default.copy()\n        total_subsequences += current_sequence.get(previous, default)[0]\n        current_sequence[elem][0] += current_sequence.get(previous, default)[1]\n        current_sequence[elem][1] += 1\n    print(total_subsequences)\n\nmain()\n", "from collections import defaultdict\nimport functools\n\n\ndef main():\n    N, K = tuple(int(n) for n in input().split())\n    NS = tuple(int(n) for n in input().split())\n    nst = defaultdict(lambda: [0, 0, 0])\n\n    for n in NS:\n        if n == 0:\n            nst[0][2] += nst[0][1]\n            nst[0][1] += nst[0][0]\n            nst[0][0] += 1\n        else:\n            d, m = divmod(n, K)\n            if d != 0 and m == 0:\n                nst[n][2] += nst[n//K][1]\n                nst[n][1] += nst[n//K][0]\n            nst[n][0] += 1\n    print(functools.reduce(lambda x, y: x + y[2], nst.values(), 0))\n\n\ndef __starting_point():\n    main()\n__starting_point()", "n,k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nlf = {}\nrt = {}\nfor x in a:\n    lf[x] = 0\n    try:\n        rt[x] += 1\n    except KeyError:\n        rt[x] = 1\n\nprog = 0\nfor x in a:\n    try:\n        if(x%k==0):\n            rt[x] -= 1\n            prog += lf[x//k]*rt[x*k]\n    except KeyError:\n        pass\n    finally:\n        \n        lf[x] += 1\n\n\nprint(prog)\n    \n", "n, k = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nd1 = {a[0] : 1}\nd2 = {}\ndp1 = [0]\ndp2 = [0, 0]\nfor i in range(1, n):\n    if a[i] % k == 0 and a[i] // k in d1:\n            dp1.append(d1[a[i] // k])\n            if a[i] % (k ** 2) == 0 and a[i] // k in d2:\n                #dp2.append(sum(d2[a[i] // k]))\n                dp2.append(d2[a[i] // k])\n            else:\n                dp2.append(0)\n    else:\n        dp1.append(0)\n        dp2.append(0)\n    if a[i] in d1:\n        d1[a[i]] += 1\n    else:\n        d1[a[i]] = 1\n    if a[i] in d2:\n        d2[a[i]] += dp1[i]\n    else:\n        d2[a[i]] = dp1[i]\n\nprint(sum(dp2))\n", "from collections import Counter\n\nn, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\n\nlk = {}\nans = 0\n\nrk = Counter(a)\n\nfor x in a:\n    rk[x] -= 1\n    if x%k == 0:\n        ans += lk.get(x/k, 0) * rk.get(x*k, 0)\n    lk[x] = 1 + lk.get(x, 0)\n\nprint(ans)\n", "n,k= list(map(int,input().split(\" \")))\nmas=list(map(int,input().split(\" \")))\ndi=dict()\nres=9999999999999999999999999999999999999\nfor i in mas:\n    a = i*k\n    a3 = str(a)+\"_3\"\n    a2=str(a)+\"_2\"\n    s1 = str(i)+\"_1\"\n    s2=str(i)+\"_2\"\n    s3=str(i)+\"_3\"\n    if di.get(s3):\n        res+=di.get(s3)\n    if di.get(s2):\n        if di.get(a3):\n            di[a3]+=di.get(s2)\n        else:\n            di[a3]=di.get(s2)\n    if di.get(s1):\n        if di.get(a2):\n            di[a2]+=1\n        else:\n            di[a2]=1\n        di[s1]+=1\n    else:\n        if di.get(a2):\n            di[a2]+=1\n        else:\n            di[a2]=1\n        di[s1]=1\n\n\nprint(res-9999999999999999999999999999999999999)\n\n\n", "__author__ = 'taras-sereda'\n\nfrom collections import Counter\n\nn,k = list(map(int,input().split()))\nsequence = list(map(int,input().split()))\nr = Counter(sequence)\nl = dict.fromkeys(r,0)\n# print(sequence)\n# print(r)\nres = 0\nfor i in sequence:\n    r[i] -= 1\n    if i%k == 0 and int(i*k) in r and int(i/k) in l:\n\n        res += r[i*k] * l[i/k]\n    l[i] += 1\n\nprint(res)\n\n\n"]