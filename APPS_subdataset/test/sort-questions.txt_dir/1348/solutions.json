["from math import ceil\n\ndef mkgr(n, srs, k):\n  res = [str(n-1)]\n  for d in srs[1]:\n    res.append(\"%i %i\" % (srs[0][0]+1, d+1))\n  for i in range(2, len(srs)):\n    h, hs= 0, 0\n    for j in range(len(srs[i])):\n      res.append(\"%i %i\" % (srs[i][j]+1, srs[i-1][h]+1))\n      hs += 1\n      if hs == k-1:\n        h += 1\n        hs = 0\n      \n  return res\n\ndef test(n,k,dists):\n  m = max(dists)\n  srs = [[] for i in range(m+1)]\n  for i in range(n):\n    srs[dists[i]].append(i)\n  if [] in srs:\n    return [\"-1\"]\n  if len(srs[0]) != 1:\n    return [\"-1\"]\n  if len(srs[1]) > k:\n    return [\"-1\"]\n  for i in range(1, m):\n    if ceil(len(srs[i+1])/len(srs[i])) + 1 > k:\n      return [\"-1\"]\n  return mkgr(n, srs, k)\n\nn, k = list(map(int, input().split()))\ndists = list(map(int, input().split()))\nres = test(n,k,dists)\nprint(\"\\n\".join(res))\n", "n, k = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\ndmax = max(d)\n\nnv = [[] for i in range(dmax+1)]\nv = [0] * (dmax+1)\n\nfor i, dist in enumerate(d):\n    nv[dist].append(i)\n    v[dist] += 1\n\nflag = True\nif v[0] != 1 or v[1] > k:\n    flag = False\nelse:\n    for i in range(2, dmax+1):\n        if v[i] > (k-1) * v[i-1] or v[i] == 0:\n            flag = False\n            break\n\nif flag:\n    print(n-1)\n    for vrtx in nv[1]:\n        print(nv[0][0] + 1, vrtx + 1)\n    for i, vs in enumerate(nv[1:-1]):\n        for j, vrtx in enumerate(vs):\n            m = 0\n            while m < (k-1):\n                if (j*(k-1) + m) < len(nv[i+2]):\n                    print(vrtx + 1, nv[i+2][j*(k-1) + m] + 1)\n                    m += 1\n                else:\n                    break\n\nelse:\n    print(-1)\n", "n,k=list(map(int,input().split()))\nd=list(zip( list(map(int,input().split())),list(range(0,n)) ))\nd=sorted(d)\n\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last<j and ( du[last]==k or d[last][0]+1!=d[j][0] ):\n        last+=1\n    if last==j or d[0][0]!=0:\n        print(-1)\n        break\n    fa[j]=last\n    du[j]+=1\n    du[last]+=1\nelse:\n    print(n-1)\n    for j in range(1,n):\n        print(d[fa[j]][1]+1,d[j][1]+1)\n", "n, k = map(int, input().split())\nt = list(map(int, input().split()))\ns, p = [], [[] for i in range(max(t) + 1)]\nfor i, j in enumerate(t, 1): p[j].append(str(i))\nif len(p[0]) - 1: print('-1')\nelse:\n    for i in range(1, len(p)):\n        if k * len(p[i - 1]) < len(p[i]):\n            print('-1')\n            return\n        j, u, v = 0, len(p[i]) // k, len(p[i]) % k\n        for x in range(u):\n            s += [p[i - 1][x] + ' ' + p[i][y] for y in range(j, j + k)]\n            j += k\n        s += [p[i - 1][u] + ' ' + p[i][y] for y in range(j, j + v)]\n        if i == 1: k -= 1\n    print(len(s))\n    print('\\n'.join(s))", "from collections import deque\n\ndef solve():\n\tn, k = list(map(int, input().split()))\n\ta = list(enumerate(map(int, input().split()), 1))\n\ta.sort(key=lambda x: x[1])\n\t\n\tif a[0][1]:\n\t\tprint(-1)\n\t\treturn\n\te = []\n\tq = deque([[1, k, a[0][0]]])\n\t\n\tfor i, x in a[1:]:\n\t\twhile q and q[0][0] < x:\n\t\t\tq.popleft()\n\t\tif not q or q[0][0] != x:\n\t\t\tprint(-1)\n\t\t\treturn\n\t\tif k > 1:\n\t\t\tq.append([x+1, k-1, i])\n\t\te.append((q[0][2], i))\n\t\tq[0][1] -= 1\n\t\tif not q[0][1]:\n\t\t\tq.popleft()\n\tprint(len(e))\n\tprint('\\n'.join(' '.join(map(str, x)) for x in e))\n\ndef __starting_point():\n\tsolve()\n\n__starting_point()", "n, k = map(int, input().split())\nd = sorted(zip(list(map(int,input().split())), range(0,n)))\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last < j and (du[last] == k or d[last][0] + 1 != d[j][0]):\n        last += 1\n    if last == j or d[0][0] != 0:\n        print(-1)\n        break\n    fa[j] = last\n    du[j] += 1\n    du[last] += 1\nelse:\n    print(n - 1)\n    for j in range(1, n):\n        print(d[fa[j]][1]+1,d[j][1]+1)", "import os\nimport sys\nimport copy\n\n# sys.stdin = open(os.path.join(os.path.dirname(__file__), '7.in'))\n\nn,k = map(lambda x:int(x), input().split())\n# G = [[-1 for _ in range(n+1)] for _ in range(n+1)]\nC = [0 for _ in range(n+1)]\nd = [ {'d':int(_),'idx':i+1} for i, _ in enumerate(input().split())]\nd.sort(key = lambda x: x['d'])\n\n# print(d)\npos = True\neg = 0\nreeg = []\n# multi zero number\ncz = 0\nfor dis in d:\n    if dis['d'] == 0:\n        cz += 1 \n\nif cz != 1:\n    pos= False\nelse:\n    first = True\n    c_vertex = -1\n    Preidx = 0\n    PPreidx = 0\n    pd = 2<<30\n    for i,vx in enumerate(d):\n        if i == 0 :\n            c_vertex = vx['idx']\n            pd = 0\n            continue   \n        # print(vx)\n        find = False\n        if vx['d'] == pd:\n            vvbg= PPreidx\n        else:\n            vvbg = Preidx\n        # print(\"ss\",vx,d[vvbg],PPreidx,Preidx)\n        \n        while vvbg < i:\n            # print(\"ss\",vx,d[vvbg])\n            if C[d[vvbg]['idx']] < k:\n                if d[vvbg]['d'] + 1 != vx['d']:\n                    pos = False\n                    break\n                # G[d[vvbg]['idx']][vx['idx']] = 1\n                C[d[vvbg]['idx']] += 1\n                C[vx['idx']] += 1\n                eg += 1\n                find = True\n                reeg.append((d[vvbg]['idx'],vx['idx']))\n                break\n            # else:\n            #     Preidx += 1\n            vvbg += 1\n                # print(reeg)\n        if not find:\n            pos = False\n\n        if i >= 1 and vx['d'] != pd:\n            # print(\"ppre\", Preidx, PPreidx)\n            PPreidx = Preidx\n            Preidx=i\n        pd = vx['d']\n        \nif pos:\n    print(eg)\n    for a,b in reeg:\n        print(a,b)\nelse:\n    print(-1)", "\n\nn, k = list(map(int, input().split()))\nnodes = [[] for _ in range(n+1)]\nedges = []\n\nfor node, dist in enumerate(map(int, input().split())):\n    nodes[dist].append(node)\n\nif len(nodes[0]) != 1 or len(nodes[1]) > k:\n    print(-1)\nelse:\n    for i in range(1, n):\n        if len(nodes[i])*(k-1) < len(nodes[i+1]):\n            print(-1)\n            return\n    for i in range(n):\n\n        next = 0\n\n        if len(nodes[i+1]) > 0:\n            for j, node in enumerate(nodes[i]):\n\n                current = 0\n\n                while current < (k if i == 0 else k-1) and next < len(nodes[i+1]):\n                    edges.append((node+1, nodes[i+1][next]+1))\n                    next += 1\n                    current += 1\n\n    print(len(edges))\n    print('\\n'.join([' '.join([str(x[0]), str(x[1])]) for x in edges]))\n", "n,k=list(map(int,input().split()))\nd=list(zip( list(map(int,input().split())),list(range(0,n)) ))\nd=sorted(d)\n\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last<j and ( du[last]==k or d[last][0]+1!=d[j][0] ):\n        last+=1\n    if last==j or d[0][0]!=0:\n        print(-1)\n        break\n    fa[j]=last\n    du[j]+=1\n    du[last]+=1\nelse:\n    print(n-1)\n    for j in range(1,n):\n        print(d[fa[j]][1]+1,d[j][1]+1)\n\n", "n,k=list(map(int,input().split()))\nd=list(zip( list(map(int,input().split())),list(range(0,n)) ))\nd=sorted(d)\n\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last<j and ( du[last]==k or d[last][0]+1!=d[j][0] ):\n        last+=1\n    if last==j or d[0][0]!=0:\n        print(-1)\n        break\n    fa[j]=last\n    du[j]+=1\n    du[last]+=1\nelse:\n    print(n-1)\n    for j in range(1,n):\n        print(d[fa[j]][1]+1,d[j][1]+1)\n\n", "n,k=list(map(int,input().split()))\nd=list(zip( list(map(int,input().split())),list(range(0,n)) ))\nd=sorted(d)\n\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last<j and ( du[last]==k or d[last][0]+1!=d[j][0] ):\n        last+=1\n    if last==j or d[0][0]!=0:\n        print(-1)\n        break\n    fa[j]=last\n    du[j]+=1\n    du[last]+=1\nelse:\n    print(n-1)\n    for j in range(1,n):\n        print(d[fa[j]][1]+1,d[j][1]+1)\n\n", "n,k=list(map(int,input().split()))\nd=list(zip( list(map(int,input().split())),list(range(0,n)) ))\nd=sorted(d)\n\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last<j and ( du[last]==k or d[last][0]+1!=d[j][0] ):\n        last+=1\n    if last==j or d[0][0]!=0:\n        print(-1)\n        break\n    fa[j]=last\n    du[j]+=1\n    du[last]+=1\nelse:\n    print(n-1)\n    for j in range(1,n):\n        print(d[fa[j]][1]+1,d[j][1]+1)\n\n", "n,k=list(map(int,input().split()))\nd=list(zip( list(map(int,input().split())),list(range(0,n)) ))\nd=sorted(d)\n\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last<j and ( du[last]==k or d[last][0]+1!=d[j][0] ):\n        last+=1\n    if last==j or d[0][0]!=0:\n        print(-1)\n        break\n    fa[j]=last\n    du[j]+=1\n    du[last]+=1\nelse:\n    print(n-1)\n    for j in range(1,n):\n        print(d[fa[j]][1]+1,d[j][1]+1)\n\n", "n,k=list(map(int,input().split()))\nd=list(zip( list(map(int,input().split())),list(range(0,n)) ))\nd=sorted(d)\n\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last<j and ( du[last]==k or d[last][0]+1!=d[j][0] ):\n        last+=1\n    if last==j or d[0][0]!=0:\n        print(-1)\n        break\n    fa[j]=last\n    du[j]+=1\n    du[last]+=1\nelse:\n    print(n-1)\n    for j in range(1,n):\n        print(d[fa[j]][1]+1,d[j][1]+1)\n\n", "n,k=list(map(int,input().split()))\nd=list(zip( list(map(int,input().split())),list(range(0,n)) ))\nd=sorted(d)\n\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last<j and ( du[last]==k or d[last][0]+1!=d[j][0] ):\n        last+=1\n    if last==j or d[0][0]!=0:\n        print(-1)\n        break\n    fa[j]=last\n    du[j]+=1\n    du[last]+=1\nelse:\n    print(n-1)\n    for j in range(1,n):\n        print(d[fa[j]][1]+1,d[j][1]+1)\n\n", "n,k=map(int,input().split())\nd=zip( list(map(int,input().split())),range(0,n) )\nd=sorted(d)\n\nlast=0\ndu=[0]*n\nfa=[0]*n\nflag=1\nfor j in range(1,n):\n    while last<j and ( du[last]==k or d[last][0]+1!=d[j][0] ):\n        last+=1\n    if last==j or d[0][0]!=0:\n        print(-1)\n        break\n    fa[j]=last\n    du[j]+=1\n    du[last]+=1\nelse:\n    print(n-1)\n    for j in range(1,n):\n        print(d[fa[j]][1]+1,d[j][1]+1)", "n, k = map(int, input().split())\nt = list(map(int, input().split()))\ns, p = [], [[] for i in range(max(t) + 1)]\nfor i, j in enumerate(t, 1): p[j].append(str(i))\nif len(p[0]) - 1: print('-1')\nelse:\n    for i in range(1, len(p)):\n        if k * len(p[i - 1]) < len(p[i]):\n            print('-1')\n            return\n        j, u, v = 0, len(p[i]) // k, len(p[i]) % k\n        for x in range(u):\n            s += [p[i - 1][x] + ' ' + p[i][y] for y in range(j, j + k)]\n            j += k\n        s += [p[i - 1][u] + ' ' + p[i][y] for y in range(j, j + v)]\n        if i == 1: k -= 1\n    print(len(s))\n    print('\\n'.join(s))", "class RestoreGraph():\n    def __init__(self,n, k, dis_values):\n        self.dis_values = dis_values\n        self.n = n\n        self.k = k\n\n    def generate_graph(self):\n        dis_pairs = [(self.dis_values[i],i) for i in range(len(self.dis_values))]\n        dis_pairs = sorted(dis_pairs)\n        if dis_pairs[0][0] != 0:\n            print(-1)\n            return\n        count = [0]*self.n\n        parent = [-1]*self.n\n        ind = 0\n        for i in range(1, self.n):\n            if dis_pairs[ind][0] != dis_pairs[i][0]-1 or count[ind] == self.k:\n                ind = ind+1\n                while(ind < i and (dis_pairs[ind][0] < dis_pairs[i][0]-1 or count[ind] == self.k)):\n                    ind += 1\n                if dis_pairs[ind][0] != dis_pairs[i][0]-1 or count[ind] == self.k:\n                    print(-1)\n                    return\n            parent[i] = ind\n            count[i] += 1\n            count[ind] += 1\n        print(self.n-1)\n        for i in range(1,n):\n            print(dis_pairs[i][1]+1, dis_pairs[parent[i]][1]+1)\n\n\nn, k = list(map(int,input().strip(' ').split(' ')))\narr = list(map(int,input().strip(' ').split(' ')))\n\ngraph = RestoreGraph(n,k,arr)\ngraph.generate_graph()\n", "'''input\n3 1\n0 1 2\n'''\nfrom sys import stdin\nimport collections\nimport math\nimport queue\n\n\n# main starts\nn, k = list(map(int, stdin.readline().split()))\ndistance = list(map(int, stdin.readline().split()))\n\n# n = 65535; k = 3\n# distance = []\n# for i in range(16):\n# \tfor j in range(2 **i):\n# \t\tdistance.append(i)\n\nfor i in range(n):\n\tdistance[i] = [i + 1, distance[i]]\n\ndistance = sorted(distance, key = lambda x:x[1])\n\nif distance[0][1] != 0:\n\tprint(-1)\n\treturn\n\nedges = []\ni = 1\nbuff = collections.deque()\nbuff.append(distance[0])\n\nwhile len(buff) > 0 and i < n:\n\tprev_node, prev_dist = buff.popleft()\n\n\tcount = 0\n\twhile i < n:\n\t\tif prev_dist + 1 == distance[i][1]:\n\t\t\tif (count == k and prev_dist == 0) or (count == k - 1 and prev_dist != 0):\n\t\t\t\tbreak\n\t\t\tedges.append([prev_node, distance[i][0]])\n\t\t\tbuff.append(distance[i])\n\t\t\tcount += 1\n\t\t\ti += 1\n\n\n\t\telif prev_dist + 2 == distance[i][1]:\n\t\t\tbreak\n\t\telse:\t\n\t\t\tprint(-1)\n\t\t\treturn\nif i != n:\n\tprint(-1)\n\treturn\nprint(len(edges))\nfor i in edges:\n\tprint(*i)", "n, k = list(map(int, input().split()))\nd = list(map(int, input().split()))\nmax_d = max(d)\nlevels = [[] for i in range(max_d+1)]\ngraph = {}\nfor i in range(len(d)):\n    levels[d[i]].append(i+1)\n\ndef do_this():\n    nonlocal n,k, d, max_d, levels, graph\n    q = []\n    last_level = levels[0]\n    if len(last_level) != 1:\n        print(-1)\n        return\n    for i in range(1, max_d+1):\n        if i == 2:\n            k = k-1\n        if k == 0:\n            print(-1)\n            return\n        cur_level = levels[i]\n        for j in range(len(cur_level)):\n            if j/k >= len(last_level):\n                print(-1)\n                return\n            q.append((last_level[int(j/k)], cur_level[j]))\n        last_level = cur_level\n    print(len(q))\n    for a,b in q: print(a, b)\n\ndo_this()\n", "n, k = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\n\nd = {}\nfor idx, x in enumerate(a):\n    if x not in d:\n        d[x] = [idx]\n    else:\n        d[x].append(idx)\n\nif 0 not in d or len(d[0]) != 1:\n    print(-1)\n    import sys; return\n\nres = []\n\nfor x in range(1, max(d.keys())+1):\n    if x not in d or len(d[x]) > len(d[x-1])*(k if x-1 is 0 else k-1):\n        print(-1)\n        import sys; return\n    t = d[x][:]\n    p = d[x-1][:]\n    z = (0 if x-1 is 0 else 1)\n    while(t):\n        res.append((p[-1]+1, t[-1]+1))\n        del t[-1]\n        z += 1\n        if z == k:\n            z = 1\n            del p[-1]\n        \nprint(len(res))\nfor x, y in res:\n    print(x, y)", "n, k = input().split()\nn = int(n)\nk = int(k)\n\nd = input().split()\nd = [int(x) for x in d]\n\nfreq = [[] for _ in range(n)]\n\nfor idx, x in enumerate(d):\n  freq[x].append(idx+1)\n\nif len(freq[0]) != 1:\n  print('-1')\n  import sys; return\n  \nsolution = []\nfor i in range(1, n):\n  if i-1 != 0:\n    new_k = k-1\n  else:\n    new_k = k\n  if len(freq[i]) > len(freq[i-1]) * new_k:\n    print('-1')\n    import sys; return\n  prev = freq[i-1]\n  idx = 0\n  counter = 0\n  for x in freq[i]:\n    solution.append((prev[idx], x))\n    counter += 1\n    if counter == (k if i-1 == 0 else k-1):\n      idx += 1\n      counter = 0\n\nprint(len(solution))\nfor x, y in solution:\n  print(x, y)\n\n", "import sys\ninput = sys.stdin.readline\nI = lambda : list(map(int,input().split()))\n\nn,k = I()\nd=I();ed=[]\nd=sorted([[d[i],i+1] for i in range(n)])\ni=1;cur=[d[0][1]];l=0;f=1\nif d[0][0]!=0:\n\tf=0\nwhile i<n:\n\tx=len(cur);m=x*(k-1) if i!=1 else k\n\tr=0;j=0;ll=[]\n\twhile i<n and d[i][0]==l+1:\n\t\tif j>=x:\n\t\t\tr=m+1;break\n\t\ted.append([cur[j],d[i][1]])\n\t\tll.append(d[i][1])\n\t\ti+=1;r+=1\n\t\tif r==((j+1)*(k-1) if l!=0 else k):\n\t\t\tj+=1\n\tif r==0 or r>m:\n\t\tf=0;break\n\tcur=list(ll)\n\tl+=1\nif f:\n\tprint(len(ed))\n\tfor i in range(len(ed)):\n\t\tprint(*ed[i])\nelse:\n\tprint(-1)", "\n\ndef read_int():\n    return int(input().strip())\n\n\ndef read_ints():\n    return list(map(int, input().strip().split(' ')))\n\n\ndef solve():\n    n, k = read_ints()\n    d = read_ints()\n    S = [[] for _ in range(n)]\n    for i in range(n):\n        S[d[i]].append(i)\n    if len(S[0]) != 1:\n        return -1\n    G = [[] for _ in range(n)]\n    degree = [0]*n\n    depth = 1\n    construct_count = 1\n    edges = []\n    for depth in range(1, n):\n        i = 0\n        prev_len = len(S[depth-1])\n        if len(S[depth]) == 0:\n            break\n        for vertex in S[depth]:\n            parent_vertex = S[depth-1][i%prev_len]\n            degree[parent_vertex] += 1\n            if degree[parent_vertex] > k:\n                return -1\n            degree[vertex] += 1\n            if degree[vertex] > k:\n                return -1\n            G[parent_vertex].append(vertex)\n            edges.append((parent_vertex, vertex))\n            construct_count += 1\n            i += 1\n    if construct_count != n:\n        return -1\n    print(len(edges))\n    for u, v in edges:\n        print(u+1, v+1)\n\n    \ndef __starting_point():\n    if solve() == -1:\n        print(-1)\n\n__starting_point()", "def solve(n,k,d):\n\tdist = [[] for i in range(n)]\n\tfor u in range(n):\n\t\tdist[d[u]].append(u)\n\tif len(dist[0])!=1:\n\t\treturn []\n\n\tans = []\n\tfor t in range(1,n):\n\t\tnxt = []\n\t\tj = 0\n\t\tlim = k if t==1 else (k-1)\n\t\tctr = 0\n\t\tfor u in dist[t]:\n\t\t\tif ctr==lim:\n\t\t\t\tctr = 0\n\t\t\t\tj += 1\n\t\t\tif j==len(dist[t-1]):\n\t\t\t\treturn []\n\t\t\telse:\n\t\t\t\tans.append((dist[t-1][j]+1,u+1))\n\t\t\t\tctr += 1\n\treturn ans\n\nn, k = list(map(int,input().split()))\nd = [int(x) for x in input().split()]\nans = solve(n,k,d)\nif ans==[]:\n\tprint(-1)\nelse:\n\tprint(len(ans))\n\tfor e in ans:\n\t\tprint(*e)\n"]