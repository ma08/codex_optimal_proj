["N, T = list(map(int, input().split()))\nA = [int(a) for a in input().split()]\nif sum(A) > N//2:\n    A = [1-a for a in A][::-1]\nK = sum(A)\nS = sum(A[-K:])\nM = K + 1\nP = 10**9+7\ninv = pow(N*(N-1)//2, P-2, P)\nX = [[0]*M for _ in range(M)]\nfor i in range(M):\n    if i > 0: X[i-1][i] = ((K-i+1)**2*inv)%P\n    if i < M-1: X[i+1][i] = (N-2*K+i+1)*(i+1)*inv%P\n    X[i][i] = (1-((K-i)**2*inv)-(N-2*K+i)*(i)*inv)%P\n\ndef ddd(n):\n    for i in range(1, 100):\n        if (n*i%P) < 100:\n            return (n*i%P), i\n    return -1, -1\ndef poww(MM, n):\n    if n == 1:\n        return MM\n    if n % 2:\n        return mult(poww(MM, n-1), MM)\n    return poww(mult(MM,MM), n//2)\ndef mult(M1, M2):\n    Y = [[0] * M for _ in range(M)]\n    for i in range(M):\n        for j in range(M):\n            for k in range(M):\n                Y[i][j] += M1[i][k] * M2[k][j]\n                Y[i][j] %= P\n    return Y\n\nX = poww(X, T)\n\nprint(X[S][K])\n", "M = 10 ** 9 + 7\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nz, o = a.count(0), a.count(1)\nd = pow(n * (n - 1) // 2, M - 2, M)\n\nif z > o:\n    o, z = z, o\n    a = [1 - x for x in a][::-1]\n\nres = [[0] * (z + 1) for i in range(z + 1)]\ntf = [[0] * (z + 1) for i in range(z + 1)]\nfor i in range(z + 1):\n    res[i][i] = 1\n    tf[i][i] = (z * (z - 1) // 2 + o * (o - 1) // 2 + i * (z - i) + (z - i) * (o - z + i)) * d % M\n    if i < z: tf[i + 1][i] = (z - i) * (z - i) * d % M\n    if i: tf[i - 1][i] = i * (o - z + i) * d % M\n\ndef mul(a, b):\n    t = [[0] * (z + 1) for i in range(z + 1)]\n    for i in range(z + 1):\n        for k in range(z + 1):\n            for j in range(z + 1):\n                t[i][j] = (t[i][j] + a[i][k] * b[k][j]) % M\n    return t\n\nwhile k:\n    if k & 1:\n        res = mul(res, tf)\n    tf = mul(tf, tf)\n    k >>= 1\n\nprint(res[-1][a[:z].count(0)])", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Codeforces Round #553 (Div. 2)\n\nProblem F. Sonya and Informatics\n\n:author:         Kitchen Tong\n:mail:    kctong529@gmail.com\n\nPlease feel free to contact me if you have any question\nregarding the implementation below.\n\"\"\"\n\n__version__ = '1.8'\n__date__ = '2019-04-21'\n\nimport sys\n\n\ndef binom_dp():\n    dp = [[-1 for j in range(110)] for i in range(110)]\n    def calculate(n, k):\n        if n < k:\n            return 0\n        if n == k or k == 0:\n            return 1\n        if dp[n][k] > 0:\n            return dp[n][k]\n        else:\n            dp[n][k] = calculate(n-1, k-1) + calculate(n-1, k)\n        return dp[n][k]\n    return calculate\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef multiply(A, B, mod):\n    if not hasattr(B[0], '__len__'):\n        C = [sum(aij * B[j] % mod for j, aij in enumerate(ai)) for ai in A]\n    else:\n        C = [[0 for col in range(len(B[0]))] for row in range(len(A))]\n        len_A = len(A)\n        len_B = len(B)\n        for row in range(len_A):\n            if sum(A[row]) == 0:\n                continue\n            for col in range(len_B):\n                C[row][col] = sum(A[row][k] * B[k][col]\n                                  for k in range(len_B)) % mod\n    return C\n\ndef memoize(func):\n    memo = {}\n    def wrapper(*args):\n        M, n, mod = args\n        if n not in memo:\n            memo[n] = func(M, n, mod)\n        return memo[n]\n    return wrapper\n\n@memoize\ndef matrix_pow(M, n, mod):\n    # print(f'n is {n}')\n    if n == 2:\n        return multiply(M, M, mod)\n    if n == 1:\n        return M\n    sub_M = matrix_pow(M, n//2, mod)\n    if n % 2 == 0:\n        return multiply(sub_M, sub_M, mod)\n    return multiply(sub_M, matrix_pow(M, n - n//2, mod), mod)\n\ndef solve(n, k, a, binom, mod):\n    ones = sum(a)\n    zeros = n - ones\n    M = [[0 for col in range(zeros+1)] for row in range(zeros+1)]\n    for row in range(max(0, zeros-ones), zeros+1):\n        pre_zeros = row\n        pre_ones = zeros - pre_zeros\n        post_zeros = pre_ones\n        post_ones = ones - pre_ones\n        M[row][row] = (pre_ones * post_ones + pre_zeros * post_zeros\n                       + binom(zeros, 2) + binom(ones, 2))\n        if row > max(0, zeros-ones):\n            M[row-1][row] = pre_zeros * post_ones\n        if row < zeros:\n            M[row+1][row] = post_zeros * pre_ones\n    M = [matrix_pow(M, k, mod)[-1]]\n    b = [0] * (zeros + 1)\n    b[zeros - sum(a[:zeros])] = 1\n    C = multiply(M, b, mod)\n    return C[-1]\n\n\ndef main(argv=None):\n    mod = int(1e9) + 7\n    n, k = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    binom = binom_dp()\n    P = solve(n, k, a, binom, mod)\n    if P == 0:\n        print(0)\n    else:\n        Q = pow(binom(n, 2), k, mod)\n        print(P * modinv(Q, mod) % mod)\n    return 0\n\n\ndef __starting_point():\n    STATUS = main()\n    return(STATUS)\n\n\n__starting_point()"]