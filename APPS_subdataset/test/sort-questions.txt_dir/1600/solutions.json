["#!/usr/bin/env python3\n\nfrom collections import Counter\n\nn = int(input())\nh_u = tuple(map(int, input().split()))\nh_s = sorted(h_u)\n\ni = 0\na = Counter()\nb = Counter()\n\nnum_partitions = 0\n\nfor i in range(n):\n  a[h_u[i]] += 1\n  b[h_s[i]] += 1\n\n  if (a == b):\n    num_partitions += 1\n    a = Counter()\n    b = Counter()\n\nprint(num_partitions)", "n = int(input())\na = [int(i) for i in input().split()]\npref = [0] * (n + 1)\nfor i in range(n):\n\tpref[i + 1] = max(pref[i], a[i])\nsuff = [0] * n\nsuff[n - 1] = a[n - 1]\nfor i in range(n - 2, -1, -1):\n\tsuff[i] = min(suff[i + 1], a[i])\nc = 0\nfor i in range(n):\n\tif pref[i] <= suff[i]:\n\t\tc += 1\nprint(c)", "n = int(input())\ns = input().split()\na = [[0] * 2 for i in range(n)]\n\nfor i in range(n):\n    a[i][0] = int(s[i])\n    a[i][1] = i\n\na.sort()\n\n\nif (a[0][1] == n-1 or a[n-1][1] == 0):\n    print(1)\nelse:\n    sum = 0\n    res = 0\n    ans = 0\n    for i in range(n):\n        sum += a[i][1]\n        res += i\n        if sum == res:\n            ans += 1\n\n    print(ans)\n", "n = int(input())\nhs = list(map(int, input().split()))\n\ndef solve(n, hs):\n    mins = fill_mins(n, hs)\n    maxs = fill_maxs(n, hs)\n    count = 1\n    for i in range(n - 1):\n        if maxs[i] <= mins[i + 1]:\n            count += 1\n    return count    \n\ndef fill_mins(n, hs):\n    mins = []\n    tmp = float('inf')\n    for h in hs[::-1]:\n        if h < tmp:\n            tmp = h\n        mins.append(tmp)\n    mins.reverse()\n    return mins\n\ndef fill_maxs(n, hs):\n    maxs = []\n    tmp = 0\n    for h in hs:\n        if h > tmp:\n            tmp = h\n        maxs.append(tmp)\n    return maxs\n\nprint(solve(n, hs))", "def main():    \n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = sorted(a)\n    \n    diff = 0\n    d = {}\n    result = 0\n    maxi = 0\n    for i in range(n):\n        if a[i] not in d: d[a[i]] = 0\n        if b[i] not in d: d[b[i]] = 0\n        if d[a[i]] == 0: diff += 1\n        d[a[i]] += 1\n        if d[a[i]] == 0: diff -= 1\n        if d[b[i]] == 0: diff += 1\n        d[b[i]] -= 1\n        if d[b[i]] == 0: diff -= 1    \n        if diff == 0: result += 1\n    \n    print(result)\n    \n\nmain()", "def solve( h , n ):\n\n    sortedH = sorted(h)\n    hsum = [0]\n    for i in range(1,n+1):\n        hsum.append( hsum[i-1] + sortedH[i-1] )\n\n    tsum = 0\n    start =0\n    res = 0\n    for i,hi in enumerate(h):\n        tsum += hi\n        if tsum == hsum[i+1]-hsum[start]:\n            res += 1\n            tsum = 0\n            start = i + 1\n\n    return res\n\ndef __starting_point():\n\n    n = int( input() )\n    h = [ int(x)-1 for x in input().split() ]\n\n    print( solve( h , n ) )\n__starting_point()", "from collections import Counter\n\ndef __starting_point():\n    n = int(input())\n    data = list(map(int, input().split()))\n    dd = {}\n    for i, x in enumerate(sorted(data)):\n        if x not in dd:\n            dd[x] = i\n\n    m = None\n    c = 0\n    n_pos = None\n\n    counter = Counter()\n\n    for i, x in enumerate(data):\n        if n_pos is None:\n            if dd[x] + counter[x] == i:\n                c += 1\n            else:\n                n_pos = dd[x] + counter[x]\n                m = x\n        else:\n            if x >= m:\n                m = x\n                n_pos = dd[x] + counter[x]\n\n            if i == n_pos:\n                c += 1\n                n_pos = None\n\n        counter[x] += 1\n\n    print(c)\n\n__starting_point()", "\"\"\"\nCodeforces Round 332\n\nProblem 599 C.\n\n@author yamaton\n@date 2015-11-20\n\"\"\"\n\nimport itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\n\n\ndef solve(xs, n):\n    max_upto = []\n    maxval = 0\n    for x in xs:\n        maxval = max(maxval, x)\n        max_upto.append(maxval)\n\n    min_after = []\n    minval = 10000000000\n    for x in reversed(xs):\n        minval = min(minval, x)\n        min_after.append(minval)\n    min_after.reverse()\n\n    count = 1\n    for i in range(1, n):\n        if max_upto[i-1] <= min_after[i]:\n            count += 1\n\n    return count\n\n\n#\n# @functools.lru_cache(maxsize=None)\n# def count(tup):\n#     if len(tup) == 1:\n#         return 1\n#\n#     maxval = 1\n#     n = len(tup)\n#     for i in range(1, n):\n#         first = tup[:i]\n#         second = tup[i:]\n#         if max(first) <= min(second):\n#             maxval = max(maxval, count(first) + count(second))\n#     return maxval\n#\n#\n# def solve(xs, n):\n#     return count(tuple(xs))\n\n\n# def p(*args, **kwargs):\n#     return print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    n = int(input())\n    xs = [int(_c) for _c in input().strip().split()]\n\n    result = solve(xs, n)\n    print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "__author__ = 'MoonBall'\n\nimport sys\n# sys.stdin = open('data/C.in', 'r')\nT = 1\n\ndef process():\n    N = int(input())\n    h = list(map(int, input().split()))\n\n    hpx = []\n    last = {}\n    for i, v in enumerate(h): hpx.append([v, i])\n    hpx = sorted(hpx, key=lambda x:x[0])\n    maxp = -1\n    i = 0\n    while i < N:\n        item = hpx[i]\n        v = item[0]\n        j = i\n        while j < N and hpx[j][0] == v:\n            p = hpx[j][1]\n            last[p] = max(maxp, p)\n            j = j + 1\n\n        j = i\n        while j < N and hpx[j][0] == v:\n            p = hpx[j][1]\n            maxp = max(maxp, p)\n            j = j + 1\n        i = j\n\n    ans = 0\n    p = 0\n    while p < N:\n        ans = ans + 1\n        nextp = p + 1\n\n        while p < N and p < nextp:\n            nextp = max(nextp, last[p] + 1)\n            p = p + 1\n\n    print(ans)\n\n\n\n\nfor _ in range(T):\n    process()\n", "n = int(input())\nh = list(map(int, input().split()))\nmins = [1000000001 for i in range(n)]\nmaxs = [0 for i in range(n)]\nans = 0\nmins[n-1] = h[n-1]\n\nfor i in range(n-2, -1, -1):\n    mins[i] = min(h[i], mins[i+1])\nmaxs[0] = h[0]\nfor i in range(1, n):\n    maxs[i] = max(maxs[i-1],h[i])\n\nfor i in range(n-1):\n    if maxs[i] <= mins[i+1]:\n        ans += 1\nprint(ans+1)\n    \n    \n", "n = int(input())\nhs = list(map(int, input().split()))\nchs = list(set(hs))\nchs.sort()\nrchs = {}\nfor i, v in enumerate(chs):\n    rchs[v] = i\nfor i in range(n):\n    hs[i] = rchs[hs[i]]\nmax_h = -1\nrs = []\nmax_hs = [0] * n\nfor i, h in enumerate(hs):\n    max_h = max(max_h, h)\n    rs.append((h, i))\n    max_hs[i] = max_h\nrs.sort()\nh, r = 0, -1\np = 0\nans = 0\nwhile r < n - 1:\n    nh, nr = rs[p]\n    if r >= nr:\n        p += 1\n    else:\n        r = nr\n        p += 1\n        while r < n - 1:\n            nh, nr = rs[p]\n            if nh >= max_hs[r]:\n                break\n            r = max(r, nr)\n            p += 1\n        ans += 1\nprint(ans)\n", "mod = 10**9+7\nx = int(input())\ny = list(map(int, input().split(' ')))\nz = y[:]\nz.sort()\n\nprod = 1\nsumx = 0\n\nprod2 = 1\nsumx2 = 0\n\nb = 0\n\nfor i in range(x):\n    prod *= y[i]\n    sumx += y[i]\n    prod2 *= z[i]\n    sumx2 += z[i]\n    prod %= mod\n    prod2 %= mod\n    if (prod == prod2 and sumx == sumx2):\n        b+=1\n        prod=1\n        prod2=1\n        sumx=0\n        sumx2=0\n\nprint(b)\n", "from collections import Counter as Cnt\nn = int(input())\ndata = tuple(map(int,input().split()))\ndatasorted = sorted(data)\n\ni = 0\na = Cnt()\nb = Cnt()\nans = 0\nfor i in range(n):\n    a[data[i]]+=1\n    b[datasorted[i]]+=1\n    if a==b:\n        ans+=1\n        a,b=Cnt(),Cnt()\nprint(ans)", "x = int(input())\ny = list(map(int, input().split(' ')))\nz = y[:]\nz.sort()\n\nsumx = 0\nsumx2 = 0\n\nb = 0\n\nfor i in range(x):\n    sumx += y[i]\n    sumx2 += z[i]\n    if (sumx == sumx2):\n        b+=1\n\n\nprint(b)", "x = int(input())\ny = list(map(int, input().split(' ')))\nz = y[:]\nz.sort()\nsumx = 0\nb = 0\n\nfor i in range(x):\n    sumx += y[i] - z[i]\n    if (sumx == 0):\n        b+=1\n\nprint(b)", "n = int(input())\nhs = list(map(int, input().split()))\nmax_h = 0\nrs = []\nmax_hs = [0] * n\nfor i, h in enumerate(hs):\n    rs.append((h, i))\n    max_h = max(max_h, h)\n    max_hs[i] = max_h\nrs.sort()\np, r = 0, -1\nans = 0\nwhile r < n - 1:\n    nh, nr = rs[p]\n    if r >= nr:\n        p += 1\n    else:\n        r = nr\n        p += 1\n        while r < n - 1:\n            nh, nr = rs[p]\n            if nh >= max_hs[r]:\n                break\n            r = max(r, nr)\n            p += 1\n        ans += 1\nprint(ans)\n", "\"\"\"\nCodeforces Round #332\n\nProblem 599 C. Day at the Beach\n\n@author yamaton\n@date 2015-11-20\n\"\"\"\n\nimport itertools as it\nimport functools\nimport operator\nimport collections\nimport math\nimport sys\n\n\ndef solve(xs, n):\n    max_upto = list(it.accumulate(xs, max))\n    min_after = list(it.accumulate(reversed(xs), min))\n    min_after.reverse()\n    count = 1 + sum(1 for i in range(1, n) if max_upto[i-1] <= min_after[i])\n    return count\n\n\ndef solve_old(xs, n):\n    max_upto = []\n    maxval = 0\n    for x in xs:\n        maxval = max(maxval, x)\n        max_upto.append(maxval)\n\n    min_after = []\n    minval = 10000000000\n    for x in reversed(xs):\n        minval = min(minval, x)\n        min_after.append(minval)\n    min_after.reverse()\n\n    count = 1\n    for i in range(1, n):\n        if max_upto[i-1] <= min_after[i]:\n            count += 1\n\n    return count\n\n\n#\n# @functools.lru_cache(maxsize=None)\n# def count(tup):\n#     if len(tup) == 1:\n#         return 1\n#\n#     maxval = 1\n#     n = len(tup)\n#     for i in range(1, n):\n#         first = tup[:i]\n#         second = tup[i:]\n#         if max(first) <= min(second):\n#             maxval = max(maxval, count(first) + count(second))\n#     return maxval\n#\n#\n# def solve(xs, n):\n#     return count(tuple(xs))\n\n\n# def p(*args, **kwargs):\n#     return print(*args, file=sys.stderr, **kwargs)\n\n\ndef main():\n    n = int(input())\n    xs = [int(_c) for _c in input().strip().split()]\n\n    result = solve(xs, n)\n    print(result)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n, s, v = int(input()), 0, 0\na = list(map(int, input().split()))\nfor ai, bi in zip(a, sorted(a)):\n    s += bi - ai\n    v += not s\nprint(v)", "#!/usr/bin/env python3\n# 599C_beach.py - Codeforces.com/problemset/problem/599/C by Sergey 2015\n\nimport unittest\nimport sys\n\n###############################################################################\n# Beach Class (Main Program)\n###############################################################################\n\n\nclass Beach:\n    \"\"\" Beach representation \"\"\"\n\n    def __init__(self, test_inputs=None):\n        \"\"\" Default constructor \"\"\"\n\n        it = iter(test_inputs.split(\"\\n\")) if test_inputs else None\n\n        def uinput():\n            return next(it) if it else sys.stdin.readline().rstrip()\n\n        # Reading single elements\n        [self.n] = list(map(int, uinput().split()))\n\n        # Reading a single line of multiple elements\n        self.nums = list(map(int, uinput().split()))\n\n    def calculate(self):\n        \"\"\" Main calcualtion function of the class \"\"\"\n\n        result, u = 0, 0\n\n        tp = sorted([(n, i) for i, n in enumerate(self.nums)])\n\n        for i in range(self.n):\n            u = max(u, tp[i][1])\n            if i >= u:\n                result += 1\n\n        return str(result)\n\n###############################################################################\n# Unit Tests\n###############################################################################\n\n\nclass unitTests(unittest.TestCase):\n\n    def test_single_test(self):\n        \"\"\" Beach class testing \"\"\"\n\n        # Constructor test\n        test = \"3\\n1 2 3\"\n        d = Beach(test)\n        self.assertEqual(d.n, 3)\n        self.assertEqual(d.nums, [1, 2, 3])\n\n        # Sample test\n        self.assertEqual(Beach(test).calculate(), \"3\")\n\n        # Sample test\n        test = \"4\\n2 1 3 2\"\n        self.assertEqual(Beach(test).calculate(), \"2\")\n\n        # My tests\n        test = \"\"\n        # self.assertEqual(Beach(test).calculate(), \"0\")\n\n        # Time limit test\n        # self.time_limit_test(5000)\n\n    def time_limit_test(self, nmax):\n        \"\"\" Timelimit testing \"\"\"\n        import random\n        import timeit\n\n        # Random inputs\n        test = str(nmax) + \" \" + str(nmax) + \"\\n\"\n        numnums = [str(i) + \" \" + str(i+1) for i in range(nmax)]\n        test += \"\\n\".join(numnums) + \"\\n\"\n        nums = [random.randint(1, 10000) for i in range(nmax)]\n        test += \" \".join(map(str, nums)) + \"\\n\"\n\n        # Run the test\n        start = timeit.default_timer()\n        d = Beach(test)\n        calc = timeit.default_timer()\n        d.calculate()\n        stop = timeit.default_timer()\n        print((\"\\nTimelimit Test: \" +\n              \"{0:.3f}s (init {1:.3f}s calc {2:.3f}s)\".\n              format(stop-start, calc-start, stop-calc)))\n\ndef __starting_point():\n\n    # Avoiding recursion limitaions\n    sys.setrecursionlimit(100000)\n\n    if sys.argv[-1] == \"-ut\":\n        unittest.main(argv=[\" \"])\n\n    # Print the result string\n    sys.stdout.write(Beach().calculate())\n\n__starting_point()", "n, s, v = int(input()), 0, 0\na = list(map(int, input().split()))\nfor ai, bi in zip(a, sorted(a)):\n    s += bi - ai\n    v += not s\nprint(v)", "def binsearch(a, x, k):\n    l = 0\n    r = k\n    while l < r - 1:\n        m = (l + r) // 2\n        if a[m] <= x:\n            l = m\n        else:\n            r = m\n    return l\nn = int(input())\nk = -1\na = [0] * n\nfor i in input().split():\n    x = int(i)\n    if k == -1:\n        k += 1\n        a[k] = x\n    else:\n        if x >= a[k]:\n            k += 1\n            a[k] = x\n        else:\n            k1 = k\n            k = binsearch(a, x, k + 1)\n            if a[k] <= x:\n                k += 1\n            a[k] = a[k1]\nprint(k + 1)", "__author__ = 'sandeepmellacheruvu'\nn = int(input())\narr = list(map(int, input().split()))\nsum = 0\nblocks = 0\nfor ai, bi in zip(arr, sorted(arr)):\n    sum += ai - bi\n    if sum == 0:\n        blocks += 1\nprint(blocks)", "# import sys\n# sys.stdin = open('cf599c.in')\n\nn = int(input())\nhh = list(map(int, input().split()))\nidx = sorted(range(n), key=lambda i: hh[i])\n\nnum_blocks = 0\ncurr_max = idx[0]\nfor j, i in enumerate(idx):\n\tcurr_max = max(i, curr_max)\n\tif curr_max <= j:\n\t\tnum_blocks += 1\n\nprint(num_blocks)", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom collections import Counter\n\nn = int(input())\nH = list(map(int,input().split()))\n_H = sorted(H)\n\ndiff = Counter()\ncount = 0\n\nfor i in range(n):\n    diff[H[i]] += 1\n    diff[_H[i]] -= 1\n\n    if _H[i] in diff and diff[_H[i]] == 0:\n        diff.pop(_H[i])\n    if H[i] in diff and diff[H[i]] == 0:\n        diff.pop(H[i])\n    if diff == Counter():\n        count += 1\n\nprint(count)\n", "n = int(input())\nhs = tuple(int(x) for x in input().split())\n\ndef blocks(seq):\n    res = 0\n    i = 0 \n    maxh = 0\n    while True:\n        if i == len(seq):\n            return res\n        maxh = max(maxh, seq[i])\n        if maxh == i:\n            res += 1\n            i += 1 \n        elif maxh > i:\n            i += 1\n            \ndef solve(n, hs):\n    hhs = sorted((hs[i], i) for i in range(n))\n    hhhs = sorted((i, hhs[i][0], hhs[i][1]) for i in range(n))\n    return blocks(list(h[2] for h in hhhs)) \n    \nprint(solve(n, hs))\n"]