["#      \nimport collections, atexit, math, sys, bisect \n\nsys.setrecursionlimit(1000000)\ndef getIntList():\n    return list(map(int, input().split()))    \n\ntry :\n    #raise ModuleNotFoundError\n    import numpy\n    def dprint(*args, **kwargs):\n        print(*args, **kwargs, file=sys.stderr)\n    dprint('debug mode')\nexcept Exception:\n    def dprint(*args, **kwargs):\n        pass\n\n\n\ninId = 0\noutId = 0\nif inId>0:\n    dprint('use input', inId)\n    sys.stdin = open('input'+ str(inId) + '.txt', 'r') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\nif outId>0:\n    dprint('use output', outId)\n    sys.stdout = open('stdout'+ str(outId) + '.txt', 'w') #\u6807\u51c6\u8f93\u51fa\u91cd\u5b9a\u5411\u81f3\u6587\u4ef6\n    atexit.register(lambda :sys.stdout.close())     #idle \u4e2d\u4e0d\u4f1a\u6267\u884c atexit\n    \nN, = getIntList()\n#print(N)\nS = input()\n\nX, Y = getIntList()\n\ndd = ( (0,1), (0,-1), (-1,0), (1,0))\npp = 'UDLR'\nzz = {}\nfor i in range(4):\n    zz[ pp[i]] = dd[i]\n\n\nif abs(X) + abs(Y) >N:\n    print(-1)\n    return\n\nif abs(X+Y-N)%2==1:\n    print(-1)\n    return\n    \nfromLeft = [None for i in range(N)]\nfromRight = fromLeft.copy()\n\nx0 = 0\ny0 = 0\nfor i in range(N):\n    x = S[i]\n    fromLeft[i] = (x0,y0)\n    g = zz[x]\n    x0+= g[0]\n    y0+= g[1]\n\nif x0==X and y0==Y:\n    print(0)\n    return\n\nx0 = 0\ny0 = 0\nfor i in range(N-1,-1,-1):\n    x = S[i]\n    fromRight[i] = (x0,y0)\n    g = zz[x]\n    x0+= g[0]\n    y0+= g[1]\n\n\nup = N\ndown = 0\ndprint(fromLeft)\ndprint(fromRight)\nwhile down+1<up:\n    mid = (up+down)//2\n    dprint('mid', mid)\n    ok = False\n    for i in range(N-mid + 1):\n        tx = fromLeft[i][0] + fromRight[i+mid-1][0]\n        ty = fromLeft[i][1] + fromRight[i+mid-1][1]\n        gg = abs(X-tx) + abs(Y- ty)\n        if gg <= mid:\n            ok = True\n            break\n    if ok:\n        up = mid\n    else:\n        down = mid\n        \nprint(up)\n\n", "def doable(n,x,y,m, prefixLR, prefixUD):\n\tfor i in range(n-m+1):\n\t\tj = i + m - 1\n\t\tdx = prefixLR[i] + prefixLR[-1] - prefixLR[j+1]\n\t\tdy = prefixUD[i] + prefixUD[-1] - prefixUD[j+1]\n\t\tif abs(x - dx) + abs(y - dy) <= m:\n\t\t\treturn True\n\treturn False\n\ndef main():\n\tn = int(input())\n\ts = list(input().strip())\n\tx,y = map(int, input().strip().split())\n\n\tk = abs(x) + abs(y)\n\tif k > n or k % 2 != n % 2:\n\t\tprint(-1)\n\t\treturn\n\n\tprefixLR = [0] * (n + 1)\n\tprefixUD = [0] * (n + 1)\n\n\tfor i in range(n):\n\t\tprefixLR[i+1] = prefixLR[i]\n\t\tprefixUD[i+1] = prefixUD[i]\n\t\tif s[i] == 'L':\n\t\t\tprefixLR[i+1] -= 1\n\t\telif s[i] == 'R':\n\t\t\tprefixLR[i+1] += 1\n\t\telif s[i] == 'D':\n\t\t\tprefixUD[i+1] -= 1\n\t\telse:\n\t\t\tprefixUD[i+1] += 1\n\n\tleft = 0\n\tright = n\n\n\twhile left < right:\n\t\tmid = left + (right - left) // 2\n\t\tif doable(n,x,y,mid, prefixLR, prefixUD):\n\t\t\tright = mid\n\t\telse:\n\t\t\tleft = mid + 1\n\n\tprint(left)\n\t\ndef __starting_point():\n\tmain()\n__starting_point()", "n = int(input())\ns = input()\np,q = input().split()\nif p[0] == '-':\n    x = -1*int(p[1:])\nelse:\n    x = int(p)\nif q[0] == '-':\n    y = -1*int(q[1:])\nelse:\n    y = int(q)\ncur = [0,0]\nif(abs(x)+abs(y) > n):\n    print(-1)\nelif((x+y)%2 != n%2):\n    print(-1)\nelse:\n    end = n\n    for i in range(n):\n        if s[i] == \"R\":\n            cur[0] += 1\n        if s[i] == \"L\":\n            cur[0] -= 1\n        if s[i] == \"U\":\n            cur[1] += 1\n        if s[i] == \"D\":\n            cur[1] -= 1\n        if(abs(x-cur[0])+abs(y-cur[1]) >= n-i):\n            end = i\n            break\n    if end == n:\n        print(0)\n    else:\n        m = [0]*(end+1)\n        start = n\n        for i in range(end,-1,-1):\n            if s[i] == \"R\":\n                cur[0] -= 1\n            if s[i] == \"L\":\n                cur[0] += 1\n            if s[i] == \"U\":\n                cur[1] -= 1\n            if s[i] == \"D\":\n                cur[1] += 1\n            while(abs(x-cur[0])+abs(y-cur[1]) <= start-i):\n                start -= 1\n                if s[start] == \"R\":\n                    x -= 1\n                if s[start] == \"L\":\n                    x += 1\n                if s[start] == \"U\":\n                    y -= 1\n                if s[start] == \"D\":\n                    y += 1\n            m[i] = start-i+1\n        minn = n\n        for i in m:\n            minn = min(minn,i)\n        print(minn)\n", "\ndef valid(step, tx, ty, nx, ny, s, d):\n    fx = 0\n    fy = 0\n    for i in range(len(s)):\n        # insert\n        c = s[i]\n        fx += d[c][0]\n        fy += d[c][1]\n        if i >= step:\n            # remove\n            c = s[i-step]\n            fx -= d[c][0]\n            fy -= d[c][1]\n        if i >= step-1:\n            diff = abs(nx-fx-tx) + abs(ny-fy-ty)\n            if diff <= step and (step - diff) % 2 == 0:\n                return True\n    return False\n\n\ndef main():\n    d = {\n        \"U\": (0, 1),\n        \"D\": (0, -1),\n        \"L\": (-1, 0),\n        \"R\": (1, 0)\n    }\n    nx = 0\n    ny = 0\n\n    n = int(input())\n    s = input()\n    tx, ty = [int(x) for x in input().split(\" \")]\n\n    diff = abs(tx) + abs(ty)\n    if diff > len(s) or (diff-len(s)) % 2 == 1:\n        print(-1)\n        return\n\n    for c in s:\n        nx += d[c][0]\n        ny += d[c][1]\n    if (nx, ny) == (tx, ty):\n        print(0)\n        return\n    l = 0\n    r = len(s)\n    ans = r\n\n    while l < r:\n        m = (l+r)//2\n        if valid(m, tx, ty, nx, ny, s, d):\n            ans = m\n            r = m\n        else:\n            l = m+1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\ns=list(input())\na,b = list(map(int, input().split()))\nL=s.count('L')\nU=s.count('U')\nR=s.count('R')\nD=s.count('D')\nx=0\ny=0\nxmin=0\nymin=0\nminn=2*n\nwhile x+y<2*n:\n    if abs(a-(R-L))+abs(b-(U-D))>y-x and y!=n:\n        i=s[y]\n        if i=='L':\n            L-=1\n        elif i=='R':\n            R-=1\n        elif i=='D':\n            D-=1\n        elif i=='U':\n            U-=1 \n        y+=1\n    elif abs(a-(R-L))+abs(b-(U-D))<=y-x or y==n:\n        if y-x<minn and abs(a-(R-L))+abs(b-(U-D))<=y-x:\n            minn=y-x\n        i=s[x]\n        if i=='L':\n            L+=1\n        elif i=='R':\n            R+=1\n        elif i=='D':\n            D+=1\n        elif i=='U':\n            U+=1\n        x+=1\n\n            \nif abs(a)+abs(b)>len(s):\n    print(-1)\nelif (len(s)-(abs(a)+abs(b)))%2!=0:\n    print(-1)\nelse:\n    print(minn)\n", "import sys\n\nn=int(input())\nS=input()\nx,y=list(map(int,input().split()))\n\nif abs(x)+abs(y)>n or (abs(x)+abs(y))%2!=n%2:\n    print(-1)\n    return\n\nnow=[0,0]\nLISTL=[(0,0)]\nfor s in S:\n    if s==\"R\":\n        now[0]+=1\n    elif s==\"L\":\n        now[0]-=1\n    elif s==\"U\":\n        now[1]+=1\n    else:\n        now[1]-=1\n\n    LISTL.append((now[0],now[1]))\n\nLISTR=[(0,0)]\nnow=[0,0]\nfor s in S[::-1]:\n    if s==\"R\":\n        now[0]+=1\n    elif s==\"L\":\n        now[0]-=1\n    elif s==\"U\":\n        now[1]+=1\n    else:\n        now[1]-=1\n\n    LISTR.append((now[0],now[1]))\n\ndef su(a,b,x,y):\n    return abs(x-(a[0]+b[0]))+abs(y-(a[1]+b[1]))\n\nANS=0\nfor i in range(n+1):\n    for j in range(max(0,ANS-i),n+1):\n        if su(LISTR[i],LISTL[j],x,y)<=n-i-j:\n            #print(i,j)\n            if ANS<i+j:\n                ANS=i+j\n\n        else:\n            break\n\nprint(n-ANS)\n    \n", "n = int(input())\ndx = [0 for i in range(n + 1)]\ndy = [0 for i in range(n + 1)]\nfor i, ch in enumerate(input()):\n    dx[i + 1] = dx[i]\n    dy[i + 1] = dy[i]\n    if ch == 'U':\n        dy[i + 1] += 1\n    elif ch == 'D':\n        dy[i + 1] -= 1\n    elif ch == 'R':\n        dx[i + 1] += 1\n    else:\n        assert ch == 'L'\n        dx[i + 1] -= 1\nx, y = list(map(int, input().split()))\ndef canChange(left, right):\n    dx1 = dx[left]\n    dy1 = dy[left]\n    dx3 = dx[-1] - dx[right]\n    dy3 = dy[-1] - dy[right]\n    dx2 = x - dx1 - dx3\n    dy2 = y - dy1 - dy3\n    length = right - left\n    free = length - (abs(dx2) + abs(dy2))\n    return free >= 0 and free % 2 == 0\nresult = n + 1\nptr = n + 1\nfor i in reversed(list(range(n))):\n    while ptr - 1 >= i and canChange(i, ptr - 1):\n        ptr -= 1\n        result = min(result, ptr - i)\nif ptr == n + 1:\n    print(-1)\nelse:\n    print(result)\n", "n=int(input())\n#a=list(map(int,input().split()))\n#b=list(map(int,input().split()))\n\ns=list(input())\nx,y=list(map(int,input().split()))\n\nit=[0,0,0,0]\n\nfor i in range(len(s)):\n    if s[i]=='U':\n        s[i]=0\n    elif s[i]=='R':\n        s[i]=1\n    elif s[i]=='D':\n        s[i]=2\n    else:\n        s[i]=3\n    it[s[i]]+=1\n\ndef distance(x,y,xx,yy):\n    return abs(x-xx)+abs(y-yy)\n\ndef yes(steps,ost,x,y):\n    xx=steps[1]-steps[3]\n    yy=steps[0]-steps[2]\n    return distance(x,y,xx,yy)<=ost\n\n\n\nans=0\n\n\nif distance(x,y,0,0)>n or (x+y+n)%2==1:\n    print(-1)\nelif yes(it,0,x,y):\n    print(0)\nelse:\n    i=-1\n    cur_ans=0\n    max_ans=0\n\n    steps=[0,0,0,0]\n    \n    while yes(steps,n-cur_ans,x,y):\n        i+=1\n        steps[s[i]]+=1\n        cur_ans+=1\n\n    steps[s[i]]-=1\n    i-=1\n    cur_ans-=1\n    max_ans=cur_ans\n\n    j=n\n    ok=True\n\n    while j>0 and ok:\n        j=j-1\n        steps[s[j]]+=1\n        cur_ans+=1\n        \n        while i>=0 and not yes(steps,n-cur_ans,x,y):\n            steps[s[i]]-=1\n            i-=1\n            cur_ans-=1\n        \n        if yes(steps,n-cur_ans,x,y) and cur_ans>max_ans:\n            max_ans=cur_ans\n        ok=(i>=0) or yes(steps,n-cur_ans,x,y)\n\n    print(n-max_ans)\n\n\n", "import sys\nfin = sys.stdin.readline\n\nn = int(fin())\ncommands = list(fin())[:-1]\nx, y = [int(elem) for elem in fin().split(' ')]\n\nmove_map = {'L': (-1, 0), 'R': (1, 0), 'U': (0, 1), 'D': (0, -1)}\n\nif (x + y) % 2 != n % 2:\n    print(-1)\n    return\n\ncuml_coord = [None] * n\ncuml_x, cuml_y = 0, 0\nfor i, command in enumerate(commands):\n    dx, dy = move_map[command]\n    cuml_x += dx\n    cuml_y += dy\n    cuml_coord[i] = (cuml_x, cuml_y)\n\nleft, right = 0, 0\nmin_len = 2**32 - 1\norg_x, org_y = cuml_coord[-1]\nif org_x == x and org_y == y:\n    min_len = 0\n\nwhile right <= n - 1:\n    if left == 0:\n        left_cuml = 0, 0\n    else:\n        left_cuml = cuml_coord[left - 1]\n    right_cuml = cuml_coord[right]\n    movable_x, movable_y = right_cuml[0] - left_cuml[0], \\\n                           right_cuml[1] - left_cuml[1]\n    fixed_x, fixed_y = org_x - movable_x, org_y - movable_y\n    sub_length = right - left + 1\n    # print(fixed_x, fixed_y, left, right)\n    # print(x - fixed_x, y - fixed_y)\n    if (abs(x - fixed_x) + abs(y - fixed_y)) <= sub_length \\\n    and (abs(x - fixed_x) + abs(y - fixed_y)) % 2 == sub_length % 2:\n        min_len = min(min_len, sub_length)\n        if left != right:\n            left += 1\n        else:\n            right += 1\n    else:\n        right += 1\nif min_len == 2**32 - 1:\n    print(-1)\nelse:\n    print(min_len)\n", "import sys\nfin = sys.stdin.readline\n\nn = int(fin())\ncommands = list(fin())[:-1]\nx, y = [int(elem) for elem in fin().split(' ')]\n\nmove_map = {'L': (-1, 0), 'R': (1, 0), 'U': (0, 1), 'D': (0, -1)}\n\nif (x + y) % 2 != n % 2:\n    print(-1)\n    return\n\ncuml_coord = [None] * n\ncuml_x, cuml_y = 0, 0\nfor i, command in enumerate(commands):\n    dx, dy = move_map[command]\n    cuml_x += dx\n    cuml_y += dy\n    cuml_coord[i] = (cuml_x, cuml_y)\n\nleft, right = 0, 0\nmin_len = 2**32 - 1\norg_x, org_y = cuml_coord[-1]\nif org_x == x and org_y == y:\n    min_len = 0\n\nwhile right <= n - 1:\n    if left == 0:\n        left_cuml = 0, 0\n    else:\n        left_cuml = cuml_coord[left - 1]\n    right_cuml = cuml_coord[right]\n    movable_x, movable_y = right_cuml[0] - left_cuml[0], \\\n                           right_cuml[1] - left_cuml[1]\n    fixed_x, fixed_y = org_x - movable_x, org_y - movable_y\n    sub_length = right - left + 1\n    # print(fixed_x, fixed_y, left, right)\n    # print(x - fixed_x, y - fixed_y)\n    if (abs(x - fixed_x) + abs(y - fixed_y)) <= sub_length \\\n    and (abs(x - fixed_x) + abs(y - fixed_y)) % 2 == sub_length % 2:\n        min_len = min(min_len, sub_length)\n        if left != right:\n            left += 1\n        else:\n            right += 1\n    else:\n        right += 1\nif min_len == 2**32 - 1:\n    print(-1)\nelse:\n    print(min_len)\n", "import math as ma\nimport sys\nfrom decimal import Decimal as dec\nfrom itertools import permutations\n\n\ndef li():\n\treturn list(map(int , sys.stdin.readline().split()))\n\n\ndef num():\n\treturn map(int , sys.stdin.readline().split())\n\n\ndef nu():\n\treturn int(sys.stdin.readline())\n\n\ndef find_gcd(x , y):\n\twhile (y):\n\t\tx , y = y , x % y\n\treturn x\n\nn=nu()\ns=input()\nx,y=num()\nuu=[0]*n\nrr=[0]*n\npu=[]\npr=[]\nfor i in range(n):\n\tif(s[i]==\"U\"):\n\t\tuu[i]=1\n\tif(s[i]==\"D\"):\n\t\tuu[i] = -1\n\tif(s[i]==\"R\"):\n\t\trr[i]=1\n\tif(s[i]==\"L\"):\n\t\trr[i]=-1\n\npu.append(uu[0])\npr.append(rr[0])\nfor i in range(1,n):\n\tpu.append(pu[i-1]+uu[i])\nfor i in range(1,n):\n\tpr.append(pr[i-1]+rr[i])\npu=[0]+pu\npr=[0]+pr\nzu=pu[len(pu)-1]\nzr=pr[len(pr)-1]\nif((abs(x-zr)+abs(y-zu))==0):\n\tprint(0)\n\treturn\nif((abs(x)+abs(y))%2!=n%2 or (abs(x)+abs(y))>n):\n\tprint(-1)\n\treturn\n\nlo=1\nhi=n\nwhile(lo<=hi):\n\tmid=(lo+hi)//2\n\tfl=False\n\tfor i in range(0,n-mid+1):\n\t\tlu=zu-pu[i+mid]+pu[i]\n\t\tlr=zr-pr[i+mid]+pr[i]\n\t\tif((abs(x-lr)+abs(y-lu))<=mid):\n\t\t\tfl=True\n\t\t\tbreak\n\tif(fl==True):\n\t\thi=mid-1\n\telse:\n\t\tlo=mid+1\nprint(lo)", "n = int(input().strip())\ns = str(input().strip())\nx,y = list(map(int,input().strip().split()))\nsumx = []\nsumy = []\n\nsx = 0\nsy = 0\nsumx.append(sx)\nsumy.append(sy)\nfor i in s:\n    if(i=='U'):\n        sy+=1\n    elif(i=='D'):\n        sy-=1\n    elif(i=='R'):\n        sx+=1\n    elif(i=='L'):\n        sx-=1\n    sumx.append(sx)\n    sumy.append(sy)\n\n#print(\"sxy\",sx, sy)\n\ndef check(mid):\n    i=0\n    while(i+mid<=n):\n        dx = sumx[i+mid]-sumx[i]\n        dy = sumy[i+mid]-sumy[i]\n        cx = sx-dx\n        cy = sy-dy\n        #print(\"cxy\",cx,cy)\n        gdx = x-cx\n        gdy = y-cy\n        t=abs(gdx)+abs(gdy)\n        #print(\"t\",t)\n        if(t%2==mid%2 and t<=mid):\n            return True\n        i+=1\n    return False\n\nhi = n\nlo = 0\nmid=(hi+lo)//2\nwhile(hi-lo>1):\n    mid=(hi+lo)//2\n    #print(\"mid\", mid)\n    if(check(mid)):\n        hi=mid\n    else:\n        lo=mid\n#print(lo)\nif(check(lo)):\n    print(lo)\nelif(check(mid)):\n    print(mid)\nelif(check(hi)):\n    print(hi)\nelse:\n    print(-1)", "def check(x, y, fx, fy, num_moves):\n\tif ((abs(fx - x) +  abs(fy - y))-num_moves) <= 0 and ((abs(fx - x) +  abs(fy - y))-num_moves)%2  == 0:\n\t\treturn True\n\treturn False \n\nN = int(input())\nmm =  {'U':0,'D':1,'L':2,'R':3}\n\ndpmat = [[0] for i in range(4)]\n\nops =  str(input())\n\nfor op in ops:\n\tdpmat[0].append(dpmat[0][-1])\n\tdpmat[1].append(dpmat[1][-1])\n\tdpmat[2].append(dpmat[2][-1])\n\tdpmat[3].append(dpmat[3][-1])\n\t\n\tdpmat[mm[op]][-1] = dpmat[mm[op]][-1]+1\n\n\nfpos = list(map(int,input().split())) \nif N < fpos[0]+fpos[1]:\n\tprint(\"-1\")\nelse :\n\tx,y = 0,0\n\n\tans = 10e10\n\n\twhile y <= N and x <= y:\n\t\tif y == 0 and x == 0:\t\n\t\t\tnum_moves = 0\n\t\t\txr = dpmat[3][N]\n\t\t\txl = dpmat[2][N]\n\t\t\tyu = dpmat[0][N]\n\t\t\tyd = dpmat[1][N]\n\t\telse:\n\t\t\tnum_moves = y-x+1\n\t\t\txr = dpmat[3][x-1] +  dpmat[3][N] - dpmat[3][y]\t\n\t\t\txl = dpmat[2][x-1] +  dpmat[2][N] - dpmat[2][y]\t\n\t\t\tyu = dpmat[0][x-1] +  dpmat[0][N] - dpmat[0][y]\t\n\t\t\tyd = dpmat[1][x-1] +  dpmat[1][N] - dpmat[1][y]\t\n\t\t\n\t\tif check(xr-xl, yu-yd, fpos[0], fpos[1], num_moves) == True:\n\t\t\tx += 1\n\t\t\tans = min(ans, num_moves)\n\t\telse:\n\t\t\tif x==0:\n\t\t\t\tx += 1\t\n\t\t\ty += 1\n\tif ans == 10e10:\n\t\tprint(\"-1\")\n\telse:\n\t\tprint(max(0,ans))\n", "3\nfrom collections import Counter\n\ndef readint():\n    return int(input())\n\n\ndef readline():\n    return [int(c) for c in input().split()]\n\n\ndef update(pos, mv, d):\n    if mv == 'U':\n        pos[1] += d\n    elif mv == 'D':\n        pos[1] -= d\n    elif mv == 'L':\n        pos[0] -= d\n    elif mv == 'R':\n        pos[0] += d\n\n\ndef can(u, v, length):\n    d = abs(u[0] - v[0]) + abs(u[1] - v[1])\n    if d % 2 != length % 2:\n        return False\n    return length >= d\n\n\ndef ok(length, n, x, y, s):\n    pos = [0, 0]\n    for i in range(length, n):\n        update(pos, s[i], 1)\n\n    l, r = 0, length\n    while True:\n        if can(pos, [x, y], length):\n            return True\n        if r == n:\n            break\n        update(pos, s[l], 1)\n        l += 1\n        update(pos, s[r], -1)\n        r += 1\n\n    return False\n\n\ndef main():\n    n = readint()\n    s = input()\n    x, y = readline()\n\n    if not ok(n, n, x, y, s):\n        print(-1)\n        return\n\n    l, r = -1, n\n    while r - l > 1:\n        mid = (l + r) // 2\n        if ok(mid, n, x, y, s):\n            r = mid\n        else:\n            l = mid\n            \n    print(r)\n\n    \n\n\ndef __starting_point():\n    main()\n\n\n\"\"\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(1e5) + 9;\n\nstring s;\nint n;\nint x, y;\n\nvoid upd(pair<int, int> &pos, char mv, int d){\n\tif(mv == 'U')\n\t\tpos.second += d;\n\tif(mv == 'D')\n\t\tpos.second -= d;\n\tif(mv == 'L')\n\t\tpos.first -= d;\n\tif(mv == 'R')\n\t\tpos.first += d;\n}\n\nbool can(pair<int, int> u, pair<int, int> v, int len){\n\tint d = abs(u.first - v.first) + abs(u.second - v.second);\n\tif(d % 2 != len % 2) return false;\n\treturn len >= d;\n}\n\nbool ok(int len){\n\tpair<int, int> pos = make_pair(0, 0);\n\tfor(int i = len; i < n; ++i)\n\t\tupd(pos, s[i], 1);\n\n\tint l = 0, r = len;\n\twhile(true){\n\t\tif(can(pos, make_pair(x, y), len))\n\t\t\treturn true;\n\t\t\n\t\tif(r == n) break;\n\t\tupd(pos, s[l++], 1);\n\t\tupd(pos, s[r++], -1);\t\t\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t\n\tcin >> n;\n\tcin >> s;\n\tcin >> x >> y;\n\t\n\tif(!ok(n)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint l = -1, r = n;\n\twhile(r - l > 1){\n\t\tint mid = (l + r) / 2;\n\t\tif(ok(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\t\n\tcout << r << endl;\n    return 0;\n}\n\"\"\"\n\n__starting_point()", "d = {\n\t'U': (0, 1),\n\t'D': (0, -1),\n\t'L': (-1, 0),\n\t'R': (1, 0)\n}\n\n\ndef compute_delta(s, head_idx, tail_idx):\n\tx = y = 0\n\tfor i in range(head_idx, tail_idx):\n\t\tx, y = x + d[s[i]][0], y + d[s[i]][1]\n\treturn x, y\n\n\ndef compute_rest(s, n, head_idx, tail_idx):\n\tx = y = 0\n\tfor i in range(0, head_idx):\n\t\tx, y = x + d[s[i]][0], y + d[s[i]][1]\n\tfor i in range(tail_idx, n):\n\t\tx, y = x + d[s[i]][0], y + d[s[i]][1]\n\treturn x, y\n\n\nn = int(input())\ns = input()\nx_d, y_d = list(map(int, input().split()))\n# n = 5\n# s = 'RURUU'\n# x_d, y_d = -2, 3\nx_t, y_t = compute_delta(s, 0, n)\n\n# if x_d == x_t and y_d == y_t:\n#    print(0)\n\nl, r = 0, n\ncurrent_sol = -1\nwhile l <= r:\n\t# print(l, r)\n\tlocal_len = (r + l) // 2\n\n\tx_l, y_l = compute_rest(s, n, 0, local_len)\n\t# print('local_len: ', local_len)\n\tis_possible = False\n\tdiff = abs(x_d - x_l) + abs(y_d - y_l)\n\tif diff <= local_len and (diff + local_len) % 2 == 0:\n\t\tis_possible = True\n\t# print('\\t', x_l, y_l, abs(x_d - x_l), abs(y_d - y_l), local_len, is_possible)\n\tfor i in range(local_len, n):\n\t\tif is_possible:\n\t\t\tbreak\n\t\td_old, d_new = d[s[i]], d[s[i - local_len]]\n\t\tx_l, y_l = x_l - d_old[0] + d_new[0], y_l - d_old[1] + d_new[1]\n\t\t# print('\\t', x_l, y_l, abs(x_d - x_l), abs(y_d - y_l), local_len)\n\t\tdiff = abs(x_d - x_l) + abs(y_d - y_l)\n\t\tif diff <= local_len and (diff + local_len) % 2 == 0:\n\t\t\tis_possible = True\n\t# print(l, r, local_len, current_sol, is_possible)\n\tif is_possible:\n\t\tcurrent_sol = local_len\n\t\tr = local_len - 1\n\telse:\n\t\tl = local_len + 1\nprint(current_sol)", "d = {\n\t'U': (0, 1),\n\t'D': (0, -1),\n\t'L': (-1, 0),\n\t'R': (1, 0)\n}\n\n\ndef compute_delta(s, head_idx, tail_idx):\n\tx = y = 0\n\tfor i in range(head_idx, tail_idx):\n\t\tx, y = x + d[s[i]][0], y + d[s[i]][1]\n\treturn [x, y]\n\n\nn = int(input())\ns = input()\ndsc = list(map(int, input().split()))\ntotal = compute_delta(s, 0, n)\n\nl, r = 0, n\ncurrent_sol = -1\nwhile l <= r:\n\tlocal_len = (r + l) // 2\n\tinitial_diff = compute_delta(s, 0, local_len)\n\tlocal = [total[0] - initial_diff[0], total[1] - initial_diff[1]]\n\tis_possible = False\n\tdiff = abs(dsc[0] - local[0]) + abs(dsc[1] - local[1])\n\tif diff <= local_len and (diff + local_len) % 2 == 0:\n\t\tis_possible = True\n\tfor i in range(local_len, n):\n\t\tif is_possible:\n\t\t\tbreak\n\t\td_old, d_new = d[s[i]], d[s[i - local_len]]\n\t\tlocal = [local[0] - d_old[0] + d_new[0], local[1] - d_old[1] + d_new[1]]\n\t\tdiff = abs(dsc[0] - local[0]) + abs(dsc[1] - local[1])\n\t\tif diff <= local_len and (diff + local_len) % 2 == 0:\n\t\t\tis_possible = True\n\tif is_possible:\n\t\tcurrent_sol = local_len\n\t\tr = local_len - 1\n\telse:\n\t\tl = local_len + 1\nprint(current_sol)\n", "# -*- coding: utf-8 -*-\n\n\"\"\"\ncreated by shhuan at 2018/11/3 11:30\n\n\nsearch for minimum steps, consider binary search\n\n\"\"\"\n\nN = int(input())\nops = [x for x in input()]\n\nX, Y = list(map(int, input().split()))\n\ndd = abs(X) + abs(Y)\nlops = len(ops)\n# if dd > lops or (lops - dd) % 2 != 0:\n#     print(-1)\n#     return\n\n\n[ll, lr, lu, ld, rl, rr, ru, rd] = [[0 for _ in range(lops + 2)] for _ in range(8)]\n\nl, r, u, d = 0, 0, 0, 0\nfor i in range(lops):\n    op = ops[i]\n    if op == 'L':\n        l += 1\n    elif op == 'R':\n        r += 1\n    elif op == 'U':\n        u += 1\n    else:\n        d += 1\n    ll[i+1] = l\n    lr[i+1] = r\n    ld[i+1] = d\n    lu[i+1] = u\n\nl, r, u, d = 0, 0, 0, 0\nfor i in range(lops-1, -1, -1):\n    op = ops[i]\n    if op == 'L':\n        l += 1\n    elif op == 'R':\n        r += 1\n    elif op == 'U':\n        u += 1\n    else:\n        d += 1\n    rl[i] = l\n    rr[i] = r\n    rd[i] = d\n    ru[i] = u\n\ndef check(lsub):\n    for i in range(lops-lsub+1):\n        # j-i+1 == lsub, j < lops => i+lsub-1 <lops => i < lops-lsub+1\n        j = i + lsub - 1\n\n        # l, r, u, d of lops [0, i-1], ll[i]={'L' of 0,...,i-1}\n        l0, r0, u0, d0 = ll[i], lr[i], lu[i], ld[i]\n\n        # l, r, u, d of ops [j+1, N-1], rr[j]={'R' of lops-1,...,j}\n        l1, r1, u1, d1 = rl[j+1], rr[j+1], ru[j+1], rd[j+1]\n\n        x = (r0+r1) - (l0+l1)\n        y = (u0+u1) - (d0+d1)\n\n        dx = abs(X-x)\n        dy = abs(Y-y)\n\n        if dx + dy <= lsub and (lsub-dx-dy) % 2 == 0:\n            return True\n\n    return False\n\n\nsl, sr = 0, lops + 1\nwhile sl < sr:\n    m = (sl + sr) // 2\n    if check(m):\n        sr = m\n    else:\n        sl = m + 1\n\nsl = -1 if sl > lops else sl\nprint(sl)\n\n\n\n", "# -*- coding: utf-8 -*-\n\n\"\"\"\ncreated by shhuan at 2018/11/3 11:30\n\n\nsearch for minimum steps, consider binary search\n\n\"\"\"\n\nN = int(input())\nops = [x for x in input()]\n\nX, Y = list(map(int, input().split()))\n\ndd = abs(X) + abs(Y)\nlops = len(ops)\nif dd > lops or (lops - dd) % 2 != 0:\n    print(-1)\n    return\n\n\n[ll, lr, lu, ld, rl, rr, ru, rd] = [[0 for _ in range(lops + 2)] for _ in range(8)]\n\nl, r, u, d = 0, 0, 0, 0\nfor i in range(lops):\n    op = ops[i]\n    if op == 'L':\n        l += 1\n    elif op == 'R':\n        r += 1\n    elif op == 'U':\n        u += 1\n    else:\n        d += 1\n    ll[i+1] = l\n    lr[i+1] = r\n    ld[i+1] = d\n    lu[i+1] = u\n\nl, r, u, d = 0, 0, 0, 0\nfor i in range(lops-1, -1, -1):\n    op = ops[i]\n    if op == 'L':\n        l += 1\n    elif op == 'R':\n        r += 1\n    elif op == 'U':\n        u += 1\n    else:\n        d += 1\n    rl[i] = l\n    rr[i] = r\n    rd[i] = d\n    ru[i] = u\n\ndef check(lsub):\n    for i in range(lops-lsub+1):\n        # j-i+1 == lsub, j < lops => i+lsub-1 <lops => i < lops-lsub+1\n        j = i + lsub - 1\n\n        # l, r, u, d of lops [0, i-1], ll[i]={'L' of 0,...,i-1}\n        l0, r0, u0, d0 = ll[i], lr[i], lu[i], ld[i]\n\n        # l, r, u, d of ops [j+1, N-1], rr[j]={'R' of lops-1,...,j}\n        l1, r1, u1, d1 = rl[j+1], rr[j+1], ru[j+1], rd[j+1]\n\n        x = (r0+r1) - (l0+l1)\n        y = (u0+u1) - (d0+d1)\n\n        dx = abs(X-x)\n        dy = abs(Y-y)\n\n        if dx + dy <= lsub and (lsub-dx-dy) % 2 == 0:\n            return True\n\n    return False\n\n\nsl, sr = 0, lops + 1\nwhile sl < sr:\n    m = (sl + sr) // 2\n    if check(m):\n        sr = m\n    else:\n        sl = m + 1\n\nsl = -1 if sl > lops else sl\nprint(sl)\n\n\n\n", "n = int(input())\ndirs = input()\ngoal = list(map(int, input().split(' ')))\n\n\ndef can(start, end, steps):\n    dist = abs(start[0] - end[0]) + abs(start[1] - end[1])\n    return dist <= steps and (steps - dist) % 2 == 0\n\n\nif not can((0, 0), goal, n):\n    print(-1)\n    return\n\ndiffs = {\n    'U': (0, 1),\n    'D': (0, -1),\n    'L': (-1, 0),\n    'R': (1, 0),\n}\n\npos = [(0, 0)] + [None] * n\nfor i, dir in enumerate(dirs):\n    old_pos = pos[i]\n    diff = diffs[dir]\n    pos[i+1] = (old_pos[0] + diff[0], old_pos[1] + diff[1])\n\nfinal_pos = pos[n]\n\n# best (minimum) segment to override to get to the solution\nbest = (abs(final_pos[0] - goal[0]) + abs(final_pos[1] - goal[1])) // 2\n\nif best == 0:\n    print(0)\n    return\n\nstart = 0\nend = best\n\ncurrent_best = float('inf')\n\nwhile end <= n:\n    # exclude segment and check if can reach without\n    cur_pos = (\n        pos[start][0] + final_pos[0] - pos[end][0],\n        pos[start][1] + final_pos[1] - pos[end][1],\n    )\n\n    if can(cur_pos, goal, end - start):\n        current_best = min(current_best, end - start)\n        if current_best == best:\n            break\n        start += 1\n    else:\n        end += 1\n\nprint(current_best)\n\n\n# min_steps = abs(goal[0]) + abs(goal[1])\n# if min_steps > n or (min_steps - n) % 2 != 0:\n#     print(-1)\n#     return\n\n# cur_pos = [0, 0]\n# for dir in dirs:\n#     if dir == 'U':\n#         cur_pos[1] += 1\n#     if dir == 'D':\n#         cur_pos[1] -= 1\n#     if dir == 'L':\n#         cur_pos[0] -= 1\n#     if dir == 'R':\n#         cur_pos[0] += 1\n\n# pos_diff = [goal[0] - cur_pos[0], goal[1] - cur_pos[1]]\n\n# vertical = abs(pos_diff[1]) > abs(pos_diff[0])\n# up = pos_diff[1] > 0\n# right = pos_diff[0] > 0\n# replacement_steps = (abs(pos_diff[0]) + abs(pos_diff[1])) // 2\n# diagonal_walk = replacement_steps - \\\n#     abs(abs(pos_diff[1]) - abs(pos_diff[0])) // 2\n\n# start, end = 0, 0\n# covered = {'U': 0, 'D': 0, 'L': 0, 'R': 0}\n# while end < n:\n#     new_dir = dirs[end]\n#     covered[new_dir] += 1\n#     remaining = covered.copy()\n#     end += 1\n\n#     if vertical:\n#         if up:\n#             pass\n#         else:\n#             pass\n#     else:\n#         if right:\n#             pass\n#         else:\n#             pass\n", "#!/usr/bin/env python3\n\nimport itertools\n\ndef solve(L, n, px, py, x, y):\n    for i in range(n):\n        j = i + L\n        if j > n:\n            break\n        dx = px[i] + px[-1] - px[j] - x\n        dy = py[i] + py[-1] - py[j] - y\n        if abs(dx) + abs(dy) <= L:\n            return True\n    return False\n\ndef main(args):\n    n = int(input())\n    d = input()\n    x, y = list(map(int, input().split()))\n    py = [0] + [1 if c == 'U' else (-1 if c == 'D' else 0) for c in d]\n    px = [0] + [1 if c == 'R' else (-1 if c == 'L' else 0) for c in d]\n    if abs(x+ y)%2 != n%2:\n        print(-1)\n        return 0\n    py = list(itertools.accumulate(py))\n    px = list(itertools.accumulate(px)) \n    if px[-1] == x and py[-1] == y:\n        print(0)\n        return 0\n    if abs(x) + abs(y) > n:\n        print(-1)\n        return 0\n    left = 0\n    right = n\n    while left + 1 < right:\n        mid = (left + right) // 2\n        if solve(mid, n, px, py, x, y):\n            left, right = left, mid\n        else:\n            left, right = mid, right\n    print(right)\n    return 0\n\ndef __starting_point():\n    import sys\n    return(main(sys.argv))\n\n__starting_point()", "def go(pos,k):\n    if 'U'==k:\n        pos[1]+=1\n    elif 'D'==k:\n        pos[1]-=1\n    elif 'L'==k:\n        pos[0]-=1\n    else:\n        pos[0]+=1\n    return pos\n\ndef relapos(a,b):           #\u8fd4\u56deb\u7684\u5750\u6807\u51cfa\u7684\u5750\u6807\n    c=[b[0]-a[0],b[1]-a[1]]\n    return c\n\ndef stdis(a,b):\n    return abs(b[1]-a[1])+abs(b[0]-a[0])\n    \n\nn=int(input())\ns=input()\nx,y=[int(i) for i in input().split()]\nposs=[[0,0]]             #\u7b2cn\u6b21\u64cd\u4f5c\u540e\u7684\u4f4d\u7f6e\npos=[0,0]\nfor i in range(0,n):\n    poss.append(tuple(go(pos,s[i])))\nif abs(x)+abs(y)>n or abs(n-x-y)%2!=0:\n    print(-1)\nelse:\n    lpos=poss[-1]\n    dd=stdis(lpos,[x,y])\n    if dd==0:\n        print(0)\n    else:\n        q1=(dd-1)//2\n        q2=n\n        j=True\n        lpos1=[0,0]\n        while q2-q1!=1:\n            q=(q2+q1)//2\n            for k1 in range(n-q+1):\n                r=relapos(poss[k1],poss[k1+q])\n                lpos1[0]=lpos[0]-r[0]\n                lpos1[1]=lpos[1]-r[1]\n                if stdis(lpos1,[x,y])<=q:\n                    q2=q\n                    break\n            else:\n                q1=q\n        print(q2)\n", "n = int(input())\nsubtract = lambda t1, t2: (t1[0] - t2[0], t1[1] - t2[1])\nadd = lambda t1, t2: (t1[0] + t2[0], t1[1] + t2[1])\ndef conv(ch):\n\tif ch == 'L':\n\t\treturn (-1, 0)\n\telif ch == 'R':\n\t\treturn (1, 0)\n\telif ch == 'U':\n\t\treturn (0, 1)\n\telif ch == 'D':\n\t\treturn (0, -1)\n\nops = [conv(ch) for ch in input()]\nx, y = list(map(int, input().split()))\nlsum = [ops[0]] * n\nfor i in range(1, n):\n\tlsum[i] = add(lsum[i - 1], ops[i])\nrsum = [ops[n - 1]] * n\ni = n - 2\nwhile i >= 0:\n\trsum[i] = add(rsum[i + 1], ops[i])\n\ti = i - 1\n\ndef check(L):\n\t\n\tfor i in range(0, n - L + 1):\n\t\tmoves = (x, y)\n\t\tif i > 0:\n\t\t\tmoves = subtract(moves, lsum[i - 1])\n\t\tif i + L < n:\n\t\t\tmoves = subtract(moves, rsum[i + L])\n\t\tturns = abs(moves[0]) + abs(moves[1])\n\t\tif (turns <= L and (L - turns) % 2 == 0):\n\t\t\treturn True;\n\treturn False;\n\nif abs(x) + abs(y) > n or (abs(x) + abs(y) - n) % 2 != 0:\n\tprint((-1));\nelse:\n\tst, en = 0, n\n\twhile st < en:\n\t\tmd = (st + en) // 2\n\t\tif check(md):\n\t\t\ten = md\n\t\telse:\n\t\t\tst = md + 1\n\tprint(st)\n", "def check(length: int):\n    nonlocal n, x, y, cur, hor, ver\n    hor = 0\n    ver = 0\n    for i in range(length, n):\n        upd(i)\n    for i in range(n - length + 1):\n        if abs(x - hor) + abs(y - ver) <= length:\n            return True\n        if i + length < n:\n            upd(i)\n            minus_upd(i + length)\n    return False\n\n\ndef upd(pos: int):\n    nonlocal s, ver, hor\n    if s[pos] == 'U':\n        ver += 1\n    elif s[pos] == 'D':\n        ver -= 1\n    elif s[pos] == 'R':\n        hor += 1\n    else:\n        hor -= 1\n\n\ndef minus_upd(pos: int):\n    nonlocal s, ver, hor\n    if s[pos] == 'U':\n        ver -= 1\n    elif s[pos] == 'D':\n        ver += 1\n    elif s[pos] == 'R':\n        hor -= 1\n    else:\n        hor += 1\n\n\nn = int(input())\ns = list(input())\nx, y = map(int, input().split())\nif (x + y) % 2 != n % 2 or abs(x) + abs(y) > n:\n    print(-1)\n    return\n\nver = 0\nhor = 0\ncur = 0\nfor i in range(n):\n    upd(i)\n\nleft = -1\nr = n\nwhile r - left > 1:\n    length = (r + left) // 2\n    if check(length):\n        r = length\n    else:\n        left = length\n\nprint(r)", "n=int(input())\na=input()\nx,y=map(int,input().split())\nlocs=[(0,0)]\nfor i in range(n):\n    if a[i]==\"U\":\n        locs.append((locs[-1][0],locs[-1][1]+1))\n    elif a[i]==\"D\":\n        locs.append((locs[-1][0],locs[-1][1]-1))\n    elif a[i]==\"R\":\n        locs.append((locs[-1][0]+1,locs[-1][1]))\n    else:\n        locs.append((locs[-1][0]-1,locs[-1][1]))\nif abs(x)+abs(y)>n or (x+y-n)%2==1:\n    print(-1)\nelif locs[-1]==(x,y):\n    print(0)\nelse:\n    a=0\n    b=0\n    best=n\n    end=locs[-1]\n    while True:\n        c,d=locs[a][0]+end[0]-locs[b][0],locs[a][1]+end[1]-locs[b][1]\n        if abs(c-x)+abs(d-y)<=b-a:\n            best=min(best,b-a)\n            a+=1\n        else:\n            b+=1\n            if b>n:\n                print(best)\n                break", "import functools\n\nn = int(input())\ndct = {'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0)}\nmoves_list = list([dct[x] for x in [*input()]])\ndest_x, dest_y = list(map(int, input().split()))\n\n\ndef add_vectors(a, b):\n    return a[0] + b[0], a[1] + b[1]\n\n\ndef subtract_vectors(a, b):\n    return a[0] - b[0], a[1] - b[1]\n\n\ntotal = functools.reduce(add_vectors, moves_list)\n\n\ndef czy(dl) -> bool:\n    sumo = total\n    for v in moves_list[:dl]:\n        sumo = subtract_vectors(sumo, v)\n    for i in range(1, n - dl + 2):\n        (dx, dy) = list(map(abs, subtract_vectors((dest_x, dest_y), sumo)))\n        if dx + dy <= dl and (dx + dy) % 2 == dl % 2:\n            return True\n        if i + dl - 1 >= n:\n            break\n        sumo = subtract_vectors(sumo, moves_list[i + dl - 1])\n        sumo = add_vectors(sumo, moves_list[i - 1])\n    return False\n\n\npocz = 0\nkon = n\nwhile pocz < kon:\n    sr = (pocz + kon) // 2\n    if czy(sr):\n        kon = sr\n    else:\n        pocz = sr + 1\n\nif czy(pocz):\n    print(pocz)\nelse:\n    print(-1)\n"]