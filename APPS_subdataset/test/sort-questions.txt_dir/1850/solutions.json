["n,p=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nr=a[p-1]+b[0]\ncou=0\nfor i in range(p-1):\n    if a[i]+b[-1]<=r:\n        cou+=1;del b[-1]\nprint(p-cou)", "I=lambda:map(int,input().split())\nn,p=I()\na=list(I())\nb=list(I())\nr=a[p-1]+b[0]\ns=0\nfor i in range(p-1):\n    if r>=b[-1]+a[i]:\n        s+=1\n        del b[-1]\nprint(p-s)", "n,k = map(int,input().split())\n\na = [int(i) for i in input().split()]\nb = [int(i) for i in input().split()]\n\nimp = i = 0\n\nwhile a[i]>a[k-1]+b[0]:\n\timp += 1\n\ti += 1\nkey = a[k-1] + b[0]\na[k-1] += b[0]\n\nfor j in range(i):\n\ta[j] += b[j+1]\n\na = sorted(a, reverse=True)\n\t\nind = a.index(key)\nq = imp+1\n\nfor k in range(n-1,ind,-1):\n    a[k] += b[q]\n    q += 1\n    \na = sorted(a, reverse=True)\nprint(a.index(key)+1)", "# PREYANSH RASTOGI\n# 2017176\n\n\ndef __starting_point():\n\t\n\n\tn,d = [int(x) for x in input().split()]\n\td-=1\n\ts = [int(x) for x in input().split()]\n\tp = [int(x) for x in input().split()]\n\n\tval = p[0]+s[d]\n\n\tans = 1\n\t\n\tt = n - (n-d) -1\n\n\tfor i in range(n-d,len(p)) :\n\n\t\tif p[i] + s[t] > val :\n\t\t\tans+=1\n\t\telse :\n\t\t\tt-=1\n\n\tprint(ans)\n\n\n\n__starting_point()", "#!/usr/bin/env python3\nimport sys\n\ndef rint():\n    return list(map(int, sys.stdin.readline().split()))\n#lines = stdin.readlines()\n\nN, D = rint()\n\nS = list(rint())\nP = list(rint())\n\nnew_score = S[D-1] + P[0]\n\nk = 1\nans = 0\nfor i in range(D-2, -1, -1):\n    if k > N-1:\n        ans = i+2\n        break\n    for j in range(k, N):\n        if S[i] + P[j] <= new_score:\n            k = j + 1\n            break\n    else:\n        ans = i+2\n        break\nelse:\n    ans = 1\nprint(ans)\n\n", "a = input().split()\na = [int(i) for i in a]\n\nb = input().split()\nb = [int(i) for i in b]\n\nc = input().split()\nc = [int(i) for i in c]\n\ncha = []\n\nfor i in range(0, a[1] - 1):\n\tcha.append(b[i] -b[a[1] - 1])\n\ncao = []\nfor i in range(1, a[1]):\n\tcao.append(c[0] - c[-i])\n\ndui = 0\ncha.sort()\ncao.sort()\n\ni = 0\nj = 0\nwhile(j < a[1] - 1):\n\tif cha[i] <= cao[j]:\n\t\tdui += 1\n\t\ti += 1\n\t\tj += 1\n\telse:\n\t\tj += 1\n\t\t\n\t\t\nprint (a[1] - dui)", "from bisect import bisect_right\n\nnum_racers, selected_racer = list(map(int, input().split()))\nselected_racer -= 1\nracers_points = list(map(int, input().split()))\nselected_racer_points = racers_points[selected_racer]\nawards = list(map(int, input().split()))\nawards.sort(reverse=True)\nselected_racer_points += awards[0]\nremaining_awards = awards[1:]\ndel racers_points[selected_racer]\nremaining_racers_points = sorted(racers_points, reverse=True)\nbest_award_pos = 0\nworst_award_pos = len(remaining_awards) - 1\nfor pos, racer_points in enumerate(remaining_racers_points):\n    if racer_points + remaining_awards[worst_award_pos] <= selected_racer_points:\n        remaining_racers_points[pos] += remaining_awards[worst_award_pos]\n        worst_award_pos -= 1\n    else:\n        remaining_racers_points[pos] += remaining_awards[best_award_pos]\n        best_award_pos += 1\nremaining_racers_points.append(selected_racer_points)\nremaining_racers_points.sort()\nprint(num_racers + 1 - bisect_right(remaining_racers_points, selected_racer_points))\n", "n,d=[int(x) for x in input().split()]\nsk=[int(x) for x in input().split()]\npk=[int(x) for x in input().split()]\nmaxm=sk[d-1]+max(pk)\ndip=0\npkk=1\nfor k in range(0,d):\n    if(sk[k]+pk[-pkk]<=maxm):\n        dip+=1\n        pkk+=1\nprint(d-dip+1)\n\n\n", "\nn,d = list(map(int,input().strip().split()))\n\npre = list(map(int,input().strip().split()))\n\nnxt = list(map(int,input().strip().split()))\n\npre[d-1] += nxt[0]\nnxt[0] = -10\n\nk = n\nl = 1\nans = 0\nfor i in range(d-2,-1,-1):\n    for j in range(l,k):\n        l+=1\n        if pre[i]+nxt[j] <= pre[d-1]:\n            ans+=1 \n            break\n    if l==n:\n        break\n        \n\nprint(d-ans)\n    \n", "# -*- coding: utf-8 -*-\nfrom math import ceil\n\ndef problem(line1, line2, line3):\n    in1 = list(map(int, line1.split()))\n    \n    n = in1[0]\n    position = in1[1]\n    \n    standings = list(map(int, line2.split()))\n    awards = list(map(int, line3.split()))\n    \n    if n == 1 or position == 1:\n        return 1\n    \n    my_points = standings[position - 1]\n    my_award = awards[0]\n    diffs = []\n    \n    for index, p in enumerate(reversed(standings[0:position - 1])):\n        diffs.append(p - my_points)\n        \n    enemies = position - 1;\n    awards = awards[-(enemies):]\n\n#    print(my_award)\n#    print(enemies)\n#    print(diffs)\n#    print(awards)\n    \n    enemy_idx = 0\n    award_idx = 0\n    overtakes = 0\n       \n#    print(award_idx)\n\n    while award_idx < len(awards):\n        while (award_idx < enemies) and (diffs[enemy_idx] + awards[award_idx] > my_award):\n            award_idx += 1\n        \n        if (award_idx < enemies) and (diffs[enemy_idx] + awards[award_idx] <= my_award):\n            overtakes += 1\n            enemy_idx += 1\n            award_idx += 1\n        else:\n            break;\n        \n    return position - overtakes\n\ndef __starting_point():\n    line1 = input()\n    line2 = input()\n    line3 = input();\n\n    result = problem(line1, line2, line3)\n    \n    print(result)\n\n__starting_point()", "import bisect\nn,d=list(map(int,input().strip().split()))\nd=d-1\n\ncurscore=list(map(int,input().strip().split()))\nnextp=list(map(int,input().strip().split()))\nlenarr=len(curscore)\nnewscore=curscore[d]+nextp.pop(0)\nnextp.sort()\n# curscore=[50,40,30,25,35,20,15]\n# print(newscore)\ncurscore.sort()\n# print(curscore)\n# print(nextp)\nindexmax=bisect.bisect(curscore,newscore)\nindexmin=bisect.bisect(curscore,curscore[lenarr-1-d])\n\nlargerpoint=0\n# print(indexmin,indexmax)\nfor i in range(indexmin,indexmax):\n    # print(curscore[i],end=\" \")\n    subval=newscore-curscore[i]\n    indexsub=bisect.bisect(nextp,subval)-1\n    # print(indexsub)\n    if indexsub<0:\n        largerpoint+=1\n        continue\n    else:\n        nextp.pop(indexsub)\n\nprint(len(curscore)-indexmax+largerpoint+1)\n", "import sys\ninput = sys.stdin.readline\nn, d = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nscore = a[d-1] + b[0]\ncurrent_pos = 1\nj = n - 1\nk = 1\ni = 0\nwhile i != d - 1:\n    if a[i] > score:\n        current_pos += 1\n        k += 1\n    else:\n        if a[i] + b[j] > score:\n            current_pos += 1\n        elif a[i] + b[j] <= score:\n            j -= 1\n    i += 1\nprint(current_pos)", "n,d=list(map(int,input().split()))\nsk = list(map(int,input().split()))\npk=list(map(int,input().split()))\n\nsk[d-1] += pk[0]\npk.pop(0)\nrank=1\n\nfor i in range(d-1):\n    if sk[i]+pk[-1]>sk[d-1]:\n        rank+=1\n    elif sk[i]+pk[-1]==sk[d-1]:\n        pk.pop()\n        \n    else:\n        j=len(pk)-1\n        pk.pop(j)            \n    \n\nprint(rank)\n\n    \n", "n,k=map(int,input().strip().split())\ncr = list(map(int,input().strip().split()))\npa = list(map(int,input().strip().split()))\nx = cr[k-1]+pa[0]\np = 0\nif k==1:\n\tprint(1)\nelse:\n    for i in range(k-1):\n    \tif cr[i]+pa[-1]<=x:\n    \t\tp +=1\n    \t\tdel pa[-1]\n    print(k-p)", "n,d=list(map(int,input().split()))\nsk = list(map(int,input().split()))\npk=list(map(int,input().split()))\n\nsk[d-1] += pk[0]\nrank=1\n\nfor i in range(d-1):\n    if sk[i]+pk[-1]>sk[d-1]:\n        rank+=1\n    else:\n        del pk[-1]\n    \n\nprint(rank)\n\n    \n", "n,p=list(map(int,input().split()))\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nx=a[p-1]+b[0]\nz = p-2\nc=0\nfor i in range(1,n):\n\tif b[i]+a[z]<=x:\n\t\tc+=1\n\t\tz-=1\n\tif z<0:\n\t\tbreak\nprint(max(p-c,1))\t\t\t\n\n", "m=input().split()\nn=int(m[0])\nj=int(m[1])\nl1=input().split()\nl2=input().split()\n\np=int(l1[j-1])+int(l2[0])\nc=j\nfor i in range (j-1):\n    if p>=int(l1[i])+int(l2[-1]):\n        c-=1\n        l2.pop()\n\n    \nprint(c)\n", "n, d = map(int, input().split())\nd -= 1\ns, p, j = [*map(int, input().split())], [*map(int, input().split())], -1\nfor i in range(n):\n\tif s[d] + p[0] < s[i]:\n\t\tcontinue\n\tif i == d:\n\t\ts[i] += p[0]\n\t\tbreak\n\telse:\n\t\ts[i] += p[j]\n\t\tj -= 1\nprint(sorted(s, reverse=True).index(s[d]) + 1)", "import sys\nfrom sys import stdin,stdout\nn,d=map(int,stdin.readline().split(' '))\nini=list(map(int,stdin.readline().split(' ')))\npoi=list(map(int,stdin.readline().split(' ')))\n\nmaxp=ini[d-1]+poi[0]\nctr3=0\nfor i in range(d-1):\n  if ini[i]+poi[-1]<=maxp:\n    ctr3+=1\n    poi.pop(-1)\nprint(d-ctr3)", "n, d = map(int, input().split())\nd -= 1\ns, p, j = [*map(int, input().split())], [*map(int, input().split())], -1\nfor i in range(n):\n\tif s[d] + p[0] < s[i]:\n\t\tcontinue\n\tif i == d:\n\t\ts[i] += p[0]\n\t\tbreak\n\telse:\n\t\ts[i] += p[j]\n\t\tj -= 1\nprint(sorted(s, reverse=True).index(s[d]) + 1)", "from bisect import bisect_right\nn,d = map(int,input().split())\ns = list(map(int,input().split()))\np = list(map(int,input().split()))\nt_wyn = []\nwyn = s[d-1]+p[0]\nt_wyn.append(wyn)\ndel s[d-1]\ns_sort = sorted(s)\np_sort = sorted(p)\np_sort.pop()\nfor x in range(0,len(s),+1):\n    szuk = wyn-s_sort[x]-1\n    if szuk < 0:\n        t_wyn.append(s_sort[x]+p_sort[-1])\n    else:\n        pos = bisect_right(p_sort,szuk)\n        if pos > 0:\n            t_wyn.append(s_sort[x] + p_sort[pos-1])\n            del p_sort[pos-1]\n            continue\n        else:\n            t_wyn.append(s_sort[x] + p_sort[-1])\n    p_sort.pop()\nt_wyn = sorted(t_wyn)\npos = bisect_right(t_wyn,wyn)\nprint(n-(pos-1))", "n, d = map(int, input().split())\n\npos = list(map(int , input().split()))\npoints = list(map(int , input().split()))\ncur = d - 1\ncur_score = pos[cur]+points[0]\nq = n - 1\nfor i in range(cur):\n    if pos[i] + points[q] <= cur_score:\n        q -= 1\n        cur -= 1\nprint(cur+1)", "n,d=map(int,input().split())\ns=list(map(int,input().split()))\nk=list(map(int,input().split()))\nx=s[d-1]+k[0]\nj=0\no=0\nfor i in range(d-2, -1, -1):\n    j+=1\n    while j<len(k) and s[i]+k[j]>x: j+=1\n    if j>=len(k):o=i+1;break\nprint(o+1)", "N,D=map(int,input().split())\nranking=list(map(int,input().split()))\nscores=list(map(int,input().split()))\nDs=ranking[D-1]+scores[0]\nranking.sort()\nimport bisect\nnew=bisect.bisect_right(ranking,Ds,0,N)\ndaiding=ranking[N+1-D:new]\nm=0\nfor i in daiding[::-1]:\n    if i+scores[-1]<=Ds:\n        del(scores[-1])\n        m+=1\nprint(D-m)", "n, d = [int(x) for x in input().split()]\ns = list(map(int, input().split()))\nl = list(map(int, input().split()))\nscore = s[d - 1] + l[0]\nrank = d\nj = n - 1\nfor i in range(d - 1):\n    if s[i] <= score:\n        if s[i] + l[j] <= score:\n            rank -= 1\n            j -= 1\nprint(rank)"]