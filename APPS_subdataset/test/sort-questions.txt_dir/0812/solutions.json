["import sys \nfrom collections import defaultdict\ninput = lambda : sys.stdin.readline().strip()\nwrite = lambda x: sys.stdout.write(x)\n\nn = int(input())\narr = sorted([(j, i + 1) for i, j in enumerate(map(int, input().split()))])\n\nif n <= 3:\n  print(arr[0][1])\n  return\n\n\na1, a2, a3 = arr[0][0], arr[1][0], arr[2][0]\nc1, c2, c3 = a3 - a2, a3 - a1, a2 - a1\n\nflag = True\nx = a2\nfor i in range(n):\n  if i == 0:\n    continue \n  if arr[i][0] != x:\n    flag = False \n    break\n  else:\n    x += c1\n\nif flag:\n  print(arr[0][1])\n  return\n\nflag = True\nx = a1\nfor i in range(n):\n  if i == 1:\n    continue \n  if arr[i][0] != x:\n    flag = False \n    break\n  else:\n    x += c2\n\nif flag:\n  print(arr[1][1])\n  return\n\n\nflag = []\nx = a1\nfor i in range(n): \n  if arr[i][0] != x:\n    flag.append(arr[i]) \n  else:\n    x += c3\n\nif len(flag) >= 2:\n  print(-1)\nelse:\n  print(flag[0][1])", "n = int(input())\nb = list(map(int, input().split()))\nb_ = []\nfor i, t in enumerate(b):\n    b_.append([t, i+1])\nb_.sort()\n\n\ndef solve(s):\n    def check(a):\n        if len(a) <= 1:\n            return True\n        delta = a[1] - a[0]\n        for i in range(1, len(a) - 1):\n            if a[i + 1] - a[i] != delta:\n                return False\n        return True\n\n    if check([x[0] for x in s[1:]]):\n        # print('a')\n        return s[0][1]\n    if check([x[0] for x in s[:-1]]):\n        # print('b')\n        return s[-1][1]\n    if check([x[0] for x in s[:1] + s[2:]]):\n        # print('c') \n        return s[1][1]\n    if check([x[0] for x in s[:-2] + s[-1:]]):\n        # print('d')\n        return s[-2][1]\n\n    # mid\n    t = []\n    for i in range(len(s) - 1):\n        t.append(s[i+1][0] - s[i][0])\n    # print(t)\n\n    i = 0\n    while t[i] == t[0]:\n        i += 1\n    j = len(t) - 1\n    while t[j] == t[-1]:\n        j -= 1\n\n    if t[0] == t[-1]:\n        if i != j - 1:\n            return -1\n        if t[i] + t[j] != t[0]:\n            return -1\n        return s[j][1]\n    else:\n        if i != j:\n            return -1\n        if i == 1 and t[0] + t[1] == t[2]:\n            return s[1][1]\n        if j == len(t) - 2 and t[j] + t[j+1] == t[j - 1]:\n            return s[len(t) - 1][1]\n        return -1\n\n\nprint(solve(b_))\n", "n = int(input())\na = []\ni = 0\nfor el in map(int, input().split()):\n    a.append((el, i))\n    i += 1\na.sort()\nif n == 2:\n    print(1)\n    return\nst = a[2][0] - a[1][0]\nfor i in range(1, n - 1):\n    if a[i + 1][0] - a[i][0] != st:\n        break\nelse:\n    print(a[0][1] + 1)\n    return\nst = a[2][0] - a[0][0]\nfor i in range(2, n - 1):\n    if a[i + 1][0] - a[i][0] != st:\n        break\nelse:\n    print(a[1][1] + 1)\n    return\nst = a[1][0] - a[0][0]\ni = 1\nfound = -1\nwhile i < n - 1:\n    if a[i + 1][0] - a[i][0] != st:\n        if found != -1:\n            print(-1)\n            return\n        else:\n            found = i + 1\n            i += 1\n    i += 1\nt = a.pop(found)\nfor i in range(n - 2):\n    if a[i + 1][0] - a[i][0] != st:\n        print(-1)\n        break\nelse:\n    print(t[1] + 1)\n    return\n", "import sys\nfrom collections import Counter\nfrom operator import itemgetter\n\nn = int(sys.stdin.readline().strip())\nif n < 3:\n    print('1')\n    return\n\ntimes = list(enumerate(map(int, (sys.stdin.readline().split()))))\ntimes.sort(key=itemgetter(1))\n\norigindices = [t[0] for t in times]\ntimes = [t[1] for t in times]\n\n\n# check if we can remove the first\nc = times[2] - times[1]\na = times[1]\nsuccess = True\nfor i in range(2,n):\n    if times[i] != a + c * (i - 1):\n        success = False\n        break\n\nif success:\n    print(origindices[0] + 1)\n    return\n\n\n# check if we can remove the second\na = times[0]\nc = times[2] - times[0]\nsuccess = True\nfor i in range(2, n):\n    if times[i] != a + c * (i - 1):\n        success = False\n        break\n\nif success:\n    print(origindices[1] + 1)\n    return\n\n\n# check if we can remove any other\nremovednum = 1 # if everything is correct (and we don't have to delete any element), we can just delete the first one\nsuccess = True\na = times[0]\nc = times[1] - times[0]\nfor i in range(2,n):\n    if (removednum == 1 and times[i] != a + c * i) \\\n       or (removednum != 1 and times[i] != a + c * (i - 1)):\n        # print(f'Found that {times[i]} is not equal to {a + c * i} {a}, {i}, {c}')\n        if removednum == 1:\n            removednum = i # maybe it will still work if we remove this one; add 1 to shift index\n        else:\n            # otherwise, we already have removed an element,\n            # so we must conclude that there is no way to make this succeed\n            success = False\n            break\n\nif success:\n    print(origindices[removednum] + 1)\n    return\n\n\n# This should only happen when everything fails:\nprint(-1)\n\n\n"]