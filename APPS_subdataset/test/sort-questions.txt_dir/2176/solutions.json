["import sys\nfrom collections import Counter\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nMOD = 998244353\nn = int(input())\nfact = [1]\nfor i in range(1, n+1):\n\tfact.append((fact[-1]*i)%MOD)\n\nseq = []\nca, cb = Counter(), Counter()\nfor _ in range(n):\n\ta, b = map(int, input().split())\n\tca[a] += 1\n\tcb[b] += 1\n\tseq.append((a, b))\n\nans = fact[n]\nans %= MOD\n#print(ans)\n\nres = 1\nfor v in ca.values():\n\tres *= fact[v]\n\tres %= MOD\nans -= res\nans %= MOD\n#print(ans)\n\nres = 1\nfor v in cb.values():\n\tres *= fact[v]\n\tres %= MOD\nans -= res\n#print(ans)\n\nseq.sort(key=lambda x: (x[0], x[1]))\ncur = seq[0][0]\nres = 1\nM = 1\nctmp = Counter()\nfor i in range(n):\n\tif seq[i][0] == cur:\n\t\tctmp[seq[i][1]] += 1\n\t\tM = max(M, seq[i][1])\n\telse:\n\t\tif seq[i][1] < M:\n\t\t\tres = 0\n\t\t\tbreak\n\t\ttmp = 1\n\t\tfor v in ctmp.values():\n\t\t\ttmp *= fact[v]\n\t\t\ttmp %= MOD\n\t\tres *= tmp\n\t\tres %= MOD\n\t\tctmp = Counter()\n\t\tctmp[seq[i][1]] += 1\n\t\tcur = seq[i][0]\n\t\tM = max(M, seq[i][1])\ntmp = 1\nfor v in ctmp.values():\n\ttmp *= fact[v]\n\ttmp %= MOD\nres *= tmp\nres %= MOD\n\nans += res\nans %= MOD\nprint(ans)", "import sys\ninput = sys.stdin.readline\n\nmod=998244353\n\nn=int(input())\nS=[list(map(int,input().split())) for i in range(n)]\n\nFACT=[1]\nfor i in range(1,3*10**5+10):\n    FACT.append(FACT[-1]*i%mod)\n\nX=[x for x,y in S]\nY=[y for x,y in S]\n\nANS=1\nfor i in range(1,n+1):\n    ANS=ANS*i%mod\n\nX.sort()\nXA=1\ncount=1\nfor i in range(1,n):\n    if X[i]==X[i-1]:\n        count+=1\n    else:\n        XA=XA*FACT[count]%mod\n        count=1\n        \nXA=XA*FACT[count]%mod\n\nY.sort()\nYA=1\ncount=1\nfor i in range(1,n):\n    if Y[i]==Y[i-1]:\n        count+=1\n    else:\n        YA=YA*FACT[count]%mod\n        count=1\nYA=YA*FACT[count]%mod\n\n\nS.sort()\nSA=1\ncount=1\nfor i in range(1,n):\n    if S[i][1]<S[i-1][1]:\n        SA=0\n        break\n    \n    if S[i]==S[i-1]:\n        count+=1\n    else:\n        SA=SA*FACT[count]%mod\n        count=1\n\nSA=SA*FACT[count]%mod\n\n    \n\nprint((ANS-XA-YA+SA)%mod)\n", "import sys\n\np = 998244353\nn = int(sys.stdin.readline())\nS1 = []\nS2 = []\nA = []\nfor i in range (0, n):\n    x, y = list(map(int, sys.stdin.readline().strip().split()))\n    S1.append(x)\n    S2.append(y)\n    A.append(x * 1000000 + y)\nS1.sort()\nS2.sort()\nA.sort()\nx = S1[0]\nc = 1\nans1 = 1\nfor i in range (1, n):\n    if S1[i] == x:\n        c = c + 1\n        ans1 = (ans1 * c) % p\n    else:\n        x = S1[i]\n        c = 1\nc = 1\nans2 = 1\nx = S2[0]\nfor i in range (1, n):\n    if S2[i] == x:\n        c = c + 1\n        ans2 = (ans2 * c) % p\n    else:\n        x = S2[i]\n        c = 1\nc = 1\nans3 = 1\nx = A[0]\nfor i in range (1, n):\n    if A[i] == x:\n        c = c + 1\n        ans3 = (ans3 * c) % p\n    else:\n        x = A[i]\n        c = 1\n    if A[i] % 1000000 < A[i-1] % 1000000:\n        ans3 = 0\nans4 = 1\nfor i in range (1, n + 1):\n    ans4 = ans4 * i % p\nprint((ans4 - ans1 -ans2 + ans3) % p)\n\n\n    \n\n", "from sys import stdin\ninput = stdin.readline\nn = int(input())\np = 998244353\nsil = [0] * 400000\nsil[1] = 1\nfor i in range(2, 400000):\n    sil[i] = (sil[i -1] * i) % p\ndef fun(l):\n    wyn = 1\n    l.sort()\n    count = 1\n    for i in range(1, len(l)):\n        if l[i] != l[i-1]:\n            wyn = (wyn * sil[count]) % p\n            count = 1\n        else:\n            count += 1\n    wyn = (wyn * sil[count]) % p\n    return wyn\ndupa = [list(map(int,input().split())) for i in range(n)]\nxx = [i[0] for i in dupa]\nyy = [i[1] for i in dupa]\ndupa.sort()\nx = [i[0] for i in dupa]\ny = [i[1] for i in dupa]\ndolne = []\npyk = 1\nleft = 0\nfor i in range(1, n):\n    if x[i] != x[i-1]:\n        dolne.append(y[left:i])\n        left = i\nif left == n - 1:\n    dolne.append([y[n - 1]])\nelse:\n    dolne.append(y[left:n])\nc = 1\nfor i in range(1, len(dolne)):\n    if min(dolne[i]) < max(dolne[i - 1]):\n        c = 0\n        break\n# c = 0 means no overlaps\n\nwyn = fun(xx) + fun(yy)\nif c == 1:\n    dupa = 1\n    for i in range(len(dolne)):\n        dupa = (dupa * fun(dolne[i])) % p\n    wyn -= dupa\nprint((sil[n] - wyn) % p)", "from collections import Counter\nimport sys\ninput = sys.stdin.readline\nMOD = 998244353 \nINF = 10**10\n\nn = int(input())\ns = []\na_s = []\nb_s = []\nfor i in range(n):\n    a, b = [int(item) for item in input().split()]\n    s.append((a, b))\n    a_s.append(a)\n    b_s.append(b)\ns.sort()\ns.append((INF, INF))\n\n# Calc facs\nfacs = [1] * (n + 1)\nans = 1\nfor i in range(1, n+1):\n    facs[i] = facs[i-1] * i % MOD\nans = facs[n]\n\n# Check both sort\npa = 0; pb = 0\nboth_cnt = 1\nsame = 1\nfor a, b in s:\n    if a == pa and b == pb:\n        same += 1\n    else:\n        if b < pb:\n            both_cnt = 0\n            break\n        both_cnt *= facs[same]\n        both_cnt %= MOD\n        same = 1\n    pa = a; pb = b\n\n# Check upper sort\nacnt = Counter(a_s)\nfirst_cnt = 1\nfor key in acnt.keys():\n    first_cnt *= facs[acnt[key]]\n    first_cnt %= MOD\n\n# Check lower sort\nbcnt = Counter(b_s)\nsecond_cnt = 1\nfor key in bcnt.keys():\n    second_cnt *= facs[bcnt[key]]\n    second_cnt %= MOD\n\nprint((ans - (first_cnt + second_cnt - both_cnt) + MOD) % MOD)", "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nimport math\nimport copy\n \n#T = int(input())\nN = int(input())\n#s = input()\n#N,M = [int(x) for x in stdin.readline().split()]\n#arr = [int(x) for x in stdin.readline().split()]\n \npermu = [0]*N\npermu[0] = 1\nfor i in range(1,N):\n    permu[i] = (permu[i-1]*(i+1))%998244353\n\ndata = []\npair = {}\nfor i in range(N):\n    a,b = [int(x) for x in stdin.readline().split()]\n    data.append((a,b))\n    if a not in pair:\n        pair[a] = []\n        \n    pair[a].append(b)\n    \n    \nfreq_one = {}\nfor i in range(N):\n    a = data[i][0]\n    if a not in freq_one:\n        freq_one[a] = 1\n    else:\n        freq_one[a] += 1\n        \nall = permu[-1]\n\n# first column\np1 = 1\nfor key in freq_one:\n    f = freq_one[key]\n    p1 *= permu[f-1]\n    p1 = p1%998244353\n\nfreq_two = {}\nfor i in range(N):\n    a = data[i][1]\n    if a not in freq_two:\n        freq_two[a] = 1\n    else:\n        freq_two[a] += 1\n        \n# second column        \np2 = 1\nfor key in freq_two:\n    f = freq_two[key]\n    p2 *= permu[f-1]\n    p2 = p2%998244353\n    \n# both sorted\nmax_second = 0\nP = list(pair.keys())\nP.sort()\n\np3 = 1\nfor key in P:\n    #print(key)\n    mini = min(pair[key])\n    if mini<max_second:\n        p3 = 0\n        break\n    \n    f = {}\n    for a in pair[key]:\n        if a not in f:\n            f[a] = 1\n        else:\n            f[a] += 1\n            \n    p = 1\n    for num in f:\n        fr = f[num]\n        p *= permu[fr-1]\n        p = p%998244353\n        \n    p3 *= p\n    p3 = p3%998244353\n    \n    max_second = max(pair[key])\n    \nans = (all-p1-p2+p3)%998244353\n\nprint(ans)\n\n\n    \n\n", "import sys\n\nin_file = sys.stdin#\n\nn = int(in_file.readline().strip())\nAl = []\nAr = []\nA = []\nfor _ in range(n):\n    x, y = map(int, in_file.readline().strip().split())\n    Al.append(x)\n    Ar.append(y)\n    A.append((x,y))\n\nAl.sort()\nAr.sort()\nA.sort()\n\ndef groups(L):\n    p = L[0]\n    G = [1]\n    for i in range(1, len(L)):\n        if p == L[i]:\n            G[-1] += 1\n        else:\n            p = L[i]\n            G.append(1)\n    return G\n\ndef bin_exp(x, a, p):\n    r = 1\n    while a>0:\n        if a%2 == 1:\n            r = (r*x)%p\n        x = (x*x)%p\n        a = a//2\n    return r\n\ndef mod_fact(x, p):\n    r = 1\n    for i in range(1, x+1):\n        r = (r*i)%p\n    return r\n\np = 998244353\nGl = groups(Al)\nrl = 1\nfor i in Gl:\n    rl = (rl*mod_fact(i, p))%p\nGr = groups(Ar)\nrr = 1\nfor i in Gr:\n    rr = (rr*mod_fact(i, p))%p\nG = groups(A)\nr = 1\nfor i in G:\n    r = (r*mod_fact(i, p))%p\nif list(zip(Al, Ar)) != A:\n    r = 0\nres = (mod_fact(len(A), p)+r)%p\nres = (p+res-rl)%p\nres = (p+res-rr)%p\n\nsys.stdout.write(str(res))\nsys.stdout.flush() ", "'''input\n3\n1 1\n2 2\n3 1\n\n'''\nimport sys\nfrom collections import defaultdict as dd\nmod=998244353  \n\ndef ri(flag=0):\n\tif flag==0:\n\t\treturn [int(i) for i in sys.stdin.readline().split()]\n\telse:\n\t\treturn int(sys.stdin.readline())\n\n\nn = ri(1)\n\none = []\nsec = []\ntake = []\nfor i in range(n):\n\ta, b = ri()\n\tone.append(a)\n\tsec.append(b)\n\ttake.append((a,b))\n\nans = 1\ntemp =1\n\nfor i in range(1,n+1):\n\tans = (ans*i)%mod\n\ntake.sort()\n\n# good good\ncnt1=0\ncnt2=0\n# check = [[0,0] for i in range(n)]\n\n# for i in range(1,n):\n# \tif take[i][0] != take[i-1][0]:\n# \t\tcheck[i][0] = check[i-1][0]+1\n# \telse:\n# \t\tcheck[i][0] = check[i-1][0]\n\n# \tif take[i][1] != take[i-1][1]:\n# \t\tcheck[i][1] = check[i-1][1]+1\n# \telse:\n# \t\tcheck[i][1] = check[i-1][1]\n\nc1= dd(int)\nc2 = dd(int)\nc3 =dd(int)\n\n\nstatus=1\n\nfor i in range(1,n):\n\tif take[i][1]<take[i-1][1]:\n\t\tstatus=0\n\nfor i in one:\n\tc1[i]+=1\nfor i in sec:\n\tc2[i]+=1\nfor i in take:\n\tc3[i]+=1\n\nok1=1\nok2=1\nok3=1\n\n#print(c1,c2,c3)\n\nfac= [1 for i in range(3*10**5+1)]\n\nfor i in range(1,3*10**5+1):\n\tfac[i] = (fac[i-1]*i)%mod\n\nfor i in c1:\n\tok1 = (ok1*fac[c1[i]])%mod\n\nfor i in c2:\n\tok2 = (ok2*fac[c2[i]])%mod\n\nfor i in c3:\n\tok3 = (ok3*fac[c3[i]])%mod\n\nif status==0:\n\tok3 = 0\n\nprint( (ans - ok1 - ok2 +ok3)%mod)\n", "from operator import itemgetter\nimport sys\n\n\nclass Combination:\n    '''MOD\u4e0a\u306e\n    \u8a08\u7b97\u91cf\uff1a\u968e\u4e57\u30fb\u9006\u5143\u30c6\u30fc\u30d6\u30eb\u306e\u4f5c\u6210O(N)\n    nCk\u3092\u6c42\u3081\u308bO(1)'''\n\n    def __init__(self, n, MOD):\n        self.fact = [1]\n        for i in range(1, n + 1):\n            self.fact.append(self.fact[-1] * i % MOD)\n\n\ninput = sys.stdin.readline\nn = int(input())\np = [list(map(int, input().split())) for i in range(n)]\nMOD = 998244353\ncomb = Combination(n, MOD)\nmemo1 = {}\nmemo2 = {}\n\nfor i in range(n):\n    tmp1, tmp2 = p[i]\n    if tmp1 not in memo1:\n        memo1[tmp1] = 1\n    else:\n        memo1[tmp1] += 1\n    if tmp2 not in memo2:\n        memo2[tmp2] = 1\n    else:\n        memo2[tmp2] += 1\n\nans = 0\n\ntmp = 1\nfor i in memo1:\n    tmp *= comb.fact[memo1[i]]\n    tmp %= MOD\nans += tmp\nans %= MOD\n\ntmp = 1\nfor i in memo2:\n    tmp *= comb.fact[memo2[i]]\n    tmp %= MOD\nans += tmp\nans %= MOD\n\np = sorted(p, key = itemgetter(1))\np = sorted(p, key = itemgetter(0))\nfor i in range(n-1):\n    if p[i][1] > p[i+1][1]:\n        ans = comb.fact[n] - ans\n        ans %= MOD\n        print(ans)\n        return\ncnt = 1\ntmp = 1\nfor i in range(n-1):\n    if p[i][0] == p[i+1][0] and p[i][1] == p[i+1][1]:\n        cnt += 1\n    else:\n        tmp *= comb.fact[cnt]\n        tmp %= MOD\n        cnt = 1\ntmp *= comb.fact[cnt]\ntmp %= MOD\nans -= tmp\n\nans = comb.fact[n] - ans\nans %= MOD\nprint(ans)", "import io, sys, atexit, os\nimport math as ma\nfrom decimal import Decimal as dec\nfrom itertools import permutations\nfrom itertools import combinations\n\n\ndef li ():\n\treturn list (map (int, sys.stdin.readline ().split ()))\n\n\ndef num ():\n\treturn map (int, sys.stdin.readline ().split ())\n\n\ndef nu ():\n\treturn int (input ())\n\n\ndef find_gcd ( x, y ):\n\twhile (y):\n\t\tx, y = y, x % y\n\treturn x\n\n\ndef lcm ( x, y ):\n\tgg = find_gcd (x, y)\n\treturn (x * y // gg)\n\n\nmm = 998244353\nyp = 0\n\ndef solve ():\n\tt = 1\n\tfor tt in range (t):\n\t\tn=nu()\n\t\ta=[]\n\t\tp=[]\n\t\tq=[]\n\t\tfact=[0]*(n+1)\n\t\tfact[0]=1\n\t\tfor i in range(1,n+1):\n\t\t\tfact[i]=(fact[i-1]*i)%mm\n\t\tfor i in range(n):\n\t\t\tx,y=num()\n\t\t\tp.append(x)\n\t\t\tq.append(y)\n\t\t\ta.append((x,y))\n\t\ta.sort()\n\t\tp.sort()\n\t\tq.sort()\n\t\tcc=1\n\t\tlast=p[0]\n\t\tans1=1\n\t\tfor i in range(1,n):\n\t\t\tif(last==p[i]):\n\t\t\t\tcc+=1\n\t\t\telse:\n\t\t\t\tans1=(ans1*fact[cc])%mm\n\t\t\t\tcc=1\n\t\t\t\tlast=p[i]\n\t\tans1 = (ans1 * fact [ cc ]) % mm\n\t\tcc=1\n\t\tlast=q[0]\n\t\tans2=1\n\t\tfor i in range(1,n):\n\t\t\tif(last==q[i]):\n\t\t\t\tcc+=1\n\t\t\telse:\n\t\t\t\tans2=(ans2*fact[cc])%mm\n\t\t\t\tcc=1\n\t\t\t\tlast=q[i]\n\t\tans2 = (ans2 * fact [ cc ]) % mm\n\t\tans3=1\n\t\tcc=1\n\t\tlast=a[0]\n\t\tfor i in range(1,n):\n\t\t\tif(last==a[i]):\n\t\t\t\tcc+=1\n\t\t\telif(last[0]>a[i][0] or last[1]>a[i][1]):\n\t\t\t\tans3=0\n\t\t\telse:\n\t\t\t\tans3=(ans3*fact[cc])%mm\n\t\t\t\tcc=1\n\t\t\t\tlast=a[i]\n\t\tans3 = (ans3 * fact [ cc ]) % mm\n\t\tprint((fact[n]-ans1-ans2+ans3+mm)%mm)\n\ndef __starting_point():\n\tsolve ()\n__starting_point()", "def increasing(arr):\n    n = len(arr)\n    for i in range(n-1):\n        if arr[i+1][0] < arr[i][0] or arr[i+1][1] < arr[i][1]:\n            return False\n\n    return True\n\ndef getFacts(n,mod):\n    facts = [1]*n\n    for i in range(1,n):\n        facts[i] = facts[i-1]*i\n        facts[i] %= mod\n\n    return facts\n\ndef solve(arr1,arr2,n,mod):\n    facts = getFacts(4*10**5+1,mod)\n    total = facts[n]\n    dist1 = {}\n    for i in arr1:\n        if i[0] not in list(dist1.keys()):\n            dist1[i[0]] = 1\n        else:\n            dist1[i[0]] += 1\n\n    dist2 = {}\n    for i in arr2:\n        if i[0] not in list(dist2.keys()):\n            dist2[i[0]] = 1\n        else:\n            dist2[i[0]] += 1\n\n    count = 1\n    for i in dist1:\n        count *= facts[dist1[i]]\n        count = count%mod\n\n    total -= count\n    count = 1\n    \n    for i in dist2:\n        count *= facts[dist2[i]]\n        count = count%mod\n\n    #print(count)\n    total -= count\n\n    arr1.sort()\n    if increasing(arr1):\n        count = 1\n    else:\n        count = 0\n    dist3 = {}\n    for i in arr1:\n        if i not in list(dist3.keys()):\n            dist3[i] = 1\n        else:\n            dist3[i] += 1\n        \n    for i in dist3:\n        count *= facts[dist3[i]]\n        count = count%mod\n\n    #print(count,total)\n    total += count\n    total = total%mod\n    print(total)\n    \n\ndef main():\n    mod = 998244353\n    n = int(input())\n    first = []\n    second = []\n    for i in range(n):\n        a,b = list(map(int,input().split()))\n        first.append((a,b))\n        second.append((b,a))\n    \n    solve(first,second,n,mod)\n\n\nmain()\n", "import sys\ninput = sys.stdin.readline\n \nmod=998244353\n \nn=int(input())\nS=[list(map(int,input().split())) for i in range(n)]\n \nFACT=[1]\nfor i in range(1,3*10**5+10):\n    FACT.append(FACT[-1]*i%mod)\n \nX=[x for x,y in S]\nY=[y for x,y in S]\n \nANS=1\nfor i in range(1,n+1):\n    ANS=ANS*i%mod\n \nX.sort()\nXA=1\ncount=1\nfor i in range(1,n):\n    if X[i]==X[i-1]:\n        count+=1\n    else:\n        XA=XA*FACT[count]%mod\n        count=1\n        \nXA=XA*FACT[count]%mod\n \nY.sort()\nYA=1\ncount=1\nfor i in range(1,n):\n    if Y[i]==Y[i-1]:\n        count+=1\n    else:\n        YA=YA*FACT[count]%mod\n        count=1\nYA=YA*FACT[count]%mod\n \n \nS.sort()\nSA=1\ncount=1\nfor i in range(1,n):\n    if S[i][1]<S[i-1][1]:\n        SA=0\n        break\n    \n    if S[i]==S[i-1]:\n        count+=1\n    else:\n        SA=SA*FACT[count]%mod\n        count=1\n \nSA=SA*FACT[count]%mod\n \n    \n \nprint((ANS-XA-YA+SA)%mod)", "import sys\ninput = sys.stdin.readline\n\nn = int(input())\ns = [list(map(int, input().split())) for y in range(n)]\nMOD = 998244353\n\nfact = [1]*(n+1)\nfor i in range(1, n+1):\n    fact[i] = (fact[i-1] * i) % MOD\n\na, b = [0]*n, [0]*n\n\nfor x, y in s:\n    a[x-1] += 1\n    b[y-1] += 1\n\na_count = 1\nb_count = 1\nfor i in range(n):\n    a_count *= fact[a[i]]\n    a_count %= MOD\n    b_count *= fact[b[i]]\n    b_count %= MOD\n\nab_count = 1\ncount = 1\ns.sort()\nfor i in range(1, n):\n    if s[i][1] < s[i-1][1]:\n        ab_count = 0\n        break\n\n    if s[i] == s[i-1]:\n        count += 1\n    else:\n        ab_count *= fact[count]\n        ab_count %= MOD\n        count = 1\n\nab_count *= fact[count]\nab_count %= MOD\n\nprint((fact[n] - a_count - b_count + ab_count) % MOD)\n", "import sys\nimport itertools\ninput = sys.stdin.readline\n\ndef main():\n    n = int(input())\n    s = []\n    A = []\n    B = []\n    for _ in range(n):\n        a, b = list(map(int, input().split()))\n        s.append([a, b])\n        A.append(a)\n        B.append(b)\n\n    A.sort()\n    B.sort()\n    s.sort()\n    ansA = 1\n    ansB = 1\n    anss = 1\n    for key, val in itertools.groupby(A):\n        f = len(list(val))\n        for i in range(1, f+1):\n            ansA *= i\n            ansA %= 998244353\n\n    for key, val in itertools.groupby(B):\n        f = len(list(val))\n        for i in range(1, f+1):\n            ansB *= i\n            ansB %= 998244353\n\n\n    for key, val in itertools.groupby(s):\n        f = len(list(val))\n        for i in range(1, f+1):\n            anss *= i\n            anss %= 998244353\n\n\n    flag = 1\n    for i in range(n-1):\n        if s[i+1][1] < s[i][1] or s[i+1][0] < s[i][0]:\n            flag = 0\n            break\n    if flag == 0:\n        anss = 0\n\n\n    ansn = 1\n    for i in range(1, n+1):\n        ansn *= i\n        ansn %= 998244353\n\n    print((ansn-ansA-ansB+anss)%998244353)\n\ndef __starting_point():\n    main()\n\n__starting_point()", "from sys import stdin\nn=int(stdin.readline().strip())\ns=[list(map(int,stdin.readline().strip().split())) for i in range(n)]\ns1=[s[i][1] for i in range(n)]\ns.sort()\ns1.sort()\nmod=998244353\nx=1\nans=1\nfact=[0 for i in range(n+1)]\nfact[1]=1\nfor i in range(2,n+1):\n    fact[i]=(i*fact[i-1])%mod\nfor i in range(1,n):\n    if s[i][0]==s[i-1][0]:\n        x+=1\n    else:\n        ans=(ans*fact[x])%mod\n        x=1\nans=(ans*fact[x])%mod\nt=True\nfor i in range(1,n):\n    if s[i][1]<s[i-1][1]:\n        t=False\n        break\nx=1\nans1=1\nfor i in range(1,n):\n    if s1[i]==s1[i-1]:\n        x+=1\n    else:\n        ans1=(ans1*fact[x])%mod\n        x=1\nans1=(ans1*fact[x])%mod\nif t:\n    ans2=1\n    x=1\n    for i in range(1,n):\n        if s[i]==s[i-1]:\n            x+=1\n        else:\n            ans2=(ans2*fact[x])%mod\n            x=1\n    ans2=(ans2*fact[x])%mod\n    ans=ans+ans1-ans2\nelse:\n    ans+=ans1\nprint((fact[n]-ans)%mod)\n    \n", "import sys\nmod = 998244353\nfact = [1]\nfor i in range(1, 300001):\n    fact.append((fact[-1]*i)%mod)\n\n\ndata = []\nnum = int(sys.stdin.readline())\n\nl = []\nfor _ in range(num):\n    data.append([int(i) for i in sys.stdin.readline().split()])\n    l.append(data[-1][1])\n\nans = 0\n# f.sort()\n# last = -1\n# tot = 1\n# run = 0\n# for p in f:\n#     if p == last:\n#         run += 1\n#     else:\n#         tot = (tot * fact[run])%mod\n#         run = 1\n#         last = p\n# tot = (tot * fact[run])%mod\n# ans += tot\n\nl.sort()\nlast = -1\ntot = 1\nrun = 0\nfor p in l:\n    if p == last:\n        run += 1\n    else:\n        tot = (tot * fact[run])%mod\n        run = 1\n        last = p\ntot = (tot * fact[run])%mod\nans += tot\n\ndata.sort()\n\n\nf = [i[0] for i in data]\n\nlast = -1\ntot = 1\nrun = 0\nfor p in f:\n    if p == last:\n        run += 1\n    else:\n        tot = (tot * fact[run])%mod\n        run = 1\n        last = p\ntot = (tot * fact[run])%mod\nans += tot\n\n\n\n\n\nsor = True\nfor i in range(num-1):\n    if data[i][1] > data[i+1][1]:\n        sor = False\n        break\n\nif sor:\n    last = [-1, -1]\n    tot = 1\n    run = 0\n    for p in data:\n        if p == last:\n            run += 1\n        else:\n            tot = (tot * fact[run])%mod\n            run = 1\n            last = p\n    tot = (tot * fact[run])%mod\n    # print(tot)\n\n    ans -= tot \nq = fact[num]\nprint((q - ans)%998244353)\n\n\n", "import sys\nmod = 998244353\nfact = [1]\nfor i in range(1, 300001):\n    fact.append((fact[-1]*i)%mod)\n\n\ndata = []\nnum = int(sys.stdin.readline())\n\nl = []\nfor _ in range(num):\n    data.append(tuple([int(i) for i in sys.stdin.readline().split()]))\n    l.append(data[-1][1])\n\nans = 0\n# f.sort()\n# last = -1\n# tot = 1\n# run = 0\n# for p in f:\n#     if p == last:\n#         run += 1\n#     else:\n#         tot = (tot * fact[run])%mod\n#         run = 1\n#         last = p\n# tot = (tot * fact[run])%mod\n# ans += tot\n\nl.sort()\nlast = -1\ntot = 1\nrun = 0\nfor p in l:\n    if p == last:\n        run += 1\n    else:\n        tot = (tot * fact[run])%mod\n        run = 1\n        last = p\ntot = (tot * fact[run])%mod\nans += tot\n\ndata.sort()\n\n\nf = [i[0] for i in data]\n\nlast = -1\ntot = 1\nrun = 0\nfor p in f:\n    if p == last:\n        run += 1\n    else:\n        tot = (tot * fact[run])%mod\n        run = 1\n        last = p\ntot = (tot * fact[run])%mod\nans += tot\n\n\n\n\n\nsor = True\nfor i in range(num-1):\n    if data[i][1] > data[i+1][1]:\n        sor = False\n        break\n\nif sor:\n    last = (-1, -1)\n    tot = 1\n    run = 0\n    for p in data:\n        if p == last:\n            run += 1\n        else:\n            tot = (tot * fact[run])%mod\n            run = 1\n            last = p\n    tot = (tot * fact[run])%mod\n    # print(tot)\n\n    ans -= tot \nq = fact[num]\nprint((q - ans)%998244353)\n\n\n", "import sys\nmod = 998244353\nfact = [1]\nfor i in range(1, 300001):\n    fact.append((fact[-1]*i)%mod)\n\n\ndata = []\nnum = int(sys.stdin.readline())\n\nl = []\nfor _ in range(num):\n    temp = [int(i) for i in sys.stdin.readline().split()]\n    data.append((temp[0]<<20) + temp[1])\n    l.append(temp[1])\n\nans = 0\n# f.sort()\n# last = -1\n# tot = 1\n# run = 0\n# for p in f:\n#     if p == last:\n#         run += 1\n#     else:\n#         tot = (tot * fact[run])%mod\n#         run = 1\n#         last = p\n# tot = (tot * fact[run])%mod\n# ans += tot\n\nl.sort()\nlast = -1\ntot = 1\nrun = 0\nfor p in l:\n    if p == last:\n        run += 1\n    else:\n        tot = (tot * fact[run])%mod\n        run = 1\n        last = p\ntot = (tot * fact[run])%mod\nans += tot\n\ndata.sort()\n\n\nf = [i>>20 for i in data]\n\nlast = -1\ntot = 1\nrun = 0\nfor p in f:\n    if p == last:\n        run += 1\n    else:\n        tot = (tot * fact[run])%mod\n        run = 1\n        last = p\ntot = (tot * fact[run])%mod\nans += tot\n\n# print(ans, 999)\n\npow2m1 = (1<<20) - 1\n\nsor = True\nfor i in range(num-1):\n    # print(data[i] & pow2m1 , data[i+1] & pow2m1)\n    if data[i] & pow2m1 > data[i+1] & pow2m1:#fix-----------\n        sor = False\n        break\n\n# print(data)\n# print(sor)\nif sor:\n    last = -1\n    tot = 1\n    run = 0\n    for p in data:\n        if p == last:\n            run += 1\n        else:\n            tot = (tot * fact[run])%mod\n            run = 1\n            last = p\n    tot = (tot * fact[run])%mod\n    # print(tot)\n\n    ans -= tot \nq = fact[num]\nprint((q - ans)%998244353)\n\n\n", "import collections\n\nn=int(input())\narr_ab=[]\narr_a=[]\narr_b=[]\nfor _ in range(n):\n  a,b=map(int,input().split())\n  arr_a.append(a)\n  arr_b.append(b)\n  arr_ab.append((a,b))\nmod=998244353\ntmp=1\nfacts=[1]\nfor val in range(1,n+1):\n  tmp*=val\n  tmp%=mod\n  facts.append(tmp)\nalls=facts[n]\ntmp=1\nfor value in collections.Counter(arr_a).values():\n  tmp*=facts[value]\n  tmp%=mod\nbads_a=tmp\ntmp=1\nfor value in collections.Counter(arr_b).values():\n  tmp*=facts[value]\n  tmp%=mod\nbads_b=tmp\narr_ab=sorted(arr_ab)\nflag=True\nfor i in range(n-1):\n  if arr_ab[i][1]<=arr_ab[i+1][1]:\n    continue\n  else:\n    flag=False\n    break\nif flag==False:\n  print((alls-(bads_a+bads_b)+mod)%mod)\nelse:\n  tmp=1\n  for val in collections.Counter(arr_ab).values():\n    tmp*=facts[val]\n    tmp%=mod\n  bads_ab=tmp\n  print((alls-(bads_a+bads_b-bads_ab)+mod)%mod)", "import collections\n\nn=int(input())\narr_ab=[]\narr_a=[]\narr_b=[]\nfor _ in range(n):\n  a,b=map(int,input().split())\n  arr_a.append(a)\n  arr_b.append(b)\n  arr_ab.append((a,b))\nmod=998244353\ntmp=1\nfacts=[1]\nfor val in range(1,n+1):\n  tmp*=val\n  tmp%=mod\n  facts.append(tmp)\nalls=facts[n]\ntmp=1\nfor value in collections.Counter(arr_a).values():\n  tmp*=facts[value]\n  tmp%=mod\nbads_a=tmp\ntmp=1\nfor value in collections.Counter(arr_b).values():\n  tmp*=facts[value]\n  tmp%=mod\nbads_b=tmp\narr_ab=sorted(arr_ab)\nflag=True\nfor i in range(n-1):\n  if arr_ab[i][1]<=arr_ab[i+1][1]:\n    continue\n  else:\n    flag=False\n    break\nif flag==False:\n  print((alls-(bads_a+bads_b))%mod)\nelse:\n  tmp=1\n  for val in collections.Counter(arr_ab).values():\n    tmp*=facts[val]\n    tmp%=mod\n  bads_ab=tmp\n  print((alls-(bads_a+bads_b-bads_ab))%mod)", "from collections import defaultdict\nimport math\n\n\nMOD = 998244353\n\n\ndef facmod(n):\n    fac = 1\n    for i in range(2, n + 1):\n        fac *= i\n        fac %= MOD\n    return fac\n\n\ndef main():\n    n = int(input())\n    s = [tuple(int(s) for s in input().split()) for _ in range(n)]\n    \n    count = defaultdict(int)\n\n    for a, _ in s:\n        count[a] += 1\n\n    first = 1\n    for c in list(count.values()):\n        first *= facmod(c)\n        first %= MOD\n\n    count = defaultdict(int)\n\n    for _, b in s:\n        count[b] += 1\n\n    second = 1\n    for c in list(count.values()):\n        second *= facmod(c)\n        second %= MOD\n\n    count = defaultdict(int)\n    \n    for t in s:\n        count[t] += 1\n    \n    both = 1\n    for c in list(count.values()):\n        both *= facmod(c)\n        both %= MOD\n\n    s.sort()\n\n    for i, (_, b) in enumerate(s[:-1]):\n        if b > s[i + 1][1]:\n            both = 0\n            break\n    \n    print((facmod(n) - (first + second - both)) % MOD)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()"]