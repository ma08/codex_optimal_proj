["import numpy as np\n\nN, *AB = list(map(int, open(0).read().split()))\nmin_med = np.median([a for a in AB[::2]])\nmax_med = np.median([b for b in AB[1::2]])\nif N % 2:\n    print((int(max_med - min_med) + 1))\nelse:\n    print((int(max_med * 2 - min_med * 2) + 1))\n", "N=int(input())\nA=[]\nB=[]\nfor i in range(N):\n  a,b=map(int,input().split())\n  A.append(a)\n  B.append(b)\nA.sort()\nB.sort()\n\nif N%2==1:\n  Amed=A[N//2]\n  Bmed=B[N//2]\n  print(Bmed-Amed+1)\nelse:\n  Amed=(A[N//2]+A[N//2-1])/2\n  Bmed=(B[N//2]+B[N//2-1])/2\n  print(round((Bmed-Amed)*2+1))", "# -*- coding:utf-8 -*-\n\ndef solve():\n    N = int(input())\n    Ls, Rs = [], []\n    for i in range(N):\n        a, b = list(map(int, input().split()))\n        Ls.append(a), Rs.append(b)\n    Ls.sort(), Rs.sort()\n\n    ans = 0\n    if N%2 == 1:\n        # N\u304c\u5947\u6570\u306a\u3089\n        l = Ls[N//2]\n        r = Rs[N//2]\n        ans = r-l+1\n    else:\n        # N\u304c\u5076\u6570\u306a\u3089\n        l2 = Ls[N//2-1]+Ls[N//2]\n        r2 = Rs[N//2-1]+Rs[N//2]\n        ans = r2-l2+1\n\n    print(ans)\n\n\ndef __starting_point():\n    solve()\n\n__starting_point()", "n = int(input())\narr_a = []\narr_b = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    arr_a.append(a)\n    arr_b.append(b)\narr_a.sort()\narr_b.sort()\nif n % 2 == 1:\n    print(arr_b[n//2] - arr_a[n//2] + 1)\nelse:\n    median_a = (arr_a[int(n/2 -1)] + arr_a[int(n/2)])\n    median_b = (arr_b[int(n/2 -1)] + arr_b[int(n/2)])\n    print(median_b - median_a + 1)", "n=int(input())\na,b=[],[]\nfor i in range(n):\n    c,d=map(int,input().split())\n    a.append(c)\n    b.append(d)\na.sort()\nb.sort(reverse=True)\nif n%2==1:\n    ac=a[(n+1)//2-1]\n    bc=b[(n+1)//2-1]\n    ans=bc-ac\nelse:\n    ac=(a[n//2-1]+a[n//2])\n    bc=(b[n//2-1]+b[n//2])\n    ans=bc-ac\nprint(ans+1)", "n = int(input())\nl = []\nr = []\nfor _ in range(n):\n  a, b = list(map(int, input().split()))\n  l.append(a)\n  r.append(b)\nl.sort()\nr.sort()\nif n % 2 == 1:\n  l_mid = l[n // 2]\n  r_mid = r[n // 2]\n  print((r_mid - l_mid + 1))\nelse:\n  l_mid = (l[n // 2] + l[n // 2 - 1]) / 2\n  r_mid = (r[n // 2] + r[n // 2 - 1]) / 2\n  print((int((r_mid - l_mid) * 2) + 1))\n", "import collections\nN = int(input())\nA = [0] * N\nB = [0] * N\nfor i in range(N):\n    a, b = map(int, input().split())\n    A[i] = a\n    B[i] = b\nA.sort()\nB.sort()\nN_q, N_mod = divmod(N, 2)\nif N_mod == 1:\n    ans = B[N_q] - A[N_q] + 1\nelse:\n    ans = B[N_q - 1] - A[N_q - 1] + B[N_q] - A[N_q] + 1\nprint(ans)", "from statistics import median\n\nN = int(input())\nA = [0] * N\nB = [0] * N\nfor c in range(N):\n    A[c], B[c] = list(map(int, input().split()))\n\nA_med = median(A)\nB_med = median(B)\n\nif N % 2 == 0:\n    print((round(2 * (B_med - A_med) + 1)))\nelse:\n    print((B_med - A_med + 1))\n", "#!/usr/bin/env python3\nimport sys\nfrom itertools import chain\nimport numpy as np\n\n# from itertools import combinations as comb\n# form bisect import bisect_left, bisect_right, insort_left, insort_right\n# from collections import Counter\n\n\ndef solve(N: int, A: \"List[int]\", B: \"List[int]\"):\n    A = sorted(A)\n    B = sorted(B)\n    if N % 2 == 1:\n        l = A[N // 2]\n        r = B[N // 2]\n        return r - l + 1\n    else:\n        l2 = A[N // 2 - 1] + A[N // 2]\n        r2 = B[N // 2 - 1] + B[N // 2]\n        return r2 - l2 + 1\n\n\ndef main():\n    tokens = chain(*(line.split() for line in sys.stdin))\n    # N, A, B = map(int, line.split())\n    N = int(next(tokens))  # type: int\n    AB = np.array(list(map(int, tokens)), dtype=np.int32)\n    A = AB[0::2]\n    B = AB[1::2]\n    answer = solve(N, A, B)\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import statistics\nN = int(input())\nAB = [map(int, input().split()) for _ in range(N)]\nA,B = [list(i) for i in zip(*AB)]\nif N%2 == 1:\n    low_med = statistics.median(A)\n    high_med = statistics.median(B)\n    print(high_med - low_med +1)\nelse:\n    low_med = statistics.median(A)\n    high_med = statistics.median(B)\n    print(int(2 * (high_med - low_med) +1))", "N = int(input())\nAB = [list(map(int, input().split())) for _ in range(N)]\nA, B = map(list, zip(*AB))\n\nA.sort()\nB.sort()\n\ndef median(a):\n    n = N\n    return a[(n+1)//2-1] if n%2 else (a[n//2-1]+a[n//2])/2\n\nA_mid = median(A)\nB_mid = median(B)\n\nr = int((B_mid-A_mid) * [2, 1][N%2]) + 1\n\nprint(r)", "ni = lambda: int(input())\nnm = lambda: list(map(int, input().split()))\nnl = lambda: list(map(int, input().split()))\n\nn=ni()\nmins=[]\nmaxs=[]\nfor i in range(n):\n  a,b=nm()\n  mins.append(a)\n  maxs.append(b)\n\nsmn = sorted(mins)\nsmx = sorted(maxs)\n\nif n%2==1:\n  mn = smn[(n+1)//2-1]\n  mx = smx[(n+1)//2-1]\n  print((round((mx-mn)+1)))\nelse:\n  mn = (smn[n//2-1]+smn[n//2])/2.0\n  mx = (smx[n//2-1]+smx[n//2])/2.0\n  print((round((mx-mn)*2+1)))\n", "n = int(input())\na = []\nb = []\nfor i in range(n):\n    s,t = map(int,input().split())\n    a.append(s)\n    b.append(t)\na.sort()\nb.sort()\nif n%2 == 0:\n    am = (a[n//2-1]+a[n//2])/2\n    bm = (b[n//2-1]+b[n//2])/2\n    print(int((bm-am)*2+1))\nelse:\n    am = a[(n-1)//2]\n    bm = b[(n-1)//2]\n    print(bm-am+1)", "import sys\ninput = sys.stdin.readline\nN = int(input())\nAB = [tuple(map(int,input().split())) for i in range(N)]\nA = []\nB = []\nfor a,b in AB:\n    A.append(a)\n    B.append(b)\nA.sort()\nB.sort()\n\nif N%2==0:\n    m = N//2\n    b = B[m] + B[m-1]\n    a = A[m] + A[m-1]\n    print(b - a + 1)\nelse:\n    m = N//2\n    print(B[m] - A[m] + 1)", "from statistics import median\n \nX = []\nX1 = []\nN=int(input())\nfor i in range(N):\n    a, b = map(int, input().split())\n    X.append(a)\n    X1.append(b)\n \nm1 = median(X)\nm2 = median(X1)\nif len(X) % 2:\n    print(int((m2 - m1) + 1))\nelse:\n    print(int(2 * (m2 - m1) + 1))", "import sys\n\nimport bisect\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    N = int(input())\n    A = []\n    B = []\n    for i in range(N):\n        a, b = list(map(int, input().split()))\n        A.append(a)\n        B.append(b)\n    pass\n    A.sort()\n    B.sort()\n    if N % 2 == 0:\n        n = N // 2\n        mini = (A[n]+A[n-1]) /2\n        maxi = (B[n]+B[n-1]) /2\n        print((int((maxi-mini)*2)+1))\n    else:\n        n = N//2\n        mini = A[n]\n        maxi = B[n]\n        print((maxi-mini+1))\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "#!/usr/bin/env python3\n# encoding:utf-8\nimport copy\nimport random\nimport bisect #bisect_left\u3000\u3053\u308c\u3067\u4e8c\u90e8\u63a2\u7d22\u306e\u5927\u5c0f\u691c\u7d22\u304c\u884c\u3048\u308b\nimport fractions #\u6700\u5c0f\u516c\u500d\u6570\u306a\u3069\u306f\u3053\u3063\u3061\nimport math\nimport sys\nimport collections\n\nmod = 10**9+7\nsys.setrecursionlimit(mod) # \u518d\u5e30\u56de\u6570\u4e0a\u9650\u306f\u3067default1000\n\nd = collections.deque()\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\nN = int(input())\nA = [0 for i in range(N)]\nB = [0 for i in range(N)]\nfor i in range(N):\n    a,b = LI()\n    A[i] = a\n    B[i] = b\n\nA.sort()\nB.sort()\n\nif N % 2 == 1:\n    min_mid = A[(N - 1) // 2]\nelse:\n    min_mid = (A[N //2 - 1] + A[N//2]) / 2\n\nif N % 2 == 1:\n    max_mid = B[(N - 1) // 2]\nelse:\n    max_mid = (B[N //2 - 1] + B[N//2]) / 2 \n\nif N % 2 == 0:\n    print((int((max_mid - min_mid) / 0.5 + 1)))\nelse:\n    print((math.ceil(max_mid) - math.floor(min_mid) + 1))\n\n\n", "N, *AB = list(map(int, open(0).read().split()))\nA = sorted(a for a in AB[::2])\nB = sorted(b for b in AB[1::2])\nif N % 2:\n    print((B[N // 2] - A[N // 2] + 1))\nelse:\n    print((B[N // 2 - 1] + B[N // 2] - A[N // 2 - 1] - A[N // 2] + 1))\n", "def main(N, lines):\n    a = sorted([line[0] for line in lines])\n    b = sorted([line[1] for line in lines])\n\n    if N % 2 == 1:\n        mi = a[N // 2]\n        ma = b[N // 2]\n        print((int(ma - mi + 1)))\n    else:\n        mi = (a[N // 2 - 1] + a[N // 2])\n        ma = (b[N // 2 - 1] + b[N // 2])\n        print((int(ma - mi + 1)))\n\n\nN = int(input())\nlines = []\nfor i in range(N):\n    lines.append(list(map(int, input().split())))\nmain(N, lines)\n", "def main():\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n    A = []\n    B = []\n    for _ in range(N):\n        a, b = list(map(int, input().split()))\n        A.append(a)\n        B.append(b)\n    A.sort()\n    B.sort()\n\n    if N & 1:\n        j = (N - 1) // 2\n        ans = B[j] - A[j] + 1\n        print(ans)\n        return\n\n    j = N // 2 - 1\n    k = N // 2\n    ans = (B[j] + B[k]) - (A[j] + A[k]) + 1\n    print(ans)\n    return\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\nt = N // 2\na_list = []\nb_list = []\nfor i in range(N):\n    ab = list(map(int, input().split()))\n    a_list.append(ab[0])\n    b_list.append(ab[1])\n\na_list = sorted(a_list)\nb_list = sorted(b_list)\n\nif N%2 == 1:\n    a_median = a_list[t]\n    b_median = b_list[t]\n    print(b_median-a_median+1)\nelif N%2 == 0:\n    a_median = (a_list[t-1]+a_list[t])/2\n    b_median = (b_list[t-1]+b_list[t])/2\n    print(int(2*(b_median-a_median)+1))", "#!/usr/bin/env python3\nimport sys\nfrom itertools import chain\nimport numpy as np\n\n# from itertools import combinations as comb\n# form bisect import bisect_left, bisect_right, insort_left, insort_right\n# from collections import Counter\n\n\ndef solve(N: int, A: \"List[int]\", B: \"List[int]\"):\n    A = np.sort(A)\n    B = np.sort(B)\n    if N % 2 == 1:\n        l = A[N // 2]\n        r = B[N // 2]\n        return r - l + 1\n    else:\n        l2 = A[N // 2 - 1] + A[N // 2]\n        r2 = B[N // 2 - 1] + B[N // 2]\n        return r2 - l2 + 1\n\n\ndef main():\n    tokens = chain(*(line.split() for line in sys.stdin))\n    # N, A, B = map(int, line.split())\n    N = int(next(tokens))  # type: int\n    AB = np.array(list(map(int, tokens)), dtype=np.int32)\n    A = AB[0::2]\n    B = AB[1::2]\n    answer = solve(N, A, B)\n    print(answer)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\ns,t=[],[]\nfor i in range(n):\n    a,b=map(int,input().split())\n    s.append(a)\n    t.append(b)\ns=sorted(s)\nt=sorted(t)\nif n%2==0:\n    print(t[n//2-1]+t[n//2]-s[n//2-1]-s[n//2]+1)\nelse:\n    print(t[n//2]-s[n//2]+1)", "def main():\n    n = int(input())\n    a = [None]*n\n    b = [None]*n\n    for i in range(n):\n        a[i], b[i] = map(int, input().split())\n    a.sort()\n    b.sort()\n    if n&1:\n        print(b[n//2]-a[n//2]+1)\n    else:\n        print(b[n//2-1]+b[n//2]-a[n//2-1]-a[n//2]+1)\n        \n\ndef __starting_point():\n    main()\n__starting_point()", "N=int(input())\nA,B=[],[]\nfor i in range(N):\n  a,b=map(int,input().split())\n  A.append(a)\n  B.append(b)\n  \nA,B=map(sorted,(A,B))\n\nif N % 2 == 1:\n  mA, mB = A[N//2],B[N//2]\n  print(mB-mA+1)\nelse:\n  mA, mB = (A[N//2-1]+A[N//2])/2,(B[N//2-1]+B[N//2])/2\n  print(int((mB-mA)/0.5+0.5)+1)", "from numpy import*\nt=loadtxt(open(0),skiprows=1)\na,b=median(t,0)\nprint(int((b-a)*(2-len(t)%2))+1)", "# -*- coding: utf-8 -*-\n\nN = int(input().strip())\nAB_list = [list(map(int, input().rstrip().split())) for i in range(N)]\n#-----\n\nA_list,B_list = list(map(list, list(zip(*AB_list))))\n\nA_list.sort()\nB_list.sort()\n\n\nif N%2 == 0:\n    Med_A = A_list[ (N-1)//2 ] + A_list[ (N-1)//2 + 1 ]\n    Med_B = B_list[ (N-1)//2 ] + B_list[ (N-1)//2 + 1 ]\n    \nelse:\n    Med_A = A_list[ (N-1)//2 ]\n    Med_B = B_list[ (N-1)//2 ]\n\n\nMed_range = Med_B - Med_A + 1\nprint(Med_range)\n", "import statistics\nn=int(input())\n \nla, lb = [], []\nfor _ in range(n):\n  a, b = map(int, input().split())\n  la.append(a)\n  lb.append(b)\nc=statistics.median(la)\nd=statistics.median(lb)\nif n%2==1:\n  print(d-c+1)\nelse:\n  print(int(2*d-2*c+1))", "n = int(input())\nl = []\nr = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    l.append(a)\n    r.append(b)\nl.sort()\nr.sort()\nif n % 2 == 1:\n    l_mid = l[n // 2]\n    r_mid = r[n // 2]\n    print(r_mid - l_mid + 1)\nelse:\n    l_mid = (l[n // 2] + l[n // 2 - 1]) / 2\n    r_mid = (r[n // 2] + r[n // 2 - 1]) / 2\n    print(int(r_mid * 2 - l_mid * 2) + 1)", "import statistics\nN = int(input())\nA = [0] * N\nB = [0] * N\nfor i in range(N):\n    A[i], B[i] = map(int, input().split())\nA.sort()\nB.sort()\nif N%2==1:\n  print(statistics.median(B)-statistics.median(A)+1)\nelse:\n  print(int(statistics.median(B)*2-statistics.median(A)*2+1))", "import statistics\nN= int(input())\nmin_all=[]\nmax_all = []\nfor _ in range(N):\n    a,b=list(map(int,input().split()))\n    min_all.append(a)\n    max_all.append(b)\nmin_median = statistics.median(min_all)\nmax_median = statistics.median(max_all)\nif N%2:\n    ans = max_median - min_median+1\nelse:\n    ans = int((max_median - min_median +0.5)*2)\nprint(ans)\n", "N = int(input())\nA = [0 for _ in range(N)]\nB = [0 for _ in range(N)]\nimport statistics\nfor k in range(N):\n  A[k], B[k] = map(int, input().split())\n\nif N%2 == 1:\n  print(statistics.median(B) - statistics.median(A) +1)\nelse:\n  print(int((statistics.median(B) - statistics.median(A))*2 +1))", "import numpy as np\n\nN = int(input())\nA = []\nB = []\n\nfor i in range(N):\n    a, b = [int(x) for x in input().split()]\n    A.append(a)\n    B.append(b)\n\nC = np.array(A)\nD = np.array(B)\n\nm_inf = np.median(C)\nm_sup = np.median(D)\n\nif N % 2 == 0:\n    ans = 2 * m_sup - 2 * m_inf + 1\nelse:\n    ans = m_sup - m_inf + 1\n\nprint(int(ans))", "def solve(n, a, b):\n    l = (n+1)//2 - 1\n    r = l + 1 + (n%2==0)\n    lb = sum(sorted(a)[l:r])\n    ub = sum(sorted(b)[l:r])\n    return (ub - lb) + 1\n\nn = int(input())\na = [0] * n\nb = [0] * n\nfor i in range(n):\n    a[i], b[i] = map(int, input().split())\nprint(solve(n, a, b))", "N = int(input())\nt = N//2\nla, lb = [], []\nfor _ in range(N):\n    A, B = list(map(int, input().split()))\n    la.append(A)\n    lb.append(B)\nla.sort()\nlb.sort()\nprint((lb[t]-la[t]+1 if N%2 else lb[t-1]-la[t]+lb[t]-la[t-1]+1))\n", "import statistics\nn=int(input())\nla, lb = [], []\nfor _ in range(n):\n  a, b =list(map(int, input().split()))\n  la.append(a)\n  lb.append(b)\nc=statistics.median(la)\nd=statistics.median(lb)\nif n%2==1:\n  print((d-c+1))\nelse:\n  print((int(2*d-2*c+1)))\n\n\n\n\n\n\n\n", "N = int(input())\n\nAB = []\n\nfor _ in range(N):\n    AB.append(list(map(int, input().split())))\n\nA_idx = [(AB[i][0], i) for i in range(N)]\nB_idx = [(AB[i][1], i) for i in range(N)]\n\nA_idx.sort(key=lambda e:e[0])\nB_idx.sort(key=lambda e:e[0])\n\nif N % 2 == 1:\n    diff = B_idx[N//2][0]-A_idx[N//2][0]\n    print(diff+1)\nelse:\n    l = N//2-1\n    u = N//2\n    diff = (B_idx[l][0]+B_idx[u][0])-(A_idx[l][0]+A_idx[u][0])\n    print(diff+1)", "import statistics\n\nN = int(input())\nA = []\nB = []\nfor i in range(N):\n    a, b = list(map(int, input().split()))\n    A.append(a)\n    B.append(b)\nAm = statistics.median(A)\nBm = statistics.median(B)\n\nif N % 2 == 0:\n    print(round(2 * (Bm - Am) + 1))\nelse:\n    print(Bm - Am + 1)", "from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef MAP1()  : return map(lambda x:int(x)-1,input().split())\ndef LIST()  : return list(MAP())\ndef LIST1() : return list(MAP1())\n\ndef solve():\n    N = INT()\n    a = []\n    b = []\n    for i in range(N):\n        A, B = MAP()\n        a.append(A)\n        b.append(B)\n    a.sort()\n    b.sort()\n\n    if N % 2 == 1:\n        am = a[(N+1)//2-1]\n        bm = b[(N+1)//2-1]\n        ans = bm - am + 1\n    else:\n        am = ( a[N//2-1]+a[N//2] ) / 2\n        bm = ( b[N//2-1]+b[N//2] ) / 2\n        ans = int( ( bm - am ) * 2 + 1 )\n    print(ans)\n\ndef __starting_point():\n    solve()\n__starting_point()", "import sys\nfrom collections import deque, defaultdict, Counter\nfrom itertools import accumulate, product, permutations, combinations\nfrom operator import itemgetter\nfrom bisect import bisect_left, bisect_right\nfrom heapq import heappop, heappush\nfrom math import ceil, floor, sqrt, gcd, inf\nfrom copy import deepcopy\nimport numpy as np\nimport scipy as sp\n\nINF = inf\nMOD = 1000000007\n\nn = int(input())\nA = [[int(i) for i in input().split()]for j in range(n)]    # n\u306f\u884c\u6570\n\ntmp = 0\nres = 0\n\nx = np.median(np.array(A), axis=0)\nif n % 2 == 0:\n    res = int((x[1] - x[0]) * 2 + 1)\nelse:\n    res = int(x[1] - x[0] + 1)\n\nprint(res)\n", "N = int(input())\n\nA = []\nB = []\nfor i in range(N):\n  a, b = list(map(int, input().split()))\n  A.append(a)\n  B.append(b)\nA.sort()\nB.sort()\n\nif N%2:\n  ma = A[N//2]\n  mb = B[N//2]\n  print((max(0, mb-ma+1)))\nelse:\n  ma = A[N//2] + A[N//2-1]\n  mb = B[N//2] + B[N//2-1]\n  print((max(0, mb-ma+1)))\n", "N=int(input())\nA=[]\nB=[]\nfor i in range(N):\n  a,b=map(int,input().split())\n  A.append(a)\n  B.append(b)\nA.sort()\nB.sort()\ndef median(x):\n  l=len(x)\n  if l%2==0:\n    return (x[l//2-1]+x[l//2])/2\n  else:\n    return x[l//2]\nif N%2==1:\n  print(median(B)-median(A)+1)\nelse:\n  print(int((median(B)-median(A))*2+1))", "a = []\nb = []\nn = int(input())\nfor _ in range(n):\n    x, y = map(int, input().split())\n    a.append(x)\n    b.append(y)\na.sort()\nb.sort()\nif n % 2 == 1:\n    print(b[(n-1)//2] - a[(n-1)//2]+1)\n    return\nprint(b[n//2] + b[n//2-1] - a[n//2] - a[n//2-1] + 1)", "N = int(input())\n\nA,B = [], []\nfor i in range(N):\n    a,b = list(map(int, input().split()))\n    A.append(a)\n    B.append(b)\n\nA.sort()\nB.sort()\n\ncnt = 0\nif(N % 2 == 1):\n    l = A[N//2]\n    r = B[N//2]\n    cnt = r - l + 1\nelse:\n    l = A[N//2-1] + A[N//2]\n    r = B[N//2-1] + B[N//2]\n    cnt = r - l + 1\nprint(cnt)\n", "import statistics\nimport math\n\nN = int(input())\n\nmin_x = []\nmax_x = []\n\nfor i in range(N):\n    A, B = list(map(int, input().split()))\n    min_x.append(A)\n    max_x.append(B)\n\nmin_x.sort()\nmax_x.sort()\n\nresult = []\n\nif len(min_x) % 2 == 0:\n    min_median = (min_x[len(min_x)//2-1] + min_x[len(min_x)//2])\n    max_median = (max_x[len(min_x)//2-1] + max_x[len(min_x)//2])\n    print((len(list(range(math.floor(min_median), math.ceil(max_median) + 1)))))\n\nelse:\n    min_median = min_x[len(min_x)//2]\n    max_median = max_x[len(min_x)//2]\n    print((max_median - min_median + 1))\n", "N=int(input())\nA=[0]*N\nB=[0]*N\nfor i in range(N):\n    A[i], B[i]=map(int, input().split())\n    \nA.sort()\nB.sort()\n\nif N%2==1:\n    print(B[N//2]-A[N//2]+1)\nelse:\n    print(B[N//2]+B[N//2-1]-A[N//2]-A[N//2-1]+1)", "def main():\n    n = int(input())\n    A,B = [],[]\n    for _ in range(n):\n        a,b = list(map(int,input().split()))\n        A.append(a)\n        B.append(b)\n    A,B = sorted(A),sorted(B)\n    if n%2==0:\n        a_m,b_m = (A[n//2]+A[n//2-1]),(B[n//2]+B[n//2-1])\n        print((b_m-a_m+1))\n    else:\n        a_m,b_m = A[n//2],B[n//2]\n        print((b_m-a_m+1))\n\ndef __starting_point():\n    main()\n\n__starting_point()", "N = int(input())\n\nA = []\nB = []\nfor i in range(N):\n  a, b = map(int, input().split())\n  A.append(a)\n  B.append(b)\nA.sort()\nB.sort()\n\nif N%2:\n  ma = A[N//2]\n  mb = B[N//2]\n  print(max(0, mb-ma+1))\nelse:\n  ma = A[N//2] + A[N//2-1]\n  mb = B[N//2] + B[N//2-1]\n  print(max(0, mb-ma+1))", "N = int(input())\nA = [0]*N\nB = [0]*N\n\nfor i in range(N):\n    A[i], B[i] = map(int, input().split())\n\nA = sorted(A)\nB = sorted(B)\n\nif N % 2 == 1:\n    print(B[(N+1)//2-1] - A[(N+1)//2-1] + 1)\nelse:\n    b = B[N//2-1] + B[N//2]\n    a = A[N//2-1] + A[N//2]\n    print(b-a+1)", "N = int(input())\nA = []; B = []\nfor i in range(N):\n  a,b = map(int,input().split())\n  A.append(a);B.append(b)\n\nA.sort();B.sort()\nif N%2 == 0:\n  MIN = A[N//2-1]+A[N//2] #Median\u306e\u4e8c\u500d\n  MAX = B[N//2-1]+B[N//2]\n  ans = MAX-MIN+1\nelse:\n  MIN = A[N//2] #Median\u306e\u4e8c\u500d\n  MAX = B[N//2]\n  ans = MAX-MIN+1\nprint(ans)", "N = int(input())\nA = []\nB = []\nfor i in range(N):\n    a, b = map(int, input().split())\n    A.append(a)\n    B.append(b)\nA.sort()\nB.sort()\nif N % 2 == 0:\n    n = N // 2\n    print(B[n] + B[n - 1] - A[n] - A[n - 1] + 1)\nelse:\n    n = N // 2\n    print((B[n] - A[n] + 1))", "from numpy import*\na,b=median(t:=loadtxt(open(0),skiprows=1),0)\nprint(int((a-b)*~(~len(t)%2))+1)", "def main():\n    n = int(input())\n    al = []\n    bl = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        al.append(a)\n        bl.append(b)\n    al.sort()\n    bl.sort()\n    if n%2:\n        print(bl[n//2]-al[n//2]+1)\n    else:\n        print(bl[n//2]+bl[n//2-1]-al[n//2]-al[n//2-1]+1)\n \ndef __starting_point():\n    main()\n__starting_point()", "def main():\n    n = int(input())\n    a = [None]*n\n    b = [None]*n\n    for i in range(n):\n        a[i],b[i] = map(int, input().split())\n    a.sort()\n    b.sort()    \n    if n&1:\n        print(b[n//2]-a[n//2]+1)\n    else:\n        print(b[n//2-1]+b[n//2]-a[n//2]+1-a[n//2-1])\n            \ndef __starting_point():\n    main()\n__starting_point()", "N = int(input())\nA = [list(map(int, input().split())) for i in range(N)]\n\n# N = 3\n# A = [[1, 3], [2, 5], [1, 7]]\n\nif N % 2 == 1:\n    minA = sorted([row[0] for row in A])\n    maxA = sorted([row[1] for row in A])\n    medA = minA[int(N/2)]\n    medB = maxA[int(N/2)]\n    print(medB-medA+1)\nelse:\n    minA = sorted([row[0] for row in A])\n    maxA = sorted([row[1] for row in A])\n    medA = (minA[int(N/2-1)]+minA[int(N/2)])/2\n    medB = (maxA[int(N/2-1)]+maxA[int(N/2)])/2\n    print(int((medB-medA)*2+1))", "N = int(input())\nAB = [[int(_) for _ in input().split()] for _ in range(N)]\nA = sorted([a for a, b in AB])\nB = sorted([b for a, b in AB])\n\nans = B[N // 2] + B[(N - 1) // 2] - (A[N // 2] + A[(N - 1) // 2])\nif N % 2:\n    ans //= 2\nans += 1\nprint(ans)\n", "n=int(input())\na=[0]*n\nb=[0]*n\nfor i in range(n):\n  a[i],b[i] = map(int,input().split())\na.sort(reverse=True)\nb.sort()\nif n%2:\n  a_med = a[n//2]\n  b_med = b[n//2]\n  print(b_med - a_med + 1)\nelse:\n  a_med = (a[n//2-1] + a[n//2])/2\n  b_med = (b[n//2-1] + b[n//2])/2\n  print(int((b_med - a_med)*2)+1)", "from operator import itemgetter\n\nn = int(input())\nAB = [list(map(int, input().split())) for _ in range(n)]\n\nsortA = sorted(AB, key=itemgetter(0))\nsortB = sorted(AB, key=itemgetter(1))\n\nif n%2==1:\n    print(sortB[n//2][1] - sortA[-n//2][0] + 1)\n\nelse:\n    print(int(((sortB[n//2][1]+sortB[n//2-1][1])/2 - (sortA[n//2][0]+sortA[n//2-1][0])/2) / (1/2) + 1))", "import sys\n\nsys.setrecursionlimit(10 ** 8)\nini = lambda: int(sys.stdin.readline())\ninm = lambda: map(int, sys.stdin.readline().split())\ninl = lambda: list(inm())\nins = lambda: sys.stdin.readline().rstrip()\ndebug = lambda *a, **kw: print(\"\\033[33m\", *a, \"\\033[0m\", **dict(file=sys.stderr, **kw))\n\nN = ini()\nA, B = [], []\nfor i in range(N):\n    a, b = inm()\n    A.append(a)\n    B.append(b)\n\n\ndef solve():\n    sa = sorted(A)\n    sb = sorted(B)\n    if N % 2 == 1:\n        return sb[N // 2] - sa[N // 2] + 1\n    else:\n        return (sb[N // 2] + sb[N // 2 - 1]) - (sa[N // 2] + sa[N // 2 - 1]) + 1\n\n\nprint(solve())\n", "#float\u578b\u3092\u8a31\u3059\u306a\n#numpy\u306fpython\u3067\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return map(int, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print('\\n'.join(x))\ndef printni(x): print('\\n'.join(list(map(str,x))))\ninf = 10**17\nmod = 10**9 + 7\n\nn=I()\nlis1=[]\nlis2=[]\nfor i in range(n):\n    a,b=MI()\n    lis1.append(a)\n    lis2.append(b)\nlis1.sort()\nlis2.sort()\nif n%2==1:\n    med1=lis1[n//2]\n    med2=lis2[n//2]\n    print(med2-med1+1)\nif n%2==0:\n    med1=lis1[n//2-1]+lis1[n//2]\n    med2=lis2[n//2-1]+lis2[n//2]\n    print(med2-med1+1)", "n=int(input())\nimport bisect as bi\nA=[] ; B=[]\nfor i in range(n):\n    a,b=list(map(int,input().split()))\n    A.append(a)\n    B.append(b)\n\nA.sort() ; B.sort()\nif n%2==1:\n    a=A[(n-1)//2] ; b=B[(n-1)//2]\n  \n    print((b-a+1))\nelse:\n    a=(A[n//2-1]+A[n//2])/2 ; b=(B[n//2-1]+B[n//2])/2\n  \n    print((int((b-a)/0.5)+1))\n", "N=int(input())\nl,r=[],[]\nfor i in range(N):\n  a,b=map(int,input().split())\n  l.append(a)\n  r.append(b)\nl.sort()\nr.sort()\nif N%2:\n  print(r[N//2]-l[N//2]+1)\nelse:\n  a=(l[N//2]+l[N//2-1])/2\n  b=(r[N//2]+r[N//2-1])/2\n  print(int((b-a)*2)+1)", "N = int(input())\nA = []\nB = []\nfor i in range (0,N):\n\ta, b = map(int, input().split())\n\tA.append(a)\n\tB.append(b)\n    \nA = sorted(A)\nB = sorted(B)\n\nfrom statistics import median\n\nif N%2 ==1:\n\tprint(median(B)-median(A)+1)\nelse:\n\tprint(int((median(B)-median(A))*2+1))", "from statistics import*\n(n,),*t=[map(int,t.split())for t in open(0)]\na,b=map(median,zip(*t))\nprint(int((b-a)*(2-n%2))+1)", "import sys\nimport numpy as np\ninput = sys.stdin.readline\nread = sys.stdin.read\n\n\ndef log(*args):\n    print(*args, file=sys.stderr)\n\n\ndef main():\n    np.set_printoptions(threshold=20)\n    N = int(input())\n    AB = np.array(read().split(), dtype=np.int)\n    A = AB[0::2]\n    B = AB[1::2]\n    A.sort()\n    B.sort()\n    if N % 2 == 1:\n        n = N // 2\n        print(B[n] - A[n] + 1)\n    else:\n        n = N // 2\n        print((B[n] + B[n - 1]) - (A[n] + A[n - 1]) + 1)\n\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import math\nn = int(input())\na = [0]*n\nb = [0]*n\nfor i in range(n):\n  a[i], b[i] = list(map(int, input().split()))\na.sort()\nb.sort()\nans = 0\nh = int(n/2)\nif n % 2 == 0:\n  a_harf = a[h-1] + a[h]\n  b_harf = b[h-1] + b[h]\n  ans = b_harf - a_harf + 1\nelse:\n  ans = b[h] - a[h] + 1\n  \nprint(ans)", "from numpy import*\n(n,),*d=[int_(i.split())for i in open(0)]\na,b=median(d,0)\nprint(int((b-a)*(2-n%2))+1)", "N=int(input())\nL=[]\nfor i in range(N):\n    A, B=list(map(int,input().split()))\n    L.append((A,B))\nL1=sorted(L,key=lambda x: x[0])\nL2=sorted(L,key=lambda x: x[1])\nif N%2==1:\n    n=N//2\n    print(L2[n][1] -L1[n][0]+1)\nelse:\n    n=N//2\n    m=(L1[n-1][1]+L1[n][1])/2\n    print(L2[n-1][1]+L2[n][1]-L1[n-1][0]-L1[n][0]+1)", "def med(l):\n\tt = len(l)\n\tif t%2:\n\t\treturn l[t//2]\n\telse: return (l[t//2]+l[t//2-1])/2\n\nn = int(input())\na = []\nb = []\nfor i in range(n):\n\tx,y = list(map(int,input().split()))\n\ta+=[x]\n\tb+=[y]\na.sort()\nb.sort()\n\nif n%2==0:\n\tprint((int((med(b)-med(a))*2)+1))\nelse:\n\tprint((med(b)-med(a)+1))\n", "n = int(input())\na = [0]*n\nb = [0]*n\n\nfor i in range(n):\n    aa,bb = list(map(int, input().split()))\n    a[i] = aa\n    b[i] = bb\n\na.sort()\nb.sort()\n\nif n%2 == 1:\n    print((b[n//2] - a[n//2] + 1))\nelse:\n    print((b[n//2] + b[(n//2)-1] - a[n//2] - a[(n//2)-1] + 1))\n", "import statistics\nn = int(input())\n\na=[0]*n\nb=[0]*n\n\nfor i in range(n):\n    a[i],b[i] = list(map(int,input().split()))\n\ncen_a=statistics.median(a)\ncen_b=statistics.median(b)\n\nif n%2==1:\n    print((cen_b-cen_a+1))\nelse:\n    print((int((cen_b-cen_a)*2+1)))\n", "n=int(input(\"\"))\na=[]\nb=[]\nfor i in range(n):\n    cc=input(\"\").split(\" \")\n    a+=[int(cc[0])]\n    b+=[int(cc[1])]\ns=0\na.sort()\nb.sort()\nif (n%2==0):\n    s=(a[int(n/2)]+a[int(n/2)-1]-b[int(n/2)]-b[int(n/2)-1])\nelse:\n    s=a[int((n-1)/2)]-b[int((n-1)/2)]\nprint((int(-s+1)))\n", "from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter\nfrom operator import mul\nimport copy\n# ! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport heapq\n\nn = int(input())\n\naa = []\nbb = []\nfor i in range(n):\n    a , b = list(map(int, input().split()))\n\n    aa.append(a)\n    bb.append(b)\n\naa.sort()\nbb.sort()\n\nif n % 2 == 0:\n    m_a = (aa[n // 2 - 1] + aa[n // 2])\n    m_b = (bb[n // 2 - 1] + bb[n // 2])\n\n    print(m_b - m_a+1)\n    return\n\nelse:\n    median_a = aa[n // 2]\n    median_b = bb[n // 2]\n\n    print(median_b-median_a+1)\n    return", "import statistics\nN = int(input())\nA = []\nB = []\nfor _ in range(N):\n  a, b = list(map(int, input().split()))\n  A.append(a)\n  B.append(b)\n\nA.sort()\nB.sort()\n\nif N % 2 == 1:\n  med_min = A[N // 2]\n  med_max = B[N // 2]\n  print((med_max - med_min + 1))  \nelse:\n  med_min_db = A[N // 2] + A[N // 2 - 1]\n  med_max_db = B[N // 2] + B[N // 2 - 1]\n  print((med_max_db - med_min_db + 1))\n\n\n\n", "n = int(input())\nA, B = map(list,zip(*[map(int,input().split()) for i in range(n)]))\nA.sort()\nB.sort()\nif n&1:\n\tprint(B[n//2]-A[n//2]+1)\nelse:\n\tprint(B[n//2]+B[n//2-1]-(A[n//2]+A[n//2-1])+1)", "from statistics import median\n\n\ndef main():\n    n = int(input())\n    a = [0] * n\n    b = [0] * n\n    for i in range(n):\n        a[i], b[i] = list(map(int, input().split()))\n    ans = median(b) - median(a)\n    if n % 2 == 0:\n        ans *= 2\n    ans = int(ans)\n    ans += 1\n    print(ans)\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "n=int(input())\nm=[]\nM=[]\nfor _ in range(n):\n    x,y=map(int,input().split())\n    m.append(x)\n    M.append(y)\nm=sorted(m)\nM=sorted(M)\n\nz=n//2\nif n%2==1:\n    a=m[z]\n    b=M[z]\n    print(b-a+1)\nelse:\n    a=m[z]+m[z-1]\n    b=M[z]+M[z-1]\n    print(b-a+1)", "import statistics\nn=int(input())\n\nla, lb = [], []\nfor _ in range(n):\n  a, b = map(int, input().split())\n  la.append(a)\n  lb.append(b)\nc=statistics.median(la)\nd=statistics.median(lb)\nif n%2==1:\n  print(d-c+1)\nelse:\n  print(int(2*d-2*c+1))", "def main():\n    n = int(input())\n    a, b = [None]*n, [None]*n\n    for i in range(n):\n        a[i], b[i] = map(int, input().split())\n    a.sort()\n    b.sort()\n    if n & 1:\n        print(b[n//2]-a[n//2]+1)\n    else:\n        print(b[n//2-1]+b[n//2]-a[n//2-1]-a[n//2]+1)\n\ndef __starting_point():\n    main()\n__starting_point()", "from statistics import median\n\nN = int(input())\nA = [0] * N\nB = [0] * N\nmax=0\nmin =0\nfor c in range(N):\n    A[c], B[c] = map(int, input().split())\n\nmed_A = median(A)\nmed_B = median(B)\n\nif N%2==0:\n    print(int((med_B-med_A)*2+1))\nelse:\n    print(med_B-med_A+1)", "import numpy as np\n\nN = int(input())\nAB = np.vstack([list(map(int, input().split())) for _ in range(N)])\nmeds = np.median(AB, axis=0)\n\nif N%2 == 0:\n    print((int((meds[1]-meds[0])*2+1)))\nelse:\n    print((int(meds[1]-meds[0] +1)))\n", "#!/usr/bin/env python3\nimport sys\n\ninput = sys.stdin.readline\n\n\ndef S():\n    return input().rstrip()\n\n\ndef I():\n    return int(input())\n\n\ndef MI():\n    return list(map(int, input().split()))\n\n\nn = I()\nab = list(map(int, sys.stdin.read().split()))\na = ab[::2]\nb = ab[1::2]\na.sort()\nb.sort()\n\nif n % 2 == 0:\n    m1 = (a[n // 2 - 1] + a[n // 2]) / 2\n    m2 = (b[n // 2 - 1] + b[n // 2]) / 2\n    print((int((m2 - m1) * 2 + 1)))\nelse:\n    m1 = a[n // 2]\n    m2 = b[n // 2]\n    print((m2 - m1 + 1))\n", "import statistics\nfrom collections import Counter\nN = int(input())\nA = [list(map(int, input().split(\" \"))) for i in range(N)]\nxMIN = []\nxMAX = []\n\n\n\nfor i in range(N):\n    xMIN.append(A[i][0])\n\nfor j in range(N):\n    xMAX.append(A[j][1])\n\n\nif N % 2 != 0:\n    medianMIN = statistics.median(xMIN)\n    medianMAX = statistics.median(xMAX)\n    print((int(medianMAX-medianMIN+1)))\nelse:\n    medianMIN_LOW = statistics.median_low(xMIN)\n    medianMIN_HIGH = statistics.median_high(xMIN)\n    medianMAX_LOW = statistics.median_low(xMAX)\n    medianMAX_HIGH = statistics.median_high(xMAX)\n    print(((medianMAX_LOW+medianMAX_HIGH)-(medianMIN_LOW+medianMIN_HIGH)+1))\n", "N = int(input())\nA = list()\nB = list()\nfor i in range(N):\n  a, b = map(int, input().split())\n  A.append(a)\n  B.append(b)\n  \nA.sort()\nB.sort()\n\nif(N%2==1):\n  x = A[(N-1)//2]\n  y = B[(N-1)//2]\n  print(y-x+1)\nelse:\n  x = A[(N//2)-1] + A[N//2]\n  y = B[(N//2)-1] + B[N//2]\n  print(y-x+1)", "def solve():\n  N = int(input())\n  A = [0]*N\n  B = [0]*N\n  for i in range(N):\n    A[i],B[i] = map(int, input().split())\n  A.sort()\n  B.sort(reverse=True)\n  if N%2==1:\n    b = A[N//2]\n    u = B[N//2]\n    return u-b+1\n  b1 = A[N//2-1]\n  b2 = A[N//2]\n  u1 = B[N//2-1]\n  u2 = B[N//2]\n  return u1+u2-b1-b2+1\nprint(solve())", "n=int(input())\na,b=[],[]\nfor i in range(n):\n  inp=list(map(int,input().split()))\n  a.append(inp[0])\n  b.append(inp[1])\na.sort()\nb.sort()\nam=sum(a[(n-1)//2:n//2+1])\nbm=sum(b[(n-1)//2:n//2+1])\nprint(bm-am+1)", "# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\nMOD = int(1e09) + 7\nINF = int(1e15)\n\n\ndef solve():\n    N = Scanner.int()\n    A = [0 for _ in range(N)]\n    B = [0 for _ in range(N)]\n    for i in range(N):\n        A[i], B[i] = Scanner.map_int()\n    A.sort()\n    B.sort()\n    if N % 2 == 0:\n        mA = A[N // 2] + A[N // 2 - 1]\n        mB = B[N // 2] + B[N // 2 - 1]\n        print((mB - mA + 1))\n    else:\n        mA = A[N // 2]\n        mB = B[N // 2]\n        print((mB - mA + 1))\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "import statistics\n\nN = int(input())\nAB = [map(int, input().split()) for _ in range(N)]\nA, B = [list(i) for i in zip(*AB)]\n\n\nA_median = statistics.median(A)\nB_median = statistics.median(B)\nif N%2==0:\n    print(int((B_median-A_median)*2)+1)\nelse:\n    print(B_median-A_median+1)", "n = int(input())\na = [0] * n\nb = [0] * n\nfor i in range(n):\n    a[i], b[i] = [int(j) for j in input().split()]\na.sort()\nb.sort()\nif n % 2 == 1:\n    print(b[n//2] - a[n//2] + 1)\nelse:\n    print(b[n//2] + b[n//2-1] - a[n//2] - a[n//2-1] + 1)", "N = int(input())\nl = []\nfor _ in range(N):\n    A, B = list(map(int, input().split()))\n    l.append((A, B))\n\nt = N//2\ntl = sorted(l)\ntr = sorted(l, key=lambda x:-x[1])\n\nif N%2:\n    print((tr[t][1]-tl[t][0]+1))\nelse:\n    a1, a2 = tl[t-1][0], tr[t][1]\n    a3, a4 = tl[t][0], tr[t-1][1]\n    print((a4-a3+a2-a1+1))\n", "N = int(input())\na, b = [], []\nfor i in range(N):\n    c, d = map(int, input().split())\n    a.append(c)\n    b.append(d)\na.sort()\nb.sort()\nif N%2 == 1:\n    print(b[N//2] - a[N//2] + 1)\nelse:\n    print((b[N//2]+b[N//2-1]) - (a[N//2]+a[N//2-1]) + 1)", "N = int(input())\n\nAlist = []\nBlist = []\n\nfor _ in range(N):\n    a, b = map(int, input().split())\n    Alist.append(a)\n    Blist.append(b)\n\nAlist.sort()\nBlist.sort()\n\nif N%2==1:\n    center_A = Alist[(N-1)//2]\n    center_B = Blist[(N-1)//2]\n    print(int(center_B - center_A + 1))\n\nelse:\n    center_A = (Alist[N//2 - 1] + Alist[N//2]) / 2\n    center_B = (Blist[N//2 - 1] + Blist[N//2]) / 2\n    print(int(center_B * 2 - center_A * 2 + 1))", "from statistics import median\nN = int(input())\nA = []\nB = []\nfor n in range(N):\n    a, b = map(int, input().split())\n    A.append(a)\n    B.append(b)\n#AB = sorted(AB, key=lambda x: x[0])\n#print(AB)\ncenA = median(A)\ncenB = median(B)\n\n\nif N % 2 == 1:\n    print(int(cenB - cenA + 1))\n\nelif N % 2 == 0:\n    print(int((cenB - cenA)*2 + 1))\n    \nelse:\n    print('RE')", "3\n# -*- coding:utf-8 -*-\n\nimport numpy\n\ndef main():\n  n = int(input())\n  la, lb = [], []\n  for _ in range(n):\n    a, b = list(map(int, input().split()))\n    la.append(a)\n    lb.append(b)\n  la.sort(), lb.sort()\n  \n  if n % 2 == 0:\n    s = (n-1)//2\n    e = s + 2\n    ma = sum(la[s:e]) / 2.0\n    mb = sum(lb[s:e]) / 2.0\n    print((int(2 * (mb - ma) + 1)))\n  if n % 2 == 1:\n    ma = la[n//2]\n    mb = lb[n//2]\n    print((mb - ma + 1))\n    \ndef __starting_point():\n  main()\n\n\n__starting_point()", "n = int(input())\nA = []\nB = []\nfor i in range(n):\n    x = [int(i) for i in input().split()]\n    A.append(x[0])\n    B.append(x[1])\nA = sorted(A)\nB = sorted(B)\nif n % 2:\n    med_A = A[n//2]\n    med_B = B[n//2]\n    print(abs(med_A - med_B) + 1)\nelse:\n    med_A  = A[(n-1)//2]+A[n//2] # this is double of median\n    med_B = B[(n-1)//2]+B[n//2]\n    print(abs(med_A - med_B) + 1) # we want gap of 1/2"]