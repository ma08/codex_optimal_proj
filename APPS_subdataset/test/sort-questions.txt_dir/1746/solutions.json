["#!/usr/bin/env python3\n\ndef main():\n    class Node:\n        def __init__(self):\n            self.children = [ ]\n\n    n = int(input())\n    nodes = [Node() for i in range(n)]\n    for i in range(1, n):\n        p = int(input())\n        nodes[p - 1].children.append(nodes[i])\n    ok = all(\n        len([child for child in node.children if not child.children]) >= 3\n        for node in nodes\n        if node.children\n    )\n    print(\"Yes\" if ok else \"No\")\n\ntry:\n    while True:\n        main()\nexcept EOFError:\n    pass\n", "read = lambda: list(map(int, input().split()))\nn = int(input())\ng = [list() for i in range(n + 1)]\nfor i in range(n - 1):\n    p = int(input())\n    g[p].append(i + 2)\nc = [0] * (n + 1)\nfor i in range(1, n + 1):\n    if len(g[i]) == 0:\n        c[i] = 1\nfor i in range(1, n +1):\n    if not c[i]:\n        cnt = 0\n        for u in g[i]:\n            cnt += c[u]\n        if cnt < 3:\n            print('No')\n            return\nprint('Yes')\n", "n = int(input())\npar = [-1 for i in range(n + 123)]\n\nfor i in range(2, n + 1):\n    par[i] = int(input())\n\nis_leaf = [True for i in range(n + 123)]\n\nfor i in range(2, n + 1):\n    is_leaf[par[i]] = False\n\nchildren = [0 for i in range(n + 123)]\n\nfor i in range(2, n + 1):\n    children[par[i]] += is_leaf[i]\n\n\nans = True\nfor i in range(1, n + 1):\n    if is_leaf[i]:\n        continue\n    ans &= children[i] >= 3\n\n\nprint('Yes' if ans else 'No')\n", "n = int(input())\nis_leaf = [True]*(n+1)\nchildren = [[] for _ in range(n+1)]\nans = \"Yes\"\n\nfor i in range(2, n+1):\n    p = int(input())\n    children[p].append(i)\n    is_leaf[p] = False\n\nfor node in range(1, n+1):\n    if not is_leaf[node]:\n        count = 0\n        for child in children[node]:\n            count += is_leaf[child]\n        if count < 3:\n            ans = \"No\"\n            break\nprint(ans)\n", "n = int(input())\nd = []\nfor i in range(n - 1):\n\td.append(int(input()))\nm = {i:[] for i in range(1, n + 1)}\nz = {i:0 for i in range(1, n + 1)}\nfor i in range(len(d)):\n\tm[d[i]].append(i + 2)\nfor i in m:\n\tif m[i] == []:\n\t\tz[i] = -1\nfor i in m:\n\tfor j in m[i]:\n\t\tif z[j] == -1:\n\t\t\tz[i] += 1\nf = True\nfor i in z:\n\tif z[i] < 3 and z[i] != -1:\n\t\tf = False\n\t\tbreak\nif f:\n\tprint('Yes')\nelse:\n\tprint('No')", "import sys\nsys.setrecursionlimit(10 ** 5)\nn = int(input())\ng = [[] for i in range(n)]\nfor i in range(1, n):\n    z = int(input()) - 1\n    g[z].append(i)\n#print(g)\nb = True\nfor el in g:\n    if len(el) == 0:\n        continue\n    z = 0\n    for v in el:\n        z += len(g[v]) == 0\n    if z <= 2:\n        b = False\nif b:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "n = int(input())\ndeg = [0 for _ in range(n + 1)]\nchd = [0 for _ in range(n + 1)]\nf = [0 for _ in range(n + 1)]\nfor i in range(2, n + 1):\n    f[i] = int(input())\n    deg[f[i]] += 1\nisok = True\nfor i in range(2, n + 1):\n    if deg[i] == 0:\n        chd[f[i]] += 1\n\nfor i in range(1, n + 1):\n    if deg[i] != 0 and chd[i] < 3:\n        isok = False\nif isok:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "def ii():\n    return int(input())\ndef mi():\n    return list(map(int, input().split()))\ndef li():\n    return list(mi())\n\nn = ii()\ng = [[] for i in range(n+1)]\nfor i in range(2, n+1):\n    x = ii()\n    g[x].append(i)\nl = set(i for i in range(1, n+1) if not g[i])\nc = sum(sum(j in l for j in g[i]) >= 3 for i in range(1, n+1))\nprint('Yes' if c + len(l) == n else 'No')\n", "n = int(input())\nparent = [None] * n\nchildren = [[] for i in range(n)]\nfor i in range(1, n):\n\tp = int(input())\n\tp = p - 1\n\tparent[i] = p\n\tchildren[p].append(i)\n\nleaf = {}\t\t\nfor i in range(n):\n\tif len(children[i]) == 0:\n\t\tleaf[i] = True\n\telse:\n\t\tleaf[i] = False\n\nfor i in range(n):\n\tif leaf[i]:\n\t\tcontinue\n\tc = 0\n\tfor j in children[i]:\n\t\tif leaf[j]:\n\t\t\tc = c + 1\n\tif c < 3:\n\t\tprint(\"No\")\n\t\tquit()\n\nprint(\"Yes\")", "n = int(input())\nleaf = [True]*(n+1)\nchd = [-1]*(n+1)\nfor i in range(2,n+1):\n    p = int(input())\n    if chd[p] == -1:\n        chd[p] = [i]\n        leaf[p] = False\n    else:\n        chd[p].append(i)\nsuc = True\nfor i in range(1,n+1):\n    ctr = 0\n    if not leaf[i]:\n        for x in chd[i]:\n            if leaf[x]:\n                ctr += 1\n        if ctr < 3:\n            suc = False\n            break\n\nif suc:\n    print('Yes')\nelse:\n    print('No')\n", "from collections import defaultdict as dd, deque\n\nn = int(input())\n\nV = [i+1 for i in range(n)]\nE = dd(list)\n\nfor i in V[1:]:\n    p = int(input())\n    E[p].append(i)\n\nfor v in V:\n    if len(E[v]) != 0 and sum(len(E[u])==0 for u in E[v]) < 3:\n        print('No')\n        break\nelse:\n    print('Yes')\n", "n = int(input())\np = [int(input()) for i in range(n - 1)]\n\nc_children = [0] * (n + 1)\n\nfor pi in p:\n\tc_children[pi] += 1\n\ndef is_leaf(i):\n\treturn c_children[i] == 0\n\nfor i in range(1, n + 1):\n\tif not is_leaf(i):\n\t\tt = 0\n\n\t\tfor j in range(2, n + 1): \n\t\t\tif p[j - 2] == i and is_leaf(j): t += 1\n\n\t\tif t < 3: \n\t\t\tprint(\"No\")\n\t\t\treturn\n\nprint(\"Yes\")\n", "def spruce():\n    n = int(input())\n    tree = dict()\n    parent = set()\n    for i in range(n-1):\n        p = int(input())\n        parent.add(p)\n        childs = tree.get(p, list())\n        childs.append(i+2)\n        tree[p] = childs\n    is_spruce = True\n    for p in parent:\n        childs = set(tree[p])\n        leafs = childs - parent\n        if len(leafs) < 3:\n            is_spruce = False\n            break\n\n    if is_spruce:\n        print('Yes')\n    else:\n        print('No')\n\ndef __starting_point():\n    spruce()\n__starting_point()", "from itertools import permutations\n\nMOD = 10**9+7\n\ndef main():\n    n = int(input())\n    parent = [0] * n\n    is_leaf = [True] * n\n    for i in range(1,n):\n        parent[i] = int(input()) - 1\n        is_leaf[parent[i]] = False\n    leafs_cnt = [0] * n\n    for i in range(n):\n        leafs_cnt[parent[i]] += is_leaf[i]\n    for i in range(n):\n        if not is_leaf[i] and leafs_cnt[i] < 3:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nwhile 1:\n    main()\n    break\n# input()\n", "n = int(input())\nc = {}\nfor i in range(n):\n    c[i]=[]\nfor i in range(n-1):\n    c[int(input())-1].append(i+1)\nf = True\nfor i in range(n):\n    cl = 0\n    for j in c[i]:\n        if len(c[j]) == 0:cl+=1\n    if len(c[i])!=0 and cl < 3:f = False\nprint('Yes' if f else 'No')\n", "import sys\nsys.setrecursionlimit(10000)\nn=int(input())\n\nvs = {}\nfor c in range(2, n+1):\n    p = int(input())\n    if p in vs:\n        vs[p].append(c)\n    else:\n        vs[p] = [c]\n\ndef check(n):\n    if n not in vs:\n        return 1\n    ch = vs[n]\n    s = 0\n    for c in ch:\n        r = check(c)\n        if r == -1:\n            return -1\n        s+=r\n    if s >= 3:\n        return 0\n    return -1\n\nprint('Yes' if check(1) == 0 else 'No')", "def solve():\n    n =  int(input())\n    #l = [[]] * (n+1)\n    l = [[] for i in range(n+1)]\n    for i in range(2, n+1):\n        a = int(input())\n        l[a].append(i)\n        #print(l)\n\n    #print(l)\n    for i in l:\n        if len(i) != 0:\n            leafCount = 0\n            for j in i:\n                if len(l[j]) == 0:\n                    leafCount+=1\n            if leafCount < 3:\n                print(\"No\")\n                return\n    print(\"Yes\")\n\nsolve()", "n=int(input())\nd={1:[]}\nfor i in range(n-1):\n\tparent=int(input())\n\tif parent in d:\n\t\td[parent].append(i+2)\n\telse:\n\t\td[parent]=[i+2]\nfor i in d:\n\tcount=0\n\tfor j in d[i]:\n\t\tif j not in d:\n\t\t\tcount+=1\n\tif count<3:\n\t\tprint('No')\n\t\treturn\nprint('Yes')", "a = dict()\nfor i in range(int(input())-1):\n\tc = int(input())\n\tif (not c in a): a[c] = list()\n\ta[c].append(i+2)\nfor i in a:\n\tl = int()\n\tfor j in a[i]:\n\t\tif (j not in a): l += 1\n\tif (l < 3):\n\t\tprint(\"No\")\n\t\treturn\nprint(\"Yes\")", "n=int(input())\nparents=[]\ntree=[[] for i in range(n)]\nfor i in range(n-1):\n    par=int(input())-1\n    tree[par].append(i+1)\n    parents.append(par)\nflag=True\n#print(parents)\n#print(tree)\nfor i in parents:\n    count=0\n    \n    for j in tree[i]:\n        if(len(tree[j])==0):\n            count+=1\n    if(count<3):\n        flag=False\n        \n        \n        \nif(flag):\n    print('Yes')\nelse:\n    print('No')", "n = int(input())\nl = [0] * n\n\nfor i in range(1,n):\n    l[i] = int(input())-1\n\nleaves = [1] * n\nleaves[0] = 0\n\nfor i in range(n):\n    for j in range(i, n-1):\n        if l[j] == i:\n            leaves[i] = 0\n\nspruce = 'Yes'\n\nfor i in range(n):\n    if leaves[i] == 0:\n        count = 0\n        for j in range(i,n):\n            if l[j] == i and leaves[j]:\n                count += 1\n        if count < 3:\n            spruce = 'No'\n\nprint(spruce)\n", "n = int(input())\ng = {}\ns = set()\nbol = True\nfor i in range(1,2000):\n    g[i]=[]\n\nfor j in range(2,n+1):\n    a = int(input())\n    s.add(a)\n    g[a].append(j)\n\nfor k in s:\n    d = 0 \n    for h in g[k]:\n        if h not in s:\n            d = d + 1\n\n    if d<3:\n        bol = False\nif bol:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "from queue import Queue\n\n\ndef BFS(v):\n    st = Queue()\n    st.put(v)\n\n    while not st.empty():\n        u = st.get()\n\n        count = 0\n        for v in graph[u]:\n            if graph[v] == list():\n                count += 1\n\n            else:\n                st.put(v)\n\n        if count < 3:\n            return False\n\n    return True\n\n\nn = int(input())\n\ngraph = {i: list() for i in range(1, n + 1)}\nfor i in range(2, n + 1):\n    j = int(input())\n\n    graph[j].append(i)\n\nprint(('No', 'Yes')[BFS(1)])\n"]