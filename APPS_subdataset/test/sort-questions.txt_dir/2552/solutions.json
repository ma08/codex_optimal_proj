["import sys\ninput = sys.stdin.readline\nT = int(input())\n\n\n\nfor testcase in range(1,T+1):\n    n,m = map(int,input().split())\n    p = tuple(map(int,input().split()))\n    h = tuple(map(int,input().split()))\n\n    a = [0]*n\n    b = [0]*n\n\n    edge = [[] for i in range(n)]\n    for _ in range(n-1):\n        x,y = map(int,input().split())\n        edge[x-1].append(y-1)\n        edge[y-1].append(x-1)\n    \n    par = [-1]*n\n    tank = [0]\n    order = []\n    while tank:\n        now = tank.pop()\n        order.append(now)\n        for e in edge[now]:\n            if par[now] != e:\n                par[e] = now\n                tank.append(e)\n    flag = True\n    for e in order[::-1]:\n        if (a[e]-b[e]-p[e] <= h[e] <= a[e]+b[e]+p[e]) and (h[e]+a[e]+b[e]+p[e])%2 == 0:\n            if e != 0:\n                a[par[e]] += (h[e]+a[e]+b[e]+p[e])//2\n                b[par[e]] += (h[e]+a[e]+b[e]+p[e])//2 - h[e]\n        else:\n            flag = False\n            break\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "\nfrom sys import stdin\nimport sys\nsys.setrecursionlimit(300000)\n\ndef dfs(v,pa):\n\n    good = 0\n    bad = 0\n    for nex in lis[v]:\n        if nex != pa:\n            nans,ng,nb = dfs(nex,v)\n            if not nans:\n                return nans,0,0\n            good += ng\n            bad  += nb\n\n    num = good + bad + p[v]\n    if (num - h[v]) % 2 == 0:\n        newbad  = (num - h[v])//2\n    else:\n        return False,0,0\n    newgood = num - newbad\n\n    if newbad - p[v] > bad or newgood < good or newbad < 0 or newgood < 0:\n        return False,0,0\n    else:\n        return True,newgood,newbad\n\n\n\n\ntt = int(stdin.readline())\n\nfor loop in range(tt):\n\n    n,m = list(map(int,stdin.readline().split()))\n    p = list(map(int,stdin.readline().split()))\n    h = list(map(int,stdin.readline().split()))\n\n    lis = [ [] for i in range(n)]\n    for i in range(n-1):\n        v,u = list(map(int,stdin.readline().split()))\n        v -= 1\n        u -= 1\n        lis[v].append(u)\n        lis[u].append(v)\n\n    ans,good,bad = dfs(0,0)\n    \n    if ans:\n        print (\"YES\")\n    else:\n        print (\"NO\")\n", "import sys\ninput = sys.stdin.readline\n\n\ndef topological_sort(tree: list, root) -> list:\n    n = len(tree)\n    visited = [False] * n\n    visited[root] = True\n    tp_sorted = [root]\n    stack = [root]\n    while stack:\n        v = stack.pop()\n        for nxt_v in tree[v]:\n            if visited[nxt_v]:\n                continue\n            visited[nxt_v] = True\n            stack.append(nxt_v)\n            tp_sorted.append(nxt_v)\n    return tp_sorted\n\n\ndef get_par(tree: list, root: int) -> list:\n    n = len(tree)\n    visited = [False] * n\n    visited[root] = True\n    par = [-1] * n\n    stack = [root]\n    while stack:\n        v = stack.pop()\n        for nxt_v in tree[v]:\n            if visited[nxt_v]:\n                continue\n            visited[nxt_v] = True\n            stack.append(nxt_v)\n            par[nxt_v] = v\n    return par\n\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    p = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    edges = [list(map(int, input().split())) for i in range(n - 1)]\n    \n    tree = [[] for i in range(n)]\n    for a, b in edges:\n        a -= 1\n        b -= 1\n        tree[a].append(b)\n        tree[b].append(a)\n\n    root = 0\n    tp_sort = topological_sort(tree, root)\n    par = get_par(tree, root)\n    cnts = [[0, 0] for i in range(n)]\n    flag = True\n    for v in tp_sort[::-1]:\n        good, bad = 0, 0\n        for nxt_v in tree[v]:\n            if nxt_v == par[v]:\n                continue\n            else:\n                good += cnts[nxt_v][0]\n                bad += cnts[nxt_v][1]\n\n        sum_p = good + bad + p[v]\n        if (sum_p + h[v]) % 2 != 0:\n            flag = False\n            break\n        g = (sum_p + h[v]) // 2\n        b = (sum_p - h[v]) // 2\n        \n        inc_g = g - good\n        if 0 <= inc_g <= p[v] + bad:\n            cnts[v] = g, b\n            continue\n        else:\n            flag = False\n            break\n\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")", "import sys, math\nimport io, os\n#data = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n#from itertools import permutations,combinations\ndef data(): return sys.stdin.readline().strip()\ndef mdata(): return list(map(int, data().split()))\ndef outl(var) : sys.stdout.write('\\n'.join(map(str, var))+'\\n')\ndef out(var) : sys.stdout.write(str(var)+'\\n')\n#from decimal import Decimal\nfrom fractions import Fraction\n#sys.setrecursionlimit(100000)\nINF = float('inf')\nmod = int(1e9)+7\n\ndef dfs(graph, start=0):\n    n = len(graph)\n\n    dp = [0] * n\n    visited, finished = [False] * n, [False] * n\n    par = [0]*n\n\n    stack = [start]\n    while stack:\n        start = stack[-1]\n\n        # push unvisited children into stack\n        if not visited[start]:\n            visited[start] = True\n            for child in graph[start]:\n                if not visited[child]:\n                    stack.append(child)\n                    par[child]=start\n\n        else:\n            stack.pop()\n\n            # base case\n            dp[start] += p[start]\n\n            # update with finished children\n            for child in graph[start]:\n                if finished[child]:\n                    dp[start] += dp[child]\n\n            finished[start] = True\n\n    return dp\n\ndef dfs2(graph, start=0):\n    n = len(graph)\n\n    dp = [0] * n\n    visited, finished = [False] * n, [False] * n\n    n = [0]*n\n\n    stack = [start]\n    while stack:\n        start = stack[-1]\n\n        # push unvisited children into stack\n        if not visited[start]:\n            visited[start] = True\n            for child in graph[start]:\n                if not visited[child]:\n                    stack.append(child)\n\n        else:\n            stack.pop()\n\n            # base case\n            dp[start] += (v[start]+h[start])//2\n            a=v[start]-dp[start]\n            if dp[start]-a!=h[start]  or a<0:\n                return False\n\n            # update with finished children\n            k=0\n            for child in graph[start]:\n                if finished[child]:\n                    k += dp[child]\n            if k>dp[start]:\n                return False\n\n            finished[start] = True\n\n    return True\n\nfor t in range(int(data())):\n    n,m=mdata()\n    p=mdata()\n    h=mdata()\n    g=[[] for i in range(n)]\n    for i in range(n-1):\n        u,v=mdata()\n        u,v=u-1,v-1\n        g[u].append(v)\n        g[v].append(u)\n    v=dfs(g,0)\n    if dfs2(g,0):\n        out(\"YES\")\n    else:\n        out(\"NO\")\n\n\n\n"]