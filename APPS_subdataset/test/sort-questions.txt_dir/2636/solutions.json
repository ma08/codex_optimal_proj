["class Solution(object):\n     def getSkyline(self, buildings):\n         \"\"\"\n         :type buildings: List[List[int]]\n         :rtype: List[List[int]]\n         \"\"\"\n         cp= set([b[0] for b in buildings]+[b[1] for b in buildings])\n         i, active, res = 0, [], []\n         for c in sorted(cp):\n             while i<len(buildings) and buildings[i][0]<=c:\n                 heapq.heappush(active, (-buildings[i][2], buildings[i][1]))\n                 i+=1\n \n             while active and active[0][1]<=c:\n                 heapq.heappop(active)\n \n             h= len(active) and -active[0][0]\n             if not res or h!=res[-1][1]:\n                 res.append([c, h])\n         return res\n \n", "class Solution:\n     def getSkyline(self, buildings):\n         \"\"\"\n         :type buildings: List[List[int]]\n         :rtype: List[List[int]]\n         \"\"\"\n         \n #         def get_height_end(idx, height):\n #             # print(heightends)\n #             for left, right in heightends[height]:\n #                 if left <= idx < right:\n #                     return right\n         \n #         coords1 = []\n #         for left, right, height in buildings:\n #             coords1.append(left)\n #             coords1.append(right)\n #         coords1.sort()\n         \n #         coords = []\n #         for k, g in itertools.groupby(coords1):\n #             coords.append(k)\n             \n #         index = { num: idx for idx, num in enumerate(coords) }\n #         events = collections.defaultdict(list)\n #         heightends = collections.defaultdict(list)\n         \n #         for left, right, height in buildings:\n             \n #             i = index[left]\n #             while i < index[right]:\n #                 # print(i, events, left, right)\n #                 if events[i] != [] and sorted(events[i])[-1] >= height:\n #                     i = get_height_end(i, sorted(events[i])[-1])\n #                     continue\n \n #                 events[i].append(height)\n #                 i += 1\n #             heightends[height].append([index[left], index[right]])\n         \n #         infpoints = []\n #         prevheight = 0\n #         for coord in coords:\n #             coordheights = sorted(events[index[coord]])\n #             coordheight = 0\n #             if coordheights != []:\n #                 coordheight = coordheights[-1]\n #             if prevheight != coordheight:\n #                 infpoints.append([coord, coordheight])\n #                 prevheight = coordheight\n         \n #         return infpoints\n \n         edges = []\n         events = collections.defaultdict(list)\n         for left, right, height in buildings:\n             edges.append((left, -height, right))\n             edges.append((right, 0, None))\n             # heapq.heappush(events[left].append()\n             # events[right].append((left, right, height))\n \n         pq = [(0, float('inf'))]\n         edges.sort()\n         skyline = [(0,0)]\n         \n         for edge, height, right in edges:\n \n             while edge >= pq[0][1]:\n                 heapq.heappop(pq)\n             if height:\n                 heapq.heappush(pq, (height, right))\n             if skyline[-1][1] != -pq[0][0]:\n                 skyline.append([edge, -pq[0][0]])\n         return skyline[1:]\n \n", "class Solution:\n     def getSkyline(self, buildings):\n         \"\"\"\n         :type buildings: List[List[int]]\n         :rtype: List[List[int]]\n         \"\"\"\n         edges = []\n         for left, right, height in buildings:\n             edges.append((left, -height, right))\n             edges.append((right, 0, None))\n             \n         edges.sort()\n         pq = [(0, float('inf'))]\n         skyline = [(0, 0)]\n         print(edges)\n         for left, negheight, right in edges:\n             while pq[0][1] <= left:\n                 heapq.heappop(pq)\n             if negheight:\n                 heapq.heappush(pq, (negheight, right))\n             if skyline[-1][1] != -pq[0][0]:\n                 skyline.append([left, -pq[0][0]])\n                 \n         return skyline[1:]", "class Solution:\n     def getSkyline(self, blds):\n         \"\"\"\n         :type buildings: List[List[int]]\n         :rtype: List[List[int]]\n         \"\"\"\n         if not blds:\n             return []\n         if len(blds) == 1:\n             return [[blds[0][0], blds[0][2]], [blds[0][1], 0]]\n         \n         mid = len(blds) >> 1\n         left = self.getSkyline(blds[:mid])\n         right = self.getSkyline(blds[mid:])\n         return self.merge(left, right)\n         #conquor how to merge left and right\n     \n     def merge(self, left, right):\n         res = []\n         h1 = h2 = 0\n         while left and right:\n             if left[0][0] < right[0][0]:\n                 pos, h1 = left.pop(0)\n             elif right[0][0] < left[0][0]:\n                 pos, h2 = right.pop(0)\n             else:\n                 pos, h1 = left.pop(0)\n                 h2 = right.pop(0)[1]\n             h = max(h1, h2)\n             if not res or res[-1][1] != h:\n                 res.append([pos, h])\n                 \n \n         if left:\n             res += left\n         if right:\n             res += right\n         return res"]