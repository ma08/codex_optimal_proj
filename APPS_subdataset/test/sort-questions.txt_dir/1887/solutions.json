["n = int(input())\nh1 = list(map(int, input().split()))\nh2 = list(map(int, input().split()))\n\nr1 = r2 = 0\nfor i in range(n):\n    r1, r2 = max(r1, r2 + h1[i]), max(r2, r1 + h2[i])\n\nprint(max(r1, r2))\n", "n = int(input())\nl = [[*map(int, input().split())], [*map(int, input().split())]]\ndp = [0, 0]\nfor i in range(n):\n    new_dp = dp[:]\n    new_dp[0] = max(new_dp[0], dp[1] + l[0][i])\n    new_dp[1] = max(new_dp[1], dp[0] + l[1][i])\n    dp = new_dp\nprint(max(dp))", "import sys\n\nn = int(sys.stdin.readline().strip())\nh1 = list(map(int, sys.stdin.readline().strip().split()))\nh2 = list(map(int, sys.stdin.readline().strip().split()))\nm1 = 0\nn1 = h1[0]\nm2 = 0\nn2 = h2[0]\nfor i in range (1, n):\n    m1, n1, m2, n2 = n1, h1[i] + max([m2, n2]), n2, h2[i] + max([m1, n1])\nprint(max([n1, n2]))", "from sys import stdin, stdout, exit\n\nn = int(stdin.readline())\ntop = list(map(int, stdin.readline().split()))\nbot = list(map(int, stdin.readline().split()))\n\ntop_dp = [0]*(n+1)\nbot_dp = [0]*(n+1)\n\nfor i in range(n):\n    top_dp[i+1] = max(top_dp[i], bot_dp[i] + top[i])\n    bot_dp[i+1] = max(bot_dp[i], top_dp[i] + bot[i])\n\nans = max(top_dp[n], bot_dp[n])\nstdout.write(str(ans) + \"\\n\")\n", "from collections import defaultdict\nn = int(input())\n\n\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\nscore = [[0 for x in range(n)]for _ in range(2)]\n\n\nif n == 1:\n    print (max(a[0],b[0]))\n    return\nelif n==2:\n    print (max(a[0]+b[1],b[0]+a[1]))\n    return\n\n\nscore[0][0] = a[0]\nscore[1][0] = b[0]\nscore[1][1] = a[0]+b[1]\nscore[0][1] = b[0]+a[1]\n\n\nfor x in range(2,n):\n    # where it has been used\n    score[0][x] = max(score[1][x-1],score[1][x-2]) + a[x]\n    score[1][x] = max(score[0][x-1],score[0][x-2])+ b[x]\nprint (max(score[0][-1],score[1][-1]))", "n = int(input())\na = [list(map(int, input().split())), list(map(int, input().split()))]\nm = [a[0][-1], a[1][-1]]\nfor i in list(range(n - 1))[::-1]:\n    m[0], m[1] = max(m[0], m[1] + a[0][i]), max(m[1], m[0] + a[1][i])\nprint(max(m[0], m[1]))\n", "import sys\ninput = sys.stdin.readline\n\nn=int(input())\nH0=list(map(int,input().split()))\nH1=list(map(int,input().split()))\n\nDP0=[0]*(n+5)\nDP1=[0]*(n+5)\n\nDP0[0]=H0[0]\nDP1[0]=H1[0]\n\nfor i in range(1,n):\n    DP0[i]=max(DP1[i-1],DP1[i-2],DP0[i-2])+H0[i]\n    DP1[i]=max(DP0[i-1],DP0[i-2],DP1[i-2])+H1[i]\n\nprint(max(max(DP0),max(DP1)))\n\n", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(100000)\n\ndef getN():\n    return int(input())\ndef getList():\n    return list(map(int, input().split()))\nimport math\n\nn = getN()\nanums = getList()\nbnums = getList()\n\nif n == 1:\n    print(max(anums[0], bnums[0]))\n    return\n\ndp1 = [0 for i in range(n)]\ndp2 = [0 for i in range(n)]\n\ndp1[0] = anums[0]\ndp1[1] = (anums[1] +  bnums[0])\ndp2[0] = bnums[0]\ndp2[1] = (bnums[1] + anums[0])\ni = 0\nfor a, b in (list(zip(anums[2:], bnums[2:]))):\n    dp1[i+2] = max(dp1[i], dp2[i+1], dp2[i]) + a\n    dp2[i + 2] = max(dp2[i], dp1[i + 1], dp1[i]) + b\n    i += 1\nprint(max(dp1[-1], dp1[-2], dp2[-1], dp2[-2]))\n# print(dp1)\n# print(dp2)\n", "\nn = int(input())\nr1 = list(map(int,input().split()))\nr2 = list(map(int,input().split()))\n\n# [i][0] sum when choosing r1 in pos\n# [i][1] sum when choosing r2 in pos\n# [i][2] sum when choosing nothing in pos\ndp = [[0,0,0] for _ in range(n)] \ndp[0] = [r1[0],r2[0],0]\nfor i in range(1,n):\n    last = dp[i-1]\n    dp[i][0] = max(last[1], last[2]) + r1[i]\n    dp[i][1] = max(last[0], last[2]) + r2[i]\n    dp[i][2] = max(last[0], last[1])\n\nprint(max(dp[n-1]))\n", "n = int(input())\n\na1 = list(map(int, input().split()))\na2 = list(map(int, input().split()))\n\n\nm1 = [0]*n\nm2 = [0]*n\n\nm1[0] = a1[0]\nm2[0] = a2[0]\nif n != 1:\n    m1[1] = m2[0] + a1[1]\n    m2[1] = m1[0] + a2[1]\n\nfor i in range(2, n):\n    m1[i] = max((m2[i-1]+a1[i], m1[i-2], m2[i-2]+a1[i]))\n    m2[i] = max((m1[i - 1] + a2[i], m2[i - 2], m1[i-2] + a2[i]))\n\nprint(max(m1[-1], m2[-1]))", "n=int(input())\na=[int(i) for i in input().split()]\nb=[int(i) for i in input().split()]\nans=[a[n-1],b[n-1]]\nbans=[0,0]\nfor i in range(n-2,-1,-1):\n  bans[0] = max(a[i]+ans[1],ans[0])\n  bans[1] = max(b[i]+ans[0],ans[1])\n  ans[0]=bans[0]\n  ans[1]=bans[1]\n  bans[0]=0\n  bans[1]=0\nprint(max(ans))\n", "from math import*\nn=int(input())\nm1=list(map(int,input().split()))\nm2=list(map(int,input().split()))\ndp=[[0]*2 for i in range(n)]\nif n==1:\n    print(max(m1[0],m2[0]))\n    return\nif n==2:\n    print(max(m1[0]+m2[1],m2[0]+m1[1]))\n    return\ndp[0][0]=m1[0]\ndp[0][1]=m2[0]\ndp[1][0]=m2[0]+m1[1]\ndp[1][1]=m2[1]+m1[0]\nfor i in range(2,n):\n    dp[i][0]=max(dp[i-1][1]+m1[i],dp[i-2][1]+m1[i])\n    dp[i][1]=max(dp[i-1][0]+m2[i],dp[i-2][0]+m2[i])\nprint(max(dp[n-1]))\n", "n = int(input())\nh1 = list(map(int,input().split()))\nh2 = list(map(int,input().split()))\nif n > 1:\n    h12 = [0] * n\n    h22 = [0] * n\n    h12[0] = h1[0]\n    h22[0] = h2[0]\n    h12[1] = max(h12[0],h22[0] + h1[1])\n    h22[1] = max(h22[0],h12[0] + h2[1])\n    for i in range(2,n):\n        h12[i] = max(h12[i-1],h22[i-1] + h1[i])\n        h22[i] = max(h22[i-1],h12[i-1] + h2[i])\n        h12[i] = max(h12[i],h22[i-2] + h1[i])\n        h22[i] = max(h22[i],h12[i-2] + h2[i])\n    print(max(h12[-1],h22[-1]))\nelse:\n    print(max(h1[0],h2[0]))\n", "def gns():\n    return list(map(int,input().split()))\nn=int(input())\nps=[]\nps.append(gns())\nps.append(gns())\ndp=[[0]*2 for i in range(n)]\n\ndef get(i,t):\n    if i<0:\n        return 0\n    else:\n        return dp[i][t]\n\nans=0\nfor i in range(n):\n    for t in range(2):\n        mx=max(get(i-1,1-t),get(i-2,1-t))\n        dp[i][t]=mx+ps[t][i]\n        ans=max(ans,dp[i][t])\n\n\n\nprint(ans)", "from sys import stdin\n\nn = int(stdin.readline())\nh = [[], []]\nh[0] = list(map(int, stdin.readline().split(' ')))\nh[1] = list(map(int, stdin.readline().split(' ')))\n\ndp = [[0 for i in range(n)], [0 for i in range(n)]]\n\ndp[0][0] = h[0][0]\ndp[1][0] = h[1][0]\n\nfor j in range(1, n):\n   for i in [0, 1]:\n      dp[i][j] = max(dp[i][j-1], h[i][j] + dp[i^1][j-1])\n\nres = max(dp[0][n-1], dp[1][n-1])\nprint(res)\n", "n=int(input())\nl1=list(map(int,input().split()))\nl2=list(map(int,input().split()))\nm1,m2=0,0\nfor i in range(n-1,-1,-1):\n    x1,x2=l1[i]+m2,l2[i]+m1\n    if x1>m1:\n        m1=x1\n    if x2>m2:\n        m2=x2\nprint(max(m1,m2))\n", "n=int(input())\nl=[[int(j) for j in input().split()] for i in range(2)]\nd1=[0]*(n+1)\nd2=[0]*(n+1)\nd1[0]=l[0][0]\nd2[0]=l[1][0]\n\nfor i in range(1,n):\n    d1[i]=max(d1[i-1],d2[i-1]+l[0][i])\n    d2[i]=max(d2[i-1],d1[i-1]+l[1][i])\nprint(max(d1[n-1],d2[n-1]))\n", "n = int(input())\nrows = []\nrows.append(list(map(int, input().split())))\nrows.append(list(map(int, input().split())))\nbest = [0, 0]\nnextBest = [0, 0]\nfor k in range(n):\n    nextBest[0] = max(best[1] + rows[0][k], best[0])\n    nextBest[1] = max(best[0] + rows[1][k], best[1])\n    best[0] = nextBest[0]\n    best[1] = nextBest[1]\nprint(max(best))\n", "n = int(input())\ns1 = [int(i) for i in input().split()]\ns2 = [int(i) for i in input().split()]\nc1 = 0\nc2 = 0\nfor i in range(n):\n    temp1 = max(c1, c2+s1[i])\n    temp2 = max(c2, c1+s2[i])\n    c1 = temp1\n    c2 = temp2\nprint(max(c1, c2))\n", "''' CODED WITH LOVE BY SATYAM KUMAR '''\n\nfrom sys import stdin, stdout\nimport cProfile, math\nfrom collections import Counter,defaultdict,deque\nfrom bisect import bisect_left,bisect,bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10**6) # max depth of recursion\nthreading.stack_size(2**27)  # new thread will get stack of such size\nfac_warmup = False\nprintHeap = str()\nmemory_constrained = False\nP = 10**9+7\nimport sys\n\nclass merge_find:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.size = [1]*n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n    def find(self,a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n    def merge(self,a,b):\n        a = self.find(a)\n        b = self.find(b)\n        if a==b:\n            return\n        if self.size[a]<self.size[b]:\n            a,b = b,a\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n    def set_size(self, a):\n        return self.size[self.find(a)]\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + \"\\n\")\n\ndef primeFactors(n): #n**0.5 complex \n    factors = dict()\n    for i in range(2,math.ceil(math.sqrt(n))+1):  \n        while n % i== 0: \n            if i in factors:\n                factors[i]+=1\n            else: factors[i]=1\n            n = n // i \n    if n>2:\n        factors[n]=1\n    return (factors)\n\ndef all_factors(n):    \n    return set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))\n\ndef fibonacci_modP(n,MOD):\n    if n<2: return 1\n    #print (n,MOD)\n    return (cached_fn(fibonacci_modP, (n+1)//2, MOD)*cached_fn(fibonacci_modP, n//2, MOD) + cached_fn(fibonacci_modP, (n-1) // 2, MOD)*cached_fn(fibonacci_modP, (n-2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n , p): \n    if (p <= n): \n        return 0\n    res = (p - 1) \n    for i in range (n + 1, p): \n        res = (res * cached_fn(InverseEuler,i, p)) % p \n    return res \n\ndef binary(n,digits = 20):\n    b = bin(n)[2:]\n    b = '0'*(digits-len(b))+b\n    return b\n\ndef isprime(n):\n    \"\"\"Returns True if n is prime.\"\"\"\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef generate_primes(n):\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * 2, n+1, p): \n                prime[i] = False\n        p += 1\n    return prime\n\nfactorial_modP = []\ndef warm_up_fac(MOD):\n    nonlocal factorial_modP,fac_warmup\n    if fac_warmup: return\n    factorial_modP= [1 for _ in range(fac_warmup_size+1)]\n    for i in range(2,fac_warmup_size):\n        factorial_modP[i]= (factorial_modP[i-1]*i) % MOD\n    fac_warmup = True\n\ndef InverseEuler(n,MOD):\n    return pow(n,MOD-2,MOD)\n\ndef nCr(n, r, MOD):\n    nonlocal fac_warmup,factorial_modP\n    if not fac_warmup:\n        warm_up_fac(MOD)\n        fac_warmup = True\n    return (factorial_modP[n]*((pow(factorial_modP[r], MOD-2, MOD) * pow(factorial_modP[n-r], MOD-2, MOD)) % MOD)) % MOD\n\ndef test_print(*args):\n    if testingMode:\n        print(args)\n\ndef display_list(list1, sep=\" \"):\n    stdout.write(sep.join(map(str, list1)) + \"\\n\")\n\ndef display_2D_list(li):\n    for i in li:\n        print(i)\ndef prefix_sum(li):\n    sm = 0\n    res = []\n    for i in li:\n        sm+=i\n        res.append(sm)\n    return res\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nimport heapq,itertools\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>' \ndef add_task(task, priority=0):\n    'Add a new task or update the priority of an existing task'\n    if task in entry_finder:\n        remove_task(task)\n    count = next(counter)\n    entry = [priority, count, task]\n    entry_finder[task] = entry\n    heapq.heappush(pq, entry)\n\ndef remove_task(task):\n    'Mark an existing task as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(task)\n    entry[-1] = REMOVED\n\ndef pop_task():\n    'Remove and return the lowest priority task. Raise KeyError if empty.'\n    while pq:\n        priority, count, task = heapq.heappop(pq)\n        if task is not REMOVED:\n            del entry_finder[task]\n            return task\n    raise KeyError('pop from an empty priority queue')\nmemory = dict()\ndef clear_cache():\n    nonlocal memory\n    memory = dict()\ndef cached_fn(fn, *args):\n    nonlocal memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr (n,r):\n    return math.factorial(n)/(math.factorial(n-r)*math.factorial(r))\ndef binary_serach(i,li):\n    #print(\"Search for \",i)\n    fn = lambda x: li[x]-x//i\n    x = -1\n    b = len(li)\n    while b>=1:\n        #print(b,x)\n        while b+x<len(li) and fn(b+x)>0: #Change this condition 2 to whatever you like\n            x+=b\n        b=b//2\n    return x\n\n# -------------------------------------------------------------- MAIN PROGRAM\nTestCases = False\ntestingMode = False\nfac_warmup_size = 10**5+100\noptimiseForReccursion = False #Can not be used clubbed with TestCases # WHen using recursive functions, use Python 3\nfrom math import factorial\n\ndef main():\n    n = get_int()\n    a = get_list()\n    b = get_list()\n    u = [0,0]\n    l = [0,0]\n    for i in range(n):\n        u.append(max(l[-1],l[-2],u[-2])+b[i])\n        l.append(max(u[-2],u[-3],l[-2])+a[i])\n    print(max(u[-1],l[-1]))\n\n# --------------------------------------------------------------------- END=\n\n\nif TestCases: \n    for i in range(get_int()): \n        cProfile.run('main()') if testingMode else main() \nelse: (cProfile.run('main()') if testingMode else main()) if not optimiseForReccursion else threading.Thread(target=main).start()", "n = int( input() )\nl = [ list( map( int, input().split() )), list( map( int, input().split())) ]\nm = [ 0, 0 ]\nfor i in range(n-1, -1, -1):\n    mm = [ 0, 0 ]\n    for j in range(2):\n        l[ j ][ i ] += m[ j^1 ]\n        mm[ j ] = max( m[ j ], l[ j ][ i ] )\n    m = mm\n\nprint( max( m ) )\n", "n = int(input())\nl1 = [0, 0] + list(map(int, input().split()))\nl2 = [0, 0] + list(map(int, input().split()))\nans1 = [0] * (n + 3)\nans2 = [0] * (n + 3)\nfor i in range(2, n + 2):\n    ans1[i] = max(ans2[i - 1], ans2[i - 2]) + l1[i]\n    ans2[i] = max(ans1[i - 1], ans1[i - 2]) + l2[i]\nprint(max(ans1[n + 1], ans2[n + 1]))", "n = int(input())\nfirst = list(map(int, input().split()))\nsecond = list(map(int, input().split()))\n\ndp_first = [0] * n\ndp_second = [0] * n\n\ndp_first[0] = first[0]\ndp_second[0] = second[0]\n\nfor i in range(1, n):\n    dp_first[i] = max(dp_first[i - 1], first[i] + dp_second[i - 1], first[i] + dp_second[i - 2] if i >= 2 else 0)\n    dp_second[i] = max(dp_second[i - 1], second[i] + dp_first[i - 1], second[i] + dp_first[i - 2] if i >= 2 else 0)\n\nprint(max(dp_first[-1], dp_second[-1]))"]